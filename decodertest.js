var fs = require('fs');

jcodec = {};
jslang = {};
jsutil = {};
jslang.reflect = {};

/*
 *  Copyright 2011 Alexandru Craciun, Eyal Kaspi
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
/**** Functionality in Java, but not in JS ********
 * methods added to JS prototypes
 */

var stjs={};

stjs.NOT_IMPLEMENTED = function(){
	throw "This method is not implemented in Javascript.";
};

stjs.JavalikeEquals = function(value){
	if (value == null)
		return false;
	if (value.valueOf)
		return this.valueOf() === value.valueOf();
	return this === value;
};

stjs.JavalikeGetClass = function(){
	return this.constructor;
};

/* String */
if (!String.prototype.equals) {
	String.prototype.equals=stjs.JavalikeEquals;
}
if (!String.prototype.getBytes) {
	String.prototype.getBytes=stjs.NOT_IMPLEMENTED;
}
if (!String.prototype.getChars) {
	String.prototype.getChars=stjs.NOT_IMPLEMENTED;
}
if (!String.prototype.contentEquals){
	String.prototype.contentEquals=stjs.NOT_IMPLEMENTED;
}
if (!String.prototype.startsWith) {
	String.prototype.startsWith=function(start, from){
		var f = from != null ? from : 0;
		return this.substring(f, f + start.length) == start;
	}
}
if (!String.prototype.endsWith) {
	String.prototype.endsWith=function(end){
		if (end == null)
			return false;
		if (this.length < end.length)
			return false;
		return this.substring(this.length - end.length, this.length) == end;
	}
}
if (!String.prototype.trim) {
	stjs.trimLeftRegExp = /^\s+/;
	stjs.trimRightRegExp = /\s+$/;
	String.prototype.trim = function() {
		return this.replace(stjs.trimLeftRegExp, "").replace(stjs.trimRightRegExp, "");
	}
}
if (!String.prototype.matches){
	String.prototype.matches=function(regexp){
		return this.match("^" + regexp + "$") != null;
	}
}
if (!String.prototype.compareTo){
	String.prototype.compareTo=function(other){
		if (other == null)
			return 1;
		if (this < other)
			return -1;
		if (this == other)
			return 0;
		return 1;
	}
}

if (!String.prototype.compareToIgnoreCase){
	String.prototype.compareToIgnoreCase=function(other){
		if (other == null)
			return 1;
		return this.toLowerCase().compareTo(other.toLowerCase());
	}
}

if (!String.prototype.equalsIgnoreCase){
	String.prototype.equalsIgnoreCase=function(other){
		if (other == null)
			return false;
		return this.toLowerCase() === other.toLowerCase();
	}
}

if (!String.prototype.codePointAt){
	String.prototype.codePointAt=String.prototype.charCodeAt;
}

if (!String.prototype.codePointBefore){
	String.prototype.codePointBefore=stjs.NOT_IMPLEMENTED;
}
if (!String.prototype.codePointCount){
	String.prototype.codePointCount=stjs.NOT_IMPLEMENTED;
}

if (!String.prototype.replaceAll){
	String.prototype.replaceAll=function(regexp, replace){
		return this.replace(new RegExp(regexp, "g"), replace);
	}
}

if (!String.prototype.replaceFirst){
	String.prototype.replaceFirst=function(regexp, replace){
		return this.replace(new RegExp(regexp), replace);
	}
}

if (!String.prototype.regionMatches){
	String.prototype.regionMatches=function(ignoreCase, toffset, other, ooffset, len){
		if (arguments.length == 4){
			len=arguments[3];
			ooffset=arguments[2];
			other=arguments[1];
			toffset=arguments[0];
			ignoreCase=false;
		}
		if (toffset < 0 || ooffset < 0 || other == null || toffset + len > this.length || ooffset + len > other.length)
			return false;
		var s1 = this.substring(toffset, toffset + len);
		var s2 = other.substring(ooffset, ooffset + len);
		return ignoreCase ? s1.equalsIgnoreCase(s2) : s1 === s2;
	}
}

if(!String.prototype.contains){
	String.prototype.contains=function(it){
		return this.indexOf(it)>=0;
	};
}

if(!String.prototype.getClass){
	String.prototype.getClass=stjs.JavalikeGetClass;
}


//force valueof to match the Java's behavior
String.valueOf=function(value){
	return new String(value);
};

/* Number */
var Byte=Number;
var Double=Number;
var Float=Number;
var Integer=Number;
var Long=Number;
var Short=Number;

/* type conversion - approximative as Javascript only has integers and doubles */
if (!Number.prototype.intValue) {
	Number.prototype.intValue=function(){
		return parseInt(this);
	}
}
if (!Number.prototype.shortValue) {
	Number.prototype.shortValue=function(){
		return parseInt(this);
	}
}
if (!Number.prototype.longValue) {
	Number.prototype.longValue=function(){
		return parseInt(this);
	}
}
if (!Number.prototype.byteValue) {
	Number.prototype.byteValue=function(){
		return parseInt(this);
	}
}

if (!Number.prototype.floatValue) {
	Number.prototype.floatValue=function(){
		return parseFloat(this);
	}
}

if (!Number.prototype.doubleValue) {
	Number.prototype.doubleValue=function(){
		return parseFloat(this);
	}
}

if (!Number.parseInt) {
	Number.parseInt = parseInt;
}
if (!Number.parseShort) {
	Number.parseShort = parseInt;
}
if (!Number.parseLong) {
	Number.parseLong = parseInt;
}
if (!Number.parseByte) {
	Number.parseByte = parseInt;
}

if (!Number.parseDouble) {
	Number.parseDouble = parseFloat;
}

if (!Number.parseFloat) {
	Number.parseFloat = parseFloat;
}

if (!Number.isNaN) {
	Number.isNaN = isNaN;
}

if (!Number.prototype.isNaN) {
	Number.prototype.isNaN = function() {
		return isNaN(this);
	}
}
if (!Number.prototype.equals) {
	Number.prototype.equals=stjs.JavalikeEquals;
}
if(!Number.prototype.getClass){
	Number.prototype.getClass=stjs.JavalikeGetClass;
}

//force valueof to match approximately the Java's behavior (for Integer.valueOf it returns in fact a double)
Number.valueOf=function(value){
	return new Number(value).valueOf();
}

/* Boolean */
if (!Boolean.prototype.equals) {
	Boolean.prototype.equals=stjs.JavalikeEquals;
}
if(!Boolean.prototype.getClass){
	Boolean.prototype.getClass=stjs.JavalikeGetClass;
}

//force valueof to match the Java's behavior
Boolean.valueOf=function(value){
	return new Boolean(value).valueOf();
}



/************* STJS helper functions ***************/
stjs.global=this;
stjs.skipCopy = {"prototype":true, "constructor": true, "$typeDescription":true, "$inherit" : true};

stjs.ns=function(path){
	var p = path.split(".");
	var obj = stjs.global;
	for(var i = 0; i < p.length; ++i){
		var part = p[i];
		obj = obj[part] = obj[part] || {};
	}
	return obj;
};

stjs.copyProps=function(from, to){
	for(var key in from){
		if (!stjs.skipCopy[key])
			to[key]	= from[key];
	}
	return to;
};

stjs.copyInexistentProps=function(from, to){
	for(var key in from){
		if (!stjs.skipCopy[key] && !to[key])
			to[key]	= from[key];
	}
	return to;
};

stjs.extend=function(_constructor, _super, _implements, _initializer, _typeDescription, _annotations){
	if(typeof(_typeDescription) !== "object"){
		// stjs 1.3+ always passes an non-null object to _typeDescription => The code calling stjs.extend
		// was generated with version 1.2 or earlier, so let's call the 1.2 version of stjs.extend
		return stjs.extend12.apply(this, arguments);
	}

	_constructor.$inherit=[];

	if(_super != null){
		// I is used as a no-op constructor that has the same prototype as _super
		// we do this because we cannot predict the result of calling new _super()
		// without parameters (it might throw an exception).
		// Basically, the following 3 lines are a safe equivalent for
		// _constructor.prototype = new _super();
		var I = function(){};
		I.prototype	= _super.prototype;
		_constructor.prototype	= new I();

		// copy static properties for super
		// assign every method from proto instance
		stjs.copyProps(_super, _constructor);
		stjs.copyProps(_super.$typeDescription, _typeDescription);
		stjs.copyProps(_super.$annotations, _annotations);

		//add the super class to inherit array
		_constructor.$inherit.push(_super);
	}

	// copy static properties and default methods from interfaces
	for(var a = 0; a < _implements.length; ++a){
		if (!_implements[a]) continue;
		stjs.copyProps(_implements[a], _constructor);
		stjs.copyInexistentProps(_implements[a].prototype, _constructor.prototype);
		_constructor.$inherit.push(_implements[a]);
	}

	// remember the correct constructor
	_constructor.prototype.constructor	= _constructor;

	// run the initializer to assign all static and instance variables/functions
	if(_initializer != null){
		_initializer(_constructor, _constructor.prototype);
	}

	_constructor.$typeDescription = _typeDescription;
	_constructor.$annotations = _annotations;

	// add the default equals method if it is not present yet, and we don't have a superclass
	if(_super == null){
		if(!_constructor.prototype.equals) {
			_constructor.prototype.equals = stjs.JavalikeEquals;
		}
		if(!_constructor.prototype.getClass) {
			_constructor.prototype.getClass = stjs.JavalikeGetClass;
		}
	}

	// build package and assign
	return	_constructor;
};

/**
 * 1.2 and earlier version of stjs.extend. Included for backwards compatibility
 */
stjs.extend12=function( _constructor,  _super, _implements){
	var I = function(){};
	I.prototype	= _super.prototype;
	_constructor.prototype	= new I();

	//copy static properties for super and interfaces
	// assign every method from proto instance
	for(var a = 1; a < arguments.length; ++a){
		stjs.copyProps(arguments[a], _constructor);
	}
	// remember the correct constructor
	_constructor.prototype.constructor	= _constructor;

	// add the default equals method if we don't have a superclass. Code generated with version 1.2 will
	// override this method is equals() is present in the original java code.
	// this was not part of the original 1.2 version of extends, however forward compatibility
	// with 1.3 requires it
	if(_super == null){
		_constructor.prototype.equals = stjs.JavalikeEquals;
		_constructor.prototype.getClass = stjs.JavalikeGetClass;
	}

	// build package and assign
	return	_constructor;
};

/**
 * return type's annotations
 */
stjs.getAnnotations = function(clz) {
	return clz.$annotations;
};

stjs.getTypeAnnotation = function(clz, annType) {
	var ann = clz.$annotations._;
	return ann ? ann[annType]: null;
};

stjs.getMemberAnnotation = function(clz, memberName, annType) {
	var ann = clz.$annotations.memberName;
	return ann ? ann[annType]: null;
};

stjs.getParameterAnnotation = function(clz, methodName, idx, annType) {
	var ann = clz.$annotations[methodName + "$" + idx];
	return ann ? ann[annType]: null;
};

/**
 * checks if the child is an instanceof parent. it checks recursively if "parent" is the child itself or it's found somewhere in the $inherit array
 */
stjs.isInstanceOf=function(child, parent){
	if (child == null)
		return false;
	if (child === parent)
		return true;
	if (!child.$inherit)
		return false;
	for(var i = 0; i < child.$inherit.length; ++i){
		if (stjs.isInstanceOf(child.$inherit[i], parent)) {
			return true;
		}
	}
	return false;
}

stjs.enumEntry=function(idx, name){
	this._name = name;
	this._ordinal = idx;
};

stjs.enumEntry.prototype.name=function(){
	return this._name;
};
stjs.enumEntry.prototype.ordinal=function(){
	return this._ordinal;
};
stjs.enumEntry.prototype.toString=function(){
	return this._name;
};
stjs.enumEntry.prototype.equals=stjs.JavalikeEquals;

stjs.enumeration=function(){
	var i;
	var e = {};
	e._values = [];
	for(i = 0; i < arguments.length; ++i){
		e[arguments[i]] = new stjs.enumEntry(i, arguments[i]);
		e._values[i] = e[arguments[i]];
	}
	e.values = function(){return this._values;};
	e.valueOf=function(label){
		return this[label];
	}
	return e;
};


/**
 * if true the execution of generated main methods is disabled.
 * this is useful when executing unit tests, to no have the main methods executing before the tests
 */
stjs.mainCallDisabled = false;

stjs.exception=function(err){
	return err;
};

stjs.isEnum=function(obj){
	return obj != null && obj.constructor == stjs.enumEntry;
};

if (typeof Math.trunc === "function") {
	stjs.trunc = Math.trunc;
} else {
	stjs.trunc=function(n) {
		if (n == null)
			return null;
		return n >= 0 ? Math.floor(n) : Math.ceil(n);
	}
}

stjs.converters = {
	Date : function(s, type) {
		var a = /^(\d{4})-(\d{2})-(\d{2}) (\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)$/
				.exec(s);
		if (a) {
			return new Date(+a[1], +a[2] - 1, +a[3], +a[4], +a[5], +a[6]);
		}
		return null;
	},

	Enum : function(s, type){
		return eval(type.arguments[0])[s];
	}
};


stjs.serializers = {
	Date : function(d, type) {
		function pad(n){
			return n < 10 ? "0" + n : "" + n;
		}
		if (d) {
			return "" + d.getFullYear() + "-" + pad(d.getMonth()+1) + "-" + pad(d.getDate()) + " " + pad(d.getHours()) + ":" + pad(d.getMinutes()) + ":" + pad(d.getSeconds());
		}
		return null;
	},

	Enum : function(e, type){
		return e != null ? e.toString() : null;
	}
};

/**
 * Used to be able to send method references and lambdas that capture 'this' as callbacks.
 * This method has a bunch of different usage patterns:
 *
 * bind(instance, "methodName"):
 *     Used when translating a capturing method reference (eg: instance::methodName), or when translating
 *
 * bind(this, function):
 *     Used when translating a lambda that uses 'this' explicitly or implicitly (eg: () -> this.doSomething(3))
 *
 * bind(this, function, specialTHISparamPosition)
 *     Used when translating a lambda that uses the special all-caps 'THIS' parameter
 *
 * bind("methodName")
 *     Used when translating a non-static method reference (eg: TypeName::methodName, where methodName is non-static)
 */
stjs.bind=function(obj, method, thisParamPos) {
	var useFirstParamAsContext = false;
	if(method == null) {
		// the bind("methodName") is the only usage where the method argument can be null
		method = obj;
		obj = null;
		useFirstParamAsContext = true;
	}
	var addThisToParameters = thisParamPos != null;

	var f = function(){
		var args = arguments;
		if (addThisToParameters) {
			Array.prototype.splice.call(args, thisParamPos, 0, this);
		}
		if(useFirstParamAsContext){
			obj = Array.prototype.shift.call(args);
		}

		if (typeof method === "string") {
			return obj[method].apply(obj, args);

		} else {
			return method.apply(obj, args);
		}
	};
	return f;
};


/** *********** global ************** */
function exception(err){
	return err;
}

function isEnum(obj){
	return obj != null && obj.constructor == stjs.enumEntry;
}

/******* parsing *************/

/**
 * parse a json string using the type definition to build a typed object hierarchy
 */
stjs.parseJSON = (function () {
	  var number
	      = '(?:-?\\b(?:0|[1-9][0-9]*)(?:\\.[0-9]+)?(?:[eE][+-]?[0-9]+)?\\b)';
	  var oneChar = '(?:[^\\0-\\x08\\x0a-\\x1f\"\\\\]'
	      + '|\\\\(?:[\"/\\\\bfnrt]|u[0-9A-Fa-f]{4}))';
	  var string = '(?:\"' + oneChar + '*\")';

	  // Will match a value in a well-formed JSON file.
	  // If the input is not well-formed, may match strangely, but not in an unsafe
	  // way.
	  // Since this only matches value tokens, it does not match whitespace, colons,
	  // or commas.
	  var jsonToken = new RegExp(
	      '(?:false|true|null|[\\{\\}\\[\\]]'
	      + '|' + number
	      + '|' + string
	      + ')', 'g');

	  // Matches escape sequences in a string literal
	  var escapeSequence = new RegExp('\\\\(?:([^u])|u(.{4}))', 'g');

	  // Decodes escape sequences in object literals
	  var escapes = {
	    '"': '"',
	    '/': '/',
	    '\\': '\\',
	    'b': '\b',
	    'f': '\f',
	    'n': '\n',
	    'r': '\r',
	    't': '\t'
	  };
	  function unescapeOne(_, ch, hex) {
	    return ch ? escapes[ch] : String.fromCharCode(parseInt(hex, 16));
	  }

	  var constructors = {};

	  function constr(name, param){
		  var c = constructors[name];
		  if (!c)
			  constructors[name] = c = eval(name);
		  return new c(param);
	  }

	  function convert(type, json){
		  if (!type)
			  return json;
		  var cv = stjs.converters[type.name || type];
		  if (cv)
			  return cv(json, type);
		  //hopefully the type has a string constructor
		 return constr(type, json);
	  }

	  function builder(type){
		  if (!type)
			  return {};
			if (typeof type == "function")
				return new type();
			if (type.name) {
				if (type.name == "Map")
					return {};
				if (type.name == "Array")
					return [];
				return constr(type.name);
			}
			return constr(type);
	  }

	  // A non-falsy value that coerces to the empty string when used as a key.
	  var EMPTY_STRING = new String('');
	  var SLASH = '\\';

	  // Constructor to use based on an open token.
	  var firstTokenCtors = { '{': Object, '[': Array };

	  var hop = Object.hasOwnProperty;

	  function nextMatch(str){
		  var m = jsonToken.exec(str);
		  return m != null ? m[0] : null;
	  }
	  return function (json, type) {
	    // Split into tokens
	    // Construct the object to return
	    var result;
	    var tok = nextMatch(json);
	    var topLevelPrimitive = false;
	    if ('{' === tok) {
	      result = builder(type, null);
	    } else if ('[' === tok) {
	      result = [];
	    } else {
	      // The RFC only allows arrays or objects at the top level, but the JSON.parse
	      // defined by the EcmaScript 5 draft does allow strings, booleans, numbers, and null
	      // at the top level.
	      result = [];
	      topLevelPrimitive = true;
	    }

	    // If undefined, the key in an object key/value record to use for the next
	    // value parsed.
	    var key;
	    // Loop over remaining tokens maintaining a stack of uncompleted objects and
	    // arrays.
	    var stack = [result];
	    var stack2 = [type];
	    for (tok = nextMatch(json); tok != null; tok = nextMatch(json)) {

	      var cont;
	      switch (tok.charCodeAt(0)) {
	        default:  // sign or digit
	          cont = stack[0];
	          cont[key || cont.length] = +(tok);
	          key = void 0;
	          break;
	        case 0x22:  // '"'
	          tok = tok.substring(1, tok.length - 1);
	          if (tok.indexOf(SLASH) !== -1) {
	            tok = tok.replace(escapeSequence, unescapeOne);
	          }
	          cont = stack[0];
	          if (!key) {
	            if (cont instanceof Array) {
	              key = cont.length;
	            } else {
	              key = tok || EMPTY_STRING;  // Use as key for next value seen.
	              stack2[0] = cont.constructor.$typeDescription ? cont.constructor.$typeDescription[key] : stack2[1].arguments[1];
	              break;
	            }
	          }
	          cont[key] = convert(stack2[0],tok);
	          key = void 0;
	          break;
	        case 0x5b:  // '['
	          cont = stack[0];
	          stack.unshift(cont[key || cont.length] = []);
	          stack2.unshift(stack2[0].arguments[0]);
	          //put the element type desc
	          key = void 0;
	          break;
	        case 0x5d:  // ']'
	          stack.shift();
	          stack2.shift();
	          break;
	        case 0x66:  // 'f'
	          cont = stack[0];
	          cont[key || cont.length] = false;
	          key = void 0;
	          break;
	        case 0x6e:  // 'n'
	          cont = stack[0];
	          cont[key || cont.length] = null;
	          key = void 0;
	          break;
	        case 0x74:  // 't'
	          cont = stack[0];
	          cont[key || cont.length] = true;
	          key = void 0;
	          break;
	        case 0x7b:  // '{'
	          cont = stack[0];
	          stack.unshift(cont[key || cont.length] = builder(stack2[0]));
	          stack2.unshift(null);
	          key = void 0;
	          break;
	        case 0x7d:  // '}'
	          stack.shift();
	          stack2.shift();
	          break;
	      }
	    }
	    // Fail if we've got an uncompleted object.
	    if (topLevelPrimitive) {
	      if (stack.length !== 1) { throw new Error(); }
	      result = result[0];
	    } else {
	      if (stack.length) { throw new Error(); }
	    }

	    return result;
	  };
})();




stjs.isArray=function( obj ) {
    return stjs.toString.call(obj) === "[object Array]";
};

/**
 * cls can by the type of the return.
 * If it's an array it can be either the type of an element or the type definition of the field.
 * TODO - for other collections and classes is not done yet
 */
stjs.typefy=function(obj, cls){
	if (stjs.isArray(obj)){
		var result = [];
		for(var idx = 0; idx < obj.length; idx++){
			result.push(stjs.typefy(obj[idx], elementType(cls)));
		}
		return result;
	}
	 var constructors = {};
	 function constr(name, param){
		  var c = constructors[name];
		  if (!c)
			  constructors[name] = c = eval(name);
		  return new c(param);
	  }

	 function elementType(type){
		 if (typeof type == "function")
			 return type;
		 if (type.arguments) {
			 return eval(type.arguments[0]);
		 }
		 if (typeof type == "string")
			 return eval(type);
		 return Object;
	  }


	function convert(type, json){
		  if (!type)
			  return json;
		  var cv = stjs.converters[type.name || type];
		  if (cv)
			  return cv(json, type);
		  //hopefully the type has a string constructor
		 return constr(type, json);
	  }

	 function builder(type){
		  if (!type)
			  return {};
			if (typeof type == "function")
				return new type();
			if (type.name) {
				if (type.name == "Map")
					return {};
				if (type.name == "Array")
					return [];
				return constr(type.name);
			}
			return constr(type);
	  }

	  if (obj == null)
		  return null;

	  var ret = new cls();
	  for(var key in obj){
		  var prop = obj[key];
		  if (prop == null)
			  continue;
		  var td = cls.$typeDescription[key];
		  if (!td) {
			  ret[key] = prop;
			  continue;
		  }
		  if (typeof prop == "string")
			ret[key] = convert(td, prop);
		  else if (typeof prop == "object") {
				if (typeof td == "string") {
					td = eval(td);
		  		}
				ret[key] = stjs.typefy(prop, td);
			}
	  }
	  return ret;
};
stjs.hydrate=stjs.typefy

stjs.stringify=function(obj, cls){
	 if (obj == null)
		  return null;

	 var ret = {};
	  for(var key in obj){
		  var td = cls.$typeDescription[key];
		  var prop = obj[key];
		  var ser = td != null ? stjs.serializers[td.name || td] : null;

		  if (typeof prop == "function")
			  continue;

		  if (!td || !ser) {
			  ret[key] = prop;
			  continue;
		  }
		  if (typeof prop != "string")
			  if (ser)
				  ret[key] = ser(prop, td);
			  else
				  ret[key] = stjs.typefy(prop, td);
	  }
	  return ret;
};
/************* STJS asserts ***************/
stjs.assertHandler = function(position, code, msg) {
	throw msg + " at " + position;
};

stjs.STJSAssert = {};

stjs.STJSAssert.setAssertHandler = function(a) {
	stjs.assertHandler = a;
}

stjs.STJSAssert.assertArgEquals = function(position, code, expectedValue, testValue) {
	if (expectedValue != testValue && stjs.assertHandler)
		stjs.assertHandler(position, code, "Wrong argument. Expected: " + expectedValue + ", got:" + testValue);
}

stjs.STJSAssert.assertArgNotNull = function(position, code, testValue) {
	if (testValue == null && stjs.assertHandler)
		stjs.assertHandler(position, code, "Wrong argument. Null value");
}

stjs.STJSAssert.assertArgTrue = function(position, code, condition) {
	if (!condition && stjs.assertHandler)
		stjs.assertHandler(position, code, "Wrong argument. Condition is false");
}

stjs.STJSAssert.assertStateEquals = function(position, code, expectedValue, testValue) {
	if (expectedValue != testValue && stjs.assertHandler)
		stjs.assertHandler(position, code, "Wrong state. Expected: " + expectedValue + ", got:" + testValue);
}

stjs.STJSAssert.assertStateNotNull = function(position, code, testValue) {
	if (testValue == null && stjs.assertHandler)
		stjs.assertHandler(position, code, "Wrong state. Null value");
}

stjs.STJSAssert.assertStateTrue = function(position, code, condition) {
	if (!condition && stjs.assertHandler)
		stjs.assertHandler(position, code, "Wrong state. Condition is false");
}
/** exception **/
var Throwable = function(message, cause){
	Error.call(this);
	if(typeof Error.captureStackTrace === 'function'){
		// nice way to capture the stack trace for chrome
		Error.captureStackTrace(this, arguments.callee);
	} else {
		// alternate way to capture the stack trace for other browsers
		try{
			throw new Error();
		}catch(e){
			this.stack = e.stack;
		}
	}
	if (typeof message === "string"){
		this.detailMessage  = message;
		this.message = message;
		this.cause = cause;
	} else {
		this.cause = message;
	}
};
stjs.extend(Throwable, Error, [], function(constructor, prototype){
	prototype.detailMessage = null;
	prototype.cause = null;
	prototype.getMessage = function() {
        return this.detailMessage;
    };

	prototype.getLocalizedMessage = function() {
        return this.getMessage();
    };

	prototype.getCause = function() {
        return (this.cause==this ? null : this.cause);
    };

	prototype.toString = function() {
	        var s = "Exception";//TODO should get the exception's type name here
	        var message = this.getLocalizedMessage();
	        return (message != null) ? (s + ": " + message) : s;
	 };

	 prototype.getStackTrace = function() {
		 return this.stack;
	 };

	 prototype.printStackTrace = function(){
		 console.error(this.getStackTrace());
	 };
}, {});

var Exception = function(message, cause){
	Throwable.call(this, message, cause);
};
stjs.extend(Exception, Throwable, [], function(constructor, prototype){
}, {});

var RuntimeException = function(message, cause){
	Exception.call(this, message, cause);
};
stjs.extend(RuntimeException, Exception, [], function(constructor, prototype){
}, {});

var Iterator = function() {};
Iterator = stjs.extend(Iterator, null, [], function(constructor, prototype) {
    prototype.hasNext = function() {};
    prototype.next = function() {};
    prototype.remove = function() {};
}, {}, {});

var Iterable = function() {};
Iterable = stjs.extend(Iterable, null, [], function(constructor, prototype) {
    prototype.iterator = function() {};
}, {}, {});

/** stjs field manipulation */
stjs.setField=function(obj, field, value, returnOldValue){
	if (stjs.setFieldHandler)
		return stjs.setFieldHandler(obj, field, value, returnOldValue);
	var toReturn = returnOldValue ? obj[field] : value;
	obj[field] = value;
	return toReturn;
};

stjs.getField=function(obj, field){
	if (stjs.getFieldHandler)
		return stjs.getFieldHandler(obj, field);
	return obj[field];
};


Boolean.parseBoolean = function(s) {
    return ((s != null) && s.equalsIgnoreCase("true"));
}
Integer.toHexString = function(i) {
    return (i).toString(16);
}
Character = Number;

String.format = function(_args) {
	var args = Array.prototype.slice.call(arguments);
	return args.join(", ")
}

var FilenameFilter = function() {};
FilenameFilter = stjs.extend(FilenameFilter, null, [], function(constructor, prototype) {
    prototype.accept = function(dir, name) {};
}, {}, {});
var IllegalArgumentException = function(msg) {
    RuntimeException.call(this, msg);
};
IllegalArgumentException = stjs.extend(IllegalArgumentException, RuntimeException, [], null, {}, {});
var Properties = function() {};
Properties = stjs.extend(Properties, null, [], function(constructor, prototype) {
    prototype.load = function(reader) {
         throw new RuntimeException("TODO");
    };
    prototype.getProperty = function(string) {
         throw new RuntimeException("TODO");
    };
}, {}, {});
var Closeable = function() {};
Closeable = stjs.extend(Closeable, null, [], function(constructor, prototype) {
    prototype.close = function() {};
}, {}, {});
var ByteOrder = function(name) {
    this.name = name;
};
ByteOrder = stjs.extend(ByteOrder, null, [], function(constructor, prototype) {
    /**
     *  Constant denoting big-endian byte order. In this order, the bytes of a multibyte value are ordered from most
     *  significant to least significant.
     */
    constructor.BIG_ENDIAN = new ByteOrder("BIG_ENDIAN");
    /**
     *  Constant denoting little-endian byte order. In this order, the bytes of a multibyte value are ordered from least
     *  significant to most significant.
     */
    constructor.LITTLE_ENDIAN = new ByteOrder("LITTLE_ENDIAN");
    prototype.name = null;
}, {BIG_ENDIAN: "ByteOrder", LITTLE_ENDIAN: "ByteOrder"}, {});
var Collection = function() {};
Collection = stjs.extend(Collection, null, [Iterable], function(constructor, prototype) {
    prototype.size = function() {};
    prototype.isEmpty = function() {};
    prototype.contains = function(o) {};
    prototype.iterator = function() {};
    prototype.toArray = function(a) {};
    prototype.add = function(_arguments) {};
    prototype.remove = function(_arguments) {};
    prototype.containsAll = function(c) {};
    prototype.addAll = function(other) {};
    prototype.removeAll = function(c) {};
    prototype.retainAll = function(c) {};
    prototype.clear = function() {};
}, {}, {});
var DataBufferByte = function() {};
DataBufferByte = stjs.extend(DataBufferByte, null, [], function(constructor, prototype) {
    prototype.getData = function() {
         throw new RuntimeException("TODO DataBufferByte.getData");
    };
}, {}, {});
var Bits = function() {};
Bits = stjs.extend(Bits, null, [], function(constructor, prototype) {
    constructor.long7 = function(x) {
        return ((stjs.trunc(x / 4294967296) >> 24) << 24 >> 24);
    };
    constructor.long6 = function(x) {
        return ((stjs.trunc(x / 4294967296) >> 16) << 24 >> 24);
    };
    constructor.long5 = function(x) {
        return ((stjs.trunc(x / 4294967296) >> 8) << 24 >> 24);
    };
    constructor.long4 = function(x) {
        return ((stjs.trunc(x / 4294967296) >> 0) << 24 >> 24);
    };
    constructor.long3 = function(x) {
        return ((x >> 24) << 24 >> 24);
    };
    constructor.long2 = function(x) {
        return ((x >> 16) << 24 >> 24);
    };
    constructor.long1 = function(x) {
        return ((x >> 8) << 24 >> 24);
    };
    constructor.long0 = function(x) {
        return ((x) << 24 >> 24);
    };
    constructor.int3 = function(x) {
        return ((x >> 24) << 24 >> 24);
    };
    constructor.int2 = function(x) {
        return ((x >> 16) << 24 >> 24);
    };
    constructor.int1 = function(x) {
        return ((x >> 8) << 24 >> 24);
    };
    constructor.int0 = function(x) {
        return ((x) << 24 >> 24);
    };
    constructor.putLongB = function(bb, bi, x) {
        bb._put(bi, Bits.long7(x));
        bb._put(bi + 1, Bits.long6(x));
        bb._put(bi + 2, Bits.long5(x));
        bb._put(bi + 3, Bits.long4(x));
        bb._put(bi + 4, Bits.long3(x));
        bb._put(bi + 5, Bits.long2(x));
        bb._put(bi + 6, Bits.long1(x));
        bb._put(bi + 7, Bits.long0(x));
    };
    constructor.putLongL = function(bb, bi, x) {
        bb._put(bi + 7, Bits.long7(x));
        bb._put(bi + 6, Bits.long6(x));
        bb._put(bi + 5, Bits.long5(x));
        bb._put(bi + 4, Bits.long4(x));
        bb._put(bi + 3, Bits.long3(x));
        bb._put(bi + 2, Bits.long2(x));
        bb._put(bi + 1, Bits.long1(x));
        bb._put(bi, Bits.long0(x));
    };
    constructor.putIntB = function(bb, bi, x) {
        bb._put(bi, Bits.int3(x));
        bb._put(bi + 1, Bits.int2(x));
        bb._put(bi + 2, Bits.int1(x));
        bb._put(bi + 3, Bits.int0(x));
    };
    constructor.putIntL = function(bb, bi, x) {
        bb._put(bi + 3, Bits.int3(x));
        bb._put(bi + 2, Bits.int2(x));
        bb._put(bi + 1, Bits.int1(x));
        bb._put(bi, Bits.int0(x));
    };
    constructor.putInt = function(bb, bi, x, bigEndian) {
        if (bigEndian) 
            Bits.putIntB(bb, bi, x);
         else 
            Bits.putIntL(bb, bi, x);
    };
    constructor.getIntB = function(bb, bi) {
        return Bits.makeInt(bb._get(bi), bb._get(bi + 1), bb._get(bi + 2), bb._get(bi + 3));
    };
    constructor.getIntL = function(bb, bi) {
        return Bits.makeInt(bb._get(bi + 3), bb._get(bi + 2), bb._get(bi + 1), bb._get(bi));
    };
    constructor.makeInt = function(b3, b2, b1, b0) {
        return (((b3) << 24) | ((b2 & 255) << 16) | ((b1 & 255) << 8) | ((b0 & 255)));
    };
    constructor.getInt = function(bb, bi, bigEndian) {
        return bigEndian ? Bits.getIntB(bb, bi) : Bits.getIntL(bb, bi);
    };
    constructor.makeShort = function(b1, b0) {
        return ((((b1 << 8) | (b0 & 255))) << 16 >> 16);
    };
    constructor.getShortL = function(bb, bi) {
        return Bits.makeShort(bb._get(bi + 1), bb._get(bi));
    };
    constructor.getShortB = function(bb, bi) {
        return Bits.makeShort(bb._get(bi), bb._get(bi + 1));
    };
    constructor.getShort = function(bb, bi, bigEndian) {
        return bigEndian ? Bits.getShortB(bb, bi) : Bits.getShortL(bb, bi);
    };
    constructor.short1 = function(x) {
        return ((x >> 8) << 24 >> 24);
    };
    constructor.short0 = function(x) {
        return ((x) << 24 >> 24);
    };
    constructor.putShortB = function(bb, bi, x) {
        bb._put(bi, Bits.short1(x));
        bb._put(bi + 1, Bits.short0(x));
    };
    constructor.putShortL = function(bb, bi, x) {
        bb._put(bi, Bits.short0(x));
        bb._put(bi + 1, Bits.short1(x));
    };
    constructor.putShort = function(bb, bi, x, bigEndian) {
        if (bigEndian) 
            Bits.putShortB(bb, bi, x);
         else 
            Bits.putShortL(bb, bi, x);
    };
    constructor.putLong = function(bb, bi, x, bigEndian) {
        if (bigEndian) 
            Bits.putLongB(bb, bi, x);
         else 
            Bits.putLongL(bb, bi, x);
    };
}, {}, {});
var IndexOutOfBoundsException = function(_arguments) {
    RuntimeException.call(this, "" + arguments[0]);
};
IndexOutOfBoundsException = stjs.extend(IndexOutOfBoundsException, RuntimeException, [], null, {}, {});
var BufferOverflowException = function() {
    RuntimeException.call(this);
};
BufferOverflowException = stjs.extend(BufferOverflowException, RuntimeException, [], null, {}, {});
var JSArrays = function() {};
JSArrays = stjs.extend(JSArrays, null, [], function(constructor, prototype) {
    /**
     *  Returns <tt>true</tt> if the two specified arrays of Objects are
     *  <i>equal</i> to one another.  The two arrays are considered equal if
     *  both arrays contain the same number of elements, and all corresponding
     *  pairs of elements in the two arrays are equal.  Two objects <tt>e1</tt>
     *  and <tt>e2</tt> are considered <i>equal</i> if <tt>(e1==null ? e2==null
     *  : e1.equals(e2))</tt>.  In other words, the two arrays are equal if
     *  they contain the same elements in the same order.  Also, two array
     *  references are considered equal if both are <tt>null</tt>.<p>
     * 
     *  @param a one array to be tested for equality
     *  @param a2 the other array to be tested for equality
     *  @return <tt>true</tt> if the two arrays are equal
     */
    constructor.equalsObjs = function(a, a2) {
        if (a == a2) 
            return true;
        if (a == null || a2 == null) 
            return false;
        var length = a.length;
        if (a2.length != length) 
            return false;
        for (var i = 0; i < length; i++) {
            var o1 = a[i];
            var o2 = a2[i];
            if (!(o1 == null ? o2 == null : o1.equals(o2))) 
                return false;
        }
        return true;
    };
}, {}, {});
var StringBuilder = function(_arguments) {
    if (arguments.length == 0) {} else {
         throw new RuntimeException("TODO StringBuilder " + arguments.length);
    }
};
StringBuilder = stjs.extend(StringBuilder, null, [], function(constructor, prototype) {
    prototype.str = "";
    prototype.append = function(o) {
        this.str += o;
        return this;
    };
    prototype.setLength = function(i) {};
    prototype.toString = function() {
        return this.str;
    };
}, {}, {});
var EnumSet = function() {};
EnumSet = stjs.extend(EnumSet, null, [Iterable], function(constructor, prototype) {
    constructor.allOf = function(class1) {
         throw new RuntimeException("TODO");
    };
    prototype.iterator = function() {
         throw new RuntimeException("TODO EnumSet.iterator");
    };
}, {}, {});
var NoSuchAlgorithmException = function() {
    RuntimeException.call(this);
};
NoSuchAlgorithmException = stjs.extend(NoSuchAlgorithmException, RuntimeException, [], null, {}, {});
var NoSuchElementException = function() {
    RuntimeException.call(this);
};
NoSuchElementException = stjs.extend(NoSuchElementException, RuntimeException, [], null, {}, {});
var ThreadFactory = function() {};
ThreadFactory = stjs.extend(ThreadFactory, null, [], function(constructor, prototype) {
    prototype.newThread = function(r) {};
}, {}, {});
var ImageIO = function() {};
ImageIO = stjs.extend(ImageIO, null, [], function(constructor, prototype) {
    constructor.write = function(bi, string, file) {
         throw new RuntimeException("TODO ImageIO.write");
    };
}, {}, {});
/**
 *  This annotation marks seemingly weird but intentionally done hacks
 *  
 *  @author zhukov
 */
var IntentionalHack = function() {};
IntentionalHack = stjs.extend(IntentionalHack, null, [], null, {}, {});
var ThreadLocal = function() {};
ThreadLocal = stjs.extend(ThreadLocal, null, [], function(constructor, prototype) {
    prototype.value = null;
    prototype.get = function() {
        return this.value;
    };
    prototype.set = function(val) {
        this.value = val;
    };
}, {}, {});
var Callable = function() {};
Callable = stjs.extend(Callable, null, [], function(constructor, prototype) {
    /**
     *  Computes a result, or throws an exception if unable to do so.
     * 
     *  @return computed result
     *  @throws Exception if unable to compute a result
     */
    prototype.call = function() {};
}, {}, {});
var Pattern = function(r) {
    this.r = r;
};
Pattern = stjs.extend(Pattern, null, [], function(constructor, prototype) {
    prototype.r = null;
    constructor.compile = function(string) {
        var r = new RegExp(string);
        return new Pattern(r);
    };
    prototype.matcher = function(string) {
         throw new RuntimeException("TODO");
    };
}, {r: "RegExp"}, {});
var Process = function() {};
Process = stjs.extend(Process, null, [], function(constructor, prototype) {
    prototype.waitFor = function() {
         throw new RuntimeException("TODO Process.waitFor");
    };
}, {}, {});
var AtomicInteger = function() {};
AtomicInteger = stjs.extend(AtomicInteger, null, [], null, {}, {});
var MessageDigest = function() {};
MessageDigest = stjs.extend(MessageDigest, null, [], function(constructor, prototype) {
    prototype.update = function(_arguments) {
         throw new RuntimeException("TODO MessageDigest.update");
    };
    prototype.digest = function() {
         throw new RuntimeException("TODO MessageDigest.digest");
    };
    constructor.getInstance = function(string) {
         throw new RuntimeException("TODO MessageDigest.getInstance");
    };
}, {}, {});
var TimeoutException = function() {
    Exception.call(this);
};
TimeoutException = stjs.extend(TimeoutException, Exception, [], null, {}, {});
var Constructor = function() {};
Constructor = stjs.extend(Constructor, null, [], function(constructor, prototype) {
    prototype.newInstance = function(_arguments) {
         throw new RuntimeException("TODO Constructor.newInstance");
    };
}, {}, {});
var FloatBuffer = function() {};
FloatBuffer = stjs.extend(FloatBuffer, null, [], function(constructor, prototype) {
    prototype.hasRemaining = function() {
         throw new RuntimeException("TODO");
    };
    prototype.put = function(_arguments) {
         throw new RuntimeException("TODO");
    };
    prototype.get = function(_arguments) {
         throw new RuntimeException("TODO");
    };
    constructor.allocate = function(i) {
         throw new RuntimeException("TODO");
    };
    prototype.flip = function() {
         throw new RuntimeException("TODO");
    };
    prototype.position = function(_arguments) {
         throw new RuntimeException("TODO");
    };
    prototype.clear = function() {
         throw new RuntimeException("TODO");
    };
    prototype.duplicate = function() {
         throw new RuntimeException("TODO");
    };
    prototype.capacity = function() {
         throw new RuntimeException("TODO");
    };
    prototype.limit = function(_arguments) {
         throw new RuntimeException("TODO");
    };
    prototype.remaining = function() {
         throw new RuntimeException("TODO");
    };
}, {}, {});
var Delayed = function() {};
Delayed = stjs.extend(Delayed, null, [], null, {}, {});
var PriorityBlockingQueue = function(initialCapacity, comparator) {};
PriorityBlockingQueue = stjs.extend(PriorityBlockingQueue, null, [], null, {}, {});
var UnsupportedOperationException = function(_arguments) {
    RuntimeException.call(this, "" + arguments);
};
UnsupportedOperationException = stjs.extend(UnsupportedOperationException, RuntimeException, [], null, {}, {});
var CRC32 = function() {};
CRC32 = stjs.extend(CRC32, null, [], function(constructor, prototype) {
    prototype.update = function(array) {
         throw new RuntimeException("TODO");
    };
    prototype.getValue = function() {
         throw new RuntimeException("TODO");
    };
}, {}, {});
var TimeZone = function() {};
TimeZone = stjs.extend(TimeZone, null, [], function(constructor, prototype) {
    constructor.getTimeZone = function(string) {
        return TimeZone.instance;
    };
    constructor.instance = new TimeZone();
}, {instance: "TimeZone"}, {});
var AssertionError = function(_arguments) {
    RuntimeException.call(this, "" + arguments);
};
AssertionError = stjs.extend(AssertionError, RuntimeException, [], null, {}, {});
var BufferUnderflowException = function() {
    RuntimeException.call(this);
};
BufferUnderflowException = stjs.extend(BufferUnderflowException, RuntimeException, [], null, {}, {});
var IllegalStateException = function(_arguments) {
    RuntimeException.call(this, "" + arguments);
};
IllegalStateException = stjs.extend(IllegalStateException, RuntimeException, [], null, {}, {});
var Modifier = function() {};
Modifier = stjs.extend(Modifier, null, [], function(constructor, prototype) {
    constructor.isPublic = function(modifiers) {
         throw new RuntimeException("TODO Modifier.isPublic");
    };
    constructor.isStatic = function(modifiers) {
         throw new RuntimeException("TODO Modifier.isStatic");
    };
}, {}, {});
var InvocationTargetException = function() {
    RuntimeException.call(this);
};
InvocationTargetException = stjs.extend(InvocationTargetException, RuntimeException, [], null, {}, {});
var Map = function() {};
Map = stjs.extend(Map, null, [], function(constructor, prototype) {
    constructor.Entry = function() {};
    constructor.Entry = stjs.extend(constructor.Entry, null, [], function(constructor, prototype) {
        prototype.getKey = function() {};
        prototype.getValue = function() {};
    }, {}, {});
    prototype.entrySet = function() {};
    prototype.get = function(k) {};
    prototype.size = function() {};
    prototype.put = function(key, value) {};
    prototype.containsKey = function(k) {};
    prototype.values = function() {};
    prototype.putAll = function(map) {};
    prototype.clear = function() {};
    prototype.remove = function(k) {};
    prototype.keySet = function() {};
}, {}, {});
var IOException = function(message) {
    RuntimeException.call(this);
};
IOException = stjs.extend(IOException, RuntimeException, [], null, {}, {});
var StackTraceElement = function() {};
StackTraceElement = stjs.extend(StackTraceElement, null, [], function(constructor, prototype) {
    constructor.Fake = new StackTraceElement();
    prototype.getFileName = function() {
        return "UnknownFile";
    };
    prototype.getClassName = function() {
        return "UnknownClass";
    };
    prototype.getMethodName = function() {
        return "unknownMethod";
    };
    prototype.getLineNumber = function() {
        return 42;
    };
}, {Fake: "StackTraceElement"}, {});
var Handler = function() {};
Handler = stjs.extend(Handler, null, [], null, {}, {});
var Matcher = function() {};
Matcher = stjs.extend(Matcher, null, [], function(constructor, prototype) {
    prototype.matches = function() {
         throw new RuntimeException("TODO");
    };
    prototype.group = function(i) {
         throw new RuntimeException("TODO");
    };
}, {}, {});
var InterruptedException = function() {
    RuntimeException.call(this);
};
InterruptedException = stjs.extend(InterruptedException, RuntimeException, [], null, {}, {});
var Calendar = function() {
    this.date = new Date();
};
Calendar = stjs.extend(Calendar, null, [], function(constructor, prototype) {
    /**
     *  Field number for <code>get</code> and <code>set</code> indicating the
     *  era, e.g., AD or BC in the Julian calendar. This is a calendar-specific
     *  value; see subclass documentation.
     * 
     *  @see GregorianCalendar#AD
     *  @see GregorianCalendar#BC
     */
    constructor.ERA = 0;
    /**
     *  Field number for <code>get</code> and <code>set</code> indicating the
     *  year. This is a calendar-specific value; see subclass documentation.
     */
    constructor.YEAR = 1;
    /**
     *  Field number for <code>get</code> and <code>set</code> indicating the
     *  month. This is a calendar-specific value. The first month of the year in
     *  the Gregorian and Julian calendars is <code>JANUARY</code> which is 0;
     *  the last depends on the number of months in a year.
     * 
     *  @see #JANUARY
     *  @see #FEBRUARY
     *  @see #MARCH
     *  @see #APRIL
     *  @see #MAY
     *  @see #JUNE
     *  @see #JULY
     *  @see #AUGUST
     *  @see #SEPTEMBER
     *  @see #OCTOBER
     *  @see #NOVEMBER
     *  @see #DECEMBER
     *  @see #UNDECIMBER
     */
    constructor.MONTH = 2;
    /**
     *  Field number for <code>get</code> and <code>set</code> indicating the
     *  week number within the current year. The first week of the year, as
     *  defined by <code>getFirstDayOfWeek()</code> and
     *  <code>getMinimalDaysInFirstWeek()</code>, has value 1. Subclasses define
     *  the value of <code>WEEK_OF_YEAR</code> for days before the first week of
     *  the year.
     * 
     *  @see #getFirstDayOfWeek
     *  @see #getMinimalDaysInFirstWeek
     */
    constructor.WEEK_OF_YEAR = 3;
    /**
     *  Field number for <code>get</code> and <code>set</code> indicating the
     *  week number within the current month. The first week of the month, as
     *  defined by <code>getFirstDayOfWeek()</code> and
     *  <code>getMinimalDaysInFirstWeek()</code>, has value 1. Subclasses define
     *  the value of <code>WEEK_OF_MONTH</code> for days before the first week of
     *  the month.
     * 
     *  @see #getFirstDayOfWeek
     *  @see #getMinimalDaysInFirstWeek
     */
    constructor.WEEK_OF_MONTH = 4;
    /**
     *  Field number for <code>get</code> and <code>set</code> indicating the day
     *  of the month. This is a synonym for <code>DAY_OF_MONTH</code>. The first
     *  day of the month has value 1.
     * 
     *  @see #DAY_OF_MONTH
     */
    constructor.DATE = 5;
    /**
     *  Field number for <code>get</code> and <code>set</code> indicating the day
     *  of the month. This is a synonym for <code>DATE</code>. The first day of
     *  the month has value 1.
     * 
     *  @see #DATE
     */
    constructor.DAY_OF_MONTH = 5;
    /**
     *  Field number for <code>get</code> and <code>set</code> indicating the day
     *  number within the current year. The first day of the year has value 1.
     */
    constructor.DAY_OF_YEAR = 6;
    /**
     *  Field number for <code>get</code> and <code>set</code> indicating the day
     *  of the week. This field takes values <code>SUNDAY</code>,
     *  <code>MONDAY</code>, <code>TUESDAY</code>, <code>WEDNESDAY</code>,
     *  <code>THURSDAY</code>, <code>FRIDAY</code>, and <code>SATURDAY</code>.
     * 
     *  @see #SUNDAY
     *  @see #MONDAY
     *  @see #TUESDAY
     *  @see #WEDNESDAY
     *  @see #THURSDAY
     *  @see #FRIDAY
     *  @see #SATURDAY
     */
    constructor.DAY_OF_WEEK = 7;
    /**
     *  Field number for <code>get</code> and <code>set</code> indicating the
     *  ordinal number of the day of the week within the current month. Together
     *  with the <code>DAY_OF_WEEK</code> field, this uniquely specifies a day
     *  within a month. Unlike <code>WEEK_OF_MONTH</code> and
     *  <code>WEEK_OF_YEAR</code>, this field's value does <em>not</em> depend on
     *  <code>getFirstDayOfWeek()</code> or
     *  <code>getMinimalDaysInFirstWeek()</code>. <code>DAY_OF_MONTH 1</code>
     *  through <code>7</code> always correspond to <code>DAY_OF_WEEK_IN_MONTH
     *  1</code>; <code>8</code> through <code>14</code> correspond to
     *  <code>DAY_OF_WEEK_IN_MONTH 2</code>, and so on.
     *  <code>DAY_OF_WEEK_IN_MONTH 0</code> indicates the week before
     *  <code>DAY_OF_WEEK_IN_MONTH 1</code>. Negative values count back from the
     *  end of the month, so the last Sunday of a month is specified as
     *  <code>DAY_OF_WEEK = SUNDAY, DAY_OF_WEEK_IN_MONTH = -1</code>. Because
     *  negative values count backward they will usually be aligned differently
     *  within the month than positive values. For example, if a month has 31
     *  days, <code>DAY_OF_WEEK_IN_MONTH -1</code> will overlap
     *  <code>DAY_OF_WEEK_IN_MONTH 5</code> and the end of <code>4</code>.
     * 
     *  @see #DAY_OF_WEEK
     *  @see #WEEK_OF_MONTH
     */
    constructor.DAY_OF_WEEK_IN_MONTH = 8;
    /**
     *  Field number for <code>get</code> and <code>set</code> indicating whether
     *  the <code>HOUR</code> is before or after noon. E.g., at 10:04:15.250 PM
     *  the <code>AM_PM</code> is <code>PM</code>.
     * 
     *  @see #AM
     *  @see #PM
     *  @see #HOUR
     */
    constructor.AM_PM = 9;
    /**
     *  Field number for <code>get</code> and <code>set</code> indicating the
     *  hour of the morning or afternoon. <code>HOUR</code> is used for the
     *  12-hour clock (0 - 11). Noon and midnight are represented by 0, not by
     *  12. E.g., at 10:04:15.250 PM the <code>HOUR</code> is 10.
     * 
     *  @see #AM_PM
     *  @see #HOUR_OF_DAY
     */
    constructor.HOUR = 10;
    /**
     *  Field number for <code>get</code> and <code>set</code> indicating the
     *  hour of the day. <code>HOUR_OF_DAY</code> is used for the 24-hour clock.
     *  E.g., at 10:04:15.250 PM the <code>HOUR_OF_DAY</code> is 22.
     * 
     *  @see #HOUR
     */
    constructor.HOUR_OF_DAY = 11;
    /**
     *  Field number for <code>get</code> and <code>set</code> indicating the
     *  minute within the hour. E.g., at 10:04:15.250 PM the <code>MINUTE</code>
     *  is 4.
     */
    constructor.MINUTE = 12;
    /**
     *  Field number for <code>get</code> and <code>set</code> indicating the
     *  second within the minute. E.g., at 10:04:15.250 PM the
     *  <code>SECOND</code> is 15.
     */
    constructor.SECOND = 13;
    /**
     *  Field number for <code>get</code> and <code>set</code> indicating the
     *  millisecond within the second. E.g., at 10:04:15.250 PM the
     *  <code>MILLISECOND</code> is 250.
     */
    constructor.MILLISECOND = 14;
    /**
     *  Field number for <code>get</code> and <code>set</code> indicating the raw
     *  offset from GMT in milliseconds.
     *  <p>
     *  This field reflects the correct GMT offset value of the time zone of this
     *  <code>Calendar</code> if the <code>TimeZone</code> implementation
     *  subclass supports historical GMT offset changes.
     */
    constructor.ZONE_OFFSET = 15;
    /**
     *  Field number for <code>get</code> and <code>set</code> indicating the
     *  daylight saving offset in milliseconds.
     *  <p>
     *  This field reflects the correct daylight saving offset value of the time
     *  zone of this <code>Calendar</code> if the <code>TimeZone</code>
     *  implementation subclass supports historical Daylight Saving Time schedule
     *  changes.
     */
    constructor.DST_OFFSET = 16;
    /**
     *  The number of distinct fields recognized by <code>get</code> and
     *  <code>set</code>. Field numbers range from <code>0..FIELD_COUNT-1</code>.
     */
    constructor.FIELD_COUNT = 17;
    /**
     *  Value of the {@link #DAY_OF_WEEK} field indicating Sunday.
     */
    constructor.SUNDAY = 1;
    /**
     *  Value of the {@link #DAY_OF_WEEK} field indicating Monday.
     */
    constructor.MONDAY = 2;
    /**
     *  Value of the {@link #DAY_OF_WEEK} field indicating Tuesday.
     */
    constructor.TUESDAY = 3;
    /**
     *  Value of the {@link #DAY_OF_WEEK} field indicating Wednesday.
     */
    constructor.WEDNESDAY = 4;
    /**
     *  Value of the {@link #DAY_OF_WEEK} field indicating Thursday.
     */
    constructor.THURSDAY = 5;
    /**
     *  Value of the {@link #DAY_OF_WEEK} field indicating Friday.
     */
    constructor.FRIDAY = 6;
    /**
     *  Value of the {@link #DAY_OF_WEEK} field indicating Saturday.
     */
    constructor.SATURDAY = 7;
    /**
     *  Value of the {@link #MONTH} field indicating the first month of the year
     *  in the Gregorian and Julian calendars.
     */
    constructor.JANUARY = 0;
    /**
     *  Value of the {@link #MONTH} field indicating the second month of the year
     *  in the Gregorian and Julian calendars.
     */
    constructor.FEBRUARY = 1;
    /**
     *  Value of the {@link #MONTH} field indicating the third month of the year
     *  in the Gregorian and Julian calendars.
     */
    constructor.MARCH = 2;
    /**
     *  Value of the {@link #MONTH} field indicating the fourth month of the year
     *  in the Gregorian and Julian calendars.
     */
    constructor.APRIL = 3;
    /**
     *  Value of the {@link #MONTH} field indicating the fifth month of the year
     *  in the Gregorian and Julian calendars.
     */
    constructor.MAY = 4;
    /**
     *  Value of the {@link #MONTH} field indicating the sixth month of the year
     *  in the Gregorian and Julian calendars.
     */
    constructor.JUNE = 5;
    /**
     *  Value of the {@link #MONTH} field indicating the seventh month of the
     *  year in the Gregorian and Julian calendars.
     */
    constructor.JULY = 6;
    /**
     *  Value of the {@link #MONTH} field indicating the eighth month of the year
     *  in the Gregorian and Julian calendars.
     */
    constructor.AUGUST = 7;
    /**
     *  Value of the {@link #MONTH} field indicating the ninth month of the year
     *  in the Gregorian and Julian calendars.
     */
    constructor.SEPTEMBER = 8;
    /**
     *  Value of the {@link #MONTH} field indicating the tenth month of the year
     *  in the Gregorian and Julian calendars.
     */
    constructor.OCTOBER = 9;
    /**
     *  Value of the {@link #MONTH} field indicating the eleventh month of the
     *  year in the Gregorian and Julian calendars.
     */
    constructor.NOVEMBER = 10;
    /**
     *  Value of the {@link #MONTH} field indicating the twelfth month of the
     *  year in the Gregorian and Julian calendars.
     */
    constructor.DECEMBER = 11;
    /**
     *  Value of the {@link #MONTH} field indicating the thirteenth month of the
     *  year. Although <code>GregorianCalendar</code> does not use this value,
     *  lunar calendars do.
     */
    constructor.UNDECIMBER = 12;
    /**
     *  Value of the {@link #AM_PM} field indicating the period of the day from
     *  midnight to just before noon.
     */
    constructor.AM = 0;
    /**
     *  Value of the {@link #AM_PM} field indicating the period of the day from
     *  noon to just before midnight.
     */
    constructor.PM = 1;
    prototype.date = null;
    prototype.set = function(_arguments) {
        if (arguments.length == 6) {
            var y = stjs.trunc(arguments[0]);
            var m = stjs.trunc(arguments[1]);
            var d = stjs.trunc(arguments[2]);
            var h = stjs.trunc(arguments[3]);
            var mm = stjs.trunc(arguments[4]);
            var s = stjs.trunc(arguments[5]);
            this.date = new Date(y, m, d, h, mm, s);
        } else if (arguments.length == 2) {
            var field = stjs.trunc(arguments[0]);
            var val = stjs.trunc(arguments[1]);
            if (Calendar.MILLISECOND == field) {
                this.date.setMilliseconds(val);
            } else {
                 throw new RuntimeException("TODO Calendar.set " + field + " " + val);
            }
        } else {
             throw new RuntimeException("TODO Calendar.set " + arguments.length);
        }
    };
    prototype.getTime = function() {
         throw new RuntimeException("TODO Calendar.getTime");
    };
    constructor.getInstance = function(_arguments) {
        return new Calendar();
    };
    prototype.getTimeInMillis = function() {
        return stjs.trunc(this.date.getTime());
    };
}, {date: "Date"}, {});
var ByteChannel = function() {};
ByteChannel = stjs.extend(ByteChannel, null, [], null, {}, {});
var Field = function() {};
Field = stjs.extend(Field, null, [], function(constructor, prototype) {
    prototype.getName = function() {
         throw new RuntimeException("TODO Field.getName");
    };
    prototype.setDouble = function(o, object) {
         throw new RuntimeException("TODO Field.setDouble");
    };
    prototype.setBoolean = function(o, object) {
         throw new RuntimeException("TODO Field.setBoolean");
    };
    prototype.set = function(o, object) {
         throw new RuntimeException("TODO Field.set");
    };
    prototype.get = function(read) {
         throw new RuntimeException("TODO Field.get");
    };
    prototype.getModifiers = function() {
         throw new RuntimeException("TODO Field.getModifiers");
    };
    prototype.getType = function() {
         throw new RuntimeException("TODO Field.getType");
    };
}, {}, {});
stjs.ns("jslang");
jslang.URL = function() {};
jslang.URL = stjs.extend(jslang.URL, null, [], function(constructor, prototype) {
    prototype.getFile = function() {
         throw new RuntimeException("TODO URL.getFile");
    };
}, {}, {});
var Future = function() {};
Future = stjs.extend(Future, null, [], function(constructor, prototype) {
    prototype.get = function(_arguments) {};
    prototype.cancel = function(mayInterruptIfRunning) {};
    prototype.isCancelled = function() {};
    prototype.isDone = function() {};
}, {}, {});
var TimeUnit = function() {};
TimeUnit = stjs.extend(TimeUnit, null, [], function(constructor, prototype) {
    constructor.MILLISECONDS = new TimeUnit();
    prototype.toMillis = function(period) {
        return period;
    };
}, {MILLISECONDS: "TimeUnit"}, {});
var File = function(_arguments) {
    switch (arguments.length) {
        case 1:
            this.path = arguments[0];
            break;
        case 2:
            var dir = arguments[0];
            this.path = dir.path + "/" + arguments[1];
            break;
        default:
             throw new RuntimeException("TODO File.init");
    }
};
File = stjs.extend(File, null, [], function(constructor, prototype) {
    constructor.fs = require("fs");
    prototype.path = null;
    prototype.length = function() {
        var statSync = File.fs.statSync(this.path);
        if (statSync != null) {
            return statSync.size;
        }
        return 0;
    };
    prototype.toString = function() {
        return this.path;
    };
    constructor.createTempFile = function(string, string2) {
         throw new RuntimeException("TODO");
    };
    prototype.getAbsolutePath = function() {
         throw new RuntimeException("TODO");
    };
    prototype.isDirectory = function() {
         throw new RuntimeException("TODO");
    };
    prototype.getName = function() {
         throw new RuntimeException("TODO");
    };
    prototype.exists = function() {
         throw new RuntimeException("TODO");
    };
    prototype.getParentFile = function() {
         throw new RuntimeException("TODO");
    };
    prototype.renameTo = function(src) {
         throw new RuntimeException("TODO");
    };
    prototype.deleteOnExit = function() {
         throw new RuntimeException("TODO");
    };
    prototype.listFiles = function(_arguments) {
        var readdirSync = File.fs.readdirSync(this.path);
        console.log("readdirSync", readdirSync);
        if (readdirSync != null) {
            var res = Array(readdirSync.length);
            for (var i = 0; i < readdirSync.length; i++) {
                res[i] = new File(this.path + "/" + readdirSync[i]);
            }
            return res;
        }
        return null;
    };
    prototype.getCanonicalPath = function() {
         throw new RuntimeException("TODO");
    };
    prototype.$delete = function() {
        File.fs.unlinkSync(this.path);
    };
    prototype.getParent = function() {
         throw new RuntimeException("TODO");
    };
    prototype.mkdirs = function() {
        File._mkdirs(this.path);
        return File.isDir(this.path);
    };
    prototype.lastModified = function() {
         throw new RuntimeException("TODO");
    };
    prototype.setLastModified = function(lastModified) {
         throw new RuntimeException("TODO");
    };
    prototype.getPath = function() {
        return this.path;
    };
    constructor.isDir = function(path) {
        try {
            var statSync = File.fs.statSync(path);
            return statSync.isDirectory();
        }catch (e) {
            return false;
        }
    };
    constructor._mkdirs = function(outDir) {
        var idx = 0;
        if (File.isDir(outDir)) {
            return;
        }
         while ((idx = outDir.indexOf("/", idx + 1)) >= 0){
            var path = outDir.substring(0, idx);
            if (!File.isDir(path)) {
                File._mkdir(path);
            }
        }
        if (!File.isDir(outDir)) {
            File._mkdir(outDir);
        }
    };
    constructor._mkdir = function(path) {
        console.log("mkdir", path);
        try {
            File.fs.mkdirSync(path);
        }catch (e) {
            if (File.isDir(path)) {} else {
                 throw e;
            }
        }
    };
}, {fs: "FS"}, {});
var NeedsSpeedOptimization = function() {};
NeedsSpeedOptimization = stjs.extend(NeedsSpeedOptimization, null, [], null, {}, {});
var WritableRaster = function() {};
WritableRaster = stjs.extend(WritableRaster, null, [], function(constructor, prototype) {
    prototype.getDataBuffer = function() {
         throw new RuntimeException("TODO WritableRaster.getDataBuffer");
    };
}, {}, {});
var NullPointerException = function(_arguments) {
    RuntimeException.call(this, "" + arguments);
};
NullPointerException = stjs.extend(NullPointerException, RuntimeException, [], null, {}, {});
var ClosedChannelException = function() {};
ClosedChannelException = stjs.extend(ClosedChannelException, null, [], null, {}, {});
var Runtime = function() {};
Runtime = stjs.extend(Runtime, null, [], function(constructor, prototype) {
    constructor.instance = new Runtime();
    constructor.getRuntime = function() {
        return Runtime.instance;
    };
    prototype.exec = function(string) {
         throw new RuntimeException("TODO Runtime.exec");
    };
    prototype.availableProcessors = function() {
        return 1;
    };
}, {instance: "Runtime"}, {});
var Executor = function() {};
Executor = stjs.extend(Executor, null, [], function(constructor, prototype) {
    prototype.execute = function(command) {};
}, {}, {});
var Assert = function() {};
Assert = stjs.extend(Assert, null, [], function(constructor, prototype) {
    constructor.assertTrue = function(_arguments) {
         throw new RuntimeException("TODO assertTrue");
    };
    constructor.assertEquals = function(_arguments) {
         throw new RuntimeException("TODO jsunit Assert.assertEquals");
    };
}, {}, {});
var Comparator = function() {};
Comparator = stjs.extend(Comparator, null, [], function(constructor, prototype) {
    prototype.compare = function(o1, o2) {};
}, {}, {});
var ShortBuffer = function() {};
ShortBuffer = stjs.extend(ShortBuffer, null, [], function(constructor, prototype) {
    constructor.wrap = function(orig) {
         throw new RuntimeException("TODO");
    };
    prototype.put = function(dctsize0, descale18) {
         throw new RuntimeException("TODO");
    };
    prototype.position = function(_arguments) {
         throw new RuntimeException("TODO");
    };
    prototype.slice = function() {
         throw new RuntimeException("TODO");
    };
    prototype.duplicate = function() {
         throw new RuntimeException("TODO");
    };
    prototype.get = function(_arguments) {
         throw new RuntimeException("TODO");
    };
}, {}, {});
var ExecutionException = function() {
    RuntimeException.call(this);
};
ExecutionException = stjs.extend(ExecutionException, RuntimeException, [], null, {}, {});
var Dimension = function(width, height) {
    this.width = width;
    this.height = height;
};
Dimension = stjs.extend(Dimension, null, [], function(constructor, prototype) {
    prototype.width = 0;
    prototype.height = 0;
}, {}, {});
var Runnable = function() {};
Runnable = stjs.extend(Runnable, null, [], function(constructor, prototype) {
    prototype.run = function() {};
}, {}, {});
var Character = function(value) {
    this.value = value;
};
Character = stjs.extend(Character, null, [], function(constructor, prototype) {
    prototype.value = '\x00';
    prototype.toString = function() {
        return (String).fromCharCode(this.value);
    };
}, {}, {});
stjs.ns("jslang.reflect");
jslang.reflect.Array = function() {};
jslang.reflect.Array = stjs.extend(jslang.reflect.Array, null, [], function(constructor, prototype) {
    constructor.newInstance = function(componentType, len) {
        var o;
        if (len == 0) {
            o = [];
        } else {
            o = new Array(len);
        }
        return o;
    };
    constructor.getLength = function(obj) {
         throw new RuntimeException("TODO Array.getLength");
    };
    constructor.get = function(obj, i) {
         throw new RuntimeException("TODO Array.get");
    };
}, {}, {});
var Channels = function() {};
Channels = stjs.extend(Channels, null, [], function(constructor, prototype) {
    constructor.newInputStream = function(_in) {
         throw new RuntimeException("TODO");
    };
    constructor.newChannel = function(inputStream) {
         throw new RuntimeException("TODO");
    };
}, {}, {});
var BufferedImage = function(croppedWidth, croppedHeight, type3byteBgr) {
     throw new RuntimeException("TODO");
};
BufferedImage = stjs.extend(BufferedImage, null, [], function(constructor, prototype) {
    constructor.TYPE_3BYTE_BGR = 0;
    prototype.getRaster = function() {
         throw new RuntimeException("TODO");
    };
    prototype.getHeight = function() {
         throw new RuntimeException("TODO");
    };
    prototype.getWidth = function() {
         throw new RuntimeException("TODO");
    };
    prototype.getRGB = function(j, i) {
         throw new RuntimeException("TODO");
    };
}, {}, {});
stjs.ns("jsutil");
jsutil.Date = function(_arguments) {
    switch (arguments.length) {
        case 0:
            this.time = stjs.trunc(new Date().getTime());
            break;
        default:
             throw new RuntimeException("Date.init " + arguments.length);
    }
};
jsutil.Date = stjs.extend(jsutil.Date, null, [], function(constructor, prototype) {
    prototype.time = 0;
    prototype.getTime = function() {
        return this.time;
    };
}, {}, {});
var IllegalAccessException = function() {
    RuntimeException.call(this);
};
IllegalAccessException = stjs.extend(IllegalAccessException, RuntimeException, [], null, {}, {});
var NoSuchMethodException = function() {
    RuntimeException.call(this);
};
NoSuchMethodException = stjs.extend(NoSuchMethodException, RuntimeException, [], null, {}, {});
var Charset = function() {};
Charset = stjs.extend(Charset, null, [], function(constructor, prototype) {
    constructor.defaultCharset = function() {
         throw new RuntimeException("TODO");
    };
    constructor.forName = function(string) {
         throw new RuntimeException("TODO");
    };
}, {}, {});
var Random = function() {};
Random = stjs.extend(Random, null, [], function(constructor, prototype) {
    prototype.nextLong = function() {
         throw new RuntimeException("TODO");
    };
}, {}, {});
var Method = function() {};
Method = stjs.extend(Method, null, [], function(constructor, prototype) {
    prototype.getName = function() {
         throw new RuntimeException("TODO Method.getName");
    };
    prototype.invoke = function(_arguments) {
         throw new RuntimeException("TODO Method.invoke");
    };
    prototype.getModifiers = function() {
         throw new RuntimeException("TODO Method.getModifiers");
    };
    prototype.getReturnType = function() {
         throw new RuntimeException("TODO Method.getReturnType");
    };
    prototype.getParameterTypes = function() {
        return null;
    };
}, {}, {});
var FixMe = function() {};
FixMe = stjs.extend(FixMe, null, [], null, {}, {});
var JSArrayIterator = function(arr) {
    this.arr = arr;
    this.cursor = 0;
};
JSArrayIterator = stjs.extend(JSArrayIterator, null, [Iterator], function(constructor, prototype) {
    prototype.arr = null;
    prototype.cursor = 0;
    prototype.hasNext = function() {
        return this.cursor < this.arr.length;
    };
    prototype.next = function() {
        return this.arr[this.cursor++];
    };
}, {arr: {name: "Array", arguments: ["T"]}}, {});
var ListIterator = function() {};
ListIterator = stjs.extend(ListIterator, null, [Iterator], function(constructor, prototype) {
    prototype.add = function(e) {};
    prototype.hasPrevious = function() {};
    prototype.previous = function() {};
    prototype.set = function(e) {};
}, {}, {});
var Channel = function() {};
Channel = stjs.extend(Channel, null, [Closeable], function(constructor, prototype) {
    /**
     *  Tells whether or not this channel is open.
     * 
     *  @return <tt>true</tt> if, and only if, this channel is open
     */
    prototype.isOpen = function() {};
}, {}, {});
var OutputStream = function() {};
OutputStream = stjs.extend(OutputStream, null, [Closeable], function(constructor, prototype) {
    prototype.write = function(_arguments) {
         throw new RuntimeException("TODO");
    };
    prototype.close = function() {
         throw new RuntimeException("TODO");
    };
    prototype.flush = function() {
         throw new RuntimeException("TODO");
    };
}, {}, {});
var InputStream = function() {};
InputStream = stjs.extend(InputStream, null, [Closeable], function(constructor, prototype) {
    prototype.read = function(_arguments) {
        if (arguments.length == 0) {
            return this.read0();
        } else if (arguments.length == 1) {
            var dst = arguments[0];
            return this.read1(dst);
        } else if (arguments.length == 3) {
            var dst = arguments[0];
            var off = stjs.trunc(arguments[1]);
            var len = stjs.trunc(arguments[2]);
            return this.read3(dst, off, len);
        } else {
             throw new RuntimeException("TODO InputStream read " + arguments.length);
        }
    };
    prototype.skip = function(l) {
         throw new RuntimeException("TODO");
    };
    prototype.close = function() {
         throw new RuntimeException("TODO");
    };
    prototype.read0 = function() {
         throw new RuntimeException("TODO");
    };
    prototype.read1 = function(buf) {
        return this.read3(buf, 0, buf.length);
    };
    prototype.read3 = function(buf, off, len) {
         throw new RuntimeException("TODO");
    };
}, {}, {});
var Reader = function() {};
Reader = stjs.extend(Reader, null, [Closeable], null, {}, {});
var RandomAccessFile = function(_arguments) {
     throw new RuntimeException("TODO");
};
RandomAccessFile = stjs.extend(RandomAccessFile, null, [Closeable], function(constructor, prototype) {
    prototype.read = function(tsPkt) {
         throw new RuntimeException("TODO");
    };
    prototype.getFilePointer = function() {
         throw new RuntimeException("TODO");
    };
    prototype.seek = function(i) {
         throw new RuntimeException("TODO");
    };
    prototype.write = function(tsPkt) {
         throw new RuntimeException("TODO");
    };
    prototype.close = function() {
         throw new RuntimeException("TODO");
    };
    prototype.getChannel = function() {
         throw new RuntimeException("TODO");
    };
}, {}, {});
var ReadableByteChannel = function() {};
ReadableByteChannel = stjs.extend(ReadableByteChannel, null, [Closeable], function(constructor, prototype) {
    prototype.read = function(buf) {};
}, {}, {});
var List = function() {};
List = stjs.extend(List, null, [Collection], function(constructor, prototype) {
    prototype.get = function(idx) {};
    prototype.set = function(index, element) {};
    prototype.size = function() {};
    prototype.clear = function() {};
    prototype.remove = function(_arguments) {};
    prototype.addAllAt = function(idx, other) {};
    prototype.listIterator = function() {};
    prototype.indexOf = function(t) {};
}, {}, {});
var Queue = function() {};
Queue = stjs.extend(Queue, null, [Collection], function(constructor, prototype) {
    prototype.offer = function(e) {};
    prototype.remove = function(_arguments) {};
    prototype.poll = function() {};
    prototype.element = function() {};
    prototype.peek = function() {};
}, {}, {});
var Set = function() {};
Set = stjs.extend(Set, null, [Collection], null, {}, {});
var ArrayIndexOutOfBoundsException = function(_arguments) {
    IndexOutOfBoundsException.call(this, "" + arguments);
};
ArrayIndexOutOfBoundsException = stjs.extend(ArrayIndexOutOfBoundsException, IndexOutOfBoundsException, [], null, {}, {});
var IntBuffer = function(int32array, off, pos, lim, cap) {
    this.hb = int32array;
    this.offset = off;
    this._mark = -1;
    this.pos = pos;
    this.lim = lim;
    this.cap = cap;
};
IntBuffer = stjs.extend(IntBuffer, null, [], function(constructor, prototype) {
    prototype.hb = null;
    prototype.offset = 0;
    prototype.pos = 0;
    prototype.lim = 0;
    prototype.cap = 0;
    prototype._mark = 0;
    constructor.wrap = function(orig) {
         throw new RuntimeException("TODO");
    };
    constructor.allocate = function(length) {
        return new IntBuffer(new Int32Array(length), 0, 0, length, length);
    };
    prototype.array = function() {
         throw new RuntimeException("TODO IntBuffer.array");
    };
    prototype.capacity = function() {
        return this.cap;
    };
    prototype.clear = function() {
         throw new RuntimeException("TODO IntBuffer.clear");
    };
    prototype.duplicate = function() {
         throw new RuntimeException("TODO IntBuffer.duplicate");
    };
    prototype.get = function(_arguments) {
        if (arguments.length == 1 && "number" == (typeof arguments[0])) {
            var i = stjs.trunc(arguments[0]);
            return this.hb[this.ix(this.checkIndex(i))];
        }
         throw new RuntimeException("TODO IntBuffer.get");
    };
    /**
     *  Checks the given index against the limit, throwing an
     *  {@link IndexOutOfBoundsException} if it is not smaller than the limit or
     *  is smaller than zero.
     */
    prototype.checkIndex = function(i) {
        if ((i < 0) || (i >= this.lim)) 
             throw new IndexOutOfBoundsException("" + i);
        return i;
    };
    prototype.put = function(_arguments) {
        if (arguments.length == 1 && "number" == (typeof arguments[0])) {
            var x = stjs.trunc(arguments[0]);
            this.hb[this.ix(this.nextPutIndex())] = x;
            return this;
        }
        console.error("arguments", arguments);
         throw new RuntimeException("TODO IntBuffer.put " + arguments.length);
    };
    prototype.ix = function(i) {
        return i + this.offset;
    };
    prototype.nextPutIndex = function() {
        if (this.pos >= this.lim) 
             throw new BufferOverflowException();
        return this.pos++;
    };
    prototype.position = function(_arguments) {
        if (arguments.length == 0) {
            return this.pos;
        } else if (arguments.length == 1) {
            var newPosition = arguments[0];
            if ((newPosition > this.lim) || (newPosition < 0)) 
                 throw new IllegalArgumentException("wrong position");
            this.pos = newPosition;
            if (this._mark > this.pos) 
                this._mark = -1;
            return this.illegalCast(this);
        }
         throw new RuntimeException("TODO IntBuffer.position");
    };
    prototype.illegalCast = function(intBuffer) {
        var o = intBuffer;
        return stjs.trunc(o);
    };
    prototype.hasRemaining = function() {
         throw new RuntimeException("TODO IntBuffer.hasRemaining");
    };
    prototype.slice = function() {
         throw new RuntimeException("TODO IntBuffer.slice");
    };
}, {hb: "Int32Array"}, {});
var ByteBuffer = function(int8array, mark, pos, lim, cap, off) {
    this.hb = int8array;
    this.arr = this.hb;
    var buf = this.arr.buffer;
    this.data = new DataView(buf, off, cap);
    this.offset = off;
    this._mark = -1;
    this.pos = pos;
    this.lim = lim;
    this.cap = cap;
};
ByteBuffer = stjs.extend(ByteBuffer, null, [], function(constructor, prototype) {
    prototype.hb = null;
    prototype.offset = 0;
    prototype.pos = 0;
    prototype.lim = 0;
    prototype.cap = 0;
    prototype._mark = 0;
    prototype.bigEndian = true;
    prototype.littleEndian = false;
    prototype.data = null;
    prototype.arr = null;
    prototype.position = function() {
        return this.pos;
    };
    prototype.setPosition = function(newPosition) {
        if ((newPosition > this.lim) || (newPosition < 0)) 
             throw new IllegalArgumentException("wrong position");
        this.pos = newPosition;
        if (this._mark > this.pos) 
            this._mark = -1;
        return this;
    };
    prototype.duplicate = function() {
        return new ByteBuffer(this.hb, this.markValue(), this.position(), this.limit(), this.capacity(), this.offset);
    };
    prototype.markValue = function() {
        return this._mark;
    };
    /**
     *  Returns the number of elements between the current position and the
     *  limit.
     * 
     *  @return The number of elements remaining in this buffer
     */
    prototype.remaining = function() {
        return this.lim - this.pos;
    };
    prototype.get = function() {
        return this.hb[this.ix(this.nextGetIndex())];
    };
    /**
     *  Checks the current position against the limit, throwing a
     *  {@link BufferUnderflowException} if it is not smaller than the limit, and
     *  then increments the position.
     * 
     *  @return The current position value, before it is incremented
     */
    prototype.nextGetIndex = function() {
        return this.pos++;
    };
    constructor.checkBounds = function(off, len, size) {
        if ((off | len | (off + len) | (size - (off + len))) < 0) 
             throw new IndexOutOfBoundsException();
    };
    /**
     *  Checks the given index against the limit, throwing an
     *  {@link IndexOutOfBoundsException} if it is not smaller than the limit or
     *  is smaller than zero.
     */
    prototype.checkIndex = function(i) {
        if ((i < 0) || (i >= this.lim)) 
             throw new IndexOutOfBoundsException("" + i);
        return i;
    };
    prototype.checkIndex2 = function(i, nb) {
        if ((i < 0) || (nb > this.lim - i)) 
             throw new IndexOutOfBoundsException();
        return i;
    };
    prototype.hasRemaining = function() {
        return this.pos < this.lim;
    };
    prototype.putInt = function(x) {
        Bits.putInt(this, this.ix(this._nextPutIndex(4)), x, this.bigEndian);
        return this;
    };
    prototype.ix = function(i) {
        return i + this.offset;
    };
    prototype._nextPutIndex = function(nb) {
        if (this.lim - this.pos < nb) 
             throw new BufferOverflowException();
        var p = this.pos;
        this.pos += nb;
        return p;
    };
    prototype.flip = function() {
        this.lim = this.pos;
        this.pos = 0;
        this._mark = -1;
        return this;
    };
    constructor.allocate = function(length) {
        return new ByteBuffer(new Int8Array(length), -1, 0, length, length, 0);
    };
    prototype.slice = function() {
        return new ByteBuffer(this.hb, -1, 0, this.remaining(), this.remaining(), this.position() + this.offset);
    };
    prototype.limit = function() {
        return this.lim;
    };
    prototype.setLimit = function(newLimit) {
        if ((newLimit > this.cap) || (newLimit < 0)) 
             throw new IllegalArgumentException(newLimit + ">" + this.cap);
        this.lim = newLimit;
        if (this.pos > this.lim) 
            this.pos = this.lim;
        if (this._mark > this.lim) 
            this._mark = -1;
        return this;
    };
    prototype.put = function(b) {
        this.hb[this.ix(this.nextPutIndex())] = b;
        return this;
    };
    prototype.putAt = function(index, b) {
        this.hb[this.ix(this.checkIndex(index))] = b;
        return this;
    };
    prototype.putArr = function(src) {
        return this.put3(src, 0, src.length);
    };
    prototype.putBuf = function(src) {
        var n = src.remaining();
        if (n > this.remaining()) 
             throw new BufferOverflowException();
        var _dst = this.arr;
        var _src = src.arr;
        var dstIdx = this.ix(this.position());
        var srcIdx = src.ix(src.position());
        _dst.subarray(dstIdx, dstIdx + n).set(_src.subarray(srcIdx, srcIdx + n), 0);
        src.setPosition(src.position() + n);
        this.setPosition(this.position() + n);
        return this;
    };
    prototype.put3 = function(src, off, len) {
        ByteBuffer.checkBounds(off, len, src.length);
        if (len > this.remaining()) 
             throw new BufferOverflowException();
        var end = off + len;
        for (var i = off; i < end; i++) 
            this.put(src[i]);
        return this;
    };
    prototype.nextPutIndex = function() {
        if (this.pos >= this.lim) 
             throw new BufferOverflowException();
        return this.pos++;
    };
    prototype.mark = function() {
        this._mark = this.pos;
        return this;
    };
    prototype.reset = function() {
        var m = this._mark;
        if (m < 0) 
             throw new IllegalStateException();
        this.pos = m;
        return this;
    };
    prototype.putLong = function(x) {
        Bits.putLong(this, this.ix(this._nextPutIndex(8)), x, this.bigEndian);
        return this;
    };
    prototype.getLong = function() {
         throw new RuntimeException("TODO getLong");
    };
    prototype.clear = function() {
        this.pos = 0;
        this.lim = this.cap;
        this._mark = -1;
        return this;
    };
    prototype.getOrder = function() {
        return this.bigEndian ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN;
    };
    prototype.order = function(bo) {
        this.bigEndian = (bo == ByteOrder.BIG_ENDIAN);
        this.littleEndian = !this.bigEndian;
        return this;
    };
    prototype.capacity = function() {
        return this.cap;
    };
    prototype.asIntBuffer = function() {
         throw new RuntimeException("TODO asIntBuffer");
    };
    prototype.array = function() {
        return this.hb;
    };
    constructor.wrap = function(_arguments) {
        if (arguments.length == 1) {
            var buf = arguments[0];
            return new ByteBuffer(buf, -1, 0, buf.length, buf.length, 0);
        } else {
            console.error("arguments", arguments);
             throw new RuntimeException("TODO ByteBuffer.wrap " + arguments.length);
        }
    };
    prototype.getDouble = function() {
         throw new RuntimeException("TODO getDouble");
    };
    prototype.getFloat = function() {
         throw new RuntimeException("TODO getFloat");
    };
    prototype.arrayOffset = function() {
        return this.offset;
    };
    prototype.hasArray = function() {
        return true;
    };
    prototype.getInt = function() {
        return this.data.getInt32(this._nextGetIndex(4), this.littleEndian);
    };
    prototype.getIntAt = function(i) {
        return this.data.getInt32(this.checkIndex2(i, 4), this.littleEndian);
    };
    prototype._nextGetIndex = function(nb) {
        if (this.lim - this.pos < nb) 
             throw new BufferUnderflowException();
        var p = this.pos;
        this.pos += nb;
        return p;
    };
    prototype.getChar = function() {
         throw new RuntimeException("TODO getChar");
    };
    prototype.putFloat = function(f) {
         throw new RuntimeException("TODO putFloat");
    };
    prototype.putDouble = function(value) {
         throw new RuntimeException("TODO putDouble");
    };
    prototype.putShort = function(_arguments) {
        if (arguments.length == 1) {
            var x = stjs.trunc(arguments[0]);
            Bits.putShort(this, this.ix(this._nextPutIndex(2)), x, this.bigEndian);
            return this;
        } else {
            console.error("TODO putShort", arguments);
             throw new RuntimeException("TODO putShort");
        }
    };
    prototype.getShort = function() {
        return Bits.getShort(this, this.ix(this._nextGetIndex(2)), this.bigEndian);
    };
    prototype.getShortAt = function(idx) {
         throw new RuntimeException("TODO ByteBuffer.getShortAt ");
    };
    prototype._get = function(i) {
        return this.hb[i];
    };
    prototype._put = function(i, b) {
        this.hb[i] = b;
    };
    prototype.getAt = function(idx) {
        return this.hb[this.ix(this.checkIndex(idx))];
    };
    prototype.getBuf = function(dst) {
        var length = dst.length;
        ByteBuffer.checkBounds(this.offset, length, dst.length);
        if (length > this.remaining()) 
             throw new BufferUnderflowException();
        var end = this.offset + length;
        for (var i = this.offset; i < end; i++) 
            dst[i] = this.get();
        return this;
    };
    prototype.getBuf3 = function(b, off, toRead) {
         throw new RuntimeException("TODO ByteBuffer.getBuf3");
    };
    constructor.allocateDirect = function(capacity) {
        return new ByteBuffer(new Int8Array(capacity), -1, 0, capacity, capacity, 0);
    };
    prototype.isDirect = function() {
        return false;
    };
    prototype.toString = function() {
        return "ByteBuffer [pos=" + this.pos + ", lim=" + this.lim + ", cap=" + this.cap + "]";
    };
}, {hb: "Int8Array", data: "DataView", arr: "Int8Array"}, {});
/**
 *  An optimized version of AbstractList.Itr
 */
var Itr = function(list) {
    this.list = list;
};
Itr = stjs.extend(Itr, null, [Iterator], function(constructor, prototype) {
    prototype.cursor = 0;
    prototype.lastRet = -1;
    prototype.list = null;
    prototype.hasNext = function() {
        return this.cursor != this.list.size();
    };
    prototype.next = function() {
        var i = this.cursor;
        if (i >= this.list.size()) 
             throw new NoSuchElementException();
        this.cursor = i + 1;
        return this.list.get(this.lastRet = i);
    };
    prototype.remove = function() {
        if (this.lastRet < 0) 
             throw new IllegalStateException();
        this.list.remove(this.lastRet);
        this.cursor = this.lastRet;
        this.lastRet = -1;
    };
}, {list: {name: "List", arguments: ["E"]}}, {});
var LinkedHashMap = function() {};
LinkedHashMap = stjs.extend(LinkedHashMap, null, [Map], function(constructor, prototype) {
    prototype.entrySet = function() {
         throw new RuntimeException("TODO");
    };
    prototype.get = function(k) {
         throw new RuntimeException("TODO");
    };
    prototype.size = function() {
         throw new RuntimeException("TODO");
    };
    prototype.put = function(k, v) {
         throw new RuntimeException("TODO");
    };
    prototype.containsKey = function(k) {
         throw new RuntimeException("TODO");
    };
    prototype.values = function() {
         throw new RuntimeException("TODO");
    };
    prototype.putAll = function(map) {
         throw new RuntimeException("TODO");
    };
    prototype.clear = function() {
         throw new RuntimeException("TODO");
    };
    prototype.remove = function(k) {
         throw new RuntimeException("TODO");
    };
    prototype.keySet = function() {
         throw new RuntimeException("TODO");
    };
}, {}, {});
var ConcurrentMap = function() {};
ConcurrentMap = stjs.extend(ConcurrentMap, null, [Map], function(constructor, prototype) {
    prototype.putIfAbsent = function(key, value) {};
}, {}, {});
var UnsupportedEncodingException = function(message) {
    IOException.call(this, message);
     throw new RuntimeException("TODO");
};
UnsupportedEncodingException = stjs.extend(UnsupportedEncodingException, IOException, [], null, {}, {});
var EOFException = function() {
    IOException.call(this, "eof");
};
EOFException = stjs.extend(EOFException, IOException, [], null, {}, {});
var FileNotFoundException = function(message) {
    IOException.call(this, message);
};
FileNotFoundException = stjs.extend(FileNotFoundException, IOException, [], null, {}, {});
var Thread = function(r) {
    this.r = r;
};
Thread = stjs.extend(Thread, null, [], function(constructor, prototype) {
    prototype.r = null;
    prototype.setDaemon = function(b) {
         throw new RuntimeException("TODO Thread.setDaemon");
    };
    prototype.setName = function(name) {
         throw new RuntimeException("TODO Thread.setName");
    };
    constructor.CurrentThread = new Thread(null);
    constructor.currentThread = function() {
        return Thread.CurrentThread;
    };
    constructor.FakeStackTrace = [StackTraceElement.Fake, StackTraceElement.Fake, StackTraceElement.Fake, StackTraceElement.Fake];
    prototype.getStackTrace = function() {
        return Thread.FakeStackTrace;
    };
}, {r: "Runnable", CurrentThread: "Thread", FakeStackTrace: "Array"}, {});
var ConsoleHandler = function() {
    Handler.call(this);
};
ConsoleHandler = stjs.extend(ConsoleHandler, Handler, [], function(constructor, prototype) {
    prototype.setLevel = function(all) {};
}, {}, {});
var ScheduledFuture = function() {};
ScheduledFuture = stjs.extend(ScheduledFuture, null, [Delayed, Future], null, {}, {});
var Level = /**
 *  Create a named Level with a given integer value and a given localization resource name.
 *  <p>
 *  
 *  @param name
 *             the name of the Level, for example "SEVERE".
 *  @param value
 *             an integer value for the level.
 *  @param resourceBundleName
 *             name of a resource bundle to use _in localizing the given name. If the resourceBundleName is null or an
 *             empty string, it is ignored.
 *  @throws NullPointerException
 *              if the name is null
 */
function(name, value, resourceBundleName) {
    if (name == null) {
         throw new NullPointerException();
    }
    this.name = name;
    this.value = value;
    this.resourceBundleName = resourceBundleName;
    this.localizedLevelName = resourceBundleName == null ? name : null;
    this.cachedLocale = null;
};
Level = stjs.extend(Level, null, [], function(constructor, prototype) {
    constructor.defaultBundle = "js.util.logging.resources.logging";
    constructor.ALL = new Level("ALL", Integer.MIN_VALUE, Level.defaultBundle);
    constructor.FINE = new Level("FINE", 500, Level.defaultBundle);
    constructor.WARNING = new Level("WARNING", 900, Level.defaultBundle);
    prototype.name = null;
    prototype.value = 0;
    prototype.resourceBundleName = null;
    prototype.localizedLevelName = null;
    prototype.cachedLocale = null;
}, {ALL: "Level", FINE: "Level", WARNING: "Level"}, {});
var ExecutorService = function() {};
ExecutorService = stjs.extend(ExecutorService, null, [Executor], function(constructor, prototype) {
    prototype.submit = function(object) {};
    prototype.shutdown = function() {};
}, {}, {});
var RunnableFuture = function() {};
RunnableFuture = stjs.extend(RunnableFuture, null, [Runnable, Future], function(constructor, prototype) {
    prototype.run = function() {};
}, {}, {});
var WritableByteChannel = function() {};
WritableByteChannel = stjs.extend(WritableByteChannel, null, [Channel], function(constructor, prototype) {
    prototype.write = function(src) {};
}, {}, {});
var ByteArrayOutputStream = function(_arguments) {
    OutputStream.call(this);
     throw new RuntimeException("TODO");
};
ByteArrayOutputStream = stjs.extend(ByteArrayOutputStream, OutputStream, [], function(constructor, prototype) {
    prototype.close = function() {
         throw new RuntimeException("TODO");
    };
    prototype.toByteArray = function() {
         throw new RuntimeException("TODO");
    };
}, {}, {});
var BufferedOutputStream = function(out) {
    OutputStream.call(this);
};
BufferedOutputStream = stjs.extend(BufferedOutputStream, OutputStream, [], function(constructor, prototype) {
    prototype.close = function() {
         throw new RuntimeException("TODO");
    };
    prototype.flush = function() {
         throw new RuntimeException("TODO");
    };
}, {}, {});
var PrintStream = function(outputStream) {
    OutputStream.call(this);
};
PrintStream = stjs.extend(PrintStream, OutputStream, [], function(constructor, prototype) {
    prototype.println = function(_arguments) {};
    prototype.print = function(o) {};
    prototype.printf = function(_arguments) {};
}, {}, {});
var DataInputStream = function(is) {
    InputStream.call(this);
     throw new RuntimeException("TODO");
};
DataInputStream = stjs.extend(DataInputStream, InputStream, [], function(constructor, prototype) {
    prototype.close = function() {
         throw new RuntimeException("TODO");
    };
    prototype.readLine = function() {
         throw new RuntimeException("TODO");
    };
}, {}, {});
var BufferedInputStream = function(is) {
    InputStream.call(this);
    this.is = is;
};
BufferedInputStream = stjs.extend(BufferedInputStream, InputStream, [], function(constructor, prototype) {
    prototype.is = null;
    prototype.read0 = function() {
        return this.is.read0();
    };
    prototype.read1 = function(buf) {
        return this.is.read1(buf);
    };
    prototype.read3 = function(buf, off, len) {
        return this.is.read3(buf, off, len);
    };
    prototype.skip = function(l) {
        return this.is.skip(l);
    };
    prototype.close = function() {
        this.is.close();
    };
}, {is: "InputStream"}, {});
var FileReader = function(file) {
    Reader.call(this);
     throw new RuntimeException("TODO");
};
FileReader = stjs.extend(FileReader, Reader, [], function(constructor, prototype) {
    prototype.close = function() {
         throw new RuntimeException("TODO");
    };
}, {}, {});
var BufferedReader = function(reader) {
    Reader.call(this);
     throw new RuntimeException("TODO");
};
BufferedReader = stjs.extend(BufferedReader, Reader, [], function(constructor, prototype) {
    prototype.close = function() {
         throw new RuntimeException("TODO");
    };
}, {}, {});
var FileChannel = function(fd) {
    this.fd = fd;
};
FileChannel = stjs.extend(FileChannel, null, [ReadableByteChannel], function(constructor, prototype) {
    constructor.fs = require("fs");
    prototype.fd = 0;
    constructor.MapMode = function(name) {
        this.name = name;
    };
    constructor.MapMode = stjs.extend(constructor.MapMode, null, [], function(constructor, prototype) {
        /**
         *  Mode for a read-only mapping.
         */
        constructor.READ_ONLY = new FileChannel.MapMode("READ_ONLY");
        /**
         *  Mode for a read/write mapping.
         */
        constructor.READ_WRITE = new FileChannel.MapMode("READ_WRITE");
        /**
         *  Mode for a private (copy-on-write) mapping.
         */
        constructor.PRIVATE = new FileChannel.MapMode("PRIVATE");
        prototype.name = null;
    }, {READ_ONLY: "FileChannel.MapMode", READ_WRITE: "FileChannel.MapMode", PRIVATE: "FileChannel.MapMode"}, {});
    prototype.isOpen = function() {
         throw new RuntimeException("TODO");
    };
    prototype.fpos = 0;
    prototype.position = function(_arguments) {
        switch (arguments.length) {
            case 0:
                return this.fpos;
            case 1:
                this.fpos = stjs.trunc(arguments[0]);
                return this.illegalCast(this);
            default:
                 throw new RuntimeException("TODO FileChannel.position " + arguments);
        }
    };
    prototype.illegalCast = function(x) {
        var o = x;
        return stjs.trunc(o);
    };
    prototype.read = function(dst) {
         throw new RuntimeException("TODO FileChannel.read " + dst);
    };
    constructor._read = function(buffer, count) {
        var slice = buffer.duplicate();
        var limit = buffer.position() + count;
        slice.setLimit(limit);
        buffer.setPosition(limit);
        return slice;
    };
    prototype.close = function() {
        console.log("close", this.fd);
        FileChannel.fs.closeSync(this.fd);
    };
    prototype.size = function() {
        return FileChannel.fs.fstatSync(this.fd).size;
    };
    prototype.truncate = function(size) {
         throw new RuntimeException("FileChannel.truncate");
    };
    prototype.write = function(buf) {
        var position = buf.position();
        var len = buf.remaining();
        var array = buf.array();
        var arr = array;
        var writen = FileChannel.fs.writeSync(this.fd, new Buffer(arr.buffer), position, len, this.fpos);
        if (writen >= 0) {
            this.fpos += writen;
            buf.setPosition(position + writen);
        }
        return writen;
    };
    prototype.map = function(mapMode, offset, len) {
         throw new RuntimeException("TODO");
    };
    prototype.transferFrom = function(input, pos, count) {
         throw new RuntimeException("TODO");
    };
}, {fs: "FS"}, {});
var BlockingQueue = function() {};
BlockingQueue = stjs.extend(BlockingQueue, null, [Queue], function(constructor, prototype) {
    prototype.poll = function() {};
    prototype.take = function() {};
    prototype.put = function(ret) {};
}, {}, {});
var HashSet = function(_arguments) {
    this._map = {};
    if (arguments.length == 0) {} else if (arguments.length == 1 && stjs.isInstanceOf(arguments[0].constructor, Iterable)) {
        var it = arguments[0];
        for (var iterator = it.iterator(); iterator.hasNext(); ) {
            var type = iterator.next();
            this.add(type);
        }
    } else {
         throw new RuntimeException("TODO new HashSet " + arguments.length);
    }
};
HashSet = stjs.extend(HashSet, null, [Set], function(constructor, prototype) {
    prototype._map = null;
    prototype._size = 0;
    prototype.size = function() {
         throw new RuntimeException("TODO Collection<E>.size");
    };
    prototype.isEmpty = function() {
        return this._size == 0;
    };
    prototype.contains = function(o) {
         throw new RuntimeException("TODO Collection<E>.contains");
    };
    prototype.toArray = function(a) {
         throw new RuntimeException("TODO Collection<E>.toArray");
    };
    prototype.add = function(_arguments) {
        var item = arguments[0];
        var key = this.makeKey(item);
        var contains = this._map[key] != null;
        this._map[key] = item;
        this._size = (Object).keys(this._map).length;
        return !contains;
    };
    prototype.remove = function(_arguments) {
         throw new RuntimeException("TODO Collection<E>.remove");
    };
    prototype.containsAll = function(c) {
         throw new RuntimeException("TODO Collection<E>.containsAll");
    };
    prototype.removeAll = function(c) {
         throw new RuntimeException("TODO Collection<E>.removeAll");
    };
    prototype.retainAll = function(c) {
         throw new RuntimeException("TODO Collection<E>.retainAll");
    };
    prototype.clear = function() {
        this._map = {};
    };
    prototype.iterator = function() {
         throw new RuntimeException("TODO Set<E>.iterator");
    };
    prototype.makeKey = function(k) {
        if (k != null) {
            if ("string" == (typeof k) || "number" == (typeof k)) {
                return "" + k;
            }
            var _toString = (k)["toString"];
            if (_toString != null) {
                try {
                    var str = _toString();
                    return str;
                }catch (e) {}
            }
            if ("function" == (typeof k)) {
                var name = (k)["name"];
                if (name != null && name != "") {
                    return name;
                }
            }
        }
        console.error("key", k);
         throw new IllegalArgumentException("supported key types: string, number, Function.name, anything.toString()");
    };
    prototype.addAll = function(other) {
         throw new RuntimeException("TODO Collection<E>.addAll");
    };
}, {_map: {name: "Map", arguments: [null, "E"]}}, {});
var MappedByteBuffer = function(int8array, off, pos, lim, cap) {
    ByteBuffer.call(this, int8array, -1, pos, lim, cap, off);
};
MappedByteBuffer = stjs.extend(MappedByteBuffer, ByteBuffer, [], null, {hb: "Int8Array", data: "DataView", arr: "Int8Array"}, {});
var ListItr = function(list, index) {
    Itr.call(this, list);
    this.cursor = index;
};
ListItr = stjs.extend(ListItr, Itr, [ListIterator], function(constructor, prototype) {
    prototype.hasPrevious = function() {
        return this.cursor != 0;
    };
    prototype.nextIndex = function() {
        return this.cursor;
    };
    prototype.previousIndex = function() {
        return this.cursor - 1;
    };
    prototype.previous = function() {
        var i = this.cursor - 1;
        if (i < 0) 
             throw new NoSuchElementException();
        this.cursor = i;
        return this.list.get(this.lastRet = i);
    };
    prototype.set = function(e) {
        if (this.lastRet < 0) 
             throw new IllegalStateException();
        this.list.set(this.lastRet, e);
    };
    prototype.add = function(e) {
        var i = this.cursor;
        this.list.add(i, e);
        this.cursor = i + 1;
        this.lastRet = -1;
    };
}, {list: {name: "List", arguments: ["E"]}}, {});
var JSScheduledFuture = function(handler) {
    this.handler = handler;
};
JSScheduledFuture = stjs.extend(JSScheduledFuture, null, [ScheduledFuture], function(constructor, prototype) {
    prototype.handler = null;
    prototype.get = function(_arguments) {
         throw new RuntimeException("TODO Future<T>.get");
    };
    prototype.cancel = function(mayInterruptIfRunning) {
         throw new RuntimeException("TODO Future<T>.cancel");
    };
    prototype.isCancelled = function() {
         throw new RuntimeException("TODO Future<T>.isCancelled");
    };
    prototype.isDone = function() {
         throw new RuntimeException("TODO Future<T>.isDone");
    };
}, {handler: "TimeoutHandler"}, {});
var ScheduledExecutorService = function() {};
ScheduledExecutorService = stjs.extend(ScheduledExecutorService, null, [ExecutorService], function(constructor, prototype) {
    prototype.scheduleAtFixedRate = function(runnable, initialDelay, period, unit) {};
}, {}, {});
var FutureTask = function(callable) {
     throw new RuntimeException("TODO FutureTask");
};
FutureTask = stjs.extend(FutureTask, null, [RunnableFuture], function(constructor, prototype) {
    prototype.get = function(_arguments) {
         throw new RuntimeException("TODO Future<V>.get");
    };
    prototype.cancel = function(mayInterruptIfRunning) {
         throw new RuntimeException("TODO Future<V>.cancel");
    };
    prototype.isCancelled = function() {
         throw new RuntimeException("TODO Future<V>.isCancelled");
    };
    prototype.isDone = function() {
         throw new RuntimeException("TODO Future<V>.isDone");
    };
    prototype.run = function() {
         throw new RuntimeException("TODO RunnableFuture<V>.run");
    };
}, {}, {});
var JSConsolePrintStream = function() {
    PrintStream.call(this, null);
};
JSConsolePrintStream = stjs.extend(JSConsolePrintStream, PrintStream, [], function(constructor, prototype) {
    prototype.println = function(_arguments) {
        if (arguments.length == 1) {
            console.log(arguments[0]);
        } else {
            console.log("println", arguments);
        }
    };
    prototype.print = function(o) {
        console.log("print", o);
    };
    prototype.printf = function(_arguments) {
        console.log("printf", arguments);
    };
}, {}, {});
var FileOutputStream = function(_arguments) {
    OutputStream.call(this);
    switch (arguments.length) {
        case 1:
            var file = arguments[0];
            this.fd = FileOutputStream.fs.openSync(file.getPath(), "w+");
            break;
        default:
             throw new RuntimeException("FileOutputStream.init " + arguments.length);
    }
};
FileOutputStream = stjs.extend(FileOutputStream, OutputStream, [], function(constructor, prototype) {
    constructor.fs = require("fs");
    prototype.fd = 0;
    prototype.close = function() {
        FileOutputStream.fs.closeSync(this.fd);
    };
    prototype.getChannel = function() {
        return new FileChannel(this.fd);
    };
}, {fs: "FS"}, {});
var MockFileChannel = function(arr) {
    FileChannel.call(this, -1);
    this.backing = ByteBuffer.wrap(arr);
    this.contentLength = this.backing.remaining();
};
MockFileChannel = stjs.extend(MockFileChannel, FileChannel, [], function(constructor, prototype) {
    prototype.backing = null;
    prototype.contentLength = 0;
    constructor.MapMode = function(name) {
        this.name = name;
    };
    constructor.MapMode = stjs.extend(constructor.MapMode, null, [], function(constructor, prototype) {
        /**
         *  Mode for a read-only mapping.
         */
        constructor.READ_ONLY = new MockFileChannel.MapMode("READ_ONLY");
        /**
         *  Mode for a read/write mapping.
         */
        constructor.READ_WRITE = new MockFileChannel.MapMode("READ_WRITE");
        /**
         *  Mode for a private (copy-on-write) mapping.
         */
        constructor.PRIVATE = new MockFileChannel.MapMode("PRIVATE");
        prototype.name = null;
    }, {READ_ONLY: "MockFileChannel.MapMode", READ_WRITE: "MockFileChannel.MapMode", PRIVATE: "MockFileChannel.MapMode"}, {});
    prototype.isOpen = function() {
         throw new RuntimeException("TODO");
    };
    prototype.position = function(_arguments) {
        if (arguments.length == 0) {
            return this.backing.position();
        }
        var newPosition = stjs.trunc(arguments[0]);
        this.backing.setPosition(stjs.trunc(newPosition));
        return this.illegalCast(this);
    };
    prototype.read = function(dst) {
        if (!this.backing.hasRemaining()) {
            return -1;
        }
        var toRead = Math.min(this.backing.remaining(), dst.remaining());
        dst.putBuf(MockFileChannel.__read(this.backing, toRead));
        this.contentLength = Math.max(this.contentLength, this.backing.position());
        return toRead;
    };
    constructor.__read = function(buffer, count) {
        var slice = buffer.duplicate();
        var limit = buffer.position() + count;
        slice.setLimit(limit);
        buffer.setPosition(limit);
        return slice;
    };
    prototype.close = function() {
         throw new RuntimeException("TODO");
    };
    prototype.size = function() {
        return this.contentLength;
    };
    prototype.truncate = function(size) {
         throw new RuntimeException("TODO");
    };
    prototype.write = function(arg0) {
         throw new RuntimeException("FileChannel.write");
    };
}, {backing: "ByteBuffer", fs: "FS"}, {});
var JSScheduledExecutorService = function() {};
JSScheduledExecutorService = stjs.extend(JSScheduledExecutorService, null, [ScheduledExecutorService], function(constructor, prototype) {
    prototype.submit = function(object) {
         throw new RuntimeException("TODO ExecutorService.submit");
    };
    prototype.shutdown = function() {
         throw new RuntimeException("TODO ExecutorService.shutdown");
    };
    prototype.execute = function(command) {
         throw new RuntimeException("TODO Executor.execute");
    };
    prototype.scheduleAtFixedRate = function(runnable, initialDelay, period, unit) {
        if (initialDelay == 0) {
            var th = setInterval(function() {
                runnable.run();
            }, ((unit.toMillis(period)) | 0));
            return new JSScheduledFuture(th);
        }
         throw new RuntimeException("TODO scheduleAtFixedRate initialDelay > 0");
    };
}, {}, {});
var ThreadPoolExecutor = function(nThreads, nThreads2, l, milliseconds, priorityBlockingQueue) {
     throw new RuntimeException("TODO ThreadPoolExecutor");
};
ThreadPoolExecutor = stjs.extend(ThreadPoolExecutor, null, [ExecutorService], function(constructor, prototype) {
    prototype.execute = function(command) {
         throw new RuntimeException("TODO Executor.execute");
    };
    prototype.submit = function(task) {
         throw new RuntimeException("TODO ExecutorService.submit");
    };
    prototype.shutdown = function() {
         throw new RuntimeException("TODO ExecutorService.shutdown");
    };
    prototype.newTaskFor = function(callable) {
        return new FutureTask(callable);
    };
}, {}, {});
var System = function() {};
System = stjs.extend(System, null, [], function(constructor, prototype) {
    constructor.out = new JSConsolePrintStream();
    constructor.err = new JSConsolePrintStream();
    constructor.arraycopy = function(src, srcPos, dst, dstPos, len) {
        var _src = src;
        var _dst = dst;
        var j = dstPos;
        var _lim = srcPos + len;
        for (var i = srcPos; i < _lim; i++) {
            _dst[j++] = _src[i];
        }
    };
    constructor.exit = function(i) {
         throw new RuntimeException("TODO");
    };
    constructor.SystemProperties = {};
    constructor.getProperty = function(string) {
        return System.SystemProperties[string];
    };
    constructor.currentTimeMillis = function() {
        return stjs.trunc(new Date().getTime());
    };
    constructor.identityHashCode = function(obj) {
         throw new RuntimeException("TODO");
    };
    constructor.console = function() {
        return null;
    };
}, {out: "PrintStream", err: "PrintStream", SystemProperties: {name: "Map", arguments: [null, null]}}, {});
var Executors = function() {};
Executors = stjs.extend(Executors, null, [], function(constructor, prototype) {
    constructor.newFixedThreadPool = function(availableProcessors, threadFactory) {
         throw new RuntimeException("TODO");
    };
    constructor.defaultThreadFactory = function() {
         throw new RuntimeException("TODO");
    };
    constructor.newSingleThreadScheduledExecutor = function() {
        return new JSScheduledExecutorService();
    };
    constructor.newScheduledThreadPool = function(i, daemonThreadFactory) {
        return new JSScheduledExecutorService();
    };
}, {}, {});
var LinkedList = function(_arguments) {
    if (arguments.length == 0) {
        this._array = new Array();
    } else {
         throw new RuntimeException("TODO new LinkedList " + arguments.length);
    }
};
LinkedList = stjs.extend(LinkedList, null, [List, Queue], function(constructor, prototype) {
    prototype._array = null;
    prototype.get = function(index) {
        this.rangeCheck(index);
        return this._array[index];
    };
    prototype.toArray = function(a) {
        var _size = this._array.length;
        if (a.length < _size) {
            var copy = this._array.slice(0);
            return copy;
        }
        System.arraycopy(this._array, 0, a, 0, _size);
        if (a.length > _size) 
            a[_size] = null;
        return a;
    };
    prototype.clear = function() {
        this._array.splice(0, this._array.length);
    };
    prototype.remove = function(_arguments) {
        if (arguments.length == 1 && "number" == (typeof arguments[0])) {
            var idx = stjs.trunc(arguments[0]);
            this.rangeCheck(idx);
            var oldValue = this._array[idx];
            this._array.splice(idx, 1);
            return oldValue;
        } else {
             throw new RuntimeException("TODO Collection<T>.remove");
        }
    };
    prototype.rangeCheck = function(index) {
        if (index >= this._array.length) 
             throw new IndexOutOfBoundsException("" + index);
    };
    prototype.isEmpty = function() {
        return this._array.length == 0;
    };
    prototype.add = function(_arguments) {
        if (arguments.length == 1) {
            this._array.push(arguments[0]);
        } else if (arguments.length == 2) {
            var idx = stjs.trunc(arguments[0]);
            var item = arguments[1];
            this._array.splice(idx, 0, item);
        } else {
            console.error("arguments", arguments);
             throw new RuntimeException("TODO LinkedList.add");
        }
        return true;
    };
    prototype.contains = function(o) {
         throw new RuntimeException("TODO");
    };
    prototype.getLast = function() {
         throw new RuntimeException("TODO");
    };
    prototype.peekFirst = function() {
         throw new RuntimeException("TODO");
    };
    prototype.removeFirst = function() {
         throw new RuntimeException("TODO");
    };
    prototype.indexOf = function(t) {
         throw new RuntimeException("TODO");
    };
    prototype.push = function(e) {
         throw new RuntimeException("TODO");
    };
    prototype.iterator = function() {
        return new Itr(this);
    };
    prototype.forEach = function(action) {
         throw new RuntimeException("TODO");
    };
    prototype.listIterator = function() {
        return new ListItr(this, 0);
    };
    prototype.size = function() {
        return this._array.length;
    };
    prototype.containsAll = function(c) {
         throw new RuntimeException("TODO Collection<T>.containsAll");
    };
    prototype.removeAll = function(c) {
         throw new RuntimeException("TODO Collection<T>.removeAll");
    };
    prototype.retainAll = function(c) {
         throw new RuntimeException("TODO Collection<T>.retainAll");
    };
    prototype.set = function(index, element) {
        this.rangeCheck(index);
        var oldValue = this._array[index];
        this._array[index] = element;
        return oldValue;
    };
    prototype.offer = function(e) {
        return this.add(e);
    };
    prototype.poll = function() {
        if (this._array.length == 0) {
            return null;
        }
        return this._array.splice(0, 1)[0];
    };
    prototype.getFirst = function() {
        if (this._array.length == 0) {
             throw new NoSuchElementException();
        }
        var f = this._array[0];
        return f;
    };
    prototype.element = function() {
        return this.getFirst();
    };
    prototype.peek = function() {
        if (this._array.length == 0) {
            return null;
        }
        var f = this._array[0];
        return f;
    };
    prototype.addAll = function(other) {
        for (var iterator$t = other.iterator(); iterator$t.hasNext(); ) {
            var t = iterator$t.next();
            this._array.push(t);
        }
        return other.size() != 0;
    };
    prototype.addAllAt = function(idx, other) {
         throw new RuntimeException("TODO Collection<T>.addAllAt");
    };
}, {_array: {name: "Array", arguments: ["T"]}}, {});
var ArrayList = function(_arguments) {
    if (arguments.length == 0) {
        this._array = new Array();
    } else if (arguments.length == 1 && "number" == (typeof arguments[0])) {
        this._array = new Array(stjs.trunc(arguments[0]));
    } else {
         throw new RuntimeException("TODO new ArrayList(collection)");
    }
};
ArrayList = stjs.extend(ArrayList, null, [List], function(constructor, prototype) {
    prototype._array = null;
    constructor.fromArray = function(arr) {
        var list = new ArrayList();
        list._array = arr;
        return list;
    };
    prototype.remove = function(_arguments) {
        if (arguments.length == 1 && "number" == (typeof arguments[0])) {
            var idx = stjs.trunc(arguments[0]);
            this.rangeCheck(idx);
            var oldValue = this._array[idx];
            this._array.splice(idx, 1);
            return oldValue;
        } else {
             throw new RuntimeException("TODO Collection<T>.remove");
        }
    };
    prototype.rangeCheck = function(index) {
        if (index >= this._array.length) 
             throw new IndexOutOfBoundsException("rangeCheck " + index);
    };
    prototype.containsAll = function(c) {
         throw new RuntimeException("TODO Collection<T>.containsAll");
    };
    prototype.removeAll = function(c) {
         throw new RuntimeException("TODO Collection<T>.removeAll");
    };
    prototype.retainAll = function(c) {
         throw new RuntimeException("TODO Collection<T>.retainAll");
    };
    prototype.isEmpty = function() {
        return this._array.length == 0;
    };
    prototype.contains = function(o) {
         throw new RuntimeException("TODO Collection<T>.contains");
    };
    prototype.iterator = function() {
        return new Itr(this);
    };
    prototype.toArray = function(a) {
        var _size = this._array.length;
        if (a.length < _size) {
            var copy = this._array.slice(0);
            return copy;
        }
        System.arraycopy(this._array, 0, a, 0, _size);
        if (a.length > _size) 
            a[_size] = null;
        return a;
    };
    prototype.add = function(_arguments) {
        if (arguments.length == 1) {
            this._array.push(arguments[0]);
            return true;
        } else {
             throw new RuntimeException("TODO Collection<T>.add");
        }
    };
    prototype.get = function(index) {
        this.rangeCheck(index);
        return this._array[index];
    };
    prototype.size = function() {
        return this._array.length;
    };
    prototype.clear = function() {
        this._array.splice(0, this._array.length);
    };
    prototype.listIterator = function() {
        return new ListItr(this, 0);
    };
    prototype.indexOf = function(t) {
         throw new RuntimeException("TODO List<T>.indexOf");
    };
    prototype.set = function(index, element) {
        this.rangeCheck(index);
        var oldValue = this._array[index];
        this._array[index] = element;
        return oldValue;
    };
    prototype.forEach = function(action) {
        this._array.forEach(action);
    };
    prototype.addAll = function(other) {
        for (var iterator$t = other.iterator(); iterator$t.hasNext(); ) {
            var t = iterator$t.next();
            this._array.push(t);
        }
        return other.size() != 0;
    };
    prototype.addAllAt = function(idx, other) {
         throw new RuntimeException("TODO Collection<T>.addAllAt");
    };
}, {_array: {name: "Array", arguments: ["T"]}}, {});
/**
 *  This class implements the Dual-Pivot Quicksort algorithm by
 *  Vladimir Yaroslavskiy, Jon Bentley, and Josh Bloch. The algorithm
 *  offers O(n log(n)) performance on many data sets that cause other
 *  quicksorts to degrade to quadratic performance, and is typically
 *  faster than traditional (one-pivot) Quicksort implementations.
 * 
 *  All exposed methods are package-private, designed to be invoked
 *  from public methods (in class Arrays) after performing any
 *  necessary array bounds checks and expanding parameters into the
 *  required forms.
 * 
 *  @author Vladimir Yaroslavskiy
 *  @author Jon Bentley
 *  @author Josh Bloch
 * 
 *  @version 2011.02.11 m765.827.12i:5\7pm
 *  @since 1.7
 */
var DualPivotQuicksort = /**
 *  Prevents instantiation.
 */
function() {};
DualPivotQuicksort = stjs.extend(DualPivotQuicksort, null, [], function(constructor, prototype) {
    /**
     *  The maximum number of runs in merge sort.
     */
    constructor.MAX_RUN_COUNT = 67;
    /**
     *  The maximum length of run in merge sort.
     */
    constructor.MAX_RUN_LENGTH = 33;
    /**
     *  If the length of an array to be sorted is less than this
     *  constant, Quicksort is used in preference to merge sort.
     */
    constructor.QUICKSORT_THRESHOLD = 286;
    /**
     *  If the length of an array to be sorted is less than this
     *  constant, insertion sort is used in preference to Quicksort.
     */
    constructor.INSERTION_SORT_THRESHOLD = 47;
    /**
     *  If the length of a byte array to be sorted is greater than this
     *  constant, counting sort is used in preference to insertion sort.
     */
    constructor.COUNTING_SORT_THRESHOLD_FOR_BYTE = 29;
    /**
     *  If the length of a short or char array to be sorted is greater
     *  than this constant, counting sort is used in preference to Quicksort.
     */
    constructor.COUNTING_SORT_THRESHOLD_FOR_SHORT_OR_CHAR = 3200;
    /**
     *  Sorts the specified range of the array using the given
     *  workspace array slice if possible for merging
     * 
     *  @param a the array to be sorted
     *  @param left the index of the first element, inclusive, to be sorted
     *  @param right the index of the last element, inclusive, to be sorted
     *  @param work a workspace array (slice)
     *  @param workBase origin of usable space in work array
     *  @param workLen usable size of work array
     */
    constructor.sortInt6 = function(a, left, right, work, workBase, workLen) {
        if (right - left < DualPivotQuicksort.QUICKSORT_THRESHOLD) {
            DualPivotQuicksort.sortInt4(a, left, right, true);
            return;
        }
        var run = new Int32Array(DualPivotQuicksort.MAX_RUN_COUNT + 1);
        var count = 0;
        run[0] = left;
        for (var k = left; k < right; run[count] = k) {
            if (a[k] < a[k + 1]) {
                 while (++k <= right && a[k - 1] <= a[k])
                    ;
            } else if (a[k] > a[k + 1]) {
                 while (++k <= right && a[k - 1] >= a[k])
                    ;
                for (var lo = run[count] - 1, hi = k; ++lo < --hi; ) {
                    var t = a[lo];
                    a[lo] = a[hi];
                    a[hi] = t;
                }
            } else {
                for (var m = DualPivotQuicksort.MAX_RUN_LENGTH; ++k <= right && a[k - 1] == a[k]; ) {
                    if (--m == 0) {
                        DualPivotQuicksort.sortInt4(a, left, right, true);
                        return;
                    }
                }
            }
            if (++count == DualPivotQuicksort.MAX_RUN_COUNT) {
                DualPivotQuicksort.sortInt4(a, left, right, true);
                return;
            }
        }
        if (run[count] == right++) {
            run[++count] = right;
        } else if (count == 1) {
            return;
        }
        var odd = 0;
        for (var n = 1; (n <<= 1) < count; odd ^= 1) 
            ;
        var b;
        var ao, bo;
        var blen = right - left;
        if (work == null || workLen < blen || workBase + blen > work.length) {
            work = new Int32Array(blen);
            workBase = 0;
        }
        if (odd == 0) {
            System.arraycopy(a, left, work, workBase, blen);
            b = a;
            bo = 0;
            a = work;
            ao = workBase - left;
        } else {
            b = work;
            ao = 0;
            bo = workBase - left;
        }
        for (var last; count > 1; count = last) {
            for (var k = (last = 0) + 2; k <= count; k += 2) {
                var hi = run[k], mi = run[k - 1];
                for (var i = run[k - 2], p = i, q = mi; i < hi; ++i) {
                    if (q >= hi || p < mi && a[p + ao] <= a[q + ao]) {
                        b[i + bo] = a[p++ + ao];
                    } else {
                        b[i + bo] = a[q++ + ao];
                    }
                }
                run[++last] = hi;
            }
            if ((count & 1) != 0) {
                for (var i = right, lo = run[count - 1]; --i >= lo; b[i + bo] = a[i + ao]) 
                    ;
                run[++last] = right;
            }
            var t = a;
            a = b;
            b = t;
            var o = ao;
            ao = bo;
            bo = o;
        }
    };
    /**
     *  Sorts the specified range of the array by Dual-Pivot Quicksort.
     * 
     *  @param a the array to be sorted
     *  @param left the index of the first element, inclusive, to be sorted
     *  @param right the index of the last element, inclusive, to be sorted
     *  @param leftmost indicates if this part is the leftmost in the range
     */
    constructor.sortInt4 = function(a, left, right, leftmost) {
        var length = right - left + 1;
        if (length < DualPivotQuicksort.INSERTION_SORT_THRESHOLD) {
            if (leftmost) {
                for (var i = left, j = i; i < right; j = ++i) {
                    var ai = a[i + 1];
                     while (ai < a[j]){
                        a[j + 1] = a[j];
                        if (j-- == left) {
                            break;
                        }
                    }
                    a[j + 1] = ai;
                }
            } else {
                do {
                    if (left >= right) {
                        return;
                    }
                } while (a[++left] >= a[left - 1]);
                for (var k = left; ++left <= right; k = ++left) {
                    var a1 = a[k], a2 = a[left];
                    if (a1 < a2) {
                        a2 = a1;
                        a1 = a[left];
                    }
                     while (a1 < a[--k]){
                        a[k + 2] = a[k];
                    }
                    a[++k + 1] = a1;
                     while (a2 < a[--k]){
                        a[k + 1] = a[k];
                    }
                    a[k + 1] = a2;
                }
                var last = a[right];
                 while (last < a[--right]){
                    a[right + 1] = a[right];
                }
                a[right + 1] = last;
            }
            return;
        }
        var seventh = (length >> 3) + (length >> 6) + 1;
        var e3 = (left + right) >>> 1;
        var e2 = e3 - seventh;
        var e1 = e2 - seventh;
        var e4 = e3 + seventh;
        var e5 = e4 + seventh;
        if (a[e2] < a[e1]) {
            var t = a[e2];
            a[e2] = a[e1];
            a[e1] = t;
        }
        if (a[e3] < a[e2]) {
            var t = a[e3];
            a[e3] = a[e2];
            a[e2] = t;
            if (t < a[e1]) {
                a[e2] = a[e1];
                a[e1] = t;
            }
        }
        if (a[e4] < a[e3]) {
            var t = a[e4];
            a[e4] = a[e3];
            a[e3] = t;
            if (t < a[e2]) {
                a[e3] = a[e2];
                a[e2] = t;
                if (t < a[e1]) {
                    a[e2] = a[e1];
                    a[e1] = t;
                }
            }
        }
        if (a[e5] < a[e4]) {
            var t = a[e5];
            a[e5] = a[e4];
            a[e4] = t;
            if (t < a[e3]) {
                a[e4] = a[e3];
                a[e3] = t;
                if (t < a[e2]) {
                    a[e3] = a[e2];
                    a[e2] = t;
                    if (t < a[e1]) {
                        a[e2] = a[e1];
                        a[e1] = t;
                    }
                }
            }
        }
        var less = left;
        var great = right;
        if (a[e1] != a[e2] && a[e2] != a[e3] && a[e3] != a[e4] && a[e4] != a[e5]) {
            var pivot1 = a[e2];
            var pivot2 = a[e4];
            a[e2] = a[left];
            a[e4] = a[right];
             while (a[++less] < pivot1)
                ;
             while (a[--great] > pivot2)
                ;
            outer:
                for (var k = less - 1; ++k <= great; ) {
                    var ak = a[k];
                    if (ak < pivot1) {
                        a[k] = a[less];
                        a[less] = ak;
                        ++less;
                    } else if (ak > pivot2) {
                         while (a[great] > pivot2){
                            if (great-- == k) {
                                break outer;
                            }
                        }
                        if (a[great] < pivot1) {
                            a[k] = a[less];
                            a[less] = a[great];
                            ++less;
                        } else {
                            a[k] = a[great];
                        }
                        a[great] = ak;
                        --great;
                    }
                }
            a[left] = a[less - 1];
            a[less - 1] = pivot1;
            a[right] = a[great + 1];
            a[great + 1] = pivot2;
            DualPivotQuicksort.sortInt4(a, left, less - 2, leftmost);
            DualPivotQuicksort.sortInt4(a, great + 2, right, false);
            if (less < e1 && e5 < great) {
                 while (a[less] == pivot1){
                    ++less;
                }
                 while (a[great] == pivot2){
                    --great;
                }
                outer:
                    for (var k = less - 1; ++k <= great; ) {
                        var ak = a[k];
                        if (ak == pivot1) {
                            a[k] = a[less];
                            a[less] = ak;
                            ++less;
                        } else if (ak == pivot2) {
                             while (a[great] == pivot2){
                                if (great-- == k) {
                                    break outer;
                                }
                            }
                            if (a[great] == pivot1) {
                                a[k] = a[less];
                                a[less] = pivot1;
                                ++less;
                            } else {
                                a[k] = a[great];
                            }
                            a[great] = ak;
                            --great;
                        }
                    }
            }
            DualPivotQuicksort.sortInt4(a, less, great, false);
        } else {
            var pivot = a[e3];
            for (var k = less; k <= great; ++k) {
                if (a[k] == pivot) {
                    continue;
                }
                var ak = a[k];
                if (ak < pivot) {
                    a[k] = a[less];
                    a[less] = ak;
                    ++less;
                } else {
                     while (a[great] > pivot){
                        --great;
                    }
                    if (a[great] < pivot) {
                        a[k] = a[less];
                        a[less] = a[great];
                        ++less;
                    } else {
                        a[k] = pivot;
                    }
                    a[great] = ak;
                    --great;
                }
            }
            DualPivotQuicksort.sortInt4(a, left, less - 1, leftmost);
            DualPivotQuicksort.sortInt4(a, great + 1, right, false);
        }
    };
    /**
     *  Sorts the specified range of the array using the given
     *  workspace array slice if possible for merging
     * 
     *  @param a the array to be sorted
     *  @param left the index of the first element, inclusive, to be sorted
     *  @param right the index of the last element, inclusive, to be sorted
     *  @param work a workspace array (slice)
     *  @param workBase origin of usable space in work array
     *  @param workLen usable size of work array
     */
    constructor.sortLong6 = function(a, left, right, work, workBase, workLen) {
        if (right - left < DualPivotQuicksort.QUICKSORT_THRESHOLD) {
            DualPivotQuicksort.sortLong4(a, left, right, true);
            return;
        }
        var run = new Int32Array(DualPivotQuicksort.MAX_RUN_COUNT + 1);
        var count = 0;
        run[0] = left;
        for (var k = left; k < right; run[count] = k) {
            if (a[k] < a[k + 1]) {
                 while (++k <= right && a[k - 1] <= a[k])
                    ;
            } else if (a[k] > a[k + 1]) {
                 while (++k <= right && a[k - 1] >= a[k])
                    ;
                for (var lo = run[count] - 1, hi = k; ++lo < --hi; ) {
                    var t = a[lo];
                    a[lo] = a[hi];
                    a[hi] = t;
                }
            } else {
                for (var m = DualPivotQuicksort.MAX_RUN_LENGTH; ++k <= right && a[k - 1] == a[k]; ) {
                    if (--m == 0) {
                        DualPivotQuicksort.sortLong4(a, left, right, true);
                        return;
                    }
                }
            }
            if (++count == DualPivotQuicksort.MAX_RUN_COUNT) {
                DualPivotQuicksort.sortLong4(a, left, right, true);
                return;
            }
        }
        if (run[count] == right++) {
            run[++count] = right;
        } else if (count == 1) {
            return;
        }
        var odd = 0;
        for (var n = 1; (n <<= 1) < count; odd ^= 1) 
            ;
        var b;
        var ao, bo;
        var blen = right - left;
        if (work == null || workLen < blen || workBase + blen > work.length) {
            work = Array(blen);
            workBase = 0;
        }
        if (odd == 0) {
            System.arraycopy(a, left, work, workBase, blen);
            b = a;
            bo = 0;
            a = work;
            ao = workBase - left;
        } else {
            b = work;
            ao = 0;
            bo = workBase - left;
        }
        for (var last; count > 1; count = last) {
            for (var k = (last = 0) + 2; k <= count; k += 2) {
                var hi = run[k], mi = run[k - 1];
                for (var i = run[k - 2], p = i, q = mi; i < hi; ++i) {
                    if (q >= hi || p < mi && a[p + ao] <= a[q + ao]) {
                        b[i + bo] = a[p++ + ao];
                    } else {
                        b[i + bo] = a[q++ + ao];
                    }
                }
                run[++last] = hi;
            }
            if ((count & 1) != 0) {
                for (var i = right, lo = run[count - 1]; --i >= lo; b[i + bo] = a[i + ao]) 
                    ;
                run[++last] = right;
            }
            var t = a;
            a = b;
            b = t;
            var o = ao;
            ao = bo;
            bo = o;
        }
    };
    /**
     *  Sorts the specified range of the array by Dual-Pivot Quicksort.
     * 
     *  @param a the array to be sorted
     *  @param left the index of the first element, inclusive, to be sorted
     *  @param right the index of the last element, inclusive, to be sorted
     *  @param leftmost indicates if this part is the leftmost in the range
     */
    constructor.sortLong4 = function(a, left, right, leftmost) {
        var length = right - left + 1;
        if (length < DualPivotQuicksort.INSERTION_SORT_THRESHOLD) {
            if (leftmost) {
                for (var i = left, j = i; i < right; j = ++i) {
                    var ai = a[i + 1];
                     while (ai < a[j]){
                        a[j + 1] = a[j];
                        if (j-- == left) {
                            break;
                        }
                    }
                    a[j + 1] = ai;
                }
            } else {
                do {
                    if (left >= right) {
                        return;
                    }
                } while (a[++left] >= a[left - 1]);
                for (var k = left; ++left <= right; k = ++left) {
                    var a1 = a[k], a2 = a[left];
                    if (a1 < a2) {
                        a2 = a1;
                        a1 = a[left];
                    }
                     while (a1 < a[--k]){
                        a[k + 2] = a[k];
                    }
                    a[++k + 1] = a1;
                     while (a2 < a[--k]){
                        a[k + 1] = a[k];
                    }
                    a[k + 1] = a2;
                }
                var last = a[right];
                 while (last < a[--right]){
                    a[right + 1] = a[right];
                }
                a[right + 1] = last;
            }
            return;
        }
        var seventh = (length >> 3) + (length >> 6) + 1;
        var e3 = (left + right) >>> 1;
        var e2 = e3 - seventh;
        var e1 = e2 - seventh;
        var e4 = e3 + seventh;
        var e5 = e4 + seventh;
        if (a[e2] < a[e1]) {
            var t = a[e2];
            a[e2] = a[e1];
            a[e1] = t;
        }
        if (a[e3] < a[e2]) {
            var t = a[e3];
            a[e3] = a[e2];
            a[e2] = t;
            if (t < a[e1]) {
                a[e2] = a[e1];
                a[e1] = t;
            }
        }
        if (a[e4] < a[e3]) {
            var t = a[e4];
            a[e4] = a[e3];
            a[e3] = t;
            if (t < a[e2]) {
                a[e3] = a[e2];
                a[e2] = t;
                if (t < a[e1]) {
                    a[e2] = a[e1];
                    a[e1] = t;
                }
            }
        }
        if (a[e5] < a[e4]) {
            var t = a[e5];
            a[e5] = a[e4];
            a[e4] = t;
            if (t < a[e3]) {
                a[e4] = a[e3];
                a[e3] = t;
                if (t < a[e2]) {
                    a[e3] = a[e2];
                    a[e2] = t;
                    if (t < a[e1]) {
                        a[e2] = a[e1];
                        a[e1] = t;
                    }
                }
            }
        }
        var less = left;
        var great = right;
        if (a[e1] != a[e2] && a[e2] != a[e3] && a[e3] != a[e4] && a[e4] != a[e5]) {
            var pivot1 = a[e2];
            var pivot2 = a[e4];
            a[e2] = a[left];
            a[e4] = a[right];
             while (a[++less] < pivot1)
                ;
             while (a[--great] > pivot2)
                ;
            outer:
                for (var k = less - 1; ++k <= great; ) {
                    var ak = a[k];
                    if (ak < pivot1) {
                        a[k] = a[less];
                        a[less] = ak;
                        ++less;
                    } else if (ak > pivot2) {
                         while (a[great] > pivot2){
                            if (great-- == k) {
                                break outer;
                            }
                        }
                        if (a[great] < pivot1) {
                            a[k] = a[less];
                            a[less] = a[great];
                            ++less;
                        } else {
                            a[k] = a[great];
                        }
                        a[great] = ak;
                        --great;
                    }
                }
            a[left] = a[less - 1];
            a[less - 1] = pivot1;
            a[right] = a[great + 1];
            a[great + 1] = pivot2;
            DualPivotQuicksort.sortLong4(a, left, less - 2, leftmost);
            DualPivotQuicksort.sortLong4(a, great + 2, right, false);
            if (less < e1 && e5 < great) {
                 while (a[less] == pivot1){
                    ++less;
                }
                 while (a[great] == pivot2){
                    --great;
                }
                outer:
                    for (var k = less - 1; ++k <= great; ) {
                        var ak = a[k];
                        if (ak == pivot1) {
                            a[k] = a[less];
                            a[less] = ak;
                            ++less;
                        } else if (ak == pivot2) {
                             while (a[great] == pivot2){
                                if (great-- == k) {
                                    break outer;
                                }
                            }
                            if (a[great] == pivot1) {
                                a[k] = a[less];
                                a[less] = pivot1;
                                ++less;
                            } else {
                                a[k] = a[great];
                            }
                            a[great] = ak;
                            --great;
                        }
                    }
            }
            DualPivotQuicksort.sortLong4(a, less, great, false);
        } else {
            var pivot = a[e3];
            for (var k = less; k <= great; ++k) {
                if (a[k] == pivot) {
                    continue;
                }
                var ak = a[k];
                if (ak < pivot) {
                    a[k] = a[less];
                    a[less] = ak;
                    ++less;
                } else {
                     while (a[great] > pivot){
                        --great;
                    }
                    if (a[great] < pivot) {
                        a[k] = a[less];
                        a[less] = a[great];
                        ++less;
                    } else {
                        a[k] = pivot;
                    }
                    a[great] = ak;
                    --great;
                }
            }
            DualPivotQuicksort.sortLong4(a, left, less - 1, leftmost);
            DualPivotQuicksort.sortLong4(a, great + 1, right, false);
        }
    };
    /**
     *  Sorts the specified range of the array using the given
     *  workspace array slice if possible for merging
     * 
     *  @param a the array to be sorted
     *  @param left the index of the first element, inclusive, to be sorted
     *  @param right the index of the last element, inclusive, to be sorted
     *  @param work a workspace array (slice)
     *  @param workBase origin of usable space in work array
     *  @param workLen usable size of work array
     */
    constructor.sortShort6 = function(a, left, right, work, workBase, workLen) {
        if (right - left > DualPivotQuicksort.COUNTING_SORT_THRESHOLD_FOR_SHORT_OR_CHAR) {
            var count = new Int32Array(DualPivotQuicksort.NUM_SHORT_VALUES);
            for (var i = left - 1; ++i <= right; count[a[i] - Short.MIN_VALUE]++) 
                ;
            for (var i = DualPivotQuicksort.NUM_SHORT_VALUES, k = right + 1; k > left; ) {
                 while (count[--i] == 0)
                    ;
                var value = (((i + Short.MIN_VALUE)) << 16 >> 16);
                var s = count[i];
                do {
                    a[--k] = value;
                } while (--s > 0);
            }
        } else {
            DualPivotQuicksort.doSortShort(a, left, right, work, workBase, workLen);
        }
    };
    /**
     * The number of distinct short values. 
     */
    constructor.NUM_SHORT_VALUES = 1 << 16;
    /**
     *  Sorts the specified range of the array.
     * 
     *  @param a the array to be sorted
     *  @param left the index of the first element, inclusive, to be sorted
     *  @param right the index of the last element, inclusive, to be sorted
     *  @param work a workspace array (slice)
     *  @param workBase origin of usable space in work array
     *  @param workLen usable size of work array
     */
    constructor.doSortShort = function(a, left, right, work, workBase, workLen) {
        if (right - left < DualPivotQuicksort.QUICKSORT_THRESHOLD) {
            DualPivotQuicksort.sortShort4(a, left, right, true);
            return;
        }
        var run = new Int32Array(DualPivotQuicksort.MAX_RUN_COUNT + 1);
        var count = 0;
        run[0] = left;
        for (var k = left; k < right; run[count] = k) {
            if (a[k] < a[k + 1]) {
                 while (++k <= right && a[k - 1] <= a[k])
                    ;
            } else if (a[k] > a[k + 1]) {
                 while (++k <= right && a[k - 1] >= a[k])
                    ;
                for (var lo = run[count] - 1, hi = k; ++lo < --hi; ) {
                    var t = a[lo];
                    a[lo] = a[hi];
                    a[hi] = t;
                }
            } else {
                for (var m = DualPivotQuicksort.MAX_RUN_LENGTH; ++k <= right && a[k - 1] == a[k]; ) {
                    if (--m == 0) {
                        DualPivotQuicksort.sortShort4(a, left, right, true);
                        return;
                    }
                }
            }
            if (++count == DualPivotQuicksort.MAX_RUN_COUNT) {
                DualPivotQuicksort.sortShort4(a, left, right, true);
                return;
            }
        }
        if (run[count] == right++) {
            run[++count] = right;
        } else if (count == 1) {
            return;
        }
        var odd = 0;
        for (var n = 1; (n <<= 1) < count; odd ^= 1) 
            ;
        var b;
        var ao, bo;
        var blen = right - left;
        if (work == null || workLen < blen || workBase + blen > work.length) {
            work = new Int16Array(blen);
            workBase = 0;
        }
        if (odd == 0) {
            System.arraycopy(a, left, work, workBase, blen);
            b = a;
            bo = 0;
            a = work;
            ao = workBase - left;
        } else {
            b = work;
            ao = 0;
            bo = workBase - left;
        }
        for (var last; count > 1; count = last) {
            for (var k = (last = 0) + 2; k <= count; k += 2) {
                var hi = run[k], mi = run[k - 1];
                for (var i = run[k - 2], p = i, q = mi; i < hi; ++i) {
                    if (q >= hi || p < mi && a[p + ao] <= a[q + ao]) {
                        b[i + bo] = a[p++ + ao];
                    } else {
                        b[i + bo] = a[q++ + ao];
                    }
                }
                run[++last] = hi;
            }
            if ((count & 1) != 0) {
                for (var i = right, lo = run[count - 1]; --i >= lo; b[i + bo] = a[i + ao]) 
                    ;
                run[++last] = right;
            }
            var t = a;
            a = b;
            b = t;
            var o = ao;
            ao = bo;
            bo = o;
        }
    };
    /**
     *  Sorts the specified range of the array by Dual-Pivot Quicksort.
     * 
     *  @param a the array to be sorted
     *  @param left the index of the first element, inclusive, to be sorted
     *  @param right the index of the last element, inclusive, to be sorted
     *  @param leftmost indicates if this part is the leftmost in the range
     */
    constructor.sortShort4 = function(a, left, right, leftmost) {
        var length = right - left + 1;
        if (length < DualPivotQuicksort.INSERTION_SORT_THRESHOLD) {
            if (leftmost) {
                for (var i = left, j = i; i < right; j = ++i) {
                    var ai = a[i + 1];
                     while (ai < a[j]){
                        a[j + 1] = a[j];
                        if (j-- == left) {
                            break;
                        }
                    }
                    a[j + 1] = ai;
                }
            } else {
                do {
                    if (left >= right) {
                        return;
                    }
                } while (a[++left] >= a[left - 1]);
                for (var k = left; ++left <= right; k = ++left) {
                    var a1 = a[k], a2 = a[left];
                    if (a1 < a2) {
                        a2 = a1;
                        a1 = a[left];
                    }
                     while (a1 < a[--k]){
                        a[k + 2] = a[k];
                    }
                    a[++k + 1] = a1;
                     while (a2 < a[--k]){
                        a[k + 1] = a[k];
                    }
                    a[k + 1] = a2;
                }
                var last = a[right];
                 while (last < a[--right]){
                    a[right + 1] = a[right];
                }
                a[right + 1] = last;
            }
            return;
        }
        var seventh = (length >> 3) + (length >> 6) + 1;
        var e3 = (left + right) >>> 1;
        var e2 = e3 - seventh;
        var e1 = e2 - seventh;
        var e4 = e3 + seventh;
        var e5 = e4 + seventh;
        if (a[e2] < a[e1]) {
            var t = a[e2];
            a[e2] = a[e1];
            a[e1] = t;
        }
        if (a[e3] < a[e2]) {
            var t = a[e3];
            a[e3] = a[e2];
            a[e2] = t;
            if (t < a[e1]) {
                a[e2] = a[e1];
                a[e1] = t;
            }
        }
        if (a[e4] < a[e3]) {
            var t = a[e4];
            a[e4] = a[e3];
            a[e3] = t;
            if (t < a[e2]) {
                a[e3] = a[e2];
                a[e2] = t;
                if (t < a[e1]) {
                    a[e2] = a[e1];
                    a[e1] = t;
                }
            }
        }
        if (a[e5] < a[e4]) {
            var t = a[e5];
            a[e5] = a[e4];
            a[e4] = t;
            if (t < a[e3]) {
                a[e4] = a[e3];
                a[e3] = t;
                if (t < a[e2]) {
                    a[e3] = a[e2];
                    a[e2] = t;
                    if (t < a[e1]) {
                        a[e2] = a[e1];
                        a[e1] = t;
                    }
                }
            }
        }
        var less = left;
        var great = right;
        if (a[e1] != a[e2] && a[e2] != a[e3] && a[e3] != a[e4] && a[e4] != a[e5]) {
            var pivot1 = a[e2];
            var pivot2 = a[e4];
            a[e2] = a[left];
            a[e4] = a[right];
             while (a[++less] < pivot1)
                ;
             while (a[--great] > pivot2)
                ;
            outer:
                for (var k = less - 1; ++k <= great; ) {
                    var ak = a[k];
                    if (ak < pivot1) {
                        a[k] = a[less];
                        a[less] = ak;
                        ++less;
                    } else if (ak > pivot2) {
                         while (a[great] > pivot2){
                            if (great-- == k) {
                                break outer;
                            }
                        }
                        if (a[great] < pivot1) {
                            a[k] = a[less];
                            a[less] = a[great];
                            ++less;
                        } else {
                            a[k] = a[great];
                        }
                        a[great] = ak;
                        --great;
                    }
                }
            a[left] = a[less - 1];
            a[less - 1] = pivot1;
            a[right] = a[great + 1];
            a[great + 1] = pivot2;
            DualPivotQuicksort.sortShort4(a, left, less - 2, leftmost);
            DualPivotQuicksort.sortShort4(a, great + 2, right, false);
            if (less < e1 && e5 < great) {
                 while (a[less] == pivot1){
                    ++less;
                }
                 while (a[great] == pivot2){
                    --great;
                }
                outer:
                    for (var k = less - 1; ++k <= great; ) {
                        var ak = a[k];
                        if (ak == pivot1) {
                            a[k] = a[less];
                            a[less] = ak;
                            ++less;
                        } else if (ak == pivot2) {
                             while (a[great] == pivot2){
                                if (great-- == k) {
                                    break outer;
                                }
                            }
                            if (a[great] == pivot1) {
                                a[k] = a[less];
                                a[less] = pivot1;
                                ++less;
                            } else {
                                a[k] = a[great];
                            }
                            a[great] = ak;
                            --great;
                        }
                    }
            }
            DualPivotQuicksort.sortShort4(a, less, great, false);
        } else {
            var pivot = a[e3];
            for (var k = less; k <= great; ++k) {
                if (a[k] == pivot) {
                    continue;
                }
                var ak = a[k];
                if (ak < pivot) {
                    a[k] = a[less];
                    a[less] = ak;
                    ++less;
                } else {
                     while (a[great] > pivot){
                        --great;
                    }
                    if (a[great] < pivot) {
                        a[k] = a[less];
                        a[less] = a[great];
                        ++less;
                    } else {
                        a[k] = pivot;
                    }
                    a[great] = ak;
                    --great;
                }
            }
            DualPivotQuicksort.sortShort4(a, left, less - 1, leftmost);
            DualPivotQuicksort.sortShort4(a, great + 1, right, false);
        }
    };
    /**
     *  Sorts the specified range of the array using the given
     *  workspace array slice if possible for merging
     * 
     *  @param a the array to be sorted
     *  @param left the index of the first element, inclusive, to be sorted
     *  @param right the index of the last element, inclusive, to be sorted
     *  @param work a workspace array (slice)
     *  @param workBase origin of usable space in work array
     *  @param workLen usable size of work array
     */
    constructor.sortChar6 = function(a, left, right, work, workBase, workLen) {
        if (right - left > DualPivotQuicksort.COUNTING_SORT_THRESHOLD_FOR_SHORT_OR_CHAR) {
            var count = new Int32Array(DualPivotQuicksort.NUM_CHAR_VALUES);
            for (var i = left - 1; ++i <= right; count[a[i]]++) 
                ;
            for (var i = DualPivotQuicksort.NUM_CHAR_VALUES, k = right + 1; k > left; ) {
                 while (count[--i] == 0)
                    ;
                var value = ((i) & 65535);
                var s = count[i];
                do {
                    a[--k] = value;
                } while (--s > 0);
            }
        } else {
            DualPivotQuicksort.doSortChar(a, left, right, work, workBase, workLen);
        }
    };
    /**
     * The number of distinct char values. 
     */
    constructor.NUM_CHAR_VALUES = 1 << 16;
    /**
     *  Sorts the specified range of the array.
     * 
     *  @param a the array to be sorted
     *  @param left the index of the first element, inclusive, to be sorted
     *  @param right the index of the last element, inclusive, to be sorted
     *  @param work a workspace array (slice)
     *  @param workBase origin of usable space in work array
     *  @param workLen usable size of work array
     */
    constructor.doSortChar = function(a, left, right, work, workBase, workLen) {
        if (right - left < DualPivotQuicksort.QUICKSORT_THRESHOLD) {
            DualPivotQuicksort.sortChar4(a, left, right, true);
            return;
        }
        var run = new Int32Array(DualPivotQuicksort.MAX_RUN_COUNT + 1);
        var count = 0;
        run[0] = left;
        for (var k = left; k < right; run[count] = k) {
            if (a[k] < a[k + 1]) {
                 while (++k <= right && a[k - 1] <= a[k])
                    ;
            } else if (a[k] > a[k + 1]) {
                 while (++k <= right && a[k - 1] >= a[k])
                    ;
                for (var lo = run[count] - 1, hi = k; ++lo < --hi; ) {
                    var t = a[lo];
                    a[lo] = a[hi];
                    a[hi] = t;
                }
            } else {
                for (var m = DualPivotQuicksort.MAX_RUN_LENGTH; ++k <= right && a[k - 1] == a[k]; ) {
                    if (--m == 0) {
                        DualPivotQuicksort.sortChar4(a, left, right, true);
                        return;
                    }
                }
            }
            if (++count == DualPivotQuicksort.MAX_RUN_COUNT) {
                DualPivotQuicksort.sortChar4(a, left, right, true);
                return;
            }
        }
        if (run[count] == right++) {
            run[++count] = right;
        } else if (count == 1) {
            return;
        }
        var odd = 0;
        for (var n = 1; (n <<= 1) < count; odd ^= 1) 
            ;
        var b;
        var ao, bo;
        var blen = right - left;
        if (work == null || workLen < blen || workBase + blen > work.length) {
            work = new Uint16Array(blen);
            workBase = 0;
        }
        if (odd == 0) {
            System.arraycopy(a, left, work, workBase, blen);
            b = a;
            bo = 0;
            a = work;
            ao = workBase - left;
        } else {
            b = work;
            ao = 0;
            bo = workBase - left;
        }
        for (var last; count > 1; count = last) {
            for (var k = (last = 0) + 2; k <= count; k += 2) {
                var hi = run[k], mi = run[k - 1];
                for (var i = run[k - 2], p = i, q = mi; i < hi; ++i) {
                    if (q >= hi || p < mi && a[p + ao] <= a[q + ao]) {
                        b[i + bo] = a[p++ + ao];
                    } else {
                        b[i + bo] = a[q++ + ao];
                    }
                }
                run[++last] = hi;
            }
            if ((count & 1) != 0) {
                for (var i = right, lo = run[count - 1]; --i >= lo; b[i + bo] = a[i + ao]) 
                    ;
                run[++last] = right;
            }
            var t = a;
            a = b;
            b = t;
            var o = ao;
            ao = bo;
            bo = o;
        }
    };
    /**
     *  Sorts the specified range of the array by Dual-Pivot Quicksort.
     * 
     *  @param a the array to be sorted
     *  @param left the index of the first element, inclusive, to be sorted
     *  @param right the index of the last element, inclusive, to be sorted
     *  @param leftmost indicates if this part is the leftmost in the range
     */
    constructor.sortChar4 = function(a, left, right, leftmost) {
        var length = right - left + 1;
        if (length < DualPivotQuicksort.INSERTION_SORT_THRESHOLD) {
            if (leftmost) {
                for (var i = left, j = i; i < right; j = ++i) {
                    var ai = a[i + 1];
                     while (ai < a[j]){
                        a[j + 1] = a[j];
                        if (j-- == left) {
                            break;
                        }
                    }
                    a[j + 1] = ai;
                }
            } else {
                do {
                    if (left >= right) {
                        return;
                    }
                } while (a[++left] >= a[left - 1]);
                for (var k = left; ++left <= right; k = ++left) {
                    var a1 = a[k], a2 = a[left];
                    if (a1 < a2) {
                        a2 = a1;
                        a1 = a[left];
                    }
                     while (a1 < a[--k]){
                        a[k + 2] = a[k];
                    }
                    a[++k + 1] = a1;
                     while (a2 < a[--k]){
                        a[k + 1] = a[k];
                    }
                    a[k + 1] = a2;
                }
                var last = a[right];
                 while (last < a[--right]){
                    a[right + 1] = a[right];
                }
                a[right + 1] = last;
            }
            return;
        }
        var seventh = (length >> 3) + (length >> 6) + 1;
        var e3 = (left + right) >>> 1;
        var e2 = e3 - seventh;
        var e1 = e2 - seventh;
        var e4 = e3 + seventh;
        var e5 = e4 + seventh;
        if (a[e2] < a[e1]) {
            var t = a[e2];
            a[e2] = a[e1];
            a[e1] = t;
        }
        if (a[e3] < a[e2]) {
            var t = a[e3];
            a[e3] = a[e2];
            a[e2] = t;
            if (t < a[e1]) {
                a[e2] = a[e1];
                a[e1] = t;
            }
        }
        if (a[e4] < a[e3]) {
            var t = a[e4];
            a[e4] = a[e3];
            a[e3] = t;
            if (t < a[e2]) {
                a[e3] = a[e2];
                a[e2] = t;
                if (t < a[e1]) {
                    a[e2] = a[e1];
                    a[e1] = t;
                }
            }
        }
        if (a[e5] < a[e4]) {
            var t = a[e5];
            a[e5] = a[e4];
            a[e4] = t;
            if (t < a[e3]) {
                a[e4] = a[e3];
                a[e3] = t;
                if (t < a[e2]) {
                    a[e3] = a[e2];
                    a[e2] = t;
                    if (t < a[e1]) {
                        a[e2] = a[e1];
                        a[e1] = t;
                    }
                }
            }
        }
        var less = left;
        var great = right;
        if (a[e1] != a[e2] && a[e2] != a[e3] && a[e3] != a[e4] && a[e4] != a[e5]) {
            var pivot1 = a[e2];
            var pivot2 = a[e4];
            a[e2] = a[left];
            a[e4] = a[right];
             while (a[++less] < pivot1)
                ;
             while (a[--great] > pivot2)
                ;
            outer:
                for (var k = less - 1; ++k <= great; ) {
                    var ak = a[k];
                    if (ak < pivot1) {
                        a[k] = a[less];
                        a[less] = ak;
                        ++less;
                    } else if (ak > pivot2) {
                         while (a[great] > pivot2){
                            if (great-- == k) {
                                break outer;
                            }
                        }
                        if (a[great] < pivot1) {
                            a[k] = a[less];
                            a[less] = a[great];
                            ++less;
                        } else {
                            a[k] = a[great];
                        }
                        a[great] = ak;
                        --great;
                    }
                }
            a[left] = a[less - 1];
            a[less - 1] = pivot1;
            a[right] = a[great + 1];
            a[great + 1] = pivot2;
            DualPivotQuicksort.sortChar4(a, left, less - 2, leftmost);
            DualPivotQuicksort.sortChar4(a, great + 2, right, false);
            if (less < e1 && e5 < great) {
                 while (a[less] == pivot1){
                    ++less;
                }
                 while (a[great] == pivot2){
                    --great;
                }
                outer:
                    for (var k = less - 1; ++k <= great; ) {
                        var ak = a[k];
                        if (ak == pivot1) {
                            a[k] = a[less];
                            a[less] = ak;
                            ++less;
                        } else if (ak == pivot2) {
                             while (a[great] == pivot2){
                                if (great-- == k) {
                                    break outer;
                                }
                            }
                            if (a[great] == pivot1) {
                                a[k] = a[less];
                                a[less] = pivot1;
                                ++less;
                            } else {
                                a[k] = a[great];
                            }
                            a[great] = ak;
                            --great;
                        }
                    }
            }
            DualPivotQuicksort.sortChar4(a, less, great, false);
        } else {
            var pivot = a[e3];
            for (var k = less; k <= great; ++k) {
                if (a[k] == pivot) {
                    continue;
                }
                var ak = a[k];
                if (ak < pivot) {
                    a[k] = a[less];
                    a[less] = ak;
                    ++less;
                } else {
                     while (a[great] > pivot){
                        --great;
                    }
                    if (a[great] < pivot) {
                        a[k] = a[less];
                        a[less] = a[great];
                        ++less;
                    } else {
                        a[k] = pivot;
                    }
                    a[great] = ak;
                    --great;
                }
            }
            DualPivotQuicksort.sortChar4(a, left, less - 1, leftmost);
            DualPivotQuicksort.sortChar4(a, great + 1, right, false);
        }
    };
    /**
     * The number of distinct byte values. 
     */
    constructor.NUM_BYTE_VALUES = 1 << 8;
    /**
     *  Sorts the specified range of the array.
     * 
     *  @param a the array to be sorted
     *  @param left the index of the first element, inclusive, to be sorted
     *  @param right the index of the last element, inclusive, to be sorted
     */
    constructor.sortByte3 = function(a, left, right) {
        if (right - left > DualPivotQuicksort.COUNTING_SORT_THRESHOLD_FOR_BYTE) {
            var count = new Int32Array(DualPivotQuicksort.NUM_BYTE_VALUES);
            for (var i = left - 1; ++i <= right; count[a[i] - Byte.MIN_VALUE]++) 
                ;
            for (var i = DualPivotQuicksort.NUM_BYTE_VALUES, k = right + 1; k > left; ) {
                 while (count[--i] == 0)
                    ;
                var value = ((i + Byte.MIN_VALUE) << 24 >> 24);
                var s = count[i];
                do {
                    a[--k] = value;
                } while (--s > 0);
            }
        } else {
            for (var i = left, j = i; i < right; j = ++i) {
                var ai = a[i + 1];
                 while (ai < a[j]){
                    a[j + 1] = a[j];
                    if (j-- == left) {
                        break;
                    }
                }
                a[j + 1] = ai;
            }
        }
    };
    /**
     *  Sorts the specified range of the array using the given
     *  workspace array slice if possible for merging
     * 
     *  @param a the array to be sorted
     *  @param left the index of the first element, inclusive, to be sorted
     *  @param right the index of the last element, inclusive, to be sorted
     *  @param work a workspace array (slice)
     *  @param workBase origin of usable space in work array
     *  @param workLen usable size of work array
     */
    constructor.sortFloat6 = function(a, left, right, work, workBase, workLen) {
         while (left <= right && Float.isNaN(a[right])){
            --right;
        }
        for (var k = right; --k >= left; ) {
            var ak = a[k];
            if (ak != ak) {
                a[k] = a[right];
                a[right] = ak;
                --right;
            }
        }
        DualPivotQuicksort.doSortFloat(a, left, right, work, workBase, workLen);
        var hi = right;
         while (left < hi){
            var middle = (left + hi) >>> 1;
            var middleValue = a[middle];
            if (middleValue < 0.0) {
                left = middle + 1;
            } else {
                hi = middle;
            }
        }
         while (left <= right && Float.floatToRawIntBits(a[left]) < 0){
            ++left;
        }
        for (var k = left, p = left - 1; ++k <= right; ) {
            var ak = a[k];
            if (ak != 0.0) {
                break;
            }
            if (Float.floatToRawIntBits(ak) < 0) {
                a[k] = 0.0;
                a[++p] = -0.0;
            }
        }
    };
    /**
     *  Sorts the specified range of the array.
     * 
     *  @param a the array to be sorted
     *  @param left the index of the first element, inclusive, to be sorted
     *  @param right the index of the last element, inclusive, to be sorted
     *  @param work a workspace array (slice)
     *  @param workBase origin of usable space in work array
     *  @param workLen usable size of work array
     */
    constructor.doSortFloat = function(a, left, right, work, workBase, workLen) {
        if (right - left < DualPivotQuicksort.QUICKSORT_THRESHOLD) {
            DualPivotQuicksort.sortFloat4(a, left, right, true);
            return;
        }
        var run = new Int32Array(DualPivotQuicksort.MAX_RUN_COUNT + 1);
        var count = 0;
        run[0] = left;
        for (var k = left; k < right; run[count] = k) {
            if (a[k] < a[k + 1]) {
                 while (++k <= right && a[k - 1] <= a[k])
                    ;
            } else if (a[k] > a[k + 1]) {
                 while (++k <= right && a[k - 1] >= a[k])
                    ;
                for (var lo = run[count] - 1, hi = k; ++lo < --hi; ) {
                    var t = a[lo];
                    a[lo] = a[hi];
                    a[hi] = t;
                }
            } else {
                for (var m = DualPivotQuicksort.MAX_RUN_LENGTH; ++k <= right && a[k - 1] == a[k]; ) {
                    if (--m == 0) {
                        DualPivotQuicksort.sortFloat4(a, left, right, true);
                        return;
                    }
                }
            }
            if (++count == DualPivotQuicksort.MAX_RUN_COUNT) {
                DualPivotQuicksort.sortFloat4(a, left, right, true);
                return;
            }
        }
        if (run[count] == right++) {
            run[++count] = right;
        } else if (count == 1) {
            return;
        }
        var odd = 0;
        for (var n = 1; (n <<= 1) < count; odd ^= 1) 
            ;
        var b;
        var ao, bo;
        var blen = right - left;
        if (work == null || workLen < blen || workBase + blen > work.length) {
            work = new Float32Array(blen);
            workBase = 0;
        }
        if (odd == 0) {
            System.arraycopy(a, left, work, workBase, blen);
            b = a;
            bo = 0;
            a = work;
            ao = workBase - left;
        } else {
            b = work;
            ao = 0;
            bo = workBase - left;
        }
        for (var last; count > 1; count = last) {
            for (var k = (last = 0) + 2; k <= count; k += 2) {
                var hi = run[k], mi = run[k - 1];
                for (var i = run[k - 2], p = i, q = mi; i < hi; ++i) {
                    if (q >= hi || p < mi && a[p + ao] <= a[q + ao]) {
                        b[i + bo] = a[p++ + ao];
                    } else {
                        b[i + bo] = a[q++ + ao];
                    }
                }
                run[++last] = hi;
            }
            if ((count & 1) != 0) {
                for (var i = right, lo = run[count - 1]; --i >= lo; b[i + bo] = a[i + ao]) 
                    ;
                run[++last] = right;
            }
            var t = a;
            a = b;
            b = t;
            var o = ao;
            ao = bo;
            bo = o;
        }
    };
    /**
     *  Sorts the specified range of the array by Dual-Pivot Quicksort.
     * 
     *  @param a the array to be sorted
     *  @param left the index of the first element, inclusive, to be sorted
     *  @param right the index of the last element, inclusive, to be sorted
     *  @param leftmost indicates if this part is the leftmost in the range
     */
    constructor.sortFloat4 = function(a, left, right, leftmost) {
        var length = right - left + 1;
        if (length < DualPivotQuicksort.INSERTION_SORT_THRESHOLD) {
            if (leftmost) {
                for (var i = left, j = i; i < right; j = ++i) {
                    var ai = a[i + 1];
                     while (ai < a[j]){
                        a[j + 1] = a[j];
                        if (j-- == left) {
                            break;
                        }
                    }
                    a[j + 1] = ai;
                }
            } else {
                do {
                    if (left >= right) {
                        return;
                    }
                } while (a[++left] >= a[left - 1]);
                for (var k = left; ++left <= right; k = ++left) {
                    var a1 = a[k], a2 = a[left];
                    if (a1 < a2) {
                        a2 = a1;
                        a1 = a[left];
                    }
                     while (a1 < a[--k]){
                        a[k + 2] = a[k];
                    }
                    a[++k + 1] = a1;
                     while (a2 < a[--k]){
                        a[k + 1] = a[k];
                    }
                    a[k + 1] = a2;
                }
                var last = a[right];
                 while (last < a[--right]){
                    a[right + 1] = a[right];
                }
                a[right + 1] = last;
            }
            return;
        }
        var seventh = (length >> 3) + (length >> 6) + 1;
        var e3 = (left + right) >>> 1;
        var e2 = e3 - seventh;
        var e1 = e2 - seventh;
        var e4 = e3 + seventh;
        var e5 = e4 + seventh;
        if (a[e2] < a[e1]) {
            var t = a[e2];
            a[e2] = a[e1];
            a[e1] = t;
        }
        if (a[e3] < a[e2]) {
            var t = a[e3];
            a[e3] = a[e2];
            a[e2] = t;
            if (t < a[e1]) {
                a[e2] = a[e1];
                a[e1] = t;
            }
        }
        if (a[e4] < a[e3]) {
            var t = a[e4];
            a[e4] = a[e3];
            a[e3] = t;
            if (t < a[e2]) {
                a[e3] = a[e2];
                a[e2] = t;
                if (t < a[e1]) {
                    a[e2] = a[e1];
                    a[e1] = t;
                }
            }
        }
        if (a[e5] < a[e4]) {
            var t = a[e5];
            a[e5] = a[e4];
            a[e4] = t;
            if (t < a[e3]) {
                a[e4] = a[e3];
                a[e3] = t;
                if (t < a[e2]) {
                    a[e3] = a[e2];
                    a[e2] = t;
                    if (t < a[e1]) {
                        a[e2] = a[e1];
                        a[e1] = t;
                    }
                }
            }
        }
        var less = left;
        var great = right;
        if (a[e1] != a[e2] && a[e2] != a[e3] && a[e3] != a[e4] && a[e4] != a[e5]) {
            var pivot1 = a[e2];
            var pivot2 = a[e4];
            a[e2] = a[left];
            a[e4] = a[right];
             while (a[++less] < pivot1)
                ;
             while (a[--great] > pivot2)
                ;
            outer:
                for (var k = less - 1; ++k <= great; ) {
                    var ak = a[k];
                    if (ak < pivot1) {
                        a[k] = a[less];
                        a[less] = ak;
                        ++less;
                    } else if (ak > pivot2) {
                         while (a[great] > pivot2){
                            if (great-- == k) {
                                break outer;
                            }
                        }
                        if (a[great] < pivot1) {
                            a[k] = a[less];
                            a[less] = a[great];
                            ++less;
                        } else {
                            a[k] = a[great];
                        }
                        a[great] = ak;
                        --great;
                    }
                }
            a[left] = a[less - 1];
            a[less - 1] = pivot1;
            a[right] = a[great + 1];
            a[great + 1] = pivot2;
            DualPivotQuicksort.sortFloat4(a, left, less - 2, leftmost);
            DualPivotQuicksort.sortFloat4(a, great + 2, right, false);
            if (less < e1 && e5 < great) {
                 while (a[less] == pivot1){
                    ++less;
                }
                 while (a[great] == pivot2){
                    --great;
                }
                outer:
                    for (var k = less - 1; ++k <= great; ) {
                        var ak = a[k];
                        if (ak == pivot1) {
                            a[k] = a[less];
                            a[less] = ak;
                            ++less;
                        } else if (ak == pivot2) {
                             while (a[great] == pivot2){
                                if (great-- == k) {
                                    break outer;
                                }
                            }
                            if (a[great] == pivot1) {
                                a[k] = a[less];
                                a[less] = a[great];
                                ++less;
                            } else {
                                a[k] = a[great];
                            }
                            a[great] = ak;
                            --great;
                        }
                    }
            }
            DualPivotQuicksort.sortFloat4(a, less, great, false);
        } else {
            var pivot = a[e3];
            for (var k = less; k <= great; ++k) {
                if (a[k] == pivot) {
                    continue;
                }
                var ak = a[k];
                if (ak < pivot) {
                    a[k] = a[less];
                    a[less] = ak;
                    ++less;
                } else {
                     while (a[great] > pivot){
                        --great;
                    }
                    if (a[great] < pivot) {
                        a[k] = a[less];
                        a[less] = a[great];
                        ++less;
                    } else {
                        a[k] = a[great];
                    }
                    a[great] = ak;
                    --great;
                }
            }
            DualPivotQuicksort.sortFloat4(a, left, less - 1, leftmost);
            DualPivotQuicksort.sortFloat4(a, great + 1, right, false);
        }
    };
    /**
     *  Sorts the specified range of the array using the given
     *  workspace array slice if possible for merging
     * 
     *  @param a the array to be sorted
     *  @param left the index of the first element, inclusive, to be sorted
     *  @param right the index of the last element, inclusive, to be sorted
     *  @param work a workspace array (slice)
     *  @param workBase origin of usable space in work array
     *  @param workLen usable size of work array
     */
    constructor.sortDouble6 = function(a, left, right, work, workBase, workLen) {
         while (left <= right && Double.isNaN(a[right])){
            --right;
        }
        for (var k = right; --k >= left; ) {
            var ak = a[k];
            if (ak != ak) {
                a[k] = a[right];
                a[right] = ak;
                --right;
            }
        }
        DualPivotQuicksort.doSortDouble(a, left, right, work, workBase, workLen);
        var hi = right;
         while (left < hi){
            var middle = (left + hi) >>> 1;
            var middleValue = a[middle];
            if (middleValue < 0.0) {
                left = middle + 1;
            } else {
                hi = middle;
            }
        }
         while (left <= right && Double.doubleToRawLongBits(a[left]) < 0){
            ++left;
        }
        for (var k = left, p = left - 1; ++k <= right; ) {
            var ak = a[k];
            if (ak != 0.0) {
                break;
            }
            if (Double.doubleToRawLongBits(ak) < 0) {
                a[k] = 0.0;
                a[++p] = -0.0;
            }
        }
    };
    /**
     *  Sorts the specified range of the array.
     * 
     *  @param a the array to be sorted
     *  @param left the index of the first element, inclusive, to be sorted
     *  @param right the index of the last element, inclusive, to be sorted
     *  @param work a workspace array (slice)
     *  @param workBase origin of usable space in work array
     *  @param workLen usable size of work array
     */
    constructor.doSortDouble = function(a, left, right, work, workBase, workLen) {
        if (right - left < DualPivotQuicksort.QUICKSORT_THRESHOLD) {
            DualPivotQuicksort.sortDouble4(a, left, right, true);
            return;
        }
        var run = new Int32Array(DualPivotQuicksort.MAX_RUN_COUNT + 1);
        var count = 0;
        run[0] = left;
        for (var k = left; k < right; run[count] = k) {
            if (a[k] < a[k + 1]) {
                 while (++k <= right && a[k - 1] <= a[k])
                    ;
            } else if (a[k] > a[k + 1]) {
                 while (++k <= right && a[k - 1] >= a[k])
                    ;
                for (var lo = run[count] - 1, hi = k; ++lo < --hi; ) {
                    var t = a[lo];
                    a[lo] = a[hi];
                    a[hi] = t;
                }
            } else {
                for (var m = DualPivotQuicksort.MAX_RUN_LENGTH; ++k <= right && a[k - 1] == a[k]; ) {
                    if (--m == 0) {
                        DualPivotQuicksort.sortDouble4(a, left, right, true);
                        return;
                    }
                }
            }
            if (++count == DualPivotQuicksort.MAX_RUN_COUNT) {
                DualPivotQuicksort.sortDouble4(a, left, right, true);
                return;
            }
        }
        if (run[count] == right++) {
            run[++count] = right;
        } else if (count == 1) {
            return;
        }
        var odd = 0;
        for (var n = 1; (n <<= 1) < count; odd ^= 1) 
            ;
        var b;
        var ao, bo;
        var blen = right - left;
        if (work == null || workLen < blen || workBase + blen > work.length) {
            work = new Float64Array(blen);
            workBase = 0;
        }
        if (odd == 0) {
            System.arraycopy(a, left, work, workBase, blen);
            b = a;
            bo = 0;
            a = work;
            ao = workBase - left;
        } else {
            b = work;
            ao = 0;
            bo = workBase - left;
        }
        for (var last; count > 1; count = last) {
            for (var k = (last = 0) + 2; k <= count; k += 2) {
                var hi = run[k], mi = run[k - 1];
                for (var i = run[k - 2], p = i, q = mi; i < hi; ++i) {
                    if (q >= hi || p < mi && a[p + ao] <= a[q + ao]) {
                        b[i + bo] = a[p++ + ao];
                    } else {
                        b[i + bo] = a[q++ + ao];
                    }
                }
                run[++last] = hi;
            }
            if ((count & 1) != 0) {
                for (var i = right, lo = run[count - 1]; --i >= lo; b[i + bo] = a[i + ao]) 
                    ;
                run[++last] = right;
            }
            var t = a;
            a = b;
            b = t;
            var o = ao;
            ao = bo;
            bo = o;
        }
    };
    /**
     *  Sorts the specified range of the array by Dual-Pivot Quicksort.
     * 
     *  @param a the array to be sorted
     *  @param left the index of the first element, inclusive, to be sorted
     *  @param right the index of the last element, inclusive, to be sorted
     *  @param leftmost indicates if this part is the leftmost in the range
     */
    constructor.sortDouble4 = function(a, left, right, leftmost) {
        var length = right - left + 1;
        if (length < DualPivotQuicksort.INSERTION_SORT_THRESHOLD) {
            if (leftmost) {
                for (var i = left, j = i; i < right; j = ++i) {
                    var ai = a[i + 1];
                     while (ai < a[j]){
                        a[j + 1] = a[j];
                        if (j-- == left) {
                            break;
                        }
                    }
                    a[j + 1] = ai;
                }
            } else {
                do {
                    if (left >= right) {
                        return;
                    }
                } while (a[++left] >= a[left - 1]);
                for (var k = left; ++left <= right; k = ++left) {
                    var a1 = a[k], a2 = a[left];
                    if (a1 < a2) {
                        a2 = a1;
                        a1 = a[left];
                    }
                     while (a1 < a[--k]){
                        a[k + 2] = a[k];
                    }
                    a[++k + 1] = a1;
                     while (a2 < a[--k]){
                        a[k + 1] = a[k];
                    }
                    a[k + 1] = a2;
                }
                var last = a[right];
                 while (last < a[--right]){
                    a[right + 1] = a[right];
                }
                a[right + 1] = last;
            }
            return;
        }
        var seventh = (length >> 3) + (length >> 6) + 1;
        var e3 = (left + right) >>> 1;
        var e2 = e3 - seventh;
        var e1 = e2 - seventh;
        var e4 = e3 + seventh;
        var e5 = e4 + seventh;
        if (a[e2] < a[e1]) {
            var t = a[e2];
            a[e2] = a[e1];
            a[e1] = t;
        }
        if (a[e3] < a[e2]) {
            var t = a[e3];
            a[e3] = a[e2];
            a[e2] = t;
            if (t < a[e1]) {
                a[e2] = a[e1];
                a[e1] = t;
            }
        }
        if (a[e4] < a[e3]) {
            var t = a[e4];
            a[e4] = a[e3];
            a[e3] = t;
            if (t < a[e2]) {
                a[e3] = a[e2];
                a[e2] = t;
                if (t < a[e1]) {
                    a[e2] = a[e1];
                    a[e1] = t;
                }
            }
        }
        if (a[e5] < a[e4]) {
            var t = a[e5];
            a[e5] = a[e4];
            a[e4] = t;
            if (t < a[e3]) {
                a[e4] = a[e3];
                a[e3] = t;
                if (t < a[e2]) {
                    a[e3] = a[e2];
                    a[e2] = t;
                    if (t < a[e1]) {
                        a[e2] = a[e1];
                        a[e1] = t;
                    }
                }
            }
        }
        var less = left;
        var great = right;
        if (a[e1] != a[e2] && a[e2] != a[e3] && a[e3] != a[e4] && a[e4] != a[e5]) {
            var pivot1 = a[e2];
            var pivot2 = a[e4];
            a[e2] = a[left];
            a[e4] = a[right];
             while (a[++less] < pivot1)
                ;
             while (a[--great] > pivot2)
                ;
            outer:
                for (var k = less - 1; ++k <= great; ) {
                    var ak = a[k];
                    if (ak < pivot1) {
                        a[k] = a[less];
                        a[less] = ak;
                        ++less;
                    } else if (ak > pivot2) {
                         while (a[great] > pivot2){
                            if (great-- == k) {
                                break outer;
                            }
                        }
                        if (a[great] < pivot1) {
                            a[k] = a[less];
                            a[less] = a[great];
                            ++less;
                        } else {
                            a[k] = a[great];
                        }
                        a[great] = ak;
                        --great;
                    }
                }
            a[left] = a[less - 1];
            a[less - 1] = pivot1;
            a[right] = a[great + 1];
            a[great + 1] = pivot2;
            DualPivotQuicksort.sortDouble4(a, left, less - 2, leftmost);
            DualPivotQuicksort.sortDouble4(a, great + 2, right, false);
            if (less < e1 && e5 < great) {
                 while (a[less] == pivot1){
                    ++less;
                }
                 while (a[great] == pivot2){
                    --great;
                }
                outer:
                    for (var k = less - 1; ++k <= great; ) {
                        var ak = a[k];
                        if (ak == pivot1) {
                            a[k] = a[less];
                            a[less] = ak;
                            ++less;
                        } else if (ak == pivot2) {
                             while (a[great] == pivot2){
                                if (great-- == k) {
                                    break outer;
                                }
                            }
                            if (a[great] == pivot1) {
                                a[k] = a[less];
                                a[less] = a[great];
                                ++less;
                            } else {
                                a[k] = a[great];
                            }
                            a[great] = ak;
                            --great;
                        }
                    }
            }
            DualPivotQuicksort.sortDouble4(a, less, great, false);
        } else {
            var pivot = a[e3];
            for (var k = less; k <= great; ++k) {
                if (a[k] == pivot) {
                    continue;
                }
                var ak = a[k];
                if (ak < pivot) {
                    a[k] = a[less];
                    a[less] = ak;
                    ++less;
                } else {
                     while (a[great] > pivot){
                        --great;
                    }
                    if (a[great] < pivot) {
                        a[k] = a[less];
                        a[less] = a[great];
                        ++less;
                    } else {
                        a[k] = a[great];
                    }
                    a[great] = ak;
                    --great;
                }
            }
            DualPivotQuicksort.sortDouble4(a, left, less - 1, leftmost);
            DualPivotQuicksort.sortDouble4(a, great + 1, right, false);
        }
    };
}, {}, {});
var ByteArrayInputStream = function(_arguments) {
    InputStream.call(this);
    if (arguments.length == 1) {
        var buf = arguments[0];
        this.buf = buf;
        this.pos = 0;
        this.count = buf.length;
    } else if (arguments.length == 3) {
        var buf = arguments[0];
        var offset = stjs.trunc(arguments[1]);
        var length = stjs.trunc(arguments[2]);
        this.buf = buf;
        this.pos = offset;
        this.count = Math.min(offset + length, buf.length);
        this._mark = offset;
    }
};
ByteArrayInputStream = stjs.extend(ByteArrayInputStream, InputStream, [], function(constructor, prototype) {
    prototype.buf = null;
    prototype.pos = 0;
    prototype._mark = 0;
    prototype.count = 0;
    prototype.read0 = function() {
        return (this.pos < this.count) ? (this.buf[this.pos++] & 255) : -1;
    };
    prototype.read3 = function(b, off, len) {
        if (b == null) {
             throw new NullPointerException();
        } else if (off < 0 || len < 0 || len > b.length - off) {
             throw new IndexOutOfBoundsException();
        }
        if (this.pos >= this.count) {
            return -1;
        }
        var avail = this.count - this.pos;
        if (len > avail) {
            len = avail;
        }
        if (len <= 0) {
            return 0;
        }
        System.arraycopy(this.buf, this.pos, b, off, len);
        this.pos += len;
        return len;
    };
    prototype.skip = function(n) {
        var k = this.count - this.pos;
        if (n < k) {
            k = n < 0 ? 0 : n;
        }
        this.pos += k;
        return k;
    };
    prototype.available = function() {
        return this.count - this.pos;
    };
    prototype.markSupported = function() {
        return true;
    };
    prototype.mark = function(readAheadLimit) {
        this._mark = this.pos;
    };
    prototype.reset = function() {
        this.pos = this._mark;
    };
    prototype.close = function() {};
}, {buf: "Int8Array"}, {});
var ConcurrentLinkedQueue = function() {
    LinkedList.call(this);
};
ConcurrentLinkedQueue = stjs.extend(ConcurrentLinkedQueue, LinkedList, [], null, {_array: {name: "Array", arguments: ["T"]}}, {});
var LinkedBlockingQueue = function() {
    LinkedList.call(this);
};
LinkedBlockingQueue = stjs.extend(LinkedBlockingQueue, LinkedList, [BlockingQueue], function(constructor, prototype) {
    prototype.take = function() {
         throw new RuntimeException("TODO BlockingQueue<E>.take");
    };
    prototype.put = function(ret) {
         throw new RuntimeException("TODO BlockingQueue<E>.put");
    };
}, {_array: {name: "Array", arguments: ["T"]}}, {});
var HashMap = function() {
    this._map = {};
};
HashMap = stjs.extend(HashMap, null, [Map], function(constructor, prototype) {
    prototype._map = null;
    prototype.entrySet = function() {
         throw new RuntimeException("TODO Map<K,V>.entrySet");
    };
    prototype.get = function(k) {
        return this._map[this.makeKey(k)];
    };
    prototype.size = function() {
         throw new RuntimeException("TODO Map<K,V>.size");
    };
    prototype.put = function(k, v) {
        var key = this.makeKey(k);
        var old = this._map[key];
        this._map[key] = v;
        return old;
    };
    prototype.makeKey = function(k) {
        if (k != null) {
            if ("string" == (typeof k) || "number" == (typeof k)) {
                return "" + k;
            }
            var _toString = (k)["toString"];
            if (_toString != null) {
                try {
                    var str = (_toString).call(k);
                    return str;
                }catch (e) {}
            }
            if ("function" == (typeof k)) {
                var name = (k)["name"];
                if (name != null && name != "") {
                    return name;
                }
            }
        }
        console.error("key", k);
         throw new IllegalArgumentException("supported key types: string, number, Function.name, anything.toString()");
    };
    prototype.containsKey = function(k) {
        var v = this._map[this.makeKey(k)];
        return v != null;
    };
    prototype.values = function() {
        var vals = new ArrayList();
        for (var key in this._map) {
            vals.add(this._map[key]);
        }
        return vals;
    };
    prototype.putAll = function(map) {
         throw new RuntimeException("TODO Map<K,V>.putAll");
    };
    prototype.clear = function() {
        this._map = {};
    };
    prototype.remove = function(k) {
         throw new RuntimeException("TODO Map<K,V>.remove");
    };
    prototype.keySet = function() {
         throw new RuntimeException("TODO Map<K,V>.keySet");
    };
}, {_map: {name: "Map", arguments: [null, "V"]}}, {});
var Arrays = function() {};
Arrays = stjs.extend(Arrays, null, [], function(constructor, prototype) {
    constructor.asList = function(_arguments) {
        if (arguments.length == 1 && ((arguments[0]).constructor)["name"] == "Array") {
            var o = arguments[0];
            return ArrayList.fromArray(o);
        } else if (arguments.length > 0) {
            var o = arguments;
            return ArrayList.fromArray(o);
        } else {
            return new ArrayList();
        }
    };
    constructor.fill = function(_arguments) {
        if (arguments.length == 2) {
            var a = arguments[0];
            var val = arguments[1];
            for (var i = 0, len = a.length; i < len; i++) 
                a[i] = val;
        } else if (arguments.length == 4) {
            var a = arguments[0];
            var fromIndex = stjs.trunc(arguments[1]);
            var toIndex = stjs.trunc(arguments[2]);
            var val = arguments[3];
            Arrays.rangeCheck(a.length, fromIndex, toIndex);
            for (var i = fromIndex; i < toIndex; i++) 
                a[i] = val;
        } else {
             throw new RuntimeException("TODO fill " + arguments.length);
        }
    };
    constructor.sort = function(_arguments) {
        if (arguments.length == 1 && Int32Array == (arguments[0]).constructor) {
            var a = arguments[0];
            DualPivotQuicksort.sortInt6(a, 0, a.length - 1, null, 0, 0);
        } else if (arguments.length == 2) {
            var a = arguments[0];
            var cmp = arguments[1];
            a.sort(function(_a, _b) {
                return cmp.compare(_a, _b);
            });
        } else {
            console.log("arguments", arguments);
             throw new RuntimeException("TODO sort " + arguments);
        }
    };
    constructor.hashCode = function(a) {
         throw new RuntimeException("TODO");
    };
    constructor.binarySearch = function(array, key) {
         throw new RuntimeException("TODO");
    };
    /**
     *  Checks that {@code fromIndex} and {@code toIndex} are in the range and
     *  throws an exception if they aren't.
     */
    constructor.rangeCheck = function(arrayLength, fromIndex, toIndex) {
        if (fromIndex > toIndex) {
             throw new IllegalArgumentException("fromIndex(" + fromIndex + ") > toIndex(" + toIndex + ")");
        }
        if (fromIndex < 0) {
             throw new ArrayIndexOutOfBoundsException(fromIndex);
        }
        if (toIndex > arrayLength) {
             throw new ArrayIndexOutOfBoundsException(toIndex);
        }
    };
}, {}, {});
var FileInputStream = function(_arguments) {
    InputStream.call(this);
    if (arguments.length == 1) {
        var file = arguments[0];
        var buffer = FileInputStream.fs.readFileSync(file.getPath());
        this.arr = new Int8Array(buffer);
        this.bais = new ByteArrayInputStream(this.arr);
    } else {
         throw new RuntimeException("TODO FileInputStream.init");
    }
};
FileInputStream = stjs.extend(FileInputStream, InputStream, [], function(constructor, prototype) {
    constructor.fs = require("fs");
    prototype.arr = null;
    prototype.bais = null;
    prototype.read0 = function() {
        return this.bais.read0();
    };
    prototype.read1 = function(buf) {
        return this.bais.read1(buf);
    };
    prototype.read3 = function(buf, off, len) {
        return this.bais.read3(buf, off, len);
    };
    prototype.skip = function(n) {
        return this.bais.skip(n);
    };
    prototype.markSupported = function() {
        return this.bais.markSupported();
    };
    prototype.mark = function(readAheadLimit) {
        this.bais.mark(readAheadLimit);
    };
    prototype.reset = function() {
        this.bais.reset();
    };
    prototype.getChannel = function() {
        return new MockFileChannel(this.arr);
    };
    prototype.close = function() {};
    prototype.available = function() {
         throw new RuntimeException("TODO");
    };
}, {fs: "FS", arr: "Int8Array", bais: "ByteArrayInputStream"}, {});
var ConcurrentHashMap = function() {
    HashMap.call(this);
};
ConcurrentHashMap = stjs.extend(ConcurrentHashMap, HashMap, [ConcurrentMap], function(constructor, prototype) {
    prototype.putIfAbsent = function(key, value) {
        if (!this.containsKey(key)) {
            return this.put(key, value);
        }
        return null;
    };
}, {_map: {name: "Map", arguments: [null, "V"]}}, {});
var Collections = function() {};
Collections = stjs.extend(Collections, null, [], function(constructor, prototype) {
    constructor.singletonList = function(o) {
        return Arrays.asList(o);
    };
    constructor.synchronizedList = function(list) {
        return list;
    };
    constructor.sort = function(list, comparator) {
        var a = list.toArray(Array(0));
        Arrays.sort(a, comparator);
        var it = list.listIterator();
        for (var j = 0; j < a.length; j++) {
            var e = a[j];
            it.next();
            it.set(e);
        }
    };
    constructor.emptyList = function() {
        return new ArrayList();
    };
}, {}, {});
var Logger = function(ctx) {};
Logger = stjs.extend(Logger, null, [], function(constructor, prototype) {
    constructor.instance = new Logger("ctx");
    constructor.getLogger = function(string) {
        return Logger.instance;
    };
    prototype.log = function(_arguments) {
        console.log(arguments);
    };
    prototype.finest = function(string) {
        console.log(string);
    };
    prototype.warning = function(string) {
        console.log(string);
    };
    prototype.getHandlers = function() {
        return Collections.emptyList();
    };
    prototype.removeHandler = function(h) {};
    prototype.setLevel = function(all) {};
    prototype.addHandler = function(h) {};
}, {instance: "Logger"}, {});
//# sourceMappingURL=jslang.map
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license. 
 *  
 *  @author in-somnia
 */
var SBRConstants = function() {};
SBRConstants = stjs.extend(SBRConstants, null, [], function(constructor, prototype) {
    constructor.startMinTable = new Int32Array([7, 7, 10, 11, 12, 16, 16, 17, 24, 32, 35, 48]);
    constructor.offsetIndexTable = new Int32Array([5, 5, 4, 4, 4, 3, 2, 1, 0, 6, 6, 6]);
    constructor.OFFSET = [new Int32Array([-8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7]), new Int32Array([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 9, 11, 13]), new Int32Array([-5, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 9, 11, 13, 16]), new Int32Array([-6, -4, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 9, 11, 13, 16]), new Int32Array([-4, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 9, 11, 13, 16, 20]), new Int32Array([-2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 9, 11, 13, 16, 20, 24]), new Int32Array([0, 1, 2, 3, 4, 5, 6, 7, 9, 11, 13, 16, 20, 24, 28, 33])];
    constructor.EXTENSION_ID_PS = 2;
    constructor.MAX_NTSRHFG = 40;
    constructor.MAX_NTSR = 32;
    constructor.MAX_M = 49;
    constructor.MAX_L_E = 5;
    constructor.EXT_SBR_DATA = 13;
    constructor.EXT_SBR_DATA_CRC = 14;
    constructor.FIXFIX = 0;
    constructor.FIXVAR = 1;
    constructor.VARFIX = 2;
    constructor.VARVAR = 3;
    constructor.LO_RES = 0;
    constructor.HI_RES = 1;
    constructor.NO_TIME_SLOTS_960 = 15;
    constructor.NO_TIME_SLOTS = 16;
    constructor.RATE = 2;
    constructor.NOISE_FLOOR_OFFSET = 6;
    constructor.T_HFGEN = 8;
    constructor.T_HFADJ = 2;
}, {startMinTable: "Int32Array", offsetIndexTable: "Int32Array", OFFSET: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var Chunk = function(offset, startTv, sampleCount, sampleSize, sampleSizes, sampleDur, sampleDurs, entry) {
    this.offset = offset;
    this.startTv = startTv;
    this.sampleCount = sampleCount;
    this.sampleSize = sampleSize;
    this.sampleSizes = sampleSizes;
    this.sampleDur = sampleDur;
    this.sampleDurs = sampleDurs;
    this.entry = entry;
};
Chunk = stjs.extend(Chunk, null, [], function(constructor, prototype) {
    prototype.offset = 0;
    prototype.startTv = 0;
    prototype.sampleCount = 0;
    prototype.sampleSize = 0;
    prototype.sampleSizes = null;
    prototype.sampleDur = 0;
    prototype.sampleDurs = null;
    prototype.entry = 0;
    prototype.getOffset = function() {
        return this.offset;
    };
    prototype.getStartTv = function() {
        return this.startTv;
    };
    prototype.getSampleCount = function() {
        return this.sampleCount;
    };
    prototype.getSampleSize = function() {
        return this.sampleSize;
    };
    prototype.getSampleSizes = function() {
        return this.sampleSizes;
    };
    prototype.getSampleDur = function() {
        return this.sampleDur;
    };
    prototype.getSampleDurs = function() {
        return this.sampleDurs;
    };
    prototype.getEntry = function() {
        return this.entry;
    };
    prototype.getDuration = function() {
        if (this.sampleDur > 0) 
            return this.sampleDur * this.sampleCount;
        var sum = 0;
        for (var j = 0; j < this.sampleDurs.length; j++) {
            var i = this.sampleDurs[j];
            sum += i;
        }
        return sum;
    };
    prototype.getSize = function() {
        if (this.sampleSize > 0) 
            return this.sampleSize * this.sampleCount;
        var sum = 0;
        for (var j = 0; j < this.sampleSizes.length; j++) {
            var i = this.sampleSizes[j];
            sum += i;
        }
        return sum;
    };
}, {sampleSizes: "Int32Array", sampleDurs: "Int32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MathUtil = function() {};
MathUtil = stjs.extend(MathUtil, null, [], function(constructor, prototype) {
    constructor.logTab = new Int32Array([0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7]);
    constructor.reverseTab = new Int32Array([0, 128, 64, 192, 32, 160, 96, 224, 16, 144, 80, 208, 48, 176, 112, 240, 8, 136, 72, 200, 40, 168, 104, 232, 24, 152, 88, 216, 56, 184, 120, 248, 4, 132, 68, 196, 36, 164, 100, 228, 20, 148, 84, 212, 52, 180, 116, 244, 12, 140, 76, 204, 44, 172, 108, 236, 28, 156, 92, 220, 60, 188, 124, 252, 2, 130, 66, 194, 34, 162, 98, 226, 18, 146, 82, 210, 50, 178, 114, 242, 10, 138, 74, 202, 42, 170, 106, 234, 26, 154, 90, 218, 58, 186, 122, 250, 6, 134, 70, 198, 38, 166, 102, 230, 22, 150, 86, 214, 54, 182, 118, 246, 14, 142, 78, 206, 46, 174, 110, 238, 30, 158, 94, 222, 62, 190, 126, 254, 1, 129, 65, 193, 33, 161, 97, 225, 17, 145, 81, 209, 49, 177, 113, 241, 9, 137, 73, 201, 41, 169, 105, 233, 25, 153, 89, 217, 57, 185, 121, 249, 5, 133, 69, 197, 37, 165, 101, 229, 21, 149, 85, 213, 53, 181, 117, 245, 13, 141, 77, 205, 45, 173, 109, 237, 29, 157, 93, 221, 61, 189, 125, 253, 3, 131, 67, 195, 35, 163, 99, 227, 19, 147, 83, 211, 51, 179, 115, 243, 11, 139, 75, 203, 43, 171, 107, 235, 27, 155, 91, 219, 59, 187, 123, 251, 7, 135, 71, 199, 39, 167, 103, 231, 23, 151, 87, 215, 55, 183, 119, 247, 15, 143, 79, 207, 47, 175, 111, 239, 31, 159, 95, 223, 63, 191, 127, 255]);
    constructor.log2 = function(v) {
        var n = 0;
        if ((v & -65536) != 0) {
            v >>= 16;
            n += 16;
        }
        if ((v & 65280) != 0) {
            v >>= 8;
            n += 8;
        }
        n += MathUtil.logTab[v];
        return n;
    };
    constructor.log2l = function(v) {
        var n = 0;
        if ((v & -4294967296) != 0) {
            v >>= 32;
            n += 32;
        }
        if ((v & 4294901760) != 0) {
            v >>= 16;
            n += 16;
        }
        if ((v & 65280) != 0) {
            v >>= 8;
            n += 8;
        }
        n += MathUtil.logTab[((v) | 0)];
        return n;
    };
    constructor.log2Slow = function(val) {
        var i = 0;
         while ((val & -2147483648) == 0){
            val <<= 1;
            i++;
        }
        return 31 - i;
    };
    constructor.gcd = function(a, b) {
        if (b != 0) 
            return MathUtil.gcd(b, a % b);
         else 
            return a;
    };
    constructor.gcdLong = function(a, b) {
        if (b != 0) 
            return MathUtil.gcdLong(b, a % b);
         else 
            return a;
    };
    constructor.clip = function(val, from, to) {
        return val < from ? from : (val > to ? to : val);
    };
    constructor.clipMax = function(val, max) {
        return val < max ? val : max;
    };
    constructor.cubeRoot = function(n) {
        return 0;
    };
    constructor.reverse = function(b) {
        return MathUtil.reverseTab[b & 255];
    };
    constructor.nextPowerOfTwo = function(n) {
        n = n - 1;
        n = n | (n >> 1);
        n = n | (n >> 2);
        n = n | (n >> 4);
        n = n | (n >> 8);
        n = n | (n >> 16);
        n = n + 1;
        return n;
    };
    constructor.abs = function(val) {
        var sign = (val >> 31);
        return (val ^ sign) - sign;
    };
    constructor.golomb = function(signedLevel) {
        if (signedLevel == 0) 
            return 0;
        return (MathUtil.abs(signedLevel) << 1) - (~signedLevel >>> 31);
    };
    constructor.toSigned = function(val, sign) {
        return (val ^ sign) - sign;
    };
    constructor.sign = function(val) {
        return -(val >> 31);
    };
    constructor.wrap = function(picNo, maxFrames) {
        return picNo < 0 ? picNo + maxFrames : (picNo >= maxFrames ? picNo - maxFrames : picNo);
    };
    constructor.max3 = function(a, b, c) {
        return Math.max(Math.max(a, b), c);
    };
}, {logTab: "Int32Array", reverseTab: "Int32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  @author The JCodec project
 */
var Rect = function(x, y, width, height) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
};
Rect = stjs.extend(Rect, null, [], function(constructor, prototype) {
    prototype.x = 0;
    prototype.y = 0;
    prototype.width = 0;
    prototype.height = 0;
    prototype.getX = function() {
        return this.x;
    };
    prototype.getY = function() {
        return this.y;
    };
    prototype.getWidth = function() {
        return this.width;
    };
    prototype.getHeight = function() {
        return this.height;
    };
    prototype.hashCode = function() {
        var prime = 31;
        var result = 1;
        result = prime * result + this.height;
        result = prime * result + this.width;
        result = prime * result + this.x;
        result = prime * result + this.y;
        return result;
    };
    prototype.equals = function(obj) {
        if (this == obj) 
            return true;
        if (obj == null) 
            return false;
        if (this.getClass() != obj.getClass()) 
            return false;
        var other = obj;
        if (this.height != other.height) 
            return false;
        if (this.width != other.width) 
            return false;
        if (this.x != other.x) 
            return false;
        if (this.y != other.y) 
            return false;
        return true;
    };
    prototype.toString = function() {
        return "Rect [x=" + this.x + ", y=" + this.y + ", width=" + this.width + ", height=" + this.height + "]";
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var IDCT2x2 = function() {};
IDCT2x2 = stjs.extend(IDCT2x2, null, [], function(constructor, prototype) {
    constructor.idct = function(blk, off) {
        var x0 = blk[off], x1 = blk[off + 1], x2 = blk[off + 2], x3 = blk[off + 3];
        var t0 = x0 + x2;
        var t2 = x0 - x2;
        var t1 = x1 + x3;
        var t3 = x1 - x3;
        blk[off] = (t0 + t1) >> 3;
        blk[off + 1] = (t0 - t1) >> 3;
        blk[off + 2] = (t2 + t3) >> 3;
        blk[off + 3] = (t2 - t3) >> 3;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var AudioFormat = function(sampleRate, sampleSizeInBits, channelCount, signed, bigEndian) {
    this.sampleRate = sampleRate;
    this.sampleSizeInBits = sampleSizeInBits;
    this.channelCount = channelCount;
    this.signed = signed;
    this.bigEndian = bigEndian;
};
AudioFormat = stjs.extend(AudioFormat, null, [], function(constructor, prototype) {
    prototype.sampleRate = 0;
    prototype.sampleSizeInBits = 0;
    prototype.channelCount = 0;
    prototype.signed = false;
    prototype.bigEndian = false;
    constructor.STEREO_48K_S16_BE = new AudioFormat(48000, 16, 2, true, true);
    constructor.STEREO_48K_S16_LE = new AudioFormat(48000, 16, 2, true, false);
    constructor.STEREO_48K_S24_BE = new AudioFormat(48000, 24, 2, true, true);
    constructor.STEREO_48K_S24_LE = new AudioFormat(48000, 24, 2, true, false);
    constructor.MONO_48K_S16_BE = new AudioFormat(48000, 16, 1, true, true);
    constructor.MONO_48K_S16_LE = new AudioFormat(48000, 16, 1, true, false);
    constructor.MONO_48K_S24_BE = new AudioFormat(48000, 24, 1, true, true);
    constructor.MONO_48K_S24_LE = new AudioFormat(48000, 24, 1, true, false);
    constructor.STEREO_44K_S16_BE = new AudioFormat(44100, 16, 2, true, true);
    constructor.STEREO_44K_S16_LE = new AudioFormat(44100, 16, 2, true, false);
    constructor.STEREO_44K_S24_BE = new AudioFormat(44100, 24, 2, true, true);
    constructor.STEREO_44K_S24_LE = new AudioFormat(44100, 24, 2, true, false);
    constructor.MONO_44K_S16_BE = new AudioFormat(44100, 16, 1, true, true);
    constructor.MONO_44K_S16_LE = new AudioFormat(44100, 16, 1, true, false);
    constructor.MONO_44K_S24_BE = new AudioFormat(44100, 24, 1, true, true);
    constructor.MONO_44K_S24_LE = new AudioFormat(44100, 24, 1, true, false);
    constructor.STEREO_S16_BE = function(rate) {
        return new AudioFormat(rate, 16, 2, true, true);
    };
    constructor.STEREO_S16_LE = function(rate) {
        return new AudioFormat(rate, 16, 2, true, false);
    };
    constructor.STEREO_S24_BE = function(rate) {
        return new AudioFormat(rate, 24, 2, true, true);
    };
    constructor.STEREO_S24_LE = function(rate) {
        return new AudioFormat(rate, 24, 2, true, false);
    };
    constructor.MONO_S16_BE = function(rate) {
        return new AudioFormat(rate, 16, 1, true, true);
    };
    constructor.MONO_S16_LE = function(rate) {
        return new AudioFormat(rate, 16, 1, true, false);
    };
    constructor.MONO_S24_BE = function(rate) {
        return new AudioFormat(rate, 24, 1, true, true);
    };
    constructor.MONO_S24_LE = function(rate) {
        return new AudioFormat(rate, 24, 1, true, false);
    };
    constructor.NCH_48K_S16_BE = function(n) {
        return new AudioFormat(48000, 16, n, true, true);
    };
    constructor.NCH_48K_S16_LE = function(n) {
        return new AudioFormat(48000, 16, n, true, false);
    };
    constructor.NCH_48K_S24_BE = function(n) {
        return new AudioFormat(48000, 24, n, true, true);
    };
    constructor.NCH_48K_S24_LE = function(n) {
        return new AudioFormat(48000, 24, n, true, false);
    };
    constructor.NCH_44K_S16_BE = function(n) {
        return new AudioFormat(44100, 16, n, true, true);
    };
    constructor.NCH_44K_S16_LE = function(n) {
        return new AudioFormat(44100, 16, n, true, false);
    };
    constructor.NCH_44K_S24_BE = function(n) {
        return new AudioFormat(44100, 24, n, true, true);
    };
    constructor.NCH_44K_S24_LE = function(n) {
        return new AudioFormat(44100, 24, n, true, false);
    };
    constructor.createAudioFormat = function(format) {
        return new AudioFormat(format.sampleRate, format.sampleSizeInBits, format.channelCount, format.signed, format.bigEndian);
    };
    constructor.createAudioFormat2 = function(format, newSampleRate) {
        var af = new AudioFormat(format.sampleRate, format.sampleSizeInBits, format.channelCount, format.signed, format.bigEndian);
        af.sampleRate = newSampleRate;
        return af;
    };
    prototype.getChannels = function() {
        return this.channelCount;
    };
    prototype.getSampleSizeInBits = function() {
        return this.sampleSizeInBits;
    };
    prototype.getSampleRate = function() {
        return this.sampleRate;
    };
    prototype.getFrameSize = function() {
        return ((((this.sampleSizeInBits >> 3) * this.channelCount)) << 16 >> 16);
    };
    prototype.getFrameRate = function() {
        return this.sampleRate;
    };
    prototype.isBigEndian = function() {
        return this.bigEndian;
    };
    prototype.isSigned = function() {
        return this.signed;
    };
    prototype.bytesToFrames = function(bytes) {
        return stjs.trunc(bytes / (this.channelCount * this.sampleSizeInBits >> 3));
    };
    prototype.framesToBytes = function(samples) {
        return samples * (this.channelCount * this.sampleSizeInBits >> 3);
    };
    prototype.bytesToSamples = function(bytes) {
        return stjs.trunc(bytes / (this.sampleSizeInBits >> 3));
    };
    prototype.samplesToBytes = function(samples) {
        return samples * (this.sampleSizeInBits >> 3);
    };
}, {STEREO_48K_S16_BE: "AudioFormat", STEREO_48K_S16_LE: "AudioFormat", STEREO_48K_S24_BE: "AudioFormat", STEREO_48K_S24_LE: "AudioFormat", MONO_48K_S16_BE: "AudioFormat", MONO_48K_S16_LE: "AudioFormat", MONO_48K_S24_BE: "AudioFormat", MONO_48K_S24_LE: "AudioFormat", STEREO_44K_S16_BE: "AudioFormat", STEREO_44K_S16_LE: "AudioFormat", STEREO_44K_S24_BE: "AudioFormat", STEREO_44K_S24_LE: "AudioFormat", MONO_44K_S16_BE: "AudioFormat", MONO_44K_S16_LE: "AudioFormat", MONO_44K_S24_BE: "AudioFormat", MONO_44K_S24_LE: "AudioFormat"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Decoded audio samples
 *  
 *  @author The JCodec project
 *  
 */
var AudioBuffer = function(data, format, nFrames) {
    this.data = data;
    this.format = format;
    this.nFrames = nFrames;
};
AudioBuffer = stjs.extend(AudioBuffer, null, [], function(constructor, prototype) {
    prototype.data = null;
    prototype.format = null;
    prototype.nFrames = 0;
    prototype.getData = function() {
        return this.data;
    };
    prototype.getFormat = function() {
        return this.format;
    };
    prototype.getNFrames = function() {
        return this.nFrames;
    };
}, {data: "ByteBuffer", format: "AudioFormat"}, {});
var IDescriptorFactory = function() {};
IDescriptorFactory = stjs.extend(IDescriptorFactory, null, [], function(constructor, prototype) {
    prototype.byTag = function(tag) {};
}, {}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license. 
 * 
 *  @author in-somnia
 */
var IBitStream = function() {};
IBitStream = stjs.extend(IBitStream, null, [], function(constructor, prototype) {
    prototype.destroy = function() {};
    prototype.setData = function(data) {};
    prototype.byteAlign = function() {};
    prototype.reset = function() {};
    prototype.getPosition = function() {};
    prototype.getBitsLeft = function() {};
    prototype.readBits = function(n) {};
    prototype.readBit = function() {};
    prototype.readBool = function() {};
    prototype.peekBits = function(n) {};
    prototype.peekBit = function() {};
    prototype.skipBits = function(n) {};
    prototype.skipBit = function() {};
    prototype.maskBits = function(n) {};
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MPEGHeader = function() {};
MPEGHeader = stjs.extend(MPEGHeader, null, [], function(constructor, prototype) {
    prototype.write = function(bb) {};
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Tape timecode
 *  
 *  @author The JCodec project
 *  
 */
var TapeTimecode = function(hour, minute, second, frame, dropFrame) {
    this.hour = hour;
    this.minute = minute;
    this.second = second;
    this.frame = frame;
    this.dropFrame = dropFrame;
};
TapeTimecode = stjs.extend(TapeTimecode, null, [], function(constructor, prototype) {
    prototype.hour = 0;
    prototype.minute = 0;
    prototype.second = 0;
    prototype.frame = 0;
    prototype.dropFrame = false;
    prototype.getHour = function() {
        return this.hour;
    };
    prototype.getMinute = function() {
        return this.minute;
    };
    prototype.getSecond = function() {
        return this.second;
    };
    prototype.getFrame = function() {
        return this.frame;
    };
    prototype.isDropFrame = function() {
        return this.dropFrame;
    };
    prototype.toString = function() {
        return String.format("%02d:%02d:%02d", this.hour, this.minute, this.second) + (this.dropFrame ? ";" : ":") + String.format("%02d", this.frame);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  @author The JCodec project
 */
var Plane = function(data, size) {
    this.data = data;
    this.size = size;
};
Plane = stjs.extend(Plane, null, [], function(constructor, prototype) {
    prototype.data = null;
    prototype.size = null;
    prototype.getData = function() {
        return this.data;
    };
    prototype.getSize = function() {
        return this.size;
    };
}, {data: "Int32Array", size: "Size"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Size = function(width, height) {
    this.width = width;
    this.height = height;
};
Size = stjs.extend(Size, null, [], function(constructor, prototype) {
    prototype.width = 0;
    prototype.height = 0;
    prototype.getWidth = function() {
        return this.width;
    };
    prototype.getHeight = function() {
        return this.height;
    };
    prototype.hashCode = function() {
        var prime = 31;
        var result = 1;
        result = prime * result + this.height;
        result = prime * result + this.width;
        return result;
    };
    prototype.equals = function(obj) {
        if (this == obj) 
            return true;
        if (obj == null) 
            return false;
        if (this.getClass() != obj.getClass()) 
            return false;
        var other = obj;
        if (this.height != other.height) 
            return false;
        if (this.width != other.width) 
            return false;
        return true;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MPEGEncoder = function() {};
MPEGEncoder = stjs.extend(MPEGEncoder, null, [], null, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Codebook for ProRes codes
 *  
 *  @author The JCodec project
 *  
 */
var Codebook = function(riceOrder, expOrder, switchBits) {
    this.riceOrder = riceOrder;
    this.expOrder = expOrder;
    this.switchBits = switchBits;
    this.golombOffset = (1 << expOrder) - ((switchBits + 1) << riceOrder);
    this.golombBits = expOrder - switchBits - 1;
    this.riceMask = (1 << riceOrder) - 1;
};
Codebook = stjs.extend(Codebook, null, [], function(constructor, prototype) {
    prototype.riceOrder = 0;
    prototype.expOrder = 0;
    prototype.switchBits = 0;
    prototype.golombOffset = 0;
    prototype.golombBits = 0;
    prototype.riceMask = 0;
}, {}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 * 
 *  @author in-somnia
 */
var HCB = function() {};
HCB = stjs.extend(HCB, null, [], function(constructor, prototype) {
    constructor.ZERO_HCB = 0;
    constructor.ESCAPE_HCB = 11;
    constructor.NOISE_HCB = 13;
    constructor.INTENSITY_HCB2 = 14;
    constructor.INTENSITY_HCB = 15;
    constructor.FIRST_PAIR_HCB = 5;
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Virtual movie track
 *  
 *  @author The JCodec project
 *  
 */
var VirtualTrack = function() {};
VirtualTrack = stjs.extend(VirtualTrack, null, [], function(constructor, prototype) {
    prototype.nextPacket = function() {};
    prototype.getCodecMeta = function() {};
    prototype.getEdits = function() {};
    prototype.getPreferredTimescale = function() {};
    prototype.close = function() {};
    constructor.VirtualEdit = function(_in, duration) {
        this._in = _in;
        this.duration = duration;
    };
    constructor.VirtualEdit = stjs.extend(constructor.VirtualEdit, null, [], function(constructor, prototype) {
        prototype._in = 0.0;
        prototype.duration = 0.0;
        prototype.getIn = function() {
            return this._in;
        };
        prototype.getDuration = function() {
            return this.duration;
        };
    }, {}, {});
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  @author The JCodec project
 */
var Transform8Bit = function() {};
Transform8Bit = stjs.extend(Transform8Bit, null, [], function(constructor, prototype) {
    constructor.Levels = stjs.enumeration("STUDIO", "PC");
    prototype.transform = function(src, dst) {};
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var CodecMeta = function(fourcc, codecPrivate) {
    this.fourcc = fourcc;
    this.codecPrivate = codecPrivate;
};
CodecMeta = stjs.extend(CodecMeta, null, [], function(constructor, prototype) {
    prototype.fourcc = null;
    prototype.codecPrivate = null;
    prototype.getFourcc = function() {
        return this.fourcc;
    };
    prototype.getCodecPrivate = function() {
        return this.codecPrivate;
    };
}, {codecPrivate: "ByteBuffer"}, {});
/**
 *  
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var ColorSpace = function(name, nComp, compPlane, compWidth, compHeight) {
    this._name = name;
    this.nComp = nComp;
    this.compPlane = compPlane;
    this.compWidth = compWidth;
    this.compHeight = compHeight;
};
ColorSpace = stjs.extend(ColorSpace, null, [], function(constructor, prototype) {
    constructor._000 = new Int32Array([0, 0, 0]);
    constructor._011 = new Int32Array([0, 1, 1]);
    constructor._012 = new Int32Array([0, 1, 2]);
    constructor.BGR = new ColorSpace("BGR", 3, ColorSpace._000, ColorSpace._000, ColorSpace._000);
    constructor.RGB = new ColorSpace("RGB", 3, ColorSpace._000, ColorSpace._000, ColorSpace._000);
    constructor.YUV420 = new ColorSpace("YUV420", 3, ColorSpace._012, ColorSpace._011, ColorSpace._011);
    constructor.YUV420J = new ColorSpace("YUV420J", 3, ColorSpace._012, ColorSpace._011, ColorSpace._011);
    constructor.YUV422 = new ColorSpace("YUV422", 3, ColorSpace._012, ColorSpace._011, ColorSpace._000);
    constructor.YUV422J = new ColorSpace("YUV422J", 3, ColorSpace._012, ColorSpace._011, ColorSpace._000);
    constructor.YUV444 = new ColorSpace("YUV444", 3, ColorSpace._012, ColorSpace._000, ColorSpace._000);
    constructor.YUV444J = new ColorSpace("YUV444J", 3, ColorSpace._012, ColorSpace._000, ColorSpace._000);
    constructor.YUV422_10 = new ColorSpace("YUV422_10", 3, ColorSpace._012, ColorSpace._011, ColorSpace._000);
    constructor.GREY = new ColorSpace("GREY", 1, new Int32Array([0]), new Int32Array([0]), new Int32Array([0]));
    constructor.MONO = new ColorSpace("MONO", 1, ColorSpace._000, ColorSpace._000, ColorSpace._000);
    constructor.YUV444_10 = new ColorSpace("YUV444_10", 3, ColorSpace._012, ColorSpace._000, ColorSpace._000);
    constructor.MAX_PLANES = 4;
    prototype.nComp = 0;
    prototype.compPlane = null;
    prototype.compWidth = null;
    prototype.compHeight = null;
    prototype._name = null;
    prototype.toString = function() {
        return this._name;
    };
}, {_000: "Int32Array", _011: "Int32Array", _012: "Int32Array", BGR: "ColorSpace", RGB: "ColorSpace", YUV420: "ColorSpace", YUV420J: "ColorSpace", YUV422: "ColorSpace", YUV422J: "ColorSpace", YUV444: "ColorSpace", YUV444J: "ColorSpace", YUV422_10: "ColorSpace", GREY: "ColorSpace", MONO: "ColorSpace", YUV444_10: "ColorSpace", compPlane: "Int32Array", compWidth: "Int32Array", compHeight: "Int32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Codec = stjs.enumeration("MPEG2", "PRORES", "H264", "J2K", "MPEG4", "DV", "VC3", "V210", "ALAW", "AC3", "MP3", "MP2", "DTS", "PCM_DVD", "TRUEHD", "PCM", "ADPCM", "NELLYMOSER", "G711", "AAC", "SPEEX", "SORENSON", "FLASH_SCREEN_VIDEO", "VP6", "FLASH_SCREEN_V2");
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Creates MP4 file out of a set of samples
 *  
 *  @author The JCodec project
 *  
 */
var TrackType = function(handler) {
    this.handler = handler;
};
TrackType = stjs.extend(TrackType, null, [], function(constructor, prototype) {
    constructor.VIDEO = new TrackType("vide");
    constructor.SOUND = new TrackType("soun");
    constructor.TIMECODE = new TrackType("tmcd");
    constructor.HINT = new TrackType("hint");
    constructor.TEXT = new TrackType("text");
    constructor.HYPER_TEXT = new TrackType("wtxt");
    constructor.CC = new TrackType("clcp");
    constructor.SUB = new TrackType("sbtl");
    constructor.MUSIC = new TrackType("musi");
    constructor.MPEG1 = new TrackType("MPEG");
    constructor.SPRITE = new TrackType("sprt");
    constructor.TWEEN = new TrackType("twen");
    constructor.CHAPTERS = new TrackType("chap");
    constructor.THREE_D = new TrackType("qd3d");
    constructor.STREAMING = new TrackType("strm");
    constructor.OBJECTS = new TrackType("obje");
    constructor._values = [TrackType.VIDEO, TrackType.SOUND, TrackType.TIMECODE, TrackType.HINT, TrackType.TEXT, TrackType.HYPER_TEXT, TrackType.CC, TrackType.SUB, TrackType.MUSIC, TrackType.MPEG1, TrackType.SPRITE, TrackType.TWEEN, TrackType.CHAPTERS, TrackType.THREE_D, TrackType.STREAMING, TrackType.OBJECTS];
    prototype.handler = null;
    prototype.getHandler = function() {
        return this.handler;
    };
    constructor.fromHandler = function(handler) {
        for (var i = 0; i < TrackType._values.length; i++) {
            var val = TrackType._values[i];
            if (val.getHandler().equals(handler)) 
                return val;
        }
        return null;
    };
}, {VIDEO: "TrackType", SOUND: "TrackType", TIMECODE: "TrackType", HINT: "TrackType", TEXT: "TrackType", HYPER_TEXT: "TrackType", CC: "TrackType", SUB: "TrackType", MUSIC: "TrackType", MPEG1: "TrackType", SPRITE: "TrackType", TWEEN: "TrackType", CHAPTERS: "TrackType", THREE_D: "TrackType", STREAMING: "TrackType", OBJECTS: "TrackType", _values: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var Edit = function(duration, mediaTime, rate) {
    this.duration = duration;
    this.mediaTime = mediaTime;
    this.rate = rate;
};
Edit = stjs.extend(Edit, null, [], function(constructor, prototype) {
    constructor.createEdit = function(edit) {
        return new Edit(edit.duration, edit.mediaTime, edit.rate);
    };
    prototype.duration = 0;
    prototype.mediaTime = 0;
    prototype.rate = 0.0;
    prototype.getDuration = function() {
        return this.duration;
    };
    prototype.getMediaTime = function() {
        return this.mediaTime;
    };
    prototype.getRate = function() {
        return this.rate;
    };
    prototype.shift = function(shift) {
        this.mediaTime += shift;
    };
    prototype.setMediaTime = function(l) {
        this.mediaTime = l;
    };
    prototype.setDuration = function(duration) {
        this.duration = duration;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A pool of open data channels used to read data
 *  
 *  @author The JCodec project
 *  
 */
var ByteChannelPool = function() {};
ByteChannelPool = stjs.extend(ByteChannelPool, null, [], function(constructor, prototype) {
    prototype.getChannel = function() {};
    prototype.close = function() {};
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Mapper = function() {};
Mapper = stjs.extend(Mapper, null, [], function(constructor, prototype) {
    prototype.leftAvailable = function(index) {};
    prototype.topAvailable = function(index) {};
    prototype.getAddress = function(index) {};
    prototype.getMbX = function(mbIndex) {};
    prototype.getMbY = function(mbIndex) {};
    prototype.topRightAvailable = function(mbIndex) {};
    prototype.topLeftAvailable = function(mbIdx) {};
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  NAL unit type
 *  
 *  @author The JCodec project
 *  
 */
var NALUnitType = function(value, displayName) {
    this.value = value;
    this.displayName = displayName;
};
NALUnitType = stjs.extend(NALUnitType, null, [], function(constructor, prototype) {
    constructor.NON_IDR_SLICE = new NALUnitType(1, "non IDR slice");
    constructor.SLICE_PART_A = new NALUnitType(2, "slice part a");
    constructor.SLICE_PART_B = new NALUnitType(3, "slice part b");
    constructor.SLICE_PART_C = new NALUnitType(4, "slice part c");
    constructor.IDR_SLICE = new NALUnitType(5, "idr slice");
    constructor.SEI = new NALUnitType(6, "sei");
    constructor.SPS = new NALUnitType(7, "sequence parameter set");
    constructor.PPS = new NALUnitType(8, "picture parameter set");
    constructor.ACC_UNIT_DELIM = new NALUnitType(9, "access unit delimiter");
    constructor.END_OF_SEQ = new NALUnitType(10, "end of sequence");
    constructor.END_OF_STREAM = new NALUnitType(11, "end of stream");
    constructor.FILLER_DATA = new NALUnitType(12, "filler data");
    constructor.SEQ_PAR_SET_EXT = new NALUnitType(13, "sequence parameter set extension");
    constructor.AUX_SLICE = new NALUnitType(19, "auxilary slice");
    constructor.lut = null;
    constructor._values = null;
    prototype.value = 0;
    prototype.displayName = null;
    prototype.getName = function() {
        return this.displayName;
    };
    prototype.getValue = function() {
        return this.value;
    };
    constructor.fromValue = function(value) {
        return value < NALUnitType.lut.length ? NALUnitType.lut[value] : null;
    };
}, {NON_IDR_SLICE: "NALUnitType", SLICE_PART_A: "NALUnitType", SLICE_PART_B: "NALUnitType", SLICE_PART_C: "NALUnitType", IDR_SLICE: "NALUnitType", SEI: "NALUnitType", SPS: "NALUnitType", PPS: "NALUnitType", ACC_UNIT_DELIM: "NALUnitType", END_OF_SEQ: "NALUnitType", END_OF_STREAM: "NALUnitType", FILLER_DATA: "NALUnitType", SEQ_PAR_SET_EXT: "NALUnitType", AUX_SLICE: "NALUnitType", lut: "Array", _values: "Array"}, {});
(function() {
    NALUnitType._values = [NALUnitType.NON_IDR_SLICE, NALUnitType.SLICE_PART_A, NALUnitType.SLICE_PART_B, NALUnitType.SLICE_PART_C, NALUnitType.IDR_SLICE, NALUnitType.SEI, NALUnitType.SPS, NALUnitType.PPS, NALUnitType.ACC_UNIT_DELIM, NALUnitType.END_OF_SEQ, NALUnitType.END_OF_STREAM, NALUnitType.FILLER_DATA, NALUnitType.SEQ_PAR_SET_EXT, NALUnitType.AUX_SLICE];
    NALUnitType.lut = Array(256);
    for (var i = 0; i < NALUnitType._values.length; i++) {
        var nalUnitType = NALUnitType._values[i];
        NALUnitType.lut[nalUnitType.value] = nalUnitType;
    }
})();
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A segment of a virtual movie file. Can contain a header of frame data.
 *  
 *  @author The JCodec project
 *  
 */
var MovieSegment = function() {};
MovieSegment = stjs.extend(MovieSegment, null, [], function(constructor, prototype) {
    prototype.getData = function() {};
    prototype.getNo = function() {};
    prototype.getPos = function() {};
    prototype.getDataLen = function() {};
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Meta information about this media track.
 *  
 *  @author The JCodec project
 *  
 */
var DemuxerTrackMeta = function(type, codec, seekFrames, totalFrames, totalDuration, dimensions, codecPrivate) {
    this.type = type;
    this.codec = codec;
    this.seekFrames = seekFrames;
    this.totalFrames = totalFrames;
    this.totalDuration = totalDuration;
    this.dimensions = dimensions;
    this.codecPrivate = codecPrivate;
};
DemuxerTrackMeta = stjs.extend(DemuxerTrackMeta, null, [], function(constructor, prototype) {
    constructor.Type = stjs.enumeration("VIDEO", "AUDIO", "OTHER");
    prototype.type = null;
    prototype.codec = null;
    prototype.seekFrames = null;
    prototype.totalFrames = 0;
    prototype.totalDuration = 0.0;
    prototype.dimensions = null;
    prototype.codecPrivate = null;
    prototype.pixelAspectRatio = null;
    prototype.getType = function() {
        return this.type;
    };
    prototype.getCodec = function() {
        return this.codec;
    };
    /**
     *  @return Array of frame indexes that can be used to seek to, i.e. which
     *          don't require any previous frames to be decoded. Is null when
     *          every frame is a seek frame.
     */
    prototype.getSeekFrames = function() {
        return this.seekFrames;
    };
    /**
     *  @return Total number of frames in this media track.
     */
    prototype.getTotalFrames = function() {
        return this.totalFrames;
    };
    /**
     *  @return Total duration in seconds of the media track
     */
    prototype.getTotalDuration = function() {
        return this.totalDuration;
    };
    prototype.getDimensions = function() {
        return this.dimensions;
    };
    prototype.getCodecPrivate = function() {
        return this.codecPrivate;
    };
    prototype.getPixelAspectRatio = function() {
        return this.pixelAspectRatio;
    };
    prototype.setPixelAspectRatio = function(pixelAspectRatio) {
        this.pixelAspectRatio = pixelAspectRatio;
    };
}, {type: {name: "Enum", arguments: ["DemuxerTrackMeta.Type"]}, codec: {name: "Enum", arguments: ["Codec"]}, seekFrames: "Int32Array", dimensions: "Size", codecPrivate: "Int8Array", pixelAspectRatio: "Rational"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  This code is borrowed from ffmpeg/libavcodec/h264_cabac.c
 *  
 *  @author The JCodec project
 *  
 */
var CABACContst = function() {};
CABACContst = stjs.extend(CABACContst, null, [], function(constructor, prototype) {
    constructor.cabac_context_init_I_A = new Int32Array([20, 2, 3, 20, 2, 3, -28, -23, -6, -1, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -9, 4, 0, -7, 13, 3, 0, 1, 0, -17, -13, 0, -7, -21, -27, -31, -24, -18, -27, -21, -30, -17, -12, -16, -11, -12, -2, -15, -13, -3, -8, -10, -30, -1, -6, -7, -20, -4, -5, -7, -22, -7, -11, -3, -5, -4, -4, -12, -7, -7, 8, 5, -2, 1, 0, -2, 1, 7, 10, 0, 11, 1, 0, 5, 31, 1, 7, 28, 16, 14, -13, -15, -13, -13, -12, -10, -16, -10, -7, -13, -19, 1, 0, -5, 18, -8, -15, 0, -4, 2, -11, -3, 15, -13, 0, 0, 21, -15, 9, 16, 0, 12, 24, 15, 8, 13, 15, 13, 10, 12, 6, 20, 15, 4, 1, 0, 7, 12, 11, 15, 11, 13, 16, 12, 10, 30, 18, 10, 17, 17, 0, 26, 22, 26, 30, 28, 33, 37, 33, 40, 38, 33, 40, 41, 38, 41, 30, 27, 26, 37, 35, 38, 38, 37, 38, 42, 35, 39, 14, 27, 21, 12, 2, -3, -6, -5, -3, -2, 0, 1, -2, -1, -9, -5, -5, -3, -2, 0, -16, -8, -10, -6, -10, -12, -15, -10, -6, -4, -12, -8, -7, -9, -17, -11, -20, -11, -6, -4, -13, -13, -11, -19, -8, -5, -4, -2, -3, -13, -10, -12, -13, -14, 0, -6, -6, -8, 0, -1, 0, -2, -2, -5, -3, -4, -9, -1, 0, 3, 10, -7, 15, 14, 16, 12, 1, 20, 18, 5, 1, 10, 17, 9, -12, -11, -16, -7, -8, -7, -9, -13, 4, -3, -3, -6, 10, -1, -1, -7, -14, 2, 0, -5, 0, -11, 1, 0, -14, 3, 4, -1, -13, 11, 5, 12, 15, 6, 7, 12, 18, 13, 13, 15, 12, 13, 15, 14, 14, 17, 17, 24, 21, 25, 31, 22, 19, 14, 10, 7, -2, -4, -3, 9, -12, 36, 36, 32, 37, 44, 34, 34, 40, 33, 35, 33, 38, 33, 23, 13, 29, 26, 22, 31, 35, 34, 34, 36, 34, 32, 35, 34, 39, 30, 34, 29, 19, 31, 31, 25, -17, -20, -18, -11, -15, -14, -26, -15, -14, 0, -14, -24, -23, -24, -11, 23, 26, 40, 49, 44, 45, 44, 33, 19, -3, -1, 1, 1, 0, -2, 0, 1, 0, -9, -14, -13, -15, -12, -18, -10, -9, -14, -10, -10, -10, -5, -9, -5, 2, 21, 24, 28, 28, 29, 29, 35, 29, 14, -17, -12, -16, -11, -12, -2, -15, -13, -3, -8, -10, -30, -17, -12, -16, -11, -12, -2, -15, -13, -3, -8, -10, -30, -7, -11, -3, -5, -4, -4, -12, -7, -7, 8, 5, -2, 1, 0, -2, 1, 7, 10, 0, 11, 1, 0, 5, 31, 1, 7, 28, 16, 14, -13, -15, -13, -13, -12, -10, -16, -10, -7, -13, -19, 1, 0, -5, 18, -7, -11, -3, -5, -4, -4, -12, -7, -7, 8, 5, -2, 1, 0, -2, 1, 7, 10, 0, 11, 1, 0, 5, 31, 1, 7, 28, 16, 14, -13, -15, -13, -13, -12, -10, -16, -10, -7, -13, -19, 1, 0, -5, 18, 24, 15, 8, 13, 15, 13, 10, 12, 6, 20, 15, 4, 1, 0, 7, 12, 11, 15, 11, 13, 16, 12, 10, 30, 18, 10, 17, 17, 0, 26, 22, 26, 30, 28, 33, 37, 33, 40, 38, 33, 40, 41, 38, 41, 24, 15, 8, 13, 15, 13, 10, 12, 6, 20, 15, 4, 1, 0, 7, 12, 11, 15, 11, 13, 16, 12, 10, 30, 18, 10, 17, 17, 0, 26, 22, 26, 30, 28, 33, 37, 33, 40, 38, 33, 40, 41, 38, 41, -17, -20, -18, -11, -15, -14, -26, -15, -14, 0, -14, -24, -23, -24, -11, -14, -13, -15, -12, -18, -10, -9, -14, -10, -10, -10, -5, -9, -5, 2, 23, 26, 40, 49, 44, 45, 44, 33, 19, 21, 24, 28, 28, 29, 29, 35, 29, 14, -3, -1, 1, 1, 0, -2, 0, 1, 0, -9, -17, -20, -18, -11, -15, -14, -26, -15, -14, 0, -14, -24, -23, -24, -11, -14, -13, -15, -12, -18, -10, -9, -14, -10, -10, -10, -5, -9, -5, 2, 23, 26, 40, 49, 44, 45, 44, 33, 19, 21, 24, 28, 28, 29, 29, 35, 29, 14, -3, -1, 1, 1, 0, -2, 0, 1, 0, -9, -6, -6, -8, 0, -1, 0, -2, -2, -5, -3, -4, -9, -1, 0, 3, 10, -7, 15, 14, 16, 12, 1, 20, 18, 5, 1, 10, 17, 9, -12, -11, -16, -7, -8, -7, -9, -13, 4, -3, -3, -6, 10, -1, -1, -6, -6, -8, 0, -1, 0, -2, -2, -5, -3, -4, -9, -1, 0, 3, 10, -7, 15, 14, 16, 12, 1, 20, 18, 5, 1, 10, 17, 9, -12, -11, -16, -7, -8, -7, -9, -13, 4, -3, -3, -6, 10, -1, -1, 15, 6, 7, 12, 18, 13, 13, 15, 12, 13, 15, 14, 14, 17, 17, 24, 21, 25, 31, 22, 19, 14, 10, 7, -2, -4, -3, 9, -12, 36, 36, 32, 37, 44, 34, 34, 40, 33, 35, 33, 38, 33, 23, 13, 15, 6, 7, 12, 18, 13, 13, 15, 12, 13, 15, 14, 14, 17, 17, 24, 21, 25, 31, 22, 19, 14, 10, 7, -2, -4, -3, 9, -12, 36, 36, 32, 37, 44, 34, 34, 40, 33, 35, 33, 38, 33, 23, 13, -3, -6, -5, -3, -2, 0, 1, -2, -1, -9, -5, -5, -3, -2, 0, -16, -8, -10, -6, -10, -12, -15, -10, -6, -4, -12, -8, -7, -9, -17, -3, -6, -5, -3, -2, 0, 1, -2, -1, -9, -5, -5, -3, -2, 0, -16, -8, -10, -6, -10, -12, -15, -10, -6, -4, -12, -8, -7, -9, -17, -3, -8, -10, -30, -3, -8, -10, -30, -3, -8, -10, -30]);
    constructor.cabac_context_init_I_B = new Int32Array([-15, 54, 74, -15, 54, 74, 127, 104, 53, 54, 51, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41, 63, 63, 63, 83, 86, 97, 72, 41, 62, 11, 55, 69, 127, 102, 82, 74, 107, 127, 127, 127, 95, 127, 114, 127, 123, 115, 122, 115, 63, 68, 84, 104, 70, 93, 90, 127, 74, 97, 91, 127, 56, 82, 76, 125, 93, 87, 77, 71, 63, 68, 84, 62, 65, 61, 56, 66, 64, 61, 78, 50, 52, 35, 44, 38, 45, 46, 44, 17, 51, 50, 19, 33, 62, 108, 100, 101, 91, 94, 88, 84, 86, 83, 87, 94, 70, 72, 74, 59, 102, 100, 95, 75, 72, 75, 71, 46, 69, 62, 65, 37, 72, 57, 54, 62, 72, 0, 9, 25, 18, 9, 19, 37, 18, 29, 33, 30, 45, 58, 62, 61, 38, 45, 39, 42, 44, 45, 41, 49, 34, 42, 55, 51, 46, 89, -19, -17, -17, -25, -20, -23, -27, -23, -28, -17, -11, -15, -6, 1, 17, -6, 3, 22, -16, -4, -8, -3, 3, 5, 0, 16, 22, 48, 37, 60, 68, 97, 71, 42, 50, 54, 62, 58, 63, 72, 74, 91, 67, 27, 39, 44, 46, 64, 68, 78, 77, 86, 92, 55, 60, 62, 65, 73, 76, 80, 88, 110, 97, 84, 79, 73, 74, 86, 96, 97, 117, 78, 33, 48, 53, 62, 71, 79, 86, 90, 97, 0, 93, 84, 79, 66, 71, 62, 60, 59, 75, 62, 58, 66, 79, 71, 68, 44, 62, 36, 40, 27, 29, 44, 36, 32, 42, 48, 62, 46, 64, 104, 97, 96, 88, 85, 85, 85, 88, 66, 77, 76, 76, 58, 76, 83, 99, 95, 95, 76, 74, 70, 75, 68, 65, 73, 62, 62, 68, 75, 55, 64, 70, 6, 19, 16, 14, 13, 11, 15, 16, 23, 23, 20, 26, 44, 40, 47, 17, 21, 22, 27, 29, 35, 50, 57, 63, 77, 82, 94, 69, 109, -35, -34, -26, -30, -32, -18, -15, -15, -7, -5, 0, 2, 13, 35, 58, -3, 0, 30, -7, -15, -3, 3, -1, 5, 11, 5, 12, 11, 29, 26, 39, 66, 21, 31, 50, 120, 112, 114, 85, 92, 89, 71, 81, 80, 68, 70, 56, 68, 50, 74, -13, -13, -15, -14, 3, 6, 34, 54, 82, 75, 23, 34, 43, 54, 55, 61, 64, 68, 92, 106, 97, 90, 90, 88, 73, 79, 86, 73, 70, 69, 66, 64, 58, 59, -10, -11, -8, -1, 3, 9, 20, 36, 67, 123, 115, 122, 115, 63, 68, 84, 104, 70, 93, 90, 127, 123, 115, 122, 115, 63, 68, 84, 104, 70, 93, 90, 127, 93, 87, 77, 71, 63, 68, 84, 62, 65, 61, 56, 66, 64, 61, 78, 50, 52, 35, 44, 38, 45, 46, 44, 17, 51, 50, 19, 33, 62, 108, 100, 101, 91, 94, 88, 84, 86, 83, 87, 94, 70, 72, 74, 59, 93, 87, 77, 71, 63, 68, 84, 62, 65, 61, 56, 66, 64, 61, 78, 50, 52, 35, 44, 38, 45, 46, 44, 17, 51, 50, 19, 33, 62, 108, 100, 101, 91, 94, 88, 84, 86, 83, 87, 94, 70, 72, 74, 59, 0, 9, 25, 18, 9, 19, 37, 18, 29, 33, 30, 45, 58, 62, 61, 38, 45, 39, 42, 44, 45, 41, 49, 34, 42, 55, 51, 46, 89, -19, -17, -17, -25, -20, -23, -27, -23, -28, -17, -11, -15, -6, 1, 17, 0, 9, 25, 18, 9, 19, 37, 18, 29, 33, 30, 45, 58, 62, 61, 38, 45, 39, 42, 44, 45, 41, 49, 34, 42, 55, 51, 46, 89, -19, -17, -17, -25, -20, -23, -27, -23, -28, -17, -11, -15, -6, 1, 17, 120, 112, 114, 85, 92, 89, 71, 81, 80, 68, 70, 56, 68, 50, 74, 106, 97, 90, 90, 88, 73, 79, 86, 73, 70, 69, 66, 64, 58, 59, -13, -13, -15, -14, 3, 6, 34, 54, 82, -10, -11, -8, -1, 3, 9, 20, 36, 67, 75, 23, 34, 43, 54, 55, 61, 64, 68, 92, 120, 112, 114, 85, 92, 89, 71, 81, 80, 68, 70, 56, 68, 50, 74, 106, 97, 90, 90, 88, 73, 79, 86, 73, 70, 69, 66, 64, 58, 59, -13, -13, -15, -14, 3, 6, 34, 54, 82, -10, -11, -8, -1, 3, 9, 20, 36, 67, 75, 23, 34, 43, 54, 55, 61, 64, 68, 92, 93, 84, 79, 66, 71, 62, 60, 59, 75, 62, 58, 66, 79, 71, 68, 44, 62, 36, 40, 27, 29, 44, 36, 32, 42, 48, 62, 46, 64, 104, 97, 96, 88, 85, 85, 85, 88, 66, 77, 76, 76, 58, 76, 83, 93, 84, 79, 66, 71, 62, 60, 59, 75, 62, 58, 66, 79, 71, 68, 44, 62, 36, 40, 27, 29, 44, 36, 32, 42, 48, 62, 46, 64, 104, 97, 96, 88, 85, 85, 85, 88, 66, 77, 76, 76, 58, 76, 83, 6, 19, 16, 14, 13, 11, 15, 16, 23, 23, 20, 26, 44, 40, 47, 17, 21, 22, 27, 29, 35, 50, 57, 63, 77, 82, 94, 69, 109, -35, -34, -26, -30, -32, -18, -15, -15, -7, -5, 0, 2, 13, 35, 58, 6, 19, 16, 14, 13, 11, 15, 16, 23, 23, 20, 26, 44, 40, 47, 17, 21, 22, 27, 29, 35, 50, 57, 63, 77, 82, 94, 69, 109, -35, -34, -26, -30, -32, -18, -15, -15, -7, -5, 0, 2, 13, 35, 58, 71, 42, 50, 54, 62, 58, 63, 72, 74, 91, 67, 27, 39, 44, 46, 64, 68, 78, 77, 86, 92, 55, 60, 62, 65, 73, 76, 80, 88, 110, 71, 42, 50, 54, 62, 58, 63, 72, 74, 91, 67, 27, 39, 44, 46, 64, 68, 78, 77, 86, 92, 55, 60, 62, 65, 73, 76, 80, 88, 110, 70, 93, 90, 127, 70, 93, 90, 127, 70, 93, 90, 127]);
    constructor.cabac_context_init_PB_A = [new Int32Array([20, 2, 3, 20, 2, 3, -28, -23, -6, -1, 7, 23, 23, 21, 1, 0, -37, 5, -13, -11, 1, 12, -4, 17, 18, 9, 29, 26, 16, 9, -46, -20, 1, -13, -11, 1, -6, -17, -6, 9, -3, -6, -11, 6, 7, -5, 2, 0, -3, -10, 5, 4, -3, 0, -7, -5, -4, -5, -7, 1, 0, 0, 0, 0, -9, 4, 0, -7, 13, 3, 0, -4, -3, -27, -28, -25, -23, -28, -20, -16, -22, -21, -18, -13, -29, -7, -5, -7, -13, -3, -1, -1, -9, -3, -9, -8, -23, 5, 6, 6, 6, -1, 0, -4, -8, -2, -6, -1, -7, 2, 5, -3, 1, 6, -4, 1, -4, 0, 2, -2, 11, 4, 1, 11, 18, 12, 13, 13, -10, -7, -2, 13, 9, -7, 9, 2, 5, -2, 0, 0, -13, -5, -1, 4, -6, 4, 14, 4, 13, 3, 1, 9, 7, 16, 5, 4, 11, -5, -1, 0, 22, 5, 14, -1, 0, 9, 11, 2, 3, 0, 0, 2, 2, 0, 4, 2, 6, 0, 3, 2, 4, 6, 6, 7, 6, 6, 11, 14, 8, -1, 7, -3, 15, 22, -1, 25, 30, 28, 28, 32, 34, 30, 30, 32, 31, 26, 26, 37, 28, 17, 1, 5, 9, 16, 18, 18, 22, 24, 23, 18, 20, 11, 9, 9, -1, -2, -9, -6, -2, 0, 0, -3, -2, -4, -4, -8, -17, -9, 3, 0, 0, 0, -6, -7, -12, -11, -30, 1, -3, -1, 1, 2, -6, 0, 0, -3, -10, 0, -4, 5, 7, 1, -2, -3, -3, -11, 0, 8, 10, 14, 13, 2, 0, -3, -6, -8, 0, -13, -16, -10, -21, -18, -14, -22, -21, -18, -21, -23, -26, -10, -12, -5, -9, -22, -5, 9, -4, -10, -1, 7, 9, 5, 12, 15, 18, 17, 10, 7, -1, 7, 8, 9, 6, 2, 13, 10, 6, 5, 13, 4, 6, -2, -2, 6, 10, 9, 12, 3, 14, 10, -3, 13, 17, 7, 7, 13, 10, 26, 14, 11, 9, 18, 21, 23, 32, 32, 34, 39, 42, 41, 46, 38, 21, 45, 53, 48, 65, 43, 39, 30, 18, 20, 0, -14, -5, -19, -35, 27, 28, 31, 27, 34, 30, 24, 33, 22, 26, 21, 26, 23, 16, 14, 8, 6, 17, 21, 23, 26, 27, 28, 28, 23, 24, 28, 23, 19, 22, 22, 11, 12, 11, 14, -4, -7, -5, -9, -8, -10, -19, -12, -16, -15, -20, -19, -16, -22, -20, 9, 26, 33, 39, 41, 45, 49, 45, 36, -6, -7, -7, -8, -5, -12, -6, -5, -8, -8, -5, -6, -10, -7, -17, -18, -4, -10, -9, -9, -1, -8, -14, 0, 2, 21, 33, 39, 46, 51, 60, 61, 55, 42, -7, -5, -7, -13, -3, -1, -1, -9, -3, -9, -8, -23, -7, -5, -7, -13, -3, -1, -1, -9, -3, -9, -8, -23, -2, -6, -1, -7, 2, 5, -3, 1, 6, -4, 1, -4, 0, 2, -2, 11, 4, 1, 11, 18, 12, 13, 13, -10, -7, -2, 13, 9, -7, 9, 2, 5, -2, 0, 0, -13, -5, -1, 4, -6, 4, 14, 4, 13, -2, -6, -1, -7, 2, 5, -3, 1, 6, -4, 1, -4, 0, 2, -2, 11, 4, 1, 11, 18, 12, 13, 13, -10, -7, -2, 13, 9, -7, 9, 2, 5, -2, 0, 0, -13, -5, -1, 4, -6, 4, 14, 4, 13, 11, 2, 3, 0, 0, 2, 2, 0, 4, 2, 6, 0, 3, 2, 4, 6, 6, 7, 6, 6, 11, 14, 8, -1, 7, -3, 15, 22, -1, 25, 30, 28, 28, 32, 34, 30, 30, 32, 31, 26, 26, 37, 28, 17, 11, 2, 3, 0, 0, 2, 2, 0, 4, 2, 6, 0, 3, 2, 4, 6, 6, 7, 6, 6, 11, 14, 8, -1, 7, -3, 15, 22, -1, 25, 30, 28, 28, 32, 34, 30, 30, 32, 31, 26, 26, 37, 28, 17, -4, -7, -5, -9, -8, -10, -19, -12, -16, -15, -20, -19, -16, -22, -20, -5, -6, -10, -7, -17, -18, -4, -10, -9, -9, -1, -8, -14, 0, 2, 9, 26, 33, 39, 41, 45, 49, 45, 36, 21, 33, 39, 46, 51, 60, 61, 55, 42, -6, -7, -7, -8, -5, -12, -6, -5, -8, -8, -4, -7, -5, -9, -8, -10, -19, -12, -16, -15, -20, -19, -16, -22, -20, -5, -6, -10, -7, -17, -18, -4, -10, -9, -9, -1, -8, -14, 0, 2, 9, 26, 33, 39, 41, 45, 49, 45, 36, 21, 33, 39, 46, 51, 60, 61, 55, 42, -6, -7, -7, -8, -5, -12, -6, -5, -8, -8, -13, -16, -10, -21, -18, -14, -22, -21, -18, -21, -23, -26, -10, -12, -5, -9, -22, -5, 9, -4, -10, -1, 7, 9, 5, 12, 15, 18, 17, 10, 7, -1, 7, 8, 9, 6, 2, 13, 10, 6, 5, 13, 4, 6, -13, -16, -10, -21, -18, -14, -22, -21, -18, -21, -23, -26, -10, -12, -5, -9, -22, -5, 9, -4, -10, -1, 7, 9, 5, 12, 15, 18, 17, 10, 7, -1, 7, 8, 9, 6, 2, 13, 10, 6, 5, 13, 4, 6, 14, 11, 9, 18, 21, 23, 32, 32, 34, 39, 42, 41, 46, 38, 21, 45, 53, 48, 65, 43, 39, 30, 18, 20, 0, -14, -5, -19, -35, 27, 28, 31, 27, 34, 30, 24, 33, 22, 26, 21, 26, 23, 16, 14, 14, 11, 9, 18, 21, 23, 32, 32, 34, 39, 42, 41, 46, 38, 21, 45, 53, 48, 65, 43, 39, 30, 18, 20, 0, -14, -5, -19, -35, 27, 28, 31, 27, 34, 30, 24, 33, 22, 26, 21, 26, 23, 16, 14, -6, -2, 0, 0, -3, -2, -4, -4, -8, -17, -9, 3, 0, 0, 0, -6, -7, -12, -11, -30, 1, -3, -1, 1, 2, -6, 0, 0, -3, -10, -6, -2, 0, 0, -3, -2, -4, -4, -8, -17, -9, 3, 0, 0, 0, -6, -7, -12, -11, -30, 1, -3, -1, 1, 2, -6, 0, 0, -3, -10, -3, -9, -8, -23, -3, -9, -8, -23, -3, -9, -8, -23]), new Int32Array([20, 2, 3, 20, 2, 3, -28, -23, -6, -1, 7, 22, 34, 16, -2, 4, -29, 2, -6, -13, 5, 9, -3, 10, 26, 19, 40, 57, 41, 26, -45, -15, -4, -6, -13, 5, 6, -13, 0, 8, -2, -5, -10, 2, 2, -3, -3, 1, -3, -6, 0, -3, -7, -5, -1, -1, 1, -2, -5, 0, 0, 0, 0, 0, -9, 4, 0, -7, 13, 3, 13, 7, 2, -39, -18, -17, -26, -35, -24, -23, -27, -24, -21, -18, -36, 0, -5, -7, -4, 0, 0, -15, -35, -2, -12, -9, -31, 3, 7, 7, 8, -3, 0, -7, -9, -13, -13, -9, -14, -8, -12, -23, -24, -10, -20, -17, -78, -70, -50, -46, -4, -5, -4, -8, 2, -1, -7, -6, -8, -34, -3, 32, 30, -44, 0, -5, 0, -1, -3, -8, -25, -14, -5, 5, 2, 0, -9, -11, 18, -4, 0, 7, 9, 18, 9, 5, 9, 0, 0, 2, 19, -4, 15, 12, 9, 0, 4, 10, 10, 33, 52, 18, 28, 35, 38, 34, 39, 32, 102, 0, 56, 33, 29, 37, 51, 39, 52, 69, 67, 44, 32, 55, 32, 0, 27, 33, 34, 36, 38, 38, 34, 35, 34, 32, 37, 35, 30, 28, 26, 29, 0, 2, 8, 14, 18, 17, 21, 17, 20, 18, 27, 16, 7, 16, 11, 10, -10, -23, -15, -7, 0, -5, -11, -9, -9, -10, -34, -21, -3, -5, -7, -11, -15, -17, -25, -25, -28, -11, -10, -10, -10, -9, -16, -7, -4, -5, -9, 2, -9, 1, 11, 5, -2, -2, 0, -8, 3, 7, 10, 17, 16, 3, -1, -5, -1, -4, 0, -21, -23, -20, -26, -25, -17, -27, -27, -17, -26, -27, -33, -10, -14, -8, -17, -28, -6, -2, -4, -9, -8, -1, 5, 1, 9, 0, 1, 7, -7, -6, -16, -2, 2, -6, -3, 2, -3, -3, 0, 9, -1, -2, -2, -1, -9, 14, 16, 0, 18, 11, 12, 10, 2, 12, 13, 0, 3, 19, 3, 18, 19, 18, 14, 26, 31, 33, 33, 37, 39, 42, 47, 45, 49, 41, 32, 69, 63, 66, 77, 54, 52, 41, 36, 40, 30, 28, 23, 12, 11, 37, 39, 40, 38, 46, 42, 40, 49, 38, 40, 38, 46, 31, 29, 25, 12, 11, 26, 22, 23, 27, 33, 26, 30, 27, 18, 25, 18, 12, 21, 14, 11, 25, 21, 21, -5, -6, -10, -7, -17, -18, -4, -10, -9, -9, -1, -8, -14, 0, 2, 17, 32, 42, 49, 53, 64, 68, 66, 47, -5, 0, -1, -2, -2, -9, -6, -4, -4, -7, -3, -3, -7, -6, -12, -14, -3, -6, -5, -5, 0, -4, -9, 1, 2, 17, 32, 42, 49, 53, 64, 68, 66, 47, 0, -5, -7, -4, 0, 0, -15, -35, -2, -12, -9, -31, 0, -5, -7, -4, 0, 0, -15, -35, -2, -12, -9, -31, -13, -13, -9, -14, -8, -12, -23, -24, -10, -20, -17, -78, -70, -50, -46, -4, -5, -4, -8, 2, -1, -7, -6, -8, -34, -3, 32, 30, -44, 0, -5, 0, -1, -3, -8, -25, -14, -5, 5, 2, 0, -9, -11, 18, -13, -13, -9, -14, -8, -12, -23, -24, -10, -20, -17, -78, -70, -50, -46, -4, -5, -4, -8, 2, -1, -7, -6, -8, -34, -3, 32, 30, -44, 0, -5, 0, -1, -3, -8, -25, -14, -5, 5, 2, 0, -9, -11, 18, 4, 10, 10, 33, 52, 18, 28, 35, 38, 34, 39, 32, 102, 0, 56, 33, 29, 37, 51, 39, 52, 69, 67, 44, 32, 55, 32, 0, 27, 33, 34, 36, 38, 38, 34, 35, 34, 32, 37, 35, 30, 28, 26, 29, 4, 10, 10, 33, 52, 18, 28, 35, 38, 34, 39, 32, 102, 0, 56, 33, 29, 37, 51, 39, 52, 69, 67, 44, 32, 55, 32, 0, 27, 33, 34, 36, 38, 38, 34, 35, 34, 32, 37, 35, 30, 28, 26, 29, -5, -6, -10, -7, -17, -18, -4, -10, -9, -9, -1, -8, -14, 0, 2, -3, -3, -7, -6, -12, -14, -3, -6, -5, -5, 0, -4, -9, 1, 2, 17, 32, 42, 49, 53, 64, 68, 66, 47, 17, 32, 42, 49, 53, 64, 68, 66, 47, -5, 0, -1, -2, -2, -9, -6, -4, -4, -7, -5, -6, -10, -7, -17, -18, -4, -10, -9, -9, -1, -8, -14, 0, 2, -3, -3, -7, -6, -12, -14, -3, -6, -5, -5, 0, -4, -9, 1, 2, 17, 32, 42, 49, 53, 64, 68, 66, 47, 17, 32, 42, 49, 53, 64, 68, 66, 47, -5, 0, -1, -2, -2, -9, -6, -4, -4, -7, -21, -23, -20, -26, -25, -17, -27, -27, -17, -26, -27, -33, -10, -14, -8, -17, -28, -6, -2, -4, -9, -8, -1, 5, 1, 9, 0, 1, 7, -7, -6, -16, -2, 2, -6, -3, 2, -3, -3, 0, 9, -1, -2, -2, -21, -23, -20, -26, -25, -17, -27, -27, -17, -26, -27, -33, -10, -14, -8, -17, -28, -6, -2, -4, -9, -8, -1, 5, 1, 9, 0, 1, 7, -7, -6, -16, -2, 2, -6, -3, 2, -3, -3, 0, 9, -1, -2, -2, 19, 18, 14, 26, 31, 33, 33, 37, 39, 42, 47, 45, 49, 41, 32, 69, 63, 66, 77, 54, 52, 41, 36, 40, 30, 28, 23, 12, 11, 37, 39, 40, 38, 46, 42, 40, 49, 38, 40, 38, 46, 31, 29, 25, 19, 18, 14, 26, 31, 33, 33, 37, 39, 42, 47, 45, 49, 41, 32, 69, 63, 66, 77, 54, 52, 41, 36, 40, 30, 28, 23, 12, 11, 37, 39, 40, 38, 46, 42, 40, 49, 38, 40, 38, 46, 31, 29, 25, -23, -15, -7, 0, -5, -11, -9, -9, -10, -34, -21, -3, -5, -7, -11, -15, -17, -25, -25, -28, -11, -10, -10, -10, -9, -16, -7, -4, -5, -9, -23, -15, -7, 0, -5, -11, -9, -9, -10, -34, -21, -3, -5, -7, -11, -15, -17, -25, -25, -28, -11, -10, -10, -10, -9, -16, -7, -4, -5, -9, -2, -12, -9, -31, -2, -12, -9, -31, -2, -12, -9, -31]), new Int32Array([20, 2, 3, 20, 2, 3, -28, -23, -6, -1, 7, 29, 25, 14, -10, -3, -27, 26, -4, -24, 5, 6, -17, 14, 20, 20, 29, 54, 37, 12, -32, -22, -2, -4, -24, 5, -6, -14, -6, 4, -11, -15, -21, 19, 20, 4, 6, 1, -5, -13, 5, 6, -3, -1, 3, -4, -2, -12, -7, 1, 0, 0, 0, 0, -9, 4, 0, -7, 13, 3, 7, -9, -20, -36, -17, -14, -25, -25, -12, -17, -31, -14, -18, -13, -37, 11, 5, 2, 5, -6, 4, -14, -37, -5, -11, -11, -30, 0, -2, 0, -4, -6, 3, -8, -13, -4, -12, -5, -3, -4, -8, -16, -9, -1, 5, 4, -4, -2, 2, -1, -4, -1, 0, -7, -4, -6, -3, -6, 8, -9, -11, 9, 0, -5, 1, -15, -5, -8, -21, -21, -13, -25, -29, 9, 17, -8, -5, -2, 13, 3, -7, 8, -10, 3, -3, -20, 0, 1, -3, -21, 16, -23, 17, 44, 50, -22, 4, 0, 7, 11, 8, 6, 7, 3, 8, 13, 13, 4, 3, 2, 6, 8, 11, 14, 7, 4, 4, 13, 9, 19, 10, 12, 0, 20, 8, 35, 33, 28, 24, 27, 34, 52, 39, 19, 31, 36, 24, 34, 30, 22, 20, 19, 27, 19, 15, 15, 21, 25, 30, 31, 27, 24, 0, 14, 15, 26, -24, -24, -22, -9, 0, 0, -14, -13, -13, -11, -29, -21, -14, -12, -11, -10, -21, -16, -23, -15, -37, -10, -8, -8, -8, -7, -14, -10, -9, -12, -18, -4, -22, -16, -2, 1, -13, -9, -4, -13, -13, -6, -13, -6, -2, -16, -10, -13, -9, -10, 0, -22, -25, -25, -27, -19, -23, -25, -26, -24, -28, -31, -37, -10, -15, -10, -13, -50, -5, 17, -5, -13, -12, -2, 0, -1, 4, -7, 5, 15, 1, 0, -10, 1, 0, 2, 0, -5, 7, 5, 2, 14, 15, 5, 2, -2, -18, 12, 5, -12, 11, 5, 0, 2, -6, 5, 7, -6, -11, -2, -2, 25, 17, 16, 17, 27, 37, 41, 42, 48, 39, 46, 52, 46, 52, 43, 32, 61, 56, 62, 81, 45, 35, 28, 34, 39, 30, 20, 18, 15, 0, 36, 37, 37, 32, 34, 29, 24, 34, 31, 35, 31, 33, 36, 27, 21, 18, 19, 36, 24, 27, 24, 31, 22, 22, 16, 15, 14, 3, -16, 21, 22, 25, 21, 19, 17, -3, -8, -9, -10, -18, -12, -11, -5, -17, -14, -16, -8, -14, -9, -11, 9, 30, 31, 33, 33, 31, 37, 31, 20, -9, -7, -8, -11, -10, -12, -8, -9, -6, -10, -3, -8, -9, -10, -18, -12, -11, -5, -17, -14, -16, -8, -14, -9, -11, 9, 30, 31, 33, 33, 31, 37, 31, 20, 11, 5, 2, 5, -6, 4, -14, -37, -5, -11, -11, -30, 11, 5, 2, 5, -6, 4, -14, -37, -5, -11, -11, -30, -4, -12, -5, -3, -4, -8, -16, -9, -1, 5, 4, -4, -2, 2, -1, -4, -1, 0, -7, -4, -6, -3, -6, 8, -9, -11, 9, 0, -5, 1, -15, -5, -8, -21, -21, -13, -25, -29, 9, 17, -8, -5, -2, 13, -4, -12, -5, -3, -4, -8, -16, -9, -1, 5, 4, -4, -2, 2, -1, -4, -1, 0, -7, -4, -6, -3, -6, 8, -9, -11, 9, 0, -5, 1, -15, -5, -8, -21, -21, -13, -25, -29, 9, 17, -8, -5, -2, 13, 4, 0, 7, 11, 8, 6, 7, 3, 8, 13, 13, 4, 3, 2, 6, 8, 11, 14, 7, 4, 4, 13, 9, 19, 10, 12, 0, 20, 8, 35, 33, 28, 24, 27, 34, 52, 39, 19, 31, 36, 24, 34, 30, 22, 4, 0, 7, 11, 8, 6, 7, 3, 8, 13, 13, 4, 3, 2, 6, 8, 11, 14, 7, 4, 4, 13, 9, 19, 10, 12, 0, 20, 8, 35, 33, 28, 24, 27, 34, 52, 39, 19, 31, 36, 24, 34, 30, 22, -3, -8, -9, -10, -18, -12, -11, -5, -17, -14, -16, -8, -14, -9, -11, -3, -8, -9, -10, -18, -12, -11, -5, -17, -14, -16, -8, -14, -9, -11, 9, 30, 31, 33, 33, 31, 37, 31, 20, 9, 30, 31, 33, 33, 31, 37, 31, 20, -9, -7, -8, -11, -10, -12, -8, -9, -6, -10, -3, -8, -9, -10, -18, -12, -11, -5, -17, -14, -16, -8, -14, -9, -11, -3, -8, -9, -10, -18, -12, -11, -5, -17, -14, -16, -8, -14, -9, -11, 9, 30, 31, 33, 33, 31, 37, 31, 20, 9, 30, 31, 33, 33, 31, 37, 31, 20, -9, -7, -8, -11, -10, -12, -8, -9, -6, -10, -22, -25, -25, -27, -19, -23, -25, -26, -24, -28, -31, -37, -10, -15, -10, -13, -50, -5, 17, -5, -13, -12, -2, 0, -1, 4, -7, 5, 15, 1, 0, -10, 1, 0, 2, 0, -5, 7, 5, 2, 14, 15, 5, 2, -22, -25, -25, -27, -19, -23, -25, -26, -24, -28, -31, -37, -10, -15, -10, -13, -50, -5, 17, -5, -13, -12, -2, 0, -1, 4, -7, 5, 15, 1, 0, -10, 1, 0, 2, 0, -5, 7, 5, 2, 14, 15, 5, 2, 17, 16, 17, 27, 37, 41, 42, 48, 39, 46, 52, 46, 52, 43, 32, 61, 56, 62, 81, 45, 35, 28, 34, 39, 30, 20, 18, 15, 0, 36, 37, 37, 32, 34, 29, 24, 34, 31, 35, 31, 33, 36, 27, 21, 17, 16, 17, 27, 37, 41, 42, 48, 39, 46, 52, 46, 52, 43, 32, 61, 56, 62, 81, 45, 35, 28, 34, 39, 30, 20, 18, 15, 0, 36, 37, 37, 32, 34, 29, 24, 34, 31, 35, 31, 33, 36, 27, 21, -24, -22, -9, 0, 0, -14, -13, -13, -11, -29, -21, -14, -12, -11, -10, -21, -16, -23, -15, -37, -10, -8, -8, -8, -7, -14, -10, -9, -12, -18, -24, -22, -9, 0, 0, -14, -13, -13, -11, -29, -21, -14, -12, -11, -10, -21, -16, -23, -15, -37, -10, -8, -8, -8, -7, -14, -10, -9, -12, -18, -5, -11, -11, -30, -5, -11, -11, -30, -5, -11, -11, -30])];
    constructor.cabac_context_init_PB_B = [new Int32Array([-15, 54, 74, -15, 54, 74, 127, 104, 53, 54, 51, 33, 2, 0, 9, 49, 118, 57, 78, 65, 62, 49, 73, 50, 64, 43, 0, 67, 90, 104, 127, 104, 67, 78, 65, 62, 86, 95, 61, 45, 69, 81, 96, 55, 67, 86, 88, 58, 76, 94, 54, 69, 81, 88, 67, 74, 74, 80, 72, 58, 41, 63, 63, 63, 83, 86, 97, 72, 41, 62, 45, 78, 96, 126, 98, 101, 67, 82, 94, 83, 110, 91, 102, 93, 127, 92, 89, 96, 108, 46, 65, 57, 93, 74, 92, 87, 126, 54, 60, 59, 69, 48, 68, 69, 88, 85, 78, 75, 77, 54, 50, 68, 50, 42, 81, 63, 70, 67, 57, 76, 35, 64, 61, 35, 25, 24, 29, 36, 93, 73, 73, 46, 49, 100, 53, 53, 53, 61, 56, 56, 63, 60, 62, 57, 69, 57, 39, 51, 68, 64, 61, 63, 50, 39, 44, 52, 48, 60, 59, 59, 33, 44, 43, 78, 60, 69, 28, 40, 44, 49, 46, 44, 51, 47, 39, 62, 46, 54, 54, 58, 63, 51, 57, 53, 52, 55, 45, 36, 53, 82, 55, 78, 46, 31, 84, 7, -7, 3, 4, 0, -1, 6, 6, 9, 19, 27, 30, 20, 34, 70, 67, 59, 67, 30, 32, 35, 29, 31, 38, 43, 41, 63, 59, 64, 94, 89, 108, 76, 44, 45, 52, 64, 59, 70, 75, 82, 102, 77, 24, 42, 48, 55, 59, 71, 83, 87, 119, 58, 29, 36, 38, 43, 55, 58, 64, 74, 90, 70, 29, 31, 42, 59, 58, 72, 81, 97, 58, 5, 14, 18, 27, 40, 58, 70, 79, 85, 0, 106, 106, 87, 114, 110, 98, 110, 106, 103, 107, 108, 112, 96, 95, 91, 93, 94, 86, 67, 80, 85, 70, 60, 58, 61, 50, 50, 49, 54, 41, 46, 51, 49, 52, 41, 47, 55, 41, 44, 50, 53, 49, 63, 64, 69, 59, 70, 44, 31, 43, 53, 34, 38, 52, 40, 32, 44, 38, 50, 57, 43, 11, 14, 11, 11, 9, -2, -15, -15, -21, -23, -33, -31, -28, -12, 29, -24, -45, -26, -43, -19, -10, 9, 26, 27, 57, 82, 75, 97, 125, 0, 0, -4, 6, 8, 10, 22, 19, 32, 31, 41, 44, 47, 65, 71, 60, 63, 65, 24, 20, 23, 32, 23, 24, 40, 32, 29, 42, 57, 53, 61, 86, 40, 51, 59, 79, 71, 69, 70, 66, 68, 73, 69, 70, 67, 62, 70, 66, 65, 63, -2, -9, -9, -7, -2, 3, 9, 27, 59, 66, 35, 42, 45, 48, 56, 60, 62, 66, 76, 85, 81, 77, 81, 80, 73, 74, 83, 71, 67, 61, 66, 66, 59, 59, -13, -14, -7, -2, 2, 6, 17, 34, 62, 92, 89, 96, 108, 46, 65, 57, 93, 74, 92, 87, 126, 92, 89, 96, 108, 46, 65, 57, 93, 74, 92, 87, 126, 85, 78, 75, 77, 54, 50, 68, 50, 42, 81, 63, 70, 67, 57, 76, 35, 64, 61, 35, 25, 24, 29, 36, 93, 73, 73, 46, 49, 100, 53, 53, 53, 61, 56, 56, 63, 60, 62, 57, 69, 57, 39, 51, 68, 85, 78, 75, 77, 54, 50, 68, 50, 42, 81, 63, 70, 67, 57, 76, 35, 64, 61, 35, 25, 24, 29, 36, 93, 73, 73, 46, 49, 100, 53, 53, 53, 61, 56, 56, 63, 60, 62, 57, 69, 57, 39, 51, 68, 28, 40, 44, 49, 46, 44, 51, 47, 39, 62, 46, 54, 54, 58, 63, 51, 57, 53, 52, 55, 45, 36, 53, 82, 55, 78, 46, 31, 84, 7, -7, 3, 4, 0, -1, 6, 6, 9, 19, 27, 30, 20, 34, 70, 28, 40, 44, 49, 46, 44, 51, 47, 39, 62, 46, 54, 54, 58, 63, 51, 57, 53, 52, 55, 45, 36, 53, 82, 55, 78, 46, 31, 84, 7, -7, 3, 4, 0, -1, 6, 6, 9, 19, 27, 30, 20, 34, 70, 79, 71, 69, 70, 66, 68, 73, 69, 70, 67, 62, 70, 66, 65, 63, 85, 81, 77, 81, 80, 73, 74, 83, 71, 67, 61, 66, 66, 59, 59, -2, -9, -9, -7, -2, 3, 9, 27, 59, -13, -14, -7, -2, 2, 6, 17, 34, 62, 66, 35, 42, 45, 48, 56, 60, 62, 66, 76, 79, 71, 69, 70, 66, 68, 73, 69, 70, 67, 62, 70, 66, 65, 63, 85, 81, 77, 81, 80, 73, 74, 83, 71, 67, 61, 66, 66, 59, 59, -2, -9, -9, -7, -2, 3, 9, 27, 59, -13, -14, -7, -2, 2, 6, 17, 34, 62, 66, 35, 42, 45, 48, 56, 60, 62, 66, 76, 106, 106, 87, 114, 110, 98, 110, 106, 103, 107, 108, 112, 96, 95, 91, 93, 94, 86, 67, 80, 85, 70, 60, 58, 61, 50, 50, 49, 54, 41, 46, 51, 49, 52, 41, 47, 55, 41, 44, 50, 53, 49, 63, 64, 106, 106, 87, 114, 110, 98, 110, 106, 103, 107, 108, 112, 96, 95, 91, 93, 94, 86, 67, 80, 85, 70, 60, 58, 61, 50, 50, 49, 54, 41, 46, 51, 49, 52, 41, 47, 55, 41, 44, 50, 53, 49, 63, 64, 11, 14, 11, 11, 9, -2, -15, -15, -21, -23, -33, -31, -28, -12, 29, -24, -45, -26, -43, -19, -10, 9, 26, 27, 57, 82, 75, 97, 125, 0, 0, -4, 6, 8, 10, 22, 19, 32, 31, 41, 44, 47, 65, 71, 11, 14, 11, 11, 9, -2, -15, -15, -21, -23, -33, -31, -28, -12, 29, -24, -45, -26, -43, -19, -10, 9, 26, 27, 57, 82, 75, 97, 125, 0, 0, -4, 6, 8, 10, 22, 19, 32, 31, 41, 44, 47, 65, 71, 76, 44, 45, 52, 64, 59, 70, 75, 82, 102, 77, 24, 42, 48, 55, 59, 71, 83, 87, 119, 58, 29, 36, 38, 43, 55, 58, 64, 74, 90, 76, 44, 45, 52, 64, 59, 70, 75, 82, 102, 77, 24, 42, 48, 55, 59, 71, 83, 87, 119, 58, 29, 36, 38, 43, 55, 58, 64, 74, 90, 74, 92, 87, 126, 74, 92, 87, 126, 74, 92, 87, 126]), new Int32Array([-15, 54, 74, -15, 54, 74, 127, 104, 53, 54, 51, 25, 0, 0, 9, 41, 118, 65, 71, 79, 52, 50, 70, 54, 34, 22, 0, 2, 36, 69, 127, 101, 76, 71, 79, 52, 69, 90, 52, 43, 69, 82, 96, 59, 75, 87, 100, 56, 74, 85, 59, 81, 86, 95, 66, 77, 70, 86, 72, 61, 41, 63, 63, 63, 83, 86, 97, 72, 41, 62, 15, 51, 80, 127, 91, 96, 81, 98, 102, 97, 119, 99, 110, 102, 127, 80, 89, 94, 92, 39, 65, 84, 127, 73, 104, 91, 127, 55, 56, 55, 61, 53, 68, 74, 88, 103, 91, 89, 92, 76, 87, 110, 105, 78, 112, 99, 127, 127, 127, 127, 66, 78, 71, 72, 59, 55, 70, 75, 89, 119, 75, 20, 22, 127, 54, 61, 58, 60, 61, 67, 84, 74, 65, 52, 57, 61, 69, 70, 55, 71, 58, 61, 41, 25, 32, 43, 47, 44, 51, 46, 38, 66, 38, 42, 34, 89, 45, 28, 31, -11, -43, 15, 0, -22, -25, 0, -18, -12, -94, 0, -15, -4, 10, -5, -29, -9, -34, -58, -63, -5, 7, -29, 1, 0, 36, -25, -30, -28, -28, -27, -18, -16, -14, -8, -6, 0, 10, 18, 25, 41, 75, 72, 77, 35, 31, 35, 30, 45, 42, 45, 26, 54, 66, 56, 73, 67, 116, 112, 71, 61, 53, 66, 77, 80, 84, 87, 127, 101, 39, 53, 61, 75, 77, 91, 107, 111, 122, 76, 44, 52, 57, 58, 72, 69, 69, 74, 86, 66, 34, 32, 31, 52, 55, 67, 73, 89, 52, 4, 8, 8, 19, 37, 61, 73, 70, 78, 0, 126, 124, 110, 126, 124, 105, 121, 117, 102, 117, 116, 122, 95, 100, 95, 111, 114, 89, 80, 82, 85, 81, 72, 64, 67, 56, 69, 69, 69, 69, 67, 77, 64, 61, 67, 64, 57, 65, 66, 62, 51, 66, 71, 75, 70, 72, 60, 37, 47, 35, 37, 41, 41, 48, 41, 41, 59, 50, 40, 66, 50, -6, -6, 0, -12, -16, -25, -22, -28, -30, -30, -42, -36, -34, -17, 9, -71, -63, -64, -74, -39, -35, -10, 0, -1, 14, 26, 37, 55, 65, -33, -36, -37, -30, -33, -30, -24, -29, -12, -10, -3, -5, 20, 30, 44, 48, 49, 45, 22, 22, 21, 20, 28, 24, 34, 42, 39, 50, 70, 54, 71, 83, 32, 49, 54, 85, 81, 77, 81, 80, 73, 74, 83, 71, 67, 61, 66, 66, 59, 59, -10, -13, -9, -5, 0, 3, 10, 27, 57, 71, 24, 36, 42, 52, 57, 63, 65, 67, 82, 81, 76, 72, 78, 72, 68, 70, 76, 66, 62, 57, 61, 60, 54, 58, -10, -13, -9, -5, 0, 3, 10, 27, 57, 80, 89, 94, 92, 39, 65, 84, 127, 73, 104, 91, 127, 80, 89, 94, 92, 39, 65, 84, 127, 73, 104, 91, 127, 103, 91, 89, 92, 76, 87, 110, 105, 78, 112, 99, 127, 127, 127, 127, 66, 78, 71, 72, 59, 55, 70, 75, 89, 119, 75, 20, 22, 127, 54, 61, 58, 60, 61, 67, 84, 74, 65, 52, 57, 61, 69, 70, 55, 103, 91, 89, 92, 76, 87, 110, 105, 78, 112, 99, 127, 127, 127, 127, 66, 78, 71, 72, 59, 55, 70, 75, 89, 119, 75, 20, 22, 127, 54, 61, 58, 60, 61, 67, 84, 74, 65, 52, 57, 61, 69, 70, 55, 45, 28, 31, -11, -43, 15, 0, -22, -25, 0, -18, -12, -94, 0, -15, -4, 10, -5, -29, -9, -34, -58, -63, -5, 7, -29, 1, 0, 36, -25, -30, -28, -28, -27, -18, -16, -14, -8, -6, 0, 10, 18, 25, 41, 45, 28, 31, -11, -43, 15, 0, -22, -25, 0, -18, -12, -94, 0, -15, -4, 10, -5, -29, -9, -34, -58, -63, -5, 7, -29, 1, 0, 36, -25, -30, -28, -28, -27, -18, -16, -14, -8, -6, 0, 10, 18, 25, 41, 85, 81, 77, 81, 80, 73, 74, 83, 71, 67, 61, 66, 66, 59, 59, 81, 76, 72, 78, 72, 68, 70, 76, 66, 62, 57, 61, 60, 54, 58, -10, -13, -9, -5, 0, 3, 10, 27, 57, -10, -13, -9, -5, 0, 3, 10, 27, 57, 71, 24, 36, 42, 52, 57, 63, 65, 67, 82, 85, 81, 77, 81, 80, 73, 74, 83, 71, 67, 61, 66, 66, 59, 59, 81, 76, 72, 78, 72, 68, 70, 76, 66, 62, 57, 61, 60, 54, 58, -10, -13, -9, -5, 0, 3, 10, 27, 57, -10, -13, -9, -5, 0, 3, 10, 27, 57, 71, 24, 36, 42, 52, 57, 63, 65, 67, 82, 126, 124, 110, 126, 124, 105, 121, 117, 102, 117, 116, 122, 95, 100, 95, 111, 114, 89, 80, 82, 85, 81, 72, 64, 67, 56, 69, 69, 69, 69, 67, 77, 64, 61, 67, 64, 57, 65, 66, 62, 51, 66, 71, 75, 126, 124, 110, 126, 124, 105, 121, 117, 102, 117, 116, 122, 95, 100, 95, 111, 114, 89, 80, 82, 85, 81, 72, 64, 67, 56, 69, 69, 69, 69, 67, 77, 64, 61, 67, 64, 57, 65, 66, 62, 51, 66, 71, 75, -6, -6, 0, -12, -16, -25, -22, -28, -30, -30, -42, -36, -34, -17, 9, -71, -63, -64, -74, -39, -35, -10, 0, -1, 14, 26, 37, 55, 65, -33, -36, -37, -30, -33, -30, -24, -29, -12, -10, -3, -5, 20, 30, 44, -6, -6, 0, -12, -16, -25, -22, -28, -30, -30, -42, -36, -34, -17, 9, -71, -63, -64, -74, -39, -35, -10, 0, -1, 14, 26, 37, 55, 65, -33, -36, -37, -30, -33, -30, -24, -29, -12, -10, -3, -5, 20, 30, 44, 112, 71, 61, 53, 66, 77, 80, 84, 87, 127, 101, 39, 53, 61, 75, 77, 91, 107, 111, 122, 76, 44, 52, 57, 58, 72, 69, 69, 74, 86, 112, 71, 61, 53, 66, 77, 80, 84, 87, 127, 101, 39, 53, 61, 75, 77, 91, 107, 111, 122, 76, 44, 52, 57, 58, 72, 69, 69, 74, 86, 73, 104, 91, 127, 73, 104, 91, 127, 73, 104, 91, 127]), new Int32Array([-15, 54, 74, -15, 54, 74, 127, 104, 53, 54, 51, 16, 0, 0, 51, 62, 99, 16, 85, 102, 57, 57, 73, 57, 40, 10, 0, 0, 42, 97, 127, 117, 74, 85, 102, 57, 93, 88, 44, 55, 89, 103, 116, 57, 58, 84, 96, 63, 85, 106, 63, 75, 90, 101, 55, 79, 75, 97, 50, 60, 41, 63, 63, 63, 83, 86, 97, 72, 41, 62, 34, 88, 127, 127, 91, 95, 84, 86, 89, 91, 127, 76, 103, 90, 127, 80, 76, 84, 78, 55, 61, 83, 127, 79, 104, 91, 127, 65, 79, 72, 92, 56, 68, 71, 98, 86, 88, 82, 72, 67, 72, 89, 69, 59, 66, 57, 71, 71, 58, 74, 44, 69, 62, 51, 47, 42, 41, 53, 76, 78, 83, 52, 67, 90, 67, 72, 75, 80, 83, 64, 31, 64, 94, 75, 63, 74, 35, 27, 91, 65, 69, 77, 66, 62, 68, 81, 30, 7, 23, 74, 66, 124, 37, -18, -34, 127, 39, 42, 34, 29, 31, 37, 42, 40, 33, 43, 36, 47, 55, 58, 60, 44, 44, 42, 48, 56, 52, 37, 49, 58, 48, 45, 69, 33, 63, -18, -25, -3, 10, 0, -14, -44, -24, 17, 25, 29, 33, 15, 20, 73, 34, 31, 44, 16, 36, 36, 28, 21, 20, 12, 16, 42, 93, 56, 57, 38, 127, 115, 82, 62, 53, 59, 85, 89, 94, 92, 127, 100, 57, 67, 71, 77, 85, 88, 104, 98, 127, 82, 48, 61, 66, 70, 75, 79, 83, 92, 108, 79, 69, 75, 58, 58, 78, 83, 81, 99, 81, 38, 62, 58, 59, 73, 76, 86, 83, 87, 0, 127, 127, 120, 127, 114, 117, 118, 117, 113, 118, 120, 124, 94, 102, 99, 106, 127, 92, 57, 86, 94, 91, 77, 71, 73, 64, 81, 64, 57, 67, 68, 67, 68, 77, 64, 68, 78, 55, 59, 65, 54, 44, 60, 70, 76, 86, 70, 64, 70, 55, 56, 69, 65, 74, 54, 54, 76, 82, 77, 77, 42, -13, -9, -12, -21, -30, -40, -41, -47, -32, -40, -51, -41, -39, -19, 11, -55, -46, -50, -67, -20, -2, 15, 1, 1, 17, 38, 45, 54, 79, -16, -14, -17, 1, 15, 15, 25, 22, 16, 18, 28, 41, 28, 47, 62, 31, 26, 24, 23, 16, 30, 29, 41, 42, 60, 52, 60, 78, 123, 53, 56, 61, 33, 50, 61, 78, 74, 72, 72, 75, 71, 63, 70, 75, 72, 67, 53, 59, 52, 68, -2, -10, -4, -1, 7, 12, 23, 38, 64, 71, 37, 44, 49, 56, 59, 63, 67, 68, 79, 78, 74, 72, 72, 75, 71, 63, 70, 75, 72, 67, 53, 59, 52, 68, -2, -10, -4, -1, 7, 12, 23, 38, 64, 80, 76, 84, 78, 55, 61, 83, 127, 79, 104, 91, 127, 80, 76, 84, 78, 55, 61, 83, 127, 79, 104, 91, 127, 86, 88, 82, 72, 67, 72, 89, 69, 59, 66, 57, 71, 71, 58, 74, 44, 69, 62, 51, 47, 42, 41, 53, 76, 78, 83, 52, 67, 90, 67, 72, 75, 80, 83, 64, 31, 64, 94, 75, 63, 74, 35, 27, 91, 86, 88, 82, 72, 67, 72, 89, 69, 59, 66, 57, 71, 71, 58, 74, 44, 69, 62, 51, 47, 42, 41, 53, 76, 78, 83, 52, 67, 90, 67, 72, 75, 80, 83, 64, 31, 64, 94, 75, 63, 74, 35, 27, 91, 39, 42, 34, 29, 31, 37, 42, 40, 33, 43, 36, 47, 55, 58, 60, 44, 44, 42, 48, 56, 52, 37, 49, 58, 48, 45, 69, 33, 63, -18, -25, -3, 10, 0, -14, -44, -24, 17, 25, 29, 33, 15, 20, 73, 39, 42, 34, 29, 31, 37, 42, 40, 33, 43, 36, 47, 55, 58, 60, 44, 44, 42, 48, 56, 52, 37, 49, 58, 48, 45, 69, 33, 63, -18, -25, -3, 10, 0, -14, -44, -24, 17, 25, 29, 33, 15, 20, 73, 78, 74, 72, 72, 75, 71, 63, 70, 75, 72, 67, 53, 59, 52, 68, 78, 74, 72, 72, 75, 71, 63, 70, 75, 72, 67, 53, 59, 52, 68, -2, -10, -4, -1, 7, 12, 23, 38, 64, -2, -10, -4, -1, 7, 12, 23, 38, 64, 71, 37, 44, 49, 56, 59, 63, 67, 68, 79, 78, 74, 72, 72, 75, 71, 63, 70, 75, 72, 67, 53, 59, 52, 68, 78, 74, 72, 72, 75, 71, 63, 70, 75, 72, 67, 53, 59, 52, 68, -2, -10, -4, -1, 7, 12, 23, 38, 64, -2, -10, -4, -1, 7, 12, 23, 38, 64, 71, 37, 44, 49, 56, 59, 63, 67, 68, 79, 127, 127, 120, 127, 114, 117, 118, 117, 113, 118, 120, 124, 94, 102, 99, 106, 127, 92, 57, 86, 94, 91, 77, 71, 73, 64, 81, 64, 57, 67, 68, 67, 68, 77, 64, 68, 78, 55, 59, 65, 54, 44, 60, 70, 127, 127, 120, 127, 114, 117, 118, 117, 113, 118, 120, 124, 94, 102, 99, 106, 127, 92, 57, 86, 94, 91, 77, 71, 73, 64, 81, 64, 57, 67, 68, 67, 68, 77, 64, 68, 78, 55, 59, 65, 54, 44, 60, 70, -13, -9, -12, -21, -30, -40, -41, -47, -32, -40, -51, -41, -39, -19, 11, -55, -46, -50, -67, -20, -2, 15, 1, 1, 17, 38, 45, 54, 79, -16, -14, -17, 1, 15, 15, 25, 22, 16, 18, 28, 41, 28, 47, 62, -13, -9, -12, -21, -30, -40, -41, -47, -32, -40, -51, -41, -39, -19, 11, -55, -46, -50, -67, -20, -2, 15, 1, 1, 17, 38, 45, 54, 79, -16, -14, -17, 1, 15, 15, 25, 22, 16, 18, 28, 41, 28, 47, 62, 115, 82, 62, 53, 59, 85, 89, 94, 92, 127, 100, 57, 67, 71, 77, 85, 88, 104, 98, 127, 82, 48, 61, 66, 70, 75, 79, 83, 92, 108, 115, 82, 62, 53, 59, 85, 89, 94, 92, 127, 100, 57, 67, 71, 77, 85, 88, 104, 98, 127, 82, 48, 61, 66, 70, 75, 79, 83, 92, 108, 79, 104, 91, 127, 79, 104, 91, 127, 79, 104, 91, 127])];
}, {cabac_context_init_I_A: "Int32Array", cabac_context_init_I_B: "Int32Array", cabac_context_init_PB_A: "Array", cabac_context_init_PB_B: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  @author The JCodec project
 */
var ImageConvert = function() {};
ImageConvert = stjs.extend(ImageConvert, null, [], function(constructor, prototype) {
    constructor.SCALEBITS = 10;
    constructor.ONE_HALF = (1 << (ImageConvert.SCALEBITS - 1));
    constructor.FIX = function(x) {
        return (stjs.trunc(((x) * (1 << ImageConvert.SCALEBITS) + 0.5)));
    };
    constructor.FIX_0_71414 = ImageConvert.FIX(0.71414);
    constructor.FIX_1_772 = ImageConvert.FIX(1.772);
    constructor._FIX_0_34414 = -ImageConvert.FIX(0.34414);
    constructor.FIX_1_402 = ImageConvert.FIX(1.402);
    constructor.ycbcr_to_rgb24 = function(y, cb, cr) {
        y = y << ImageConvert.SCALEBITS;
        cb = cb - 128;
        cr = cr - 128;
        var add_r = ImageConvert.FIX_1_402 * cr + ImageConvert.ONE_HALF;
        var add_g = ImageConvert._FIX_0_34414 * cb - ImageConvert.FIX_0_71414 * cr + ImageConvert.ONE_HALF;
        var add_b = ImageConvert.FIX_1_772 * cb + ImageConvert.ONE_HALF;
        var r = (y + add_r) >> ImageConvert.SCALEBITS;
        var g = (y + add_g) >> ImageConvert.SCALEBITS;
        var b = (y + add_b) >> ImageConvert.SCALEBITS;
        r = ImageConvert.crop(r);
        g = ImageConvert.crop(g);
        b = ImageConvert.crop(b);
        return ((r & 255) << 16) | ((g & 255) << 8) | (b & 255);
    };
    constructor.CROP = 1024;
    constructor.Y_JPEG_TO_CCIR = function(y) {
        return (((y) * ImageConvert.FIX(219.0 / 255.0) + (ImageConvert.ONE_HALF + (16 << ImageConvert.SCALEBITS))) >> ImageConvert.SCALEBITS);
    };
    constructor.Y_CCIR_TO_JPEG = function(y) {
        return ((y) * ImageConvert.FIX(255.0 / 219.0) + (ImageConvert.ONE_HALF - 16 * ImageConvert.FIX(255.0 / 219.0))) >> ImageConvert.SCALEBITS;
    };
    constructor.cropTable = new Int8Array(ImageConvert.CROP + 256 + ImageConvert.CROP);
    constructor.intCropTable = new Int32Array(ImageConvert.CROP + 256 + ImageConvert.CROP);
    constructor._y_ccir_to_jpeg = new Int8Array(256);
    constructor._y_jpeg_to_ccir = new Int8Array(256);
    constructor.icrop = function(i) {
        return ImageConvert.intCropTable[i + ImageConvert.CROP];
    };
    constructor.crop = function(i) {
        return ImageConvert.cropTable[i + ImageConvert.CROP];
    };
    constructor.y_ccir_to_jpeg = function(y) {
        return ImageConvert._y_ccir_to_jpeg[(y & 255)];
    };
    constructor.y_jpeg_to_ccir = function(y) {
        return ImageConvert._y_jpeg_to_ccir[(y & 255)];
    };
    constructor.YUV444toRGB888 = function(y, u, v, rgb) {
        var c = y - 16;
        var d = u - 128;
        var e = v - 128;
        var r = (298 * c + 409 * e + 128) >> 8;
        var g = (298 * c - 100 * d - 208 * e + 128) >> 8;
        var b = (298 * c + 516 * d + 128) >> 8;
        rgb.put(ImageConvert.crop(r));
        rgb.put(ImageConvert.crop(g));
        rgb.put(ImageConvert.crop(b));
    };
    constructor.RGB888toYUV444 = function(rgb, Y, U, V) {
        var r = rgb.get() & 255;
        var g = rgb.get() & 255;
        var b = rgb.get() & 255;
        var y = 66 * r + 129 * g + 25 * b;
        var u = -38 * r - 74 * g + 112 * b;
        var v = 112 * r - 94 * g - 18 * b;
        y = (y + 128) >> 8;
        u = (u + 128) >> 8;
        v = (v + 128) >> 8;
        Y.put(ImageConvert.crop(y + 16));
        U.put(ImageConvert.crop(u + 128));
        V.put(ImageConvert.crop(v + 128));
    };
    constructor.RGB888toY4 = function(r, g, b) {
        var y = 66 * r + 129 * g + 25 * b;
        y = (y + 128) >> 8;
        return ImageConvert.crop(y + 16);
    };
    constructor.RGB888toU4 = function(r, g, b) {
        var u = -38 * r - 74 * g + 112 * b;
        u = (u + 128) >> 8;
        return ImageConvert.crop(u + 128);
    };
    constructor.RGB888toV4 = function(r, g, b) {
        var v = 112 * r - 94 * g - 18 * b;
        v = (v + 128) >> 8;
        return ImageConvert.crop(v + 128);
    };
}, {cropTable: "Int8Array", intCropTable: "Int32Array", _y_ccir_to_jpeg: "Int8Array", _y_jpeg_to_ccir: "Int8Array"}, {});
(function() {
    for (var i = -ImageConvert.CROP; i < 0; i++) {
        ImageConvert.cropTable[i + ImageConvert.CROP] = 0;
        ImageConvert.intCropTable[i + ImageConvert.CROP] = 0;
    }
    for (var i = 0; i < 256; i++) {
        ImageConvert.cropTable[i + ImageConvert.CROP] = (i << 24 >> 24);
        ImageConvert.intCropTable[i + ImageConvert.CROP] = i;
    }
    for (var i = 256; i < ImageConvert.CROP; i++) {
        ImageConvert.cropTable[i + ImageConvert.CROP] = (255 << 24 >> 24);
        ImageConvert.intCropTable[i + ImageConvert.CROP] = 255;
    }
    for (var i = 0; i < 256; i++) {
        ImageConvert._y_ccir_to_jpeg[i] = ImageConvert.crop(ImageConvert.Y_CCIR_TO_JPEG(i));
        ImageConvert._y_jpeg_to_ccir[i] = ImageConvert.crop(ImageConvert.Y_JPEG_TO_CCIR(i));
    }
})();
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  @author The JCodec project
 *  @deprecated Use org.jcodec.scale.Transform8Bit and related APIs
 */
var Transform = function() {};
Transform = stjs.extend(Transform, null, [], function(constructor, prototype) {
    constructor.Levels = stjs.enumeration("STUDIO", "PC");
    prototype.transform = function(src, dst) {};
}, {}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 * 
 *  @author in-somnia
 */
var Codebooks = function() {};
Codebooks = stjs.extend(Codebooks, null, [], function(constructor, prototype) {
    constructor.HCB1 = [new Int32Array([1, 0, 0, 0, 0, 0]), new Int32Array([5, 16, 1, 0, 0, 0]), new Int32Array([5, 17, -1, 0, 0, 0]), new Int32Array([5, 18, 0, 0, 0, -1]), new Int32Array([5, 19, 0, 1, 0, 0]), new Int32Array([5, 20, 0, 0, 0, 1]), new Int32Array([5, 21, 0, 0, -1, 0]), new Int32Array([5, 22, 0, 0, 1, 0]), new Int32Array([5, 23, 0, -1, 0, 0]), new Int32Array([7, 96, 1, -1, 0, 0]), new Int32Array([7, 97, -1, 1, 0, 0]), new Int32Array([7, 98, 0, 0, -1, 1]), new Int32Array([7, 99, 0, 1, -1, 0]), new Int32Array([7, 100, 0, -1, 1, 0]), new Int32Array([7, 101, 0, 0, 1, -1]), new Int32Array([7, 102, 1, 1, 0, 0]), new Int32Array([7, 103, 0, 0, -1, -1]), new Int32Array([7, 104, -1, -1, 0, 0]), new Int32Array([7, 105, 0, -1, -1, 0]), new Int32Array([7, 106, 1, 0, -1, 0]), new Int32Array([7, 107, 0, 1, 0, -1]), new Int32Array([7, 108, -1, 0, 1, 0]), new Int32Array([7, 109, 0, 0, 1, 1]), new Int32Array([7, 110, 1, 0, 1, 0]), new Int32Array([7, 111, 0, -1, 0, 1]), new Int32Array([7, 112, 0, 1, 1, 0]), new Int32Array([7, 113, 0, 1, 0, 1]), new Int32Array([7, 114, -1, 0, -1, 0]), new Int32Array([7, 115, 1, 0, 0, 1]), new Int32Array([7, 116, -1, 0, 0, -1]), new Int32Array([7, 117, 1, 0, 0, -1]), new Int32Array([7, 118, -1, 0, 0, 1]), new Int32Array([7, 119, 0, -1, 0, -1]), new Int32Array([9, 480, 1, 1, -1, 0]), new Int32Array([9, 481, -1, 1, -1, 0]), new Int32Array([9, 482, 1, -1, 1, 0]), new Int32Array([9, 483, 0, 1, 1, -1]), new Int32Array([9, 484, 0, 1, -1, 1]), new Int32Array([9, 485, 0, -1, 1, 1]), new Int32Array([9, 486, 0, -1, 1, -1]), new Int32Array([9, 487, 1, -1, -1, 0]), new Int32Array([9, 488, 1, 0, -1, 1]), new Int32Array([9, 489, 0, 1, -1, -1]), new Int32Array([9, 490, -1, 1, 1, 0]), new Int32Array([9, 491, -1, 0, 1, -1]), new Int32Array([9, 492, -1, -1, 1, 0]), new Int32Array([9, 493, 0, -1, -1, 1]), new Int32Array([9, 494, 1, -1, 0, 1]), new Int32Array([9, 495, 1, -1, 0, -1]), new Int32Array([9, 496, -1, 1, 0, -1]), new Int32Array([9, 497, -1, -1, -1, 0]), new Int32Array([9, 498, 0, -1, -1, -1]), new Int32Array([9, 499, 0, 1, 1, 1]), new Int32Array([9, 500, 1, 0, 1, -1]), new Int32Array([9, 501, 1, 1, 0, 1]), new Int32Array([9, 502, -1, 1, 0, 1]), new Int32Array([9, 503, 1, 1, 1, 0]), new Int32Array([10, 1008, -1, -1, 0, 1]), new Int32Array([10, 1009, -1, 0, -1, -1]), new Int32Array([10, 1010, 1, 1, 0, -1]), new Int32Array([10, 1011, 1, 0, -1, -1]), new Int32Array([10, 1012, -1, 0, -1, 1]), new Int32Array([10, 1013, -1, -1, 0, -1]), new Int32Array([10, 1014, -1, 0, 1, 1]), new Int32Array([10, 1015, 1, 0, 1, 1]), new Int32Array([11, 2032, 1, -1, 1, -1]), new Int32Array([11, 2033, -1, 1, -1, 1]), new Int32Array([11, 2034, -1, 1, 1, -1]), new Int32Array([11, 2035, 1, -1, -1, 1]), new Int32Array([11, 2036, 1, 1, 1, 1]), new Int32Array([11, 2037, -1, -1, 1, 1]), new Int32Array([11, 2038, 1, 1, -1, -1]), new Int32Array([11, 2039, -1, -1, 1, -1]), new Int32Array([11, 2040, -1, -1, -1, -1]), new Int32Array([11, 2041, 1, 1, -1, 1]), new Int32Array([11, 2042, 1, -1, 1, 1]), new Int32Array([11, 2043, -1, 1, 1, 1]), new Int32Array([11, 2044, -1, 1, -1, -1]), new Int32Array([11, 2045, -1, -1, -1, 1]), new Int32Array([11, 2046, 1, -1, -1, -1]), new Int32Array([11, 2047, 1, 1, 1, -1])];
    constructor.HCB2 = [new Int32Array([3, 0, 0, 0, 0, 0]), new Int32Array([4, 2, 1, 0, 0, 0]), new Int32Array([5, 6, -1, 0, 0, 0]), new Int32Array([5, 7, 0, 0, 0, 1]), new Int32Array([5, 8, 0, 0, -1, 0]), new Int32Array([5, 9, 0, 0, 0, -1]), new Int32Array([5, 10, 0, -1, 0, 0]), new Int32Array([5, 11, 0, 0, 1, 0]), new Int32Array([5, 12, 0, 1, 0, 0]), new Int32Array([6, 26, 0, -1, 1, 0]), new Int32Array([6, 27, -1, 1, 0, 0]), new Int32Array([6, 28, 0, 1, -1, 0]), new Int32Array([6, 29, 0, 0, 1, -1]), new Int32Array([6, 30, 0, 1, 0, -1]), new Int32Array([6, 31, 0, 0, -1, 1]), new Int32Array([6, 32, -1, 0, 0, -1]), new Int32Array([6, 33, 1, -1, 0, 0]), new Int32Array([6, 34, 1, 0, -1, 0]), new Int32Array([6, 35, -1, -1, 0, 0]), new Int32Array([6, 36, 0, 0, -1, -1]), new Int32Array([6, 37, 1, 0, 1, 0]), new Int32Array([6, 38, 1, 0, 0, 1]), new Int32Array([6, 39, 0, -1, 0, 1]), new Int32Array([6, 40, -1, 0, 1, 0]), new Int32Array([6, 41, 0, 1, 0, 1]), new Int32Array([6, 42, 0, -1, -1, 0]), new Int32Array([6, 43, -1, 0, 0, 1]), new Int32Array([6, 44, 0, -1, 0, -1]), new Int32Array([6, 45, -1, 0, -1, 0]), new Int32Array([6, 46, 1, 1, 0, 0]), new Int32Array([6, 47, 0, 1, 1, 0]), new Int32Array([6, 48, 0, 0, 1, 1]), new Int32Array([6, 49, 1, 0, 0, -1]), new Int32Array([7, 100, 0, 1, -1, 1]), new Int32Array([7, 101, 1, 0, -1, 1]), new Int32Array([7, 102, -1, 1, -1, 0]), new Int32Array([7, 103, 0, -1, 1, -1]), new Int32Array([7, 104, 1, -1, 1, 0]), new Int32Array([7, 105, 1, 1, 0, -1]), new Int32Array([7, 106, 1, 0, 1, 1]), new Int32Array([7, 107, -1, 1, 1, 0]), new Int32Array([7, 108, 0, -1, -1, 1]), new Int32Array([7, 109, 1, 1, 1, 0]), new Int32Array([7, 110, -1, 0, 1, -1]), new Int32Array([7, 111, -1, -1, -1, 0]), new Int32Array([7, 112, -1, 0, -1, 1]), new Int32Array([7, 113, 1, -1, -1, 0]), new Int32Array([7, 114, 1, 1, -1, 0]), new Int32Array([8, 230, 1, -1, 0, 1]), new Int32Array([8, 231, -1, 1, 0, -1]), new Int32Array([8, 232, -1, -1, 1, 0]), new Int32Array([8, 233, -1, 0, 1, 1]), new Int32Array([8, 234, -1, -1, 0, 1]), new Int32Array([8, 235, -1, -1, 0, -1]), new Int32Array([8, 236, 0, -1, -1, -1]), new Int32Array([8, 237, 1, 0, 1, -1]), new Int32Array([8, 238, 1, 0, -1, -1]), new Int32Array([8, 239, 0, 1, -1, -1]), new Int32Array([8, 240, 0, 1, 1, 1]), new Int32Array([8, 241, -1, 1, 0, 1]), new Int32Array([8, 242, -1, 0, -1, -1]), new Int32Array([8, 243, 0, 1, 1, -1]), new Int32Array([8, 244, 1, -1, 0, -1]), new Int32Array([8, 245, 0, -1, 1, 1]), new Int32Array([8, 246, 1, 1, 0, 1]), new Int32Array([8, 247, 1, -1, 1, -1]), new Int32Array([8, 248, -1, 1, -1, 1]), new Int32Array([9, 498, 1, -1, -1, 1]), new Int32Array([9, 499, -1, -1, -1, -1]), new Int32Array([9, 500, -1, 1, 1, -1]), new Int32Array([9, 501, -1, 1, 1, 1]), new Int32Array([9, 502, 1, 1, 1, 1]), new Int32Array([9, 503, -1, -1, 1, -1]), new Int32Array([9, 504, 1, -1, 1, 1]), new Int32Array([9, 505, -1, 1, -1, -1]), new Int32Array([9, 506, -1, -1, 1, 1]), new Int32Array([9, 507, 1, 1, -1, -1]), new Int32Array([9, 508, 1, -1, -1, -1]), new Int32Array([9, 509, -1, -1, -1, 1]), new Int32Array([9, 510, 1, 1, -1, 1]), new Int32Array([9, 511, 1, 1, 1, -1])];
    constructor.HCB3 = [new Int32Array([1, 0, 0, 0, 0, 0]), new Int32Array([4, 8, 1, 0, 0, 0]), new Int32Array([4, 9, 0, 0, 0, 1]), new Int32Array([4, 10, 0, 1, 0, 0]), new Int32Array([4, 11, 0, 0, 1, 0]), new Int32Array([5, 24, 1, 1, 0, 0]), new Int32Array([5, 25, 0, 0, 1, 1]), new Int32Array([6, 52, 0, 1, 1, 0]), new Int32Array([6, 53, 0, 1, 0, 1]), new Int32Array([6, 54, 1, 0, 1, 0]), new Int32Array([6, 55, 0, 1, 1, 1]), new Int32Array([6, 56, 1, 0, 0, 1]), new Int32Array([6, 57, 1, 1, 1, 0]), new Int32Array([7, 116, 1, 1, 1, 1]), new Int32Array([7, 117, 1, 0, 1, 1]), new Int32Array([7, 118, 1, 1, 0, 1]), new Int32Array([8, 238, 2, 0, 0, 0]), new Int32Array([8, 239, 0, 0, 0, 2]), new Int32Array([8, 240, 0, 0, 1, 2]), new Int32Array([8, 241, 2, 1, 0, 0]), new Int32Array([8, 242, 1, 2, 1, 0]), new Int32Array([9, 486, 0, 0, 2, 1]), new Int32Array([9, 487, 0, 1, 2, 1]), new Int32Array([9, 488, 1, 2, 0, 0]), new Int32Array([9, 489, 0, 1, 1, 2]), new Int32Array([9, 490, 2, 1, 1, 0]), new Int32Array([9, 491, 0, 0, 2, 0]), new Int32Array([9, 492, 0, 2, 1, 0]), new Int32Array([9, 493, 0, 1, 2, 0]), new Int32Array([9, 494, 0, 2, 0, 0]), new Int32Array([9, 495, 0, 1, 0, 2]), new Int32Array([9, 496, 2, 0, 1, 0]), new Int32Array([9, 497, 1, 2, 1, 1]), new Int32Array([9, 498, 0, 2, 1, 1]), new Int32Array([9, 499, 1, 1, 2, 0]), new Int32Array([9, 500, 1, 1, 2, 1]), new Int32Array([10, 1002, 1, 2, 0, 1]), new Int32Array([10, 1003, 1, 0, 2, 0]), new Int32Array([10, 1004, 1, 0, 2, 1]), new Int32Array([10, 1005, 0, 2, 0, 1]), new Int32Array([10, 1006, 2, 1, 1, 1]), new Int32Array([10, 1007, 1, 1, 1, 2]), new Int32Array([10, 1008, 2, 1, 0, 1]), new Int32Array([10, 1009, 1, 0, 1, 2]), new Int32Array([10, 1010, 0, 0, 2, 2]), new Int32Array([10, 1011, 0, 1, 2, 2]), new Int32Array([10, 1012, 2, 2, 1, 0]), new Int32Array([10, 1013, 1, 2, 2, 0]), new Int32Array([10, 1014, 1, 0, 0, 2]), new Int32Array([10, 1015, 2, 0, 0, 1]), new Int32Array([10, 1016, 0, 2, 2, 1]), new Int32Array([11, 2034, 2, 2, 0, 0]), new Int32Array([11, 2035, 1, 2, 2, 1]), new Int32Array([11, 2036, 1, 1, 0, 2]), new Int32Array([11, 2037, 2, 0, 1, 1]), new Int32Array([11, 2038, 1, 1, 2, 2]), new Int32Array([11, 2039, 2, 2, 1, 1]), new Int32Array([11, 2040, 0, 2, 2, 0]), new Int32Array([11, 2041, 0, 2, 1, 2]), new Int32Array([12, 4084, 1, 0, 2, 2]), new Int32Array([12, 4085, 2, 2, 0, 1]), new Int32Array([12, 4086, 2, 1, 2, 0]), new Int32Array([12, 4087, 2, 2, 2, 0]), new Int32Array([12, 4088, 0, 2, 2, 2]), new Int32Array([12, 4089, 2, 2, 2, 1]), new Int32Array([12, 4090, 2, 1, 2, 1]), new Int32Array([12, 4091, 1, 2, 1, 2]), new Int32Array([12, 4092, 1, 2, 2, 2]), new Int32Array([13, 8186, 0, 2, 0, 2]), new Int32Array([13, 8187, 2, 0, 2, 0]), new Int32Array([13, 8188, 1, 2, 0, 2]), new Int32Array([14, 16378, 2, 0, 2, 1]), new Int32Array([14, 16379, 2, 1, 1, 2]), new Int32Array([14, 16380, 2, 1, 0, 2]), new Int32Array([15, 32762, 2, 2, 2, 2]), new Int32Array([15, 32763, 2, 2, 1, 2]), new Int32Array([15, 32764, 2, 1, 2, 2]), new Int32Array([15, 32765, 2, 0, 1, 2]), new Int32Array([15, 32766, 2, 0, 0, 2]), new Int32Array([16, 65534, 2, 2, 0, 2]), new Int32Array([16, 65535, 2, 0, 2, 2])];
    constructor.HCB4 = [new Int32Array([4, 0, 1, 1, 1, 1]), new Int32Array([4, 1, 0, 1, 1, 1]), new Int32Array([4, 2, 1, 1, 0, 1]), new Int32Array([4, 3, 1, 1, 1, 0]), new Int32Array([4, 4, 1, 0, 1, 1]), new Int32Array([4, 5, 1, 0, 0, 0]), new Int32Array([4, 6, 1, 1, 0, 0]), new Int32Array([4, 7, 0, 0, 0, 0]), new Int32Array([4, 8, 0, 0, 1, 1]), new Int32Array([4, 9, 1, 0, 1, 0]), new Int32Array([5, 20, 1, 0, 0, 1]), new Int32Array([5, 21, 0, 1, 1, 0]), new Int32Array([5, 22, 0, 0, 0, 1]), new Int32Array([5, 23, 0, 1, 0, 1]), new Int32Array([5, 24, 0, 0, 1, 0]), new Int32Array([5, 25, 0, 1, 0, 0]), new Int32Array([7, 104, 2, 1, 1, 1]), new Int32Array([7, 105, 1, 1, 2, 1]), new Int32Array([7, 106, 1, 2, 1, 1]), new Int32Array([7, 107, 1, 1, 1, 2]), new Int32Array([7, 108, 2, 1, 1, 0]), new Int32Array([7, 109, 2, 1, 0, 1]), new Int32Array([7, 110, 1, 2, 1, 0]), new Int32Array([7, 111, 2, 0, 1, 1]), new Int32Array([7, 112, 0, 1, 2, 1]), new Int32Array([8, 226, 0, 1, 1, 2]), new Int32Array([8, 227, 1, 1, 2, 0]), new Int32Array([8, 228, 0, 2, 1, 1]), new Int32Array([8, 229, 1, 0, 1, 2]), new Int32Array([8, 230, 1, 2, 0, 1]), new Int32Array([8, 231, 1, 1, 0, 2]), new Int32Array([8, 232, 1, 0, 2, 1]), new Int32Array([8, 233, 2, 1, 0, 0]), new Int32Array([8, 234, 2, 0, 1, 0]), new Int32Array([8, 235, 1, 2, 0, 0]), new Int32Array([8, 236, 2, 0, 0, 1]), new Int32Array([8, 237, 0, 1, 0, 2]), new Int32Array([8, 238, 0, 2, 1, 0]), new Int32Array([8, 239, 0, 0, 1, 2]), new Int32Array([8, 240, 0, 1, 2, 0]), new Int32Array([8, 241, 0, 2, 0, 1]), new Int32Array([8, 242, 1, 0, 0, 2]), new Int32Array([8, 243, 0, 0, 2, 1]), new Int32Array([8, 244, 1, 0, 2, 0]), new Int32Array([8, 245, 2, 0, 0, 0]), new Int32Array([8, 246, 0, 0, 0, 2]), new Int32Array([9, 494, 0, 2, 0, 0]), new Int32Array([9, 495, 0, 0, 2, 0]), new Int32Array([9, 496, 1, 2, 2, 1]), new Int32Array([9, 497, 2, 2, 1, 1]), new Int32Array([9, 498, 2, 1, 2, 1]), new Int32Array([9, 499, 1, 1, 2, 2]), new Int32Array([9, 500, 1, 2, 1, 2]), new Int32Array([9, 501, 2, 1, 1, 2]), new Int32Array([10, 1004, 1, 2, 2, 0]), new Int32Array([10, 1005, 2, 2, 1, 0]), new Int32Array([10, 1006, 2, 1, 2, 0]), new Int32Array([10, 1007, 0, 2, 2, 1]), new Int32Array([10, 1008, 0, 1, 2, 2]), new Int32Array([10, 1009, 2, 2, 0, 1]), new Int32Array([10, 1010, 0, 2, 1, 2]), new Int32Array([10, 1011, 2, 0, 2, 1]), new Int32Array([10, 1012, 1, 0, 2, 2]), new Int32Array([10, 1013, 2, 2, 2, 1]), new Int32Array([10, 1014, 1, 2, 0, 2]), new Int32Array([10, 1015, 2, 0, 1, 2]), new Int32Array([10, 1016, 2, 1, 0, 2]), new Int32Array([10, 1017, 1, 2, 2, 2]), new Int32Array([11, 2036, 2, 1, 2, 2]), new Int32Array([11, 2037, 2, 2, 1, 2]), new Int32Array([11, 2038, 0, 2, 2, 0]), new Int32Array([11, 2039, 2, 2, 0, 0]), new Int32Array([11, 2040, 0, 0, 2, 2]), new Int32Array([11, 2041, 2, 0, 2, 0]), new Int32Array([11, 2042, 0, 2, 0, 2]), new Int32Array([11, 2043, 2, 0, 0, 2]), new Int32Array([11, 2044, 2, 2, 2, 2]), new Int32Array([11, 2045, 0, 2, 2, 2]), new Int32Array([11, 2046, 2, 2, 2, 0]), new Int32Array([12, 4094, 2, 2, 0, 2]), new Int32Array([12, 4095, 2, 0, 2, 2])];
    constructor.HCB5 = [new Int32Array([1, 0, 0, 0]), new Int32Array([4, 8, -1, 0]), new Int32Array([4, 9, 1, 0]), new Int32Array([4, 10, 0, 1]), new Int32Array([4, 11, 0, -1]), new Int32Array([5, 24, 1, -1]), new Int32Array([5, 25, -1, 1]), new Int32Array([5, 26, -1, -1]), new Int32Array([5, 27, 1, 1]), new Int32Array([7, 112, -2, 0]), new Int32Array([7, 113, 0, 2]), new Int32Array([7, 114, 2, 0]), new Int32Array([7, 115, 0, -2]), new Int32Array([8, 232, -2, -1]), new Int32Array([8, 233, 2, 1]), new Int32Array([8, 234, -1, -2]), new Int32Array([8, 235, 1, 2]), new Int32Array([8, 236, -2, 1]), new Int32Array([8, 237, 2, -1]), new Int32Array([8, 238, -1, 2]), new Int32Array([8, 239, 1, -2]), new Int32Array([8, 240, -3, 0]), new Int32Array([8, 241, 3, 0]), new Int32Array([8, 242, 0, -3]), new Int32Array([8, 243, 0, 3]), new Int32Array([9, 488, -3, -1]), new Int32Array([9, 489, 1, 3]), new Int32Array([9, 490, 3, 1]), new Int32Array([9, 491, -1, -3]), new Int32Array([9, 492, -3, 1]), new Int32Array([9, 493, 3, -1]), new Int32Array([9, 494, 1, -3]), new Int32Array([9, 495, -1, 3]), new Int32Array([9, 496, -2, 2]), new Int32Array([9, 497, 2, 2]), new Int32Array([9, 498, -2, -2]), new Int32Array([9, 499, 2, -2]), new Int32Array([10, 1000, -3, -2]), new Int32Array([10, 1001, 3, -2]), new Int32Array([10, 1002, -2, 3]), new Int32Array([10, 1003, 2, -3]), new Int32Array([10, 1004, 3, 2]), new Int32Array([10, 1005, 2, 3]), new Int32Array([10, 1006, -3, 2]), new Int32Array([10, 1007, -2, -3]), new Int32Array([10, 1008, 0, -4]), new Int32Array([10, 1009, -4, 0]), new Int32Array([10, 1010, 4, 1]), new Int32Array([10, 1011, 4, 0]), new Int32Array([11, 2024, -4, -1]), new Int32Array([11, 2025, 0, 4]), new Int32Array([11, 2026, 4, -1]), new Int32Array([11, 2027, -1, -4]), new Int32Array([11, 2028, 1, 4]), new Int32Array([11, 2029, -1, 4]), new Int32Array([11, 2030, -4, 1]), new Int32Array([11, 2031, 1, -4]), new Int32Array([11, 2032, 3, -3]), new Int32Array([11, 2033, -3, -3]), new Int32Array([11, 2034, -3, 3]), new Int32Array([11, 2035, -2, 4]), new Int32Array([11, 2036, -4, -2]), new Int32Array([11, 2037, 4, 2]), new Int32Array([11, 2038, 2, -4]), new Int32Array([11, 2039, 2, 4]), new Int32Array([11, 2040, 3, 3]), new Int32Array([11, 2041, -4, 2]), new Int32Array([12, 4084, -2, -4]), new Int32Array([12, 4085, 4, -2]), new Int32Array([12, 4086, 3, -4]), new Int32Array([12, 4087, -4, -3]), new Int32Array([12, 4088, -4, 3]), new Int32Array([12, 4089, 3, 4]), new Int32Array([12, 4090, -3, 4]), new Int32Array([12, 4091, 4, 3]), new Int32Array([12, 4092, 4, -3]), new Int32Array([12, 4093, -3, -4]), new Int32Array([13, 8188, 4, -4]), new Int32Array([13, 8189, -4, 4]), new Int32Array([13, 8190, 4, 4]), new Int32Array([13, 8191, -4, -4])];
    constructor.HCB6 = [new Int32Array([4, 0, 0, 0]), new Int32Array([4, 1, 1, 0]), new Int32Array([4, 2, 0, -1]), new Int32Array([4, 3, 0, 1]), new Int32Array([4, 4, -1, 0]), new Int32Array([4, 5, 1, 1]), new Int32Array([4, 6, -1, 1]), new Int32Array([4, 7, 1, -1]), new Int32Array([4, 8, -1, -1]), new Int32Array([6, 36, 2, -1]), new Int32Array([6, 37, 2, 1]), new Int32Array([6, 38, -2, 1]), new Int32Array([6, 39, -2, -1]), new Int32Array([6, 40, -2, 0]), new Int32Array([6, 41, -1, 2]), new Int32Array([6, 42, 2, 0]), new Int32Array([6, 43, 1, -2]), new Int32Array([6, 44, 1, 2]), new Int32Array([6, 45, 0, -2]), new Int32Array([6, 46, -1, -2]), new Int32Array([6, 47, 0, 2]), new Int32Array([6, 48, 2, -2]), new Int32Array([6, 49, -2, 2]), new Int32Array([6, 50, -2, -2]), new Int32Array([6, 51, 2, 2]), new Int32Array([7, 104, -3, 1]), new Int32Array([7, 105, 3, 1]), new Int32Array([7, 106, 3, -1]), new Int32Array([7, 107, -1, 3]), new Int32Array([7, 108, -3, -1]), new Int32Array([7, 109, 1, 3]), new Int32Array([7, 110, 1, -3]), new Int32Array([7, 111, -1, -3]), new Int32Array([7, 112, 3, 0]), new Int32Array([7, 113, -3, 0]), new Int32Array([7, 114, 0, -3]), new Int32Array([7, 115, 0, 3]), new Int32Array([7, 116, 3, 2]), new Int32Array([8, 234, -3, -2]), new Int32Array([8, 235, -2, 3]), new Int32Array([8, 236, 2, 3]), new Int32Array([8, 237, 3, -2]), new Int32Array([8, 238, 2, -3]), new Int32Array([8, 239, -2, -3]), new Int32Array([8, 240, -3, 2]), new Int32Array([8, 241, 3, 3]), new Int32Array([9, 484, 3, -3]), new Int32Array([9, 485, -3, -3]), new Int32Array([9, 486, -3, 3]), new Int32Array([9, 487, 1, -4]), new Int32Array([9, 488, -1, -4]), new Int32Array([9, 489, 4, 1]), new Int32Array([9, 490, -4, 1]), new Int32Array([9, 491, -4, -1]), new Int32Array([9, 492, 1, 4]), new Int32Array([9, 493, 4, -1]), new Int32Array([9, 494, -1, 4]), new Int32Array([9, 495, 0, -4]), new Int32Array([9, 496, -4, 2]), new Int32Array([9, 497, -4, -2]), new Int32Array([9, 498, 2, 4]), new Int32Array([9, 499, -2, -4]), new Int32Array([9, 500, -4, 0]), new Int32Array([9, 501, 4, 2]), new Int32Array([9, 502, 4, -2]), new Int32Array([9, 503, -2, 4]), new Int32Array([9, 504, 4, 0]), new Int32Array([9, 505, 2, -4]), new Int32Array([9, 506, 0, 4]), new Int32Array([10, 1014, -3, -4]), new Int32Array([10, 1015, -3, 4]), new Int32Array([10, 1016, 3, -4]), new Int32Array([10, 1017, 4, -3]), new Int32Array([10, 1018, 3, 4]), new Int32Array([10, 1019, 4, 3]), new Int32Array([10, 1020, -4, 3]), new Int32Array([10, 1021, -4, -3]), new Int32Array([11, 2044, 4, 4]), new Int32Array([11, 2045, -4, 4]), new Int32Array([11, 2046, -4, -4]), new Int32Array([11, 2047, 4, -4])];
    constructor.HCB7 = [new Int32Array([1, 0, 0, 0]), new Int32Array([3, 4, 1, 0]), new Int32Array([3, 5, 0, 1]), new Int32Array([4, 12, 1, 1]), new Int32Array([6, 52, 2, 1]), new Int32Array([6, 53, 1, 2]), new Int32Array([6, 54, 2, 0]), new Int32Array([6, 55, 0, 2]), new Int32Array([7, 112, 3, 1]), new Int32Array([7, 113, 1, 3]), new Int32Array([7, 114, 2, 2]), new Int32Array([7, 115, 3, 0]), new Int32Array([7, 116, 0, 3]), new Int32Array([8, 234, 2, 3]), new Int32Array([8, 235, 3, 2]), new Int32Array([8, 236, 1, 4]), new Int32Array([8, 237, 4, 1]), new Int32Array([8, 238, 1, 5]), new Int32Array([8, 239, 5, 1]), new Int32Array([8, 240, 3, 3]), new Int32Array([8, 241, 2, 4]), new Int32Array([8, 242, 0, 4]), new Int32Array([8, 243, 4, 0]), new Int32Array([9, 488, 4, 2]), new Int32Array([9, 489, 2, 5]), new Int32Array([9, 490, 5, 2]), new Int32Array([9, 491, 0, 5]), new Int32Array([9, 492, 6, 1]), new Int32Array([9, 493, 5, 0]), new Int32Array([9, 494, 1, 6]), new Int32Array([9, 495, 4, 3]), new Int32Array([9, 496, 3, 5]), new Int32Array([9, 497, 3, 4]), new Int32Array([9, 498, 5, 3]), new Int32Array([9, 499, 2, 6]), new Int32Array([9, 500, 6, 2]), new Int32Array([9, 501, 1, 7]), new Int32Array([10, 1004, 3, 6]), new Int32Array([10, 1005, 0, 6]), new Int32Array([10, 1006, 6, 0]), new Int32Array([10, 1007, 4, 4]), new Int32Array([10, 1008, 7, 1]), new Int32Array([10, 1009, 4, 5]), new Int32Array([10, 1010, 7, 2]), new Int32Array([10, 1011, 5, 4]), new Int32Array([10, 1012, 6, 3]), new Int32Array([10, 1013, 2, 7]), new Int32Array([10, 1014, 7, 3]), new Int32Array([10, 1015, 6, 4]), new Int32Array([10, 1016, 5, 5]), new Int32Array([10, 1017, 4, 6]), new Int32Array([10, 1018, 3, 7]), new Int32Array([11, 2038, 7, 0]), new Int32Array([11, 2039, 0, 7]), new Int32Array([11, 2040, 6, 5]), new Int32Array([11, 2041, 5, 6]), new Int32Array([11, 2042, 7, 4]), new Int32Array([11, 2043, 4, 7]), new Int32Array([11, 2044, 5, 7]), new Int32Array([11, 2045, 7, 5]), new Int32Array([12, 4092, 7, 6]), new Int32Array([12, 4093, 6, 6]), new Int32Array([12, 4094, 6, 7]), new Int32Array([12, 4095, 7, 7])];
    constructor.HCB8 = [new Int32Array([3, 0, 1, 1]), new Int32Array([4, 2, 2, 1]), new Int32Array([4, 3, 1, 0]), new Int32Array([4, 4, 1, 2]), new Int32Array([4, 5, 0, 1]), new Int32Array([4, 6, 2, 2]), new Int32Array([5, 14, 0, 0]), new Int32Array([5, 15, 2, 0]), new Int32Array([5, 16, 0, 2]), new Int32Array([5, 17, 3, 1]), new Int32Array([5, 18, 1, 3]), new Int32Array([5, 19, 3, 2]), new Int32Array([5, 20, 2, 3]), new Int32Array([6, 42, 3, 3]), new Int32Array([6, 43, 4, 1]), new Int32Array([6, 44, 1, 4]), new Int32Array([6, 45, 4, 2]), new Int32Array([6, 46, 2, 4]), new Int32Array([6, 47, 3, 0]), new Int32Array([6, 48, 0, 3]), new Int32Array([6, 49, 4, 3]), new Int32Array([6, 50, 3, 4]), new Int32Array([6, 51, 5, 2]), new Int32Array([7, 104, 5, 1]), new Int32Array([7, 105, 2, 5]), new Int32Array([7, 106, 1, 5]), new Int32Array([7, 107, 5, 3]), new Int32Array([7, 108, 3, 5]), new Int32Array([7, 109, 4, 4]), new Int32Array([7, 110, 5, 4]), new Int32Array([7, 111, 0, 4]), new Int32Array([7, 112, 4, 5]), new Int32Array([7, 113, 4, 0]), new Int32Array([7, 114, 2, 6]), new Int32Array([7, 115, 6, 2]), new Int32Array([7, 116, 6, 1]), new Int32Array([7, 117, 1, 6]), new Int32Array([8, 236, 3, 6]), new Int32Array([8, 237, 6, 3]), new Int32Array([8, 238, 5, 5]), new Int32Array([8, 239, 5, 0]), new Int32Array([8, 240, 6, 4]), new Int32Array([8, 241, 0, 5]), new Int32Array([8, 242, 4, 6]), new Int32Array([8, 243, 7, 1]), new Int32Array([8, 244, 7, 2]), new Int32Array([8, 245, 2, 7]), new Int32Array([8, 246, 6, 5]), new Int32Array([8, 247, 7, 3]), new Int32Array([8, 248, 1, 7]), new Int32Array([8, 249, 5, 6]), new Int32Array([8, 250, 3, 7]), new Int32Array([9, 502, 6, 6]), new Int32Array([9, 503, 7, 4]), new Int32Array([9, 504, 6, 0]), new Int32Array([9, 505, 4, 7]), new Int32Array([9, 506, 0, 6]), new Int32Array([9, 507, 7, 5]), new Int32Array([9, 508, 7, 6]), new Int32Array([9, 509, 6, 7]), new Int32Array([10, 1020, 5, 7]), new Int32Array([10, 1021, 7, 0]), new Int32Array([10, 1022, 0, 7]), new Int32Array([10, 1023, 7, 7])];
    constructor.HCB9 = [new Int32Array([1, 0, 0, 0]), new Int32Array([3, 4, 1, 0]), new Int32Array([3, 5, 0, 1]), new Int32Array([4, 12, 1, 1]), new Int32Array([6, 52, 2, 1]), new Int32Array([6, 53, 1, 2]), new Int32Array([6, 54, 2, 0]), new Int32Array([6, 55, 0, 2]), new Int32Array([7, 112, 3, 1]), new Int32Array([7, 113, 2, 2]), new Int32Array([7, 114, 1, 3]), new Int32Array([8, 230, 3, 0]), new Int32Array([8, 231, 0, 3]), new Int32Array([8, 232, 2, 3]), new Int32Array([8, 233, 3, 2]), new Int32Array([8, 234, 1, 4]), new Int32Array([8, 235, 4, 1]), new Int32Array([8, 236, 2, 4]), new Int32Array([8, 237, 1, 5]), new Int32Array([9, 476, 4, 2]), new Int32Array([9, 477, 3, 3]), new Int32Array([9, 478, 0, 4]), new Int32Array([9, 479, 4, 0]), new Int32Array([9, 480, 5, 1]), new Int32Array([9, 481, 2, 5]), new Int32Array([9, 482, 1, 6]), new Int32Array([9, 483, 3, 4]), new Int32Array([9, 484, 5, 2]), new Int32Array([9, 485, 6, 1]), new Int32Array([9, 486, 4, 3]), new Int32Array([10, 974, 0, 5]), new Int32Array([10, 975, 2, 6]), new Int32Array([10, 976, 5, 0]), new Int32Array([10, 977, 1, 7]), new Int32Array([10, 978, 3, 5]), new Int32Array([10, 979, 1, 8]), new Int32Array([10, 980, 8, 1]), new Int32Array([10, 981, 4, 4]), new Int32Array([10, 982, 5, 3]), new Int32Array([10, 983, 6, 2]), new Int32Array([10, 984, 7, 1]), new Int32Array([10, 985, 0, 6]), new Int32Array([10, 986, 8, 2]), new Int32Array([10, 987, 2, 8]), new Int32Array([10, 988, 3, 6]), new Int32Array([10, 989, 2, 7]), new Int32Array([10, 990, 4, 5]), new Int32Array([10, 991, 9, 1]), new Int32Array([10, 992, 1, 9]), new Int32Array([10, 993, 7, 2]), new Int32Array([11, 1988, 6, 0]), new Int32Array([11, 1989, 5, 4]), new Int32Array([11, 1990, 6, 3]), new Int32Array([11, 1991, 8, 3]), new Int32Array([11, 1992, 0, 7]), new Int32Array([11, 1993, 9, 2]), new Int32Array([11, 1994, 3, 8]), new Int32Array([11, 1995, 4, 6]), new Int32Array([11, 1996, 3, 7]), new Int32Array([11, 1997, 0, 8]), new Int32Array([11, 1998, 10, 1]), new Int32Array([11, 1999, 6, 4]), new Int32Array([11, 2000, 2, 9]), new Int32Array([11, 2001, 5, 5]), new Int32Array([11, 2002, 8, 0]), new Int32Array([11, 2003, 7, 0]), new Int32Array([11, 2004, 7, 3]), new Int32Array([11, 2005, 10, 2]), new Int32Array([11, 2006, 9, 3]), new Int32Array([11, 2007, 8, 4]), new Int32Array([11, 2008, 1, 10]), new Int32Array([11, 2009, 7, 4]), new Int32Array([11, 2010, 6, 5]), new Int32Array([11, 2011, 5, 6]), new Int32Array([11, 2012, 4, 8]), new Int32Array([11, 2013, 4, 7]), new Int32Array([11, 2014, 3, 9]), new Int32Array([11, 2015, 11, 1]), new Int32Array([11, 2016, 5, 8]), new Int32Array([11, 2017, 9, 0]), new Int32Array([11, 2018, 8, 5]), new Int32Array([12, 4038, 10, 3]), new Int32Array([12, 4039, 2, 10]), new Int32Array([12, 4040, 0, 9]), new Int32Array([12, 4041, 11, 2]), new Int32Array([12, 4042, 9, 4]), new Int32Array([12, 4043, 6, 6]), new Int32Array([12, 4044, 12, 1]), new Int32Array([12, 4045, 4, 9]), new Int32Array([12, 4046, 8, 6]), new Int32Array([12, 4047, 1, 11]), new Int32Array([12, 4048, 9, 5]), new Int32Array([12, 4049, 10, 4]), new Int32Array([12, 4050, 5, 7]), new Int32Array([12, 4051, 7, 5]), new Int32Array([12, 4052, 2, 11]), new Int32Array([12, 4053, 1, 12]), new Int32Array([12, 4054, 12, 2]), new Int32Array([12, 4055, 11, 3]), new Int32Array([12, 4056, 3, 10]), new Int32Array([12, 4057, 5, 9]), new Int32Array([12, 4058, 6, 7]), new Int32Array([12, 4059, 8, 7]), new Int32Array([12, 4060, 11, 4]), new Int32Array([12, 4061, 0, 10]), new Int32Array([12, 4062, 7, 6]), new Int32Array([12, 4063, 12, 3]), new Int32Array([12, 4064, 10, 0]), new Int32Array([12, 4065, 10, 5]), new Int32Array([12, 4066, 4, 10]), new Int32Array([12, 4067, 6, 8]), new Int32Array([12, 4068, 2, 12]), new Int32Array([12, 4069, 9, 6]), new Int32Array([12, 4070, 9, 7]), new Int32Array([12, 4071, 4, 11]), new Int32Array([12, 4072, 11, 0]), new Int32Array([12, 4073, 6, 9]), new Int32Array([12, 4074, 3, 11]), new Int32Array([12, 4075, 5, 10]), new Int32Array([13, 8152, 8, 8]), new Int32Array([13, 8153, 7, 8]), new Int32Array([13, 8154, 12, 5]), new Int32Array([13, 8155, 3, 12]), new Int32Array([13, 8156, 11, 5]), new Int32Array([13, 8157, 7, 7]), new Int32Array([13, 8158, 12, 4]), new Int32Array([13, 8159, 11, 6]), new Int32Array([13, 8160, 10, 6]), new Int32Array([13, 8161, 4, 12]), new Int32Array([13, 8162, 7, 9]), new Int32Array([13, 8163, 5, 11]), new Int32Array([13, 8164, 0, 11]), new Int32Array([13, 8165, 12, 6]), new Int32Array([13, 8166, 6, 10]), new Int32Array([13, 8167, 12, 0]), new Int32Array([13, 8168, 10, 7]), new Int32Array([13, 8169, 5, 12]), new Int32Array([13, 8170, 7, 10]), new Int32Array([13, 8171, 9, 8]), new Int32Array([13, 8172, 0, 12]), new Int32Array([13, 8173, 11, 7]), new Int32Array([13, 8174, 8, 9]), new Int32Array([13, 8175, 9, 9]), new Int32Array([13, 8176, 10, 8]), new Int32Array([13, 8177, 7, 11]), new Int32Array([13, 8178, 12, 7]), new Int32Array([13, 8179, 6, 11]), new Int32Array([13, 8180, 8, 11]), new Int32Array([13, 8181, 11, 8]), new Int32Array([13, 8182, 7, 12]), new Int32Array([13, 8183, 6, 12]), new Int32Array([14, 16368, 8, 10]), new Int32Array([14, 16369, 10, 9]), new Int32Array([14, 16370, 8, 12]), new Int32Array([14, 16371, 9, 10]), new Int32Array([14, 16372, 9, 11]), new Int32Array([14, 16373, 9, 12]), new Int32Array([14, 16374, 10, 11]), new Int32Array([14, 16375, 12, 9]), new Int32Array([14, 16376, 10, 10]), new Int32Array([14, 16377, 11, 9]), new Int32Array([14, 16378, 12, 8]), new Int32Array([14, 16379, 11, 10]), new Int32Array([14, 16380, 12, 10]), new Int32Array([14, 16381, 12, 11]), new Int32Array([15, 32764, 10, 12]), new Int32Array([15, 32765, 11, 11]), new Int32Array([15, 32766, 11, 12]), new Int32Array([15, 32767, 12, 12])];
    constructor.HCB10 = [new Int32Array([4, 0, 1, 1]), new Int32Array([4, 1, 1, 2]), new Int32Array([4, 2, 2, 1]), new Int32Array([5, 6, 2, 2]), new Int32Array([5, 7, 1, 0]), new Int32Array([5, 8, 0, 1]), new Int32Array([5, 9, 1, 3]), new Int32Array([5, 10, 3, 2]), new Int32Array([5, 11, 3, 1]), new Int32Array([5, 12, 2, 3]), new Int32Array([5, 13, 3, 3]), new Int32Array([6, 28, 2, 0]), new Int32Array([6, 29, 0, 2]), new Int32Array([6, 30, 2, 4]), new Int32Array([6, 31, 4, 2]), new Int32Array([6, 32, 1, 4]), new Int32Array([6, 33, 4, 1]), new Int32Array([6, 34, 0, 0]), new Int32Array([6, 35, 4, 3]), new Int32Array([6, 36, 3, 4]), new Int32Array([6, 37, 3, 0]), new Int32Array([6, 38, 0, 3]), new Int32Array([6, 39, 4, 4]), new Int32Array([6, 40, 2, 5]), new Int32Array([6, 41, 5, 2]), new Int32Array([7, 84, 1, 5]), new Int32Array([7, 85, 5, 1]), new Int32Array([7, 86, 5, 3]), new Int32Array([7, 87, 3, 5]), new Int32Array([7, 88, 5, 4]), new Int32Array([7, 89, 4, 5]), new Int32Array([7, 90, 6, 2]), new Int32Array([7, 91, 2, 6]), new Int32Array([7, 92, 6, 3]), new Int32Array([7, 93, 4, 0]), new Int32Array([7, 94, 6, 1]), new Int32Array([7, 95, 0, 4]), new Int32Array([7, 96, 1, 6]), new Int32Array([7, 97, 3, 6]), new Int32Array([7, 98, 5, 5]), new Int32Array([7, 99, 6, 4]), new Int32Array([7, 100, 4, 6]), new Int32Array([8, 202, 6, 5]), new Int32Array([8, 203, 7, 2]), new Int32Array([8, 204, 3, 7]), new Int32Array([8, 205, 2, 7]), new Int32Array([8, 206, 5, 6]), new Int32Array([8, 207, 8, 2]), new Int32Array([8, 208, 7, 3]), new Int32Array([8, 209, 5, 0]), new Int32Array([8, 210, 7, 1]), new Int32Array([8, 211, 0, 5]), new Int32Array([8, 212, 8, 1]), new Int32Array([8, 213, 1, 7]), new Int32Array([8, 214, 8, 3]), new Int32Array([8, 215, 7, 4]), new Int32Array([8, 216, 4, 7]), new Int32Array([8, 217, 2, 8]), new Int32Array([8, 218, 6, 6]), new Int32Array([8, 219, 7, 5]), new Int32Array([8, 220, 1, 8]), new Int32Array([8, 221, 3, 8]), new Int32Array([8, 222, 8, 4]), new Int32Array([8, 223, 4, 8]), new Int32Array([8, 224, 5, 7]), new Int32Array([8, 225, 8, 5]), new Int32Array([8, 226, 5, 8]), new Int32Array([9, 454, 7, 6]), new Int32Array([9, 455, 6, 7]), new Int32Array([9, 456, 9, 2]), new Int32Array([9, 457, 6, 0]), new Int32Array([9, 458, 6, 8]), new Int32Array([9, 459, 9, 3]), new Int32Array([9, 460, 3, 9]), new Int32Array([9, 461, 9, 1]), new Int32Array([9, 462, 2, 9]), new Int32Array([9, 463, 0, 6]), new Int32Array([9, 464, 8, 6]), new Int32Array([9, 465, 9, 4]), new Int32Array([9, 466, 4, 9]), new Int32Array([9, 467, 10, 2]), new Int32Array([9, 468, 1, 9]), new Int32Array([9, 469, 7, 7]), new Int32Array([9, 470, 8, 7]), new Int32Array([9, 471, 9, 5]), new Int32Array([9, 472, 7, 8]), new Int32Array([9, 473, 10, 3]), new Int32Array([9, 474, 5, 9]), new Int32Array([9, 475, 10, 4]), new Int32Array([9, 476, 2, 10]), new Int32Array([9, 477, 10, 1]), new Int32Array([9, 478, 3, 10]), new Int32Array([9, 479, 9, 6]), new Int32Array([9, 480, 6, 9]), new Int32Array([9, 481, 8, 0]), new Int32Array([9, 482, 4, 10]), new Int32Array([9, 483, 7, 0]), new Int32Array([9, 484, 11, 2]), new Int32Array([10, 970, 7, 9]), new Int32Array([10, 971, 11, 3]), new Int32Array([10, 972, 10, 6]), new Int32Array([10, 973, 1, 10]), new Int32Array([10, 974, 11, 1]), new Int32Array([10, 975, 9, 7]), new Int32Array([10, 976, 0, 7]), new Int32Array([10, 977, 8, 8]), new Int32Array([10, 978, 10, 5]), new Int32Array([10, 979, 3, 11]), new Int32Array([10, 980, 5, 10]), new Int32Array([10, 981, 8, 9]), new Int32Array([10, 982, 11, 5]), new Int32Array([10, 983, 0, 8]), new Int32Array([10, 984, 11, 4]), new Int32Array([10, 985, 2, 11]), new Int32Array([10, 986, 7, 10]), new Int32Array([10, 987, 6, 10]), new Int32Array([10, 988, 10, 7]), new Int32Array([10, 989, 4, 11]), new Int32Array([10, 990, 1, 11]), new Int32Array([10, 991, 12, 2]), new Int32Array([10, 992, 9, 8]), new Int32Array([10, 993, 12, 3]), new Int32Array([10, 994, 11, 6]), new Int32Array([10, 995, 5, 11]), new Int32Array([10, 996, 12, 4]), new Int32Array([10, 997, 11, 7]), new Int32Array([10, 998, 12, 5]), new Int32Array([10, 999, 3, 12]), new Int32Array([10, 1000, 6, 11]), new Int32Array([10, 1001, 9, 0]), new Int32Array([10, 1002, 10, 8]), new Int32Array([10, 1003, 10, 0]), new Int32Array([10, 1004, 12, 1]), new Int32Array([10, 1005, 0, 9]), new Int32Array([10, 1006, 4, 12]), new Int32Array([10, 1007, 9, 9]), new Int32Array([10, 1008, 12, 6]), new Int32Array([10, 1009, 2, 12]), new Int32Array([10, 1010, 8, 10]), new Int32Array([11, 2022, 9, 10]), new Int32Array([11, 2023, 1, 12]), new Int32Array([11, 2024, 11, 8]), new Int32Array([11, 2025, 12, 7]), new Int32Array([11, 2026, 7, 11]), new Int32Array([11, 2027, 5, 12]), new Int32Array([11, 2028, 6, 12]), new Int32Array([11, 2029, 10, 9]), new Int32Array([11, 2030, 8, 11]), new Int32Array([11, 2031, 12, 8]), new Int32Array([11, 2032, 0, 10]), new Int32Array([11, 2033, 7, 12]), new Int32Array([11, 2034, 11, 0]), new Int32Array([11, 2035, 10, 10]), new Int32Array([11, 2036, 11, 9]), new Int32Array([11, 2037, 11, 10]), new Int32Array([11, 2038, 0, 11]), new Int32Array([11, 2039, 11, 11]), new Int32Array([11, 2040, 9, 11]), new Int32Array([11, 2041, 10, 11]), new Int32Array([11, 2042, 12, 0]), new Int32Array([11, 2043, 8, 12]), new Int32Array([12, 4088, 12, 9]), new Int32Array([12, 4089, 10, 12]), new Int32Array([12, 4090, 9, 12]), new Int32Array([12, 4091, 11, 12]), new Int32Array([12, 4092, 12, 11]), new Int32Array([12, 4093, 0, 12]), new Int32Array([12, 4094, 12, 10]), new Int32Array([12, 4095, 12, 12])];
    constructor.HCB11 = [new Int32Array([4, 0, 0, 0]), new Int32Array([4, 1, 1, 1]), new Int32Array([5, 4, 16, 16]), new Int32Array([5, 5, 1, 0]), new Int32Array([5, 6, 0, 1]), new Int32Array([5, 7, 2, 1]), new Int32Array([5, 8, 1, 2]), new Int32Array([5, 9, 2, 2]), new Int32Array([6, 20, 1, 3]), new Int32Array([6, 21, 3, 1]), new Int32Array([6, 22, 3, 2]), new Int32Array([6, 23, 2, 0]), new Int32Array([6, 24, 2, 3]), new Int32Array([6, 25, 0, 2]), new Int32Array([6, 26, 3, 3]), new Int32Array([7, 54, 4, 1]), new Int32Array([7, 55, 1, 4]), new Int32Array([7, 56, 4, 2]), new Int32Array([7, 57, 2, 4]), new Int32Array([7, 58, 4, 3]), new Int32Array([7, 59, 3, 4]), new Int32Array([7, 60, 3, 0]), new Int32Array([7, 61, 0, 3]), new Int32Array([7, 62, 5, 1]), new Int32Array([7, 63, 5, 2]), new Int32Array([7, 64, 2, 5]), new Int32Array([7, 65, 4, 4]), new Int32Array([7, 66, 1, 5]), new Int32Array([7, 67, 5, 3]), new Int32Array([7, 68, 3, 5]), new Int32Array([7, 69, 5, 4]), new Int32Array([8, 140, 4, 5]), new Int32Array([8, 141, 6, 2]), new Int32Array([8, 142, 2, 6]), new Int32Array([8, 143, 6, 1]), new Int32Array([8, 144, 6, 3]), new Int32Array([8, 145, 3, 6]), new Int32Array([8, 146, 1, 6]), new Int32Array([8, 147, 4, 16]), new Int32Array([8, 148, 3, 16]), new Int32Array([8, 149, 16, 5]), new Int32Array([8, 150, 16, 3]), new Int32Array([8, 151, 16, 4]), new Int32Array([8, 152, 6, 4]), new Int32Array([8, 153, 16, 6]), new Int32Array([8, 154, 4, 0]), new Int32Array([8, 155, 4, 6]), new Int32Array([8, 156, 0, 4]), new Int32Array([8, 157, 2, 16]), new Int32Array([8, 158, 5, 5]), new Int32Array([8, 159, 5, 16]), new Int32Array([8, 160, 16, 7]), new Int32Array([8, 161, 16, 2]), new Int32Array([8, 162, 16, 8]), new Int32Array([8, 163, 2, 7]), new Int32Array([8, 164, 7, 2]), new Int32Array([8, 165, 3, 7]), new Int32Array([8, 166, 6, 5]), new Int32Array([8, 167, 5, 6]), new Int32Array([8, 168, 6, 16]), new Int32Array([8, 169, 16, 10]), new Int32Array([8, 170, 7, 3]), new Int32Array([8, 171, 7, 1]), new Int32Array([8, 172, 16, 9]), new Int32Array([8, 173, 7, 16]), new Int32Array([8, 174, 1, 16]), new Int32Array([8, 175, 1, 7]), new Int32Array([8, 176, 4, 7]), new Int32Array([8, 177, 16, 11]), new Int32Array([8, 178, 7, 4]), new Int32Array([8, 179, 16, 12]), new Int32Array([8, 180, 8, 16]), new Int32Array([8, 181, 16, 1]), new Int32Array([8, 182, 6, 6]), new Int32Array([8, 183, 9, 16]), new Int32Array([8, 184, 2, 8]), new Int32Array([8, 185, 5, 7]), new Int32Array([8, 186, 10, 16]), new Int32Array([8, 187, 16, 13]), new Int32Array([8, 188, 8, 3]), new Int32Array([8, 189, 8, 2]), new Int32Array([8, 190, 3, 8]), new Int32Array([8, 191, 5, 0]), new Int32Array([8, 192, 16, 14]), new Int32Array([8, 193, 11, 16]), new Int32Array([8, 194, 7, 5]), new Int32Array([8, 195, 4, 8]), new Int32Array([8, 196, 6, 7]), new Int32Array([8, 197, 7, 6]), new Int32Array([8, 198, 0, 5]), new Int32Array([9, 398, 8, 4]), new Int32Array([9, 399, 16, 15]), new Int32Array([9, 400, 12, 16]), new Int32Array([9, 401, 1, 8]), new Int32Array([9, 402, 8, 1]), new Int32Array([9, 403, 14, 16]), new Int32Array([9, 404, 5, 8]), new Int32Array([9, 405, 13, 16]), new Int32Array([9, 406, 3, 9]), new Int32Array([9, 407, 8, 5]), new Int32Array([9, 408, 7, 7]), new Int32Array([9, 409, 2, 9]), new Int32Array([9, 410, 8, 6]), new Int32Array([9, 411, 9, 2]), new Int32Array([9, 412, 9, 3]), new Int32Array([9, 413, 15, 16]), new Int32Array([9, 414, 4, 9]), new Int32Array([9, 415, 6, 8]), new Int32Array([9, 416, 6, 0]), new Int32Array([9, 417, 9, 4]), new Int32Array([9, 418, 5, 9]), new Int32Array([9, 419, 8, 7]), new Int32Array([9, 420, 7, 8]), new Int32Array([9, 421, 1, 9]), new Int32Array([9, 422, 10, 3]), new Int32Array([9, 423, 0, 6]), new Int32Array([9, 424, 10, 2]), new Int32Array([9, 425, 9, 1]), new Int32Array([9, 426, 9, 5]), new Int32Array([9, 427, 4, 10]), new Int32Array([9, 428, 2, 10]), new Int32Array([9, 429, 9, 6]), new Int32Array([9, 430, 3, 10]), new Int32Array([9, 431, 6, 9]), new Int32Array([9, 432, 10, 4]), new Int32Array([9, 433, 8, 8]), new Int32Array([9, 434, 10, 5]), new Int32Array([9, 435, 9, 7]), new Int32Array([9, 436, 11, 3]), new Int32Array([9, 437, 1, 10]), new Int32Array([9, 438, 7, 0]), new Int32Array([9, 439, 10, 6]), new Int32Array([9, 440, 7, 9]), new Int32Array([9, 441, 3, 11]), new Int32Array([9, 442, 5, 10]), new Int32Array([9, 443, 10, 1]), new Int32Array([9, 444, 4, 11]), new Int32Array([9, 445, 11, 2]), new Int32Array([9, 446, 13, 2]), new Int32Array([9, 447, 6, 10]), new Int32Array([9, 448, 13, 3]), new Int32Array([9, 449, 2, 11]), new Int32Array([9, 450, 16, 0]), new Int32Array([9, 451, 5, 11]), new Int32Array([9, 452, 11, 5]), new Int32Array([10, 906, 11, 4]), new Int32Array([10, 907, 9, 8]), new Int32Array([10, 908, 7, 10]), new Int32Array([10, 909, 8, 9]), new Int32Array([10, 910, 0, 16]), new Int32Array([10, 911, 4, 13]), new Int32Array([10, 912, 0, 7]), new Int32Array([10, 913, 3, 13]), new Int32Array([10, 914, 11, 6]), new Int32Array([10, 915, 13, 1]), new Int32Array([10, 916, 13, 4]), new Int32Array([10, 917, 12, 3]), new Int32Array([10, 918, 2, 13]), new Int32Array([10, 919, 13, 5]), new Int32Array([10, 920, 8, 10]), new Int32Array([10, 921, 6, 11]), new Int32Array([10, 922, 10, 8]), new Int32Array([10, 923, 10, 7]), new Int32Array([10, 924, 14, 2]), new Int32Array([10, 925, 12, 4]), new Int32Array([10, 926, 1, 11]), new Int32Array([10, 927, 4, 12]), new Int32Array([10, 928, 11, 1]), new Int32Array([10, 929, 3, 12]), new Int32Array([10, 930, 1, 13]), new Int32Array([10, 931, 12, 2]), new Int32Array([10, 932, 7, 11]), new Int32Array([10, 933, 3, 14]), new Int32Array([10, 934, 5, 12]), new Int32Array([10, 935, 5, 13]), new Int32Array([10, 936, 14, 4]), new Int32Array([10, 937, 4, 14]), new Int32Array([10, 938, 11, 7]), new Int32Array([10, 939, 14, 3]), new Int32Array([10, 940, 12, 5]), new Int32Array([10, 941, 13, 6]), new Int32Array([10, 942, 12, 6]), new Int32Array([10, 943, 8, 0]), new Int32Array([10, 944, 11, 8]), new Int32Array([10, 945, 2, 12]), new Int32Array([10, 946, 9, 9]), new Int32Array([10, 947, 14, 5]), new Int32Array([10, 948, 6, 13]), new Int32Array([10, 949, 10, 10]), new Int32Array([10, 950, 15, 2]), new Int32Array([10, 951, 8, 11]), new Int32Array([10, 952, 9, 10]), new Int32Array([10, 953, 14, 6]), new Int32Array([10, 954, 10, 9]), new Int32Array([10, 955, 5, 14]), new Int32Array([10, 956, 11, 9]), new Int32Array([10, 957, 14, 1]), new Int32Array([10, 958, 2, 14]), new Int32Array([10, 959, 6, 12]), new Int32Array([10, 960, 1, 12]), new Int32Array([10, 961, 13, 8]), new Int32Array([10, 962, 0, 8]), new Int32Array([10, 963, 13, 7]), new Int32Array([10, 964, 7, 12]), new Int32Array([10, 965, 12, 7]), new Int32Array([10, 966, 7, 13]), new Int32Array([10, 967, 15, 3]), new Int32Array([10, 968, 12, 1]), new Int32Array([10, 969, 6, 14]), new Int32Array([10, 970, 2, 15]), new Int32Array([10, 971, 15, 5]), new Int32Array([10, 972, 15, 4]), new Int32Array([10, 973, 1, 14]), new Int32Array([10, 974, 9, 11]), new Int32Array([10, 975, 4, 15]), new Int32Array([10, 976, 14, 7]), new Int32Array([10, 977, 8, 13]), new Int32Array([10, 978, 13, 9]), new Int32Array([10, 979, 8, 12]), new Int32Array([10, 980, 5, 15]), new Int32Array([10, 981, 3, 15]), new Int32Array([10, 982, 10, 11]), new Int32Array([10, 983, 11, 10]), new Int32Array([10, 984, 12, 8]), new Int32Array([10, 985, 15, 6]), new Int32Array([10, 986, 15, 7]), new Int32Array([10, 987, 8, 14]), new Int32Array([10, 988, 15, 1]), new Int32Array([10, 989, 7, 14]), new Int32Array([10, 990, 9, 0]), new Int32Array([10, 991, 0, 9]), new Int32Array([10, 992, 9, 13]), new Int32Array([10, 993, 9, 12]), new Int32Array([10, 994, 12, 9]), new Int32Array([10, 995, 14, 8]), new Int32Array([10, 996, 10, 13]), new Int32Array([10, 997, 14, 9]), new Int32Array([10, 998, 12, 10]), new Int32Array([10, 999, 6, 15]), new Int32Array([10, 1000, 7, 15]), new Int32Array([11, 2002, 9, 14]), new Int32Array([11, 2003, 15, 8]), new Int32Array([11, 2004, 11, 11]), new Int32Array([11, 2005, 11, 14]), new Int32Array([11, 2006, 1, 15]), new Int32Array([11, 2007, 10, 12]), new Int32Array([11, 2008, 10, 14]), new Int32Array([11, 2009, 13, 11]), new Int32Array([11, 2010, 13, 10]), new Int32Array([11, 2011, 11, 13]), new Int32Array([11, 2012, 11, 12]), new Int32Array([11, 2013, 8, 15]), new Int32Array([11, 2014, 14, 11]), new Int32Array([11, 2015, 13, 12]), new Int32Array([11, 2016, 12, 13]), new Int32Array([11, 2017, 15, 9]), new Int32Array([11, 2018, 14, 10]), new Int32Array([11, 2019, 10, 0]), new Int32Array([11, 2020, 12, 11]), new Int32Array([11, 2021, 9, 15]), new Int32Array([11, 2022, 0, 10]), new Int32Array([11, 2023, 12, 12]), new Int32Array([11, 2024, 11, 0]), new Int32Array([11, 2025, 12, 14]), new Int32Array([11, 2026, 10, 15]), new Int32Array([11, 2027, 13, 13]), new Int32Array([11, 2028, 0, 13]), new Int32Array([11, 2029, 14, 12]), new Int32Array([11, 2030, 15, 10]), new Int32Array([11, 2031, 15, 11]), new Int32Array([11, 2032, 11, 15]), new Int32Array([11, 2033, 14, 13]), new Int32Array([11, 2034, 13, 0]), new Int32Array([11, 2035, 0, 11]), new Int32Array([11, 2036, 13, 14]), new Int32Array([11, 2037, 15, 12]), new Int32Array([11, 2038, 15, 13]), new Int32Array([11, 2039, 12, 15]), new Int32Array([11, 2040, 14, 0]), new Int32Array([11, 2041, 14, 14]), new Int32Array([11, 2042, 13, 15]), new Int32Array([11, 2043, 12, 0]), new Int32Array([11, 2044, 14, 15]), new Int32Array([12, 4090, 0, 14]), new Int32Array([12, 4091, 0, 12]), new Int32Array([12, 4092, 15, 14]), new Int32Array([12, 4093, 15, 0]), new Int32Array([12, 4094, 0, 15]), new Int32Array([12, 4095, 15, 15])];
    constructor.HCB_SF = [new Int32Array([1, 0, 60]), new Int32Array([3, 4, 59]), new Int32Array([4, 10, 61]), new Int32Array([4, 11, 58]), new Int32Array([4, 12, 62]), new Int32Array([5, 26, 57]), new Int32Array([5, 27, 63]), new Int32Array([6, 56, 56]), new Int32Array([6, 57, 64]), new Int32Array([6, 58, 55]), new Int32Array([6, 59, 65]), new Int32Array([7, 120, 66]), new Int32Array([7, 121, 54]), new Int32Array([7, 122, 67]), new Int32Array([8, 246, 53]), new Int32Array([8, 247, 68]), new Int32Array([8, 248, 52]), new Int32Array([8, 249, 69]), new Int32Array([8, 250, 51]), new Int32Array([9, 502, 70]), new Int32Array([9, 503, 50]), new Int32Array([9, 504, 49]), new Int32Array([9, 505, 71]), new Int32Array([10, 1012, 72]), new Int32Array([10, 1013, 48]), new Int32Array([10, 1014, 73]), new Int32Array([10, 1015, 47]), new Int32Array([10, 1016, 74]), new Int32Array([10, 1017, 46]), new Int32Array([11, 2036, 76]), new Int32Array([11, 2037, 75]), new Int32Array([11, 2038, 77]), new Int32Array([11, 2039, 78]), new Int32Array([11, 2040, 45]), new Int32Array([11, 2041, 43]), new Int32Array([12, 4084, 44]), new Int32Array([12, 4085, 79]), new Int32Array([12, 4086, 42]), new Int32Array([12, 4087, 41]), new Int32Array([12, 4088, 80]), new Int32Array([12, 4089, 40]), new Int32Array([13, 8180, 81]), new Int32Array([13, 8181, 39]), new Int32Array([13, 8182, 82]), new Int32Array([13, 8183, 38]), new Int32Array([13, 8184, 83]), new Int32Array([14, 16370, 37]), new Int32Array([14, 16371, 35]), new Int32Array([14, 16372, 85]), new Int32Array([14, 16373, 33]), new Int32Array([14, 16374, 36]), new Int32Array([14, 16375, 34]), new Int32Array([14, 16376, 84]), new Int32Array([14, 16377, 32]), new Int32Array([15, 32756, 87]), new Int32Array([15, 32757, 89]), new Int32Array([15, 32758, 30]), new Int32Array([15, 32759, 31]), new Int32Array([16, 65520, 86]), new Int32Array([16, 65521, 29]), new Int32Array([16, 65522, 26]), new Int32Array([16, 65523, 27]), new Int32Array([16, 65524, 28]), new Int32Array([16, 65525, 24]), new Int32Array([16, 65526, 88]), new Int32Array([17, 131054, 25]), new Int32Array([17, 131055, 22]), new Int32Array([17, 131056, 23]), new Int32Array([18, 262114, 90]), new Int32Array([18, 262115, 21]), new Int32Array([18, 262116, 19]), new Int32Array([18, 262117, 3]), new Int32Array([18, 262118, 1]), new Int32Array([18, 262119, 2]), new Int32Array([18, 262120, 0]), new Int32Array([19, 524242, 98]), new Int32Array([19, 524243, 99]), new Int32Array([19, 524244, 100]), new Int32Array([19, 524245, 101]), new Int32Array([19, 524246, 102]), new Int32Array([19, 524247, 117]), new Int32Array([19, 524248, 97]), new Int32Array([19, 524249, 91]), new Int32Array([19, 524250, 92]), new Int32Array([19, 524251, 93]), new Int32Array([19, 524252, 94]), new Int32Array([19, 524253, 95]), new Int32Array([19, 524254, 96]), new Int32Array([19, 524255, 104]), new Int32Array([19, 524256, 111]), new Int32Array([19, 524257, 112]), new Int32Array([19, 524258, 113]), new Int32Array([19, 524259, 114]), new Int32Array([19, 524260, 115]), new Int32Array([19, 524261, 116]), new Int32Array([19, 524262, 110]), new Int32Array([19, 524263, 105]), new Int32Array([19, 524264, 106]), new Int32Array([19, 524265, 107]), new Int32Array([19, 524266, 108]), new Int32Array([19, 524267, 109]), new Int32Array([19, 524268, 118]), new Int32Array([19, 524269, 6]), new Int32Array([19, 524270, 8]), new Int32Array([19, 524271, 9]), new Int32Array([19, 524272, 10]), new Int32Array([19, 524273, 5]), new Int32Array([19, 524274, 103]), new Int32Array([19, 524275, 120]), new Int32Array([19, 524276, 119]), new Int32Array([19, 524277, 4]), new Int32Array([19, 524278, 7]), new Int32Array([19, 524279, 15]), new Int32Array([19, 524280, 16]), new Int32Array([19, 524281, 18]), new Int32Array([19, 524282, 20]), new Int32Array([19, 524283, 17]), new Int32Array([19, 524284, 11]), new Int32Array([19, 524285, 12]), new Int32Array([19, 524286, 14]), new Int32Array([19, 524287, 13])];
    constructor.CODEBOOKS = [Codebooks.HCB1, Codebooks.HCB2, Codebooks.HCB3, Codebooks.HCB4, Codebooks.HCB5, Codebooks.HCB6, Codebooks.HCB7, Codebooks.HCB8, Codebooks.HCB9, Codebooks.HCB10, Codebooks.HCB11];
}, {HCB1: "Array", HCB2: "Array", HCB3: "Array", HCB4: "Array", HCB5: "Array", HCB6: "Array", HCB7: "Array", HCB8: "Array", HCB9: "Array", HCB10: "Array", HCB11: "Array", HCB_SF: "Array", CODEBOOKS: "Array"}, {});
var NotSupportedException = function(_arguments) {
    RuntimeException.call(this, "" + arguments);
};
NotSupportedException = stjs.extend(NotSupportedException, RuntimeException, [], null, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var SliceType = function(name, ordinal) {
    this._name = name;
    this._ordinal = ordinal;
    SliceType._values[ordinal] = this;
};
SliceType = stjs.extend(SliceType, null, [], function(constructor, prototype) {
    constructor._values = Array(5);
    constructor.P = new SliceType("P", 0);
    constructor.B = new SliceType("B", 1);
    constructor.I = new SliceType("I", 2);
    constructor.SP = new SliceType("SP", 3);
    constructor.SI = new SliceType("SI", 4);
    prototype._name = null;
    prototype._ordinal = 0;
    prototype.isIntra = function() {
        return this == SliceType.I || this == SliceType.SI;
    };
    prototype.isInter = function() {
        return this != SliceType.I && this != SliceType.SI;
    };
    constructor.values = function() {
        return SliceType._values;
    };
    prototype.ordinal = function() {
        return this._ordinal;
    };
    prototype.toString = function() {
        return this._name;
    };
    prototype.name = function() {
        return this._name;
    };
    constructor.fromValue = function(j) {
        return SliceType.values()[j];
    };
}, {_values: "Array", P: "SliceType", B: "SliceType", I: "SliceType", SP: "SliceType", SI: "SliceType"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Represents a section of PSI payload ( Program Stream Information ) MPEG
 *  Transport stream
 *  
 *  @author The JCodec project
 *  
 */
var PSISection = function(tableId, specificId, versionNumber, currentNextIndicator, sectionNumber, lastSectionNumber) {
    this.tableId = tableId;
    this.specificId = specificId;
    this.versionNumber = versionNumber;
    this.currentNextIndicator = currentNextIndicator;
    this.sectionNumber = sectionNumber;
    this.lastSectionNumber = lastSectionNumber;
};
PSISection = stjs.extend(PSISection, null, [], function(constructor, prototype) {
    prototype.tableId = 0;
    prototype.specificId = 0;
    prototype.versionNumber = 0;
    prototype.currentNextIndicator = 0;
    prototype.sectionNumber = 0;
    prototype.lastSectionNumber = 0;
    constructor.parsePSI = function(data) {
        var tableId = data.get() & 255;
        var w0 = data.getShort() & 65535;
        if ((w0 & 49152) != 32768) 
             throw new RuntimeException("Invalid section data");
        var sectionLength = w0 & 4095;
        data.setLimit(data.position() + sectionLength);
        var specificId = data.getShort() & 65535;
        var b0 = data.get() & 255;
        var versionNumber = (b0 >> 1) & 31;
        var currentNextIndicator = b0 & 1;
        var sectionNumber = data.get() & 255;
        var lastSectionNumber = data.get() & 255;
        return new PSISection(tableId, specificId, versionNumber, currentNextIndicator, sectionNumber, lastSectionNumber);
    };
    prototype.getTableId = function() {
        return this.tableId;
    };
    prototype.getSpecificId = function() {
        return this.specificId;
    };
    prototype.getVersionNumber = function() {
        return this.versionNumber;
    };
    prototype.getCurrentNextIndicator = function() {
        return this.currentNextIndicator;
    };
    prototype.getSectionNumber = function() {
        return this.sectionNumber;
    };
    prototype.getLastSectionNumber = function() {
        return this.lastSectionNumber;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  MPEG 4 AVC ( H.264 ) Encoder pluggable rate control mechanism
 *  
 *  @author The JCodec project
 *  
 */
var RateControl = function() {};
RateControl = stjs.extend(RateControl, null, [], function(constructor, prototype) {
    prototype.getInitQp = function(sliceType) {};
    prototype.getQpDelta = function() {};
    prototype.accept = function(bits) {};
    prototype.reset = function() {};
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MBType = function(intra, code) {
    this.intra = intra;
    this._code = code;
};
MBType = stjs.extend(MBType, null, [], function(constructor, prototype) {
    constructor.I_NxN = new MBType(true, 0);
    constructor.I_16x16 = new MBType(true, 1);
    constructor.I_PCM = new MBType(true, 25);
    constructor.P_16x16 = new MBType(false, 0);
    constructor.P_16x8 = new MBType(false, 1);
    constructor.P_8x16 = new MBType(false, 2);
    constructor.P_8x8 = new MBType(false, 3);
    constructor.P_8x8ref0 = new MBType(false, 4);
    constructor.B_Direct_16x16 = new MBType(false, 0);
    constructor.B_L0_16x16 = new MBType(false, 1);
    constructor.B_L1_16x16 = new MBType(false, 2);
    constructor.B_Bi_16x16 = new MBType(false, 3);
    constructor.B_L0_L0_16x8 = new MBType(false, 4);
    constructor.B_L0_L0_8x16 = new MBType(false, 5);
    constructor.B_L1_L1_16x8 = new MBType(false, 6);
    constructor.B_L1_L1_8x16 = new MBType(false, 7);
    constructor.B_L0_L1_16x8 = new MBType(false, 8);
    constructor.B_L0_L1_8x16 = new MBType(false, 9);
    constructor.B_L1_L0_16x8 = new MBType(false, 10);
    constructor.B_L1_L0_8x16 = new MBType(false, 11);
    constructor.B_L0_Bi_16x8 = new MBType(false, 12);
    constructor.B_L0_Bi_8x16 = new MBType(false, 13);
    constructor.B_L1_Bi_16x8 = new MBType(false, 14);
    constructor.B_L1_Bi_8x16 = new MBType(false, 15);
    constructor.B_Bi_L0_16x8 = new MBType(false, 16);
    constructor.B_Bi_L0_8x16 = new MBType(false, 17);
    constructor.B_Bi_L1_16x8 = new MBType(false, 18);
    constructor.B_Bi_L1_8x16 = new MBType(false, 19);
    constructor.B_Bi_Bi_16x8 = new MBType(false, 20);
    constructor.B_Bi_Bi_8x16 = new MBType(false, 21);
    constructor.B_8x8 = new MBType(false, 22);
    prototype.intra = false;
    prototype._code = 0;
    prototype.isIntra = function() {
        return this.intra;
    };
    prototype.code = function() {
        return this._code;
    };
}, {I_NxN: "MBType", I_16x16: "MBType", I_PCM: "MBType", P_16x16: "MBType", P_16x8: "MBType", P_8x16: "MBType", P_8x8: "MBType", P_8x8ref0: "MBType", B_Direct_16x16: "MBType", B_L0_16x16: "MBType", B_L1_16x16: "MBType", B_Bi_16x16: "MBType", B_L0_L0_16x8: "MBType", B_L0_L0_8x16: "MBType", B_L1_L1_16x8: "MBType", B_L1_L1_8x16: "MBType", B_L0_L1_16x8: "MBType", B_L0_L1_8x16: "MBType", B_L1_L0_16x8: "MBType", B_L1_L0_8x16: "MBType", B_L0_Bi_16x8: "MBType", B_L0_Bi_8x16: "MBType", B_L1_Bi_16x8: "MBType", B_L1_Bi_8x16: "MBType", B_Bi_L0_16x8: "MBType", B_Bi_L0_8x16: "MBType", B_Bi_L1_16x8: "MBType", B_Bi_L1_8x16: "MBType", B_Bi_Bi_16x8: "MBType", B_Bi_Bi_8x16: "MBType", B_8x8: "MBType"}, {});
var UnhandledStateException = function(string) {
    RuntimeException.call(this, string);
};
UnhandledStateException = stjs.extend(UnhandledStateException, RuntimeException, [], null, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  @author The JCodec project
 */
var AutoResource = function() {};
AutoResource = stjs.extend(AutoResource, null, [], function(constructor, prototype) {
    prototype.setCurTime = function(curTime) {};
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var ScalingMatrix = function() {};
ScalingMatrix = stjs.extend(ScalingMatrix, null, [], function(constructor, prototype) {
    prototype.ScalingList4x4 = null;
    prototype.ScalingList8x8 = null;
}, {ScalingList4x4: "Array", ScalingList8x8: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var ContainerAdaptor = function() {};
ContainerAdaptor = stjs.extend(ContainerAdaptor, null, [], function(constructor, prototype) {
    prototype.decodeFrame = function(packet, data) {};
    prototype.decodeFrame8Bit = function(packet, data) {};
    prototype.canSeek = function(data) {};
    prototype.allocatePicture = function() {};
    prototype.allocatePicture8Bit = function() {};
    prototype.getMediaInfo = function() {};
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var JCodecException = function(arg0) {
    Exception.call(this, arg0);
};
JCodecException = stjs.extend(JCodecException, Exception, [], null, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var MPEGDemuxer = function() {};
MPEGDemuxer = stjs.extend(MPEGDemuxer, null, [], function(constructor, prototype) {
    prototype.getTracks = function() {};
    prototype.getVideoTracks = function() {};
    prototype.getAudioTracks = function() {};
    prototype.seekByte = function(offset) {};
    constructor.MPEGDemuxerTrack = function() {};
    constructor.MPEGDemuxerTrack = stjs.extend(constructor.MPEGDemuxerTrack, null, [], function(constructor, prototype) {
        prototype.nextFrame = function(buf) {};
        prototype.getMeta = function() {};
        prototype.ignore = function() {};
    }, {}, {});
}, {}, {});
var PESPacket = function(data, pts, streamId, length, pos, dts) {
    this.data = data;
    this.pts = pts;
    this.streamId = streamId;
    this.length = length;
    this.pos = pos;
    this.dts = dts;
};
PESPacket = stjs.extend(PESPacket, null, [], function(constructor, prototype) {
    prototype.data = null;
    prototype.pts = 0;
    prototype.streamId = 0;
    prototype.length = 0;
    prototype.pos = 0;
    prototype.dts = 0;
}, {data: "ByteBuffer"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var VP8Util = function() {};
VP8Util = stjs.extend(VP8Util, null, [], function(constructor, prototype) {
    constructor.BLOCK_TYPES = 4;
    constructor.COEF_BANDS = 8;
    constructor.PREV_COEF_CONTEXTS = 3;
    constructor.MAX_ENTROPY_TOKENS = 12;
    constructor.MAX_MODE_LF_DELTAS = 4;
    constructor.MAX_REF_LF_DELTAS = 4;
    constructor.MB_FEATURE_TREE_PROBS = 3;
    /**
     *  delta() is the process to read 5 bits from the bitstream to determine a signed delta value:
     *  
     *  +-------+--------------------------------------------------+
     *  | Index | Description                                      |
     *  +-------+--------------------------------------------------+
     *  | L(4)  | Magnitude of delta                               |
     *  | L(1)  | Sign of delta, 0 for positive and 1 for negative |
     *  +-------+--------------------------------------------------+
     *  
     *  @param bc
     *  @return
     *  @throws IOException
     */
    constructor.delta = function(bc) {
        var magnitude = bc.decodeInt(4);
        if (bc.decodeBit() > 0) 
            magnitude = -magnitude;
        return magnitude;
    };
    constructor.SubblockConstants = function() {};
    constructor.SubblockConstants = stjs.extend(constructor.SubblockConstants, null, [], function(constructor, prototype) {
        /**
         *  predict DC using row above and column to the left
         */
        constructor.B_DC_PRED = 0;
        /**
         *  propagate second differences a la "true motion"
         */
        constructor.B_TM_PRED = 1;
        /**
         * 
         *  predict rows using row above 
         */
        constructor.B_VE_PRED = 2;
        /**
         *  predict columns using column to the left
         */
        constructor.B_HE_PRED = 3;
        /**
         *  southwest (left and down) 45 degree diagonal prediction
         */
        constructor.B_LD_PRED = 4;
        /**
         * 
         *  southeast (right and down) "" 
         */
        constructor.B_RD_PRED = 5;
        /**
         *  SSE (vertical right) diagonal prediction
         */
        constructor.B_VR_PRED = 6;
        /**
         * 
         *  SSW (vertical left) "" 
         */
        constructor.B_VL_PRED = 7;
        /**
         *   ESE (horizontal down) "" 
         */
        constructor.B_HD_PRED = 8;
        /**
         * 
         *  ENE (horizontal up) "" 
         */
        constructor.B_HU_PRED = 9;
        /**
         *  predict DC using row above and column to the left
         */
        constructor.DC_PRED = 0;
        /**
         * 
         *  predict rows using row above 
         */
        constructor.V_PRED = 1;
        /**
         *  predict columns using column to the left
         */
        constructor.H_PRED = 2;
        /**
         *  propagate second differences a la "true motion"
         */
        constructor.TM_PRED = 3;
        /**
         *  each Y subblock is independently predicted
         */
        constructor.B_PRED = 4;
        /**
         * exact value: 0 
         */
        constructor.DCT_0 = 0;
        /**
         * exact value: 1 
         */
        constructor.DCT_1 = 1;
        /**
         * exact value: 2 
         */
        constructor.DCT_2 = 2;
        /**
         * exact value: 3 
         */
        constructor.DCT_3 = 3;
        /**
         * exact value: 4 
         */
        constructor.DCT_4 = 4;
        /**
         * value range: [5,6] 
         */
        constructor.cat_5_6 = 5;
        /**
         * value range: [7, 8, 9, 10] size == 4 
         */
        constructor.cat_7_10 = 6;
        /**
         * value range: [11, 12, 13, 14, 15, 16, 17, 18] size == 8 
         */
        constructor.cat_11_18 = 7;
        /**
         * value range: [19 - 34] size == 16 
         */
        constructor.cat_19_34 = 8;
        /**
         * value range: [35 - 66] size == 32 
         */
        constructor.cat_35_66 = 9;
        /**
         * value range: [67 - 2048] size == 1982 
         */
        constructor.cat_67_2048 = 10;
        /**
         * end of block 
         */
        constructor.dct_eob = 11;
        /**
         *  <pre>
         *     <root> 
         *     /    \
         *  dct_eob  2
         *          /  \
         *       DCO_0  4
         *             /  \ 
         *           DCT_1 \ 
         *                  6-------+
         *                 /         \
         *                /           \ 
         *               8             \
         *              / \             \    
         *         DCT_2  10             \
         *               /  \            12-----+
         *           DCT_3  DCY_4       /        \
         *                            14          16
         *                           /  \        /  \
         *                       cat1   cat2    /    \
         *                                     18     20----+ 
         *                                    /  \     |     \
         *                                 cat3  cat4  cat5  cat6
         *  </pre>
         */
        constructor.vp8CoefTree = new Int32Array([-VP8Util.SubblockConstants.dct_eob, 2, -VP8Util.SubblockConstants.DCT_0, 4, -VP8Util.SubblockConstants.DCT_1, 6, 8, 12, -VP8Util.SubblockConstants.DCT_2, 10, -VP8Util.SubblockConstants.DCT_3, -VP8Util.SubblockConstants.DCT_4, 14, 16, -VP8Util.SubblockConstants.cat_5_6, -VP8Util.SubblockConstants.cat_7_10, 18, 20, -VP8Util.SubblockConstants.cat_11_18, -VP8Util.SubblockConstants.cat_19_34, -VP8Util.SubblockConstants.cat_35_66, -VP8Util.SubblockConstants.cat_67_2048]);
        constructor.vp8CoefBands = new Int32Array([0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7]);
        /**
         *  <pre>
         *   0---1   2---3
         *     /   /   /   
         *   4   5   6   7
         *   | /   /   / | 
         *   8   9   10  11
         *     /   /   /   
         *   12--13  14--15
         *   </pre>
         */
        constructor.vp8defaultZigZag1d = new Int32Array([0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15]);
        /**
         * 
         *  <pre>
         *       <root>
         *      /      \
         *  B_DC_PRED   2
         *            /  \
         *   B_TM_PRED    4
         *              /   \
         *      B_VE_PRED    6---------------------+
         *                 /                        \        
         *                8                         12
         *              /  \                      /   \
         *      B_HE_PRED  10             B_LD_PRED    14
         *                /  \                       /   \
         *       B_RD_PRED  B_VR_PRED        B_VL_PRED    16
         *                                              /   \
         *                                      B_HD_PRED  B_HU_PRED
         *  </pre>
         */
        constructor.subblockModeTree = new Int32Array([-VP8Util.SubblockConstants.B_DC_PRED, 2, -VP8Util.SubblockConstants.B_TM_PRED, 4, -VP8Util.SubblockConstants.B_VE_PRED, 6, 8, 12, -VP8Util.SubblockConstants.B_HE_PRED, 10, -VP8Util.SubblockConstants.B_RD_PRED, -VP8Util.SubblockConstants.B_VR_PRED, -VP8Util.SubblockConstants.B_LD_PRED, 14, -VP8Util.SubblockConstants.B_VL_PRED, 16, -VP8Util.SubblockConstants.B_HD_PRED, -VP8Util.SubblockConstants.B_HU_PRED]);
        constructor.Pcat1 = new Int32Array([159, 0]);
        constructor.Pcat2 = new Int32Array([165, 145, 0]);
        constructor.Pcat3 = new Int32Array([173, 148, 140, 0]);
        constructor.Pcat4 = new Int32Array([176, 155, 140, 135, 0]);
        constructor.Pcat5 = new Int32Array([180, 157, 141, 134, 130, 0]);
        constructor.Pcat6 = new Int32Array([254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 0]);
        constructor.keyFrameSubblockModeProb = [[new Int32Array([231, 120, 48, 89, 115, 113, 120, 152, 112]), new Int32Array([152, 179, 64, 126, 170, 118, 46, 70, 95]), new Int32Array([175, 69, 143, 80, 85, 82, 72, 155, 103]), new Int32Array([56, 58, 10, 171, 218, 189, 17, 13, 152]), new Int32Array([144, 71, 10, 38, 171, 213, 144, 34, 26]), new Int32Array([114, 26, 17, 163, 44, 195, 21, 10, 173]), new Int32Array([121, 24, 80, 195, 26, 62, 44, 64, 85]), new Int32Array([170, 46, 55, 19, 136, 160, 33, 206, 71]), new Int32Array([63, 20, 8, 114, 114, 208, 12, 9, 226]), new Int32Array([81, 40, 11, 96, 182, 84, 29, 16, 36])], [new Int32Array([134, 183, 89, 137, 98, 101, 106, 165, 148]), new Int32Array([72, 187, 100, 130, 157, 111, 32, 75, 80]), new Int32Array([66, 102, 167, 99, 74, 62, 40, 234, 128]), new Int32Array([41, 53, 9, 178, 241, 141, 26, 8, 107]), new Int32Array([104, 79, 12, 27, 217, 255, 87, 17, 7]), new Int32Array([74, 43, 26, 146, 73, 166, 49, 23, 157]), new Int32Array([65, 38, 105, 160, 51, 52, 31, 115, 128]), new Int32Array([87, 68, 71, 44, 114, 51, 15, 186, 23]), new Int32Array([47, 41, 14, 110, 182, 183, 21, 17, 194]), new Int32Array([66, 45, 25, 102, 197, 189, 23, 18, 22])], [new Int32Array([88, 88, 147, 150, 42, 46, 45, 196, 205]), new Int32Array([43, 97, 183, 117, 85, 38, 35, 179, 61]), new Int32Array([39, 53, 200, 87, 26, 21, 43, 232, 171]), new Int32Array([56, 34, 51, 104, 114, 102, 29, 93, 77]), new Int32Array([107, 54, 32, 26, 51, 1, 81, 43, 31]), new Int32Array([39, 28, 85, 171, 58, 165, 90, 98, 64]), new Int32Array([34, 22, 116, 206, 23, 34, 43, 166, 73]), new Int32Array([68, 25, 106, 22, 64, 171, 36, 225, 114]), new Int32Array([34, 19, 21, 102, 132, 188, 16, 76, 124]), new Int32Array([62, 18, 78, 95, 85, 57, 50, 48, 51])], [new Int32Array([193, 101, 35, 159, 215, 111, 89, 46, 111]), new Int32Array([60, 148, 31, 172, 219, 228, 21, 18, 111]), new Int32Array([112, 113, 77, 85, 179, 255, 38, 120, 114]), new Int32Array([40, 42, 1, 196, 245, 209, 10, 25, 109]), new Int32Array([100, 80, 8, 43, 154, 1, 51, 26, 71]), new Int32Array([88, 43, 29, 140, 166, 213, 37, 43, 154]), new Int32Array([61, 63, 30, 155, 67, 45, 68, 1, 209]), new Int32Array([142, 78, 78, 16, 255, 128, 34, 197, 171]), new Int32Array([41, 40, 5, 102, 211, 183, 4, 1, 221]), new Int32Array([51, 50, 17, 168, 209, 192, 23, 25, 82])], [new Int32Array([125, 98, 42, 88, 104, 85, 117, 175, 82]), new Int32Array([95, 84, 53, 89, 128, 100, 113, 101, 45]), new Int32Array([75, 79, 123, 47, 51, 128, 81, 171, 1]), new Int32Array([57, 17, 5, 71, 102, 57, 53, 41, 49]), new Int32Array([115, 21, 2, 10, 102, 255, 166, 23, 6]), new Int32Array([38, 33, 13, 121, 57, 73, 26, 1, 85]), new Int32Array([41, 10, 67, 138, 77, 110, 90, 47, 114]), new Int32Array([101, 29, 16, 10, 85, 128, 101, 196, 26]), new Int32Array([57, 18, 10, 102, 102, 213, 34, 20, 43]), new Int32Array([117, 20, 15, 36, 163, 128, 68, 1, 26])], [new Int32Array([138, 31, 36, 171, 27, 166, 38, 44, 229]), new Int32Array([67, 87, 58, 169, 82, 115, 26, 59, 179]), new Int32Array([63, 59, 90, 180, 59, 166, 93, 73, 154]), new Int32Array([40, 40, 21, 116, 143, 209, 34, 39, 175]), new Int32Array([57, 46, 22, 24, 128, 1, 54, 17, 37]), new Int32Array([47, 15, 16, 183, 34, 223, 49, 45, 183]), new Int32Array([46, 17, 33, 183, 6, 98, 15, 32, 183]), new Int32Array([65, 32, 73, 115, 28, 128, 23, 128, 205]), new Int32Array([40, 3, 9, 115, 51, 192, 18, 6, 223]), new Int32Array([87, 37, 9, 115, 59, 77, 64, 21, 47])], [new Int32Array([104, 55, 44, 218, 9, 54, 53, 130, 226]), new Int32Array([64, 90, 70, 205, 40, 41, 23, 26, 57]), new Int32Array([54, 57, 112, 184, 5, 41, 38, 166, 213]), new Int32Array([30, 34, 26, 133, 152, 116, 10, 32, 134]), new Int32Array([75, 32, 12, 51, 192, 255, 160, 43, 51]), new Int32Array([39, 19, 53, 221, 26, 114, 32, 73, 255]), new Int32Array([31, 9, 65, 234, 2, 15, 1, 118, 73]), new Int32Array([88, 31, 35, 67, 102, 85, 55, 186, 85]), new Int32Array([56, 21, 23, 111, 59, 205, 45, 37, 192]), new Int32Array([55, 38, 70, 124, 73, 102, 1, 34, 98])], [new Int32Array([102, 61, 71, 37, 34, 53, 31, 243, 192]), new Int32Array([69, 60, 71, 38, 73, 119, 28, 222, 37]), new Int32Array([68, 45, 128, 34, 1, 47, 11, 245, 171]), new Int32Array([62, 17, 19, 70, 146, 85, 55, 62, 70]), new Int32Array([75, 15, 9, 9, 64, 255, 184, 119, 16]), new Int32Array([37, 43, 37, 154, 100, 163, 85, 160, 1]), new Int32Array([63, 9, 92, 136, 28, 64, 32, 201, 85]), new Int32Array([86, 6, 28, 5, 64, 255, 25, 248, 1]), new Int32Array([56, 8, 17, 132, 137, 255, 55, 116, 128]), new Int32Array([58, 15, 20, 82, 135, 57, 26, 121, 40])], [new Int32Array([164, 50, 31, 137, 154, 133, 25, 35, 218]), new Int32Array([51, 103, 44, 131, 131, 123, 31, 6, 158]), new Int32Array([86, 40, 64, 135, 148, 224, 45, 183, 128]), new Int32Array([22, 26, 17, 131, 240, 154, 14, 1, 209]), new Int32Array([83, 12, 13, 54, 192, 255, 68, 47, 28]), new Int32Array([45, 16, 21, 91, 64, 222, 7, 1, 197]), new Int32Array([56, 21, 39, 155, 60, 138, 23, 102, 213]), new Int32Array([85, 26, 85, 85, 128, 128, 32, 146, 171]), new Int32Array([18, 11, 7, 63, 144, 171, 4, 4, 246]), new Int32Array([35, 27, 10, 146, 174, 171, 12, 26, 128])], [new Int32Array([190, 80, 35, 99, 180, 80, 126, 54, 45]), new Int32Array([85, 126, 47, 87, 176, 51, 41, 20, 32]), new Int32Array([101, 75, 128, 139, 118, 146, 116, 128, 85]), new Int32Array([56, 41, 15, 176, 236, 85, 37, 9, 62]), new Int32Array([146, 36, 19, 30, 171, 255, 97, 27, 20]), new Int32Array([71, 30, 17, 119, 118, 255, 17, 18, 138]), new Int32Array([101, 38, 60, 138, 55, 70, 43, 26, 142]), new Int32Array([138, 45, 61, 62, 219, 1, 81, 188, 64]), new Int32Array([32, 41, 20, 117, 151, 142, 20, 21, 163]), new Int32Array([112, 19, 12, 61, 195, 128, 48, 4, 24])]];
    }, {vp8CoefTree: "Int32Array", vp8CoefBands: "Int32Array", vp8defaultZigZag1d: "Int32Array", subblockModeTree: "Int32Array", Pcat1: "Int32Array", Pcat2: "Int32Array", Pcat3: "Int32Array", Pcat4: "Int32Array", Pcat5: "Int32Array", Pcat6: "Int32Array", keyFrameSubblockModeProb: "Array"}, {});
    constructor.getDefaultCoefProbs = function() {
        var r = Array.apply(null, Array(VP8Util.vp8DefaultCoefProbs.length)).map(function() {
            return Array.apply(null, Array(VP8Util.vp8DefaultCoefProbs[0].length)).map(function() {
                return Array.apply(null, Array(VP8Util.vp8DefaultCoefProbs[0][0].length)).map(function() {
                    return new Int32Array(VP8Util.vp8DefaultCoefProbs[0][0][0].length);
                });
            });
        });
        for (var i = 0; i < VP8Util.vp8DefaultCoefProbs.length; i++) 
            for (var j = 0; j < VP8Util.vp8DefaultCoefProbs[0].length; j++) 
                for (var k = 0; k < VP8Util.vp8DefaultCoefProbs[0][0].length; k++) 
                    for (var l = 0; l < VP8Util.vp8DefaultCoefProbs[0][0][0].length; l++) 
                        r[i][j][k][l] = VP8Util.vp8DefaultCoefProbs[i][j][k][l];
        return r;
    };
    constructor.vp8KeyFrameUVModeProb = new Int32Array([142, 114, 183]);
    /**
     * 
     *  <pre>
     *  +-----------------------------+
     *  |         root                |
     *  |        /    \               |
     *  |   -DC_PRED    2             |
     *  |             /   \           |
     *  |       -V_PRED    4          |
     *  |                 /  \        |
     *  |          -H_PRED  -TM_PRED  |
     *  +-----------------------------+
     *  </pre>
     *  
     */
    constructor.vp8UVModeTree = new Int32Array([-VP8Util.SubblockConstants.DC_PRED, 2, -VP8Util.SubblockConstants.V_PRED, 4, -VP8Util.SubblockConstants.H_PRED, -VP8Util.SubblockConstants.TM_PRED]);
    constructor.keyFrameYModeProb = new Int32Array([145, 156, 163, 128]);
    /**
     *  Left branch is picked if 0 is decoded, right branch is picked
     *  if 1 is decoded. Positive value of the node tells the index
     *  of the left-most child. Negative value implies leaf node (no
     *  children), with corresponding absolute value.
     *  
     *  0 implies B_PRED is returned.
     *  100 implies DC_PRED is returned.
     *  101 implies V_PRED is returned
     *  110 - H_PRED
     *  111 - TM_PRED
     *  <pre>
     *  +------------------------------------------+
     *  |         root                             |
     *  |        /    \                            |
     *  |   -B_PRED    2------------               |
     *  |             /             \              |
     *  |            4               6----         |
     *  |          /  \             /     \        |
     *  |   -DC_PRED  -V_PRED   -H_PRED  -TM_PRED  |
     *  +------------------------------------------+
     *  </pre>
     *  
     */
    constructor.keyFrameYModeTree = new Int32Array([-VP8Util.SubblockConstants.B_PRED, 2, 4, 6, -VP8Util.SubblockConstants.DC_PRED, -VP8Util.SubblockConstants.V_PRED, -VP8Util.SubblockConstants.H_PRED, -VP8Util.SubblockConstants.TM_PRED]);
    constructor.getBitInBytes = function(bs, i) {
        var byteIndex = i >> 3;
        var bitIndex = i & 7;
        return (bs[byteIndex] >> bitIndex) & 1;
    };
    constructor.getBitsInBytes = function(bytes, idx, len) {
        var val = 0;
        for (var i = 0; i < len; i++) 
            val |= VP8Util.getBitInBytes(bytes, idx + i) << i;
        return val;
    };
    constructor.getMacroblockCount = function(dimention) {
        if ((dimention & 15) != 0) 
            dimention += 16 - (dimention & 15);
        return dimention >> 4;
    };
    constructor.PRED_BLOCK_127 = new Int32Array([127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127]);
    constructor.PRED_BLOCK_129 = new Int32Array([129, 129, 129, 129, 129, 129, 129, 129, 129, 129, 129, 129, 129, 129, 129, 129]);
    constructor.pickDefaultPrediction = function(intra_bmode) {
        if (intra_bmode == VP8Util.SubblockConstants.B_TM_PRED || intra_bmode == VP8Util.SubblockConstants.B_DC_PRED || intra_bmode == VP8Util.SubblockConstants.B_VE_PRED || intra_bmode == VP8Util.SubblockConstants.B_HE_PRED || intra_bmode == VP8Util.SubblockConstants.B_VR_PRED || intra_bmode == VP8Util.SubblockConstants.B_RD_PRED || intra_bmode == VP8Util.SubblockConstants.B_HD_PRED) 
            return VP8Util.PRED_BLOCK_129;
        return VP8Util.PRED_BLOCK_127;
    };
    constructor.QuantizationParams = function(baseIndex, ydcIndexDelta, y2dcIndexDelta, y2acIndexDelta, chromaDCIndexDelta, chromaACIndexDelta) {
        this.yAC = VP8Util.QuantizationParams.acQLookup[VP8Util.QuantizationParams.clip(baseIndex, 127)];
        this.yDC = VP8Util.QuantizationParams.dcQLookup[VP8Util.QuantizationParams.clip(baseIndex + ydcIndexDelta, 127)];
        this.y2DC = VP8Util.QuantizationParams.dcQLookup[VP8Util.QuantizationParams.clip(baseIndex + y2dcIndexDelta, 127)] * 2;
        this.y2AC = stjs.trunc(VP8Util.QuantizationParams.acQLookup[VP8Util.QuantizationParams.clip(baseIndex + y2acIndexDelta, 127)] * 155 / 100);
        if (this.y2AC < 8) 
            this.y2AC = 8;
        this.chromaDC = VP8Util.QuantizationParams.dcQLookup[VP8Util.QuantizationParams.clip(baseIndex + chromaDCIndexDelta, 127)];
        this.chromaAC = VP8Util.QuantizationParams.acQLookup[VP8Util.QuantizationParams.clip(baseIndex + chromaACIndexDelta, 127)];
    };
    constructor.QuantizationParams = stjs.extend(constructor.QuantizationParams, null, [], function(constructor, prototype) {
        prototype.yAC = 0;
        prototype.yDC = 0;
        prototype.y2DC = 0;
        prototype.y2AC = 0;
        prototype.chromaDC = 0;
        prototype.chromaAC = 0;
        constructor.dcQLookup = new Int32Array([4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 93, 95, 96, 98, 100, 101, 102, 104, 106, 108, 110, 112, 114, 116, 118, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157]);
        constructor.acQLookup = new Int32Array([4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152, 155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284]);
        constructor.clip = function(val, max) {
            if (val > max) 
                return max;
            if (val < 0) 
                return 0;
            return val;
        };
        constructor.clip255 = function(val) {
            if (val > 255) 
                return 255;
            if (val < 0) 
                return 0;
            return val;
        };
    }, {dcQLookup: "Int32Array", acQLookup: "Int32Array"}, {});
    constructor.PLANE = stjs.enumeration("U", "V", "Y1", "Y2");
    constructor.vp8DefaultCoefProbs = [[[new Int32Array([128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]), new Int32Array([128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]), new Int32Array([128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128])], [new Int32Array([253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128]), new Int32Array([189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128]), new Int32Array([106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128])], [new Int32Array([1, 98, 248, 255, 236, 226, 255, 255, 128, 128, 128]), new Int32Array([181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128]), new Int32Array([78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128])], [new Int32Array([1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128]), new Int32Array([184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128]), new Int32Array([77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128])], [new Int32Array([1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128]), new Int32Array([170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128]), new Int32Array([37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128])], [new Int32Array([1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128]), new Int32Array([207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128]), new Int32Array([102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128])], [new Int32Array([1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128]), new Int32Array([177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128]), new Int32Array([80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128])], [new Int32Array([1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]), new Int32Array([246, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]), new Int32Array([255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128])]], [[new Int32Array([198, 35, 237, 223, 193, 187, 162, 160, 145, 155, 62]), new Int32Array([131, 45, 198, 221, 172, 176, 220, 157, 252, 221, 1]), new Int32Array([68, 47, 146, 208, 149, 167, 221, 162, 255, 223, 128])], [new Int32Array([1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128]), new Int32Array([184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128]), new Int32Array([81, 99, 181, 242, 176, 190, 249, 202, 255, 255, 128])], [new Int32Array([1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128]), new Int32Array([99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128]), new Int32Array([23, 91, 163, 242, 170, 187, 247, 210, 255, 255, 128])], [new Int32Array([1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128]), new Int32Array([109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128]), new Int32Array([44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128])], [new Int32Array([1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128]), new Int32Array([94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128]), new Int32Array([22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128])], [new Int32Array([1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128]), new Int32Array([124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128]), new Int32Array([35, 77, 181, 251, 193, 211, 255, 205, 128, 128, 128])], [new Int32Array([1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128]), new Int32Array([121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128]), new Int32Array([45, 99, 188, 251, 195, 217, 255, 224, 128, 128, 128])], [new Int32Array([1, 1, 251, 255, 213, 255, 128, 128, 128, 128, 128]), new Int32Array([203, 1, 248, 255, 255, 128, 128, 128, 128, 128, 128]), new Int32Array([137, 1, 177, 255, 224, 255, 128, 128, 128, 128, 128])]], [[new Int32Array([253, 9, 248, 251, 207, 208, 255, 192, 128, 128, 128]), new Int32Array([175, 13, 224, 243, 193, 185, 249, 198, 255, 255, 128]), new Int32Array([73, 17, 171, 221, 161, 179, 236, 167, 255, 234, 128])], [new Int32Array([1, 95, 247, 253, 212, 183, 255, 255, 128, 128, 128]), new Int32Array([239, 90, 244, 250, 211, 209, 255, 255, 128, 128, 128]), new Int32Array([155, 77, 195, 248, 188, 195, 255, 255, 128, 128, 128])], [new Int32Array([1, 24, 239, 251, 218, 219, 255, 205, 128, 128, 128]), new Int32Array([201, 51, 219, 255, 196, 186, 128, 128, 128, 128, 128]), new Int32Array([69, 46, 190, 239, 201, 218, 255, 228, 128, 128, 128])], [new Int32Array([1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128]), new Int32Array([223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128]), new Int32Array([141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128])], [new Int32Array([1, 16, 248, 255, 255, 128, 128, 128, 128, 128, 128]), new Int32Array([190, 36, 230, 255, 236, 255, 128, 128, 128, 128, 128]), new Int32Array([149, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128])], [new Int32Array([1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128]), new Int32Array([247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128]), new Int32Array([240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128])], [new Int32Array([1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128]), new Int32Array([213, 62, 250, 255, 255, 128, 128, 128, 128, 128, 128]), new Int32Array([55, 93, 255, 128, 128, 128, 128, 128, 128, 128, 128])], [new Int32Array([128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]), new Int32Array([128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]), new Int32Array([128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128])]], [[new Int32Array([202, 24, 213, 235, 186, 191, 220, 160, 240, 175, 255]), new Int32Array([126, 38, 182, 232, 169, 184, 228, 174, 255, 187, 128]), new Int32Array([61, 46, 138, 219, 151, 178, 240, 170, 255, 216, 128])], [new Int32Array([1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128]), new Int32Array([166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128]), new Int32Array([39, 77, 162, 232, 172, 180, 245, 178, 255, 255, 128])], [new Int32Array([1, 52, 220, 246, 198, 199, 249, 220, 255, 255, 128]), new Int32Array([124, 74, 191, 243, 183, 193, 250, 221, 255, 255, 128]), new Int32Array([24, 71, 130, 219, 154, 170, 243, 182, 255, 255, 128])], [new Int32Array([1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128]), new Int32Array([149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128]), new Int32Array([28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128])], [new Int32Array([1, 81, 230, 252, 204, 203, 255, 192, 128, 128, 128]), new Int32Array([123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128]), new Int32Array([20, 95, 153, 243, 164, 173, 255, 203, 128, 128, 128])], [new Int32Array([1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128]), new Int32Array([168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128]), new Int32Array([47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128])], [new Int32Array([1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128]), new Int32Array([141, 84, 213, 252, 201, 202, 255, 219, 128, 128, 128]), new Int32Array([42, 80, 160, 240, 162, 185, 255, 205, 128, 128, 128])], [new Int32Array([1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]), new Int32Array([244, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]), new Int32Array([238, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128])]]];
    constructor.vp8CoefUpdateProbs = [[[new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255]), new Int32Array([250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255]), new Int32Array([254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])]], [[new Int32Array([217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255]), new Int32Array([234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255])], [new Int32Array([255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])]], [[new Int32Array([186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255])], [new Int32Array([255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])]], [[new Int32Array([248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])]]];
    constructor.predictHU = function(left) {
        var p = new Int32Array(16);
        p[0 * 4 + 0] = VP8Util.avg2(left[0], left[1]);
        p[0 * 4 + 1] = VP8Util.avg3(left[0], left[1], left[2]);
        p[0 * 4 + 2] = p[1 * 4 + 0] = VP8Util.avg2(left[1], left[2]);
        p[0 * 4 + 3] = p[1 * 4 + 1] = VP8Util.avg3(left[1], left[2], left[3]);
        p[1 * 4 + 2] = p[2 * 4 + 0] = VP8Util.avg2(left[2], left[3]);
        p[1 * 4 + 3] = p[2 * 4 + 1] = VP8Util.avg3(left[2], left[3], left[3]);
        p[2 * 4 + 2] = p[2 * 4 + 3] = p[3 * 4 + 0] = p[3 * 4 + 1] = p[3 * 4 + 2] = p[3 * 4 + 3] = left[3];
        return p;
    };
    constructor.predictHD = function(above, left, aboveLeft) {
        var p = new Int32Array(16);
        var edge = new Int32Array(9);
        edge[0] = left[3];
        edge[1] = left[2];
        edge[2] = left[1];
        edge[3] = left[0];
        edge[4] = aboveLeft;
        edge[5] = above[0];
        edge[6] = above[1];
        edge[7] = above[2];
        edge[8] = above[3];
        p[3 * 4 + 0] = VP8Util.avg2(edge[0], edge[1]);
        p[3 * 4 + 1] = VP8Util.avg3(edge[0], edge[1], edge[2]);
        p[2 * 4 + 0] = p[3 * 4 + 2] = VP8Util.avg2(edge[1], edge[2]);
        p[2 * 4 + 1] = p[3 * 4 + 3] = VP8Util.avg3(edge[1], edge[2], edge[3]);
        p[2 * 4 + 2] = p[1 * 4 + 0] = VP8Util.avg2(edge[2], edge[3]);
        p[2 * 4 + 3] = p[1 * 4 + 1] = VP8Util.avg3(edge[2], edge[3], edge[4]);
        p[1 * 4 + 2] = p[0 * 4 + 0] = VP8Util.avg2(edge[3], edge[4]);
        p[1 * 4 + 3] = p[0 * 4 + 1] = VP8Util.avg3(edge[3], edge[4], edge[5]);
        p[0 * 4 + 2] = VP8Util.avg3(edge[4], edge[5], edge[6]);
        p[0 * 4 + 3] = VP8Util.avg3(edge[5], edge[6], edge[7]);
        return p;
    };
    constructor.predictVL = function(above, aboveRight) {
        var p = new Int32Array(16);
        p[0 * 4 + 0] = VP8Util.avg2(above[0], above[1]);
        p[1 * 4 + 0] = VP8Util.avg3(above[0], above[1], above[2]);
        p[2 * 4 + 0] = p[0 * 4 + 1] = VP8Util.avg2(above[1], above[2]);
        p[1 * 4 + 1] = p[3 * 4 + 0] = VP8Util.avg3(above[1], above[2], above[3]);
        p[2 * 4 + 1] = p[0 * 4 + 2] = VP8Util.avg2(above[2], above[3]);
        p[3 * 4 + 1] = p[1 * 4 + 2] = VP8Util.avg3(above[2], above[3], aboveRight[0]);
        p[2 * 4 + 2] = p[0 * 4 + 3] = VP8Util.avg2(above[3], aboveRight[0]);
        p[3 * 4 + 2] = p[1 * 4 + 3] = VP8Util.avg3(above[3], aboveRight[0], aboveRight[1]);
        p[2 * 4 + 3] = VP8Util.avg3(aboveRight[0], aboveRight[1], aboveRight[2]);
        p[3 * 4 + 3] = VP8Util.avg3(aboveRight[1], aboveRight[2], aboveRight[3]);
        return p;
    };
    constructor.predictVR = function(above, left, aboveLeft) {
        var p = new Int32Array(16);
        var edge = new Int32Array(9);
        edge[0] = left[3];
        edge[1] = left[2];
        edge[2] = left[1];
        edge[3] = left[0];
        edge[4] = aboveLeft;
        edge[5] = above[0];
        edge[6] = above[1];
        edge[7] = above[2];
        edge[8] = above[3];
        p[3 * 4 + 0] = VP8Util.avg3(edge[1], edge[2], edge[3]);
        p[2 * 4 + 0] = VP8Util.avg3(edge[2], edge[3], edge[4]);
        p[3 * 4 + 1] = p[1 * 4 + 0] = VP8Util.avg3(edge[3], edge[4], edge[5]);
        p[2 * 4 + 1] = p[0 * 4 + 0] = VP8Util.avg2(edge[4], edge[5]);
        p[3 * 4 + 2] = p[1 * 4 + 1] = VP8Util.avg3(edge[4], edge[5], edge[6]);
        p[2 * 4 + 2] = p[0 * 4 + 1] = VP8Util.avg2(edge[5], edge[6]);
        p[3 * 4 + 3] = p[1 * 4 + 2] = VP8Util.avg3(edge[5], edge[6], edge[7]);
        p[2 * 4 + 3] = p[0 * 4 + 2] = VP8Util.avg2(edge[6], edge[7]);
        p[1 * 4 + 3] = VP8Util.avg3(edge[6], edge[7], edge[8]);
        p[0 * 4 + 3] = VP8Util.avg2(edge[7], edge[8]);
        return p;
    };
    /**
     *  <pre>
     *   E4|E5|E6|E7|E8|
     *   __|__|__|__|__|
     *   E3|
     *   __|
     *   E2|
     *   __|
     *   E1|
     *   __|
     *   E0|
     *   __|
     *  </pre>
     *  
     *  @param above
     *  @param left
     *  @param aboveLeft
     *  @return
     */
    constructor.predictRD = function(above, left, aboveLeft) {
        var p = new Int32Array(16);
        var edge = new Int32Array(9);
        edge[0] = left[3];
        edge[1] = left[2];
        edge[2] = left[1];
        edge[3] = left[0];
        edge[4] = aboveLeft;
        edge[5] = above[0];
        edge[6] = above[1];
        edge[7] = above[2];
        edge[8] = above[3];
        p[3 * 4 + 0] = VP8Util.avg3(edge[0], edge[1], edge[2]);
        p[3 * 4 + 1] = p[2 * 4 + 0] = VP8Util.avg3(edge[1], edge[2], edge[3]);
        p[3 * 4 + 2] = p[2 * 4 + 1] = p[1 * 4 + 0] = VP8Util.avg3(edge[2], edge[3], edge[4]);
        p[3 * 4 + 3] = p[2 * 4 + 2] = p[1 * 4 + 1] = p[0 * 4 + 0] = VP8Util.avg3(edge[3], edge[4], edge[5]);
        p[2 * 4 + 3] = p[1 * 4 + 2] = p[0 * 4 + 1] = VP8Util.avg3(edge[4], edge[5], edge[6]);
        p[1 * 4 + 3] = p[0 * 4 + 2] = VP8Util.avg3(edge[5], edge[6], edge[7]);
        p[0 * 4 + 3] = VP8Util.avg3(edge[6], edge[7], edge[8]);
        return p;
    };
    constructor.predictLD = function(above, aboveRight) {
        var p = new Int32Array(16);
        p[0 * 4 + 0] = VP8Util.avg3(above[0], above[1], above[2]);
        p[0 * 4 + 1] = p[1 * 4 + 0] = VP8Util.avg3(above[1], above[2], above[3]);
        p[0 * 4 + 2] = p[1 * 4 + 1] = p[2 * 4 + 0] = VP8Util.avg3(above[2], above[3], aboveRight[0]);
        p[0 * 4 + 3] = p[1 * 4 + 2] = p[2 * 4 + 1] = p[3 * 4 + 0] = VP8Util.avg3(above[3], aboveRight[0], aboveRight[1]);
        p[1 * 4 + 3] = p[2 * 4 + 2] = p[3 * 4 + 1] = VP8Util.avg3(aboveRight[0], aboveRight[1], aboveRight[2]);
        p[2 * 4 + 3] = p[3 * 4 + 2] = VP8Util.avg3(aboveRight[1], aboveRight[2], aboveRight[3]);
        p[3 * 4 + 3] = VP8Util.avg3(aboveRight[2], aboveRight[3], aboveRight[3]);
        return p;
    };
    constructor.predictHE = function(left, aboveLeft) {
        var p = new Int32Array(16);
        var v = VP8Util.avg3(left[2], left[3], left[3]);
        p[3 * 4 + 0] = p[3 * 4 + 1] = p[3 * 4 + 2] = p[3 * 4 + 3] = VP8Util.avg3(left[2], left[3], left[3]);
        p[2 * 4 + 0] = p[2 * 4 + 1] = p[2 * 4 + 2] = p[2 * 4 + 3] = VP8Util.avg3(left[1], left[2], left[3]);
        p[1 * 4 + 0] = p[1 * 4 + 1] = p[1 * 4 + 2] = p[1 * 4 + 3] = VP8Util.avg3(left[0], left[1], left[2]);
        p[0 * 4 + 0] = p[0 * 4 + 1] = p[0 * 4 + 2] = p[0 * 4 + 3] = VP8Util.avg3(aboveLeft, left[0], left[1]);
        return p;
    };
    /**
     *  avg3(Pixel x, Pixel y, Pixel z) { avg2(Pixel x, Pixel y) { return (x + y + 1) >> 1;}
     *  
     *  @param above
     *  @param aboveLeft
     *  @param aboveRight
     *  @return
     */
    constructor.predictVE = function(above, aboveLeft, aboveRight) {
        var p = new Int32Array(16);
        p[0 * 4 + 0] = p[1 * 4 + 0] = p[2 * 4 + 0] = p[3 * 4 + 0] = VP8Util.avg3(aboveLeft, above[0], above[1]);
        p[0 * 4 + 1] = p[1 * 4 + 1] = p[2 * 4 + 1] = p[3 * 4 + 1] = VP8Util.avg3(above[0], above[1], above[2]);
        p[0 * 4 + 2] = p[1 * 4 + 2] = p[2 * 4 + 2] = p[3 * 4 + 2] = VP8Util.avg3(above[1], above[2], above[3]);
        p[0 * 4 + 3] = p[1 * 4 + 3] = p[2 * 4 + 3] = p[3 * 4 + 3] = VP8Util.avg3(above[2], above[3], aboveRight[0]);
        return p;
    };
    constructor.avg2 = function(x, y) {
        return (x + y + 1) >> 1;
    };
    constructor.avg3 = function(x, y, z) {
        return (x + y + y + z + 2) >> 2;
    };
    constructor.predictTM = function(above, left, aboveLeft) {
        var p = new Int32Array(16);
        for (var aRow = 0; aRow < 4; aRow++) 
            for (var aCol = 0; aCol < 4; aCol++) 
                p[aRow * 4 + aCol] = VP8Util.QuantizationParams.clip255(left[aRow] + above[aCol] - aboveLeft);
        return p;
    };
    constructor.predictDC = function(above, left) {
        var p = new Int32Array(16);
        var v = 4;
        var i = 0;
        do {
            v += above[i] + left[i];
        } while (++i < 4);
        v >>= 3;
        for (var aRow = 0; aRow < 4; aRow++) 
            for (var aCol = 0; aCol < 4; aCol++) 
                p[aRow * 4 + aCol] = v;
        return p;
    };
    constructor.planeToType = function(plane, withY2) {
        switch (plane) {
            case VP8Util.PLANE.Y2:
                return 1;
            case VP8Util.PLANE.Y1:
                if (withY2) 
                    return 0;
                 else 
                    return 3;
            case VP8Util.PLANE.U:
                return 2;
            case VP8Util.PLANE.V:
                return 2;
        }
        return -1;
    };
}, {vp8KeyFrameUVModeProb: "Int32Array", vp8UVModeTree: "Int32Array", keyFrameYModeProb: "Int32Array", keyFrameYModeTree: "Int32Array", PRED_BLOCK_127: "Int32Array", PRED_BLOCK_129: "Int32Array", vp8DefaultCoefProbs: "Array", vp8CoefUpdateProbs: "Array"}, {});
var NotImplementedException = function(string) {
    RuntimeException.call(this, string);
};
NotImplementedException = stjs.extend(NotImplementedException, RuntimeException, [], null, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @see http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/de//pubs/archive/37073.pdf
 *  @see http://jpegclub.org/jidctred/
 *  @see http://www3.matapp.unimib.it/corsi-2007-2008/matematica/istituzioni-di-analisi-numerica/jpeg/papers/11-multiplications.pdf
 *  @see http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/de//pubs/archive/37073.pdf
 *  <pre>
 *  </pre>
 *  
 *  @author The JCodec project
 */
var VP8DCT = function() {};
VP8DCT = stjs.extend(VP8DCT, null, [], function(constructor, prototype) {
    constructor.cospi8sqrt2minus1 = 20091;
    constructor.sinpi8sqrt2 = 35468;
    constructor.decodeDCT = function(input) {
        var i;
        var a1, b1, c1, d1;
        var offset = 0;
        var output = new Int32Array(16);
        var temp1, temp2;
        for (i = 0; i < 4; i++) {
            a1 = input[offset + 0] + input[offset + 8];
            b1 = input[offset + 0] - input[offset + 8];
            temp1 = (input[offset + 4] * VP8DCT.sinpi8sqrt2) >> 16;
            temp2 = input[offset + 12] + ((input[offset + 12] * VP8DCT.cospi8sqrt2minus1) >> 16);
            c1 = temp1 - temp2;
            temp1 = input[offset + 4] + ((input[offset + 4] * VP8DCT.cospi8sqrt2minus1) >> 16);
            temp2 = (input[offset + 12] * VP8DCT.sinpi8sqrt2) >> 16;
            d1 = temp1 + temp2;
            output[offset + (0 * 4)] = a1 + d1;
            output[offset + (3 * 4)] = a1 - d1;
            output[offset + (1 * 4)] = b1 + c1;
            output[offset + (2 * 4)] = b1 - c1;
            offset++;
        }
        offset = 0;
        for (i = 0; i < 4; i++) {
            a1 = output[(offset * 4) + 0] + output[(offset * 4) + 2];
            b1 = output[(offset * 4) + 0] - output[(offset * 4) + 2];
            temp1 = (output[(offset * 4) + 1] * VP8DCT.sinpi8sqrt2) >> 16;
            temp2 = output[(offset * 4) + 3] + ((output[(offset * 4) + 3] * VP8DCT.cospi8sqrt2minus1) >> 16);
            c1 = temp1 - temp2;
            temp1 = output[(offset * 4) + 1] + ((output[(offset * 4) + 1] * VP8DCT.cospi8sqrt2minus1) >> 16);
            temp2 = (output[(offset * 4) + 3] * VP8DCT.sinpi8sqrt2) >> 16;
            d1 = temp1 + temp2;
            output[(offset * 4) + 0] = (a1 + d1 + 4) >> 3;
            output[(offset * 4) + 3] = (a1 - d1 + 4) >> 3;
            output[(offset * 4) + 1] = (b1 + c1 + 4) >> 3;
            output[(offset * 4) + 2] = (b1 - c1 + 4) >> 3;
            offset++;
        }
        return output;
    };
    constructor.encodeDCT = function(input) {
        var i;
        var a1, b1, c1, d1;
        var ip = 0;
        var output = new Int32Array(input.length);
        var op = 0;
        for (i = 0; i < 4; i++) {
            a1 = ((input[ip + 0] + input[ip + 3]) << 3);
            b1 = ((input[ip + 1] + input[ip + 2]) << 3);
            c1 = ((input[ip + 1] - input[ip + 2]) << 3);
            d1 = ((input[ip + 0] - input[ip + 3]) << 3);
            output[op + 0] = a1 + b1;
            output[op + 2] = a1 - b1;
            output[op + 1] = (c1 * 2217 + d1 * 5352 + 14500) >> 12;
            output[op + 3] = (d1 * 2217 - c1 * 5352 + 7500) >> 12;
            ip += 4;
            op += 4;
        }
        ip = 0;
        op = 0;
        for (i = 0; i < 4; i++) {
            a1 = output[ip + 0] + output[ip + 12];
            b1 = output[ip + 4] + output[ip + 8];
            c1 = output[ip + 4] - output[ip + 8];
            d1 = output[ip + 0] - output[ip + 12];
            output[op + 0] = (a1 + b1 + 7) >> 4;
            output[op + 8] = (a1 - b1 + 7) >> 4;
            output[op + 4] = ((c1 * 2217 + d1 * 5352 + 12000) >> 16) + (d1 != 0 ? 1 : 0);
            output[op + 12] = (d1 * 2217 - c1 * 5352 + 51000) >> 16;
            ip++;
            op++;
        }
        return output;
    };
    constructor.decodeWHT = function(input) {
        var i;
        var a1, b1, c1, d1;
        var a2, b2, c2, d2;
        var output = new Int32Array(16);
        var diff = Array.apply(null, Array(4)).map(function() {
            return new Int32Array(4);
        });
        var offset = 0;
        for (i = 0; i < 4; i++) {
            a1 = input[offset + 0] + input[offset + 12];
            b1 = input[offset + 4] + input[offset + 8];
            c1 = input[offset + 4] - input[offset + 8];
            d1 = input[offset + 0] - input[offset + 12];
            output[offset + 0] = a1 + b1;
            output[offset + 4] = c1 + d1;
            output[offset + 8] = a1 - b1;
            output[offset + 12] = d1 - c1;
            offset++;
        }
        offset = 0;
        for (i = 0; i < 4; i++) {
            a1 = output[offset + 0] + output[offset + 3];
            b1 = output[offset + 1] + output[offset + 2];
            c1 = output[offset + 1] - output[offset + 2];
            d1 = output[offset + 0] - output[offset + 3];
            a2 = a1 + b1;
            b2 = c1 + d1;
            c2 = a1 - b1;
            d2 = d1 - c1;
            output[offset + 0] = (a2 + 3) >> 3;
            output[offset + 1] = (b2 + 3) >> 3;
            output[offset + 2] = (c2 + 3) >> 3;
            output[offset + 3] = (d2 + 3) >> 3;
            diff[0][i] = (a2 + 3) >> 3;
            diff[1][i] = (b2 + 3) >> 3;
            diff[2][i] = (c2 + 3) >> 3;
            diff[3][i] = (d2 + 3) >> 3;
            offset += 4;
        }
        return output;
    };
    constructor.encodeWHT = function(input) {
        var i;
        var a1, b1, c1, d1;
        var a2, b2, c2, d2;
        var inputOffset = 0;
        var outputOffset = 0;
        var output = new Int32Array(input.length);
        for (i = 0; i < 4; i++) {
            a1 = ((input[inputOffset + 0] + input[inputOffset + 2])) << 2;
            d1 = ((input[inputOffset + 1] + input[inputOffset + 3])) << 2;
            c1 = ((input[inputOffset + 1] - input[inputOffset + 3])) << 2;
            b1 = ((input[inputOffset + 0] - input[inputOffset + 2])) << 2;
            output[outputOffset + 0] = a1 + d1 + (a1 != 0 ? 1 : 0);
            output[outputOffset + 1] = b1 + c1;
            output[outputOffset + 2] = b1 - c1;
            output[outputOffset + 3] = a1 - d1;
            inputOffset += 4;
            outputOffset += 4;
        }
        inputOffset = 0;
        outputOffset = 0;
        for (i = 0; i < 4; i++) {
            a1 = output[inputOffset + 0] + output[inputOffset + 8];
            d1 = output[inputOffset + 4] + output[inputOffset + 12];
            c1 = output[inputOffset + 4] - output[inputOffset + 12];
            b1 = output[inputOffset + 0] - output[inputOffset + 8];
            a2 = a1 + d1;
            b2 = b1 + c1;
            c2 = b1 - c1;
            d2 = a1 - d1;
            a2 += (a2 < 0 ? 1 : 0);
            b2 += (b2 < 0 ? 1 : 0);
            c2 += (c2 < 0 ? 1 : 0);
            d2 += (d2 < 0 ? 1 : 0);
            output[outputOffset + 0] = (a2 + 3) >> 3;
            output[outputOffset + 4] = (b2 + 3) >> 3;
            output[outputOffset + 8] = (c2 + 3) >> 3;
            output[outputOffset + 12] = (d2 + 3) >> 3;
            inputOffset++;
            outputOffset++;
        }
        return output;
    };
}, {}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  An enumeration that represents all possible sample frequencies AAC data can
 *  have.
 *  
 *  @author in-somnia
 */
var SampleFrequency = function(index, freqency, prediction, maxTNS_SFB) {
    this.index = index;
    this.frequency = freqency;
    this.prediction = prediction;
    this.maxTNS_SFB = maxTNS_SFB;
};
SampleFrequency = stjs.extend(SampleFrequency, null, [], function(constructor, prototype) {
    constructor.SAMPLE_FREQUENCY_96000 = new SampleFrequency(0, 96000, new Int32Array([33, 512]), new Int32Array([31, 9]));
    constructor.SAMPLE_FREQUENCY_88200 = new SampleFrequency(1, 88200, new Int32Array([33, 512]), new Int32Array([31, 9]));
    constructor.SAMPLE_FREQUENCY_64000 = new SampleFrequency(2, 64000, new Int32Array([38, 664]), new Int32Array([34, 10]));
    constructor.SAMPLE_FREQUENCY_48000 = new SampleFrequency(3, 48000, new Int32Array([40, 672]), new Int32Array([40, 14]));
    constructor.SAMPLE_FREQUENCY_44100 = new SampleFrequency(4, 44100, new Int32Array([40, 672]), new Int32Array([42, 14]));
    constructor.SAMPLE_FREQUENCY_32000 = new SampleFrequency(5, 32000, new Int32Array([40, 672]), new Int32Array([51, 14]));
    constructor.SAMPLE_FREQUENCY_24000 = new SampleFrequency(6, 24000, new Int32Array([41, 652]), new Int32Array([46, 14]));
    constructor.SAMPLE_FREQUENCY_22050 = new SampleFrequency(7, 22050, new Int32Array([41, 652]), new Int32Array([46, 14]));
    constructor.SAMPLE_FREQUENCY_16000 = new SampleFrequency(8, 16000, new Int32Array([37, 664]), new Int32Array([42, 14]));
    constructor.SAMPLE_FREQUENCY_12000 = new SampleFrequency(9, 12000, new Int32Array([37, 664]), new Int32Array([42, 14]));
    constructor.SAMPLE_FREQUENCY_11025 = new SampleFrequency(10, 11025, new Int32Array([37, 664]), new Int32Array([42, 14]));
    constructor.SAMPLE_FREQUENCY_8000 = new SampleFrequency(11, 8000, new Int32Array([34, 664]), new Int32Array([39, 14]));
    constructor.SAMPLE_FREQUENCY_NONE = new SampleFrequency(-1, 0, new Int32Array([0, 0]), new Int32Array([0, 0]));
    constructor._values = [SampleFrequency.SAMPLE_FREQUENCY_96000, SampleFrequency.SAMPLE_FREQUENCY_88200, SampleFrequency.SAMPLE_FREQUENCY_64000, SampleFrequency.SAMPLE_FREQUENCY_48000, SampleFrequency.SAMPLE_FREQUENCY_44100, SampleFrequency.SAMPLE_FREQUENCY_32000, SampleFrequency.SAMPLE_FREQUENCY_24000, SampleFrequency.SAMPLE_FREQUENCY_22050, SampleFrequency.SAMPLE_FREQUENCY_16000, SampleFrequency.SAMPLE_FREQUENCY_12000, SampleFrequency.SAMPLE_FREQUENCY_11025, SampleFrequency.SAMPLE_FREQUENCY_8000, SampleFrequency.SAMPLE_FREQUENCY_NONE];
    constructor.values = function() {
        return SampleFrequency._values;
    };
    /**
     *  Returns a sample frequency instance for the given index. If the index is
     *  not between 0 and 11 inclusive, SAMPLE_FREQUENCY_NONE is returned.
     *  
     *  @return a sample frequency with the given index
     */
    constructor.forInt = function(i) {
        var freq;
        if (i >= 0 && i < 12) 
            freq = SampleFrequency.values()[i];
         else 
            freq = SampleFrequency.SAMPLE_FREQUENCY_NONE;
        return freq;
    };
    constructor.forFrequency = function(i) {
        var all = SampleFrequency.values();
        var freq = null;
        for (var j = 0; freq == null && j < 12; j++) {
            if (i == all[j].frequency) 
                freq = all[j];
        }
        if (freq == null) 
            freq = SampleFrequency.SAMPLE_FREQUENCY_NONE;
        return freq;
    };
    prototype.index = 0;
    prototype.frequency = 0;
    prototype.prediction = null;
    prototype.maxTNS_SFB = null;
    /**
     *  Returns this sample frequency's index between 0 (96000) and 11 (8000) or
     *  -1 if this is SAMPLE_FREQUENCY_NONE.
     *  
     *  @return the sample frequency's index
     */
    prototype.getIndex = function() {
        return this.index;
    };
    /**
     *  Returns the sample frequency as integer value. This may be a value
     *  between 96000 and 8000, or 0 if this is SAMPLE_FREQUENCY_NONE.
     *  
     *  @return the sample frequency
     */
    prototype.getFrequency = function() {
        return this.frequency;
    };
    /**
     *  Returns the highest scale factor band allowed for ICPrediction at this
     *  sample frequency. This method is mainly used internally.
     *  
     *  @return the highest prediction SFB
     */
    prototype.getMaximalPredictionSFB = function() {
        return this.prediction[0];
    };
    /**
     *  Returns the number of predictors allowed for ICPrediction at this sample
     *  frequency. This method is mainly used internally.
     *  
     *  @return the number of ICPredictors
     */
    prototype.getPredictorCount = function() {
        return this.prediction[1];
    };
    /**
     *  Returns the highest scale factor band allowed for TNS at this sample
     *  frequency. This method is mainly used internally.
     *  
     *  @return the highest SFB for TNS
     */
    prototype.getMaximalTNS_SFB = function(shortWindow) {
        return this.maxTNS_SFB[shortWindow ? 1 : 0];
    };
    /**
     *  Returns a string representation of this sample frequency. The method is
     *  identical to <code>getDescription()</code>.
     *  
     *  @return the sample frequency's description
     */
    prototype.toString = function() {
        return Integer.toString(this.frequency);
    };
}, {SAMPLE_FREQUENCY_96000: "SampleFrequency", SAMPLE_FREQUENCY_88200: "SampleFrequency", SAMPLE_FREQUENCY_64000: "SampleFrequency", SAMPLE_FREQUENCY_48000: "SampleFrequency", SAMPLE_FREQUENCY_44100: "SampleFrequency", SAMPLE_FREQUENCY_32000: "SampleFrequency", SAMPLE_FREQUENCY_24000: "SampleFrequency", SAMPLE_FREQUENCY_22050: "SampleFrequency", SAMPLE_FREQUENCY_16000: "SampleFrequency", SAMPLE_FREQUENCY_12000: "SampleFrequency", SAMPLE_FREQUENCY_11025: "SampleFrequency", SAMPLE_FREQUENCY_8000: "SampleFrequency", SAMPLE_FREQUENCY_NONE: "SampleFrequency", _values: "Array", prediction: "Int32Array", maxTNS_SFB: "Int32Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 * 
 *  @author in-somnia
 */
var HuffmanTables = function() {};
HuffmanTables = stjs.extend(HuffmanTables, null, [], function(constructor, prototype) {
    constructor.T_HUFFMAN_ENV_1_5DB = [new Int32Array([1, 2]), new Int32Array([-64, -65]), new Int32Array([3, 4]), new Int32Array([-63, -66]), new Int32Array([5, 6]), new Int32Array([-62, -67]), new Int32Array([7, 8]), new Int32Array([-61, -68]), new Int32Array([9, 10]), new Int32Array([-60, -69]), new Int32Array([11, 12]), new Int32Array([-59, -70]), new Int32Array([13, 14]), new Int32Array([-58, -71]), new Int32Array([15, 16]), new Int32Array([-57, -72]), new Int32Array([17, 18]), new Int32Array([-73, -56]), new Int32Array([19, 21]), new Int32Array([-74, 20]), new Int32Array([-55, -75]), new Int32Array([22, 26]), new Int32Array([23, 24]), new Int32Array([-54, -76]), new Int32Array([-77, 25]), new Int32Array([-53, -78]), new Int32Array([27, 34]), new Int32Array([28, 29]), new Int32Array([-52, -79]), new Int32Array([30, 31]), new Int32Array([-80, -51]), new Int32Array([32, 33]), new Int32Array([-83, -82]), new Int32Array([-81, -50]), new Int32Array([35, 57]), new Int32Array([36, 40]), new Int32Array([37, 38]), new Int32Array([-88, -84]), new Int32Array([-48, 39]), new Int32Array([-90, -85]), new Int32Array([41, 46]), new Int32Array([42, 43]), new Int32Array([-49, -87]), new Int32Array([44, 45]), new Int32Array([-89, -86]), new Int32Array([-124, -123]), new Int32Array([47, 50]), new Int32Array([48, 49]), new Int32Array([-122, -121]), new Int32Array([-120, -119]), new Int32Array([51, 54]), new Int32Array([52, 53]), new Int32Array([-118, -117]), new Int32Array([-116, -115]), new Int32Array([55, 56]), new Int32Array([-114, -113]), new Int32Array([-112, -111]), new Int32Array([58, 89]), new Int32Array([59, 74]), new Int32Array([60, 67]), new Int32Array([61, 64]), new Int32Array([62, 63]), new Int32Array([-110, -109]), new Int32Array([-108, -107]), new Int32Array([65, 66]), new Int32Array([-106, -105]), new Int32Array([-104, -103]), new Int32Array([68, 71]), new Int32Array([69, 70]), new Int32Array([-102, -101]), new Int32Array([-100, -99]), new Int32Array([72, 73]), new Int32Array([-98, -97]), new Int32Array([-96, -95]), new Int32Array([75, 82]), new Int32Array([76, 79]), new Int32Array([77, 78]), new Int32Array([-94, -93]), new Int32Array([-92, -91]), new Int32Array([80, 81]), new Int32Array([-47, -46]), new Int32Array([-45, -44]), new Int32Array([83, 86]), new Int32Array([84, 85]), new Int32Array([-43, -42]), new Int32Array([-41, -40]), new Int32Array([87, 88]), new Int32Array([-39, -38]), new Int32Array([-37, -36]), new Int32Array([90, 105]), new Int32Array([91, 98]), new Int32Array([92, 95]), new Int32Array([93, 94]), new Int32Array([-35, -34]), new Int32Array([-33, -32]), new Int32Array([96, 97]), new Int32Array([-31, -30]), new Int32Array([-29, -28]), new Int32Array([99, 102]), new Int32Array([100, 101]), new Int32Array([-27, -26]), new Int32Array([-25, -24]), new Int32Array([103, 104]), new Int32Array([-23, -22]), new Int32Array([-21, -20]), new Int32Array([106, 113]), new Int32Array([107, 110]), new Int32Array([108, 109]), new Int32Array([-19, -18]), new Int32Array([-17, -16]), new Int32Array([111, 112]), new Int32Array([-15, -14]), new Int32Array([-13, -12]), new Int32Array([114, 117]), new Int32Array([115, 116]), new Int32Array([-11, -10]), new Int32Array([-9, -8]), new Int32Array([118, 119]), new Int32Array([-7, -6]), new Int32Array([-5, -4])];
    constructor.F_HUFFMAN_ENV_1_5DB = [new Int32Array([1, 2]), new Int32Array([-64, -65]), new Int32Array([3, 4]), new Int32Array([-63, -66]), new Int32Array([5, 6]), new Int32Array([-67, -62]), new Int32Array([7, 8]), new Int32Array([-68, -61]), new Int32Array([9, 10]), new Int32Array([-69, -60]), new Int32Array([11, 13]), new Int32Array([-70, 12]), new Int32Array([-59, -71]), new Int32Array([14, 16]), new Int32Array([-58, 15]), new Int32Array([-72, -57]), new Int32Array([17, 19]), new Int32Array([-73, 18]), new Int32Array([-56, -74]), new Int32Array([20, 23]), new Int32Array([21, 22]), new Int32Array([-55, -75]), new Int32Array([-54, -53]), new Int32Array([24, 27]), new Int32Array([25, 26]), new Int32Array([-76, -52]), new Int32Array([-77, -51]), new Int32Array([28, 31]), new Int32Array([29, 30]), new Int32Array([-50, -78]), new Int32Array([-79, -49]), new Int32Array([32, 36]), new Int32Array([33, 34]), new Int32Array([-48, -47]), new Int32Array([-80, 35]), new Int32Array([-81, -82]), new Int32Array([37, 47]), new Int32Array([38, 41]), new Int32Array([39, 40]), new Int32Array([-83, -46]), new Int32Array([-45, -84]), new Int32Array([42, 44]), new Int32Array([-85, 43]), new Int32Array([-44, -43]), new Int32Array([45, 46]), new Int32Array([-88, -87]), new Int32Array([-86, -90]), new Int32Array([48, 66]), new Int32Array([49, 56]), new Int32Array([50, 53]), new Int32Array([51, 52]), new Int32Array([-92, -42]), new Int32Array([-41, -39]), new Int32Array([54, 55]), new Int32Array([-105, -89]), new Int32Array([-38, -37]), new Int32Array([57, 60]), new Int32Array([58, 59]), new Int32Array([-94, -91]), new Int32Array([-40, -36]), new Int32Array([61, 63]), new Int32Array([-20, 62]), new Int32Array([-115, -110]), new Int32Array([64, 65]), new Int32Array([-108, -107]), new Int32Array([-101, -97]), new Int32Array([67, 89]), new Int32Array([68, 75]), new Int32Array([69, 72]), new Int32Array([70, 71]), new Int32Array([-95, -93]), new Int32Array([-34, -27]), new Int32Array([73, 74]), new Int32Array([-22, -17]), new Int32Array([-16, -124]), new Int32Array([76, 82]), new Int32Array([77, 79]), new Int32Array([-123, 78]), new Int32Array([-122, -121]), new Int32Array([80, 81]), new Int32Array([-120, -119]), new Int32Array([-118, -117]), new Int32Array([83, 86]), new Int32Array([84, 85]), new Int32Array([-116, -114]), new Int32Array([-113, -112]), new Int32Array([87, 88]), new Int32Array([-111, -109]), new Int32Array([-106, -104]), new Int32Array([90, 105]), new Int32Array([91, 98]), new Int32Array([92, 95]), new Int32Array([93, 94]), new Int32Array([-103, -102]), new Int32Array([-100, -99]), new Int32Array([96, 97]), new Int32Array([-98, -96]), new Int32Array([-35, -33]), new Int32Array([99, 102]), new Int32Array([100, 101]), new Int32Array([-32, -31]), new Int32Array([-30, -29]), new Int32Array([103, 104]), new Int32Array([-28, -26]), new Int32Array([-25, -24]), new Int32Array([106, 113]), new Int32Array([107, 110]), new Int32Array([108, 109]), new Int32Array([-23, -21]), new Int32Array([-19, -18]), new Int32Array([111, 112]), new Int32Array([-15, -14]), new Int32Array([-13, -12]), new Int32Array([114, 117]), new Int32Array([115, 116]), new Int32Array([-11, -10]), new Int32Array([-9, -8]), new Int32Array([118, 119]), new Int32Array([-7, -6]), new Int32Array([-5, -4])];
    constructor.T_HUFFMAN_ENV_BAL_1_5DB = [new Int32Array([-64, 1]), new Int32Array([-63, 2]), new Int32Array([-65, 3]), new Int32Array([-62, 4]), new Int32Array([-66, 5]), new Int32Array([-61, 6]), new Int32Array([-67, 7]), new Int32Array([-60, 8]), new Int32Array([-68, 9]), new Int32Array([10, 11]), new Int32Array([-69, -59]), new Int32Array([12, 13]), new Int32Array([-70, -58]), new Int32Array([14, 28]), new Int32Array([15, 21]), new Int32Array([16, 18]), new Int32Array([-57, 17]), new Int32Array([-71, -56]), new Int32Array([19, 20]), new Int32Array([-88, -87]), new Int32Array([-86, -85]), new Int32Array([22, 25]), new Int32Array([23, 24]), new Int32Array([-84, -83]), new Int32Array([-82, -81]), new Int32Array([26, 27]), new Int32Array([-80, -79]), new Int32Array([-78, -77]), new Int32Array([29, 36]), new Int32Array([30, 33]), new Int32Array([31, 32]), new Int32Array([-76, -75]), new Int32Array([-74, -73]), new Int32Array([34, 35]), new Int32Array([-72, -55]), new Int32Array([-54, -53]), new Int32Array([37, 41]), new Int32Array([38, 39]), new Int32Array([-52, -51]), new Int32Array([-50, 40]), new Int32Array([-49, -48]), new Int32Array([42, 45]), new Int32Array([43, 44]), new Int32Array([-47, -46]), new Int32Array([-45, -44]), new Int32Array([46, 47]), new Int32Array([-43, -42]), new Int32Array([-41, -40])];
    constructor.F_HUFFMAN_ENV_BAL_1_5DB = [new Int32Array([-64, 1]), new Int32Array([-65, 2]), new Int32Array([-63, 3]), new Int32Array([-66, 4]), new Int32Array([-62, 5]), new Int32Array([-61, 6]), new Int32Array([-67, 7]), new Int32Array([-68, 8]), new Int32Array([-60, 9]), new Int32Array([10, 11]), new Int32Array([-69, -59]), new Int32Array([-70, 12]), new Int32Array([-58, 13]), new Int32Array([14, 17]), new Int32Array([-71, 15]), new Int32Array([-57, 16]), new Int32Array([-56, -73]), new Int32Array([18, 32]), new Int32Array([19, 25]), new Int32Array([20, 22]), new Int32Array([-72, 21]), new Int32Array([-88, -87]), new Int32Array([23, 24]), new Int32Array([-86, -85]), new Int32Array([-84, -83]), new Int32Array([26, 29]), new Int32Array([27, 28]), new Int32Array([-82, -81]), new Int32Array([-80, -79]), new Int32Array([30, 31]), new Int32Array([-78, -77]), new Int32Array([-76, -75]), new Int32Array([33, 40]), new Int32Array([34, 37]), new Int32Array([35, 36]), new Int32Array([-74, -55]), new Int32Array([-54, -53]), new Int32Array([38, 39]), new Int32Array([-52, -51]), new Int32Array([-50, -49]), new Int32Array([41, 44]), new Int32Array([42, 43]), new Int32Array([-48, -47]), new Int32Array([-46, -45]), new Int32Array([45, 46]), new Int32Array([-44, -43]), new Int32Array([-42, 47]), new Int32Array([-41, -40])];
    constructor.T_HUFFMAN_ENV_3_0DB = [new Int32Array([-64, 1]), new Int32Array([-65, 2]), new Int32Array([-63, 3]), new Int32Array([-66, 4]), new Int32Array([-62, 5]), new Int32Array([-67, 6]), new Int32Array([-61, 7]), new Int32Array([-68, 8]), new Int32Array([-60, 9]), new Int32Array([10, 11]), new Int32Array([-69, -59]), new Int32Array([12, 14]), new Int32Array([-70, 13]), new Int32Array([-71, -58]), new Int32Array([15, 18]), new Int32Array([16, 17]), new Int32Array([-72, -57]), new Int32Array([-73, -74]), new Int32Array([19, 22]), new Int32Array([-56, 20]), new Int32Array([-55, 21]), new Int32Array([-54, -77]), new Int32Array([23, 31]), new Int32Array([24, 25]), new Int32Array([-75, -76]), new Int32Array([26, 27]), new Int32Array([-78, -53]), new Int32Array([28, 29]), new Int32Array([-52, -95]), new Int32Array([-94, 30]), new Int32Array([-93, -92]), new Int32Array([32, 47]), new Int32Array([33, 40]), new Int32Array([34, 37]), new Int32Array([35, 36]), new Int32Array([-91, -90]), new Int32Array([-89, -88]), new Int32Array([38, 39]), new Int32Array([-87, -86]), new Int32Array([-85, -84]), new Int32Array([41, 44]), new Int32Array([42, 43]), new Int32Array([-83, -82]), new Int32Array([-81, -80]), new Int32Array([45, 46]), new Int32Array([-79, -51]), new Int32Array([-50, -49]), new Int32Array([48, 55]), new Int32Array([49, 52]), new Int32Array([50, 51]), new Int32Array([-48, -47]), new Int32Array([-46, -45]), new Int32Array([53, 54]), new Int32Array([-44, -43]), new Int32Array([-42, -41]), new Int32Array([56, 59]), new Int32Array([57, 58]), new Int32Array([-40, -39]), new Int32Array([-38, -37]), new Int32Array([60, 61]), new Int32Array([-36, -35]), new Int32Array([-34, -33])];
    constructor.F_HUFFMAN_ENV_3_0DB = [new Int32Array([-64, 1]), new Int32Array([-65, 2]), new Int32Array([-63, 3]), new Int32Array([-66, 4]), new Int32Array([-62, 5]), new Int32Array([-67, 6]), new Int32Array([7, 8]), new Int32Array([-61, -68]), new Int32Array([9, 10]), new Int32Array([-60, -69]), new Int32Array([11, 12]), new Int32Array([-59, -70]), new Int32Array([13, 14]), new Int32Array([-58, -71]), new Int32Array([15, 16]), new Int32Array([-57, -72]), new Int32Array([17, 19]), new Int32Array([-56, 18]), new Int32Array([-55, -73]), new Int32Array([20, 24]), new Int32Array([21, 22]), new Int32Array([-74, -54]), new Int32Array([-53, 23]), new Int32Array([-75, -76]), new Int32Array([25, 30]), new Int32Array([26, 27]), new Int32Array([-52, -51]), new Int32Array([28, 29]), new Int32Array([-77, -79]), new Int32Array([-50, -49]), new Int32Array([31, 39]), new Int32Array([32, 35]), new Int32Array([33, 34]), new Int32Array([-78, -46]), new Int32Array([-82, -88]), new Int32Array([36, 37]), new Int32Array([-83, -48]), new Int32Array([-47, 38]), new Int32Array([-86, -85]), new Int32Array([40, 47]), new Int32Array([41, 44]), new Int32Array([42, 43]), new Int32Array([-80, -44]), new Int32Array([-43, -42]), new Int32Array([45, 46]), new Int32Array([-39, -87]), new Int32Array([-84, -40]), new Int32Array([48, 55]), new Int32Array([49, 52]), new Int32Array([50, 51]), new Int32Array([-95, -94]), new Int32Array([-93, -92]), new Int32Array([53, 54]), new Int32Array([-91, -90]), new Int32Array([-89, -81]), new Int32Array([56, 59]), new Int32Array([57, 58]), new Int32Array([-45, -41]), new Int32Array([-38, -37]), new Int32Array([60, 61]), new Int32Array([-36, -35]), new Int32Array([-34, -33])];
    constructor.T_HUFFMAN_ENV_BAL_3_0DB = [new Int32Array([-64, 1]), new Int32Array([-63, 2]), new Int32Array([-65, 3]), new Int32Array([-66, 4]), new Int32Array([-62, 5]), new Int32Array([-61, 6]), new Int32Array([-67, 7]), new Int32Array([-68, 8]), new Int32Array([-60, 9]), new Int32Array([10, 16]), new Int32Array([11, 13]), new Int32Array([-69, 12]), new Int32Array([-76, -75]), new Int32Array([14, 15]), new Int32Array([-74, -73]), new Int32Array([-72, -71]), new Int32Array([17, 20]), new Int32Array([18, 19]), new Int32Array([-70, -59]), new Int32Array([-58, -57]), new Int32Array([21, 22]), new Int32Array([-56, -55]), new Int32Array([-54, 23]), new Int32Array([-53, -52])];
    constructor.F_HUFFMAN_ENV_BAL_3_0DB = [new Int32Array([-64, 1]), new Int32Array([-65, 2]), new Int32Array([-63, 3]), new Int32Array([-66, 4]), new Int32Array([-62, 5]), new Int32Array([-61, 6]), new Int32Array([-67, 7]), new Int32Array([-68, 8]), new Int32Array([-60, 9]), new Int32Array([10, 13]), new Int32Array([-69, 11]), new Int32Array([-59, 12]), new Int32Array([-58, -76]), new Int32Array([14, 17]), new Int32Array([15, 16]), new Int32Array([-75, -74]), new Int32Array([-73, -72]), new Int32Array([18, 21]), new Int32Array([19, 20]), new Int32Array([-71, -70]), new Int32Array([-57, -56]), new Int32Array([22, 23]), new Int32Array([-55, -54]), new Int32Array([-53, -52])];
    constructor.T_HUFFMAN_NOISE_3_0DB = [new Int32Array([-64, 1]), new Int32Array([-63, 2]), new Int32Array([-65, 3]), new Int32Array([-66, 4]), new Int32Array([-62, 5]), new Int32Array([-67, 6]), new Int32Array([7, 8]), new Int32Array([-61, -68]), new Int32Array([9, 30]), new Int32Array([10, 15]), new Int32Array([-60, 11]), new Int32Array([-69, 12]), new Int32Array([13, 14]), new Int32Array([-59, -53]), new Int32Array([-95, -94]), new Int32Array([16, 23]), new Int32Array([17, 20]), new Int32Array([18, 19]), new Int32Array([-93, -92]), new Int32Array([-91, -90]), new Int32Array([21, 22]), new Int32Array([-89, -88]), new Int32Array([-87, -86]), new Int32Array([24, 27]), new Int32Array([25, 26]), new Int32Array([-85, -84]), new Int32Array([-83, -82]), new Int32Array([28, 29]), new Int32Array([-81, -80]), new Int32Array([-79, -78]), new Int32Array([31, 46]), new Int32Array([32, 39]), new Int32Array([33, 36]), new Int32Array([34, 35]), new Int32Array([-77, -76]), new Int32Array([-75, -74]), new Int32Array([37, 38]), new Int32Array([-73, -72]), new Int32Array([-71, -70]), new Int32Array([40, 43]), new Int32Array([41, 42]), new Int32Array([-58, -57]), new Int32Array([-56, -55]), new Int32Array([44, 45]), new Int32Array([-54, -52]), new Int32Array([-51, -50]), new Int32Array([47, 54]), new Int32Array([48, 51]), new Int32Array([49, 50]), new Int32Array([-49, -48]), new Int32Array([-47, -46]), new Int32Array([52, 53]), new Int32Array([-45, -44]), new Int32Array([-43, -42]), new Int32Array([55, 58]), new Int32Array([56, 57]), new Int32Array([-41, -40]), new Int32Array([-39, -38]), new Int32Array([59, 60]), new Int32Array([-37, -36]), new Int32Array([-35, 61]), new Int32Array([-34, -33])];
    constructor.T_HUFFMAN_NOISE_BAL_3_0DB = [new Int32Array([-64, 1]), new Int32Array([-65, 2]), new Int32Array([-63, 3]), new Int32Array([4, 9]), new Int32Array([-66, 5]), new Int32Array([-62, 6]), new Int32Array([7, 8]), new Int32Array([-76, -75]), new Int32Array([-74, -73]), new Int32Array([10, 17]), new Int32Array([11, 14]), new Int32Array([12, 13]), new Int32Array([-72, -71]), new Int32Array([-70, -69]), new Int32Array([15, 16]), new Int32Array([-68, -67]), new Int32Array([-61, -60]), new Int32Array([18, 21]), new Int32Array([19, 20]), new Int32Array([-59, -58]), new Int32Array([-57, -56]), new Int32Array([22, 23]), new Int32Array([-55, -54]), new Int32Array([-53, -52])];
}, {T_HUFFMAN_ENV_1_5DB: "Array", F_HUFFMAN_ENV_1_5DB: "Array", T_HUFFMAN_ENV_BAL_1_5DB: "Array", F_HUFFMAN_ENV_BAL_1_5DB: "Array", T_HUFFMAN_ENV_3_0DB: "Array", F_HUFFMAN_ENV_3_0DB: "Array", T_HUFFMAN_ENV_BAL_3_0DB: "Array", F_HUFFMAN_ENV_BAL_3_0DB: "Array", T_HUFFMAN_NOISE_3_0DB: "Array", T_HUFFMAN_NOISE_BAL_3_0DB: "Array"}, {});
var LogLevel = stjs.enumeration("DEBUG", "INFO", "WARN", "ERROR");
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  Scalefactor lookup table
 *  @author in-somnia
 */
var ScaleFactorTable = function() {};
ScaleFactorTable = stjs.extend(ScaleFactorTable, null, [], function(constructor, prototype) {
    constructor.SCALEFACTOR_TABLE = new Float32Array([8.881784E-16, 1.0562281E-15, 1.2560739E-15, 1.4937321E-15, 1.7763568E-15, 2.1124561E-15, 2.5121479E-15, 2.9874642E-15, 3.5527137E-15, 4.2249122E-15, 5.0242958E-15, 5.9749285E-15, 7.1054274E-15, 8.4498245E-15, 1.00485916E-14, 1.1949857E-14, 1.4210855E-14, 1.6899649E-14, 2.0097183E-14, 2.3899714E-14, 2.842171E-14, 3.3799298E-14, 4.0194366E-14, 4.7799428E-14, 5.684342E-14, 6.7598596E-14, 8.038873E-14, 9.5598856E-14, 1.1368684E-13, 1.3519719E-13, 1.6077747E-13, 1.9119771E-13, 2.2737368E-13, 2.7039438E-13, 3.2155493E-13, 3.8239542E-13, 4.5474735E-13, 5.4078877E-13, 6.4310986E-13, 7.6479085E-13, 9.094947E-13, 1.0815775E-12, 1.2862197E-12, 1.5295817E-12, 1.8189894E-12, 2.163155E-12, 2.5724394E-12, 3.0591634E-12, 3.6379788E-12, 4.32631E-12, 5.144879E-12, 6.1183268E-12, 7.2759576E-12, 8.65262E-12, 1.0289758E-11, 1.22366535E-11, 1.4551915E-11, 1.730524E-11, 2.0579516E-11, 2.4473307E-11, 2.910383E-11, 3.461048E-11, 4.115903E-11, 4.8946614E-11, 5.820766E-11, 6.922096E-11, 8.231806E-11, 9.789323E-11, 1.1641532E-10, 1.3844192E-10, 1.6463612E-10, 1.9578646E-10, 2.3283064E-10, 2.7688385E-10, 3.2927225E-10, 3.915729E-10, 4.656613E-10, 5.537677E-10, 6.585445E-10, 7.831458E-10, 9.313226E-10, 1.1075354E-9, 1.317089E-9, 1.5662917E-9, 1.8626451E-9, 2.2150708E-9, 2.634178E-9, 3.1325833E-9, 3.7252903E-9, 4.4301416E-9, 5.268356E-9, 6.2651666E-9, 7.4505806E-9, 8.860283E-9, 1.0536712E-8, 1.2530333E-8, 1.4901161E-8, 1.7720566E-8, 2.1073424E-8, 2.5060666E-8, 2.9802322E-8, 3.5441133E-8, 4.2146848E-8, 5.0121333E-8, 5.9604645E-8, 7.0882265E-8, 8.4293696E-8, 1.00242666E-7, 1.1920929E-7, 1.4176453E-7, 1.6858739E-7, 2.0048533E-7, 2.3841858E-7, 2.8352906E-7, 3.3717478E-7, 4.0097066E-7, 4.7683716E-7, 5.670581E-7, 6.7434956E-7, 8.019413E-7, 9.536743E-7, 1.1341162E-6, 1.3486991E-6, 1.6038827E-6, 1.9073486E-6, 2.2682325E-6, 2.6973983E-6, 3.2077653E-6, 3.8146973E-6, 4.536465E-6, 5.3947965E-6, 6.4155306E-6, 7.6293945E-6, 9.07293E-6, 1.0789593E-5, 1.2831061E-5, 1.5258789E-5, 1.814586E-5, 2.1579186E-5, 2.5662122E-5, 3.0517578E-5, 3.629172E-5, 4.3158372E-5, 5.1324245E-5, 6.1035156E-5, 7.258344E-5, 8.6316744E-5, 1.0264849E-4, 1.2207031E-4, 1.4516688E-4, 1.7263349E-4, 2.0529698E-4, 2.4414062E-4, 2.9033376E-4, 3.4526698E-4, 4.1059396E-4, 4.8828125E-4, 5.806675E-4, 6.9053395E-4, 8.211879E-4, 9.765625E-4, 0.001161335, 0.0013810679, 0.0016423758, 0.001953125, 0.00232267, 0.0027621358, 0.0032847517, 0.00390625, 0.00464534, 0.0055242716, 0.0065695033, 0.0078125, 0.00929068, 0.011048543, 0.013139007, 0.015625, 0.01858136, 0.022097087, 0.026278013, 0.03125, 0.03716272, 0.044194173, 0.052556027, 0.0625, 0.07432544, 0.088388346, 0.10511205, 0.125, 0.14865088, 0.17677669, 0.2102241, 0.25, 0.29730177, 0.35355338, 0.4204482, 0.5, 0.59460354, 0.70710677, 0.8408964, 1.0, 1.1892071, 1.4142135, 1.6817929, 2.0, 2.3784142, 2.828427, 3.3635857, 4.0, 4.7568283, 5.656854, 6.7271714, 8.0, 9.513657, 11.313708, 13.454343, 16.0, 19.027313, 22.627417, 26.908686, 32.0, 38.054626, 45.254833, 53.81737, 64.0, 76.10925, 90.50967, 107.63474, 128.0, 152.2185, 181.01933, 215.26949, 256.0, 304.437, 362.03867, 430.53897, 512.0, 608.874, 724.07733, 861.07794, 1024.0, 1217.748, 1448.1547, 1722.1559, 2048.0, 2435.496, 2896.3093, 3444.3118, 4096.0, 4870.992, 5792.6187, 6888.6235, 8192.0, 9741.984, 11585.237, 13777.247, 16384.0, 19483.969, 23170.475, 27554.494, 32768.0, 38967.938, 46340.95, 55108.99, 65536.0, 77935.875, 92681.9, 110217.98, 131072.0, 155871.75, 185363.8, 220435.95, 262144.0, 311743.5, 370727.6, 440871.9, 524288.0, 623487.0, 741455.2, 881743.8, 1048576.0, 1246974.0, 1482910.4, 1763487.6, 2097152.0, 2493948.0, 2965820.8, 3526975.2, 4194304.0, 4987896.0, 5931641.5, 7053950.5, 8388608.0, 9975792.0, 1.1863283E7, 1.4107901E7, 1.6777216E7, 1.9951584E7, 2.3726566E7, 2.8215802E7, 3.3554432E7, 3.9903168E7, 4.7453132E7, 5.6431604E7, 6.7108864E7, 7.9806336E7, 9.4906264E7, 1.12863208E8, 1.34217728E8, 1.59612672E8, 1.89812528E8, 2.25726416E8, 2.68435456E8, 3.19225344E8, 3.79625056E8, 4.51452832E8, 5.3687091E8, 6.3845069E8, 7.5925011E8, 9.0290566E8, 1.07374182E9, 1.27690138E9, 1.51850022E9, 1.80581133E9, 2.14748365E9, 2.55380275E9, 3.03700045E9, 3.61162266E9, 4.2949673E9, 5.1076055E9, 6.0740009E9, 7.2232453E9, 8.5899346E9, 1.0215211E10, 1.21480018E10, 1.44464906E10, 1.71798692E10, 2.0430422E10, 2.42960036E10, 2.88929812E10, 3.4359738E10, 4.0860844E10, 4.8592007E10, 5.7785962E10, 6.8719477E10, 8.1721688E10, 9.7184014E10, 1.15571925E11, 1.37438953E11, 1.63443376E11, 1.94368029E11, 2.3114385E11, 2.74877907E11, 3.26886752E11, 3.88736057E11, 4.622877E11, 5.4975581E11, 6.537735E11, 7.7747211E11, 9.245754E11, 1.09951163E12, 1.30754701E12, 1.55494423E12, 1.8491508E12, 2.19902326E12, 2.61509402E12, 3.10988846E12, 3.6983016E12, 4.3980465E12, 5.230188E12, 6.2197769E12, 7.3966032E12, 8.796093E12, 1.04603761E13, 1.24395538E13, 1.47932064E13, 1.7592186E13, 2.09207521E13, 2.48791077E13, 2.95864128E13, 3.5184372E13, 4.1841504E13, 4.9758215E13, 5.9172826E13, 7.0368744E13, 8.3683009E13, 9.9516431E13, 1.18345651E14, 1.40737488E14, 1.67366017E14, 1.99032861E14, 2.36691302E14, 2.81474977E14, 3.34732034E14, 3.98065723E14, 4.73382605E14, 5.6294995E14, 6.6946407E14, 7.9613145E14, 9.4676521E14, 1.12589991E15, 1.33892814E15, 1.59226289E15, 1.89353042E15, 2.25179981E15, 2.67785627E15, 3.18452578E15, 3.78706084E15, 4.5035996E15, 5.3557125E15, 6.3690516E15, 7.5741217E15, 9.0071993E15, 1.07114251E16, 1.27381031E16, 1.51482434E16, 1.80143985E16, 2.14228502E16, 2.54762063E16, 3.02964867E16, 3.6028797E16, 4.28457E16, 5.0952413E16, 6.0592973E16, 7.2057594E16, 8.5691401E16, 1.01904825E17, 1.21185947E17]);
}, {SCALEFACTOR_TABLE: "Float32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Current state of the decoder, this data is accessed from many methods
 *  
 *  @author The JCodec project
 *  
 */
var DecoderState = function(sh) {
    var mbWidth = sh.sps.pic_width_in_mbs_minus1 + 1;
    this.chromaQpOffset = new Int32Array([sh.pps.chroma_qp_index_offset, sh.pps.extended != null ? sh.pps.extended.second_chroma_qp_index_offset : sh.pps.chroma_qp_index_offset]);
    this.chromaFormat = sh.sps.chroma_format_idc;
    this.mvTop = Array.apply(null, Array(2)).map(function() {
        return Array.apply(null, Array((mbWidth << 2) + 1)).map(function() {
            return new Int32Array(3);
        });
    });
    this.mvLeft = Array.apply(null, Array(2)).map(function() {
        return Array.apply(null, Array(4)).map(function() {
            return new Int32Array(3);
        });
    });
    this.mvTopLeft = Array.apply(null, Array(2)).map(function() {
        return new Int32Array(3);
    });
    this.leftRow = Array.apply(null, Array(3)).map(function() {
        return new Int8Array(16);
    });
    this.topLeft = Array.apply(null, Array(3)).map(function() {
        return new Int8Array(4);
    });
    this.topLine = Array.apply(null, Array(3)).map(function() {
        return new Int8Array(mbWidth << 4);
    });
    this.qp = sh.pps.pic_init_qp_minus26 + 26 + sh.slice_qp_delta;
};
DecoderState = stjs.extend(DecoderState, null, [], function(constructor, prototype) {
    prototype.chromaQpOffset = null;
    prototype.qp = 0;
    prototype.leftRow = null;
    prototype.topLine = null;
    prototype.topLeft = null;
    prototype.chromaFormat = null;
    prototype.mvTop = null;
    prototype.mvLeft = null;
    prototype.mvTopLeft = null;
}, {chromaQpOffset: "Int32Array", leftRow: "Array", topLine: "Array", topLeft: "Array", chromaFormat: "ColorSpace", mvTop: "Array", mvLeft: "Array", mvTopLeft: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var PictureWithMetadata8Bit = function(picture, timestamp, duration) {
    this.picture = picture;
    this.timestamp = timestamp;
    this.duration = duration;
};
PictureWithMetadata8Bit = stjs.extend(PictureWithMetadata8Bit, null, [], function(constructor, prototype) {
    prototype.picture = null;
    prototype.timestamp = 0.0;
    prototype.duration = 0.0;
    prototype.getPicture = function() {
        return this.picture;
    };
    prototype.getTimestamp = function() {
        return this.timestamp;
    };
    prototype.getDuration = function() {
        return this.duration;
    };
}, {picture: "Picture8Bit"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var BooleanArithmeticDecoder = function(input, offset) {
    this.input = input;
    this.offset = offset;
    this.initBoolDecoder();
};
BooleanArithmeticDecoder = stjs.extend(BooleanArithmeticDecoder, null, [], function(constructor, prototype) {
    prototype.bit_count = 0;
    prototype.input = null;
    prototype.offset = 0;
    prototype.range = 0;
    prototype.value = 0;
    prototype.callCounter = 0;
    prototype.debugName = null;
    prototype.initBoolDecoder = function() {
        this.value = 0;
        this.value = (this.input.get() & 255) << 8;
        this.offset++;
        this.range = 255;
        this.bit_count = 0;
    };
    prototype.decodeBit = function() {
        return this.decodeBool(128);
    };
    prototype.decodeBool = function(probability) {
        var bit = 0;
        var range = this.range;
        var value = this.value;
        var split = 1 + (((range - 1) * probability) >> 8);
        var bigsplit = (split << 8);
        this.callCounter++;
        range = split;
        if (value >= bigsplit) {
            range = this.range - range;
            value = value - bigsplit;
            bit = 1;
        }
        var count = this.bit_count;
        var shift = BooleanArithmeticDecoder.leadingZeroCountInByte((range << 24 >> 24));
        range <<= shift;
        value <<= shift;
        count -= shift;
        if (count <= 0) {
            value |= (this.input.get() & 255) << (-count);
            this.offset++;
            count += 8;
        }
        this.bit_count = count;
        this.value = value;
        this.range = range;
        return bit;
    };
    prototype.decodeInt = function(sizeInBits) {
        var v = 0;
         while (sizeInBits-- > 0)
            v = (v << 1) | this.decodeBool(128);
        return v;
    };
    /**
     *   
     *  General formula in VP8 trees.
     *  <ul>
     *   <li> if tree element is a positive number it is treated as index of the child elements <pre>tree[i] > 0</pre>
     *        <ul>
     *        <li> left child is assumed to have index <pre>i</pre> and value <pre>tree[i]</pre> </li>
     *        <li> right child is assumed to have index <pre>i+1</pre> and value <pre>tree[i+1]</pre></li>
     *        </ul>
     *   </li>
     *   <li> a negative tree value means a leaf node was reached and it's negated value should be returned <pre>-tree[i]</pre></li>
     *  </ul>
     *  
     *  Here's a real example of a tree coded according to this formula in VP8 spec.
     *  <pre>
     *  const tree_index mb_segment_tree [2 * (4-1)] =
     *  // +-------+---+
     *  // |       |   |
     *   { 2,  4, -0, -1, -2, -3 };
     *  //     |           |   |
     *  //     +-----------+---+
     *  </pre>
     *  
     *  If presented in hierarchical form this tree would look like:
     *  <pre>
     *  +---------------+
     *  |      root     |
     *  |     /    \    |
     *  |    2      4   |
     *  |   / \    / \  |
     *  | -0  -1 -2  -3 |
     *  +---------------+
     *  <pre>
     *  
     *  On the other hand probabilities are coded only for non-leaf nodes. 
     *  Thus tree array has twice as many nodes as probabilities array
     *  Consider (3>>1) == 1 == (2>>1), and (0>>1) == 0 == (1>>1)
     *  Thus single probability element refers to single parent element in tree.
     *  if (using that probability) a '0' is coded, algorithm goes to the left 
     *  branch, correspondingly if '1' is coded, algorithm goes to
     *  the right branch (see tree structure above).
     *  
     *  The process is repeated until a negative tree element is found.
     *   
     */
    prototype.readTree = function(tree, probability) {
        var i = 0;
         while ((i = tree[i + this.decodeBool(probability[i >> 1])]) > 0){}
        return -i;
    };
    prototype.readTreeSkip = function(t, p, skip_branches) {
        var i = skip_branches * 2;
         while ((i = t[i + this.decodeBool(p[i >> 1])]) > 0){}
        return -i;
    };
    prototype.seek = function() {
        this.input.setPosition(this.offset);
    };
    prototype.toString = function() {
        return "bc: " + this.value;
    };
    constructor.getBitInBytes = function(bs, i) {
        var byteIndex = i >> 3;
        var bitIndex = i & 7;
        return (bs[byteIndex] >> (7 - bitIndex)) & 1;
    };
    constructor.getBitsInBytes = function(bytes, idx, len) {
        var val = 0;
        for (var i = 0; i < len; i++) {
            val = (val << 1) | BooleanArithmeticDecoder.getBitInBytes(bytes, idx + i);
        }
        return val;
    };
    constructor.leadingZeroCountInByte = function(b) {
        var i = b & 255;
        if (i >= 128 || i == 0) 
            return 0;
        return Integer.numberOfLeadingZeros(b) - 24;
    };
}, {input: "ByteBuffer"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var VPXConst = function() {};
VPXConst = stjs.extend(VPXConst, null, [], function(constructor, prototype) {
    constructor.vp8Norm = new Int32Array([0, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    constructor.tokenDefaultBinProbs = [[[new Int32Array([128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]), new Int32Array([128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]), new Int32Array([128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128])], [new Int32Array([253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128]), new Int32Array([189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128]), new Int32Array([106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128])], [new Int32Array([1, 98, 248, 255, 236, 226, 255, 255, 128, 128, 128]), new Int32Array([181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128]), new Int32Array([78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128])], [new Int32Array([1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128]), new Int32Array([184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128]), new Int32Array([77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128])], [new Int32Array([1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128]), new Int32Array([170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128]), new Int32Array([37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128])], [new Int32Array([1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128]), new Int32Array([207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128]), new Int32Array([102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128])], [new Int32Array([1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128]), new Int32Array([177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128]), new Int32Array([80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128])], [new Int32Array([1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]), new Int32Array([246, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]), new Int32Array([255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128])]], [[new Int32Array([198, 35, 237, 223, 193, 187, 162, 160, 145, 155, 62]), new Int32Array([131, 45, 198, 221, 172, 176, 220, 157, 252, 221, 1]), new Int32Array([68, 47, 146, 208, 149, 167, 221, 162, 255, 223, 128])], [new Int32Array([1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128]), new Int32Array([184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128]), new Int32Array([81, 99, 181, 242, 176, 190, 249, 202, 255, 255, 128])], [new Int32Array([1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128]), new Int32Array([99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128]), new Int32Array([23, 91, 163, 242, 170, 187, 247, 210, 255, 255, 128])], [new Int32Array([1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128]), new Int32Array([109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128]), new Int32Array([44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128])], [new Int32Array([1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128]), new Int32Array([94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128]), new Int32Array([22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128])], [new Int32Array([1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128]), new Int32Array([124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128]), new Int32Array([35, 77, 181, 251, 193, 211, 255, 205, 128, 128, 128])], [new Int32Array([1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128]), new Int32Array([121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128]), new Int32Array([45, 99, 188, 251, 195, 217, 255, 224, 128, 128, 128])], [new Int32Array([1, 1, 251, 255, 213, 255, 128, 128, 128, 128, 128]), new Int32Array([203, 1, 248, 255, 255, 128, 128, 128, 128, 128, 128]), new Int32Array([137, 1, 177, 255, 224, 255, 128, 128, 128, 128, 128])]], [[new Int32Array([253, 9, 248, 251, 207, 208, 255, 192, 128, 128, 128]), new Int32Array([175, 13, 224, 243, 193, 185, 249, 198, 255, 255, 128]), new Int32Array([73, 17, 171, 221, 161, 179, 236, 167, 255, 234, 128])], [new Int32Array([1, 95, 247, 253, 212, 183, 255, 255, 128, 128, 128]), new Int32Array([239, 90, 244, 250, 211, 209, 255, 255, 128, 128, 128]), new Int32Array([155, 77, 195, 248, 188, 195, 255, 255, 128, 128, 128])], [new Int32Array([1, 24, 239, 251, 218, 219, 255, 205, 128, 128, 128]), new Int32Array([201, 51, 219, 255, 196, 186, 128, 128, 128, 128, 128]), new Int32Array([69, 46, 190, 239, 201, 218, 255, 228, 128, 128, 128])], [new Int32Array([1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128]), new Int32Array([223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128]), new Int32Array([141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128])], [new Int32Array([1, 16, 248, 255, 255, 128, 128, 128, 128, 128, 128]), new Int32Array([190, 36, 230, 255, 236, 255, 128, 128, 128, 128, 128]), new Int32Array([149, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128])], [new Int32Array([1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128]), new Int32Array([247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128]), new Int32Array([240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128])], [new Int32Array([1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128]), new Int32Array([213, 62, 250, 255, 255, 128, 128, 128, 128, 128, 128]), new Int32Array([55, 93, 255, 128, 128, 128, 128, 128, 128, 128, 128])], [new Int32Array([128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]), new Int32Array([128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]), new Int32Array([128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128])]], [[new Int32Array([202, 24, 213, 235, 186, 191, 220, 160, 240, 175, 255]), new Int32Array([126, 38, 182, 232, 169, 184, 228, 174, 255, 187, 128]), new Int32Array([61, 46, 138, 219, 151, 178, 240, 170, 255, 216, 128])], [new Int32Array([1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128]), new Int32Array([166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128]), new Int32Array([39, 77, 162, 232, 172, 180, 245, 178, 255, 255, 128])], [new Int32Array([1, 52, 220, 246, 198, 199, 249, 220, 255, 255, 128]), new Int32Array([124, 74, 191, 243, 183, 193, 250, 221, 255, 255, 128]), new Int32Array([24, 71, 130, 219, 154, 170, 243, 182, 255, 255, 128])], [new Int32Array([1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128]), new Int32Array([149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128]), new Int32Array([28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128])], [new Int32Array([1, 81, 230, 252, 204, 203, 255, 192, 128, 128, 128]), new Int32Array([123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128]), new Int32Array([20, 95, 153, 243, 164, 173, 255, 203, 128, 128, 128])], [new Int32Array([1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128]), new Int32Array([168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128]), new Int32Array([47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128])], [new Int32Array([1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128]), new Int32Array([141, 84, 213, 252, 201, 202, 255, 219, 128, 128, 128]), new Int32Array([42, 80, 160, 240, 162, 185, 255, 205, 128, 128, 128])], [new Int32Array([1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]), new Int32Array([244, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]), new Int32Array([238, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128])]]];
    constructor.tokenProbUpdateFlagProbs = [[[new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255]), new Int32Array([250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255]), new Int32Array([254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])]], [[new Int32Array([217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255]), new Int32Array([234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255])], [new Int32Array([255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])]], [[new Int32Array([186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255])], [new Int32Array([255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])]], [[new Int32Array([248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])]]];
    constructor.probCoeffExtCat6 = new Int32Array([254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129]);
    constructor.probCoeffExtCat5 = new Int32Array([180, 157, 141, 134, 130]);
    constructor.dc_qlookup = new Int32Array([4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 93, 95, 96, 98, 100, 101, 102, 104, 106, 108, 110, 112, 114, 116, 118, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157]);
    constructor.ac_qlookup = new Int32Array([4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152, 155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284]);
    constructor.zigzag = new Int32Array([0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15]);
}, {vp8Norm: "Int32Array", tokenDefaultBinProbs: "Array", tokenProbUpdateFlagProbs: "Array", probCoeffExtCat6: "Int32Array", probCoeffExtCat5: "Int32Array", dc_qlookup: "Int32Array", ac_qlookup: "Int32Array", zigzag: "Int32Array"}, {});
var AssertionException = function(string) {
    RuntimeException.call(this, string);
};
AssertionException = stjs.extend(AssertionException, RuntimeException, [], null, {}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 * 
 *  @author in-somnia
 */
var SineWindows = function() {};
SineWindows = stjs.extend(SineWindows, null, [], function(constructor, prototype) {
    constructor.SINE_1024 = new Float32Array([7.669903E-4, 0.002300969, 0.0038349426, 0.005368907, 0.0069028586, 0.008436794, 0.00997071, 0.011504602, 0.013038468, 0.014572302, 0.016106103, 0.017639864, 0.019173585, 0.02070726, 0.022240888, 0.023774462, 0.025307981, 0.02684144, 0.028374836, 0.029908165, 0.031441424, 0.03297461, 0.034507714, 0.036040742, 0.037573684, 0.039106537, 0.040639296, 0.042171963, 0.04370453, 0.04523699, 0.046769347, 0.048301592, 0.049833726, 0.05136574, 0.052897636, 0.05442941, 0.05596105, 0.057492558, 0.059023935, 0.06055517, 0.062086266, 0.063617215, 0.06514801, 0.06667866, 0.06820914, 0.06973947, 0.07126963, 0.07279963, 0.07432945, 0.07585911, 0.07738858, 0.07891786, 0.080446966, 0.08197588, 0.0835046, 0.085033126, 0.08656145, 0.08808957, 0.08961748, 0.09114519, 0.092672676, 0.09419994, 0.09572699, 0.097253814, 0.09878041, 0.10030677, 0.1018329, 0.10335878, 0.10488442, 0.10640982, 0.10793497, 0.109459855, 0.11098449, 0.11250886, 0.11403298, 0.115556814, 0.11708038, 0.11860368, 0.12012669, 0.121649414, 0.12317186, 0.12469402, 0.12621588, 0.12773745, 0.1292587, 0.13077967, 0.13230032, 0.13382065, 0.13534068, 0.13686039, 0.13837977, 0.13989884, 0.14141756, 0.14293596, 0.14445402, 0.14597175, 0.14748912, 0.14900614, 0.15052283, 0.15203916, 0.15355512, 0.15507074, 0.15658598, 0.15810084, 0.15961535, 0.16112947, 0.16264322, 0.16415659, 0.16566956, 0.16718215, 0.16869435, 0.17020614, 0.17171754, 0.17322853, 0.17473911, 0.1762493, 0.17775905, 0.17926839, 0.18077731, 0.1822858, 0.18379387, 0.1853015, 0.18680869, 0.18831545, 0.18982176, 0.19132763, 0.19283305, 0.19433801, 0.19584252, 0.19734657, 0.19885014, 0.20035325, 0.2018559, 0.20335807, 0.20485975, 0.20636095, 0.20786168, 0.20936191, 0.21086164, 0.21236089, 0.21385963, 0.21535787, 0.2168556, 0.21835282, 0.21984953, 0.22134572, 0.2228414, 0.22433653, 0.22583115, 0.22732525, 0.22881879, 0.23031181, 0.23180428, 0.2332962, 0.23478758, 0.2362784, 0.23776866, 0.23925838, 0.24074753, 0.24223611, 0.24372411, 0.24521154, 0.24669841, 0.24818468, 0.24967039, 0.2511555, 0.25264, 0.25412393, 0.25560725, 0.25708997, 0.25857207, 0.2600536, 0.26153448, 0.26301476, 0.26449442, 0.26597348, 0.26745188, 0.26892966, 0.2704068, 0.27188334, 0.2733592, 0.27483445, 0.27630904, 0.27778298, 0.27925625, 0.28072888, 0.28220084, 0.28367212, 0.28514278, 0.28661272, 0.28808203, 0.28955063, 0.29101855, 0.2924858, 0.29395235, 0.2954182, 0.29688337, 0.29834786, 0.29981163, 0.3012747, 0.30273703, 0.30419868, 0.3056596, 0.30711982, 0.3085793, 0.31003806, 0.31149608, 0.31295338, 0.31440994, 0.31586576, 0.31732082, 0.31877515, 0.32022873, 0.32168156, 0.32313362, 0.32458493, 0.32603547, 0.32748523, 0.32893425, 0.3303825, 0.33182994, 0.3332766, 0.3347225, 0.3361676, 0.3376119, 0.33905542, 0.34049815, 0.34194008, 0.34338117, 0.34482148, 0.34626096, 0.34769964, 0.3491375, 0.35057455, 0.35201076, 0.35344616, 0.3548807, 0.35631442, 0.3577473, 0.35917935, 0.3606105, 0.36204088, 0.36347038, 0.364899, 0.36632678, 0.36775368, 0.36917976, 0.37060493, 0.37202924, 0.37345266, 0.37487522, 0.3762969, 0.3777177, 0.3791376, 0.3805566, 0.38197473, 0.38339192, 0.38480824, 0.38622364, 0.38763815, 0.38905174, 0.3904644, 0.39187613, 0.39328697, 0.39469686, 0.39610586, 0.3975139, 0.398921, 0.40032718, 0.4017324, 0.40313667, 0.40454, 0.40594238, 0.4073438, 0.40874428, 0.4101438, 0.41154233, 0.41293988, 0.4143365, 0.41573212, 0.41712677, 0.41852042, 0.4199131, 0.4213048, 0.4226955, 0.4240852, 0.4254739, 0.4268616, 0.42824832, 0.429634, 0.4310187, 0.43240237, 0.43378502, 0.43516666, 0.43654725, 0.43792683, 0.4393054, 0.4406829, 0.44205937, 0.4434348, 0.4448092, 0.44618255, 0.44755486, 0.4489261, 0.45029628, 0.45166543, 0.45303348, 0.45440048, 0.4557664, 0.45713127, 0.45849505, 0.45985776, 0.4612194, 0.46257994, 0.46393937, 0.46529773, 0.466655, 0.46801114, 0.46936622, 0.47072017, 0.47207302, 0.47342476, 0.47477537, 0.47612488, 0.4774733, 0.47882056, 0.48016667, 0.48151168, 0.48285556, 0.4841983, 0.4855399, 0.48688036, 0.48821968, 0.48955783, 0.49089485, 0.4922307, 0.4935654, 0.49489895, 0.4962313, 0.4975625, 0.49889255, 0.5002214, 0.50154907, 0.50287557, 0.5042009, 0.50552505, 0.506848, 0.5081697, 0.50949025, 0.5108096, 0.51212776, 0.5134447, 0.51476043, 0.516075, 0.5173883, 0.5187004, 0.52001125, 0.52132094, 0.5226294, 0.52393657, 0.5252425, 0.52654725, 0.52785075, 0.529153, 0.530454, 0.5317537, 0.5330522, 0.53434944, 0.5356455, 0.53694016, 0.53823364, 0.53952587, 0.5408168, 0.54210645, 0.5433948, 0.5446819, 0.54596776, 0.5472523, 0.5485355, 0.5498175, 0.55109817, 0.5523775, 0.55365556, 0.55493236, 0.5562078, 0.55748194, 0.5587548, 0.5600263, 0.5612965, 0.5625654, 0.56383294, 0.5650992, 0.5663641, 0.56762767, 0.5688899, 0.5701508, 0.57141036, 0.57266855, 0.57392544, 0.57518095, 0.5764351, 0.5776879, 0.5789393, 0.5801894, 0.5814381, 0.5826855, 0.58393145, 0.58517605, 0.5864193, 0.58766115, 0.5889016, 0.5901407, 0.5913784, 0.59261465, 0.5938496, 0.59508306, 0.5963152, 0.59754586, 0.5987752, 0.60000306, 0.60122955, 0.6024546, 0.6036782, 0.6049005, 0.60612124, 0.60734063, 0.6085586, 0.60977507, 0.61099017, 0.6122038, 0.613416, 0.61462677, 0.6158361, 0.6170439, 0.6182503, 0.6194553, 0.62065876, 0.6218608, 0.62306136, 0.6242605, 0.6254581, 0.62665427, 0.627849, 0.6290422, 0.63023394, 0.6314242, 0.63261294, 0.6338002, 0.634986, 0.63617027, 0.63735306, 0.63853437, 0.6397142, 0.64089245, 0.6420692, 0.6432445, 0.64441824, 0.6455905, 0.6467612, 0.6479304, 0.64909804, 0.6502642, 0.6514288, 0.6525919, 0.6537534, 0.6549134, 0.6560719, 0.6572288, 0.6583842, 0.65953803, 0.6606903, 0.661841, 0.66299015, 0.6641378, 0.6652838, 0.66642827, 0.6675712, 0.6687125, 0.66985226, 0.67099047, 0.67212707, 0.67326206, 0.6743955, 0.6755274, 0.6766576, 0.6777863, 0.67891335, 0.68003887, 0.6811627, 0.682285, 0.6834057, 0.6845247, 0.6856422, 0.68675804, 0.68787223, 0.6889849, 0.69009584, 0.6912052, 0.6923129, 0.69341904, 0.6945235, 0.6956263, 0.6967275, 0.6978271, 0.698925, 0.70002127, 0.7011159, 0.7022089, 0.7033002, 0.70438987, 0.7054779, 0.70656425, 0.70764893, 0.70873195, 0.7098133, 0.710893, 0.711971, 0.7130473, 0.714122, 0.71519494, 0.7162663, 0.7173359, 0.7184038, 0.71947, 0.72053456, 0.72159743, 0.7226586, 0.723718, 0.72477573, 0.7258318, 0.7268861, 0.7279387, 0.7289896, 0.7300388, 0.7310863, 0.732132, 0.73317605, 0.73421836, 0.73525894, 0.7362978, 0.7373349, 0.7383703, 0.7394039, 0.74043584, 0.741466, 0.7424944, 0.7435211, 0.744546, 0.74556917, 0.74659055, 0.7476102, 0.7486281, 0.7496442, 0.75065863, 0.7516712, 0.75268203, 0.75369114, 0.7546984, 0.7557039, 0.75670767, 0.7577096, 0.7587098, 0.75970817, 0.76070476, 0.76169956, 0.7626926, 0.7636838, 0.76467323, 0.7656609, 0.7666467, 0.7676307, 0.7686129, 0.7695933, 0.7705719, 0.7715487, 0.77252364, 0.7734968, 0.7744681, 0.77543765, 0.77640533, 0.77737117, 0.7783352, 0.77929735, 0.78025776, 0.78121626, 0.7821729, 0.7831278, 0.7840808, 0.7850319, 0.78598124, 0.7869287, 0.78787434, 0.78881806, 0.78976, 0.7907, 0.7916382, 0.7925745, 0.79350895, 0.7944415, 0.79537225, 0.79630107, 0.79722804, 0.79815316, 0.7990764, 0.7999977, 0.80091715, 0.8018347, 0.8027504, 0.8036642, 0.8045761, 0.8054861, 0.8063942, 0.80730045, 0.8082047, 0.8091071, 0.81000763, 0.81090623, 0.811803, 0.81269777, 0.8135906, 0.81448156, 0.8153706, 0.8162577, 0.8171429, 0.8180262, 0.81890756, 0.81978697, 0.82066447, 0.82154006, 0.8224137, 0.8232854, 0.82415515, 0.825023, 0.8258889, 0.8267528, 0.8276148, 0.8284748, 0.82933295, 0.83018905, 0.83104324, 0.8318955, 0.8327458, 0.8335941, 0.8344404, 0.8352848, 0.8361273, 0.8369677, 0.8378062, 0.8386427, 0.83947724, 0.84030986, 0.84114045, 0.841969, 0.84279567, 0.8436203, 0.84444296, 0.84526366, 0.8460823, 0.84689903, 0.84771377, 0.8485265, 0.84933716, 0.8501459, 0.85095257, 0.8517573, 0.85256, 0.8533607, 0.8541594, 0.8549561, 0.85575074, 0.8565434, 0.857334, 0.85812265, 0.85890925, 0.8596939, 0.86047643, 0.86125696, 0.86203545, 0.8628119, 0.86358637, 0.8643588, 0.8651292, 0.86589754, 0.8666639, 0.8674281, 0.86819035, 0.86895055, 0.86970866, 0.8704648, 0.87121886, 0.87197083, 0.8727208, 0.8734687, 0.87421453, 0.8749583, 0.8757, 0.8764397, 0.87717724, 0.8779128, 0.87864625, 0.87937766, 0.880107, 0.8808343, 0.88155943, 0.88228256, 0.8830036, 0.88372254, 0.88443947, 0.88515425, 0.88586694, 0.8865776, 0.8872861, 0.88799256, 0.88869697, 0.88939923, 0.8900994, 0.8907975, 0.8914935, 0.8921874, 0.8928792, 0.8935689, 0.8942565, 0.894942, 0.89562535, 0.89630663, 0.89698577, 0.8976628, 0.8983378, 0.8990106, 0.8996813, 0.9003499, 0.9010164, 0.90168077, 0.902343, 0.9030031, 0.9036611, 0.90431696, 0.9049707, 0.9056223, 0.90627176, 0.9069191, 0.90756434, 0.90820736, 0.90884835, 0.9094871, 0.91012377, 0.91075826, 0.91139066, 0.91202086, 0.912649, 0.9132749, 0.91389865, 0.9145203, 0.9151398, 0.9157571, 0.9163723, 0.9169853, 0.91759616, 0.91820484, 0.9188114, 0.9194158, 0.92001796, 0.92061806, 0.9212159, 0.92181164, 0.9224052, 0.9229965, 0.9235858, 0.92417276, 0.9247576, 0.9253403, 0.9259208, 0.9264991, 0.92707527, 0.92764926, 0.928221, 0.9287906, 0.929358, 0.92992324, 0.93048626, 0.9310471, 0.93160576, 0.9321622, 0.9327165, 0.93326855, 0.93381846, 0.9343661, 0.9349116, 0.93545485, 0.93599594, 0.9365348, 0.9370715, 0.937606, 0.93813825, 0.9386683, 0.9391961, 0.93972176, 0.9402452, 0.9407664, 0.9412854, 0.9418022, 0.9423168, 0.9428291, 0.9433392, 0.9438471, 0.9443528, 0.9448563, 0.94535756, 0.9458566, 0.9463534, 0.9468479, 0.94734025, 0.9478304, 0.94831824, 0.9488039, 0.9492873, 0.9497685, 0.95024747, 0.9507241, 0.95119864, 0.9516709, 0.95214087, 0.9526086, 0.9530741, 0.9535374, 0.95399845, 0.9544572, 0.95491374, 0.95536804, 0.9558201, 0.95626986, 0.95671743, 0.9571627, 0.9576057, 0.9580465, 0.95848507, 0.9589213, 0.95935535, 0.95978713, 0.96021664, 0.9606439, 0.96106887, 0.9614916, 0.96191204, 0.9623302, 0.96274614, 0.9631598, 0.9635712, 0.9639804, 0.96438724, 0.96479183, 0.9651941, 0.9655942, 0.965992, 0.96638745, 0.9667807, 0.96717167, 0.96756035, 0.96794677, 0.96833086, 0.96871275, 0.9690923, 0.9694696, 0.9698446, 0.97021735, 0.9705878, 0.9709559, 0.9713218, 0.9716854, 0.97204673, 0.97240573, 0.97276247, 0.9731169, 0.973469, 0.9738189, 0.97416645, 0.97451174, 0.9748547, 0.9751954, 0.9755338, 0.9758699, 0.9762037, 0.9765352, 0.9768644, 0.9771913, 0.97751594, 0.9778382, 0.97815824, 0.9784759, 0.97879136, 0.97910446, 0.97941524, 0.97972375, 0.9800299, 0.9803338, 0.98063534, 0.9809346, 0.9812316, 0.98152626, 0.98181856, 0.9821086, 0.9823963, 0.9826817, 0.9829648, 0.9832456, 0.983524, 0.98380023, 0.98407406, 0.98434556, 0.9846148, 0.98488164, 0.9851462, 0.9854085, 0.9856684, 0.98592603, 0.9861813, 0.9864343, 0.9866849, 0.9869333, 0.9871793, 0.98742294, 0.98766434, 0.98790336, 0.9881401, 0.9883745, 0.9886065, 0.9888363, 0.9890637, 0.98928875, 0.9895115, 0.98973197, 0.98995006, 0.9901658, 0.9903792, 0.99059033, 0.9907991, 0.99100554, 0.9912097, 0.99141145, 0.9916109, 0.991808, 0.9920028, 0.99219525, 0.9923853, 0.99257314, 0.9927586, 0.9929417, 0.99312246, 0.99330086, 0.993477, 0.99365073, 0.99382216, 0.9939912, 0.99415797, 0.99432236, 0.9944844, 0.99464417, 0.9948015, 0.99495655, 0.99510926, 0.9952596, 0.99540764, 0.9955533, 0.9956966, 0.9958376, 0.99597627, 0.9961126, 0.9962465, 0.9963781, 0.9965074, 0.9966343, 0.9967589, 0.9968811, 0.997001, 0.99711853, 0.99723375, 0.9973466, 0.9974571, 0.9975652, 0.99767107, 0.9977745, 0.99787563, 0.9979744, 0.9980708, 0.99816483, 0.99825656, 0.9983459, 0.99843293, 0.99851763, 0.99859995, 0.99867994, 0.99875754, 0.9988328, 0.9989057, 0.9989763, 0.9990445, 0.99911034, 0.9991739, 0.99923503, 0.99929386, 0.9993503, 0.99940443, 0.99945617, 0.9995056, 0.99955267, 0.9995974, 0.9996397, 0.9996797, 0.99971735, 0.99975264, 0.9997856, 0.9998162, 0.99984443, 0.9998703, 0.99989384, 0.999915, 0.99993384, 0.9999503, 0.9999644, 0.99997616, 0.9999856, 0.99999267, 0.9999974, 0.9999997]);
    constructor.SINE_128 = new Float32Array([0.0061358847, 0.01840673, 0.030674804, 0.04293826, 0.055195246, 0.06744392, 0.07968244, 0.091908954, 0.10412163, 0.11631863, 0.1284981, 0.14065824, 0.15279719, 0.16491312, 0.17700422, 0.18906866, 0.20110464, 0.21311031, 0.22508392, 0.2370236, 0.24892761, 0.2607941, 0.27262136, 0.28440753, 0.2961509, 0.30784965, 0.31950203, 0.3311063, 0.34266073, 0.35416353, 0.36561298, 0.37700742, 0.38834503, 0.3996242, 0.41084316, 0.42200026, 0.43309382, 0.44412214, 0.45508358, 0.4659765, 0.47679922, 0.48755017, 0.49822766, 0.50883013, 0.519356, 0.52980363, 0.54017144, 0.55045795, 0.56066155, 0.57078075, 0.58081394, 0.5907597, 0.60061646, 0.6103828, 0.6200572, 0.62963825, 0.63912445, 0.6485144, 0.6578067, 0.66699994, 0.6760927, 0.6850837, 0.69397146, 0.70275474, 0.7114322, 0.72000253, 0.72846437, 0.7368166, 0.74505776, 0.7531868, 0.7612024, 0.76910335, 0.7768885, 0.78455657, 0.79210657, 0.79953724, 0.8068476, 0.8140363, 0.8211025, 0.82804507, 0.8348629, 0.841555, 0.84812033, 0.854558, 0.86086696, 0.86704624, 0.873095, 0.8790122, 0.8847971, 0.89044875, 0.89596623, 0.9013488, 0.9065957, 0.91170603, 0.9166791, 0.92151403, 0.9262102, 0.93076694, 0.9351835, 0.9394592, 0.94359344, 0.9475856, 0.951435, 0.9551412, 0.95870346, 0.9621214, 0.96539444, 0.9685221, 0.9715039, 0.97433937, 0.97702813, 0.9795698, 0.9819639, 0.9842101, 0.9863081, 0.9882576, 0.9900582, 0.99170977, 0.9932119, 0.9945646, 0.9957674, 0.9968203, 0.99772304, 0.99847555, 0.99907774, 0.9995294, 0.9998306, 0.99998116]);
    constructor.SINE_960 = new Float32Array([8.18123E-4, 0.0024543668, 0.004090604, 0.00572683, 0.0073630414, 0.008999232, 0.010635399, 0.012271538, 0.013907644, 0.015543712, 0.017179739, 0.01881572, 0.020451652, 0.022087527, 0.023723343, 0.025359096, 0.026994782, 0.028630394, 0.030265931, 0.031901386, 0.03353676, 0.035172038, 0.036807224, 0.03844231, 0.040077295, 0.041712172, 0.043346938, 0.044981588, 0.046616115, 0.04825052, 0.049884796, 0.051518936, 0.05315294, 0.0547868, 0.056420516, 0.05805408, 0.059687488, 0.061320737, 0.06295382, 0.064586736, 0.06621948, 0.06785204, 0.06948443, 0.071116626, 0.07274863, 0.07438044, 0.07601206, 0.07764347, 0.07927467, 0.08090566, 0.08253644, 0.08416699, 0.08579731, 0.08742741, 0.089057274, 0.090686895, 0.09231628, 0.093945414, 0.0955743, 0.09720293, 0.09883129, 0.1004594, 0.10208723, 0.10371479, 0.10534207, 0.10696907, 0.10859578, 0.110222206, 0.11184833, 0.11347417, 0.11509969, 0.11672491, 0.11834981, 0.1199744, 0.12159866, 0.123222604, 0.12484621, 0.1264695, 0.12809242, 0.12971503, 0.13133727, 0.13295917, 0.1345807, 0.13620189, 0.1378227, 0.13944314, 0.14106323, 0.14268291, 0.14430223, 0.14592116, 0.14753969, 0.14915784, 0.15077558, 0.15239291, 0.15400985, 0.15562636, 0.15724246, 0.15885815, 0.16047339, 0.16208823, 0.1637026, 0.16531657, 0.16693008, 0.16854315, 0.17015575, 0.1717679, 0.1733796, 0.17499083, 0.1766016, 0.1782119, 0.17982171, 0.18143104, 0.18303989, 0.18464825, 0.18625611, 0.18786347, 0.18947034, 0.19107668, 0.19268253, 0.19428785, 0.19589266, 0.19749694, 0.19910069, 0.20070392, 0.2023066, 0.20390874, 0.20551033, 0.20711137, 0.20871186, 0.2103118, 0.21191117, 0.21350996, 0.2151082, 0.21670584, 0.21830292, 0.21989942, 0.22149532, 0.22309062, 0.22468533, 0.22627944, 0.22787294, 0.22946583, 0.2310581, 0.23264977, 0.2342408, 0.23583122, 0.23742099, 0.23901014, 0.24059863, 0.24218649, 0.2437737, 0.24536026, 0.24694616, 0.2485314, 0.25011596, 0.25169986, 0.2532831, 0.25486565, 0.25644752, 0.25802872, 0.2596092, 0.261189, 0.2627681, 0.26434648, 0.2659242, 0.26750115, 0.26907742, 0.27065295, 0.27222776, 0.27380186, 0.2753752, 0.27694783, 0.2785197, 0.2800908, 0.28166118, 0.2832308, 0.2847997, 0.28636777, 0.2879351, 0.2895017, 0.29106748, 0.2926325, 0.29419672, 0.29576015, 0.2973228, 0.29888466, 0.3004457, 0.30200595, 0.30356538, 0.305124, 0.3066818, 0.3082388, 0.30979496, 0.31135032, 0.3129048, 0.31445846, 0.31601128, 0.31756327, 0.3191144, 0.32066464, 0.32221407, 0.32376263, 0.3253103, 0.3268571, 0.32840303, 0.3299481, 0.33149227, 0.33303556, 0.33457795, 0.33611944, 0.33766004, 0.33919972, 0.3407385, 0.3422764, 0.34381336, 0.34534937, 0.3468845, 0.34841868, 0.34995192, 0.35148424, 0.3530156, 0.35454604, 0.35607553, 0.35760406, 0.3591316, 0.36065823, 0.36218387, 0.36370853, 0.36523223, 0.36675495, 0.3682767, 0.36979744, 0.3713172, 0.37283596, 0.37435374, 0.3758705, 0.37738624, 0.378901, 0.38041475, 0.38192746, 0.38343915, 0.38494983, 0.38645947, 0.38796806, 0.3894756, 0.39098215, 0.39248762, 0.39399204, 0.3954954, 0.39699772, 0.39849895, 0.39999914, 0.40149826, 0.4029963, 0.40449324, 0.4059891, 0.4074839, 0.4089776, 0.4104702, 0.4119617, 0.4134521, 0.41494137, 0.41642955, 0.41791663, 0.41940257, 0.42088738, 0.4223711, 0.42385367, 0.42533508, 0.4268154, 0.42829454, 0.42977253, 0.43124938, 0.43272507, 0.4341996, 0.435673, 0.4371452, 0.43861625, 0.4400861, 0.44155478, 0.44302228, 0.4444886, 0.44595373, 0.44741768, 0.4488804, 0.45034194, 0.45180228, 0.4532614, 0.4547193, 0.45617598, 0.45763147, 0.4590857, 0.46053872, 0.4619905, 0.46344104, 0.46489033, 0.4663384, 0.4677852, 0.46923077, 0.47067505, 0.4721181, 0.4735599, 0.47500038, 0.47643963, 0.4778776, 0.47931427, 0.48074967, 0.48218378, 0.4836166, 0.48504812, 0.48647836, 0.48790726, 0.48933488, 0.4907612, 0.4921862, 0.49360988, 0.49503222, 0.49645326, 0.49787295, 0.49929133, 0.50070834, 0.502124, 0.50353837, 0.50495136, 0.50636303, 0.50777334, 0.5091823, 0.51058984, 0.51199603, 0.51340085, 0.5148043, 0.5162064, 0.5176071, 0.5190064, 0.5204043, 0.5218008, 0.523196, 0.52458966, 0.525982, 0.5273729, 0.5287624, 0.53015053, 0.5315372, 0.53292245, 0.5343062, 0.53568864, 0.5370696, 0.5384491, 0.53982717, 0.5412038, 0.542579, 0.5439527, 0.545325, 0.5466958, 0.5480651, 0.54943305, 0.5507994, 0.5521644, 0.55352783, 0.5548898, 0.5562503, 0.5576093, 0.5589668, 0.5603228, 0.56167734, 0.5630303, 0.56438184, 0.5657318, 0.56708026, 0.56842726, 0.56977266, 0.57111657, 0.572459, 0.5737998, 0.5751391, 0.5764769, 0.5778131, 0.5791478, 0.58048093, 0.5818125, 0.5831425, 0.584471, 0.58579785, 0.58712316, 0.5884469, 0.5897691, 0.5910897, 0.5924087, 0.59372616, 0.595042, 0.5963562, 0.5976689, 0.59897995, 0.60028934, 0.6015972, 0.6029034, 0.60420805, 0.60551107, 0.6068124, 0.60811216, 0.6094103, 0.61070675, 0.61200166, 0.61329484, 0.6145864, 0.6158764, 0.6171646, 0.61845124, 0.61973625, 0.62101954, 0.62230116, 0.6235812, 0.6248595, 0.6261361, 0.62741107, 0.6286844, 0.629956, 0.6312259, 0.63249415, 0.63376063, 0.6350255, 0.63628864, 0.63755006, 0.6388098, 0.6400678, 0.6413241, 0.64257866, 0.64383155, 0.6450827, 0.6463321, 0.6475798, 0.6488257, 0.65006995, 0.6513124, 0.65255314, 0.65379214, 0.65502936, 0.65626484, 0.65749854, 0.6587305, 0.6599607, 0.66118914, 0.6624158, 0.6636407, 0.66486377, 0.6660851, 0.66730464, 0.6685224, 0.66973835, 0.67095256, 0.6721649, 0.6733755, 0.67458427, 0.67579126, 0.6769964, 0.67819977, 0.6794013, 0.680601, 0.6817989, 0.68299496, 0.6841892, 0.6853816, 0.6865722, 0.6877609, 0.6889478, 0.69013286, 0.691316, 0.6924974, 0.6936769, 0.6948545, 0.6960303, 0.69720423, 0.69837624, 0.6995464, 0.7007147, 0.7018812, 0.7030457, 0.7042084, 0.7053692, 0.70652807, 0.70768505, 0.70884013, 0.70999336, 0.7111447, 0.71229404, 0.71344155, 0.71458715, 0.71573085, 0.7168726, 0.7180124, 0.71915036, 0.7202863, 0.7214204, 0.72255254, 0.7236827, 0.72481096, 0.7259373, 0.7270617, 0.7281841, 0.72930455, 0.7304231, 0.73153967, 0.7326543, 0.7337669, 0.7348776, 0.73598635, 0.7370931, 0.73819786, 0.73930067, 0.74040145, 0.7415003, 0.74259716, 0.743692, 0.7447849, 0.7458758, 0.74696463, 0.7480515, 0.7491364, 0.7502193, 0.75130016, 0.752379, 0.7534558, 0.75453067, 0.75560343, 0.75667423, 0.75774294, 0.7588097, 0.7598744, 0.76093704, 0.76199764, 0.7630562, 0.7641128, 0.76516724, 0.76621974, 0.7672701, 0.7683184, 0.7693647, 0.7704089, 0.7714511, 0.77249116, 0.77352923, 0.77456516, 0.77559906, 0.7766308, 0.77766055, 0.7786882, 0.77971375, 0.7807372, 0.7817586, 0.7827779, 0.78379506, 0.7848102, 0.78582317, 0.78683406, 0.7878428, 0.7888495, 0.78985405, 0.7908565, 0.7918568, 0.792855, 0.79385114, 0.7948451, 0.7958369, 0.7968266, 0.7978142, 0.7987996, 0.7997829, 0.800764, 0.80174303, 0.8027199, 0.8036946, 0.8046672, 0.8056376, 0.8066058, 0.8075719, 0.8085358, 0.8094976, 0.81045717, 0.8114146, 0.8123699, 0.81332296, 0.81427383, 0.81522256, 0.8161691, 0.81711346, 0.8180556, 0.8189956, 0.81993335, 0.82086897, 0.8218024, 0.8227335, 0.8236625, 0.8245893, 0.8255139, 0.8264362, 0.8273564, 0.8282743, 0.82919, 0.8301035, 0.8310148, 0.83192384, 0.83283067, 0.8337353, 0.83463764, 0.83553773, 0.8364357, 0.8373313, 0.8382247, 0.83911586, 0.8400048, 0.8408915, 0.8417759, 0.84265804, 0.8435379, 0.8444156, 0.84529096, 0.8461641, 0.84703493, 0.84790355, 0.84876984, 0.84963393, 0.8504957, 0.8513552, 0.8522124, 0.85306734, 0.85392, 0.85477036, 0.8556184, 0.8564642, 0.85730773, 0.85814893, 0.8589878, 0.8598244, 0.8606587, 0.8614907, 0.8623204, 0.8631478, 0.86397284, 0.8647956, 0.865616, 0.86643416, 0.86724997, 0.86806345, 0.8688746, 0.86968344, 0.87048995, 0.87129414, 0.87209594, 0.8728955, 0.87369263, 0.87448746, 0.87527996, 0.8760701, 0.8768579, 0.87764335, 0.87842643, 0.8792072, 0.8799856, 0.8807616, 0.8815353, 0.88230664, 0.8830756, 0.8838422, 0.8846064, 0.8853683, 0.88612777, 0.88688487, 0.88763964, 0.888392, 0.889142, 0.8898896, 0.89063483, 0.8913776, 0.8921181, 0.8928562, 0.8935918, 0.89432514, 0.895056, 0.8957845, 0.8965106, 0.89723426, 0.8979556, 0.8986745, 0.89939094, 0.900105, 0.9008167, 0.9015259, 0.90223277, 0.9029372, 0.9036392, 0.9043388, 0.905036, 0.90573066, 0.90642303, 0.9071129, 0.9078004, 0.9084854, 0.909168, 0.90984815, 0.91052586, 0.9112012, 0.911874, 0.9125444, 0.9132124, 0.9138779, 0.914541, 0.9152016, 0.9158598, 0.9165155, 0.9171688, 0.9178196, 0.91846794, 0.9191139, 0.9197573, 0.92039824, 0.9210368, 0.9216728, 0.9223064, 0.9229375, 0.92356616, 0.9241923, 0.924816, 0.9254372, 0.92605597, 0.9266722, 0.92728597, 0.9278973, 0.9285061, 0.9291124, 0.9297162, 0.9303176, 0.9309164, 0.93151283, 0.9321067, 0.9326981, 0.9332869, 0.9338733, 0.9344572, 0.93503857, 0.93561745, 0.9361938, 0.93676764, 0.937339, 0.9379079, 0.9384742, 0.939038, 0.93959934, 0.9401581, 0.94071436, 0.94126815, 0.94181937, 0.9423681, 0.94291425, 0.94345796, 0.94399905, 0.9445377, 0.9450738, 0.9456073, 0.9461383, 0.94666684, 0.9471928, 0.94771624, 0.94823706, 0.94875544, 0.94927126, 0.9497845, 0.9502952, 0.9508034, 0.951309, 0.9518121, 0.95231265, 0.9528106, 0.953306, 0.95379895, 0.95428926, 0.954777, 0.95526224, 0.95574486, 0.956225, 0.95670253, 0.9571775, 0.95764995, 0.95811975, 0.95858705, 0.9590518, 0.9595139, 0.9599735, 0.9604305, 0.960885, 0.96133685, 0.96178615, 0.9622328, 0.962677, 0.96311855, 0.96355754, 0.96399397, 0.96442777, 0.964859, 0.9652877, 0.96571374, 0.96613723, 0.96655816, 0.96697646, 0.9673922, 0.9678053, 0.9682159, 0.9686238, 0.9690292, 0.969432, 0.9698321, 0.97022974, 0.9706247, 0.97101706, 0.9714069, 0.971794, 0.9721786, 0.9725606, 0.97293997, 0.9733167, 0.97369087, 0.97406244, 0.9744314, 0.9747977, 0.97516143, 0.9755226, 0.97588104, 0.97623694, 0.9765902, 0.9769409, 0.97728896, 0.9776344, 0.97797716, 0.9783174, 0.9786549, 0.9789899, 0.97932225, 0.9796519, 0.97997904, 0.9803035, 0.98062533, 0.9809446, 0.98126113, 0.98157513, 0.98188645, 0.98219514, 0.9825012, 0.98280466, 0.9831055, 0.9834037, 0.9836992, 0.98399216, 0.98428243, 0.9845701, 0.98485506, 0.98513746, 0.9854172, 0.9856943, 0.9859687, 0.98624057, 0.98650974, 0.9867763, 0.98704016, 0.9873014, 0.98756003, 0.987816, 0.9880693, 0.98832, 0.988568, 0.9888134, 0.9890561, 0.9892962, 0.98953366, 0.98976845, 0.9900006, 0.9902301, 0.99045694, 0.9906811, 0.99090266, 0.99112153, 0.9913377, 0.99155134, 0.9917622, 0.9919705, 0.9921761, 0.99237907, 0.99257934, 0.992777, 0.99297196, 0.9931643, 0.99335396, 0.99354094, 0.9937253, 0.993907, 0.99408597, 0.99426234, 0.994436, 0.9946071, 0.9947755, 0.9949412, 0.9951042, 0.9952646, 0.9954223, 0.99557734, 0.99572974, 0.9958795, 0.9960265, 0.9961709, 0.9963126, 0.9964517, 0.99658805, 0.99672174, 0.9968528, 0.9969812, 0.9971069, 0.99722993, 0.99735034, 0.997468, 0.99758303, 0.9976954, 0.99780506, 0.9979121, 0.9980164, 0.9981181, 0.9982171, 0.9983134, 0.99840707, 0.9984981, 0.99858636, 0.998672, 0.998755, 0.99883527, 0.9989129, 0.9989878, 0.9990601, 0.99912965, 0.9991966, 0.99926084, 0.99932235, 0.99938124, 0.9994375, 0.99949104, 0.9995419, 0.99959004, 0.9996356, 0.99967843, 0.99971855, 0.99975604, 0.99979085, 0.999823, 0.9998524, 0.9998792, 0.99990326, 0.9999247, 0.99994344, 0.9999595, 0.9999729, 0.9999836, 0.99999166, 0.99999696, 0.99999964]);
    constructor.SINE_120 = new Float32Array([0.006544938, 0.019633692, 0.032719083, 0.045798868, 0.058870804, 0.07193265, 0.08498218, 0.09801714, 0.11103531, 0.12403445, 0.13701235, 0.14996676, 0.16289547, 0.17579629, 0.18866697, 0.20150532, 0.21430916, 0.22707626, 0.23980446, 0.25249156, 0.26513544, 0.27773383, 0.29028466, 0.30278578, 0.315235, 0.3276302, 0.33996925, 0.35225004, 0.3644705, 0.3766285, 0.38872197, 0.40074882, 0.41270703, 0.42459452, 0.43640924, 0.4481492, 0.45981237, 0.47139674, 0.48290035, 0.4943212, 0.5056574, 0.5169069, 0.5280678, 0.5391383, 0.5501164, 0.5610002, 0.57178795, 0.5824777, 0.59306765, 0.6035559, 0.61394083, 0.62422055, 0.6343933, 0.64445734, 0.65441096, 0.66425246, 0.6739801, 0.6835923, 0.69308734, 0.7024637, 0.71171963, 0.72085357, 0.72986406, 0.7387495, 0.74750835, 0.7561391, 0.7646403, 0.77301043, 0.78124815, 0.78935206, 0.79732066, 0.80515265, 0.81284666, 0.82040143, 0.82781565, 0.83508795, 0.8422172, 0.84920216, 0.8560416, 0.8627344, 0.8692793, 0.8756753, 0.8819213, 0.8880161, 0.8939588, 0.89974827, 0.90538365, 0.9108638, 0.91618794, 0.9213551, 0.92636436, 0.9312149, 0.93590593, 0.94043654, 0.94480604, 0.94901365, 0.95305866, 0.95694035, 0.9606581, 0.96421117, 0.9675991, 0.9708212, 0.97387695, 0.9767659, 0.9794874, 0.9820411, 0.98442656, 0.9866433, 0.98869103, 0.99056935, 0.9922779, 0.99381644, 0.9951847, 0.9963825, 0.99740946, 0.9982656, 0.99895066, 0.9994646, 0.99980724, 0.9999786]);
}, {SINE_1024: "Float32Array", SINE_128: "Float32Array", SINE_960: "Float32Array", SINE_120: "Float32Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 * 
 *  @author in-somnia
 */
var KBDWindows = function() {};
KBDWindows = stjs.extend(KBDWindows, null, [], function(constructor, prototype) {
    constructor.KBD_1024 = new Float32Array([2.9256154E-4, 4.2998567E-4, 5.467407E-4, 6.5482303E-4, 7.5870194E-4, 8.6059334E-4, 9.617754E-4, 0.001063061, 0.0011650036, 0.0012680013, 0.0013723518, 0.0014782865, 0.0015859902, 0.0016956148, 0.0018072877, 0.0019211179, 0.0020372008, 0.0021556206, 0.0022764534, 0.0023997684, 0.002525629, 0.002654095, 0.0027852214, 0.0029190616, 0.0030556656, 0.0031950814, 0.0033373553, 0.0034825325, 0.0036306567, 0.0037817704, 0.003935915, 0.004093132, 0.004253461, 0.004416942, 0.004583614, 0.004753516, 0.0049266857, 0.0051031616, 0.0052829813, 0.005466182, 0.0056528007, 0.005842875, 0.0060364413, 0.006233536, 0.0064341966, 0.006638458, 0.0068463576, 0.0070579313, 0.0072732153, 0.007492245, 0.007715057, 0.0079416875, 0.008172171, 0.008406544, 0.008644843, 0.008887102, 0.009133358, 0.009383645, 0.009638, 0.009896458, 0.010159055, 0.010425826, 0.010696805, 0.010972029, 0.0112515325, 0.011535351, 0.011823521, 0.012116075, 0.01241305, 0.01271448, 0.013020401, 0.013330848, 0.013645855, 0.013965457, 0.014289689, 0.014618587, 0.014952184, 0.015290515, 0.015633615, 0.015981518, 0.01633426, 0.016691875, 0.017054394, 0.017421857, 0.017794292, 0.018171739, 0.018554227, 0.018941795, 0.019334473, 0.019732295, 0.020135297, 0.02054351, 0.020956969, 0.021375706, 0.021799758, 0.022229154, 0.02266393, 0.023104116, 0.023549749, 0.024000859, 0.024457477, 0.02491964, 0.025387377, 0.025860721, 0.026339704, 0.02682436, 0.027314719, 0.027810814, 0.028312674, 0.028820332, 0.02933382, 0.02985317, 0.03037841, 0.030909576, 0.03144669, 0.03198979, 0.032538906, 0.033094067, 0.0336553, 0.034222636, 0.03479611, 0.035375744, 0.035961572, 0.03655362, 0.03715192, 0.037756503, 0.03836739, 0.038984615, 0.039608207, 0.04023819, 0.040874593, 0.04151744, 0.042166766, 0.042822596, 0.043484952, 0.044153865, 0.044829357, 0.04551146, 0.0462002, 0.046895597, 0.04759768, 0.048306476, 0.049022008, 0.049744297, 0.050473373, 0.05120926, 0.05195198, 0.052701555, 0.05345801, 0.05422137, 0.05499166, 0.055768896, 0.056553107, 0.05734431, 0.058142528, 0.058947787, 0.0597601, 0.060579497, 0.061405994, 0.062239613, 0.06308037, 0.06392829, 0.064783394, 0.065645695, 0.066515215, 0.06739197, 0.06827598, 0.06916727, 0.07006585, 0.070971735, 0.071884945, 0.0728055, 0.07373342, 0.074668705, 0.07561139, 0.07656147, 0.077518985, 0.07848393, 0.07945632, 0.080436185, 0.08142353, 0.08241835, 0.083420694, 0.084430546, 0.08544793, 0.086472854, 0.08750533, 0.088545375, 0.08959299, 0.0906482, 0.091711, 0.0927814, 0.09385943, 0.09494507, 0.09603836, 0.09713928, 0.09824785, 0.09936407, 0.10048797, 0.101619534, 0.10275877, 0.10390569, 0.10506031, 0.106222615, 0.10739262, 0.10857033, 0.10975575, 0.110948876, 0.112149715, 0.113358274, 0.11457455, 0.115798555, 0.11703028, 0.11826973, 0.119516894, 0.120771796, 0.12203442, 0.12330477, 0.12458284, 0.12586865, 0.12716216, 0.1284634, 0.12977235, 0.13108903, 0.1324134, 0.13374549, 0.13508528, 0.13643277, 0.13778795, 0.13915081, 0.14052136, 0.14189959, 0.14328548, 0.14467904, 0.14608026, 0.1474891, 0.14890559, 0.15032972, 0.15176146, 0.1532008, 0.15464775, 0.15610228, 0.1575644, 0.15903409, 0.16051131, 0.1619961, 0.1634884, 0.16498822, 0.16649553, 0.16801035, 0.16953263, 0.17106237, 0.17259955, 0.17414416, 0.17569618, 0.1772556, 0.17882238, 0.18039654, 0.18197803, 0.18356684, 0.18516295, 0.18676636, 0.18837702, 0.18999492, 0.19162005, 0.19325238, 0.1948919, 0.19653857, 0.19819237, 0.1998533, 0.2015213, 0.20319638, 0.2048785, 0.20656763, 0.20826375, 0.20996685, 0.21167688, 0.21339384, 0.21511766, 0.21684836, 0.2185859, 0.22033022, 0.22208133, 0.2238392, 0.22560377, 0.22737503, 0.22915295, 0.2309375, 0.23272865, 0.23452635, 0.2363306, 0.23814134, 0.23995855, 0.2417822, 0.24361224, 0.24544866, 0.24729142, 0.24914046, 0.25099578, 0.2528573, 0.25472504, 0.25659892, 0.25847894, 0.26036504, 0.26225716, 0.2641553, 0.2660594, 0.26796943, 0.26988536, 0.27180713, 0.27373472, 0.27566808, 0.27760717, 0.27955195, 0.28150237, 0.2834584, 0.28542, 0.28738713, 0.28935972, 0.29133776, 0.29332116, 0.29530993, 0.297304, 0.29930335, 0.3013079, 0.3033176, 0.30533245, 0.30735236, 0.3093773, 0.31140724, 0.3134421, 0.31548184, 0.31752646, 0.31957585, 0.32162997, 0.3236888, 0.3257523, 0.32782036, 0.32989296, 0.3319701, 0.33405167, 0.33613762, 0.33822796, 0.34032255, 0.3424214, 0.34452447, 0.34663165, 0.34874293, 0.35085824, 0.3529775, 0.35510075, 0.35722783, 0.35935876, 0.36149344, 0.36363184, 0.3657739, 0.36791956, 0.3700688, 0.37222147, 0.37437764, 0.37653714, 0.37870002, 0.38086614, 0.38303548, 0.38520798, 0.38738358, 0.38956222, 0.39174384, 0.39392838, 0.3961158, 0.39830604, 0.40049905, 0.40269473, 0.40489307, 0.40709397, 0.40929738, 0.4115033, 0.41371155, 0.4159222, 0.4181351, 0.42035022, 0.42256752, 0.42478693, 0.42700836, 0.42923176, 0.4314571, 0.43368432, 0.43591332, 0.43814406, 0.44037646, 0.4426105, 0.44484606, 0.44708315, 0.44932166, 0.45156154, 0.4538027, 0.45604512, 0.45828876, 0.46053347, 0.46277925, 0.46502605, 0.46727377, 0.46952236, 0.47177178, 0.4740219, 0.47627273, 0.4785242, 0.4807762, 0.4830287, 0.48528165, 0.48753494, 0.48978856, 0.49204242, 0.49429646, 0.49655062, 0.49880484, 0.501059, 0.5033131, 0.50556713, 0.50782096, 0.5100745, 0.5123277, 0.5145805, 0.5168329, 0.51908475, 0.521336, 0.52358663, 0.5258366, 0.52808577, 0.5303341, 0.53258157, 0.53482807, 0.5370735, 0.5393179, 0.5415612, 0.5438032, 0.546044, 0.54828346, 0.55052155, 0.55275816, 0.5549932, 0.5572267, 0.5594586, 0.5616888, 0.5639172, 0.56614375, 0.5683685, 0.5705912, 0.57281196, 0.5750306, 0.57724714, 0.57946146, 0.58167356, 0.58388335, 0.58609074, 0.5882957, 0.59049815, 0.59269804, 0.59489536, 0.59708995, 0.59928185, 0.60147095, 0.6036572, 0.6058405, 0.60802084, 0.6101982, 0.6123724, 0.6145435, 0.6167114, 0.61887604, 0.62103736, 0.6231953, 0.6253498, 0.62750083, 0.62964827, 0.6317921, 0.63393235, 0.6360689, 0.6382016, 0.6403305, 0.6424555, 0.6445766, 0.6466937, 0.64880675, 0.65091574, 0.6530205, 0.65512115, 0.65721744, 0.6593095, 0.66139716, 0.6634804, 0.66555923, 0.6676335, 0.6697032, 0.67176825, 0.67382866, 0.6758843, 0.67793524, 0.6799813, 0.6820225, 0.6840588, 0.6860901, 0.6881164, 0.6901376, 0.69215375, 0.6941647, 0.69617045, 0.6981709, 0.7001661, 0.7021559, 0.70414037, 0.70611936, 0.70809287, 0.71006083, 0.7120232, 0.71398, 0.7159311, 0.71787655, 0.7198162, 0.7217501, 0.7236782, 0.7256003, 0.7275166, 0.72942686, 0.73133117, 0.73322946, 0.73512167, 0.73700774, 0.73888767, 0.7407614, 0.7426289, 0.74449015, 0.74634504, 0.7481936, 0.7500359, 0.75187165, 0.75370103, 0.75552386, 0.7573402, 0.75915, 0.7609532, 0.7627498, 0.7645397, 0.766323, 0.7680995, 0.76986927, 0.7716323, 0.7733885, 0.77513784, 0.7768803, 0.7786159, 0.78034455, 0.7820663, 0.783781, 0.78548867, 0.7871893, 0.7888829, 0.7905694, 0.79224885, 0.79392105, 0.7955861, 0.797244, 0.7988947, 0.8005381, 0.80217427, 0.80380315, 0.80542475, 0.807039, 0.8086459, 0.81024545, 0.8118376, 0.8134223, 0.81499964, 0.8165695, 0.8181319, 0.81968683, 0.8212342, 0.8227741, 0.8243065, 0.82583135, 0.8273486, 0.82885826, 0.83036035, 0.8318549, 0.8333417, 0.834821, 0.83629256, 0.8377565, 0.8392128, 0.84066135, 0.8421022, 0.8435354, 0.8449609, 0.8463787, 0.84778875, 0.84919107, 0.85058564, 0.85197246, 0.8533515, 0.8547228, 0.8560863, 0.8574421, 0.85879004, 0.86013025, 0.86146265, 0.86278725, 0.8641041, 0.8654131, 0.86671436, 0.8680078, 0.8692934, 0.8705712, 0.87184125, 0.87310344, 0.8743579, 0.8756045, 0.87684333, 0.87807435, 0.8792976, 0.8805131, 0.8817207, 0.88292056, 0.88411266, 0.885297, 0.88647354, 0.8876423, 0.88880336, 0.88995665, 0.8911022, 0.89224, 0.89337003, 0.8944924, 0.89560705, 0.896714, 0.8978132, 0.8989048, 0.89998865, 0.9010649, 0.90213346, 0.90319437, 0.9042477, 0.90529335, 0.9063314, 0.9073619, 0.90838486, 0.9094002, 0.910408, 0.9114083, 0.912401, 0.9133863, 0.91436404, 0.91533434, 0.9162972, 0.9172526, 0.91820055, 0.9191411, 0.92007434, 0.9210002, 0.92191863, 0.9228298, 0.92373365, 0.92463017, 0.92551947, 0.9264015, 0.9272763, 0.9281439, 0.9290044, 0.9298576, 0.93070376, 0.93154275, 0.93237466, 0.93319947, 0.9340173, 0.93482804, 0.9356318, 0.9364286, 0.9372184, 0.93800133, 0.9387773, 0.93954647, 0.94030875, 0.94106424, 0.9418129, 0.9425548, 0.94328994, 0.94401836, 0.94474006, 0.94545513, 0.9461636, 0.94686544, 0.9475607, 0.9482494, 0.94893163, 0.9496073, 0.95027655, 0.95093936, 0.9515958, 0.95224583, 0.9528895, 0.9535269, 0.954158, 0.95478284, 0.9554015, 0.956014, 0.9566203, 0.95722044, 0.9578145, 0.9584025, 0.95898455, 0.9595605, 0.9601306, 0.9606947, 0.96125287, 0.9618052, 0.96235174, 0.9628925, 0.9634274, 0.96395665, 0.96448016, 0.964998, 0.96551025, 0.9660169, 0.966518, 0.96701354, 0.9675036, 0.9679882, 0.96846735, 0.96894115, 0.9694096, 0.9698727, 0.97033054, 0.9707831, 0.9712305, 0.9716727, 0.97210974, 0.9725417, 0.9729686, 0.9733904, 0.9738073, 0.97421914, 0.97462606, 0.97502816, 0.97542536, 0.97581774, 0.9762053, 0.97658813, 0.97696626, 0.9773397, 0.9777085, 0.9780727, 0.9784323, 0.9787874, 0.979138, 0.97948414, 0.97982585, 0.98016316, 0.9804961, 0.9808247, 0.9811491, 0.98146915, 0.98178506, 0.9820968, 0.98240435, 0.98270786, 0.98300725, 0.9833026, 0.98359394, 0.98388135, 0.98416483, 0.98444444, 0.9847202, 0.9849921, 0.9852602, 0.9855246, 0.98578525, 0.9860422, 0.9862955, 0.98654526, 0.9867914, 0.987034, 0.9872731, 0.9875087, 0.9877409, 0.9879697, 0.98819506, 0.98841715, 0.9886359, 0.9888514, 0.9890637, 0.9892727, 0.98947865, 0.9896814, 0.98988104, 0.9900777, 0.9902712, 0.99046177, 0.99064934, 0.990834, 0.99101573, 0.9911946, 0.9913706, 0.9915438, 0.99171424, 0.99188197, 0.9920469, 0.9922092, 0.9923689, 0.9925259, 0.9926803, 0.9928322, 0.9929815, 0.99312836, 0.9932727, 0.99341464, 0.9935542, 0.9936913, 0.9938261, 0.9939586, 0.99408877, 0.9942167, 0.9943424, 0.9944658, 0.9945872, 0.99470633, 0.99482334, 0.99493825, 0.99505115, 0.99516195, 0.9952708, 0.99537766, 0.9954825, 0.99558544, 0.99568653, 0.99578565, 0.995883, 0.9959785, 0.9960722, 0.996164, 0.9962542, 0.99634266, 0.9964294, 0.99651444, 0.9965978, 0.9966796, 0.9967598, 0.99683833, 0.9969154, 0.99699086, 0.9970649, 0.99713737, 0.9972084, 0.997278, 0.99734616, 0.9974129, 0.9974783, 0.9975424, 0.9976051, 0.9976665, 0.99772656, 0.9977854, 0.99784297, 0.99789935, 0.9979545, 0.99800843, 0.99806124, 0.99811286, 0.9981634, 0.99821275, 0.9982611, 0.9983083, 0.99835443, 0.9983996, 0.9984437, 0.9984868, 0.99852896, 0.9985701, 0.9986103, 0.9986496, 0.9986879, 0.9987254, 0.998762, 0.9987977, 0.9988326, 0.9988666, 0.9988998, 0.9989322, 0.99896383, 0.99899465, 0.99902475, 0.9990541, 0.9990827, 0.9991106, 0.99913776, 0.9991643, 0.9991901, 0.9992153, 0.9992398, 0.9992637, 0.99928695, 0.9993096, 0.9993317, 0.9993532, 0.9993741, 0.9993944, 0.9994142, 0.9994335, 0.99945223, 0.9994705, 0.9994882, 0.99950546, 0.9995222, 0.9995385, 0.9995543, 0.99956965, 0.9995846, 0.9995991, 0.9996132, 0.9996269, 0.99964017, 0.99965304, 0.99966556, 0.9996777, 0.99968946, 0.99970084, 0.99971193, 0.99972266, 0.9997331, 0.99974316, 0.9997529, 0.99976236, 0.99977154, 0.99978036, 0.99978894, 0.9997973, 0.9998053, 0.9998131, 0.9998206, 0.99982786, 0.9998349, 0.9998417, 0.99984825, 0.99985456, 0.9998607, 0.9998666, 0.99987227, 0.9998778, 0.9998831, 0.9998882, 0.9998931, 0.9998979, 0.9999025, 0.9999069, 0.9999111, 0.99991524, 0.9999192, 0.99992293, 0.9999266, 0.9999301, 0.9999335, 0.9999367, 0.9999398, 0.9999428, 0.99994564, 0.9999484, 0.999951, 0.99995357, 0.99995595, 0.9999583, 0.9999605, 0.9999626, 0.99996465, 0.9999666, 0.99996847, 0.99997026, 0.9999719, 0.99997354, 0.9999751, 0.9999766, 0.99997795, 0.9999793, 0.99998057, 0.99998176, 0.99998295, 0.999984, 0.99998504, 0.99998605, 0.999987, 0.99998784, 0.9999887, 0.9999895, 0.9999902, 0.99999094, 0.9999916, 0.99999225, 0.99999285, 0.9999934, 0.9999939, 0.99999446, 0.9999949, 0.99999535, 0.99999577, 0.9999961, 0.9999965, 0.9999968, 0.99999714, 0.99999744, 0.9999977, 0.9999979, 0.99999815, 0.9999984, 0.99999857, 0.99999875, 0.9999989, 0.99999905, 0.9999992, 0.99999934, 0.99999946, 0.9999995, 0.99999964, 0.9999997, 0.99999976, 0.9999998, 0.9999999, 0.99999994]);
    constructor.KBD_128 = new Float32Array([4.3795702E-5, 1.18673845E-4, 2.3071657E-4, 3.894728E-4, 6.058127E-4, 8.9199696E-4, 0.0012617254, 0.0017301724, 0.0023140071, 0.0030313989, 0.003902005, 0.00494694, 0.006188728, 0.007651231, 0.00935956, 0.011339966, 0.013619707, 0.016226895, 0.019190324, 0.022539284, 0.02630334, 0.030512117, 0.03519505, 0.04038113, 0.046098642, 0.05237489, 0.059235904, 0.06670617, 0.074808344, 0.083562955, 0.09298815, 0.10309941, 0.11390932, 0.1254273, 0.13765942, 0.15060817, 0.1642723, 0.17864668, 0.19372223, 0.20948577, 0.22591996, 0.2430034, 0.26071054, 0.27901176, 0.29787362, 0.31725872, 0.33712614, 0.35743153, 0.3781274, 0.39916334, 0.4204864, 0.4420414, 0.46377128, 0.48561758, 0.5075207, 0.52942044, 0.5512564, 0.5729685, 0.5944971, 0.6157838, 0.6367718, 0.65740615, 0.67763436, 0.6974065, 0.7166758, 0.735399, 0.7535364, 0.7710523, 0.78791517, 0.8040978, 0.8195774, 0.83433586, 0.8483596, 0.86163956, 0.8741714, 0.885955, 0.89699465, 0.90729886, 0.91687983, 0.9257536, 0.93393934, 0.9414595, 0.94833905, 0.95460534, 0.9602877, 0.965417, 0.9700254, 0.9741459, 0.9778117, 0.9810564, 0.9839133, 0.986415, 0.9885935, 0.99047965, 0.9921028, 0.9934912, 0.99467105, 0.9956672, 0.9965025, 0.9971979, 0.99777263, 0.998244, 0.9986275, 0.9989369, 0.99918437, 0.99938047, 0.99953437, 0.999654, 0.99974597, 0.9998158, 0.99986833, 0.99990726, 0.9999357, 0.9999562, 0.99997073, 0.99998087, 0.9999878, 0.9999924, 0.9999954, 0.9999973, 0.9999985, 0.9999992, 0.9999996, 0.9999998, 0.99999994, 1.0, 1.0, 1.0]);
    constructor.KBD_960 = new Float32Array([3.0215626E-4, 4.452267E-4, 5.674948E-4, 6.812466E-4, 7.910497E-4, 8.991655E-4, 0.0010068978, 0.0011150759, 0.0012242653, 0.0013348736, 0.0014472068, 0.001561504, 0.0016779569, 0.0017967242, 0.0019179397, 0.0020417196, 0.0021681653, 0.002297368, 0.0024294101, 0.0025643678, 0.002702311, 0.0028433062, 0.0029874153, 0.0031346984, 0.0032852124, 0.0034390124, 0.0035961515, 0.0037566822, 0.0039206543, 0.0040881187, 0.004259123, 0.0044337157, 0.0046119443, 0.004793856, 0.0049794964, 0.0051689115, 0.0053621475, 0.005559249, 0.0057602613, 0.005965229, 0.006174197, 0.006387209, 0.0066043097, 0.006825543, 0.0070509524, 0.007280582, 0.007514476, 0.0077526774, 0.007995229, 0.008242176, 0.00849356, 0.008749426, 0.009009816, 0.009274773, 0.009544341, 0.009818562, 0.01009748, 0.010381138, 0.010669579, 0.010962844, 0.011260978, 0.011564023, 0.0118720215, 0.012185017, 0.01250305, 0.012826165, 0.013154404, 0.01348781, 0.013826424, 0.01417029, 0.014519448, 0.014873942, 0.015233814, 0.015599105, 0.015969856, 0.016346112, 0.016727913, 0.017115299, 0.017508315, 0.017907, 0.018311396, 0.018721545, 0.019137487, 0.019559264, 0.019986916, 0.020420484, 0.02086001, 0.021305535, 0.021757096, 0.022214737, 0.022678494, 0.023148412, 0.023624528, 0.024106883, 0.024595516, 0.025090465, 0.025591772, 0.026099475, 0.026613612, 0.027134223, 0.027661344, 0.028195018, 0.02873528, 0.02928217, 0.029835723, 0.030395979, 0.030962974, 0.031536747, 0.032117333, 0.03270477, 0.033299096, 0.033900343, 0.034508552, 0.035123758, 0.035745993, 0.0363753, 0.0370117, 0.037655246, 0.03830596, 0.03896388, 0.039629042, 0.04030148, 0.040981222, 0.041668307, 0.04236277, 0.043064635, 0.04377394, 0.04449072, 0.045215003, 0.04594682, 0.046686206, 0.04743319, 0.048187803, 0.048950076, 0.049720038, 0.05049772, 0.051283147, 0.052076355, 0.052877367, 0.053686213, 0.054502927, 0.055327527, 0.056160048, 0.057000514, 0.05784895, 0.058705386, 0.059569843, 0.060442355, 0.06132294, 0.062211625, 0.06310843, 0.06401339, 0.06492652, 0.065847844, 0.066777386, 0.067715175, 0.06866122, 0.06961555, 0.070578195, 0.071549155, 0.072528474, 0.07351615, 0.07451222, 0.07551669, 0.07652959, 0.07755093, 0.07858074, 0.07961902, 0.0806658, 0.08172109, 0.082784906, 0.08385727, 0.08493819, 0.08602769, 0.08712578, 0.088232465, 0.089347765, 0.0904717, 0.09160427, 0.0927455, 0.09389539, 0.095053956, 0.09622121, 0.097397156, 0.098581806, 0.09977517, 0.100977264, 0.10218809, 0.103407644, 0.10463595, 0.105873, 0.10711882, 0.1083734, 0.10963675, 0.110908866, 0.11218977, 0.11347944, 0.11477791, 0.11608516, 0.11740119, 0.118726015, 0.120059624, 0.12140203, 0.122753225, 0.12411321, 0.12548198, 0.12685953, 0.12824588, 0.129641, 0.1310449, 0.13245757, 0.133879, 0.13530922, 0.13674818, 0.13819589, 0.13965234, 0.14111754, 0.14259146, 0.14407411, 0.14556547, 0.14706554, 0.14857428, 0.15009172, 0.15161783, 0.15315259, 0.154696, 0.15624805, 0.1578087, 0.15937798, 0.16095585, 0.16254228, 0.16413727, 0.16574082, 0.1673529, 0.16897348, 0.17060255, 0.1722401, 0.17388609, 0.17554054, 0.17720339, 0.17887463, 0.18055424, 0.1822422, 0.18393849, 0.18564309, 0.18735597, 0.18907711, 0.19080646, 0.19254404, 0.19428979, 0.1960437, 0.19780573, 0.19957587, 0.20135407, 0.20314032, 0.20493457, 0.20673682, 0.20854701, 0.21036512, 0.21219113, 0.21402499, 0.21586668, 0.21771616, 0.2195734, 0.22143836, 0.223311, 0.22519132, 0.22707924, 0.22897474, 0.23087779, 0.23278835, 0.23470637, 0.23663183, 0.23856467, 0.24050486, 0.24245237, 0.24440713, 0.24636914, 0.24833833, 0.25031465, 0.2522981, 0.25428858, 0.25628608, 0.25829056, 0.26030195, 0.26232022, 0.26434532, 0.2663772, 0.26841584, 0.27046117, 0.27251315, 0.27457172, 0.2766368, 0.2787084, 0.28078645, 0.28287092, 0.2849617, 0.28705877, 0.2891621, 0.29127163, 0.29338726, 0.295509, 0.29763678, 0.2997705, 0.30191016, 0.3040557, 0.30620703, 0.3083641, 0.31052688, 0.3126953, 0.3148693, 0.31704885, 0.31923383, 0.32142425, 0.32362, 0.32582104, 0.3280273, 0.33023876, 0.3324553, 0.3346769, 0.33690348, 0.339135, 0.34137136, 0.34361252, 0.34585842, 0.348109, 0.3503642, 0.35262394, 0.35488814, 0.35715678, 0.35942975, 0.36170703, 0.36398852, 0.36627415, 0.36856386, 0.3708576, 0.3731553, 0.37545687, 0.3777623, 0.38007143, 0.38238424, 0.3847007, 0.38702068, 0.38934413, 0.39167097, 0.3940012, 0.39633462, 0.39867127, 0.40101105, 0.40335387, 0.40569967, 0.4080484, 0.41039994, 0.41275427, 0.41511127, 0.4174709, 0.4198331, 0.42219776, 0.4245648, 0.4269342, 0.42930585, 0.43167967, 0.43405563, 0.43643358, 0.43881354, 0.44119534, 0.443579, 0.44596437, 0.44835138, 0.45074, 0.45313016, 0.45552173, 0.45791465, 0.46030888, 0.46270433, 0.46510088, 0.46749854, 0.46989715, 0.47229666, 0.47469702, 0.47709814, 0.47949994, 0.48190233, 0.48430526, 0.48670864, 0.4891124, 0.49151644, 0.4939207, 0.49632514, 0.49872962, 0.5011341, 0.5035385, 0.50594276, 0.50834674, 0.5107504, 0.51315373, 0.5155565, 0.5179588, 0.52036047, 0.52276146, 0.5251616, 0.52756095, 0.5299594, 0.5323568, 0.53475314, 0.5371483, 0.53954226, 0.5419349, 0.5443261, 0.546716, 0.5491042, 0.55149084, 0.55387586, 0.55625904, 0.5586404, 0.5610199, 0.56339735, 0.5657728, 0.56814605, 0.5705171, 0.5728859, 0.5752523, 0.57761633, 0.5799778, 0.5823367, 0.58469296, 0.58704644, 0.5893972, 0.591745, 0.5940899, 0.59643185, 0.5987706, 0.6011062, 0.6034386, 0.6057677, 0.60809344, 0.6104157, 0.61273444, 0.6150496, 0.6173611, 0.6196689, 0.62197286, 0.62427294, 0.6265691, 0.62886125, 0.63114935, 0.6334333, 0.63571304, 0.63798845, 0.64025956, 0.64252627, 0.6447885, 0.64704615, 0.6492992, 0.65154755, 0.6537912, 0.65603006, 0.65826404, 0.660493, 0.66271704, 0.664936, 0.6671499, 0.66935855, 0.67156196, 0.67376006, 0.67595273, 0.67814004, 0.6803218, 0.6824981, 0.6846687, 0.6868337, 0.68899286, 0.6911463, 0.6932939, 0.6954356, 0.69757134, 0.699701, 0.70182467, 0.7039421, 0.70605344, 0.70815855, 0.7102573, 0.7123498, 0.71443576, 0.71651536, 0.7185884, 0.72065496, 0.72271484, 0.7247681, 0.7268146, 0.7288544, 0.7308874, 0.7329135, 0.7349327, 0.736945, 0.7389502, 0.74094844, 0.74293953, 0.74492353, 0.7469003, 0.7488699, 0.75083214, 0.7527872, 0.75473475, 0.756675, 0.75860775, 0.7605331, 0.7624508, 0.7643611, 0.76626366, 0.7681586, 0.77004594, 0.7719255, 0.7737973, 0.77566135, 0.7775175, 0.77936584, 0.7812063, 0.7830388, 0.78486335, 0.78667986, 0.7884884, 0.79028887, 0.79208124, 0.79386544, 0.79564154, 0.7974094, 0.7991691, 0.80092055, 0.80266374, 0.8043986, 0.80612516, 0.8078434, 0.80955327, 0.8112547, 0.8129477, 0.8146323, 0.8163084, 0.817976, 0.81963515, 0.8212857, 0.8229278, 0.8245612, 0.82618606, 0.8278023, 0.82940996, 0.831009, 0.8325993, 0.83418095, 0.8357539, 0.8373181, 0.8388737, 0.8404205, 0.8419585, 0.8434878, 0.8450083, 0.84652007, 0.848023, 0.84951717, 0.8510025, 0.85247904, 0.8539467, 0.85540557, 0.8568556, 0.85829675, 0.85972905, 0.86115247, 0.86256707, 0.8639728, 0.8653696, 0.86675763, 0.8681367, 0.86950696, 0.87086827, 0.87222075, 0.87356436, 0.8748991, 0.87622494, 0.8775419, 0.87885004, 0.88014925, 0.8814396, 0.8827212, 0.88399386, 0.88525766, 0.8865127, 0.88775885, 0.8889962, 0.8902247, 0.8914444, 0.89265525, 0.89385736, 0.8950507, 0.8962353, 0.8974111, 0.89857817, 0.89973646, 0.90088606, 0.90202695, 0.9031592, 0.9042827, 0.90539753, 0.90650374, 0.90760136, 0.9086903, 0.90977067, 0.9108424, 0.91190565, 0.9129603, 0.9140064, 0.91504407, 0.9160732, 0.9170939, 0.91810614, 0.91910994, 0.92010534, 0.9210924, 0.92207104, 0.9230414, 0.9240034, 0.92495716, 0.9259026, 0.9268399, 0.9277689, 0.9286897, 0.92960244, 0.930507, 0.93140346, 0.9322918, 0.93317217, 0.9340444, 0.93490875, 0.93576515, 0.93661356, 0.93745404, 0.9382867, 0.93911153, 0.93992853, 0.9407377, 0.94153917, 0.9423329, 0.943119, 0.9438974, 0.94466823, 0.9454315, 0.94618714, 0.9469353, 0.947676, 0.9484092, 0.94913507, 0.9498535, 0.9505646, 0.95126843, 0.951965, 0.95265424, 0.95333636, 0.9540113, 0.9546792, 0.95533997, 0.95599365, 0.9566404, 0.95728016, 0.957913, 0.9585389, 0.959158, 0.95977026, 0.9603758, 0.9609746, 0.9615666, 0.96215206, 0.9627309, 0.96330315, 0.96386886, 0.96442807, 0.9649809, 0.96552724, 0.96606725, 0.96660095, 0.9671284, 0.9676496, 0.96816456, 0.96867335, 0.96917605, 0.9696727, 0.9701633, 0.97064793, 0.9711266, 0.9715994, 0.97206634, 0.97252744, 0.97298276, 0.97343236, 0.9738763, 0.9743146, 0.97474724, 0.97517437, 0.975596, 0.9760121, 0.97642285, 0.97682816, 0.97722816, 0.97762287, 0.9780123, 0.9783966, 0.9787757, 0.97914964, 0.97951853, 0.97988236, 0.98024124, 0.9805952, 0.98094416, 0.9812883, 0.9816277, 0.98196226, 0.98229206, 0.98261726, 0.98293775, 0.98325366, 0.98356503, 0.9838719, 0.98417425, 0.9844722, 0.98476577, 0.98505497, 0.98533994, 0.9856206, 0.98589706, 0.98616934, 0.9864375, 0.9867016, 0.9869616, 0.98721766, 0.9874697, 0.98771787, 0.9879621, 0.9882026, 0.9884392, 0.9886721, 0.98890126, 0.98912674, 0.98934865, 0.9895669, 0.9897816, 0.98999286, 0.9902006, 0.9904049, 0.99060583, 0.9908034, 0.9909977, 0.9911887, 0.99137646, 0.991561, 0.99174243, 0.9919207, 0.9920959, 0.9922681, 0.99243724, 0.9926034, 0.9927667, 0.9929271, 0.99308455, 0.9932393, 0.99339116, 0.99354035, 0.9936868, 0.99383056, 0.9939717, 0.9941103, 0.99424624, 0.99437964, 0.9945106, 0.99463904, 0.9947651, 0.9948887, 0.99501, 0.9951289, 0.9952456, 0.99535996, 0.99547213, 0.99558204, 0.99568987, 0.9957955, 0.995899, 0.99600047, 0.9960999, 0.99619734, 0.99629277, 0.99638623, 0.9964778, 0.9965674, 0.9966552, 0.9967412, 0.99682534, 0.9969078, 0.9969884, 0.99706733, 0.9971445, 0.9972201, 0.997294, 0.99736637, 0.99743706, 0.99750626, 0.9975739, 0.99764, 0.9977047, 0.9977679, 0.9978297, 0.99789006, 0.99794906, 0.9980067, 0.99806297, 0.998118, 0.9981717, 0.99822414, 0.99827534, 0.99832535, 0.99837416, 0.9984218, 0.9984683, 0.99851364, 0.99855787, 0.998601, 0.9986431, 0.99868417, 0.99872416, 0.9987632, 0.99880123, 0.9988383, 0.9988744, 0.9989096, 0.99894387, 0.9989773, 0.9990098, 0.99904144, 0.9990723, 0.9991023, 0.9991315, 0.99915993, 0.9991876, 0.9992145, 0.99924064, 0.999266, 0.99929076, 0.99931484, 0.9993382, 0.9993609, 0.999383, 0.99940443, 0.99942523, 0.99944544, 0.99946505, 0.9994841, 0.9995026, 0.99952054, 0.99953794, 0.9995548, 0.9995712, 0.99958706, 0.99960244, 0.99961734, 0.9996318, 0.99964577, 0.99965936, 0.9996725, 0.99968517, 0.9996975, 0.99970937, 0.99972093, 0.999732, 0.9997428, 0.99975324, 0.9997633, 0.999773, 0.9997824, 0.9997915, 0.99980026, 0.9998087, 0.99981683, 0.99982476, 0.99983233, 0.99983966, 0.9998467, 0.99985355, 0.9998601, 0.99986637, 0.99987245, 0.99987835, 0.99988395, 0.9998894, 0.99989456, 0.9998996, 0.9999044, 0.99990904, 0.99991345, 0.99991775, 0.99992186, 0.99992573, 0.99992955, 0.9999331, 0.9999366, 0.9999399, 0.9999431, 0.9999461, 0.99994904, 0.9999518, 0.99995446, 0.99995697, 0.9999594, 0.99996173, 0.99996394, 0.999966, 0.99996805, 0.99996996, 0.99997175, 0.9999735, 0.99997514, 0.9999767, 0.9999782, 0.9999796, 0.9999809, 0.9999822, 0.99998343, 0.99998456, 0.99998564, 0.99998665, 0.9999876, 0.9999885, 0.9999894, 0.99999017, 0.99999094, 0.99999166, 0.9999923, 0.99999297, 0.99999356, 0.9999941, 0.9999946, 0.9999951, 0.9999955, 0.99999595, 0.99999636, 0.9999967, 0.999997, 0.9999974, 0.9999977, 0.9999979, 0.99999815, 0.9999984, 0.99999857, 0.9999988, 0.9999989, 0.9999991, 0.9999992, 0.9999994, 0.99999946, 0.9999996, 0.9999997, 0.99999976, 0.9999998, 0.9999999, 0.99999994]);
    constructor.KBD_120 = new Float32Array([4.523201E-5, 1.2745647E-4, 2.5293985E-4, 4.3351404E-4, 6.827101E-4, 0.0010158708, 0.0014502163, 0.0020048865, 0.002700962, 0.003561459, 0.0046113017, 0.005877263, 0.0073878774, 0.009173328, 0.0112652965, 0.013696786, 0.016501913, 0.019715669, 0.023373658, 0.0275118, 0.03216601, 0.037371866, 0.043164253, 0.04957698, 0.05664239, 0.06439101, 0.072851084, 0.082048275, 0.09200519, 0.102741085, 0.114271455, 0.12660775, 0.13975702, 0.15372172, 0.1684994, 0.18408258, 0.20045857, 0.21760936, 0.23551162, 0.25413665, 0.27345052, 0.29341415, 0.3139834, 0.3351095, 0.35673913, 0.37881488, 0.40127558, 0.42405677, 0.44709122, 0.47030926, 0.4936395, 0.5170094, 0.54034567, 0.5635751, 0.586625, 0.60942394, 0.6319022, 0.65399253, 0.6756304, 0.696755, 0.71730924, 0.7372405, 0.756501, 0.77504814, 0.79284453, 0.8098587, 0.8260648, 0.8414431, 0.85597974, 0.86966664, 0.88250166, 0.8944884, 0.9056356, 0.9159574, 0.9254725, 0.93420404, 0.9421792, 0.94942844, 0.9559854, 0.96188605, 0.96716833, 0.97187155, 0.97603595, 0.9797022, 0.98291075, 0.98570174, 0.9881142, 0.99018586, 0.99195284, 0.99344957, 0.9947081, 0.99575853, 0.99662834, 0.9973428, 0.99792475, 0.99839455, 0.9987703, 0.99906796, 0.99930143, 0.9994825, 0.99962145, 0.9997268, 0.9998056, 0.99986386, 0.9999062, 0.9999365, 0.9999579, 0.9999727, 0.9999827, 0.9999894, 0.9999937, 0.99999636, 0.999998, 0.9999989, 0.99999946, 0.99999976, 0.9999999, 0.99999994, 1.0, 1.0]);
}, {KBD_1024: "Float32Array", KBD_128: "Float32Array", KBD_960: "Float32Array", KBD_120: "Float32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Context model for table-based binary arithmetic encoders/decoders
 *  
 *  Stores probability state table index and current MPS symbol value
 *  
 *  @author The JCodec project
 *  
 */
var Context = function(state, mps) {
    this.stateIdx = state;
    this.mps = mps;
};
Context = stjs.extend(Context, null, [], function(constructor, prototype) {
    prototype.stateIdx = 0;
    prototype.mps = 0;
    prototype.getState = function() {
        return this.stateIdx;
    };
    prototype.getMps = function() {
        return this.mps;
    };
    prototype.setMps = function(mps) {
        this.mps = mps;
    };
    prototype.setState = function(state) {
        this.stateIdx = state;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Constants shared by both MQ encoder and decoder
 *  
 *  @author The JCodec project
 *  
 */
var MQConst = function() {};
MQConst = stjs.extend(MQConst, null, [], function(constructor, prototype) {
    constructor.pLps = new Int32Array([22017, 13313, 6145, 2753, 1313, 545, 22017, 21505, 18433, 14337, 12289, 9217, 7169, 5633, 22017, 21505, 20737, 18433, 14337, 13313, 12289, 10241, 9217, 8705, 7169, 6145, 5633, 5121, 4609, 4353, 2753, 2497, 2209, 1313, 1089, 673, 545, 321, 273, 133, 73, 37, 21, 9, 5, 1, 22017]);
    constructor.mpsSwitch = new Int32Array([1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    constructor.transitLPS = new Int32Array([1, 6, 9, 12, 29, 33, 6, 14, 14, 14, 17, 18, 20, 21, 14, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 46]);
    constructor.transitMPS = new Int32Array([1, 2, 3, 4, 5, 38, 7, 8, 9, 10, 11, 12, 13, 29, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 45, 46]);
}, {pLps: "Int32Array", mpsSwitch: "Int32Array", transitLPS: "Int32Array", transitMPS: "Int32Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  Different AAC profiles.
 *  The function <code>Decoder.canDecode</code> specifies if the decoder can
 *  handle a given format.
 *  More precisely, the ISO standard calls these 'object types'.
 *  @author in-somnia
 */
var Profile = function(num, descr, supported) {
    this.num = num;
    this.descr = descr;
    this.supported = supported;
};
Profile = stjs.extend(Profile, null, [], function(constructor, prototype) {
    constructor.UNKNOWN = new Profile(-1, "unknown", false);
    constructor.AAC_MAIN = new Profile(1, "AAC Main Profile", true);
    constructor.AAC_LC = new Profile(2, "AAC Low Complexity", true);
    constructor.AAC_SSR = new Profile(3, "AAC Scalable Sample Rate", false);
    constructor.AAC_LTP = new Profile(4, "AAC Long Term Prediction", false);
    constructor.AAC_SBR = new Profile(5, "AAC SBR", true);
    constructor.AAC_SCALABLE = new Profile(6, "Scalable AAC", false);
    constructor.TWIN_VQ = new Profile(7, "TwinVQ", false);
    constructor.AAC_LD = new Profile(11, "AAC Low Delay", false);
    constructor.ER_AAC_LC = new Profile(17, "Error Resilient AAC Low Complexity", true);
    constructor.ER_AAC_SSR = new Profile(18, "Error Resilient AAC SSR", false);
    constructor.ER_AAC_LTP = new Profile(19, "Error Resilient AAC Long Term Prediction", false);
    constructor.ER_AAC_SCALABLE = new Profile(20, "Error Resilient Scalable AAC", false);
    constructor.ER_TWIN_VQ = new Profile(21, "Error Resilient TwinVQ", false);
    constructor.ER_BSAC = new Profile(22, "Error Resilient BSAC", false);
    constructor.ER_AAC_LD = new Profile(23, "Error Resilient AAC Low Delay", false);
    constructor.ALL = [Profile.AAC_MAIN, Profile.AAC_LC, Profile.AAC_SSR, Profile.AAC_LTP, Profile.AAC_SBR, Profile.AAC_SCALABLE, Profile.TWIN_VQ, null, null, null, Profile.AAC_LD, null, null, null, null, null, Profile.ER_AAC_LC, Profile.ER_AAC_SSR, Profile.ER_AAC_LTP, Profile.ER_AAC_SCALABLE, Profile.ER_TWIN_VQ, Profile.ER_BSAC, Profile.ER_AAC_LD];
    /**
     *  Returns a profile instance for the given index. If the index is not
     *  between 1 and 23 inclusive, UNKNOWN is returned.
     *  @return a profile with the given index
     */
    constructor.forInt = function(i) {
        var p;
        if (i <= 0 || i > Profile.ALL.length) 
            p = Profile.UNKNOWN;
         else 
            p = Profile.ALL[i - 1];
        return p;
    };
    prototype.num = 0;
    prototype.descr = null;
    prototype.supported = false;
    /**
     *  Returns this profile's index between 1 and 23 or -1 if this is the
     *  <code>UNKNOWN</code> instance.
     *  @return the profile's index
     */
    prototype.getIndex = function() {
        return this.num;
    };
    /**
     *  Returns a short description of this profile.
     *  @return the profile's description
     */
    prototype.getDescription = function() {
        return this.descr;
    };
    /**
     *  Returns a string representation of this profile. The method is
     *  identical to <code>getDescription()</code>.
     *  @return the profile's description
     */
    prototype.toString = function() {
        return this.descr;
    };
    /**
     *  Returns a boolean, indicating if this profile can be decoded by the
     *  <code>Decoder</code>.
     *  @see Decoder#canDecode(net.sourceforge.jaad.aac.Profile) 
     *  @return true if the profile is supported
     */
    prototype.isDecodingSupported = function() {
        return this.supported;
    };
    /**
     *  Returns a boolean, indicating if this profile contains error resilient
     *  tools. That is, if it's index is higher than 16, since the first error
     *  resilient profile is ER_AAC_LC (17).
     *  This method is mainly used internally.
     *  @return true if the profile uses error resilience
     */
    prototype.isErrorResilientProfile = function() {
        return this.num > 16;
    };
}, {UNKNOWN: "Profile", AAC_MAIN: "Profile", AAC_LC: "Profile", AAC_SSR: "Profile", AAC_LTP: "Profile", AAC_SBR: "Profile", AAC_SCALABLE: "Profile", TWIN_VQ: "Profile", AAC_LD: "Profile", ER_AAC_LC: "Profile", ER_AAC_SSR: "Profile", ER_AAC_LTP: "Profile", ER_AAC_SCALABLE: "Profile", ER_TWIN_VQ: "Profile", ER_BSAC: "Profile", ER_AAC_LD: "Profile", ALL: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed under FreeBSD License
 *  
 *  AAC block types
 *  
 *  @author The JCodec project
 *  
 */
var BlockType = stjs.enumeration("TYPE_SCE", "TYPE_CPE", "TYPE_CCE", "TYPE_LFE", "TYPE_DSE", "TYPE_PCE", "TYPE_FIL", "TYPE_END");
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var AudioSink = function() {};
AudioSink = stjs.extend(AudioSink, null, [], function(constructor, prototype) {
    prototype.writeFloat = function(buffer) {};
}, {}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  The SampleBuffer holds the decoded AAC frame. It contains the raw PCM data
 *  and its format.
 *  @author in-somnia
 */
var SampleBuffer = function() {
    this.data = new Int8Array(0);
    this.sampleRate = 0;
    this.channels = 0;
    this.bitsPerSample = 0;
    this.bigEndian = true;
};
SampleBuffer = stjs.extend(SampleBuffer, null, [], function(constructor, prototype) {
    prototype.sampleRate = 0;
    prototype.channels = 0;
    prototype.bitsPerSample = 0;
    prototype.length = 0.0;
    prototype.bitrate = 0.0;
    prototype.encodedBitrate = 0.0;
    prototype.data = null;
    prototype.bigEndian = false;
    /**
     *  Returns the buffer's PCM data.
     *  @return the audio data
     */
    prototype.getData = function() {
        return this.data;
    };
    /**
     *  Returns the data's sample rate.
     *  @return the sample rate
     */
    prototype.getSampleRate = function() {
        return this.sampleRate;
    };
    /**
     *  Returns the number of channels stored in the data buffer.
     *  @return the number of channels
     */
    prototype.getChannels = function() {
        return this.channels;
    };
    /**
     *  Returns the number of bits per sample. Usually this is 16, meaning a
     *  sample is stored in two bytes.
     *  @return the number of bits per sample
     */
    prototype.getBitsPerSample = function() {
        return this.bitsPerSample;
    };
    /**
     *  Returns the length of the current frame in seconds.
     *  length = samplesPerChannel / sampleRate
     *  @return the length in seconds
     */
    prototype.getLength = function() {
        return this.length;
    };
    /**
     *  Returns the bitrate of the decoded PCM data.
     *  <code>bitrate = (samplesPerChannel * bitsPerSample) / length</code>
     *  @return the bitrate
     */
    prototype.getBitrate = function() {
        return this.bitrate;
    };
    /**
     *  Returns the AAC bitrate of the current frame.
     *  @return the AAC bitrate
     */
    prototype.getEncodedBitrate = function() {
        return this.encodedBitrate;
    };
    /**
     *  Indicates the endianness for the data.
     *  
     *  @return true if the data is in big endian, false if it is in little endian
     */
    prototype.isBigEndian = function() {
        return this.bigEndian;
    };
    /**
     *  Sets the endianness for the data.
     *  
     *  @param bigEndian if true the data will be in big endian, else in little 
     *  endian
     */
    prototype.setBigEndian = function(bigEndian) {
        if (bigEndian != this.bigEndian) {
            var tmp;
            for (var i = 0; i < this.data.length; i += 2) {
                tmp = this.data[i];
                this.data[i] = this.data[i + 1];
                this.data[i + 1] = tmp;
            }
            this.bigEndian = bigEndian;
        }
    };
    prototype.setData = function(data, sampleRate, channels, bitsPerSample, bitsRead) {
        this.data = data;
        this.sampleRate = sampleRate;
        this.channels = channels;
        this.bitsPerSample = bitsPerSample;
        if (sampleRate == 0) {
            this.length = 0;
            this.bitrate = 0;
            this.encodedBitrate = 0;
        } else {
            var bytesPerSample = stjs.trunc(bitsPerSample / 8);
            var samplesPerChannel = stjs.trunc(data.length / (bytesPerSample * channels));
            this.length = samplesPerChannel / sampleRate;
            this.bitrate = (samplesPerChannel * bitsPerSample * channels) / this.length;
            this.encodedBitrate = bitsRead / this.length;
        }
    };
}, {data: "Int8Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Profile = stjs.enumeration("MAIN", "LC", "OTHER");
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  AAC bitstream block
 *  
 *  @author The JCodec project
 *  
 */
var Block = function() {};
Block = stjs.extend(Block, null, [], function(constructor, prototype) {
    prototype.type = null;
    prototype.getType = function() {
        return this.type;
    };
    prototype.parse = function(_in) {};
}, {type: {name: "Enum", arguments: ["BlockType"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var AACTab = function() {};
AACTab = stjs.extend(AACTab, null, [], function(constructor, prototype) {
    constructor.codes1 = new Int32Array([2040, 497, 2045, 1013, 104, 1008, 2039, 492, 2037, 1009, 114, 1012, 116, 17, 118, 491, 108, 1014, 2044, 481, 2033, 496, 97, 502, 2034, 490, 2043, 498, 105, 493, 119, 23, 111, 486, 100, 485, 103, 21, 98, 18, 0, 20, 101, 22, 109, 489, 99, 484, 107, 19, 113, 483, 112, 499, 2046, 487, 2035, 495, 96, 494, 2032, 482, 2042, 1011, 106, 488, 117, 16, 115, 500, 110, 1015, 2038, 480, 2041, 1010, 102, 501, 2047, 503, 2036]);
    constructor.bits1 = new Int32Array([11, 9, 11, 10, 7, 10, 11, 9, 11, 10, 7, 10, 7, 5, 7, 9, 7, 10, 11, 9, 11, 9, 7, 9, 11, 9, 11, 9, 7, 9, 7, 5, 7, 9, 7, 9, 7, 5, 7, 5, 1, 5, 7, 5, 7, 9, 7, 9, 7, 5, 7, 9, 7, 9, 11, 9, 11, 9, 7, 9, 11, 9, 11, 10, 7, 9, 7, 5, 7, 9, 7, 10, 11, 9, 11, 10, 7, 9, 11, 9, 11]);
    constructor.codes2 = new Int32Array([499, 111, 509, 235, 35, 234, 503, 232, 506, 242, 45, 112, 32, 6, 43, 110, 40, 233, 505, 102, 248, 231, 27, 241, 500, 107, 501, 236, 42, 108, 44, 10, 39, 103, 26, 245, 36, 8, 31, 9, 0, 7, 29, 11, 48, 239, 28, 100, 30, 12, 41, 243, 47, 240, 508, 113, 498, 244, 33, 230, 247, 104, 504, 238, 34, 101, 49, 2, 38, 237, 37, 106, 507, 114, 510, 105, 46, 246, 511, 109, 502]);
    constructor.bits2 = new Int32Array([9, 7, 9, 8, 6, 8, 9, 8, 9, 8, 6, 7, 6, 5, 6, 7, 6, 8, 9, 7, 8, 8, 6, 8, 9, 7, 9, 8, 6, 7, 6, 5, 6, 7, 6, 8, 6, 5, 6, 5, 3, 5, 6, 5, 6, 8, 6, 7, 6, 5, 6, 8, 6, 8, 9, 7, 9, 8, 6, 8, 8, 7, 9, 8, 6, 7, 6, 4, 6, 8, 6, 7, 9, 7, 9, 7, 6, 8, 9, 7, 9]);
    constructor.codes3 = new Int32Array([0, 9, 239, 11, 25, 240, 491, 486, 1010, 10, 53, 495, 52, 55, 489, 493, 487, 1011, 494, 1005, 8186, 492, 498, 2041, 2040, 1016, 4088, 8, 56, 1014, 54, 117, 1009, 1003, 1004, 4084, 24, 118, 2036, 57, 116, 1007, 499, 500, 2038, 488, 1002, 8188, 242, 497, 4091, 1013, 2035, 4092, 238, 1015, 32766, 496, 2037, 32765, 8187, 16378, 65535, 241, 1008, 16380, 490, 1006, 16379, 4086, 4090, 32764, 2034, 4085, 65534, 1012, 2039, 32763, 4087, 4089, 32762]);
    constructor.bits3 = new Int32Array([1, 4, 8, 4, 5, 8, 9, 9, 10, 4, 6, 9, 6, 6, 9, 9, 9, 10, 9, 10, 13, 9, 9, 11, 11, 10, 12, 4, 6, 10, 6, 7, 10, 10, 10, 12, 5, 7, 11, 6, 7, 10, 9, 9, 11, 9, 10, 13, 8, 9, 12, 10, 11, 12, 8, 10, 15, 9, 11, 15, 13, 14, 16, 8, 10, 14, 9, 10, 14, 12, 12, 15, 11, 12, 16, 10, 11, 15, 12, 12, 15]);
    constructor.codes4 = new Int32Array([7, 22, 246, 24, 8, 239, 495, 243, 2040, 25, 23, 237, 21, 1, 226, 240, 112, 1008, 494, 241, 2042, 238, 228, 1010, 2038, 1007, 2045, 5, 20, 242, 9, 4, 229, 244, 232, 1012, 6, 2, 231, 3, 0, 107, 227, 105, 499, 235, 230, 1014, 110, 106, 500, 1004, 496, 1017, 245, 236, 2043, 234, 111, 1015, 2041, 1011, 4095, 233, 109, 1016, 108, 104, 501, 1006, 498, 2036, 2039, 1009, 4094, 1005, 497, 2037, 2046, 1013, 2044]);
    constructor.bits4 = new Int32Array([4, 5, 8, 5, 4, 8, 9, 8, 11, 5, 5, 8, 5, 4, 8, 8, 7, 10, 9, 8, 11, 8, 8, 10, 11, 10, 11, 4, 5, 8, 4, 4, 8, 8, 8, 10, 4, 4, 8, 4, 4, 7, 8, 7, 9, 8, 8, 10, 7, 7, 9, 10, 9, 10, 8, 8, 11, 8, 7, 10, 11, 10, 12, 8, 7, 10, 7, 7, 9, 10, 9, 11, 11, 10, 12, 10, 9, 11, 11, 10, 11]);
    constructor.codes5 = new Int32Array([8191, 4087, 2036, 2024, 1009, 2030, 2041, 4088, 8189, 4093, 2033, 1000, 488, 240, 492, 1006, 2034, 4090, 4084, 1007, 498, 232, 112, 236, 496, 1002, 2035, 2027, 491, 234, 26, 8, 25, 238, 495, 2029, 1008, 242, 115, 11, 0, 10, 113, 243, 2025, 2031, 494, 239, 24, 9, 27, 235, 489, 2028, 2038, 1003, 499, 237, 114, 233, 497, 1005, 2039, 4086, 2032, 1001, 493, 241, 490, 1004, 2040, 4089, 8188, 4092, 4085, 2026, 1011, 1010, 2037, 4091, 8190]);
    constructor.bits5 = new Int32Array([13, 12, 11, 11, 10, 11, 11, 12, 13, 12, 11, 10, 9, 8, 9, 10, 11, 12, 12, 10, 9, 8, 7, 8, 9, 10, 11, 11, 9, 8, 5, 4, 5, 8, 9, 11, 10, 8, 7, 4, 1, 4, 7, 8, 11, 11, 9, 8, 5, 4, 5, 8, 9, 11, 11, 10, 9, 8, 7, 8, 9, 10, 11, 12, 11, 10, 9, 8, 9, 10, 11, 12, 13, 12, 12, 11, 10, 10, 11, 12, 13]);
    constructor.codes6 = new Int32Array([2046, 1021, 497, 491, 500, 490, 496, 1020, 2045, 1014, 485, 234, 108, 113, 104, 240, 486, 1015, 499, 239, 50, 39, 40, 38, 49, 235, 503, 488, 111, 46, 8, 4, 6, 41, 107, 494, 495, 114, 45, 2, 0, 3, 47, 115, 506, 487, 110, 43, 7, 1, 5, 44, 109, 492, 505, 238, 48, 36, 42, 37, 51, 236, 498, 1016, 484, 237, 106, 112, 105, 116, 241, 1018, 2047, 1017, 502, 493, 504, 489, 501, 1019, 2044]);
    constructor.bits6 = new Int32Array([11, 10, 9, 9, 9, 9, 9, 10, 11, 10, 9, 8, 7, 7, 7, 8, 9, 10, 9, 8, 6, 6, 6, 6, 6, 8, 9, 9, 7, 6, 4, 4, 4, 6, 7, 9, 9, 7, 6, 4, 4, 4, 6, 7, 9, 9, 7, 6, 4, 4, 4, 6, 7, 9, 9, 8, 6, 6, 6, 6, 6, 8, 9, 10, 9, 8, 7, 7, 7, 7, 8, 10, 11, 10, 9, 9, 9, 9, 9, 10, 11]);
    constructor.codes7 = new Int32Array([0, 5, 55, 116, 242, 491, 1005, 2039, 4, 12, 53, 113, 236, 238, 494, 501, 54, 52, 114, 234, 241, 489, 499, 1013, 115, 112, 235, 240, 497, 496, 1004, 1018, 243, 237, 488, 495, 1007, 1009, 1017, 2043, 493, 239, 490, 498, 1011, 1016, 2041, 2044, 1006, 492, 500, 1012, 1015, 2040, 4093, 4094, 2038, 1008, 1010, 1014, 2042, 2045, 4092, 4095]);
    constructor.bits7 = new Int32Array([1, 3, 6, 7, 8, 9, 10, 11, 3, 4, 6, 7, 8, 8, 9, 9, 6, 6, 7, 8, 8, 9, 9, 10, 7, 7, 8, 8, 9, 9, 10, 10, 8, 8, 9, 9, 10, 10, 10, 11, 9, 8, 9, 9, 10, 10, 11, 11, 10, 9, 9, 10, 10, 11, 12, 12, 11, 10, 10, 10, 11, 11, 12, 12]);
    constructor.codes8 = new Int32Array([14, 5, 16, 48, 111, 241, 506, 1022, 3, 0, 4, 18, 44, 106, 117, 248, 15, 2, 6, 20, 46, 105, 114, 245, 47, 17, 19, 42, 50, 108, 236, 250, 113, 43, 45, 49, 109, 112, 242, 505, 239, 104, 51, 107, 110, 238, 249, 1020, 504, 116, 115, 237, 240, 246, 502, 509, 1021, 243, 244, 247, 503, 507, 508, 1023]);
    constructor.bits8 = new Int32Array([5, 4, 5, 6, 7, 8, 9, 10, 4, 3, 4, 5, 6, 7, 7, 8, 5, 4, 4, 5, 6, 7, 7, 8, 6, 5, 5, 6, 6, 7, 8, 8, 7, 6, 6, 6, 7, 7, 8, 9, 8, 7, 6, 7, 7, 8, 8, 10, 9, 7, 7, 8, 8, 8, 9, 9, 10, 8, 8, 8, 9, 9, 9, 10]);
    constructor.codes9 = new Int32Array([0, 5, 55, 231, 478, 974, 985, 1992, 1997, 4040, 4061, 8164, 8172, 4, 12, 53, 114, 234, 237, 482, 977, 979, 992, 2008, 4047, 4053, 54, 52, 113, 232, 236, 481, 975, 989, 987, 2000, 4039, 4052, 4068, 230, 112, 233, 477, 483, 978, 988, 1996, 1994, 2014, 4056, 4074, 8155, 479, 235, 476, 486, 981, 990, 1995, 2013, 2012, 4045, 4066, 4071, 8161, 976, 480, 484, 982, 1989, 2001, 2011, 4050, 2016, 4057, 4075, 8163, 8169, 1988, 485, 983, 1990, 1999, 2010, 4043, 4058, 4067, 4073, 8166, 8179, 8183, 2003, 984, 993, 2004, 2009, 4051, 4062, 8157, 8153, 8162, 8170, 8177, 8182, 2002, 980, 986, 1991, 2007, 2018, 4046, 4059, 8152, 8174, 16368, 8180, 16370, 2017, 991, 1993, 2006, 4042, 4048, 4069, 4070, 8171, 8175, 16371, 16372, 16373, 4064, 1998, 2005, 4038, 4049, 4065, 8160, 8168, 8176, 16369, 16376, 16374, 32764, 4072, 2015, 4041, 4055, 4060, 8156, 8159, 8173, 8181, 16377, 16379, 32765, 32766, 8167, 4044, 4054, 4063, 8158, 8154, 8165, 8178, 16378, 16375, 16380, 16381, 32767]);
    constructor.bits9 = new Int32Array([1, 3, 6, 8, 9, 10, 10, 11, 11, 12, 12, 13, 13, 3, 4, 6, 7, 8, 8, 9, 10, 10, 10, 11, 12, 12, 6, 6, 7, 8, 8, 9, 10, 10, 10, 11, 12, 12, 12, 8, 7, 8, 9, 9, 10, 10, 11, 11, 11, 12, 12, 13, 9, 8, 9, 9, 10, 10, 11, 11, 11, 12, 12, 12, 13, 10, 9, 9, 10, 11, 11, 11, 12, 11, 12, 12, 13, 13, 11, 9, 10, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 11, 10, 10, 11, 11, 12, 12, 13, 13, 13, 13, 13, 13, 11, 10, 10, 11, 11, 11, 12, 12, 13, 13, 14, 13, 14, 11, 10, 11, 11, 12, 12, 12, 12, 13, 13, 14, 14, 14, 12, 11, 11, 12, 12, 12, 13, 13, 13, 14, 14, 14, 15, 12, 11, 12, 12, 12, 13, 13, 13, 13, 14, 14, 15, 15, 13, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15]);
    constructor.codes10 = new Int32Array([34, 8, 29, 38, 95, 211, 463, 976, 983, 1005, 2032, 2038, 4093, 7, 0, 1, 9, 32, 84, 96, 213, 220, 468, 973, 990, 2023, 28, 2, 6, 12, 30, 40, 91, 205, 217, 462, 476, 985, 1009, 37, 11, 10, 13, 36, 87, 97, 204, 221, 460, 478, 979, 999, 93, 33, 31, 35, 39, 89, 100, 216, 223, 466, 482, 989, 1006, 209, 85, 41, 86, 88, 98, 206, 224, 226, 474, 980, 995, 2027, 457, 94, 90, 92, 99, 202, 218, 455, 458, 480, 987, 1000, 2028, 483, 210, 203, 208, 215, 219, 454, 469, 472, 970, 986, 2026, 2033, 481, 212, 207, 214, 222, 225, 464, 470, 977, 981, 1010, 2030, 2043, 1001, 461, 456, 459, 465, 471, 479, 975, 992, 1007, 2022, 2040, 4090, 1003, 477, 467, 473, 475, 978, 972, 988, 1002, 2029, 2035, 2041, 4089, 2034, 974, 484, 971, 984, 982, 994, 997, 2024, 2036, 2037, 2039, 4091, 2042, 1004, 991, 993, 996, 998, 1008, 2025, 2031, 4088, 4094, 4092, 4095]);
    constructor.bits10 = new Int32Array([6, 5, 6, 6, 7, 8, 9, 10, 10, 10, 11, 11, 12, 5, 4, 4, 5, 6, 7, 7, 8, 8, 9, 10, 10, 11, 6, 4, 5, 5, 6, 6, 7, 8, 8, 9, 9, 10, 10, 6, 5, 5, 5, 6, 7, 7, 8, 8, 9, 9, 10, 10, 7, 6, 6, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 8, 7, 6, 7, 7, 7, 8, 8, 8, 9, 10, 10, 11, 9, 7, 7, 7, 7, 8, 8, 9, 9, 9, 10, 10, 11, 9, 8, 8, 8, 8, 8, 9, 9, 9, 10, 10, 11, 11, 9, 8, 8, 8, 8, 8, 9, 9, 10, 10, 10, 11, 11, 10, 9, 9, 9, 9, 9, 9, 10, 10, 10, 11, 11, 12, 10, 9, 9, 9, 9, 10, 10, 10, 10, 11, 11, 11, 12, 11, 10, 9, 10, 10, 10, 10, 10, 11, 11, 11, 11, 12, 11, 10, 10, 10, 10, 10, 10, 11, 11, 12, 12, 12, 12]);
    constructor.codes11 = new Int32Array([0, 6, 25, 61, 156, 198, 423, 912, 962, 991, 2022, 2035, 4091, 2028, 4090, 4094, 910, 5, 1, 8, 20, 55, 66, 146, 175, 401, 421, 437, 926, 960, 930, 973, 2006, 174, 23, 7, 9, 24, 57, 64, 142, 163, 184, 409, 428, 449, 945, 918, 958, 970, 157, 60, 21, 22, 26, 59, 68, 145, 165, 190, 406, 430, 441, 929, 913, 933, 981, 148, 154, 54, 56, 58, 65, 140, 155, 176, 195, 414, 427, 444, 927, 911, 937, 975, 147, 191, 62, 63, 67, 69, 158, 167, 185, 404, 418, 442, 451, 934, 935, 955, 980, 159, 416, 143, 141, 144, 152, 166, 182, 196, 415, 431, 447, 921, 959, 948, 969, 999, 168, 438, 171, 164, 170, 178, 194, 197, 408, 420, 440, 908, 932, 964, 966, 989, 1000, 173, 943, 402, 189, 188, 398, 407, 410, 419, 433, 909, 920, 951, 979, 977, 987, 2013, 180, 990, 425, 411, 412, 417, 426, 429, 435, 907, 946, 952, 974, 993, 992, 2002, 2021, 183, 2019, 443, 424, 422, 432, 434, 439, 923, 922, 954, 949, 982, 2007, 996, 2008, 2026, 186, 2024, 928, 445, 436, 906, 452, 914, 938, 944, 956, 983, 2004, 2012, 2011, 2005, 2032, 193, 2043, 968, 931, 917, 925, 940, 942, 965, 984, 994, 998, 2020, 2023, 2016, 2025, 2039, 400, 2034, 915, 446, 448, 916, 919, 941, 963, 961, 978, 2010, 2009, 2015, 2027, 2036, 2042, 405, 2040, 957, 924, 939, 936, 947, 953, 976, 995, 997, 2018, 2014, 2029, 2033, 2041, 2044, 403, 4093, 988, 950, 967, 972, 971, 985, 986, 2003, 2017, 2030, 2031, 2037, 2038, 4092, 4095, 413, 450, 181, 161, 150, 151, 149, 153, 160, 162, 172, 169, 177, 179, 187, 192, 399, 4]);
    constructor.bits11 = new Int32Array([4, 5, 6, 7, 8, 8, 9, 10, 10, 10, 11, 11, 12, 11, 12, 12, 10, 5, 4, 5, 6, 7, 7, 8, 8, 9, 9, 9, 10, 10, 10, 10, 11, 8, 6, 5, 5, 6, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 10, 8, 7, 6, 6, 6, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 10, 8, 8, 7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 10, 10, 10, 10, 8, 8, 7, 7, 7, 7, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 8, 9, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 10, 10, 10, 10, 10, 8, 9, 8, 8, 8, 8, 8, 8, 9, 9, 9, 10, 10, 10, 10, 10, 10, 8, 10, 9, 8, 8, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 11, 8, 10, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 11, 11, 8, 11, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 11, 10, 11, 11, 8, 11, 10, 9, 9, 10, 9, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 8, 11, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 9, 11, 10, 9, 9, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 9, 11, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 9, 12, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 12, 12, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 5]);
    constructor.ff_aac_scalefactor_code = new Int32Array([262120, 262118, 262119, 262117, 524277, 524273, 524269, 524278, 524270, 524271, 524272, 524284, 524285, 524287, 524286, 524279, 524280, 524283, 524281, 262116, 524282, 262115, 131055, 131056, 65525, 131054, 65522, 65523, 65524, 65521, 32758, 32759, 16377, 16373, 16375, 16371, 16374, 16370, 8183, 8181, 4089, 4087, 4086, 2041, 4084, 2040, 1017, 1015, 1013, 504, 503, 250, 248, 246, 121, 58, 56, 26, 11, 4, 0, 10, 12, 27, 57, 59, 120, 122, 247, 249, 502, 505, 1012, 1014, 1016, 2037, 2036, 2038, 2039, 4085, 4088, 8180, 8182, 8184, 16376, 16372, 65520, 32756, 65526, 32757, 262114, 524249, 524250, 524251, 524252, 524253, 524254, 524248, 524242, 524243, 524244, 524245, 524246, 524274, 524255, 524263, 524264, 524265, 524266, 524267, 524262, 524256, 524257, 524258, 524259, 524260, 524261, 524247, 524268, 524276, 524275]);
    constructor.ff_aac_scalefactor_bits = new Int32Array([18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 18, 19, 18, 17, 17, 16, 17, 16, 16, 16, 16, 15, 15, 14, 14, 14, 14, 14, 14, 13, 13, 12, 12, 12, 11, 12, 11, 10, 10, 10, 9, 9, 8, 8, 8, 7, 6, 6, 5, 4, 3, 1, 4, 4, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 10, 11, 11, 11, 11, 12, 12, 13, 13, 13, 14, 14, 16, 15, 16, 15, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19]);
    constructor.maxSfbTab = new Int32Array([33, 33, 38, 40, 40, 40, 41, 41, 37, 37, 37, 34, 34]);
    constructor.ltpCoefTab = new Float32Array([0.570829, 0.696616, 0.813004, 0.911304, 0.9849, 1.067894, 1.194601, 1.369533]);
    constructor.ff_aac_num_swb_1024 = new Int32Array([41, 41, 47, 49, 49, 51, 47, 47, 43, 43, 43, 40, 40]);
    constructor.ff_aac_num_swb_128 = new Int32Array([12, 12, 12, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15]);
    constructor.swb_offset_1024_96 = new Int32Array([0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 64, 72, 80, 88, 96, 108, 120, 132, 144, 156, 172, 188, 212, 240, 276, 320, 384, 448, 512, 576, 640, 704, 768, 832, 896, 960, 1024]);
    constructor.swb_offset_128_96 = new Int32Array([0, 4, 8, 12, 16, 20, 24, 32, 40, 48, 64, 92, 128]);
    constructor.swb_offset_1024_64 = new Int32Array([0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 64, 72, 80, 88, 100, 112, 124, 140, 156, 172, 192, 216, 240, 268, 304, 344, 384, 424, 464, 504, 544, 584, 624, 664, 704, 744, 784, 824, 864, 904, 944, 984, 1024]);
    constructor.swb_offset_1024_48 = new Int32Array([0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 48, 56, 64, 72, 80, 88, 96, 108, 120, 132, 144, 160, 176, 196, 216, 240, 264, 292, 320, 352, 384, 416, 448, 480, 512, 544, 576, 608, 640, 672, 704, 736, 768, 800, 832, 864, 896, 928, 1024]);
    constructor.swb_offset_128_48 = new Int32Array([0, 4, 8, 12, 16, 20, 28, 36, 44, 56, 68, 80, 96, 112, 128]);
    constructor.swb_offset_1024_32 = new Int32Array([0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 48, 56, 64, 72, 80, 88, 96, 108, 120, 132, 144, 160, 176, 196, 216, 240, 264, 292, 320, 352, 384, 416, 448, 480, 512, 544, 576, 608, 640, 672, 704, 736, 768, 800, 832, 864, 896, 928, 960, 992, 1024]);
    constructor.swb_offset_1024_24 = new Int32Array([0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 52, 60, 68, 76, 84, 92, 100, 108, 116, 124, 136, 148, 160, 172, 188, 204, 220, 240, 260, 284, 308, 336, 364, 396, 432, 468, 508, 552, 600, 652, 704, 768, 832, 896, 960, 1024]);
    constructor.swb_offset_128_24 = new Int32Array([0, 4, 8, 12, 16, 20, 24, 28, 36, 44, 52, 64, 76, 92, 108, 128]);
    constructor.swb_offset_1024_16 = new Int32Array([0, 8, 16, 24, 32, 40, 48, 56, 64, 72, 80, 88, 100, 112, 124, 136, 148, 160, 172, 184, 196, 212, 228, 244, 260, 280, 300, 320, 344, 368, 396, 424, 456, 492, 532, 572, 616, 664, 716, 772, 832, 896, 960, 1024]);
    constructor.swb_offset_128_16 = new Int32Array([0, 4, 8, 12, 16, 20, 24, 28, 32, 40, 48, 60, 72, 88, 108, 128]);
    constructor.swb_offset_1024_8 = new Int32Array([0, 12, 24, 36, 48, 60, 72, 84, 96, 108, 120, 132, 144, 156, 172, 188, 204, 220, 236, 252, 268, 288, 308, 328, 348, 372, 396, 420, 448, 476, 508, 544, 580, 620, 664, 712, 764, 820, 880, 944, 1024]);
    constructor.swb_offset_128_8 = new Int32Array([0, 4, 8, 12, 16, 20, 24, 28, 36, 44, 52, 60, 72, 88, 108, 128]);
    constructor.ff_swb_offset_1024 = [AACTab.swb_offset_1024_96, AACTab.swb_offset_1024_96, AACTab.swb_offset_1024_64, AACTab.swb_offset_1024_48, AACTab.swb_offset_1024_48, AACTab.swb_offset_1024_32, AACTab.swb_offset_1024_24, AACTab.swb_offset_1024_24, AACTab.swb_offset_1024_16, AACTab.swb_offset_1024_16, AACTab.swb_offset_1024_16, AACTab.swb_offset_1024_8, AACTab.swb_offset_1024_8];
    constructor.ff_swb_offset_128 = [AACTab.swb_offset_128_96, AACTab.swb_offset_128_96, AACTab.swb_offset_128_96, AACTab.swb_offset_128_48, AACTab.swb_offset_128_48, AACTab.swb_offset_128_48, AACTab.swb_offset_128_24, AACTab.swb_offset_128_24, AACTab.swb_offset_128_16, AACTab.swb_offset_128_16, AACTab.swb_offset_128_16, AACTab.swb_offset_128_8, AACTab.swb_offset_128_8];
    constructor.tns_tmp2_map_1_3 = new Float32Array([0.0, -0.43388373, 0.6427876, 0.34202015]);
    constructor.tns_tmp2_map_0_3 = new Float32Array([0.0, -0.43388373, -0.7818315, -0.9749279, 0.9848077, 0.8660254, 0.6427876, 0.34202015]);
    constructor.tns_tmp2_map_1_4 = new Float32Array([0.0, -0.2079117, -0.40673664, -0.58778524, 0.6736956, 0.52643216, 0.36124167, 0.18374951]);
    constructor.tns_tmp2_map_0_4 = new Float32Array([0.0, -0.2079117, -0.40673664, -0.58778524, -0.7431448, -0.8660254, -0.95105654, -0.9945219, 0.99573416, 0.9618256, 0.8951633, 0.7980172, 0.6736956, 0.52643216, 0.36124167, 0.18374951]);
    constructor.tns_tmp2_map = [AACTab.tns_tmp2_map_0_3, AACTab.tns_tmp2_map_0_4, AACTab.tns_tmp2_map_1_3, AACTab.tns_tmp2_map_1_4];
    constructor.codebook_vector0_vals = new Float32Array([-1.0, 0.0, 1.0]);
    constructor.codebook_vector02_idx = new Int32Array([0, 33088, 33152, 16656, 49744, 49808, 16672, 49760, 49824, 8452, 41540, 41604, 25108, 58196, 58260, 25124, 58212, 58276, 8456, 41544, 41608, 25112, 58200, 58264, 25128, 58216, 58280, 4353, 37441, 37505, 21009, 54097, 54161, 21025, 54113, 54177, 12805, 45893, 45957, 29461, 62549, 62613, 29477, 62565, 62629, 12809, 45897, 45961, 29465, 62553, 62617, 29481, 62569, 62633, 4354, 37442, 37506, 21010, 54098, 54162, 21026, 54114, 54178, 12806, 45894, 45958, 29462, 62550, 62614, 29478, 62566, 62630, 12810, 45898, 45962, 29466, 62554, 62618, 29482, 62570, 62634]);
    constructor.codebook_vector4_vals = new Float32Array([-6.349604, -4.326749, -2.5198421, -1.0, 0.0, 1.0, 2.5198421, 4.326749, 6.349604]);
    constructor.codebook_vector4_idx = new Int32Array([0, 16, 32, 48, 64, 80, 96, 112, 128, 1, 17, 33, 49, 65, 81, 97, 113, 129, 2, 18, 34, 50, 66, 82, 98, 114, 130, 3, 19, 35, 51, 67, 83, 99, 115, 131, 4, 20, 36, 52, 68, 84, 100, 116, 132, 5, 21, 37, 53, 69, 85, 101, 117, 133, 6, 22, 38, 54, 70, 86, 102, 118, 134, 7, 23, 39, 55, 71, 87, 103, 119, 135, 8, 24, 40, 56, 72, 88, 104, 120, 136]);
    constructor.codebook_vector6_idx = new Int32Array([0, 272, 288, 304, 320, 336, 352, 368, 4353, 529, 545, 561, 577, 593, 609, 625, 4354, 530, 546, 562, 578, 594, 610, 626, 4355, 531, 547, 563, 579, 595, 611, 627, 4356, 532, 548, 564, 580, 596, 612, 628, 4357, 533, 549, 565, 581, 597, 613, 629, 4358, 534, 550, 566, 582, 598, 614, 630, 4359, 535, 551, 567, 583, 599, 615, 631]);
    constructor.codebook_vector8_idx = new Int32Array([0, 272, 288, 304, 320, 336, 352, 368, 384, 400, 416, 432, 448, 4353, 529, 545, 561, 577, 593, 609, 625, 641, 657, 673, 689, 705, 4354, 530, 546, 562, 578, 594, 610, 626, 642, 658, 674, 690, 706, 4355, 531, 547, 563, 579, 595, 611, 627, 643, 659, 675, 691, 707, 4356, 532, 548, 564, 580, 596, 612, 628, 644, 660, 676, 692, 708, 4357, 533, 549, 565, 581, 597, 613, 629, 645, 661, 677, 693, 709, 4358, 534, 550, 566, 582, 598, 614, 630, 646, 662, 678, 694, 710, 4359, 535, 551, 567, 583, 599, 615, 631, 647, 663, 679, 695, 711, 4360, 536, 552, 568, 584, 600, 616, 632, 648, 664, 680, 696, 712, 4361, 537, 553, 569, 585, 601, 617, 633, 649, 665, 681, 697, 713, 4362, 538, 554, 570, 586, 602, 618, 634, 650, 666, 682, 698, 714, 4363, 539, 555, 571, 587, 603, 619, 635, 651, 667, 683, 699, 715, 4364, 540, 556, 572, 588, 604, 620, 636, 652, 668, 684, 700, 716]);
    constructor.codebook_vector10_vals = new Float32Array([0.0, 1.0, 2.5198421, 4.326749, 6.349604, 8.54988, 10.902723, 13.390518, 16.0, 18.720755, 21.544348, 24.463781, 27.473143, 30.56735, 33.741993, 36.99318]);
    constructor.codebook_vector10_idx = new Int32Array([0, 4112, 4128, 4144, 4160, 4176, 4192, 4208, 4224, 4240, 4256, 4272, 4288, 4304, 4320, 4336, 4608, 4097, 8209, 8225, 8241, 8257, 8273, 8289, 8305, 8321, 8337, 8353, 8369, 8385, 8401, 8417, 8433, 8705, 4098, 8210, 8226, 8242, 8258, 8274, 8290, 8306, 8322, 8338, 8354, 8370, 8386, 8402, 8418, 8434, 8706, 4099, 8211, 8227, 8243, 8259, 8275, 8291, 8307, 8323, 8339, 8355, 8371, 8387, 8403, 8419, 8435, 8707, 4100, 8212, 8228, 8244, 8260, 8276, 8292, 8308, 8324, 8340, 8356, 8372, 8388, 8404, 8420, 8436, 8708, 4101, 8213, 8229, 8245, 8261, 8277, 8293, 8309, 8325, 8341, 8357, 8373, 8389, 8405, 8421, 8437, 8709, 4102, 8214, 8230, 8246, 8262, 8278, 8294, 8310, 8326, 8342, 8358, 8374, 8390, 8406, 8422, 8438, 8710, 4103, 8215, 8231, 8247, 8263, 8279, 8295, 8311, 8327, 8343, 8359, 8375, 8391, 8407, 8423, 8439, 8711, 4104, 8216, 8232, 8248, 8264, 8280, 8296, 8312, 8328, 8344, 8360, 8376, 8392, 8408, 8424, 8440, 8712, 4105, 8217, 8233, 8249, 8265, 8281, 8297, 8313, 8329, 8345, 8361, 8377, 8393, 8409, 8425, 8441, 8713, 4106, 8218, 8234, 8250, 8266, 8282, 8298, 8314, 8330, 8346, 8362, 8378, 8394, 8410, 8426, 8442, 8714, 4107, 8219, 8235, 8251, 8267, 8283, 8299, 8315, 8331, 8347, 8363, 8379, 8395, 8411, 8427, 8443, 8715, 4108, 8220, 8236, 8252, 8268, 8284, 8300, 8316, 8332, 8348, 8364, 8380, 8396, 8412, 8428, 8444, 8716, 4109, 8221, 8237, 8253, 8269, 8285, 8301, 8317, 8333, 8349, 8365, 8381, 8397, 8413, 8429, 8445, 8717, 4110, 8222, 8238, 8254, 8270, 8286, 8302, 8318, 8334, 8350, 8366, 8382, 8398, 8414, 8430, 8446, 8718, 4111, 8223, 8239, 8255, 8271, 8287, 8303, 8319, 8335, 8351, 8367, 8383, 8399, 8415, 8431, 8447, 8719, 4352, 8464, 8480, 8496, 8512, 8528, 8544, 8560, 8576, 8592, 8608, 8624, 8640, 8656, 8672, 8688, 8960]);
}, {codes1: "Int32Array", bits1: "Int32Array", codes2: "Int32Array", bits2: "Int32Array", codes3: "Int32Array", bits3: "Int32Array", codes4: "Int32Array", bits4: "Int32Array", codes5: "Int32Array", bits5: "Int32Array", codes6: "Int32Array", bits6: "Int32Array", codes7: "Int32Array", bits7: "Int32Array", codes8: "Int32Array", bits8: "Int32Array", codes9: "Int32Array", bits9: "Int32Array", codes10: "Int32Array", bits10: "Int32Array", codes11: "Int32Array", bits11: "Int32Array", ff_aac_scalefactor_code: "Int32Array", ff_aac_scalefactor_bits: "Int32Array", maxSfbTab: "Int32Array", ltpCoefTab: "Float32Array", ff_aac_num_swb_1024: "Int32Array", ff_aac_num_swb_128: "Int32Array", swb_offset_1024_96: "Int32Array", swb_offset_128_96: "Int32Array", swb_offset_1024_64: "Int32Array", swb_offset_1024_48: "Int32Array", swb_offset_128_48: "Int32Array", swb_offset_1024_32: "Int32Array", swb_offset_1024_24: "Int32Array", swb_offset_128_24: "Int32Array", swb_offset_1024_16: "Int32Array", swb_offset_128_16: "Int32Array", swb_offset_1024_8: "Int32Array", swb_offset_128_8: "Int32Array", ff_swb_offset_1024: "Array", ff_swb_offset_128: "Array", tns_tmp2_map_1_3: "Float32Array", tns_tmp2_map_0_3: "Float32Array", tns_tmp2_map_1_4: "Float32Array", tns_tmp2_map_0_4: "Float32Array", tns_tmp2_map: "Array", codebook_vector0_vals: "Float32Array", codebook_vector02_idx: "Int32Array", codebook_vector4_vals: "Float32Array", codebook_vector4_idx: "Int32Array", codebook_vector6_idx: "Int32Array", codebook_vector8_idx: "Int32Array", codebook_vector10_vals: "Float32Array", codebook_vector10_idx: "Int32Array"}, {});
var IBoxFactory = function() {};
IBoxFactory = stjs.extend(IBoxFactory, null, [], function(constructor, prototype) {
    prototype.newBox = function(header) {};
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var MediaInfo = function(dim) {
    this.dim = dim;
};
MediaInfo = stjs.extend(MediaInfo, null, [], function(constructor, prototype) {
    prototype.dim = null;
    prototype.getDim = function() {
        return this.dim;
    };
    prototype.setDim = function(dim) {
        this.dim = dim;
    };
}, {dim: "Size"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  All possible channel configurations for AAC.
 *  
 *  @author in-somnia
 */
var ChannelConfiguration = function(chCount, descr) {
    this.chCount = chCount;
    this.descr = descr;
};
ChannelConfiguration = stjs.extend(ChannelConfiguration, null, [], function(constructor, prototype) {
    constructor.CHANNEL_CONFIG_UNSUPPORTED = new ChannelConfiguration(-1, "invalid");
    constructor.CHANNEL_CONFIG_NONE = new ChannelConfiguration(0, "No channel");
    constructor.CHANNEL_CONFIG_MONO = new ChannelConfiguration(1, "Mono");
    constructor.CHANNEL_CONFIG_STEREO = new ChannelConfiguration(2, "Stereo");
    constructor.CHANNEL_CONFIG_STEREO_PLUS_CENTER = new ChannelConfiguration(3, "Stereo+Center");
    constructor.CHANNEL_CONFIG_STEREO_PLUS_CENTER_PLUS_REAR_MONO = new ChannelConfiguration(4, "Stereo+Center+Rear");
    constructor.CHANNEL_CONFIG_FIVE = new ChannelConfiguration(5, "Five channels");
    constructor.CHANNEL_CONFIG_FIVE_PLUS_ONE = new ChannelConfiguration(6, "Five channels+LF");
    constructor.CHANNEL_CONFIG_SEVEN_PLUS_ONE = new ChannelConfiguration(8, "Seven channels+LF");
    constructor.forInt = function(i) {
        var c;
        switch (i) {
            case 0:
                c = ChannelConfiguration.CHANNEL_CONFIG_NONE;
                break;
            case 1:
                c = ChannelConfiguration.CHANNEL_CONFIG_MONO;
                break;
            case 2:
                c = ChannelConfiguration.CHANNEL_CONFIG_STEREO;
                break;
            case 3:
                c = ChannelConfiguration.CHANNEL_CONFIG_STEREO_PLUS_CENTER;
                break;
            case 4:
                c = ChannelConfiguration.CHANNEL_CONFIG_STEREO_PLUS_CENTER_PLUS_REAR_MONO;
                break;
            case 5:
                c = ChannelConfiguration.CHANNEL_CONFIG_FIVE;
                break;
            case 6:
                c = ChannelConfiguration.CHANNEL_CONFIG_FIVE_PLUS_ONE;
                break;
            case 7:
            case 8:
                c = ChannelConfiguration.CHANNEL_CONFIG_SEVEN_PLUS_ONE;
                break;
            default:
                c = ChannelConfiguration.CHANNEL_CONFIG_UNSUPPORTED;
                break;
        }
        return c;
    };
    prototype.chCount = 0;
    prototype.descr = null;
    /**
     *  Returns the number of channels in this configuration.
     */
    prototype.getChannelCount = function() {
        return this.chCount;
    };
    /**
     *  Returns a short description of this configuration.
     *  
     *  @return the channel configuration's description
     */
    prototype.getDescription = function() {
        return this.descr;
    };
    /**
     *  Returns a string representation of this channel configuration. The method
     *  is identical to <code>getDescription()</code>.
     *  
     *  @return the channel configuration's description
     */
    prototype.toString = function() {
        return this.descr;
    };
}, {CHANNEL_CONFIG_UNSUPPORTED: "ChannelConfiguration", CHANNEL_CONFIG_NONE: "ChannelConfiguration", CHANNEL_CONFIG_MONO: "ChannelConfiguration", CHANNEL_CONFIG_STEREO: "ChannelConfiguration", CHANNEL_CONFIG_STEREO_PLUS_CENTER: "ChannelConfiguration", CHANNEL_CONFIG_STEREO_PLUS_CENTER_PLUS_REAR_MONO: "ChannelConfiguration", CHANNEL_CONFIG_FIVE: "ChannelConfiguration", CHANNEL_CONFIG_FIVE_PLUS_ONE: "ChannelConfiguration", CHANNEL_CONFIG_SEVEN_PLUS_ONE: "ChannelConfiguration"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var AudioFilter = function() {};
AudioFilter = stjs.extend(AudioFilter, null, [], function(constructor, prototype) {
    prototype.filter = function(_in, inPos, out) {};
    prototype.getDelay = function() {};
    prototype.getNInputs = function() {};
    prototype.getNOutputs = function() {};
}, {}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 * 
 *  @author in-somnia
 */
var RVLCTables = function() {};
RVLCTables = stjs.extend(RVLCTables, null, [], function(constructor, prototype) {
    constructor.RVLC_BOOK = [new Int32Array([0, 1, 0]), new Int32Array([-1, 3, 5]), new Int32Array([1, 3, 7]), new Int32Array([-2, 4, 9]), new Int32Array([-3, 5, 17]), new Int32Array([2, 5, 27]), new Int32Array([-4, 6, 33]), new Int32Array([99, 6, 50]), new Int32Array([3, 6, 51]), new Int32Array([99, 6, 52]), new Int32Array([-7, 7, 65]), new Int32Array([99, 7, 96]), new Int32Array([99, 7, 98]), new Int32Array([7, 7, 99]), new Int32Array([4, 7, 107]), new Int32Array([-5, 8, 129]), new Int32Array([99, 8, 194]), new Int32Array([5, 8, 195]), new Int32Array([99, 8, 212]), new Int32Array([99, 9, 256]), new Int32Array([-6, 9, 257]), new Int32Array([99, 9, 426]), new Int32Array([6, 9, 427]), new Int32Array([99, 10, 0])];
    constructor.ESCAPE_BOOK = [new Int32Array([1, 2, 0]), new Int32Array([0, 2, 2]), new Int32Array([3, 3, 2]), new Int32Array([2, 3, 6]), new Int32Array([4, 4, 14]), new Int32Array([7, 5, 13]), new Int32Array([6, 5, 15]), new Int32Array([5, 5, 31]), new Int32Array([11, 6, 24]), new Int32Array([10, 6, 25]), new Int32Array([9, 6, 29]), new Int32Array([8, 6, 61]), new Int32Array([13, 7, 56]), new Int32Array([12, 7, 120]), new Int32Array([15, 8, 114]), new Int32Array([14, 8, 242]), new Int32Array([17, 9, 230]), new Int32Array([16, 9, 486]), new Int32Array([19, 10, 463]), new Int32Array([18, 10, 974]), new Int32Array([22, 11, 925]), new Int32Array([20, 11, 1950]), new Int32Array([21, 11, 1951]), new Int32Array([23, 12, 1848]), new Int32Array([25, 13, 3698]), new Int32Array([24, 14, 7399]), new Int32Array([26, 15, 14797]), new Int32Array([49, 19, 236736]), new Int32Array([50, 19, 236737]), new Int32Array([51, 19, 236738]), new Int32Array([52, 19, 236739]), new Int32Array([53, 19, 236740]), new Int32Array([27, 20, 473482]), new Int32Array([28, 20, 473483]), new Int32Array([29, 20, 473484]), new Int32Array([30, 20, 473485]), new Int32Array([31, 20, 473486]), new Int32Array([32, 20, 473487]), new Int32Array([33, 20, 473488]), new Int32Array([34, 20, 473489]), new Int32Array([35, 20, 473490]), new Int32Array([36, 20, 473491]), new Int32Array([37, 20, 473492]), new Int32Array([38, 20, 473493]), new Int32Array([39, 20, 473494]), new Int32Array([40, 20, 473495]), new Int32Array([41, 20, 473496]), new Int32Array([42, 20, 473497]), new Int32Array([43, 20, 473498]), new Int32Array([44, 20, 473499]), new Int32Array([45, 20, 473500]), new Int32Array([46, 20, 473501]), new Int32Array([47, 20, 473502]), new Int32Array([48, 20, 473503]), new Int32Array([99, 21, 0])];
}, {RVLC_BOOK: "Array", ESCAPE_BOOK: "Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 * 
 *  @author in-somnia
 */
var PSConstants = function() {};
PSConstants = stjs.extend(PSConstants, null, [], function(constructor, prototype) {
    constructor.MAX_PS_ENVELOPES = 5;
    constructor.NO_ALLPASS_LINKS = 3;
    constructor.NEGATE_IPD_MASK = 4096;
    constructor.DECAY_SLOPE = 0.05;
    constructor.COEF_SQRT2 = 1.4142135;
}, {}, {});
var H264Utils2 = function() {};
H264Utils2 = stjs.extend(H264Utils2, null, [], function(constructor, prototype) {
    constructor.golomb2Signed = function(val) {
        var sign = ((val & 1) << 1) - 1;
        val = ((val >> 1) + (val & 1)) * sign;
        return val;
    };
}, {}, {});
/**
 *  this annotation warns not to remove methods/constructors/fields if their
 *  usages are not found via normal means
 */
var UsedViaReflection = function() {};
UsedViaReflection = stjs.extend(UsedViaReflection, null, [], null, {}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  Intensity stereo lookup table for all possible values for
 *  0.5<sup>0.25*scaleFactor</sup>.
 *  @author in-somnia
 */
var ISScaleTable = function() {};
ISScaleTable = stjs.extend(ISScaleTable, null, [], function(constructor, prototype) {
    constructor.SCALE_TABLE = new Float32Array([1.0, 0.8408964, 0.70710677, 0.59460354, 0.5, 0.4204482, 0.35355338, 0.29730177, 0.25, 0.2102241, 0.17677669, 0.14865088, 0.125, 0.10511205, 0.088388346, 0.07432544, 0.0625, 0.052556027, 0.044194173, 0.03716272, 0.03125, 0.026278013, 0.022097087, 0.01858136, 0.015625, 0.013139007, 0.011048543, 0.00929068, 0.0078125, 0.0065695033, 0.0055242716, 0.00464534, 0.00390625, 0.0032847517, 0.0027621358, 0.00232267, 0.001953125, 0.0016423758, 0.0013810679, 0.001161335, 9.765625E-4, 8.211879E-4, 6.9053395E-4, 5.806675E-4, 4.8828125E-4, 4.1059396E-4, 3.4526698E-4, 2.9033376E-4, 2.4414062E-4, 2.0529698E-4, 1.7263349E-4, 1.4516688E-4, 1.2207031E-4, 1.0264849E-4, 8.6316744E-5, 7.258344E-5, 6.1035156E-5, 5.1324245E-5, 4.3158372E-5, 3.629172E-5, 3.0517578E-5, 2.5662122E-5, 2.1579186E-5, 1.814586E-5, 1.5258789E-5, 1.2831061E-5, 1.0789593E-5, 9.07293E-6, 7.6293945E-6, 6.4155306E-6, 5.3947965E-6, 4.536465E-6, 3.8146973E-6, 3.2077653E-6, 2.6973983E-6, 2.2682325E-6, 1.9073486E-6, 1.6038827E-6, 1.3486991E-6, 1.1341162E-6, 9.536743E-7, 8.019413E-7, 6.7434956E-7, 5.670581E-7, 4.7683716E-7, 4.0097066E-7, 3.3717478E-7, 2.8352906E-7, 2.3841858E-7, 2.0048533E-7, 1.6858739E-7, 1.4176453E-7, 1.1920929E-7, 1.00242666E-7, 8.4293696E-8, 7.0882265E-8, 5.9604645E-8, 5.0121333E-8, 4.2146848E-8, 3.5441133E-8, 2.9802322E-8, 2.5060666E-8, 2.1073424E-8, 1.7720566E-8, 1.4901161E-8, 1.2530333E-8, 1.0536712E-8, 8.860283E-9, 7.4505806E-9, 6.2651666E-9, 5.268356E-9, 4.4301416E-9, 3.7252903E-9, 3.1325833E-9, 2.634178E-9, 2.2150708E-9, 1.8626451E-9, 1.5662917E-9, 1.317089E-9, 1.1075354E-9, 9.313226E-10, 7.831458E-10, 6.585445E-10, 5.537677E-10, 4.656613E-10, 3.915729E-10, 3.2927225E-10, 2.7688385E-10, 2.3283064E-10, 1.9578646E-10, 1.6463612E-10, 1.3844192E-10, 1.1641532E-10, 9.789323E-11, 8.231806E-11, 6.922096E-11, 5.820766E-11, 4.8946614E-11, 4.115903E-11, 3.461048E-11, 2.910383E-11, 2.4473307E-11, 2.0579516E-11, 1.730524E-11, 1.4551915E-11, 1.22366535E-11, 1.0289758E-11, 8.65262E-12, 7.2759576E-12, 6.1183268E-12, 5.144879E-12, 4.32631E-12, 3.6379788E-12, 3.0591634E-12, 2.5724394E-12, 2.163155E-12, 1.8189894E-12, 1.5295817E-12, 1.2862197E-12, 1.0815775E-12, 9.094947E-13, 7.6479085E-13, 6.4310986E-13, 5.4078877E-13, 4.5474735E-13, 3.8239542E-13, 3.2155493E-13, 2.7039438E-13, 2.2737368E-13, 1.9119771E-13, 1.6077747E-13, 1.3519719E-13, 1.1368684E-13, 9.5598856E-14, 8.038873E-14, 6.7598596E-14, 5.684342E-14, 4.7799428E-14, 4.0194366E-14, 3.3799298E-14, 2.842171E-14, 2.3899714E-14, 2.0097183E-14, 1.6899649E-14, 1.4210855E-14, 1.1949857E-14, 1.00485916E-14, 8.4498245E-15, 7.1054274E-15, 5.9749285E-15, 5.0242958E-15, 4.2249122E-15, 3.5527137E-15, 2.9874642E-15, 2.5121479E-15, 2.1124561E-15, 1.7763568E-15, 1.4937321E-15, 1.2560739E-15, 1.0562281E-15, 8.881784E-16, 7.4686606E-16, 6.2803697E-16, 5.2811403E-16, 4.440892E-16, 3.7343303E-16, 3.1401849E-16, 2.6405702E-16, 2.220446E-16, 1.8671652E-16, 1.5700924E-16, 1.3202851E-16, 1.110223E-16, 9.335826E-17, 7.850462E-17, 6.6014254E-17, 5.551115E-17, 4.667913E-17, 3.925231E-17, 3.3007127E-17, 2.7755576E-17, 2.3339564E-17, 1.9626155E-17, 1.6503563E-17, 1.3877788E-17, 1.1669782E-17, 9.813078E-18, 8.251782E-18, 6.938894E-18, 5.834891E-18, 4.906539E-18, 4.125891E-18, 3.469447E-18, 2.9174455E-18, 2.4532694E-18, 2.0629454E-18, 1.7347235E-18, 1.4587228E-18, 1.2266347E-18, 1.0314727E-18, 8.6736174E-19, 7.293614E-19, 6.1331736E-19, 5.1573636E-19, 4.3368087E-19, 3.646807E-19, 3.0665868E-19, 2.5786818E-19, 2.1684043E-19, 1.8234035E-19, 1.5332934E-19, 1.2893409E-19, 1.0842022E-19, 9.1170173E-20, 7.666467E-20]);
}, {SCALE_TABLE: "Float32Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 * 
 *  @author in-somnia
 */
var GCConstants = function() {};
GCConstants = stjs.extend(GCConstants, null, [], function(constructor, prototype) {
    constructor.BANDS = 4;
    constructor.MAX_CHANNELS = 5;
    constructor.NPQFTAPS = 96;
    constructor.NPEPARTS = 64;
    constructor.ID_GAIN = 16;
    constructor.LN_GAIN = new Int32Array([-4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]);
}, {LN_GAIN: "Int32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var AudioDecoder = function() {};
AudioDecoder = stjs.extend(AudioDecoder, null, [], function(constructor, prototype) {
    prototype.decodeFrame = function(frame, dst) {};
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var ChannelPosition = stjs.enumeration("AAC_CHANNEL_FRONT", "AAC_CHANNEL_SIDE", "AAC_CHANNEL_BACK", "AAC_CHANNEL_LFE", "AAC_CHANNEL_CC");
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var DemuxerTrack = function() {};
DemuxerTrack = stjs.extend(DemuxerTrack, null, [], function(constructor, prototype) {
    prototype.nextFrame = function() {};
    prototype.getMeta = function() {};
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MP4Edit = function() {};
MP4Edit = stjs.extend(MP4Edit, null, [], function(constructor, prototype) {
    /**
     *  Operation performed on a movie header and fragments
     *  
     *  @param mov
     */
    prototype.applyToFragment = function(mov, fragmentBox) {};
    /**
     *  Operation performed on a movie header
     *  
     *  @param mov
     */
    prototype.apply = function(mov) {};
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var AACConts = function() {};
AACConts = stjs.extend(AACConts, null, [], function(constructor, prototype) {
    constructor.AAC_CHANNEL_COUNT = new Int16Array([0, 1, 2, 3, 4, 5, 6, 8]);
    constructor.AAC_SAMPLE_RATES = new Int32Array([96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350]);
}, {AAC_CHANNEL_COUNT: "Int16Array", AAC_SAMPLE_RATES: "Int32Array"}, {});
var FormatException = function(msg) {
    RuntimeException.call(this, msg);
};
FormatException = stjs.extend(FormatException, RuntimeException, [], null, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  @author The JCodec project
 */
var SimpleIDCT10Bit = function() {};
SimpleIDCT10Bit = stjs.extend(SimpleIDCT10Bit, null, [], function(constructor, prototype) {
    constructor.W1 = 90901;
    constructor.W2 = 85627;
    constructor.W3 = 77062;
    constructor.W4 = 65535;
    constructor.W5 = 51491;
    constructor.W6 = 35468;
    constructor.W7 = 18081;
    constructor.ROW_SHIFT = 15;
    constructor.COL_SHIFT = 20;
    constructor.idct10 = function(buf, off) {
        for (var i = 0; i < 8; i++) 
            SimpleIDCT10Bit.idctRow(buf, off + (i << 3));
        for (var i = 0; i < 8; i++) 
            SimpleIDCT10Bit.idctCol(buf, off + i);
    };
    constructor.idctCol = function(buf, off) {
        var a0, a1, a2, a3, b0, b1, b2, b3;
        a0 = SimpleIDCT10Bit.W4 * (buf[off + 8 * 0] + (stjs.trunc((1 << (SimpleIDCT10Bit.COL_SHIFT - 1)) / SimpleIDCT10Bit.W4)));
        a1 = a0;
        a2 = a0;
        a3 = a0;
        a0 += SimpleIDCT10Bit.W2 * buf[off + 8 * 2];
        a1 += SimpleIDCT10Bit.W6 * buf[off + 8 * 2];
        a2 += -SimpleIDCT10Bit.W6 * buf[off + 8 * 2];
        a3 += -SimpleIDCT10Bit.W2 * buf[off + 8 * 2];
        b0 = SimpleIDCT10Bit.W1 * buf[off + 8 * 1];
        b1 = SimpleIDCT10Bit.W3 * buf[off + 8 * 1];
        b2 = SimpleIDCT10Bit.W5 * buf[off + 8 * 1];
        b3 = SimpleIDCT10Bit.W7 * buf[off + 8 * 1];
        b0 += SimpleIDCT10Bit.W3 * buf[off + 8 * 3];
        b1 += -SimpleIDCT10Bit.W7 * buf[off + 8 * 3];
        b2 += -SimpleIDCT10Bit.W1 * buf[off + 8 * 3];
        b3 += -SimpleIDCT10Bit.W5 * buf[off + 8 * 3];
        if (buf[off + 8 * 4] != 0) {
            a0 += SimpleIDCT10Bit.W4 * buf[off + 8 * 4];
            a1 += -SimpleIDCT10Bit.W4 * buf[off + 8 * 4];
            a2 += -SimpleIDCT10Bit.W4 * buf[off + 8 * 4];
            a3 += SimpleIDCT10Bit.W4 * buf[off + 8 * 4];
        }
        if (buf[off + 8 * 5] != 0) {
            b0 += SimpleIDCT10Bit.W5 * buf[off + 8 * 5];
            b1 += -SimpleIDCT10Bit.W1 * buf[off + 8 * 5];
            b2 += SimpleIDCT10Bit.W7 * buf[off + 8 * 5];
            b3 += SimpleIDCT10Bit.W3 * buf[off + 8 * 5];
        }
        if (buf[off + 8 * 6] != 0) {
            a0 += SimpleIDCT10Bit.W6 * buf[off + 8 * 6];
            a1 += -SimpleIDCT10Bit.W2 * buf[off + 8 * 6];
            a2 += SimpleIDCT10Bit.W2 * buf[off + 8 * 6];
            a3 += -SimpleIDCT10Bit.W6 * buf[off + 8 * 6];
        }
        if (buf[off + 8 * 7] != 0) {
            b0 += SimpleIDCT10Bit.W7 * buf[off + 8 * 7];
            b1 += -SimpleIDCT10Bit.W5 * buf[off + 8 * 7];
            b2 += SimpleIDCT10Bit.W3 * buf[off + 8 * 7];
            b3 += -SimpleIDCT10Bit.W1 * buf[off + 8 * 7];
        }
        buf[off] = ((a0 + b0) >> SimpleIDCT10Bit.COL_SHIFT);
        buf[off + 8] = ((a1 + b1) >> SimpleIDCT10Bit.COL_SHIFT);
        buf[off + 16] = ((a2 + b2) >> SimpleIDCT10Bit.COL_SHIFT);
        buf[off + 24] = ((a3 + b3) >> SimpleIDCT10Bit.COL_SHIFT);
        buf[off + 32] = ((a3 - b3) >> SimpleIDCT10Bit.COL_SHIFT);
        buf[off + 40] = ((a2 - b2) >> SimpleIDCT10Bit.COL_SHIFT);
        buf[off + 48] = ((a1 - b1) >> SimpleIDCT10Bit.COL_SHIFT);
        buf[off + 56] = ((a0 - b0) >> SimpleIDCT10Bit.COL_SHIFT);
    };
    constructor.idctRow = function(buf, off) {
        var a0, a1, a2, a3, b0, b1, b2, b3;
        a0 = (SimpleIDCT10Bit.W4 * buf[off]) + (1 << (SimpleIDCT10Bit.ROW_SHIFT - 1));
        a1 = a0;
        a2 = a0;
        a3 = a0;
        a0 += SimpleIDCT10Bit.W2 * buf[off + 2];
        a1 += SimpleIDCT10Bit.W6 * buf[off + 2];
        a2 -= SimpleIDCT10Bit.W6 * buf[off + 2];
        a3 -= SimpleIDCT10Bit.W2 * buf[off + 2];
        b0 = SimpleIDCT10Bit.W1 * buf[off + 1];
        b0 += SimpleIDCT10Bit.W3 * buf[off + 3];
        b1 = SimpleIDCT10Bit.W3 * buf[off + 1];
        b1 += -SimpleIDCT10Bit.W7 * buf[off + 3];
        b2 = SimpleIDCT10Bit.W5 * buf[off + 1];
        b2 += -SimpleIDCT10Bit.W1 * buf[off + 3];
        b3 = SimpleIDCT10Bit.W7 * buf[off + 1];
        b3 += -SimpleIDCT10Bit.W5 * buf[off + 3];
        if (buf[off + 4] != 0 || buf[off + 5] != 0 || buf[off + 6] != 0 || buf[off + 7] != 0) {
            a0 += SimpleIDCT10Bit.W4 * buf[off + 4] + SimpleIDCT10Bit.W6 * buf[off + 6];
            a1 += -SimpleIDCT10Bit.W4 * buf[off + 4] - SimpleIDCT10Bit.W2 * buf[off + 6];
            a2 += -SimpleIDCT10Bit.W4 * buf[off + 4] + SimpleIDCT10Bit.W2 * buf[off + 6];
            a3 += SimpleIDCT10Bit.W4 * buf[off + 4] - SimpleIDCT10Bit.W6 * buf[off + 6];
            b0 += SimpleIDCT10Bit.W5 * buf[off + 5];
            b0 += SimpleIDCT10Bit.W7 * buf[off + 7];
            b1 += -SimpleIDCT10Bit.W1 * buf[off + 5];
            b1 += -SimpleIDCT10Bit.W5 * buf[off + 7];
            b2 += SimpleIDCT10Bit.W7 * buf[off + 5];
            b2 += SimpleIDCT10Bit.W3 * buf[off + 7];
            b3 += SimpleIDCT10Bit.W3 * buf[off + 5];
            b3 += -SimpleIDCT10Bit.W1 * buf[off + 7];
        }
        buf[off + 0] = (a0 + b0) >> SimpleIDCT10Bit.ROW_SHIFT;
        buf[off + 7] = (a0 - b0) >> SimpleIDCT10Bit.ROW_SHIFT;
        buf[off + 1] = (a1 + b1) >> SimpleIDCT10Bit.ROW_SHIFT;
        buf[off + 6] = (a1 - b1) >> SimpleIDCT10Bit.ROW_SHIFT;
        buf[off + 2] = (a2 + b2) >> SimpleIDCT10Bit.ROW_SHIFT;
        buf[off + 5] = (a2 - b2) >> SimpleIDCT10Bit.ROW_SHIFT;
        buf[off + 3] = (a3 + b3) >> SimpleIDCT10Bit.ROW_SHIFT;
        buf[off + 4] = (a3 - b3) >> SimpleIDCT10Bit.ROW_SHIFT;
    };
    constructor.coefficients = new Float64Array(64);
    constructor.fdct10 = function(block, off, dctOut) {
        var i, j, k;
        var out = new Float64Array(8 * 8);
        for (i = 0; i < 64; i += 8) {
            for (j = 0; j < 8; ++j) {
                var tmp = 0;
                for (k = 0; k < 8; ++k) {
                    tmp += SimpleIDCT10Bit.coefficients[i + k] * ((block[k * 8 + j + off] + 128) << 2);
                }
                out[i + j] = tmp * 4;
            }
        }
        for (j = 0; j < 8; ++j) {
            for (i = 0; i < 64; i += 8) {
                var tmp = 0;
                for (k = 0; k < 8; ++k) {
                    tmp += out[i + k] * SimpleIDCT10Bit.coefficients[j * 8 + k];
                }
                dctOut[i + j + off] = stjs.trunc((tmp + 0.499999999999));
            }
        }
    };
}, {coefficients: "Float64Array"}, {});
(function() {
    for (var j = 0; j < 8; ++j) {
        SimpleIDCT10Bit.coefficients[j] = Math.sqrt(0.125);
        for (var i = 8; i < 64; i += 8) {
            SimpleIDCT10Bit.coefficients[i + j] = 0.5 * Math.cos(i * (j + 0.5) * Math.PI / 64.0);
        }
    }
})();
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var AudioSource = function() {};
AudioSource = stjs.extend(AudioSource, null, [], function(constructor, prototype) {
    prototype.getFormat = function() {};
    prototype.readFloat = function(buffer) {};
}, {}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  @author in-somnia
 */
var MDCTTables = function() {};
MDCTTables = stjs.extend(MDCTTables, null, [], function(constructor, prototype) {
    constructor.MDCT_TABLE_2048 = [new Float32Array([0.031249998, 1.1984224E-5]), new Float32Array([0.031249814, 1.0785781E-4]), new Float32Array([0.031249335, 2.0373038E-4]), new Float32Array([0.031248564, 2.9960103E-4]), new Float32Array([0.031247498, 3.9546887E-4]), new Float32Array([0.031246137, 4.9133296E-4]), new Float32Array([0.031244483, 5.871925E-4]), new Float32Array([0.031242535, 6.830464E-4]), new Float32Array([0.031240292, 7.7889394E-4]), new Float32Array([0.031237755, 8.7473413E-4]), new Float32Array([0.031234924, 9.705661E-4]), new Float32Array([0.0312318, 0.0010663889]), new Float32Array([0.03122838, 0.0011622017]), new Float32Array([0.031224668, 0.0012580036]), new Float32Array([0.031220661, 0.0013537935]), new Float32Array([0.031216362, 0.0014495709]), new Float32Array([0.031211767, 0.0015453345]), new Float32Array([0.03120688, 0.0016410836]), new Float32Array([0.031201698, 0.0017368172]), new Float32Array([0.031196224, 0.0018325346]), new Float32Array([0.031190453, 0.0019282346]), new Float32Array([0.031184392, 0.0020239165]), new Float32Array([0.031178035, 0.0021195794]), new Float32Array([0.031171385, 0.0022152222]), new Float32Array([0.031164443, 0.0023108441]), new Float32Array([0.031157207, 0.0024064444]), new Float32Array([0.031149678, 0.002502022]), new Float32Array([0.031141855, 0.0025975762]), new Float32Array([0.03113374, 0.002693106]), new Float32Array([0.03112533, 0.00278861]), new Float32Array([0.031116627, 0.002884088]), new Float32Array([0.031107632, 0.002979539]), new Float32Array([0.031098345, 0.003074962]), new Float32Array([0.031088766, 0.003170356]), new Float32Array([0.031078892, 0.0032657199]), new Float32Array([0.031068727, 0.0033610533]), new Float32Array([0.03105827, 0.0034563548]), new Float32Array([0.03104752, 0.003551624]), new Float32Array([0.031036478, 0.00364686]), new Float32Array([0.031025143, 0.0037420613]), new Float32Array([0.031013517, 0.0038372274]), new Float32Array([0.031001598, 0.0039323573]), new Float32Array([0.030989388, 0.0040274505]), new Float32Array([0.030976886, 0.004122506]), new Float32Array([0.030964091, 0.004217522]), new Float32Array([0.030951008, 0.0043124985]), new Float32Array([0.03093763, 0.0044074347]), new Float32Array([0.030923964, 0.0045023295]), new Float32Array([0.030910006, 0.0045971815]), new Float32Array([0.030895757, 0.0046919906]), new Float32Array([0.030881215, 0.004786755]), new Float32Array([0.030866385, 0.004881475]), new Float32Array([0.030851264, 0.0049761487]), new Float32Array([0.030835852, 0.0050707757]), new Float32Array([0.03082015, 0.005165355]), new Float32Array([0.030804157, 0.0052598855]), new Float32Array([0.030787876, 0.0053543663]), new Float32Array([0.030771304, 0.0054487973]), new Float32Array([0.030754441, 0.0055431766]), new Float32Array([0.03073729, 0.0056375037]), new Float32Array([0.03071985, 0.0057317778]), new Float32Array([0.030702122, 0.0058259983]), new Float32Array([0.030684102, 0.0059201634]), new Float32Array([0.030665796, 0.006014273]), new Float32Array([0.0306472, 0.006108326]), new Float32Array([0.030628316, 0.0062023215]), new Float32Array([0.030609142, 0.006296259]), new Float32Array([0.030589683, 0.0063901367]), new Float32Array([0.030569933, 0.0064839544]), new Float32Array([0.030549897, 0.006577711]), new Float32Array([0.030529574, 0.006671406]), new Float32Array([0.030508962, 0.006765038]), new Float32Array([0.030488063, 0.0068586064]), new Float32Array([0.030466879, 0.00695211]), new Float32Array([0.030445406, 0.0070455484]), new Float32Array([0.030423647, 0.0071389205]), new Float32Array([0.030401602, 0.0072322255]), new Float32Array([0.030379271, 0.007325462]), new Float32Array([0.030356653, 0.0074186297]), new Float32Array([0.030333752, 0.007511728]), new Float32Array([0.030310562, 0.007604755]), new Float32Array([0.030287089, 0.007697711]), new Float32Array([0.03026333, 0.007790594]), new Float32Array([0.030239286, 0.007883404]), new Float32Array([0.030214958, 0.00797614]), new Float32Array([0.030190345, 0.0080688]), new Float32Array([0.030165449, 0.008161386]), new Float32Array([0.030140268, 0.008253893]), new Float32Array([0.030114803, 0.008346323]), new Float32Array([0.030089056, 0.008438675]), new Float32Array([0.030063024, 0.008530947]), new Float32Array([0.03003671, 0.008623139]), new Float32Array([0.030010113, 0.00871525]), new Float32Array([0.029983234, 0.008807278]), new Float32Array([0.029956073, 0.008899224]), new Float32Array([0.02992863, 0.008991086]), new Float32Array([0.029900905, 0.009082864]), new Float32Array([0.029872898, 0.009174556]), new Float32Array([0.02984461, 0.009266161]), new Float32Array([0.02981604, 0.00935768]), new Float32Array([0.029787192, 0.009449109]), new Float32Array([0.029758062, 0.009540451]), new Float32Array([0.029728653, 0.009631703]), new Float32Array([0.029698964, 0.009722863]), new Float32Array([0.029668994, 0.009813933]), new Float32Array([0.029638747, 0.00990491]), new Float32Array([0.029608218, 0.009995794]), new Float32Array([0.029577412, 0.010086584]), new Float32Array([0.029546328, 0.010177278]), new Float32Array([0.029514967, 0.010267877]), new Float32Array([0.029483326, 0.010358379]), new Float32Array([0.029451407, 0.010448785]), new Float32Array([0.029419212, 0.010539091]), new Float32Array([0.02938674, 0.010629298]), new Float32Array([0.029353991, 0.0107194055]), new Float32Array([0.029320966, 0.010809411]), new Float32Array([0.029287666, 0.0108993165]), new Float32Array([0.02925409, 0.010989118]), new Float32Array([0.029220238, 0.011078817]), new Float32Array([0.029186111, 0.011168411]), new Float32Array([0.02915171, 0.0112579]), new Float32Array([0.029117033, 0.011347284]), new Float32Array([0.029082084, 0.01143656]), new Float32Array([0.02904686, 0.011525729]), new Float32Array([0.029011363, 0.011614789]), new Float32Array([0.028975593, 0.01170374]), new Float32Array([0.028939549, 0.011792581]), new Float32Array([0.028903235, 0.0118813105]), new Float32Array([0.028866647, 0.011969929]), new Float32Array([0.028829789, 0.012058434]), new Float32Array([0.028792657, 0.012146826]), new Float32Array([0.028755257, 0.012235103]), new Float32Array([0.028717585, 0.012323265]), new Float32Array([0.028679641, 0.012411311]), new Float32Array([0.028641429, 0.012499241]), new Float32Array([0.028602947, 0.012587053]), new Float32Array([0.028564196, 0.012674746]), new Float32Array([0.028525176, 0.01276232]), new Float32Array([0.028485889, 0.012849774]), new Float32Array([0.028446332, 0.012937107]), new Float32Array([0.028406506, 0.013024318]), new Float32Array([0.028366415, 0.013111407]), new Float32Array([0.028326057, 0.013198372]), new Float32Array([0.02828543, 0.013285213]), new Float32Array([0.02824454, 0.0133719295]), new Float32Array([0.028203381, 0.013458519]), new Float32Array([0.02816196, 0.013544983]), new Float32Array([0.028120272, 0.013631319]), new Float32Array([0.028078318, 0.013717527]), new Float32Array([0.0280361, 0.013803605]), new Float32Array([0.027993621, 0.013889553]), new Float32Array([0.027950877, 0.013975372]), new Float32Array([0.027907869, 0.014061058]), new Float32Array([0.0278646, 0.014146612]), new Float32Array([0.027821066, 0.014232032]), new Float32Array([0.027777273, 0.014317319]), new Float32Array([0.027733216, 0.0144024715]), new Float32Array([0.0276889, 0.014487488]), new Float32Array([0.027644323, 0.014572368]), new Float32Array([0.027599486, 0.014657111]), new Float32Array([0.02755439, 0.014741716]), new Float32Array([0.027509032, 0.014826182]), new Float32Array([0.027463416, 0.014910509]), new Float32Array([0.027417542, 0.014994696]), new Float32Array([0.02737141, 0.015078741]), new Float32Array([0.02732502, 0.015162644]), new Float32Array([0.027278373, 0.015246404]), new Float32Array([0.02723147, 0.015330022]), new Float32Array([0.02718431, 0.015413495]), new Float32Array([0.027136894, 0.015496822]), new Float32Array([0.027089221, 0.015580004]), new Float32Array([0.027041296, 0.015663039]), new Float32Array([0.026993115, 0.015745927]), new Float32Array([0.02694468, 0.015828667]), new Float32Array([0.026895992, 0.015911257]), new Float32Array([0.02684705, 0.015993698]), new Float32Array([0.026797855, 0.01607599]), new Float32Array([0.02674841, 0.016158128]), new Float32Array([0.02669871, 0.016240114]), new Float32Array([0.026648762, 0.01632195]), new Float32Array([0.026598562, 0.016403629]), new Float32Array([0.02654811, 0.016485155]), new Float32Array([0.026497409, 0.016566526]), new Float32Array([0.02644646, 0.016647741]), new Float32Array([0.026395261, 0.0167288]), new Float32Array([0.026343813, 0.0168097]), new Float32Array([0.026292117, 0.016890442]), new Float32Array([0.026240176, 0.016971026]), new Float32Array([0.026187984, 0.01705145]), new Float32Array([0.026135549, 0.017131714]), new Float32Array([0.026082866, 0.017211815]), new Float32Array([0.026029939, 0.017291756]), new Float32Array([0.025976766, 0.017371533]), new Float32Array([0.025923347, 0.017451147]), new Float32Array([0.025869686, 0.017530596]), new Float32Array([0.025815781, 0.017609881]), new Float32Array([0.025761634, 0.017688999]), new Float32Array([0.025707243, 0.017767953]), new Float32Array([0.025652612, 0.017846737]), new Float32Array([0.025597738, 0.017925354]), new Float32Array([0.025542622, 0.018003803]), new Float32Array([0.025487268, 0.018082082]), new Float32Array([0.025431672, 0.01816019]), new Float32Array([0.02537584, 0.01823813]), new Float32Array([0.025319764, 0.018315895]), new Float32Array([0.025263453, 0.018393489]), new Float32Array([0.025206905, 0.01847091]), new Float32Array([0.025150118, 0.018548155]), new Float32Array([0.025093095, 0.018625228]), new Float32Array([0.025035836, 0.018702125]), new Float32Array([0.02497834, 0.018778846]), new Float32Array([0.024920609, 0.01885539]), new Float32Array([0.024862645, 0.018931756]), new Float32Array([0.024804447, 0.019007945]), new Float32Array([0.024746014, 0.019083954]), new Float32Array([0.024687348, 0.019159785]), new Float32Array([0.024628451, 0.019235434]), new Float32Array([0.024569321, 0.019310903]), new Float32Array([0.02450996, 0.019386189]), new Float32Array([0.02445037, 0.019461293]), new Float32Array([0.024390548, 0.019536214]), new Float32Array([0.024330497, 0.01961095]), new Float32Array([0.024270218, 0.019685503]), new Float32Array([0.024209708, 0.019759871]), new Float32Array([0.024148973, 0.019834053]), new Float32Array([0.024088008, 0.019908046]), new Float32Array([0.024026819, 0.019981854]), new Float32Array([0.023965402, 0.020055473]), new Float32Array([0.02390376, 0.020128904]), new Float32Array([0.023841891, 0.020202145]), new Float32Array([0.0237798, 0.020275196]), new Float32Array([0.023717485, 0.020348055]), new Float32Array([0.023654947, 0.020420725]), new Float32Array([0.023592185, 0.0204932]), new Float32Array([0.023529202, 0.020565484]), new Float32Array([0.023465998, 0.020637574]), new Float32Array([0.023402572, 0.02070947]), new Float32Array([0.023338927, 0.02078117]), new Float32Array([0.02327506, 0.020852676]), new Float32Array([0.023210976, 0.020923983]), new Float32Array([0.023146672, 0.020995095]), new Float32Array([0.023082152, 0.02106601]), new Float32Array([0.023017414, 0.021136725]), new Float32Array([0.022952458, 0.021207243]), new Float32Array([0.022887288, 0.02127756]), new Float32Array([0.022821901, 0.021347677]), new Float32Array([0.0227563, 0.021417594]), new Float32Array([0.022690484, 0.021487307]), new Float32Array([0.022624455, 0.02155682]), new Float32Array([0.022558214, 0.02162613]), new Float32Array([0.02249176, 0.021695236]), new Float32Array([0.022425095, 0.021764137]), new Float32Array([0.022358216, 0.021832833]), new Float32Array([0.02229113, 0.021901324]), new Float32Array([0.022223832, 0.02196961]), new Float32Array([0.022156326, 0.022037689]), new Float32Array([0.022088611, 0.02210556]), new Float32Array([0.022020688, 0.022173222]), new Float32Array([0.021952558, 0.022240676]), new Float32Array([0.021884222, 0.022307921]), new Float32Array([0.021815678, 0.022374956]), new Float32Array([0.02174693, 0.02244178]), new Float32Array([0.021677978, 0.022508394]), new Float32Array([0.02160882, 0.022574795]), new Float32Array([0.02153946, 0.022640983]), new Float32Array([0.021469899, 0.02270696]), new Float32Array([0.021400133, 0.02277272]), new Float32Array([0.021330167, 0.022838268]), new Float32Array([0.021259999, 0.0229036]), new Float32Array([0.021189632, 0.022968717]), new Float32Array([0.021119066, 0.023033619]), new Float32Array([0.0210483, 0.023098303]), new Float32Array([0.020977337, 0.02316277]), new Float32Array([0.020906175, 0.023227017]), new Float32Array([0.020834817, 0.023291048]), new Float32Array([0.020763263, 0.023354858]), new Float32Array([0.020691514, 0.023418449]), new Float32Array([0.02061957, 0.02348182]), new Float32Array([0.020547431, 0.023544969]), new Float32Array([0.020475099, 0.023607897]), new Float32Array([0.020402575, 0.023670603]), new Float32Array([0.02032986, 0.023733085]), new Float32Array([0.020256951, 0.023795344]), new Float32Array([0.020183852, 0.02385738]), new Float32Array([0.020110564, 0.023919191]), new Float32Array([0.020037087, 0.023980778]), new Float32Array([0.01996342, 0.024042137]), new Float32Array([0.019889567, 0.02410327]), new Float32Array([0.019815525, 0.024164177]), new Float32Array([0.019741297, 0.024224857]), new Float32Array([0.019666882, 0.024285309]), new Float32Array([0.019592285, 0.024345532]), new Float32Array([0.019517502, 0.024405524]), new Float32Array([0.019442534, 0.024465289]), new Float32Array([0.019367384, 0.024524823]), new Float32Array([0.019292051, 0.024584126]), new Float32Array([0.019216537, 0.024643198]), new Float32Array([0.019140843, 0.024702037]), new Float32Array([0.019064968, 0.024760643]), new Float32Array([0.018988915, 0.024819018]), new Float32Array([0.01891268, 0.024877159]), new Float32Array([0.018836271, 0.024935065]), new Float32Array([0.01875968, 0.024992736]), new Float32Array([0.018682918, 0.025050173]), new Float32Array([0.018605975, 0.025107373]), new Float32Array([0.01852886, 0.025164336]), new Float32Array([0.01845157, 0.025221065]), new Float32Array([0.018374106, 0.025277553]), new Float32Array([0.018296469, 0.025333805]), new Float32Array([0.01821866, 0.02538982]), new Float32Array([0.01814068, 0.025445594]), new Float32Array([0.018062528, 0.025501128]), new Float32Array([0.017984206, 0.025556425]), new Float32Array([0.017905716, 0.025611479]), new Float32Array([0.017827056, 0.025666293]), new Float32Array([0.01774823, 0.025720865]), new Float32Array([0.017669236, 0.025775194]), new Float32Array([0.017590076, 0.025829282]), new Float32Array([0.01751075, 0.025883125]), new Float32Array([0.01743126, 0.025936725]), new Float32Array([0.017351603, 0.025990082]), new Float32Array([0.017271785, 0.026043193]), new Float32Array([0.017191805, 0.026096059]), new Float32Array([0.017111663, 0.02614868]), new Float32Array([0.017031359, 0.026201056]), new Float32Array([0.016950896, 0.026253184]), new Float32Array([0.016870271, 0.026305065]), new Float32Array([0.01678949, 0.026356699]), new Float32Array([0.01670855, 0.026408084]), new Float32Array([0.016627451, 0.02645922]), new Float32Array([0.016546197, 0.026510108]), new Float32Array([0.016464788, 0.026560746]), new Float32Array([0.016383223, 0.026611134]), new Float32Array([0.016301505, 0.026661273]), new Float32Array([0.016219633, 0.026711158]), new Float32Array([0.016137607, 0.026760794]), new Float32Array([0.016055431, 0.026810179]), new Float32Array([0.015973102, 0.02685931]), new Float32Array([0.015890624, 0.026908187]), new Float32Array([0.015807996, 0.026956813]), new Float32Array([0.01572522, 0.027005184]), new Float32Array([0.015642295, 0.027053302]), new Float32Array([0.015559223, 0.027101165]), new Float32Array([0.015476004, 0.027148772]), new Float32Array([0.01539264, 0.027196124]), new Float32Array([0.015309131, 0.02724322]), new Float32Array([0.015225478, 0.02729006]), new Float32Array([0.015141682, 0.027336642]), new Float32Array([0.015057743, 0.027382966]), new Float32Array([0.014973662, 0.027429035]), new Float32Array([0.0148894405, 0.027474845]), new Float32Array([0.0148050785, 0.027520396]), new Float32Array([0.014720578, 0.027565686]), new Float32Array([0.014635938, 0.02761072]), new Float32Array([0.014551161, 0.027655492]), new Float32Array([0.014466247, 0.027700003]), new Float32Array([0.014381196, 0.027744256]), new Float32Array([0.01429601, 0.027788246]), new Float32Array([0.01421069, 0.027831974]), new Float32Array([0.014125235, 0.027875442]), new Float32Array([0.014039649, 0.027918646]), new Float32Array([0.013953929, 0.027961588]), new Float32Array([0.013868079, 0.028004266]), new Float32Array([0.013782097, 0.02804668]), new Float32Array([0.013695987, 0.028088832]), new Float32Array([0.0136097465, 0.028130718]), new Float32Array([0.013523379, 0.02817234]), new Float32Array([0.013436884, 0.028213697]), new Float32Array([0.013350262, 0.028254787]), new Float32Array([0.013263515, 0.028295612]), new Float32Array([0.013176642, 0.028336171]), new Float32Array([0.013089647, 0.028376464]), new Float32Array([0.013002527, 0.028416488]), new Float32Array([0.012915285, 0.028456245]), new Float32Array([0.012827922, 0.028495735]), new Float32Array([0.012740438, 0.028534956]), new Float32Array([0.012652834, 0.02857391]), new Float32Array([0.012565111, 0.028612593]), new Float32Array([0.012477269, 0.028651008]), new Float32Array([0.012389311, 0.028689153]), new Float32Array([0.012301235, 0.028727027]), new Float32Array([0.012213044, 0.028764632]), new Float32Array([0.012124738, 0.028801966]), new Float32Array([0.012036318, 0.028839028]), new Float32Array([0.011947785, 0.02887582]), new Float32Array([0.0118591385, 0.02891234]), new Float32Array([0.011770381, 0.028948586]), new Float32Array([0.011681512, 0.028984562]), new Float32Array([0.011592534, 0.029020263]), new Float32Array([0.011503447, 0.029055692]), new Float32Array([0.01141425, 0.029090848]), new Float32Array([0.011324948, 0.029125728]), new Float32Array([0.011235538, 0.029160336]), new Float32Array([0.011146022, 0.029194668]), new Float32Array([0.011056402, 0.029228726]), new Float32Array([0.010966677, 0.02926251]), new Float32Array([0.010876849, 0.029296018]), new Float32Array([0.01078692, 0.02932925]), new Float32Array([0.010696888, 0.029362205]), new Float32Array([0.0106067555, 0.029394884]), new Float32Array([0.010516523, 0.029427288]), new Float32Array([0.010426193, 0.029459413]), new Float32Array([0.010335763, 0.02949126]), new Float32Array([0.010245237, 0.029522832]), new Float32Array([0.010154613, 0.029554125]), new Float32Array([0.010063895, 0.02958514]), new Float32Array([0.009973082, 0.029615877]), new Float32Array([0.009882174, 0.029646333]), new Float32Array([0.009791174, 0.029676512]), new Float32Array([0.009700082, 0.029706411]), new Float32Array([0.009608898, 0.02973603]), new Float32Array([0.009517624, 0.029765371]), new Float32Array([0.00942626, 0.02979443]), new Float32Array([0.009334808, 0.02982321]), new Float32Array([0.009243268, 0.029851709]), new Float32Array([0.00915164, 0.029879926]), new Float32Array([0.009059927, 0.029907862]), new Float32Array([0.008968129, 0.029935516]), new Float32Array([0.0088762455, 0.02996289]), new Float32Array([0.008784279, 0.02998998]), new Float32Array([0.00869223, 0.03001679]), new Float32Array([0.008600098, 0.030043315]), new Float32Array([0.008507887, 0.030069558]), new Float32Array([0.008415595, 0.03009552]), new Float32Array([0.008323223, 0.030121196]), new Float32Array([0.008230773, 0.03014659]), new Float32Array([0.008138246, 0.0301717]), new Float32Array([0.008045643, 0.030196525]), new Float32Array([0.007952963, 0.030221067]), new Float32Array([0.007860209, 0.030245325]), new Float32Array([0.00776738, 0.030269297]), new Float32Array([0.0076744785, 0.030292984]), new Float32Array([0.007581505, 0.030316386]), new Float32Array([0.00748846, 0.030339504]), new Float32Array([0.0073953443, 0.030362334]), new Float32Array([0.0073021594, 0.030384881]), new Float32Array([0.0072089056, 0.03040714]), new Float32Array([0.007115584, 0.030429114]), new Float32Array([0.007022195, 0.0304508]), new Float32Array([0.00692874, 0.030472202]), new Float32Array([0.0068352204, 0.030493315]), new Float32Array([0.006741636, 0.030514142]), new Float32Array([0.006647988, 0.030534681]), new Float32Array([0.0065542776, 0.030554933]), new Float32Array([0.0064605055, 0.030574897]), new Float32Array([0.006366673, 0.030594574]), new Float32Array([0.00627278, 0.030613963]), new Float32Array([0.006178828, 0.030633064]), new Float32Array([0.0060848184, 0.030651875]), new Float32Array([0.005990751, 0.030670399]), new Float32Array([0.0058966274, 0.030688634]), new Float32Array([0.005802448, 0.03070658]), new Float32Array([0.0057082144, 0.030724239]), new Float32Array([0.005613927, 0.030741606]), new Float32Array([0.0055195866, 0.030758685]), new Float32Array([0.0054251943, 0.030775474]), new Float32Array([0.0053307507, 0.030791974]), new Float32Array([0.0052362573, 0.030808182]), new Float32Array([0.0051417146, 0.030824102]), new Float32Array([0.0050471234, 0.030839732]), new Float32Array([0.0049524847, 0.03085507]), new Float32Array([0.004857799, 0.03087012]), new Float32Array([0.004763068, 0.030884879]), new Float32Array([0.004668292, 0.030899346]), new Float32Array([0.0045734723, 0.030913522]), new Float32Array([0.0044786097, 0.030927408]), new Float32Array([0.0043837046, 0.030941002]), new Float32Array([0.004288758, 0.030954305]), new Float32Array([0.0041937716, 0.030967318]), new Float32Array([0.0040987455, 0.03098004]), new Float32Array([0.004003681, 0.030992467]), new Float32Array([0.0039085783, 0.031004604]), new Float32Array([0.0038134393, 0.03101645]), new Float32Array([0.0037182642, 0.031028004]), new Float32Array([0.0036230541, 0.031039266]), new Float32Array([0.0035278099, 0.031050235]), new Float32Array([0.0034325325, 0.031060912]), new Float32Array([0.0033372228, 0.031071296]), new Float32Array([0.0032418817, 0.031081388]), new Float32Array([0.00314651, 0.031091187]), new Float32Array([0.003051109, 0.031100696]), new Float32Array([0.0029556789, 0.031109909]), new Float32Array([0.002860221, 0.03111883]), new Float32Array([0.0027647365, 0.03112746]), new Float32Array([0.0026692257, 0.031135796]), new Float32Array([0.00257369, 0.031143837]), new Float32Array([0.00247813, 0.031151587]), new Float32Array([0.0023825464, 0.031159043]), new Float32Array([0.0022869406, 0.031166205]), new Float32Array([0.0021913133, 0.031173076]), new Float32Array([0.0020956653, 0.031179652]), new Float32Array([0.0019999978, 0.031185934]), new Float32Array([0.0019043112, 0.031191923]), new Float32Array([0.0018086068, 0.031197619]), new Float32Array([0.0017128853, 0.03120302]), new Float32Array([0.0016171477, 0.03120813]), new Float32Array([0.0015213949, 0.031212945]), new Float32Array([0.0014256279, 0.031217465]), new Float32Array([0.0013298473, 0.031221692]), new Float32Array([0.0012340542, 0.031225624]), new Float32Array([0.0011382495, 0.031229263]), new Float32Array([0.0010424341, 0.031232608]), new Float32Array([9.4660895E-4, 0.03123566]), new Float32Array([8.507748E-4, 0.031238416]), new Float32Array([7.549327E-4, 0.03124088]), new Float32Array([6.590835E-4, 0.031243049]), new Float32Array([5.632281E-4, 0.031244924]), new Float32Array([4.6736735E-4, 0.031246506]), new Float32Array([3.7150222E-4, 0.03124779]), new Float32Array([2.756336E-4, 0.031248784]), new Float32Array([1.7976238E-4, 0.031249482]), new Float32Array([8.388947E-5, 0.031249888])];
    constructor.MDCT_TABLE_128 = [new Float32Array([0.08838793, 2.7117162E-4]), new Float32Array([0.088354655, 0.0024402384]), new Float32Array([0.08826816, 0.0046078353]), new Float32Array([0.08812849, 0.0067726565]), new Float32Array([0.08793574, 0.008933398]), new Float32Array([0.08769002, 0.011088759]), new Float32Array([0.08739147, 0.01323744]), new Float32Array([0.08704029, 0.015378147]), new Float32Array([0.08663668, 0.01750959]), new Float32Array([0.08618088, 0.019630488]), new Float32Array([0.08567317, 0.021739561]), new Float32Array([0.085113846, 0.023835538]), new Float32Array([0.08450326, 0.025917158]), new Float32Array([0.08384177, 0.027983164]), new Float32Array([0.08312978, 0.030032318]), new Float32Array([0.08236771, 0.03206338]), new Float32Array([0.08155603, 0.034075126]), new Float32Array([0.08069522, 0.03606635]), new Float32Array([0.0797858, 0.038035847]), new Float32Array([0.07882833, 0.039982434]), new Float32Array([0.07782337, 0.041904934]), new Float32Array([0.07677153, 0.043802194]), new Float32Array([0.075673446, 0.04567307]), new Float32Array([0.07452978, 0.04751643]), new Float32Array([0.07334123, 0.049331173]), new Float32Array([0.072108485, 0.051116202]), new Float32Array([0.07083231, 0.052870438]), new Float32Array([0.06951348, 0.054592825]), new Float32Array([0.06815276, 0.05628233]), new Float32Array([0.066751, 0.05793793]), new Float32Array([0.06530903, 0.059558634]), new Float32Array([0.063827716, 0.061143458]), new Float32Array([0.062307958, 0.06269145]), new Float32Array([0.060750667, 0.06420168]), new Float32Array([0.059156783, 0.06567325]), new Float32Array([0.057527263, 0.06710525]), new Float32Array([0.055863094, 0.06849682]), new Float32Array([0.05416527, 0.069847144]), new Float32Array([0.05243482, 0.07115539]), new Float32Array([0.05067279, 0.072420776]), new Float32Array([0.048880234, 0.07364254]), new Float32Array([0.047058232, 0.07481994]), new Float32Array([0.045207888, 0.07595227]), new Float32Array([0.043330308, 0.07703885]), new Float32Array([0.04142663, 0.07807902]), new Float32Array([0.039497998, 0.07907217]), new Float32Array([0.037545573, 0.080017686]), new Float32Array([0.035570532, 0.080915]), new Float32Array([0.033574067, 0.08176357]), new Float32Array([0.031557377, 0.08256289]), new Float32Array([0.029521678, 0.08331249]), new Float32Array([0.027468195, 0.08401189]), new Float32Array([0.025398167, 0.084660694]), new Float32Array([0.02331284, 0.0852585]), new Float32Array([0.02121347, 0.08580495]), new Float32Array([0.019101324, 0.08629971]), new Float32Array([0.01697767, 0.08674248]), new Float32Array([0.014843788, 0.08713301]), new Float32Array([0.012700967, 0.08747105]), new Float32Array([0.010550494, 0.08775641]), new Float32Array([0.008393667, 0.0879889]), new Float32Array([0.006231783, 0.08816839]), new Float32Array([0.004066145, 0.08829477]), new Float32Array([0.0018980585, 0.08836797])];
    constructor.MDCT_TABLE_1920 = [new Float32Array([0.032274857, 1.3202404E-5]), new Float32Array([0.03227464, 1.1882137E-4]), new Float32Array([0.032274082, 2.2443906E-4]), new Float32Array([0.032273173, 3.3005435E-4]), new Float32Array([0.03227192, 4.3566612E-4]), new Float32Array([0.032270323, 5.412732E-4]), new Float32Array([0.03226838, 6.468745E-4]), new Float32Array([0.032266088, 7.524689E-4]), new Float32Array([0.032263454, 8.580552E-4]), new Float32Array([0.032260474, 9.636323E-4]), new Float32Array([0.032257147, 0.0010691991]), new Float32Array([0.032253474, 0.0011747545]), new Float32Array([0.032249458, 0.0012802972]), new Float32Array([0.032245096, 0.0013858263]), new Float32Array([0.032240387, 0.0014913405]), new Float32Array([0.032235336, 0.0015968387]), new Float32Array([0.032229938, 0.00170232]), new Float32Array([0.032224193, 0.0018077828]), new Float32Array([0.032218102, 0.0019132263]), new Float32Array([0.03221167, 0.0020186494]), new Float32Array([0.032204892, 0.0021240509]), new Float32Array([0.03219777, 0.0022294295]), new Float32Array([0.0321903, 0.0023347845]), new Float32Array([0.03218249, 0.0024401143]), new Float32Array([0.03217433, 0.002545418]), new Float32Array([0.03216583, 0.0026506945]), new Float32Array([0.03215698, 0.0027559423]), new Float32Array([0.03214779, 0.002861161]), new Float32Array([0.032138254, 0.0029663488]), new Float32Array([0.032128375, 0.0030715049]), new Float32Array([0.032118153, 0.0031766281]), new Float32Array([0.032107584, 0.0032817174]), new Float32Array([0.032096673, 0.0033867715]), new Float32Array([0.03208542, 0.0034917893]), new Float32Array([0.03207382, 0.0035967696]), new Float32Array([0.03206188, 0.0037017115]), new Float32Array([0.032049593, 0.0038066139]), new Float32Array([0.032036964, 0.003911475]), new Float32Array([0.032023992, 0.0040162946]), new Float32Array([0.03201068, 0.004121071]), new Float32Array([0.031997018, 0.004225804]), new Float32Array([0.031983018, 0.004330491]), new Float32Array([0.031968676, 0.004435132]), new Float32Array([0.03195399, 0.0045397254]), new Float32Array([0.031938963, 0.00464427]), new Float32Array([0.031923596, 0.004748765]), new Float32Array([0.031907883, 0.004853209]), new Float32Array([0.03189183, 0.004957601]), new Float32Array([0.031875435, 0.0050619403]), new Float32Array([0.0318587, 0.005166225]), new Float32Array([0.031841625, 0.0052704546]), new Float32Array([0.031824205, 0.0053746277]), new Float32Array([0.031806447, 0.005478743]), new Float32Array([0.031788345, 0.0055827997]), new Float32Array([0.03176991, 0.0056867967]), new Float32Array([0.031751126, 0.005790733]), new Float32Array([0.031732008, 0.005894607]), new Float32Array([0.031712547, 0.005998418]), new Float32Array([0.031692747, 0.0061021647]), new Float32Array([0.031672608, 0.006205846]), new Float32Array([0.03165213, 0.0063094613]), new Float32Array([0.031631313, 0.0064130086]), new Float32Array([0.031610157, 0.0065164873]), new Float32Array([0.031588662, 0.0066198963]), new Float32Array([0.031566832, 0.0067232344]), new Float32Array([0.03154466, 0.0068265004]), new Float32Array([0.03152215, 0.0069296933]), new Float32Array([0.031499304, 0.007032812]), new Float32Array([0.03147612, 0.0071358555]), new Float32Array([0.0314526, 0.0072388225]), new Float32Array([0.031428743, 0.007341712]), new Float32Array([0.03140455, 0.007444523]), new Float32Array([0.03138002, 0.0075472537]), new Float32Array([0.031355154, 0.007649904]), new Float32Array([0.031329952, 0.0077524725]), new Float32Array([0.031304415, 0.007854958]), new Float32Array([0.03127854, 0.007957359]), new Float32Array([0.031252332, 0.008059675]), new Float32Array([0.031225791, 0.008161904]), new Float32Array([0.031198913, 0.008264047]), new Float32Array([0.031171702, 0.0083661005]), new Float32Array([0.031144157, 0.0084680645]), new Float32Array([0.031116279, 0.008569938]), new Float32Array([0.031088067, 0.00867172]), new Float32Array([0.031059522, 0.008773409]), new Float32Array([0.031030646, 0.008875004]), new Float32Array([0.031001436, 0.008976503]), new Float32Array([0.030971894, 0.009077908]), new Float32Array([0.030942021, 0.009179214]), new Float32Array([0.030911816, 0.009280422]), new Float32Array([0.030881282, 0.009381531]), new Float32Array([0.030850416, 0.009482539]), new Float32Array([0.030819219, 0.009583446]), new Float32Array([0.030787691, 0.00968425]), new Float32Array([0.030755835, 0.009784951]), new Float32Array([0.03072365, 0.009885546]), new Float32Array([0.030691134, 0.009986036]), new Float32Array([0.030658292, 0.010086419]), new Float32Array([0.03062512, 0.010186694]), new Float32Array([0.03059162, 0.010286859]), new Float32Array([0.030557793, 0.010386915]), new Float32Array([0.030523637, 0.01048686]), new Float32Array([0.030489156, 0.010586691]), new Float32Array([0.030454349, 0.01068641]), new Float32Array([0.030419214, 0.010786015]), new Float32Array([0.030383755, 0.010885503]), new Float32Array([0.030347968, 0.010984875]), new Float32Array([0.030311858, 0.01108413]), new Float32Array([0.030275423, 0.011183266]), new Float32Array([0.030238664, 0.011282281]), new Float32Array([0.03020158, 0.011381176]), new Float32Array([0.030164175, 0.01147995]), new Float32Array([0.030126445, 0.0115786]), new Float32Array([0.030088393, 0.011677126]), new Float32Array([0.030050019, 0.011775528]), new Float32Array([0.030011322, 0.011873803]), new Float32Array([0.029972306, 0.011971951]), new Float32Array([0.029932966, 0.012069971]), new Float32Array([0.029893307, 0.012167862]), new Float32Array([0.029853327, 0.012265622]), new Float32Array([0.029813029, 0.012363251]), new Float32Array([0.02977241, 0.012460748]), new Float32Array([0.029731473, 0.012558111]), new Float32Array([0.029690217, 0.012655339]), new Float32Array([0.029648645, 0.012752432]), new Float32Array([0.029606754, 0.012849389]), new Float32Array([0.029564546, 0.012946208]), new Float32Array([0.02952202, 0.013042888]), new Float32Array([0.029479181, 0.013139429]), new Float32Array([0.029436024, 0.013235829]), new Float32Array([0.029392552, 0.013332087]), new Float32Array([0.029348766, 0.013428202]), new Float32Array([0.029304665, 0.013524174]), new Float32Array([0.02926025, 0.01362]), new Float32Array([0.029215522, 0.013715681]), new Float32Array([0.029170481, 0.013811215]), new Float32Array([0.029125128, 0.013906601]), new Float32Array([0.029079463, 0.014001838]), new Float32Array([0.029033488, 0.014096925]), new Float32Array([0.028987199, 0.014191861]), new Float32Array([0.028940601, 0.014286646]), new Float32Array([0.028893694, 0.014381277]), new Float32Array([0.028846476, 0.014475754]), new Float32Array([0.02879895, 0.014570076]), new Float32Array([0.028751116, 0.014664243]), new Float32Array([0.028702972, 0.014758252]), new Float32Array([0.028654523, 0.014852103]), new Float32Array([0.028605767, 0.014945795]), new Float32Array([0.028556703, 0.015039327]), new Float32Array([0.028507335, 0.015132697]), new Float32Array([0.02845766, 0.015225907]), new Float32Array([0.028407682, 0.0153189525]), new Float32Array([0.028357398, 0.015411834]), new Float32Array([0.028306812, 0.015504551]), new Float32Array([0.02825592, 0.015597101]), new Float32Array([0.02820473, 0.015689485]), new Float32Array([0.028153235, 0.0157817]), new Float32Array([0.028101439, 0.015873747]), new Float32Array([0.02804934, 0.015965624]), new Float32Array([0.027996944, 0.01605733]), new Float32Array([0.027944246, 0.016148863]), new Float32Array([0.02789125, 0.016240224]), new Float32Array([0.027837954, 0.01633141]), new Float32Array([0.02778436, 0.016422423]), new Float32Array([0.02773047, 0.016513258]), new Float32Array([0.027676282, 0.016603917]), new Float32Array([0.027621798, 0.016694399]), new Float32Array([0.027567018, 0.016784701]), new Float32Array([0.027511943, 0.016874824]), new Float32Array([0.027456572, 0.016964767]), new Float32Array([0.027400909, 0.017054526]), new Float32Array([0.027344951, 0.017144104]), new Float32Array([0.027288701, 0.017233498]), new Float32Array([0.027232159, 0.017322708]), new Float32Array([0.027175324, 0.017411733]), new Float32Array([0.027118199, 0.01750057]), new Float32Array([0.027060783, 0.01758922]), new Float32Array([0.027003078, 0.017677682]), new Float32Array([0.026945084, 0.017765954]), new Float32Array([0.0268868, 0.017854037]), new Float32Array([0.02682823, 0.017941928]), new Float32Array([0.026769372, 0.018029626]), new Float32Array([0.026710225, 0.018117134]), new Float32Array([0.026650794, 0.018204445]), new Float32Array([0.026591077, 0.018291561]), new Float32Array([0.026531076, 0.018378483]), new Float32Array([0.026470792, 0.018465206]), new Float32Array([0.026410222, 0.018551733]), new Float32Array([0.026349371, 0.018638061]), new Float32Array([0.026288237, 0.01872419]), new Float32Array([0.026226822, 0.018810118]), new Float32Array([0.026165126, 0.018895842]), new Float32Array([0.026103148, 0.018981367]), new Float32Array([0.026040893, 0.019066688]), new Float32Array([0.025978358, 0.019151803]), new Float32Array([0.025915544, 0.019236716]), new Float32Array([0.025852455, 0.019321421]), new Float32Array([0.025789086, 0.019405918]), new Float32Array([0.025725443, 0.019490208]), new Float32Array([0.025661524, 0.01957429]), new Float32Array([0.02559733, 0.019658163]), new Float32Array([0.025532862, 0.019741824]), new Float32Array([0.02546812, 0.019825274]), new Float32Array([0.025403107, 0.019908514]), new Float32Array([0.025337819, 0.019991538]), new Float32Array([0.025272261, 0.020074349]), new Float32Array([0.025206434, 0.020156944]), new Float32Array([0.025140336, 0.020239323]), new Float32Array([0.025073968, 0.020321487]), new Float32Array([0.025007332, 0.020403432]), new Float32Array([0.024940427, 0.020485159]), new Float32Array([0.024873257, 0.020566666]), new Float32Array([0.02480582, 0.020647954]), new Float32Array([0.024738116, 0.02072902]), new Float32Array([0.024670148, 0.020809865]), new Float32Array([0.024601916, 0.020890485]), new Float32Array([0.02453342, 0.020970883]), new Float32Array([0.024464663, 0.021051057]), new Float32Array([0.024395643, 0.021131003]), new Float32Array([0.02432636, 0.021210724]), new Float32Array([0.024256818, 0.021290218]), new Float32Array([0.024187017, 0.021369485]), new Float32Array([0.024116956, 0.021448523]), new Float32Array([0.024046637, 0.02152733]), new Float32Array([0.02397606, 0.021605907]), new Float32Array([0.023905227, 0.021684252]), new Float32Array([0.023834137, 0.021762365]), new Float32Array([0.023762792, 0.021840246]), new Float32Array([0.023691194, 0.021917893]), new Float32Array([0.02361934, 0.021995304]), new Float32Array([0.023547234, 0.022072481]), new Float32Array([0.023474876, 0.022149421]), new Float32Array([0.023402268, 0.022226123]), new Float32Array([0.023329407, 0.022302588]), new Float32Array([0.023256298, 0.022378813]), new Float32Array([0.023182938, 0.0224548]), new Float32Array([0.023109332, 0.022530545]), new Float32Array([0.023035476, 0.022606049]), new Float32Array([0.022961376, 0.022681313]), new Float32Array([0.022887029, 0.02275633]), new Float32Array([0.022812435, 0.022831107]), new Float32Array([0.0227376, 0.022905638]), new Float32Array([0.022662519, 0.022979924]), new Float32Array([0.022587197, 0.023053963]), new Float32Array([0.022511631, 0.023127757]), new Float32Array([0.022435825, 0.023201302]), new Float32Array([0.02235978, 0.023274599]), new Float32Array([0.022283494, 0.023347646]), new Float32Array([0.02220697, 0.023420444]), new Float32Array([0.022130208, 0.02349299]), new Float32Array([0.022053208, 0.023565285]), new Float32Array([0.021975974, 0.023637328]), new Float32Array([0.021898502, 0.023709117]), new Float32Array([0.021820799, 0.023780653]), new Float32Array([0.02174286, 0.023851933]), new Float32Array([0.021664688, 0.02392296]), new Float32Array([0.021586284, 0.023993729]), new Float32Array([0.021507649, 0.024064241]), new Float32Array([0.021428784, 0.024134494]), new Float32Array([0.02134969, 0.02420449]), new Float32Array([0.021270366, 0.024274228]), new Float32Array([0.021190817, 0.024343705]), new Float32Array([0.021111038, 0.024412923]), new Float32Array([0.021031033, 0.024481876]), new Float32Array([0.020950805, 0.024550568]), new Float32Array([0.02087035, 0.024618998]), new Float32Array([0.020789674, 0.024687165]), new Float32Array([0.020708775, 0.024755066]), new Float32Array([0.020627653, 0.024822703]), new Float32Array([0.02054631, 0.024890075]), new Float32Array([0.020464748, 0.024957178]), new Float32Array([0.020382967, 0.025024015]), new Float32Array([0.020300966, 0.025090585]), new Float32Array([0.020218749, 0.025156885]), new Float32Array([0.020136315, 0.025222916]), new Float32Array([0.020053666, 0.025288677]), new Float32Array([0.0199708, 0.025354166]), new Float32Array([0.019887723, 0.025419384]), new Float32Array([0.019804433, 0.025484331]), new Float32Array([0.019720929, 0.025549004]), new Float32Array([0.019637214, 0.025613405]), new Float32Array([0.01955329, 0.02567753]), new Float32Array([0.019469157, 0.02574138]), new Float32Array([0.019384814, 0.025804954]), new Float32Array([0.019300263, 0.025868252]), new Float32Array([0.019215506, 0.025931275]), new Float32Array([0.019130545, 0.025994018]), new Float32Array([0.019045377, 0.026056483]), new Float32Array([0.018960005, 0.02611867]), new Float32Array([0.018874431, 0.026180577]), new Float32Array([0.018788654, 0.026242202]), new Float32Array([0.018702677, 0.026303547]), new Float32Array([0.018616498, 0.02636461]), new Float32Array([0.018530121, 0.026425391]), new Float32Array([0.018443543, 0.02648589]), new Float32Array([0.01835677, 0.026546104]), new Float32Array([0.018269802, 0.026606034]), new Float32Array([0.018182635, 0.02666568]), new Float32Array([0.018095275, 0.026725039]), new Float32Array([0.01800772, 0.026784113]), new Float32Array([0.017919973, 0.0268429]), new Float32Array([0.017832035, 0.026901398]), new Float32Array([0.017743904, 0.02695961]), new Float32Array([0.017655585, 0.027017532]), new Float32Array([0.017567076, 0.027075164]), new Float32Array([0.017478378, 0.027132507]), new Float32Array([0.017389493, 0.02718956]), new Float32Array([0.017300423, 0.02724632]), new Float32Array([0.017211167, 0.02730279]), new Float32Array([0.017121727, 0.027358968]), new Float32Array([0.017032104, 0.027414853]), new Float32Array([0.016942298, 0.027470443]), new Float32Array([0.01685231, 0.02752574]), new Float32Array([0.016762143, 0.02758074]), new Float32Array([0.016671795, 0.027635446]), new Float32Array([0.016581269, 0.027689857]), new Float32Array([0.016490566, 0.027743971]), new Float32Array([0.016399685, 0.027797787]), new Float32Array([0.01630863, 0.027851306]), new Float32Array([0.0162174, 0.027904527]), new Float32Array([0.016125996, 0.027957449]), new Float32Array([0.016034419, 0.02801007]), new Float32Array([0.01594267, 0.028062394]), new Float32Array([0.01585075, 0.028114416]), new Float32Array([0.015758662, 0.028166136]), new Float32Array([0.015666405, 0.028217556]), new Float32Array([0.015573979, 0.028268673]), new Float32Array([0.015481387, 0.028319487]), new Float32Array([0.015388629, 0.028369997]), new Float32Array([0.015295706, 0.028420204]), new Float32Array([0.015202619, 0.028470108]), new Float32Array([0.01510937, 0.028519705]), new Float32Array([0.015015959, 0.028568998]), new Float32Array([0.014922387, 0.028617984]), new Float32Array([0.014828655, 0.028666664]), new Float32Array([0.014734765, 0.028715037]), new Float32Array([0.014640716, 0.028763102]), new Float32Array([0.014546511, 0.02881086]), new Float32Array([0.014452149, 0.02885831]), new Float32Array([0.014357634, 0.02890545]), new Float32Array([0.014262964, 0.02895228]), new Float32Array([0.014168141, 0.0289988]), new Float32Array([0.014073168, 0.02904501]), new Float32Array([0.013978043, 0.02909091]), new Float32Array([0.013882768, 0.029136496]), new Float32Array([0.013787345, 0.029181771]), new Float32Array([0.013691775, 0.029226733]), new Float32Array([0.013596057, 0.029271383]), new Float32Array([0.013500194, 0.02931572]), new Float32Array([0.013404187, 0.029359741]), new Float32Array([0.013308035, 0.02940345]), new Float32Array([0.013211742, 0.029446842]), new Float32Array([0.013115306, 0.02948992]), new Float32Array([0.013018731, 0.029532682]), new Float32Array([0.012922016, 0.029575128]), new Float32Array([0.012825162, 0.029617256]), new Float32Array([0.012728171, 0.029659068]), new Float32Array([0.012631045, 0.029700562]), new Float32Array([0.012533782, 0.029741738]), new Float32Array([0.012436386, 0.029782595]), new Float32Array([0.012338856, 0.029823134]), new Float32Array([0.012241194, 0.029863352]), new Float32Array([0.012143401, 0.029903252]), new Float32Array([0.012045478, 0.029942831]), new Float32Array([0.011947426, 0.02998209]), new Float32Array([0.011849246, 0.030021027]), new Float32Array([0.011750939, 0.030059641]), new Float32Array([0.011652507, 0.030097935]), new Float32Array([0.01155395, 0.030135907]), new Float32Array([0.011455269, 0.030173557]), new Float32Array([0.011356465, 0.030210882]), new Float32Array([0.011257539, 0.030247884]), new Float32Array([0.011158492, 0.030284563]), new Float32Array([0.011059327, 0.030320916]), new Float32Array([0.010960043, 0.030356945]), new Float32Array([0.0108606415, 0.030392649]), new Float32Array([0.010761124, 0.030428028]), new Float32Array([0.010661491, 0.03046308]), new Float32Array([0.010561744, 0.030497806]), new Float32Array([0.010461884, 0.030532207]), new Float32Array([0.010361912, 0.030566279]), new Float32Array([0.010261828, 0.030600024]), new Float32Array([0.0101616355, 0.030633444]), new Float32Array([0.010061333, 0.030666532]), new Float32Array([0.009960923, 0.030699294]), new Float32Array([0.009860408, 0.030731726]), new Float32Array([0.009759786, 0.030763831]), new Float32Array([0.009659058, 0.030795604]), new Float32Array([0.009558229, 0.03082705]), new Float32Array([0.009457297, 0.030858163]), new Float32Array([0.009356263, 0.030888947]), new Float32Array([0.009255129, 0.0309194]), new Float32Array([0.009153896, 0.030949522]), new Float32Array([0.009052565, 0.030979311]), new Float32Array([0.008951138, 0.03100877]), new Float32Array([0.008849614, 0.031037897]), new Float32Array([0.008747996, 0.03106669]), new Float32Array([0.008646283, 0.03109515]), new Float32Array([0.008544479, 0.03112328]), new Float32Array([0.008442583, 0.031151075]), new Float32Array([0.008340595, 0.031178536]), new Float32Array([0.00823852, 0.031205663]), new Float32Array([0.008136355, 0.031232458]), new Float32Array([0.008034104, 0.031258915]), new Float32Array([0.007931766, 0.03128504]), new Float32Array([0.007829344, 0.03131083]), new Float32Array([0.007726838, 0.03133628]), new Float32Array([0.007624249, 0.0313614]), new Float32Array([0.0075215786, 0.031386185]), new Float32Array([0.007418827, 0.03141063]), new Float32Array([0.0073159966, 0.03143474]), new Float32Array([0.0072130878, 0.031458512]), new Float32Array([0.0071101016, 0.031481948]), new Float32Array([0.007007039, 0.03150505]), new Float32Array([0.006903902, 0.03152781]), new Float32Array([0.0068006907, 0.031550232]), new Float32Array([0.0066974065, 0.03157232]), new Float32Array([0.0065940507, 0.031594068]), new Float32Array([0.006490624, 0.031615477]), new Float32Array([0.006387128, 0.03163655]), new Float32Array([0.006283564, 0.031657282]), new Float32Array([0.006179932, 0.031677675]), new Float32Array([0.0060762344, 0.031697728]), new Float32Array([0.0059724716, 0.031717446]), new Float32Array([0.0058686445, 0.031736817]), new Float32Array([0.005764755, 0.031755853]), new Float32Array([0.005660803, 0.03177455]), new Float32Array([0.005556791, 0.031792905]), new Float32Array([0.0054527195, 0.031810917]), new Float32Array([0.0053485897, 0.031828593]), new Float32Array([0.005244402, 0.031845924]), new Float32Array([0.005140159, 0.031862915]), new Float32Array([0.0050358605, 0.031879567]), new Float32Array([0.004931508, 0.031895876]), new Float32Array([0.0048271026, 0.031911843]), new Float32Array([0.004722646, 0.03192747]), new Float32Array([0.004618138, 0.03194275]), new Float32Array([0.0045135813, 0.031957693]), new Float32Array([0.004408976, 0.031972293]), new Float32Array([0.0043043233, 0.03198655]), new Float32Array([0.004199625, 0.032000467]), new Float32Array([0.0040948815, 0.03201404]), new Float32Array([0.0039900937, 0.032027267]), new Float32Array([0.0038852638, 0.032040153]), new Float32Array([0.003780392, 0.032052696]), new Float32Array([0.0036754797, 0.032064896]), new Float32Array([0.003570528, 0.03207675]), new Float32Array([0.0034655381, 0.032088265]), new Float32Array([0.0033605113, 0.032099433]), new Float32Array([0.0032554483, 0.03211026]), new Float32Array([0.0031503504, 0.032120742]), new Float32Array([0.003045219, 0.03213088]), new Float32Array([0.0029400548, 0.032140672]), new Float32Array([0.002834859, 0.03215012]), new Float32Array([0.0027296331, 0.032159224]), new Float32Array([0.0026243778, 0.032167986]), new Float32Array([0.0025190946, 0.0321764]), new Float32Array([0.0024137842, 0.032184474]), new Float32Array([0.002308448, 0.0321922]), new Float32Array([0.002203087, 0.03219958]), new Float32Array([0.0020977026, 0.032206617]), new Float32Array([0.0019922957, 0.03221331]), new Float32Array([0.0018868673, 0.03221966]), new Float32Array([0.0017814188, 0.03222566]), new Float32Array([0.0016759513, 0.03223132]), new Float32Array([0.0015704657, 0.03223663]), new Float32Array([0.0014649634, 0.032241598]), new Float32Array([0.0013594454, 0.032246217]), new Float32Array([0.0012539128, 0.032250494]), new Float32Array([0.0011483667, 0.032254424]), new Float32Array([0.0010428084, 0.03225801]), new Float32Array([9.372389E-4, 0.03226125]), new Float32Array([8.316594E-4, 0.032264143]), new Float32Array([7.26071E-4, 0.03226669]), new Float32Array([6.204748E-4, 0.032268897]), new Float32Array([5.1487196E-4, 0.032270756]), new Float32Array([4.0926356E-4, 0.032272268]), new Float32Array([3.0365083E-4, 0.032273434]), new Float32Array([1.9803483E-4, 0.032274254]), new Float32Array([9.24167E-5, 0.03227473])];
    constructor.MDCT_TABLE_240 = [new Float32Array([0.09128661, 2.9873577E-4]), new Float32Array([0.0912475, 0.0026882382]), new Float32Array([0.091145866, 0.005075898]), new Float32Array([0.09098176, 0.007460079]), new Float32Array([0.0907553, 0.009839147]), new Float32Array([0.09046664, 0.012211473]), new Float32Array([0.09011598, 0.014575429]), new Float32Array([0.08970356, 0.016929395]), new Float32Array([0.089229666, 0.01927176]), new Float32Array([0.08869461, 0.021600917]), new Float32Array([0.08809877, 0.023915268]), new Float32Array([0.087442555, 0.02621323]), new Float32Array([0.086726405, 0.028493227]), new Float32Array([0.08595082, 0.030753694]), new Float32Array([0.08511633, 0.032993086]), new Float32Array([0.0842235, 0.035209868]), new Float32Array([0.08327296, 0.037402514]), new Float32Array([0.08226534, 0.03956953]), new Float32Array([0.08120134, 0.041709427]), new Float32Array([0.08008169, 0.04382074]), new Float32Array([0.07890715, 0.045902014]), new Float32Array([0.07767854, 0.047951832]), new Float32Array([0.07639668, 0.04996879]), new Float32Array([0.075062476, 0.051951498]), new Float32Array([0.073676825, 0.053898603]), new Float32Array([0.07224067, 0.055808768]), new Float32Array([0.07075501, 0.05768068]), new Float32Array([0.06922086, 0.059513066]), new Float32Array([0.06763928, 0.061304666]), new Float32Array([0.066011325, 0.06305425]), new Float32Array([0.06433814, 0.06476062]), new Float32Array([0.062620856, 0.0664226]), new Float32Array([0.060860656, 0.06803906]), new Float32Array([0.05905875, 0.06960889]), new Float32Array([0.05721636, 0.07113101]), new Float32Array([0.05533476, 0.07260439]), new Float32Array([0.05341524, 0.07402801]), new Float32Array([0.051459108, 0.07540089]), new Float32Array([0.04946771, 0.07672209]), new Float32Array([0.047442406, 0.07799071]), new Float32Array([0.04538459, 0.079205886]), new Float32Array([0.04329567, 0.080366775]), new Float32Array([0.041177075, 0.08147258]), new Float32Array([0.03903026, 0.082522556]), new Float32Array([0.0368567, 0.08351597]), new Float32Array([0.034657877, 0.084452145]), new Float32Array([0.032435298, 0.08533044]), new Float32Array([0.030190494, 0.08615026]), new Float32Array([0.027924998, 0.08691104]), new Float32Array([0.025640363, 0.08761224]), new Float32Array([0.023338156, 0.08825341]), new Float32Array([0.021019952, 0.088834085]), new Float32Array([0.018687345, 0.08935388]), new Float32Array([0.016341928, 0.08981244]), new Float32Array([0.0139853135, 0.09020945]), new Float32Array([0.011619112, 0.090544626]), new Float32Array([0.00924495, 0.09081775]), new Float32Array([0.0068644495, 0.09102864]), new Float32Array([0.0044792453, 0.091177136]), new Float32Array([0.0020909712, 0.091263145])];
}, {MDCT_TABLE_2048: "Array", MDCT_TABLE_128: "Array", MDCT_TABLE_1920: "Array", MDCT_TABLE_240: "Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  Inverse quantization lookup table for all possible values
 *  from 0<sup>4/3</sup> to 8191<sup>4/3</sup>.
 *  @author in-somnia
 */
var IQTable = function() {};
IQTable = stjs.extend(IQTable, null, [], function(constructor, prototype) {
    constructor.IQ_TABLE = new Float32Array([0.0, 1.0, 2.5198421, 4.326749, 6.349604, 8.54988, 10.902723, 13.390518, 16.0, 18.720755, 21.544348, 24.463781, 27.473143, 30.56735, 33.741993, 36.99318, 40.317474, 43.71179, 47.173344, 50.69963, 54.288353, 57.93741, 61.644867, 65.40894, 69.22798, 73.10044, 77.024895, 81.0, 85.02449, 89.09719, 93.21697, 97.3828, 101.593666, 105.84863, 110.146805, 114.48732, 118.869385, 123.292206, 127.755066, 132.25725, 136.79808, 141.3769, 145.99312, 150.64612, 155.33533, 160.0602, 164.8202, 169.61482, 174.44357, 179.30598, 184.20157, 189.12991, 194.09058, 199.08315, 204.10721, 209.16238, 214.24829, 219.36456, 224.51085, 229.68678, 234.89206, 240.12633, 245.38928, 250.6806, 256.0, 261.34717, 266.72183, 272.12372, 277.55255, 283.00806, 288.48996, 293.99805, 299.53207, 305.09177, 310.6769, 316.28726, 321.9226, 327.5827, 333.26736, 338.97638, 344.70956, 350.46664, 356.24747, 362.05188, 367.8796, 373.73053, 379.60443, 385.50113, 391.4205, 397.3623, 403.32642, 409.31268, 415.3209, 421.3509, 427.4026, 433.47574, 439.57028, 445.68597, 451.82275, 457.98044, 464.15887, 470.35797, 476.57755, 482.81747, 489.0776, 495.35788, 501.65808, 507.97815, 514.31793, 520.6773, 527.0562, 533.4544, 539.8719, 546.3085, 552.76404, 559.2386, 565.7319, 572.2439, 578.7744, 585.3235, 591.89087, 598.47656, 605.08044, 611.70233, 618.3422, 625.0, 631.67554, 638.3688, 645.0796, 651.80786, 658.5536, 665.31665, 672.0969, 678.89435, 685.7088, 692.5403, 699.3886, 706.2537, 713.1356, 720.0341, 726.94916, 733.88074, 740.8287, 747.79297, 754.7735, 761.77026, 768.7831, 775.8119, 782.85675, 789.9174, 796.9939, 804.0862, 811.1941, 818.3176, 825.45667, 832.6112, 839.7812, 846.96643, 854.167, 861.38275, 868.61365, 875.8596, 883.1206, 890.39655, 897.6874, 904.9931, 912.31354, 919.6487, 926.99854, 934.3629, 941.7419, 949.1354, 956.5432, 963.96545, 971.40204, 978.85284, 986.3179, 993.797, 1001.2903, 1008.7976, 1016.3189, 1023.8542, 1031.4033, 1038.9663, 1046.5431, 1054.1335, 1061.7378, 1069.3556, 1076.987, 1084.632, 1092.2904, 1099.9624, 1107.6477, 1115.3463, 1123.0583, 1130.7836, 1138.522, 1146.2737, 1154.0383, 1161.8162, 1169.607, 1177.411, 1185.2278, 1193.0575, 1200.9001, 1208.7555, 1216.6238, 1224.5048, 1232.3983, 1240.3047, 1248.2236, 1256.1552, 1264.0991, 1272.0558, 1280.0248, 1288.0062, 1296.0, 1304.0062, 1312.0247, 1320.0554, 1328.0984, 1336.1536, 1344.2208, 1352.3003, 1360.3918, 1368.4955, 1376.6111, 1384.7386, 1392.8782, 1401.0295, 1409.1929, 1417.368, 1425.555, 1433.7538, 1441.9642, 1450.1864, 1458.4202, 1466.6656, 1474.9227, 1483.1914, 1491.4716, 1499.7633, 1508.0665, 1516.3811, 1524.7072, 1533.0446, 1541.3933, 1549.7534, 1558.1248, 1566.5074, 1574.9014, 1583.3064, 1591.7227, 1600.15, 1608.5885, 1617.0381, 1625.4987, 1633.9703, 1642.453, 1650.9465, 1659.4512, 1667.9666, 1676.4929, 1685.0302, 1693.5781, 1702.137, 1710.7065, 1719.2869, 1727.8779, 1736.4797, 1745.092, 1753.7152, 1762.3489, 1770.993, 1779.648, 1788.3132, 1796.9891, 1805.6754, 1814.3722, 1823.0795, 1831.7971, 1840.5251, 1849.2635, 1858.0123, 1866.7714, 1875.5406, 1884.3202, 1893.1101, 1901.9102, 1910.7203, 1919.5408, 1928.3712, 1937.2119, 1946.0627, 1954.9236, 1963.7944, 1972.6753, 1981.5663, 1990.4672, 1999.378, 2008.2988, 2017.2296, 2026.1702, 2035.1207, 2044.081, 2053.0513, 2062.0312, 2071.021, 2080.0205, 2089.0298, 2098.0488, 2107.0776, 2116.116, 2125.164, 2134.2217, 2143.289, 2152.366, 2161.4524, 2170.5486, 2179.654, 2188.7693, 2197.8938, 2207.0278, 2216.1714, 2225.3245, 2234.4868, 2243.6587, 2252.8398, 2262.0305, 2271.2305, 2280.4397, 2289.6582, 2298.886, 2308.123, 2317.3696, 2326.625, 2335.89, 2345.1638, 2354.447, 2363.7395, 2373.041, 2382.3516, 2391.6711, 2401.0, 2410.338, 2419.6848, 2429.0408, 2438.4058, 2447.7798, 2457.1626, 2466.5544, 2475.9553, 2485.3652, 2494.784, 2504.2117, 2513.648, 2523.0935, 2532.5476, 2542.0107, 2551.4824, 2560.9631, 2570.4526, 2579.951, 2589.4578, 2598.9734, 2608.4978, 2618.031, 2627.5728, 2637.1233, 2646.6824, 2656.25, 2665.8264, 2675.4114, 2685.0051, 2694.6072, 2704.218, 2713.8372, 2723.465, 2733.1013, 2742.746, 2752.3994, 2762.0613, 2771.7314, 2781.4102, 2791.0972, 2800.7927, 2810.4966, 2820.209, 2829.9297, 2839.6587, 2849.396, 2859.1416, 2868.8958, 2878.658, 2888.4285, 2898.2075, 2907.9944, 2917.7898, 2927.5935, 2937.4053, 2947.225, 2957.0535, 2966.8896, 2976.7341, 2986.587, 2996.4478, 3006.3167, 3016.1936, 3026.0786, 3035.972, 3045.873, 3055.7825, 3065.6997, 3075.6252, 3085.5586, 3095.5, 3105.4492, 3115.4067, 3125.3718, 3135.3452, 3145.3264, 3155.3154, 3165.3125, 3175.3174, 3185.3303, 3195.351, 3205.3796, 3215.416, 3225.4602, 3235.5122, 3245.5723, 3255.64, 3265.7153, 3275.7986, 3285.8896, 3295.9885, 3306.095, 3316.2092, 3326.331, 3336.4607, 3346.5981, 3356.7432, 3366.896, 3377.0564, 3387.2244, 3397.4, 3407.5833, 3417.7742, 3427.9727, 3438.1787, 3448.3923, 3458.6138, 3468.8425, 3479.0789, 3489.3228, 3499.5742, 3509.833, 3520.0994, 3530.3733, 3540.6548, 3550.9436, 3561.24, 3571.5437, 3581.855, 3592.1736, 3602.4995, 3612.833, 3623.1738, 3633.522, 3643.8777, 3654.2407, 3664.6108, 3674.9885, 3685.3735, 3695.7659, 3706.1655, 3716.5725, 3726.9866, 3737.4082, 3747.837, 3758.273, 3768.7163, 3779.1667, 3789.6245, 3800.0894, 3810.5615, 3821.041, 3831.5276, 3842.0212, 3852.5222, 3863.0303, 3873.5454, 3884.0679, 3894.5974, 3905.134, 3915.6777, 3926.2285, 3936.7864, 3947.3513, 3957.9236, 3968.5027, 3979.0889, 3989.6821, 4000.2825, 4010.8896, 4021.504, 4032.1252, 4042.7537, 4053.389, 4064.0312, 4074.6807, 4085.337, 4096.0, 4106.67, 4117.347, 4128.0312, 4138.722, 4149.42, 4160.1245, 4170.8364, 4181.5547, 4192.2803, 4203.012, 4213.7515, 4224.4976, 4235.25, 4246.01, 4256.7764, 4267.5493, 4278.3296, 4289.116, 4299.91, 4310.7104, 4321.5176, 4332.3315, 4343.1523, 4353.9795, 4364.814, 4375.655, 4386.5024, 4397.3564, 4408.218, 4419.0854, 4429.9595, 4440.841, 4451.7285, 4462.623, 4473.524, 4484.4316, 4495.346, 4506.267, 4517.195, 4528.129, 4539.07, 4550.017, 4560.971, 4571.9316, 4582.899, 4593.8726, 4604.8525, 4615.8394, 4626.833, 4637.833, 4648.8394, 4659.852, 4670.8716, 4681.8975, 4692.93, 4703.9688, 4715.014, 4726.0664, 4737.1245, 4748.1895, 4759.2607, 4770.3384, 4781.4224, 4792.513, 4803.6104, 4814.7134, 4825.823, 4836.9395, 4848.062, 4859.191, 4870.3267, 4881.4683, 4892.616, 4903.7705, 4914.9316, 4926.0986, 4937.272, 4948.4517, 4959.638, 4970.8306, 4982.0293, 4993.234, 5004.4453, 5015.663, 5026.8867, 5038.117, 5049.3535, 5060.596, 5071.8447, 5083.1, 5094.3613, 5105.629, 5116.903, 5128.1826, 5139.469, 5150.7617, 5162.06, 5173.3647, 5184.676, 5195.993, 5207.3164, 5218.646, 5229.9814, 5241.323, 5252.6714, 5264.0254, 5275.3853, 5286.752, 5298.124, 5309.503, 5320.887, 5332.278, 5343.675, 5355.0776, 5366.487, 5377.902, 5389.3228, 5400.75, 5412.183, 5423.622, 5435.0674, 5446.519, 5457.976, 5469.4395, 5480.9087, 5492.3843, 5503.8657, 5515.353, 5526.846, 5538.345, 5549.8506, 5561.362, 5572.879, 5584.4023, 5595.931, 5607.4663, 5619.0073, 5630.554, 5642.107, 5653.6655, 5665.2305, 5676.801, 5688.3774, 5699.9595, 5711.548, 5723.142, 5734.742, 5746.3477, 5757.9595, 5769.577, 5781.2007, 5792.83, 5804.465, 5816.106, 5827.7524, 5839.4053, 5851.0635, 5862.728, 5874.398, 5886.0737, 5897.7554, 5909.443, 5921.1357, 5932.835, 5944.5396, 5956.25, 5967.9663, 5979.6885, 5991.416, 6003.1494, 6014.8887, 6026.634, 6038.3843, 6050.141, 6061.903, 6073.671, 6085.4443, 6097.2236, 6109.0083, 6120.7993, 6132.595, 6144.3975, 6156.205, 6168.018, 6179.8374, 6191.6616, 6203.492, 6215.328, 6227.1694, 6239.0166, 6250.8696, 6262.728, 6274.592, 6286.4614, 6298.337, 6310.218, 6322.104, 6333.996, 6345.894, 6357.797, 6369.7056, 6381.62, 6393.54, 6405.4653, 6417.3965, 6429.333, 6441.2754, 6453.2227, 6465.176, 6477.135, 6489.099, 6501.069, 6513.044, 6525.025, 6537.0107, 6549.003, 6561.0, 6573.003, 6585.0107, 6597.025, 6609.044, 6621.0684, 6633.0986, 6645.1343, 6657.1753, 6669.2217, 6681.2734, 6693.331, 6705.3936, 6717.462, 6729.5356, 6741.6143, 6753.6987, 6765.7886, 6777.8843, 6789.985, 6802.091, 6814.202, 6826.319, 6838.4414, 6850.569, 6862.7017, 6874.8403, 6886.984, 6899.133, 6911.287, 6923.447, 6935.612, 6947.782, 6959.958, 6972.139, 6984.3257, 6996.517, 7008.7144, 7020.9165, 7033.1245, 7045.3374, 7057.5557, 7069.779, 7082.008, 7094.2417, 7106.4814, 7118.726, 7130.9756, 7143.231, 7155.491, 7167.757, 7180.028, 7192.304, 7204.5854, 7216.872, 7229.164, 7241.4614, 7253.7637, 7266.0713, 7278.384, 7290.7017, 7303.025, 7315.3535, 7327.687, 7340.026, 7352.3696, 7364.7188, 7377.073, 7389.4326, 7401.7974, 7414.167, 7426.542, 7438.9224, 7451.3076, 7463.698, 7476.0938, 7488.494, 7500.9004, 7513.311, 7525.7275, 7538.1484, 7550.575, 7563.0063, 7575.443, 7587.885, 7600.3315, 7612.7837, 7625.2407, 7637.7026, 7650.17, 7662.642, 7675.119, 7687.6016, 7700.0894, 7712.5815, 7725.0796, 7737.582, 7750.09, 7762.6025, 7775.12, 7787.643, 7800.171, 7812.704, 7825.2417, 7837.7847, 7850.333, 7862.8857, 7875.444, 7888.007, 7900.5747, 7913.148, 7925.726, 7938.309, 7950.897, 7963.4897, 7976.088, 7988.691, 8001.299, 8013.9116, 8026.5293, 8039.1523, 8051.78, 8064.4126, 8077.0503, 8089.693, 8102.3403, 8114.993, 8127.6504, 8140.313, 8152.98, 8165.6523, 8178.3296, 8191.0117, 8203.698, 8216.391, 8229.087, 8241.789, 8254.495, 8267.207, 8279.923, 8292.645, 8305.37, 8318.102, 8330.837, 8343.578, 8356.323, 8369.074, 8381.829, 8394.59, 8407.3545, 8420.124, 8432.899, 8445.679, 8458.463, 8471.252, 8484.046, 8496.845, 8509.648, 8522.457, 8535.2705, 8548.089, 8560.911, 8573.739, 8586.572, 8599.409, 8612.251, 8625.099, 8637.95, 8650.807, 8663.668, 8676.533, 8689.404, 8702.28, 8715.16, 8728.046, 8740.936, 8753.83, 8766.7295, 8779.634, 8792.542, 8805.456, 8818.374, 8831.297, 8844.225, 8857.157, 8870.095, 8883.037, 8895.983, 8908.935, 8921.891, 8934.852, 8947.817, 8960.787, 8973.763, 8986.742, 8999.727, 9012.715, 9025.709, 9038.707, 9051.71, 9064.718, 9077.73, 9090.747, 9103.769, 9116.795, 9129.826, 9142.861, 9155.902, 9168.947, 9181.996, 9195.051, 9208.109, 9221.173, 9234.241, 9247.313, 9260.391, 9273.473, 9286.56, 9299.65, 9312.746, 9325.847, 9338.952, 9352.062, 9365.176, 9378.295, 9391.418, 9404.546, 9417.679, 9430.815, 9443.957, 9457.104, 9470.254, 9483.41, 9496.569, 9509.734, 9522.903, 9536.077, 9549.255, 9562.438, 9575.625, 9588.817, 9602.014, 9615.215, 9628.42, 9641.63, 9654.845, 9668.063, 9681.287, 9694.515, 9707.747, 9720.984, 9734.227, 9747.473, 9760.723, 9773.978, 9787.237, 9800.502, 9813.7705, 9827.043, 9840.321, 9853.603, 9866.89, 9880.181, 9893.476, 9906.775, 9920.08, 9933.389, 9946.702, 9960.02, 9973.342, 9986.669, 10000.0, 10013.336, 10026.676, 10040.02, 10053.369, 10066.722, 10080.08, 10093.442, 10106.809, 10120.18, 10133.555, 10146.935, 10160.319, 10173.708, 10187.101, 10200.498, 10213.9, 10227.307, 10240.717, 10254.132, 10267.552, 10280.976, 10294.403, 10307.836, 10321.273, 10334.715, 10348.16, 10361.61, 10375.064, 10388.523, 10401.987, 10415.454, 10428.926, 10442.402, 10455.883, 10469.368, 10482.857, 10496.351, 10509.849, 10523.352, 10536.857, 10550.369, 10563.884, 10577.403, 10590.928, 10604.456, 10617.988, 10631.525, 10645.066, 10658.612, 10672.162, 10685.716, 10699.274, 10712.837, 10726.404, 10739.976, 10753.551, 10767.131, 10780.715, 10794.303, 10807.8955, 10821.493, 10835.094, 10848.699, 10862.31, 10875.924, 10889.542, 10903.164, 10916.791, 10930.422, 10944.058, 10957.697, 10971.341, 10984.989, 10998.642, 11012.298, 11025.959, 11039.624, 11053.293, 11066.967, 11080.645, 11094.326, 11108.012, 11121.702, 11135.397, 11149.096, 11162.799, 11176.506, 11190.218, 11203.933, 11217.653, 11231.377, 11245.105, 11258.838, 11272.574, 11286.314, 11300.06, 11313.809, 11327.5625, 11341.319, 11355.081, 11368.847, 11382.617, 11396.392, 11410.17, 11423.952, 11437.738, 11451.529, 11465.324, 11479.123, 11492.927, 11506.734, 11520.546, 11534.361, 11548.181, 11562.005, 11575.833, 11589.665, 11603.502, 11617.342, 11631.187, 11645.035, 11658.889, 11672.745, 11686.606, 11700.472, 11714.341, 11728.214, 11742.092, 11755.974, 11769.859, 11783.749, 11797.643, 11811.541, 11825.442, 11839.349, 11853.259, 11867.174, 11881.092, 11895.015, 11908.94, 11922.871, 11936.806, 11950.745, 11964.6875, 11978.635, 11992.586, 12006.54, 12020.5, 12034.463, 12048.43, 12062.401, 12076.376, 12090.355, 12104.339, 12118.326, 12132.317, 12146.313, 12160.3125, 12174.316, 12188.324, 12202.335, 12216.351, 12230.371, 12244.395, 12258.422, 12272.454, 12286.489, 12300.529, 12314.572, 12328.62, 12342.672, 12356.728, 12370.787, 12384.852, 12398.919, 12412.99, 12427.066, 12441.146, 12455.2295, 12469.317, 12483.409, 12497.505, 12511.6045, 12525.708, 12539.815, 12553.927, 12568.042, 12582.161, 12596.285, 12610.412, 12624.544, 12638.679, 12652.818, 12666.961, 12681.108, 12695.259, 12709.414, 12723.573, 12737.736, 12751.902, 12766.073, 12780.248, 12794.427, 12808.609, 12822.796, 12836.986, 12851.181, 12865.379, 12879.581, 12893.787, 12907.997, 12922.211, 12936.429, 12950.65, 12964.876, 12979.105, 12993.339, 13007.576, 13021.817, 13036.0625, 13050.312, 13064.564, 13078.821, 13093.082, 13107.347, 13121.615, 13135.888, 13150.164, 13164.443, 13178.728, 13193.016, 13207.307, 13221.603, 13235.902, 13250.205, 13264.513, 13278.823, 13293.139, 13307.457, 13321.779, 13336.106, 13350.437, 13364.7705, 13379.108, 13393.45, 13407.796, 13422.1455, 13436.499, 13450.855, 13465.217, 13479.582, 13493.95, 13508.322, 13522.699, 13537.079, 13551.463, 13565.851, 13580.242, 13594.638, 13609.037, 13623.44, 13637.847, 13652.258, 13666.672, 13681.09, 13695.512, 13709.9375, 13724.367, 13738.801, 13753.238, 13767.679, 13782.124, 13796.572, 13811.024, 13825.48, 13839.94, 13854.404, 13868.872, 13883.343, 13897.818, 13912.297, 13926.779, 13941.266, 13955.756, 13970.25, 13984.747, 13999.249, 14013.754, 14028.263, 14042.775, 14057.292, 14071.812, 14086.336, 14100.863, 14115.395, 14129.93, 14144.469, 14159.011, 14173.558, 14188.107, 14202.661, 14217.219, 14231.78, 14246.345, 14260.914, 14275.486, 14290.0625, 14304.642, 14319.226, 14333.8125, 14348.403, 14362.998, 14377.597, 14392.199, 14406.805, 14421.414, 14436.027, 14450.645, 14465.265, 14479.89, 14494.518, 14509.149, 14523.784, 14538.424, 14553.066, 14567.713, 14582.362, 14597.017, 14611.674, 14626.335, 14641.0, 14655.669, 14670.341, 14685.017, 14699.696, 14714.379, 14729.066, 14743.757, 14758.451, 14773.148, 14787.85, 14802.555, 14817.264, 14831.977, 14846.692, 14861.412, 14876.136, 14890.862, 14905.594, 14920.327, 14935.065, 14949.807, 14964.553, 14979.301, 14994.054, 15008.81, 15023.569, 15038.333, 15053.1, 15067.87, 15082.645, 15097.423, 15112.204, 15126.989, 15141.777, 15156.57, 15171.366, 15186.166, 15200.969, 15215.775, 15230.586, 15245.399, 15260.217, 15275.038, 15289.863, 15304.691, 15319.523, 15334.359, 15349.198, 15364.041, 15378.887, 15393.737, 15408.59, 15423.447, 15438.308, 15453.172, 15468.04, 15482.911, 15497.786, 15512.664, 15527.547, 15542.433, 15557.321, 15572.214, 15587.11, 15602.01, 15616.914, 15631.82, 15646.731, 15661.6455, 15676.5625, 15691.484, 15706.409, 15721.337, 15736.269, 15751.204, 15766.144, 15781.086, 15796.031, 15810.981, 15825.934, 15840.891, 15855.851, 15870.814, 15885.781, 15900.752, 15915.727, 15930.704, 15945.686, 15960.67, 15975.658, 15990.65, 16005.6455, 16020.645, 16035.646, 16050.652, 16065.662, 16080.675, 16095.691, 16110.711, 16125.734, 16140.762, 16155.792, 16170.826, 16185.863, 16200.904, 16215.948, 16230.996, 16246.048, 16261.103, 16276.161, 16291.223, 16306.288, 16321.356, 16336.429, 16351.505, 16366.584, 16381.667, 16396.752, 16411.842, 16426.936, 16442.031, 16457.133, 16472.236, 16487.342, 16502.453, 16517.566, 16532.684, 16547.805, 16562.93, 16578.057, 16593.188, 16608.322, 16623.46, 16638.602, 16653.746, 16668.895, 16684.047, 16699.203, 16714.361, 16729.523, 16744.69, 16759.857, 16775.03, 16790.207, 16805.385, 16820.568, 16835.754, 16850.943, 16866.137, 16881.334, 16896.533, 16911.736, 16926.943, 16942.152, 16957.367, 16972.584, 16987.805, 17003.027, 17018.256, 17033.486, 17048.719, 17063.957, 17079.197, 17094.441, 17109.69, 17124.94, 17140.195, 17155.453, 17170.713, 17185.979, 17201.246, 17216.518, 17231.793, 17247.07, 17262.352, 17277.637, 17292.926, 17308.217, 17323.512, 17338.81, 17354.111, 17369.416, 17384.725, 17400.037, 17415.352, 17430.672, 17445.992, 17461.318, 17476.646, 17491.979, 17507.314, 17522.654, 17537.996, 17553.342, 17568.69, 17584.043, 17599.398, 17614.756, 17630.12, 17645.484, 17660.854, 17676.227, 17691.602, 17706.98, 17722.363, 17737.748, 17753.137, 17768.53, 17783.926, 17799.324, 17814.727, 17830.133, 17845.541, 17860.953, 17876.37, 17891.79, 17907.21, 17922.637, 17938.064, 17953.498, 17968.934, 17984.371, 17999.814, 18015.26, 18030.709, 18046.16, 18061.615, 18077.074, 18092.537, 18108.002, 18123.47, 18138.943, 18154.418, 18169.896, 18185.379, 18200.863, 18216.352, 18231.844, 18247.338, 18262.838, 18278.338, 18293.844, 18309.352, 18324.863, 18340.379, 18355.896, 18371.418, 18386.941, 18402.47, 18418.002, 18433.535, 18449.072, 18464.613, 18480.158, 18495.705, 18511.256, 18526.81, 18542.367, 18557.928, 18573.492, 18589.059, 18604.629, 18620.203, 18635.781, 18651.361, 18666.943, 18682.531, 18698.121, 18713.713, 18729.31, 18744.91, 18760.512, 18776.12, 18791.729, 18807.34, 18822.957, 18838.576, 18854.197, 18869.824, 18885.453, 18901.084, 18916.719, 18932.357, 18948.0, 18963.645, 18979.293, 18994.943, 19010.6, 19026.256, 19041.918, 19057.582, 19073.25, 19088.92, 19104.594, 19120.271, 19135.951, 19151.635, 19167.322, 19183.012, 19198.705, 19214.402, 19230.102, 19245.805, 19261.51, 19277.22, 19292.932, 19308.648, 19324.367, 19340.088, 19355.814, 19371.543, 19387.273, 19403.01, 19418.746, 19434.488, 19450.232, 19465.98, 19481.73, 19497.484, 19513.242, 19529.002, 19544.766, 19560.533, 19576.303, 19592.076, 19607.852, 19623.63, 19639.414, 19655.2, 19670.988, 19686.78, 19702.576, 19718.373, 19734.176, 19749.98, 19765.787, 19781.6, 19797.414, 19813.23, 19829.05, 19844.875, 19860.701, 19876.531, 19892.365, 19908.201, 19924.041, 19939.883, 19955.729, 19971.578, 19987.43, 20003.285, 20019.143, 20035.004, 20050.87, 20066.736, 20082.607, 20098.482, 20114.36, 20130.24, 20146.123, 20162.01, 20177.898, 20193.791, 20209.688, 20225.586, 20241.488, 20257.395, 20273.303, 20289.215, 20305.129, 20321.047, 20336.967, 20352.893, 20368.818, 20384.75, 20400.682, 20416.62, 20432.559, 20448.502, 20464.447, 20480.396, 20496.348, 20512.303, 20528.262, 20544.223, 20560.188, 20576.154, 20592.125, 20608.1, 20624.076, 20640.055, 20656.04, 20672.025, 20688.014, 20704.006, 20720.002, 20736.0, 20752.002, 20768.006, 20784.014, 20800.025, 20816.04, 20832.055, 20848.076, 20864.1, 20880.125, 20896.154, 20912.186, 20928.223, 20944.26, 20960.303, 20976.346, 20992.395, 21008.445, 21024.498, 21040.557, 21056.615, 21072.68, 21088.744, 21104.814, 21120.887, 21136.96, 21153.04, 21169.121, 21185.205, 21201.293, 21217.383, 21233.477, 21249.574, 21265.674, 21281.775, 21297.883, 21313.99, 21330.104, 21346.217, 21362.336, 21378.457, 21394.58, 21410.707, 21426.838, 21442.97, 21459.107, 21475.246, 21491.389, 21507.533, 21523.682, 21539.834, 21555.988, 21572.145, 21588.307, 21604.469, 21620.635, 21636.805, 21652.979, 21669.152, 21685.332, 21701.514, 21717.697, 21733.885, 21750.076, 21766.27, 21782.467, 21798.666, 21814.87, 21831.074, 21847.283, 21863.494, 21879.709, 21895.928, 21912.148, 21928.371, 21944.598, 21960.828, 21977.06, 21993.297, 22009.535, 22025.777, 22042.021, 22058.27, 22074.52, 22090.773, 22107.03, 22123.29, 22139.553, 22155.818, 22172.086, 22188.357, 22204.633, 22220.91, 22237.191, 22253.475, 22269.762, 22286.05, 22302.344, 22318.639, 22334.938, 22351.238, 22367.543, 22383.85, 22400.16, 22416.473, 22432.79, 22449.11, 22465.432, 22481.756, 22498.084, 22514.416, 22530.75, 22547.086, 22563.426, 22579.77, 22596.115, 22612.465, 22628.816, 22645.17, 22661.527, 22677.889, 22694.252, 22710.62, 22726.988, 22743.361, 22759.736, 22776.115, 22792.496, 22808.88, 22825.268, 22841.658, 22858.05, 22874.447, 22890.846, 22907.248, 22923.652, 22940.06, 22956.47, 22972.885, 22989.3, 23005.72, 23022.143, 23038.568, 23054.996, 23071.428, 23087.861, 23104.299, 23120.738, 23137.182, 23153.627, 23170.076, 23186.527, 23202.982, 23219.44, 23235.9, 23252.363, 23268.83, 23285.299, 23301.77, 23318.246, 23334.723, 23351.203, 23367.688, 23384.174, 23400.664, 23417.156, 23433.652, 23450.15, 23466.65, 23483.154, 23499.662, 23516.172, 23532.684, 23549.2, 23565.719, 23582.24, 23598.764, 23615.291, 23631.822, 23648.354, 23664.89, 23681.43, 23697.97, 23714.516, 23731.062, 23747.613, 23764.166, 23780.723, 23797.281, 23813.844, 23830.408, 23846.975, 23863.545, 23880.12, 23896.695, 23913.273, 23929.855, 23946.441, 23963.03, 23979.62, 23996.213, 24012.809, 24029.408, 24046.01, 24062.615, 24079.223, 24095.834, 24112.447, 24129.064, 24145.684, 24162.305, 24178.93, 24195.559, 24212.19, 24228.822, 24245.459, 24262.098, 24278.74, 24295.385, 24312.033, 24328.684, 24345.336, 24361.992, 24378.652, 24395.314, 24411.979, 24428.646, 24445.318, 24461.99, 24478.668, 24495.346, 24512.027, 24528.713, 24545.4, 24562.092, 24578.785, 24595.48, 24612.18, 24628.88, 24645.586, 24662.293, 24679.004, 24695.717, 24712.434, 24729.152, 24745.873, 24762.598, 24779.324, 24796.055, 24812.787, 24829.523, 24846.262, 24863.004, 24879.748, 24896.494, 24913.244, 24929.996, 24946.752, 24963.51, 24980.271, 24997.035, 25013.803, 25030.572, 25047.344, 25064.12, 25080.896, 25097.678, 25114.46, 25131.248, 25148.037, 25164.828, 25181.623, 25198.422, 25215.22, 25232.025, 25248.83, 25265.639, 25282.451, 25299.266, 25316.082, 25332.902, 25349.725, 25366.55, 25383.379, 25400.209, 25417.043, 25433.88, 25450.719, 25467.562, 25484.406, 25501.254, 25518.105, 25534.959, 25551.814, 25568.674, 25585.535, 25602.4, 25619.268, 25636.137, 25653.01, 25669.885, 25686.764, 25703.645, 25720.53, 25737.416, 25754.305, 25771.197, 25788.092, 25804.99, 25821.89, 25838.795, 25855.7, 25872.61, 25889.52, 25906.436, 25923.352, 25940.271, 25957.195, 25974.12, 25991.049, 26007.979, 26024.912, 26041.85, 26058.787, 26075.73, 26092.674, 26109.623, 26126.572, 26143.525, 26160.48, 26177.44, 26194.4, 26211.365, 26228.33, 26245.3, 26262.273, 26279.248, 26296.225, 26313.205, 26330.19, 26347.174, 26364.162, 26381.154, 26398.148, 26415.145, 26432.145, 26449.146, 26466.152, 26483.16, 26500.17, 26517.184, 26534.2, 26551.219, 26568.24, 26585.264, 26602.291, 26619.32, 26636.352, 26653.387, 26670.424, 26687.465, 26704.508, 26721.555, 26738.604, 26755.654, 26772.709, 26789.766, 26806.824, 26823.887, 26840.951, 26858.02, 26875.09, 26892.162, 26909.238, 26926.316, 26943.398, 26960.482, 26977.568, 26994.658, 27011.75, 27028.844, 27045.941, 27063.041, 27080.145, 27097.25, 27114.357, 27131.469, 27148.582, 27165.7, 27182.818, 27199.94, 27217.064, 27234.191, 27251.32, 27268.453, 27285.588, 27302.727, 27319.867, 27337.01, 27354.156, 27371.305, 27388.455, 27405.61, 27422.766, 27439.926, 27457.088, 27474.252, 27491.42, 27508.59, 27525.764, 27542.938, 27560.117, 27577.297, 27594.48, 27611.666, 27628.855, 27646.047, 27663.24, 27680.438, 27697.637, 27714.84, 27732.045, 27749.252, 27766.463, 27783.676, 27800.89, 27818.11, 27835.33, 27852.553, 27869.78, 27887.008, 27904.24, 27921.473, 27938.71, 27955.95, 27973.191, 27990.438, 28007.684, 28024.934, 28042.188, 28059.443, 28076.701, 28093.96, 28111.225, 28128.49, 28145.76, 28163.031, 28180.305, 28197.582, 28214.861, 28232.143, 28249.428, 28266.715, 28284.004, 28301.297, 28318.592, 28335.889, 28353.19, 28370.492, 28387.799, 28405.107, 28422.418, 28439.73, 28457.047, 28474.367, 28491.688, 28509.012, 28526.338, 28543.668, 28561.0, 28578.334, 28595.672, 28613.012, 28630.354, 28647.7, 28665.047, 28682.398, 28699.75, 28717.105, 28734.465, 28751.826, 28769.19, 28786.555, 28803.924, 28821.295, 28838.67, 28856.047, 28873.426, 28890.807, 28908.191, 28925.578, 28942.969, 28960.361, 28977.756, 28995.152, 29012.553, 29029.955, 29047.361, 29064.77, 29082.18, 29099.594, 29117.01, 29134.428, 29151.848, 29169.271, 29186.697, 29204.127, 29221.559, 29238.992, 29256.43, 29273.867, 29291.31, 29308.754, 29326.201, 29343.65, 29361.104, 29378.559, 29396.016, 29413.475, 29430.938, 29448.402, 29465.871, 29483.34, 29500.814, 29518.29, 29535.768, 29553.248, 29570.73, 29588.217, 29605.705, 29623.197, 29640.69, 29658.186, 29675.686, 29693.186, 29710.69, 29728.197, 29745.705, 29763.217, 29780.73, 29798.248, 29815.768, 29833.29, 29850.814, 29868.342, 29885.871, 29903.402, 29920.938, 29938.475, 29956.016, 29973.557, 29991.104, 30008.65, 30026.201, 30043.754, 30061.309, 30078.867, 30096.428, 30113.99, 30131.555, 30149.123, 30166.695, 30184.268, 30201.844, 30219.422, 30237.002, 30254.586, 30272.172, 30289.762, 30307.352, 30324.945, 30342.543, 30360.14, 30377.742, 30395.346, 30412.953, 30430.562, 30448.174, 30465.787, 30483.404, 30501.023, 30518.645, 30536.27, 30553.896, 30571.525, 30589.156, 30606.791, 30624.428, 30642.068, 30659.71, 30677.355, 30695.002, 30712.652, 30730.305, 30747.959, 30765.615, 30783.275, 30800.938, 30818.604, 30836.27, 30853.94, 30871.613, 30889.287, 30906.965, 30924.645, 30942.328, 30960.014, 30977.701, 30995.39, 31013.084, 31030.78, 31048.477, 31066.178, 31083.879, 31101.584, 31119.293, 31137.004, 31154.717, 31172.432, 31190.148, 31207.87, 31225.592, 31243.318, 31261.047, 31278.777, 31296.51, 31314.244, 31331.982, 31349.723, 31367.467, 31385.213, 31402.96, 31420.71, 31438.463, 31456.219, 31473.977, 31491.738, 31509.502, 31527.268, 31545.035, 31562.805, 31580.578, 31598.354, 31616.133, 31633.912, 31651.695, 31669.482, 31687.27, 31705.06, 31722.854, 31740.648, 31758.447, 31776.248, 31794.05, 31811.855, 31829.664, 31847.475, 31865.287, 31883.104, 31900.922, 31918.742, 31936.564, 31954.39, 31972.219, 31990.049, 32007.88, 32025.717, 32043.555, 32061.395, 32079.238, 32097.084, 32114.932, 32132.781, 32150.635, 32168.49, 32186.348, 32204.207, 32222.07, 32239.936, 32257.803, 32275.674, 32293.545, 32311.422, 32329.299, 32347.178, 32365.06, 32382.945, 32400.834, 32418.723, 32436.615, 32454.51, 32472.408, 32490.307, 32508.209, 32526.115, 32544.021, 32561.932, 32579.844, 32597.758, 32615.676, 32633.594, 32651.516, 32669.441, 32687.367, 32705.297, 32723.229, 32741.162, 32759.1, 32777.04, 32794.98, 32812.926, 32830.87, 32848.82, 32866.77, 32884.727, 32902.68, 32920.64, 32938.6, 32956.566, 32974.53, 32992.5, 33010.47, 33028.445, 33046.418, 33064.4, 33082.38, 33100.363, 33118.348, 33136.336, 33154.33, 33172.32, 33190.316, 33208.312, 33226.312, 33244.316, 33262.32, 33280.33, 33298.34, 33316.35, 33334.367, 33352.383, 33370.402, 33388.426, 33406.45, 33424.477, 33442.508, 33460.54, 33478.574, 33496.61, 33514.65, 33532.69, 33550.734, 33568.78, 33586.832, 33604.883, 33622.934, 33640.992, 33659.05, 33677.11, 33695.176, 33713.242, 33731.31, 33749.38, 33767.453, 33785.527, 33803.605, 33821.688, 33839.77, 33857.855, 33875.94, 33894.03, 33912.125, 33930.22, 33948.316, 33966.418, 33984.52, 34002.625, 34020.73, 34038.84, 34056.953, 34075.066, 34093.184, 34111.3, 34129.42, 34147.547, 34165.67, 34183.8, 34201.934, 34220.066, 34238.203, 34256.34, 34274.48, 34292.625, 34310.77, 34328.918, 34347.066, 34365.22, 34383.375, 34401.53, 34419.69, 34437.855, 34456.02, 34474.188, 34492.355, 34510.527, 34528.703, 34546.88, 34565.06, 34583.24, 34601.42, 34619.61, 34637.797, 34655.99, 34674.184, 34692.38, 34710.574, 34728.777, 34746.98, 34765.184, 34783.39, 34801.6, 34819.812, 34838.027, 34856.246, 34874.465, 34892.688, 34910.91, 34929.137, 34947.367, 34965.598, 34983.832, 35002.07, 35020.31, 35038.547, 35056.793, 35075.04, 35093.285, 35111.535, 35129.79, 35148.043, 35166.3, 35184.562, 35202.824, 35221.09, 35239.355, 35257.625, 35275.895, 35294.17, 35312.445, 35330.727, 35349.008, 35367.29, 35385.58, 35403.863, 35422.156, 35440.45, 35458.742, 35477.043, 35495.34, 35513.645, 35531.95, 35550.258, 35568.566, 35586.88, 35605.19, 35623.508, 35641.83, 35660.15, 35678.473, 35696.797, 35715.125, 35733.457, 35751.79, 35770.125, 35788.465, 35806.805, 35825.145, 35843.492, 35861.84, 35880.188, 35898.54, 35916.895, 35935.25, 35953.61, 35971.97, 35990.336, 36008.7, 36027.07, 36045.438, 36063.812, 36082.188, 36100.566, 36118.945, 36137.33, 36155.71, 36174.098, 36192.49, 36210.88, 36229.273, 36247.67, 36266.07, 36284.47, 36302.875, 36321.277, 36339.688, 36358.098, 36376.51, 36394.926, 36413.344, 36431.76, 36450.184, 36468.61, 36487.035, 36505.465, 36523.895, 36542.33, 36560.766, 36579.203, 36597.645, 36616.086, 36634.53, 36652.98, 36671.43, 36689.883, 36708.336, 36726.793, 36745.25, 36763.715, 36782.176, 36800.645, 36819.113, 36837.582, 36856.055, 36874.53, 36893.008, 36911.49, 36929.97, 36948.457, 36966.94, 36985.43, 37003.92, 37022.418, 37040.914, 37059.41, 37077.914, 37096.414, 37114.92, 37133.43, 37151.938, 37170.45, 37188.965, 37207.48, 37226.0, 37244.523, 37263.047, 37281.574, 37300.1, 37318.633, 37337.164, 37355.7, 37374.24, 37392.777, 37411.32, 37429.867, 37448.41, 37466.96, 37485.51, 37504.066, 37522.62, 37541.18, 37559.742, 37578.305, 37596.87, 37615.438, 37634.008, 37652.58, 37671.152, 37689.73, 37708.31, 37726.89, 37745.473, 37764.06, 37782.65, 37801.24, 37819.832, 37838.426, 37857.023, 37875.62, 37894.223, 37912.83, 37931.434, 37950.043, 37968.656, 37987.266, 38005.883, 38024.5, 38043.12, 38061.742, 38080.367, 38098.996, 38117.625, 38136.254, 38154.89, 38173.523, 38192.164, 38210.805, 38229.445, 38248.094, 38266.74, 38285.39, 38304.04, 38322.695, 38341.35, 38360.01, 38378.67, 38397.336, 38416.0, 38434.668, 38453.336, 38472.01, 38490.684, 38509.363, 38528.04, 38546.723, 38565.406, 38584.09, 38602.78, 38621.47, 38640.164, 38658.86, 38677.555, 38696.254, 38714.957, 38733.66, 38752.367, 38771.074, 38789.785, 38808.5, 38827.215, 38845.934, 38864.652, 38883.375, 38902.098, 38920.824, 38939.555, 38958.285, 38977.02, 38995.754, 39014.492, 39033.23, 39051.973, 39070.72, 39089.465, 39108.215, 39126.965, 39145.72, 39164.477, 39183.234, 39201.992, 39220.754, 39239.52, 39258.29, 39277.06, 39295.83, 39314.6, 39333.38, 39352.156, 39370.938, 39389.72, 39408.504, 39427.293, 39446.082, 39464.87, 39483.668, 39502.465, 39521.26, 39540.062, 39558.863, 39577.67, 39596.477, 39615.285, 39634.098, 39652.914, 39671.73, 39690.547, 39709.367, 39728.19, 39747.016, 39765.844, 39784.67, 39803.504, 39822.34, 39841.176, 39860.016, 39878.855, 39897.7, 39916.543, 39935.39, 39954.242, 39973.094, 39991.945, 40010.8, 40029.66, 40048.523, 40067.387, 40086.25, 40105.117, 40123.99, 40142.86, 40161.734, 40180.61, 40199.49, 40218.367, 40237.25, 40256.137, 40275.023, 40293.914, 40312.805, 40331.7, 40350.598, 40369.496, 40388.395, 40407.297, 40426.203, 40445.11, 40464.02, 40482.934, 40501.848, 40520.76, 40539.68, 40558.6, 40577.523, 40596.45, 40615.375, 40634.305, 40653.24, 40672.17, 40691.105, 40710.043, 40728.984, 40747.93, 40766.87, 40785.82, 40804.77, 40823.72, 40842.676, 40861.63, 40880.586, 40899.547, 40918.51, 40937.477, 40956.44, 40975.41, 40994.383, 41013.355, 41032.332, 41051.31, 41070.29, 41089.27, 41108.254, 41127.242, 41146.23, 41165.223, 41184.215, 41203.21, 41222.207, 41241.207, 41260.21, 41279.215, 41298.22, 41317.227, 41336.24, 41355.25, 41374.266, 41393.285, 41412.305, 41431.324, 41450.348, 41469.375, 41488.402, 41507.434, 41526.465, 41545.5, 41564.535, 41583.574, 41602.617, 41621.66, 41640.707, 41659.754, 41678.805, 41697.855, 41716.91, 41735.965, 41755.023, 41774.086, 41793.15, 41812.215, 41831.28, 41850.35, 41869.42, 41888.496, 41907.57, 41926.65, 41945.73, 41964.812, 41983.9, 42002.984, 42022.074, 42041.164, 42060.258, 42079.35, 42098.45, 42117.55, 42136.652, 42155.758, 42174.863, 42193.973, 42213.082, 42232.195, 42251.31, 42270.426, 42289.547, 42308.668, 42327.793, 42346.918, 42366.047, 42385.176, 42404.31, 42423.44, 42442.58, 42461.72, 42480.86, 42500.0, 42519.15, 42538.293, 42557.445, 42576.594, 42595.75, 42614.906, 42634.062, 42653.223, 42672.387, 42691.55, 42710.72, 42729.887, 42749.06, 42768.23, 42787.406, 42806.582, 42825.76, 42844.945, 42864.13, 42883.316, 42902.504, 42921.695, 42940.887, 42960.082, 42979.277, 42998.477, 43017.68, 43036.883, 43056.086, 43075.293, 43094.504, 43113.715, 43132.93, 43152.145, 43171.363, 43190.586, 43209.81, 43229.03, 43248.258, 43267.49, 43286.72, 43305.953, 43325.188, 43344.426, 43363.664, 43382.906, 43402.15, 43421.395, 43440.645, 43459.895, 43479.145, 43498.402, 43517.656, 43536.918, 43556.176, 43575.44, 43594.707, 43613.973, 43633.242, 43652.516, 43671.79, 43691.062, 43710.34, 43729.62, 43748.902, 43768.188, 43787.473, 43806.76, 43826.055, 43845.348, 43864.64, 43883.938, 43903.24, 43922.54, 43941.844, 43961.15, 43980.457, 43999.766, 44019.08, 44038.39, 44057.707, 44077.027, 44096.348, 44115.668, 44134.992, 44154.32, 44173.65, 44192.98, 44212.312, 44231.65, 44250.984, 44270.324, 44289.668, 44309.008, 44328.355, 44347.703, 44367.055, 44386.406, 44405.758, 44425.117, 44444.473, 44463.836, 44483.2, 44502.562, 44521.93, 44541.297, 44560.668, 44580.043, 44599.418, 44618.793, 44638.176, 44657.555, 44676.938, 44696.324, 44715.715, 44735.1, 44754.496, 44773.89, 44793.285, 44812.684, 44832.086, 44851.49, 44870.89, 44890.297, 44909.707, 44929.117, 44948.53, 44967.945, 44987.363, 45006.78, 45026.203, 45045.63, 45065.055, 45084.48, 45103.91, 45123.344, 45142.777, 45162.215, 45181.652, 45201.094, 45220.535, 45239.98, 45259.426, 45278.875, 45298.324, 45317.777, 45337.23, 45356.688, 45376.15, 45395.61, 45415.074, 45434.54, 45454.004, 45473.477, 45492.945, 45512.42, 45531.895, 45551.375, 45570.855, 45590.336, 45609.82, 45629.305, 45648.793, 45668.285, 45687.777, 45707.273, 45726.77, 45746.266, 45765.77, 45785.27, 45804.773, 45824.28, 45843.793, 45863.3, 45882.816, 45902.332, 45921.848, 45941.367, 45960.89, 45980.414, 45999.938, 46019.465, 46038.996, 46058.527, 46078.062, 46097.598, 46117.137, 46136.676, 46156.22, 46175.76, 46195.31, 46214.855, 46234.406, 46253.96, 46273.516, 46293.07, 46312.63, 46332.19, 46351.754, 46371.32, 46390.887, 46410.453, 46430.027, 46449.598, 46469.176, 46488.75, 46508.332, 46527.91, 46547.496, 46567.082, 46586.668, 46606.258, 46625.85, 46645.445, 46665.04, 46684.637, 46704.24, 46723.84, 46743.445, 46763.05, 46782.656, 46802.27, 46821.88, 46841.496, 46861.11, 46880.73, 46900.35, 46919.973, 46939.598, 46959.223, 46978.85, 46998.484, 47018.117, 47037.75, 47057.387, 47077.027, 47096.668, 47116.312, 47135.957, 47155.6, 47175.254, 47194.902, 47214.56, 47234.21, 47253.87, 47273.527, 47293.19, 47312.855, 47332.52, 47352.188, 47371.855, 47391.527, 47411.203, 47430.88, 47450.555, 47470.234, 47489.918, 47509.6, 47529.29, 47548.977, 47568.664, 47588.355, 47608.05, 47627.746, 47647.445, 47667.145, 47686.848, 47706.55, 47726.258, 47745.97, 47765.676, 47785.39, 47805.105, 47824.82, 47844.54, 47864.26, 47883.984, 47903.707, 47923.434, 47943.164, 47962.895, 47982.625, 48002.36, 48022.098, 48041.836, 48061.58, 48081.32, 48101.066, 48120.812, 48140.562, 48160.312, 48180.066, 48199.82, 48219.58, 48239.336, 48259.098, 48278.86, 48298.625, 48318.395, 48338.16, 48357.934, 48377.707, 48397.48, 48417.258, 48437.04, 48456.82, 48476.6, 48496.387, 48516.176, 48535.965, 48555.758, 48575.55, 48595.344, 48615.145, 48634.94, 48654.742, 48674.547, 48694.35, 48714.16, 48733.97, 48753.78, 48773.594, 48793.41, 48813.227, 48833.047, 48852.87, 48872.69, 48892.52, 48912.348, 48932.176, 48952.008, 48971.84, 48991.676, 49011.516, 49031.355, 49051.195, 49071.04, 49090.887, 49110.734, 49130.582, 49150.434, 49170.29, 49190.145, 49210.004, 49229.863, 49249.723, 49269.586, 49289.453, 49309.32, 49329.19, 49349.062, 49368.938, 49388.812, 49408.69, 49428.57, 49448.453, 49468.336, 49488.223, 49508.11, 49528.0, 49547.89, 49567.785, 49587.68, 49607.58, 49627.477, 49647.38, 49667.28, 49687.188, 49707.098, 49727.008, 49746.918, 49766.832, 49786.746, 49806.664, 49826.586, 49846.508, 49866.43, 49886.355, 49906.28, 49926.21, 49946.145, 49966.08, 49986.01, 50005.95, 50025.89, 50045.832, 50065.777, 50085.723, 50105.668, 50125.617, 50145.57, 50165.523, 50185.48, 50205.438, 50225.395, 50245.355, 50265.32, 50285.285, 50305.254, 50325.223, 50345.195, 50365.168, 50385.14, 50405.12, 50425.098, 50445.08, 50465.062, 50485.047, 50505.035, 50525.023, 50545.016, 50565.008, 50585.004, 50605.0, 50625.0, 50645.0, 50665.004, 50685.008, 50705.016, 50725.023, 50745.035, 50765.047, 50785.062, 50805.08, 50825.098, 50845.12, 50865.14, 50885.168, 50905.195, 50925.223, 50945.254, 50965.285, 50985.32, 51005.355, 51025.395, 51045.434, 51065.477, 51085.523, 51105.566, 51125.617, 51145.668, 51165.72, 51185.773, 51205.83, 51225.887, 51245.945, 51266.008, 51286.074, 51306.14, 51326.207, 51346.277, 51366.348, 51386.42, 51406.5, 51426.574, 51446.656, 51466.74, 51486.82, 51506.906, 51526.992, 51547.082, 51567.176, 51587.27, 51607.363, 51627.46, 51647.56, 51667.66, 51687.766, 51707.87, 51727.977, 51748.086, 51768.195, 51788.31, 51808.426, 51828.543, 51848.66, 51868.78, 51888.902, 51909.027, 51929.156, 51949.285, 51969.414, 51989.547, 52009.68, 52029.816, 52049.957, 52070.098, 52090.24, 52110.383, 52130.527, 52150.676, 52170.83, 52190.977, 52211.133, 52231.29, 52251.445, 52271.605, 52291.766, 52311.93, 52332.098, 52352.266, 52372.434, 52392.605, 52412.777, 52432.953, 52453.13, 52473.31, 52493.492, 52513.67, 52533.86, 52554.047, 52574.234, 52594.426, 52614.617, 52634.812, 52655.008, 52675.207, 52695.406, 52715.61, 52735.816, 52756.02, 52776.23, 52796.438, 52816.652, 52836.863, 52857.082, 52877.3, 52897.52, 52917.742, 52937.965, 52958.19, 52978.418, 52998.65, 53018.88, 53039.113, 53059.348, 53079.582, 53099.824, 53120.062, 53140.31, 53160.55, 53180.797, 53201.047, 53221.297, 53241.55, 53261.805, 53282.062, 53302.32, 53322.582, 53342.844, 53363.105, 53383.37, 53403.64, 53423.91, 53444.184, 53464.457, 53484.73, 53505.008, 53525.29, 53545.57, 53565.855, 53586.14, 53606.426, 53626.715, 53647.008, 53667.3, 53687.594, 53707.89, 53728.19, 53748.492, 53768.793, 53789.098, 53809.402, 53829.71, 53850.023, 53870.336, 53890.65, 53910.965, 53931.28, 53951.6, 53971.926, 53992.246, 54012.574, 54032.902, 54053.23, 54073.562, 54093.895, 54114.23, 54134.566, 54154.906, 54175.246, 54195.59, 54215.934, 54236.28, 54256.63, 54276.98, 54297.332, 54317.688, 54338.043, 54358.4, 54378.758, 54399.12, 54419.484, 54439.85, 54460.22, 54480.586, 54500.96, 54521.332, 54541.707, 54562.086, 54582.465, 54602.844, 54623.227, 54643.613, 54664.0, 54684.387, 54704.777, 54725.168, 54745.562, 54765.96, 54786.36, 54806.758, 54827.16, 54847.562, 54867.97, 54888.375, 54908.785, 54929.195, 54949.61, 54970.023, 54990.44, 55010.86, 55031.28, 55051.703, 55072.13, 55092.555, 55112.984, 55133.414, 55153.844, 55174.277, 55194.715, 55215.152, 55235.594, 55256.035, 55276.477, 55296.92, 55317.37, 55337.82, 55358.27, 55378.723, 55399.176, 55419.633, 55440.094, 55460.555, 55481.016, 55501.48, 55521.945, 55542.414, 55562.883, 55583.355, 55603.83, 55624.305, 55644.78, 55665.26, 55685.742, 55706.227, 55726.71, 55747.2, 55767.688, 55788.176, 55808.668, 55829.164, 55849.66, 55870.156, 55890.656, 55911.16, 55931.664, 55952.168, 55972.676, 55993.188, 56013.695, 56034.21, 56054.727, 56075.242, 56095.76, 56116.28, 56136.805, 56157.33, 56177.855, 56198.383, 56218.914, 56239.445, 56259.98, 56280.516, 56301.05, 56321.59, 56342.133, 56362.676, 56383.22, 56403.766, 56424.316, 56444.867, 56465.418, 56485.973, 56506.53, 56527.09, 56547.65, 56568.21, 56588.773, 56609.34, 56629.906, 56650.477, 56671.047, 56691.62, 56712.195, 56732.773, 56753.35, 56773.93, 56794.51, 56815.098, 56835.684, 56856.273, 56876.863, 56897.453, 56918.047, 56938.64, 56959.24, 56979.84, 57000.44, 57021.043, 57041.65, 57062.254, 57082.863, 57103.473, 57124.086, 57144.7, 57165.316, 57185.934, 57206.55, 57227.176, 57247.797, 57268.42, 57289.05, 57309.68, 57330.31, 57350.94, 57371.574, 57392.21, 57412.85, 57433.492, 57454.133, 57474.777, 57495.42, 57516.07, 57536.72, 57557.37, 57578.023, 57598.68, 57619.336, 57639.992, 57660.652, 57681.316, 57701.98, 57722.645, 57743.312, 57763.984, 57784.656, 57805.33, 57826.004, 57846.68, 57867.36, 57888.04, 57908.723, 57929.406, 57950.094, 57970.78, 57991.473, 58012.164, 58032.855, 58053.555, 58074.25, 58094.95, 58115.652, 58136.35, 58157.06, 58177.766, 58198.473, 58219.184, 58239.895, 58260.61, 58281.324, 58302.043, 58322.76, 58343.484, 58364.207, 58384.934, 58405.66, 58426.387, 58447.117, 58467.85, 58488.586, 58509.32, 58530.06, 58550.797, 58571.54, 58592.28, 58613.027, 58633.773, 58654.523, 58675.273, 58696.027, 58716.78, 58737.54, 58758.297, 58779.055, 58799.816, 58820.582, 58841.348, 58862.113, 58882.883, 58903.652, 58924.426, 58945.203, 58965.977, 58986.758, 59007.535, 59028.316, 59049.1, 59069.887, 59090.676, 59111.465, 59132.254, 59153.047, 59173.844, 59194.637, 59215.438, 59236.24, 59257.04, 59277.844, 59298.65, 59319.457, 59340.266, 59361.08, 59381.89, 59402.703, 59423.52, 59444.34, 59465.16, 59485.98, 59506.805, 59527.63, 59548.457, 59569.29, 59590.117, 59610.953, 59631.785, 59652.625, 59673.46, 59694.3, 59715.145, 59735.99, 59756.832, 59777.68, 59798.53, 59819.383, 59840.234, 59861.09, 59881.945, 59902.805, 59923.664, 59944.527, 59965.39, 59986.258, 60007.125, 60027.992, 60048.863, 60069.74, 60090.613, 60111.49, 60132.367, 60153.246, 60174.13, 60195.01, 60215.9, 60236.785, 60257.676, 60278.566, 60299.46, 60320.355, 60341.25, 60362.15, 60383.05, 60403.95, 60424.855, 60445.76, 60466.668, 60487.58, 60508.49, 60529.4, 60550.316, 60571.23, 60592.15, 60613.07, 60633.992, 60654.914, 60675.84, 60696.766, 60717.695, 60738.63, 60759.56, 60780.496, 60801.43, 60822.367, 60843.31, 60864.25, 60885.195, 60906.14, 60927.086, 60948.035, 60968.984, 60989.938, 61010.89, 61031.848, 61052.805, 61073.766, 61094.727, 61115.69, 61136.656, 61157.62, 61178.59, 61199.562, 61220.535, 61241.508, 61262.484, 61283.46, 61304.44, 61325.42, 61346.406, 61367.39, 61388.375, 61409.363, 61430.355, 61451.348, 61472.34, 61493.336, 61514.332, 61535.332, 61556.332, 61577.336, 61598.34, 61619.348, 61640.355, 61661.363, 61682.375, 61703.39, 61724.406, 61745.42, 61766.44, 61787.46, 61808.484, 61829.508, 61850.535, 61871.562, 61892.59, 61913.62, 61934.656, 61955.69, 61976.727, 61997.766, 62018.805, 62039.848, 62060.89, 62081.938, 62102.984, 62124.035, 62145.086, 62166.137, 62187.19, 62208.25, 62229.31, 62250.367, 62271.43, 62292.492, 62313.56, 62334.625, 62355.69, 62376.76, 62397.836, 62418.91, 62439.984, 62461.062, 62482.145, 62503.223, 62524.31, 62545.39, 62566.477, 62587.566, 62608.656, 62629.75, 62650.844, 62671.938, 62693.035, 62714.133, 62735.234, 62756.336, 62777.44, 62798.547, 62819.656, 62840.766, 62861.875, 62882.99, 62904.105, 62925.223, 62946.34, 62967.46, 62988.582, 63009.707, 63030.832, 63051.96, 63073.09, 63094.22, 63115.35, 63136.484, 63157.62, 63178.76, 63199.9, 63221.043, 63242.184, 63263.33, 63284.477, 63305.625, 63326.777, 63347.93, 63369.082, 63390.24, 63411.395, 63432.555, 63453.715, 63474.88, 63496.043, 63517.207, 63538.375, 63559.547, 63580.72, 63601.89, 63623.066, 63644.242, 63665.42, 63686.6, 63707.785, 63728.97, 63750.152, 63771.34, 63792.53, 63813.72, 63834.914, 63856.11, 63877.305, 63898.5, 63919.703, 63940.902, 63962.105, 63983.312, 64004.52, 64025.727, 64046.938, 64068.15, 64089.363, 64110.58, 64131.793, 64153.016, 64174.234, 64195.457, 64216.68, 64237.906, 64259.137, 64280.363, 64301.598, 64322.83, 64344.062, 64365.3, 64386.54, 64407.777, 64429.02, 64450.266, 64471.508, 64492.758, 64514.004, 64535.254, 64556.508, 64577.76, 64599.02, 64620.277, 64641.535, 64662.797, 64684.06, 64705.324, 64726.59, 64747.86, 64769.13, 64790.4, 64811.67, 64832.945, 64854.223, 64875.504, 64896.78, 64918.066, 64939.348, 64960.633, 64981.92, 65003.21, 65024.5, 65045.793, 65067.086, 65088.383, 65109.68, 65130.98, 65152.28, 65173.586, 65194.89, 65216.195, 65237.504, 65258.812, 65280.125, 65301.438, 65322.754, 65344.07, 65365.39, 65386.71, 65408.03, 65429.355, 65450.68, 65472.008, 65493.336, 65514.668, 65536.0, 65557.336, 65578.67, 65600.01, 65621.34, 65642.69, 65664.03, 65685.375, 65706.72, 65728.07, 65749.42, 65770.77, 65792.125, 65813.48, 65834.836, 65856.195, 65877.555, 65898.914, 65920.28, 65941.65, 65963.016, 65984.38, 66005.75, 66027.125, 66048.5, 66069.875, 66091.25, 66112.63, 66134.016, 66155.4, 66176.78, 66198.164, 66219.555, 66240.945, 66262.336, 66283.73, 66305.125, 66326.516, 66347.914, 66369.32, 66390.72, 66412.125, 66433.53, 66454.94, 66476.34, 66497.75, 66519.164, 66540.58, 66561.99, 66583.414, 66604.83, 66626.25, 66647.67, 66669.1, 66690.52, 66711.95, 66733.38, 66754.81, 66776.24, 66797.68, 66819.12, 66840.555, 66861.99, 66883.44, 66904.875, 66926.32, 66947.766, 66969.22, 66990.664, 67012.12, 67033.57, 67055.02, 67076.484, 67097.94, 67119.4, 67140.86, 67162.33, 67183.79, 67205.26, 67226.73, 67248.195, 67269.67, 67291.14, 67312.62, 67334.09, 67355.58, 67377.055, 67398.54, 67420.02, 67441.51, 67463.0, 67484.484, 67505.98, 67527.47, 67548.96, 67570.46, 67591.96, 67613.46, 67634.96, 67656.46, 67677.97, 67699.48, 67720.984, 67742.49, 67764.0, 67785.516, 67807.03, 67828.55, 67850.06, 67871.586, 67893.11, 67914.63, 67936.16, 67957.69, 67979.21, 68000.74, 68022.27, 68043.805, 68065.34, 68086.88, 68108.42, 68129.96, 68151.5, 68173.05, 68194.59, 68216.14, 68237.69, 68259.24, 68280.79, 68302.34, 68323.9, 68345.46, 68367.016, 68388.58, 68410.14, 68431.7, 68453.27, 68474.836, 68496.41, 68517.98, 68539.555, 68561.125, 68582.7, 68604.28, 68625.86, 68647.445, 68669.02, 68690.61, 68712.195, 68733.78, 68755.375, 68776.97, 68798.56, 68820.16, 68841.75, 68863.35, 68884.945, 68906.55, 68928.16, 68949.76, 68971.37, 68992.98, 69014.586, 69036.195, 69057.81, 69079.42, 69101.04, 69122.664, 69144.28, 69165.91, 69187.52, 69209.15, 69230.78, 69252.41, 69274.04, 69295.67, 69317.305, 69338.94, 69360.58, 69382.21, 69403.85, 69425.5, 69447.14, 69468.79, 69490.44, 69512.086, 69533.734, 69555.38, 69577.04, 69598.695, 69620.35, 69642.016, 69663.67, 69685.336, 69707.0, 69728.664, 69750.336, 69772.0, 69793.67, 69815.34, 69837.02, 69858.695, 69880.375, 69902.055, 69923.734, 69945.414, 69967.1, 69988.79, 70010.48, 70032.164, 70053.85, 70075.55, 70097.24, 70118.94, 70140.63, 70162.336, 70184.04, 70205.74, 70227.445, 70249.15, 70270.86, 70292.56, 70314.27, 70335.99, 70357.7, 70379.42, 70401.14, 70422.86, 70444.58, 70466.305, 70488.02, 70509.75, 70531.484, 70553.21, 70574.945, 70596.67, 70618.41, 70640.15, 70661.88, 70683.625, 70705.37, 70727.11, 70748.85, 70770.6, 70792.34, 70814.09, 70835.84, 70857.6, 70879.35, 70901.11, 70922.87, 70944.625, 70966.39, 70988.16, 71009.914, 71031.69, 71053.45, 71075.22, 71096.99, 71118.766, 71140.54, 71162.32, 71184.09, 71205.875, 71227.66, 71249.44, 71271.23, 71293.01, 71314.8, 71336.586, 71358.375, 71380.17, 71401.97, 71423.766, 71445.56, 71467.36, 71489.164, 71510.96, 71532.766, 71554.58, 71576.38, 71598.195, 71620.01, 71641.82, 71663.63, 71685.445, 71707.266, 71729.086, 71750.91, 71772.73, 71794.555, 71816.38, 71838.21, 71860.04, 71881.87, 71903.7, 71925.54, 71947.375, 71969.21, 71991.05, 72012.89, 72034.734, 72056.58, 72078.42, 72100.27, 72122.125, 72143.97, 72165.83, 72187.68, 72209.54, 72231.39, 72253.25, 72275.12, 72296.98, 72318.84, 72340.7, 72362.57, 72384.445, 72406.31, 72428.19, 72450.06, 72471.94, 72493.81, 72515.695, 72537.57, 72559.45, 72581.34, 72603.23, 72625.12, 72647.0, 72668.89, 72690.79, 72712.68, 72734.58, 72756.47, 72778.375, 72800.27, 72822.17, 72844.08, 72865.984, 72887.89, 72909.8, 72931.71, 72953.625, 72975.54, 72997.45, 73019.37, 73041.29, 73063.21, 73085.13, 73107.055, 73128.98, 73150.91, 73172.836, 73194.766, 73216.695, 73238.63, 73260.56, 73282.5, 73304.44, 73326.38, 73348.32, 73370.266, 73392.21, 73414.16, 73436.1, 73458.055, 73480.01, 73501.96, 73523.914, 73545.87, 73567.83, 73589.79, 73611.75, 73633.71, 73655.68, 73677.64, 73699.61, 73721.58, 73743.555, 73765.52, 73787.5, 73809.48, 73831.45, 73853.43, 73875.414, 73897.4, 73919.38, 73941.37, 73963.35, 73985.34, 74007.336, 74029.33, 74051.32, 74073.31, 74095.31, 74117.31, 74139.31, 74161.31, 74183.32, 74205.33, 74227.33, 74249.34, 74271.35, 74293.36, 74315.375, 74337.39, 74359.41, 74381.43, 74403.445, 74425.47, 74447.49, 74469.516, 74491.55, 74513.57, 74535.6, 74557.63, 74579.664, 74601.7, 74623.74, 74645.77, 74667.82, 74689.86, 74711.9, 74733.945, 74755.99, 74778.04, 74800.086, 74822.14, 74844.195, 74866.25, 74888.305, 74910.36, 74932.42, 74954.484, 74976.55, 74998.61, 75020.67, 75042.74, 75064.81, 75086.88, 75108.95, 75131.02, 75153.1, 75175.18, 75197.26, 75219.336, 75241.42, 75263.5, 75285.586, 75307.67, 75329.766, 75351.85, 75373.945, 75396.04, 75418.13, 75440.23, 75462.33, 75484.43, 75506.53, 75528.63, 75550.734, 75572.84, 75594.95, 75617.06, 75639.17, 75661.28, 75683.4, 75705.516, 75727.63, 75749.75, 75771.875, 75793.99, 75816.12, 75838.24, 75860.37, 75882.5, 75904.63, 75926.766, 75948.9, 75971.03, 75993.17, 76015.305, 76037.445, 76059.586, 76081.734, 76103.875, 76126.02, 76148.17, 76170.32, 76192.47, 76214.625, 76236.78, 76258.94, 76281.09, 76303.25, 76325.414, 76347.58, 76369.74, 76391.91, 76414.08, 76436.24, 76458.414, 76480.586, 76502.76, 76524.94, 76547.12, 76569.29, 76591.47, 76613.66, 76635.836, 76658.02, 76680.21, 76702.4, 76724.586, 76746.78, 76768.98, 76791.164, 76813.37, 76835.56, 76857.766, 76879.96, 76902.164, 76924.37, 76946.58, 76968.78, 76990.99, 77013.2, 77035.414, 77057.63, 77079.84, 77102.06, 77124.28, 77146.5, 77168.73, 77190.945, 77213.17, 77235.4, 77257.625, 77279.86, 77302.09, 77324.32, 77346.555, 77368.8, 77391.03, 77413.27, 77435.516, 77457.76, 77480.0, 77502.25, 77524.49, 77546.74, 77568.99, 77591.25, 77613.5, 77635.76, 77658.016, 77680.27, 77702.53, 77724.8, 77747.055, 77769.32, 77791.586, 77813.86, 77836.125, 77858.4, 77880.67, 77902.945, 77925.23, 77947.5, 77969.78, 77992.06, 78014.34, 78036.625, 78058.914, 78081.2, 78103.49, 78125.78, 78148.07, 78170.37, 78192.664, 78214.96, 78237.26, 78259.555, 78281.86, 78304.164, 78326.47, 78348.77, 78371.086, 78393.39, 78415.7, 78438.016, 78460.33, 78482.65, 78504.97, 78527.28, 78549.6, 78571.93, 78594.25, 78616.58, 78638.91, 78661.234, 78683.56, 78705.9, 78728.23, 78750.56, 78772.9, 78795.234, 78817.58, 78839.92, 78862.266, 78884.61, 78906.95, 78929.3, 78951.65, 78974.0, 78996.35, 79018.71, 79041.06, 79063.42, 79085.78, 79108.14, 79130.5, 79152.87, 79175.23, 79197.59, 79219.96, 79242.336, 79264.7, 79287.08, 79309.45, 79331.83, 79354.21, 79376.586, 79398.97, 79421.35, 79443.734, 79466.12, 79488.51, 79510.9, 79533.29, 79555.68, 79578.07, 79600.47, 79622.86, 79645.26, 79667.664, 79690.06, 79712.47, 79734.87, 79757.27, 79779.68, 79802.09, 79824.5, 79846.914, 79869.33, 79891.74, 79914.164, 79936.58, 79959.0, 79981.42, 80003.84, 80026.27, 80048.695, 80071.125, 80093.555, 80115.984, 80138.42, 80160.85, 80183.29, 80205.73, 80228.164, 80250.61, 80273.05, 80295.49, 80317.94, 80340.38, 80362.836, 80385.28, 80407.734, 80430.19, 80452.64, 80475.1, 80497.555, 80520.016, 80542.48, 80564.945, 80587.41, 80609.875, 80632.336, 80654.805, 80677.28, 80699.75, 80722.23, 80744.695, 80767.17, 80789.66, 80812.13, 80834.62, 80857.1, 80879.586, 80902.07, 80924.555, 80947.05, 80969.54, 80992.03, 81014.52, 81037.016, 81059.516, 81082.016, 81104.516, 81127.016, 81149.516, 81172.02, 81194.53, 81217.04, 81239.55, 81262.055, 81284.57, 81307.086, 81329.6, 81352.12, 81374.63, 81397.16, 81419.68, 81442.2, 81464.73, 81487.26, 81509.78, 81532.31, 81554.84, 81577.375, 81599.914, 81622.445, 81644.984, 81667.52, 81690.06, 81712.61, 81735.15, 81757.695, 81780.24, 81802.79, 81825.34, 81847.89, 81870.445, 81893.0, 81915.555, 81938.11, 81960.67, 81983.234, 82005.8, 82028.36, 82050.92, 82073.49, 82096.06, 82118.63, 82141.2, 82163.77, 82186.35, 82208.93, 82231.51, 82254.086, 82276.664, 82299.25, 82321.83, 82344.414, 82367.01, 82389.59, 82412.19, 82434.77, 82457.37, 82479.96, 82502.56, 82525.16, 82547.76, 82570.36, 82592.96, 82615.56, 82638.17, 82660.78, 82683.39, 82706.0, 82728.61, 82751.23, 82773.836, 82796.45, 82819.07, 82841.695, 82864.31, 82886.94, 82909.56, 82932.19, 82954.81, 82977.445, 83000.07, 83022.7, 83045.336, 83067.98, 83090.61, 83113.25, 83135.89, 83158.53, 83181.17, 83203.82, 83226.46, 83249.11, 83271.76, 83294.414, 83317.06, 83339.72, 83362.37, 83385.03, 83407.69, 83430.34, 83453.01, 83475.67, 83498.336, 83521.0, 83543.664, 83566.336, 83589.01, 83611.68, 83634.35, 83657.03, 83679.7, 83702.38, 83725.06, 83747.74, 83770.43, 83793.11, 83815.8, 83838.484, 83861.17, 83883.87, 83906.555, 83929.25, 83951.945, 83974.64, 83997.336, 84020.04, 84042.74, 84065.445, 84088.15, 84110.85, 84133.56, 84156.266, 84178.98, 84201.69, 84224.41, 84247.12, 84269.836, 84292.555, 84315.27, 84337.99, 84360.72, 84383.445, 84406.164, 84428.9, 84451.625, 84474.35, 84497.086, 84519.82, 84542.555, 84565.29, 84588.03, 84610.766, 84633.51, 84656.25, 84678.99, 84701.74, 84724.484, 84747.234, 84769.984, 84792.74, 84815.49, 84838.25, 84861.0, 84883.76, 84906.52, 84929.28, 84952.05, 84974.805, 84997.57, 85020.336, 85043.11, 85065.875, 85088.65, 85111.42, 85134.195, 85156.98, 85179.75, 85202.53, 85225.31, 85248.09, 85270.875, 85293.664, 85316.445, 85339.234, 85362.02, 85384.82, 85407.61, 85430.41, 85453.2, 85476.0, 85498.8, 85521.6, 85544.4, 85567.2, 85590.01, 85612.81, 85635.625, 85658.43, 85681.24, 85704.055, 85726.87, 85749.69, 85772.5, 85795.32, 85818.14, 85840.96, 85863.79, 85886.61, 85909.44, 85932.266, 85955.09, 85977.92, 86000.76, 86023.59, 86046.43, 86069.266, 86092.1, 86114.945, 86137.78, 86160.625, 86183.47, 86206.32, 86229.164, 86252.016, 86274.87, 86297.72, 86320.57, 86343.42, 86366.28, 86389.14, 86412.0, 86434.86, 86457.72, 86480.586, 86503.45, 86526.32, 86549.19, 86572.055, 86594.93, 86617.805, 86640.68, 86663.555, 86686.43, 86709.31, 86732.19, 86755.07, 86777.95, 86800.84, 86823.73, 86846.62, 86869.51, 86892.4, 86915.29, 86938.19, 86961.08, 86983.98, 87006.875, 87029.77, 87052.68, 87075.586, 87098.484, 87121.39, 87144.305, 87167.21, 87190.125, 87213.03, 87235.945, 87258.87, 87281.78, 87304.695, 87327.62, 87350.54, 87373.46, 87396.39, 87419.31, 87442.24, 87465.17, 87488.1, 87511.03, 87533.97, 87556.9, 87579.836, 87602.77, 87625.71, 87648.66, 87671.59, 87694.54, 87717.484, 87740.43, 87763.38, 87786.33, 87809.28, 87832.234, 87855.19, 87878.15, 87901.1, 87924.06, 87947.02, 87969.984, 87992.945, 88015.914, 88038.88, 88061.85, 88084.82, 88107.79, 88130.76, 88153.734, 88176.71, 88199.69, 88222.664, 88245.65, 88268.625, 88291.61, 88314.59, 88337.58, 88360.57, 88383.555, 88406.55, 88429.54, 88452.53, 88475.52, 88498.52, 88521.52, 88544.52, 88567.52, 88590.52, 88613.52, 88636.53, 88659.54, 88682.55, 88705.555, 88728.57, 88751.58, 88774.59, 88797.61, 88820.625, 88843.65, 88866.664, 88889.69, 88912.71, 88935.734, 88958.766, 88981.79, 89004.82, 89027.85, 89050.88, 89073.914, 89096.95, 89119.984, 89143.02, 89166.06, 89189.11, 89212.15, 89235.195, 89258.24, 89281.29, 89304.336, 89327.38, 89350.44, 89373.49, 89396.54, 89419.6, 89442.66, 89465.72, 89488.77, 89511.836, 89534.9, 89557.97, 89581.03, 89604.1, 89627.17, 89650.24, 89673.31, 89696.38, 89719.46, 89742.54, 89765.62, 89788.695, 89811.77, 89834.86, 89857.945, 89881.03, 89904.12, 89927.2, 89950.3, 89973.39, 89996.48, 90019.58, 90042.67, 90065.766, 90088.87, 90111.97, 90135.07, 90158.17, 90181.28, 90204.38, 90227.49, 90250.6, 90273.71, 90296.83, 90319.94, 90343.055, 90366.17, 90389.29, 90412.41, 90435.53, 90458.65, 90481.77, 90504.9, 90528.03, 90551.16, 90574.29, 90597.42, 90620.555, 90643.69, 90666.82, 90689.96, 90713.1, 90736.24, 90759.38, 90782.52, 90805.67, 90828.81, 90851.96, 90875.11, 90898.266, 90921.414, 90944.57, 90967.73, 90990.88, 91014.04, 91037.195, 91060.36, 91083.52, 91106.69, 91129.85, 91153.016, 91176.19, 91199.35, 91222.52, 91245.7, 91268.875, 91292.05, 91315.23, 91338.41, 91361.586, 91384.766, 91407.95, 91431.13, 91454.32, 91477.51, 91500.695, 91523.89, 91547.08, 91570.27, 91593.47, 91616.664, 91639.86, 91663.06, 91686.26, 91709.46, 91732.664, 91755.875, 91779.08, 91802.29, 91825.5, 91848.71, 91871.92, 91895.13, 91918.35, 91941.56, 91964.78, 91988.01, 92011.23, 92034.445, 92057.67, 92080.9, 92104.125, 92127.35, 92150.586, 92173.81, 92197.05, 92220.28, 92243.516, 92266.76, 92289.99, 92313.234, 92336.48, 92359.72, 92382.96, 92406.21, 92429.46, 92452.7, 92475.96, 92499.21, 92522.46, 92545.72, 92568.98, 92592.234, 92615.49, 92638.75, 92662.016, 92685.28, 92708.54, 92731.81, 92755.08, 92778.34, 92801.62, 92824.89, 92848.164, 92871.44, 92894.72, 92917.99, 92941.27, 92964.555, 92987.836, 93011.125, 93034.41, 93057.695, 93080.984, 93104.27, 93127.56, 93150.86, 93174.15, 93197.445, 93220.74, 93244.04, 93267.34, 93290.64, 93313.945, 93337.25, 93360.555, 93383.87, 93407.17, 93430.484, 93453.8, 93477.11, 93500.42, 93523.74, 93547.055, 93570.375, 93593.695, 93617.016, 93640.34, 93663.664, 93686.99, 93710.32, 93733.65, 93756.984, 93780.31, 93803.65, 93826.984, 93850.32, 93873.66, 93896.99, 93920.336, 93943.68, 93967.02, 93990.37, 94013.71, 94037.06, 94060.414, 94083.76, 94107.12, 94130.47, 94153.82, 94177.18, 94200.54, 94223.9, 94247.26, 94270.62, 94293.984, 94317.35, 94340.72, 94364.086, 94387.45, 94410.83, 94434.195, 94457.57, 94480.945, 94504.33, 94527.7, 94551.086, 94574.47, 94597.85, 94621.234, 94644.62, 94668.01, 94691.39, 94714.78, 94738.17, 94761.57, 94784.96, 94808.36, 94831.76, 94855.16, 94878.555, 94901.95, 94925.36, 94948.766, 94972.17, 94995.58, 95018.984, 95042.39, 95065.805, 95089.22, 95112.63, 95136.05, 95159.47, 95182.88, 95206.305, 95229.73, 95253.15, 95276.58, 95300.0, 95323.43, 95346.86, 95370.29, 95393.72, 95417.16, 95440.586, 95464.02, 95487.46, 95510.9, 95534.34, 95557.78, 95581.23, 95604.67, 95628.12, 95651.56, 95675.016, 95698.46, 95721.914, 95745.37, 95768.82, 95792.28, 95815.734, 95839.195, 95862.66, 95886.12, 95909.586, 95933.05, 95956.516, 95979.984, 96003.45, 96026.92, 96050.39, 96073.87, 96097.34, 96120.82, 96144.3, 96167.77, 96191.26, 96214.734, 96238.22, 96261.7, 96285.195, 96308.68, 96332.17, 96355.66, 96379.15, 96402.65, 96426.14, 96449.64, 96473.13, 96496.63, 96520.13, 96543.64, 96567.14, 96590.65, 96614.15, 96637.66, 96661.17, 96684.68, 96708.195, 96731.7, 96755.22, 96778.734, 96802.26, 96825.77, 96849.3, 96872.81, 96896.336, 96919.87, 96943.39, 96966.92, 96990.445, 97013.98, 97037.51, 97061.05, 97084.58, 97108.12, 97131.66, 97155.195, 97178.734, 97202.27, 97225.82, 97249.37, 97272.91, 97296.46, 97320.01, 97343.555, 97367.11, 97390.664, 97414.22, 97437.77, 97461.336, 97484.89, 97508.45, 97532.016, 97555.58, 97579.14, 97602.71, 97626.27, 97649.84, 97673.414, 97696.984, 97720.56, 97744.13, 97767.71, 97791.29, 97814.87, 97838.45, 97862.03, 97885.62, 97909.2, 97932.79, 97956.375, 97979.96, 98003.555, 98027.15, 98050.734, 98074.336, 98097.93, 98121.52, 98145.125, 98168.73, 98192.33, 98215.93, 98239.54, 98263.14, 98286.75, 98310.36, 98333.97, 98357.58, 98381.195, 98404.805, 98428.42, 98452.04, 98475.66, 98499.28, 98522.9, 98546.52, 98570.15, 98593.77, 98617.4, 98641.03, 98664.664, 98688.29, 98711.92, 98735.56, 98759.195, 98782.836, 98806.47, 98830.11, 98853.75, 98877.4, 98901.04, 98924.69, 98948.336, 98971.984, 98995.63, 99019.28, 99042.94, 99066.586, 99090.24, 99113.9, 99137.56, 99161.22, 99184.88, 99208.55, 99232.21, 99255.875, 99279.54, 99303.21, 99326.875, 99350.55, 99374.22, 99397.9, 99421.57, 99445.25, 99468.93, 99492.61, 99516.29, 99539.97, 99563.66, 99587.336, 99611.02, 99634.71, 99658.4, 99682.09, 99705.79, 99729.48, 99753.17, 99776.87, 99800.57, 99824.266, 99847.97, 99871.67, 99895.375, 99919.08, 99942.78, 99966.49, 99990.2, 100013.914, 100037.625, 100061.336, 100085.055, 100108.766, 100132.484, 100156.2, 100179.92, 100203.65, 100227.37, 100251.09, 100274.82, 100298.55, 100322.27, 100346.01, 100369.74, 100393.47, 100417.2, 100440.945, 100464.68, 100488.414, 100512.16, 100535.9, 100559.64, 100583.38, 100607.13, 100630.875, 100654.625, 100678.375, 100702.125, 100725.88, 100749.63, 100773.39, 100797.15, 100820.91, 100844.664, 100868.42, 100892.19, 100915.95, 100939.72, 100963.484, 100987.25, 101011.02, 101034.79, 101058.56, 101082.336, 101106.11, 101129.89, 101153.664, 101177.445, 101201.23, 101225.01, 101248.79, 101272.58, 101296.36, 101320.15, 101343.94, 101367.73, 101391.52, 101415.31, 101439.11, 101462.91, 101486.7, 101510.5, 101534.305, 101558.1, 101581.91, 101605.71, 101629.516, 101653.32, 101677.13, 101700.94, 101724.75, 101748.56, 101772.38, 101796.195, 101820.01, 101843.83, 101867.65, 101891.47, 101915.29, 101939.12, 101962.945, 101986.766, 102010.59, 102034.42, 102058.26, 102082.086, 102105.92, 102129.76, 102153.59, 102177.43, 102201.27, 102225.11, 102248.95, 102272.8, 102296.64, 102320.484, 102344.336, 102368.18, 102392.03, 102415.88, 102439.734, 102463.59, 102487.445, 102511.305, 102535.164, 102559.02, 102582.88, 102606.75, 102630.61, 102654.48, 102678.34, 102702.21, 102726.086, 102749.95, 102773.83, 102797.7, 102821.58, 102845.45, 102869.33, 102893.21, 102917.086, 102940.97, 102964.85, 102988.74, 103012.625, 103036.516, 103060.41, 103084.3, 103108.19, 103132.08, 103155.98, 103179.87, 103203.766, 103227.664, 103251.56, 103275.47, 103299.37, 103323.27, 103347.18, 103371.086, 103394.99, 103418.91, 103442.81, 103466.73, 103490.64, 103514.555, 103538.48, 103562.39, 103586.31, 103610.234, 103634.16, 103658.08, 103682.01, 103705.93, 103729.86, 103753.79, 103777.72, 103801.65, 103825.586, 103849.516, 103873.45, 103897.39, 103921.33, 103945.27, 103969.21, 103993.16, 104017.1, 104041.05, 104064.99, 104088.94, 104112.89, 104136.84, 104160.8, 104184.75, 104208.7, 104232.66, 104256.62, 104280.58, 104304.54, 104328.5, 104352.46, 104376.43, 104400.4, 104424.36, 104448.336, 104472.305, 104496.27, 104520.25, 104544.22, 104568.195, 104592.17, 104616.16, 104640.13, 104664.12, 104688.1, 104712.086, 104736.07, 104760.055, 104784.05, 104808.03, 104832.02, 104856.016, 104880.01, 104904.01, 104928.0, 104952.0, 104976.0, 105000.0, 105024.0, 105048.01, 105072.01, 105096.016, 105120.02, 105144.03, 105168.05, 105192.055, 105216.07, 105240.086, 105264.1, 105288.12, 105312.13, 105336.16, 105360.17, 105384.195, 105408.22, 105432.25, 105456.27, 105480.305, 105504.33, 105528.36, 105552.4, 105576.43, 105600.46, 105624.5, 105648.54, 105672.58, 105696.62, 105720.66, 105744.7, 105768.74, 105792.79, 105816.836, 105840.89, 105864.94, 105888.99, 105913.04, 105937.09, 105961.15, 105985.21, 106009.266, 106033.33, 106057.38, 106081.445, 106105.516, 106129.58, 106153.64, 106177.71, 106201.78, 106225.85, 106249.92, 106273.99, 106298.07, 106322.15, 106346.23, 106370.305, 106394.38, 106418.46, 106442.55, 106466.63, 106490.72, 106514.805, 106538.89, 106562.98, 106587.07, 106611.164, 106635.26, 106659.35, 106683.445, 106707.55, 106731.65, 106755.74, 106779.84, 106803.95, 106828.055, 106852.164, 106876.266, 106900.375, 106924.484, 106948.59, 106972.71, 106996.82, 107020.94, 107045.055, 107069.17, 107093.3, 107117.414, 107141.54, 107165.66, 107189.78, 107213.914, 107238.04, 107262.164, 107286.3, 107310.43, 107334.56, 107358.695, 107382.836, 107406.97, 107431.11, 107455.25, 107479.39, 107503.53, 107527.67, 107551.82, 107575.97, 107600.12, 107624.266, 107648.414, 107672.57, 107696.72, 107720.875, 107745.03, 107769.19, 107793.34, 107817.51, 107841.67, 107865.83, 107889.99, 107914.164, 107938.33, 107962.5, 107986.664, 108010.836, 108035.01, 108059.18, 108083.36, 108107.53, 108131.71, 108155.89, 108180.07, 108204.25, 108228.44, 108252.62, 108276.805, 108300.99, 108325.18, 108349.375, 108373.56, 108397.76, 108421.95, 108446.15, 108470.34, 108494.54, 108518.74, 108542.94, 108567.14, 108591.34, 108615.55, 108639.76, 108663.96, 108688.17, 108712.38, 108736.59, 108760.805, 108785.02, 108809.234, 108833.45, 108857.67, 108881.89, 108906.11, 108930.336, 108954.555, 108978.78, 109003.01, 109027.234, 109051.46, 109075.695, 109099.93, 109124.16, 109148.39, 109172.63, 109196.87, 109221.1, 109245.34, 109269.586, 109293.83, 109318.07, 109342.32, 109366.56, 109390.81, 109415.06, 109439.31, 109463.56, 109487.81, 109512.07, 109536.33, 109560.586, 109584.84, 109609.1, 109633.36, 109657.625, 109681.89, 109706.16, 109730.42, 109754.69, 109778.96, 109803.23, 109827.5, 109851.77, 109876.05, 109900.33, 109924.6, 109948.88, 109973.164, 109997.445, 110021.73, 110046.01, 110070.3, 110094.58, 110118.87, 110143.16, 110167.445, 110191.74, 110216.03, 110240.33, 110264.625, 110288.92, 110313.22, 110337.52, 110361.82, 110386.125, 110410.43, 110434.734, 110459.04, 110483.35, 110507.66, 110531.97, 110556.28, 110580.59, 110604.91, 110629.23, 110653.55, 110677.86, 110702.18, 110726.51, 110750.83, 110775.15, 110799.48, 110823.805, 110848.13, 110872.46, 110896.79, 110921.125, 110945.46, 110969.79, 110994.125, 111018.47, 111042.805, 111067.15, 111091.484, 111115.83, 111140.17, 111164.516, 111188.87, 111213.21, 111237.56, 111261.914, 111286.266, 111310.62, 111334.98, 111359.33, 111383.69, 111408.05, 111432.41, 111456.766, 111481.13, 111505.49, 111529.86, 111554.23, 111578.59, 111602.97, 111627.336, 111651.71, 111676.08, 111700.45, 111724.836, 111749.21, 111773.586, 111797.97, 111822.35, 111846.734, 111871.12, 111895.5, 111919.89, 111944.27, 111968.664, 111993.055, 112017.45, 112041.84, 112066.234, 112090.63, 112115.03, 112139.43, 112163.83, 112188.234, 112212.63, 112237.04, 112261.445, 112285.85, 112310.26, 112334.664, 112359.08, 112383.49, 112407.91, 112432.32, 112456.734, 112481.15, 112505.57, 112529.99, 112554.41, 112578.836, 112603.26, 112627.68, 112652.11, 112676.54, 112700.97, 112725.4, 112749.83, 112774.26, 112798.695, 112823.13, 112847.57, 112872.01, 112896.445, 112920.89, 112945.33, 112969.77, 112994.22, 113018.664, 113043.11, 113067.56, 113092.016, 113116.46, 113140.914, 113165.375, 113189.83, 113214.28, 113238.74, 113263.2, 113287.664, 113312.125, 113336.586, 113361.055, 113385.516, 113409.984, 113434.45, 113458.93, 113483.4, 113507.87, 113532.34, 113556.82, 113581.3, 113605.77, 113630.25, 113654.734, 113679.22, 113703.7, 113728.19, 113752.67, 113777.16, 113801.65, 113826.13, 113850.625, 113875.12, 113899.62, 113924.11, 113948.61, 113973.1, 113997.6, 114022.1, 114046.6, 114071.11, 114095.61, 114120.12, 114144.625, 114169.13, 114193.64, 114218.16, 114242.664, 114267.18, 114291.695, 114316.21, 114340.73, 114365.25, 114389.766, 114414.29, 114438.81, 114463.336, 114487.86, 114512.39, 114536.914, 114561.445, 114585.98, 114610.51, 114635.04, 114659.58, 114684.11, 114708.65, 114733.19, 114757.73, 114782.27, 114806.81, 114831.36, 114855.9, 114880.445, 114904.99, 114929.55, 114954.09, 114978.65, 115003.2, 115027.76, 115052.31, 115076.87, 115101.42, 115125.984, 115150.55, 115175.11, 115199.67, 115224.234, 115248.805, 115273.37, 115297.94, 115322.51, 115347.08, 115371.65, 115396.23, 115420.805, 115445.375, 115469.95, 115494.53, 115519.12, 115543.695, 115568.28, 115592.87, 115617.45, 115642.04, 115666.625, 115691.22, 115715.805, 115740.4, 115764.99, 115789.586, 115814.18, 115838.78, 115863.38, 115887.98, 115912.58, 115937.19, 115961.79, 115986.39, 116011.0, 116035.61, 116060.22, 116084.83, 116109.44, 116134.055, 116158.664, 116183.28, 116207.9, 116232.516, 116257.14, 116281.76, 116306.38, 116331.01, 116355.63, 116380.26, 116404.88, 116429.516, 116454.14, 116478.77, 116503.41, 116528.04, 116552.67, 116577.31, 116601.95, 116626.586, 116651.23, 116675.875, 116700.516, 116725.16, 116749.805, 116774.45, 116799.1, 116823.75, 116848.4, 116873.055, 116897.7, 116922.36, 116947.016, 116971.67, 116996.336, 117020.99, 117045.66, 117070.32, 117094.984, 117119.65, 117144.31, 117168.98, 117193.65, 117218.32, 117242.99, 117267.664, 117292.336, 117317.016, 117341.69, 117366.37, 117391.05, 117415.73, 117440.414, 117465.09, 117489.78, 117514.47, 117539.16, 117563.84, 117588.53, 117613.23, 117637.914, 117662.61, 117687.305, 117712.0, 117736.695, 117761.4, 117786.09, 117810.8, 117835.5, 117860.2, 117884.914, 117909.62, 117934.33, 117959.03, 117983.74, 118008.46, 118033.17, 118057.88, 118082.6, 118107.32, 118132.04, 118156.76, 118181.48, 118206.195, 118230.92, 118255.65, 118280.375, 118305.1, 118329.83, 118354.56, 118379.29, 118404.02, 118428.76, 118453.49, 118478.23, 118502.97, 118527.7, 118552.445, 118577.19, 118601.93, 118626.67, 118651.42, 118676.164, 118700.914, 118725.664, 118750.414, 118775.164, 118799.92, 118824.67, 118849.43, 118874.19, 118898.945, 118923.7, 118948.47, 118973.23, 118997.99, 119022.76, 119047.52, 119072.29, 119097.06, 119121.83, 119146.6, 119171.375, 119196.15, 119220.92, 119245.695, 119270.48, 119295.26, 119320.03, 119344.81, 119369.6, 119394.38, 119419.17, 119443.95, 119468.74, 119493.53, 119518.32, 119543.12, 119567.91, 119592.7, 119617.5, 119642.3, 119667.09, 119691.89, 119716.695, 119741.49, 119766.3, 119791.1, 119815.91, 119840.72, 119865.52, 119890.336, 119915.15, 119939.96, 119964.77, 119989.586, 120014.41, 120039.22, 120064.04, 120088.86, 120113.68, 120138.51, 120163.33, 120188.16, 120212.98, 120237.805, 120262.63, 120287.47, 120312.3, 120337.13, 120361.97, 120386.805, 120411.64, 120436.48, 120461.31, 120486.16, 120511.0, 120535.84, 120560.69, 120585.53, 120610.375, 120635.23, 120660.08, 120684.93, 120709.78, 120734.63, 120759.484, 120784.34, 120809.2, 120834.055, 120858.92, 120883.78, 120908.64, 120933.51, 120958.37, 120983.234, 121008.1, 121032.97, 121057.84, 121082.71, 121107.586, 121132.46, 121157.336, 121182.21, 121207.086, 121231.97, 121256.85, 121281.73, 121306.61, 121331.5, 121356.38, 121381.266, 121406.16, 121431.05, 121455.94, 121480.83, 121505.72, 121530.62, 121555.51, 121580.41, 121605.305, 121630.2, 121655.1, 121680.01, 121704.914, 121729.81, 121754.72, 121779.625, 121804.54, 121829.445, 121854.36, 121879.266, 121904.18, 121929.09, 121954.016, 121978.93, 122003.85, 122028.766, 122053.69, 122078.61, 122103.53, 122128.46, 122153.38, 122178.31, 122203.24, 122228.17, 122253.1, 122278.03, 122302.97, 122327.91, 122352.836, 122377.77, 122402.72, 122427.66, 122452.59, 122477.54, 122502.484, 122527.43, 122552.375, 122577.32, 122602.27, 122627.22, 122652.17, 122677.125, 122702.08, 122727.04, 122751.99, 122776.95, 122801.91, 122826.87, 122851.83, 122876.8, 122901.76, 122926.73, 122951.69, 122976.66, 123001.625, 123026.6, 123051.57, 123076.55, 123101.516, 123126.49, 123151.47, 123176.445, 123201.43, 123226.41, 123251.39, 123276.375, 123301.36, 123326.34, 123351.33, 123376.32, 123401.305, 123426.3, 123451.29, 123476.28, 123501.28, 123526.27, 123551.27, 123576.27, 123601.27, 123626.27, 123651.27, 123676.27, 123701.28, 123726.29, 123751.3, 123776.305, 123801.31, 123826.32, 123851.336, 123876.35, 123901.37, 123926.38, 123951.4, 123976.414, 124001.44, 124026.45, 124051.48, 124076.5, 124101.53, 124126.555, 124151.58, 124176.61, 124201.64, 124226.67, 124251.7, 124276.734, 124301.77, 124326.805, 124351.84, 124376.88, 124401.92, 124426.97, 124452.01, 124477.055, 124502.09, 124527.14, 124552.19, 124577.24, 124602.29, 124627.34, 124652.39, 124677.445, 124702.5, 124727.56, 124752.62, 124777.67, 124802.734, 124827.8, 124852.86, 124877.92, 124902.99, 124928.055, 124953.125, 124978.195, 125003.266, 125028.336, 125053.41, 125078.484, 125103.555, 125128.63, 125153.71, 125178.79, 125203.87, 125228.95, 125254.03, 125279.12, 125304.2, 125329.29, 125354.375, 125379.47, 125404.555, 125429.65, 125454.74, 125479.836, 125504.93, 125530.02, 125555.125, 125580.23, 125605.33, 125630.43, 125655.53, 125680.63, 125705.74, 125730.84, 125755.95, 125781.06, 125806.17, 125831.28, 125856.4, 125881.51, 125906.625, 125931.74, 125956.86, 125981.98, 126007.1, 126032.22, 126057.34, 126082.47, 126107.59, 126132.72, 126157.85, 126182.98, 126208.11, 126233.24, 126258.375, 126283.51, 126308.64, 126333.78, 126358.914, 126384.055, 126409.195, 126434.336, 126459.484, 126484.625, 126509.77, 126534.92, 126560.06, 126585.22, 126610.37, 126635.516, 126660.67, 126685.83, 126710.98, 126736.13, 126761.3, 126786.45, 126811.62, 126836.77, 126861.94, 126887.1, 126912.266, 126937.44, 126962.6, 126987.77, 127012.945, 127038.12, 127063.29, 127088.46, 127113.63, 127138.81, 127163.99, 127189.17, 127214.35, 127239.53, 127264.72, 127289.9, 127315.086, 127340.27, 127365.46, 127390.65, 127415.836, 127441.03, 127466.22, 127491.414, 127516.61, 127541.805, 127567.01, 127592.2, 127617.41, 127642.61, 127667.81, 127693.016, 127718.22, 127743.42, 127768.63, 127793.84, 127819.055, 127844.266, 127869.48, 127894.69, 127919.91, 127945.125, 127970.34, 127995.56, 128020.78, 128046.0, 128071.23, 128096.445, 128121.67, 128146.9, 128172.125, 128197.35, 128222.586, 128247.82, 128273.05, 128298.28, 128323.516, 128348.76, 128373.99, 128399.234, 128424.47, 128449.71, 128474.95, 128500.195, 128525.445, 128550.69, 128575.94, 128601.19, 128626.44, 128651.69, 128676.94, 128702.195, 128727.445, 128752.7, 128777.96, 128803.22, 128828.48, 128853.74, 128879.0, 128904.266, 128929.53, 128954.8, 128980.06, 129005.336, 129030.6, 129055.875, 129081.15, 129106.42, 129131.695, 129156.97, 129182.25, 129207.52, 129232.805, 129258.086, 129283.37, 129308.66, 129333.94, 129359.23, 129384.51, 129409.8, 129435.086, 129460.38, 129485.67, 129510.96, 129536.26, 129561.555, 129586.85, 129612.15, 129637.445, 129662.75, 129688.055, 129713.35, 129738.66, 129763.96, 129789.27, 129814.58, 129839.89, 129865.2, 129890.51, 129915.83, 129941.14, 129966.45, 129991.77, 130017.086, 130042.41, 130067.73, 130093.05, 130118.375, 130143.695, 130169.02, 130194.35, 130219.68, 130245.01, 130270.336, 130295.664, 130321.0, 130346.336, 130371.67, 130397.01, 130422.34, 130447.68, 130473.02, 130498.37, 130523.7, 130549.05, 130574.4, 130599.74, 130625.086, 130650.44, 130675.79, 130701.14, 130726.49, 130751.84, 130777.2, 130802.555, 130827.914, 130853.27, 130878.63, 130903.99, 130929.35, 130954.72, 130980.086, 131005.445, 131030.81, 131056.19, 131081.55, 131106.92, 131132.3, 131157.67, 131183.05, 131208.42, 131233.8, 131259.17, 131284.55, 131309.94, 131335.31, 131360.7, 131386.08, 131411.47, 131436.86, 131462.25, 131487.64, 131513.03, 131538.42, 131563.81, 131589.2, 131614.6, 131640.0, 131665.39, 131690.8, 131716.19, 131741.6, 131767.0, 131792.4, 131817.81, 131843.22, 131868.62, 131894.03, 131919.44, 131944.84, 131970.27, 131995.67, 132021.1, 132046.5, 132071.92, 132097.34, 132122.77, 132148.19, 132173.61, 132199.03, 132224.45, 132249.88, 132275.31, 132300.73, 132326.17, 132351.6, 132377.03, 132402.47, 132427.89, 132453.33, 132478.77, 132504.2, 132529.64, 132555.1, 132580.53, 132605.97, 132631.42, 132656.86, 132682.31, 132707.75, 132733.2, 132758.66, 132784.11, 132809.56, 132835.02, 132860.47, 132885.92, 132911.39, 132936.84, 132962.3, 132987.77, 133013.22, 133038.69, 133064.16, 133089.62, 133115.1, 133140.56, 133166.03, 133191.5, 133216.97, 133242.44, 133267.92, 133293.39, 133318.88, 133344.34, 133369.83, 133395.31, 133420.8, 133446.28, 133471.77, 133497.25, 133522.73, 133548.22, 133573.7, 133599.2, 133624.69, 133650.19, 133675.69, 133701.17, 133726.67, 133752.17, 133777.67, 133803.17, 133828.67, 133854.17, 133879.67, 133905.19, 133930.69, 133956.2, 133981.7, 134007.22, 134032.73, 134058.23, 134083.75, 134109.27, 134134.78, 134160.3, 134185.81, 134211.34, 134236.86, 134262.38, 134287.9, 134313.44, 134338.95, 134364.48, 134390.02, 134415.55, 134441.08, 134466.61, 134492.14, 134517.67, 134543.2, 134568.75, 134594.28, 134619.81, 134645.36, 134670.9, 134696.44, 134721.98, 134747.53, 134773.08, 134798.62, 134824.17, 134849.72, 134875.28, 134900.83, 134926.39, 134951.94, 134977.5, 135003.05, 135028.61, 135054.17, 135079.73, 135105.3, 135130.86, 135156.42, 135181.98, 135207.55, 135233.12, 135258.69, 135284.27, 135309.83, 135335.4, 135360.98, 135386.56, 135412.12, 135437.7, 135463.28, 135488.88, 135514.45, 135540.03, 135565.61, 135591.2, 135616.78, 135642.38, 135667.97, 135693.55, 135719.14, 135744.73, 135770.33, 135795.92, 135821.52, 135847.12, 135872.72, 135898.31, 135923.92, 135949.52, 135975.12, 136000.73, 136026.33, 136051.94, 136077.55, 136103.16, 136128.77, 136154.38, 136179.98, 136205.61, 136231.22, 136256.84, 136282.45, 136308.08, 136333.69, 136359.31, 136384.94, 136410.56, 136436.19, 136461.81, 136487.44, 136513.06, 136538.7, 136564.33, 136589.95, 136615.6, 136641.23, 136666.86, 136692.5, 136718.14, 136743.78, 136769.42, 136795.06, 136820.7, 136846.34, 136871.98, 136897.64, 136923.28, 136948.94, 136974.58, 137000.23, 137025.89, 137051.55, 137077.2, 137102.86, 137128.52, 137154.17, 137179.83, 137205.48, 137231.16, 137256.81, 137282.48, 137308.14, 137333.81, 137359.48, 137385.16, 137410.81, 137436.48, 137462.16, 137487.84, 137513.52, 137539.19, 137564.88, 137590.55, 137616.22, 137641.9, 137667.6, 137693.28, 137718.95, 137744.64, 137770.33, 137796.02, 137821.7, 137847.4, 137873.1, 137898.78, 137924.48, 137950.17, 137975.88, 138001.58, 138027.27, 138052.97, 138078.67, 138104.38, 138130.08, 138155.78, 138181.48, 138207.2, 138232.9, 138258.61, 138284.33, 138310.05, 138335.75, 138361.47, 138387.19, 138412.9, 138438.62, 138464.34, 138490.06, 138515.78, 138541.5, 138567.23, 138592.95, 138618.69, 138644.4, 138670.14, 138695.88, 138721.6, 138747.33, 138773.06, 138798.8, 138824.53, 138850.28, 138876.02, 138901.75, 138927.5, 138953.23, 138978.98, 139004.72, 139030.47, 139056.22, 139081.97, 139107.72, 139133.47, 139159.22, 139184.97, 139210.72, 139236.48, 139262.23, 139288.0, 139313.75, 139339.52, 139365.28, 139391.03, 139416.8, 139442.56, 139468.33, 139494.1, 139519.88, 139545.64, 139571.4, 139597.19, 139622.95, 139648.73, 139674.5, 139700.28, 139726.06, 139751.84, 139777.62, 139803.4, 139829.19, 139854.97, 139880.75, 139906.53, 139932.33, 139958.11, 139983.9, 140009.69, 140035.48, 140061.28, 140087.08, 140112.88, 140138.67, 140164.47, 140190.27, 140216.06, 140241.86, 140267.67, 140293.47, 140319.28, 140345.08, 140370.89, 140396.7, 140422.52, 140448.33, 140474.14, 140499.95, 140525.77, 140551.58, 140577.39, 140603.22, 140629.03, 140654.86, 140680.67, 140706.5, 140732.33, 140758.16, 140783.97, 140809.8, 140835.62, 140861.47, 140887.3, 140913.12, 140938.95, 140964.8, 140990.62, 141016.47, 141042.31, 141068.14, 141093.98, 141119.83, 141145.67, 141171.52, 141197.36, 141223.2, 141249.06, 141274.9, 141300.75, 141326.61, 141352.45, 141378.31, 141404.17, 141430.03, 141455.88, 141481.73, 141507.6, 141533.47, 141559.33, 141585.19, 141611.05, 141636.92, 141662.78, 141688.66, 141714.52, 141740.39, 141766.27, 141792.14, 141818.02, 141843.89, 141869.77, 141895.64, 141921.52, 141947.39, 141973.28, 141999.16, 142025.05, 142050.92, 142076.81, 142102.7, 142128.6, 142154.48, 142180.38, 142206.27, 142232.16, 142258.05, 142283.94, 142309.84, 142335.73, 142361.64, 142387.53, 142413.44, 142439.34, 142465.23, 142491.14, 142517.05, 142542.95, 142568.86, 142594.78, 142620.69, 142646.6, 142672.52, 142698.42, 142724.34, 142750.25, 142776.17, 142802.1, 142828.02, 142853.94, 142879.86, 142905.78, 142931.7, 142957.62, 142983.55, 143009.48, 143035.4, 143061.34, 143087.27, 143113.2, 143139.14, 143165.08, 143191.02, 143216.95, 143242.89, 143268.83, 143294.77, 143320.7, 143346.66, 143372.6, 143398.55, 143424.48, 143450.44, 143476.39, 143502.34, 143528.3, 143554.25, 143580.2, 143606.16, 143632.11, 143658.06, 143684.03, 143709.98, 143735.94, 143761.9, 143787.88, 143813.83, 143839.8, 143865.77, 143891.73, 143917.7, 143943.67, 143969.64, 143995.62, 144021.6, 144047.56, 144073.55, 144099.52, 144125.5, 144151.48, 144177.45, 144203.44, 144229.42, 144255.4, 144281.39, 144307.38, 144333.38, 144359.36, 144385.34, 144411.34, 144437.33, 144463.33, 144489.33, 144515.31, 144541.31, 144567.31, 144593.31, 144619.31, 144645.31, 144671.31, 144697.33, 144723.33, 144749.33, 144775.34, 144801.34, 144827.36, 144853.38, 144879.39, 144905.39, 144931.4, 144957.42, 144983.45, 145009.47, 145035.48, 145061.5, 145087.53, 145113.55, 145139.58, 145165.6, 145191.62, 145217.66, 145243.69, 145269.72, 145295.73, 145321.78, 145347.81, 145373.84, 145399.88, 145425.92, 145451.95, 145478.0, 145504.03, 145530.08, 145556.11, 145582.16, 145608.2, 145634.25, 145660.3, 145686.34, 145712.39, 145738.45, 145764.5, 145790.55, 145816.61, 145842.66, 145868.72, 145894.78, 145920.84, 145946.89, 145972.95, 145999.02, 146025.08, 146051.16, 146077.22, 146103.28, 146129.36, 146155.42, 146181.48, 146207.56, 146233.64, 146259.72, 146285.78, 146311.86, 146337.94, 146364.02, 146390.1, 146416.19, 146442.27, 146468.34, 146494.44, 146520.52, 146546.61, 146572.69, 146598.78, 146624.88, 146650.97, 146677.06, 146703.16, 146729.25, 146755.34, 146781.44, 146807.53, 146833.64, 146859.73, 146885.84, 146911.94, 146938.05, 146964.16, 146990.27, 147016.36, 147042.47, 147068.58, 147094.7, 147120.81, 147146.92, 147173.03, 147199.16, 147225.27, 147251.39, 147277.52, 147303.62, 147329.75, 147355.88, 147382.0, 147408.12, 147434.25, 147460.38, 147486.5, 147512.64, 147538.77, 147564.89, 147591.03, 147617.17, 147643.3, 147669.44, 147695.58, 147721.72, 147747.86, 147774.0, 147800.14, 147826.28, 147852.42, 147878.58, 147904.72, 147930.88, 147957.02, 147983.17, 148009.33, 148035.47, 148061.62, 148087.78, 148113.94, 148140.1, 148166.25, 148192.42, 148218.58, 148244.73, 148270.9, 148297.06, 148323.23, 148349.4, 148375.56, 148401.73, 148427.9, 148454.08, 148480.25, 148506.42, 148532.6, 148558.78, 148584.95, 148611.12, 148637.31, 148663.48, 148689.67, 148715.86, 148742.05, 148768.22, 148794.4, 148820.6, 148846.78, 148872.98, 148899.17, 148925.36, 148951.55, 148977.75, 149003.94, 149030.14, 149056.34, 149082.53, 149108.73, 149134.94, 149161.14, 149187.34, 149213.55, 149239.75, 149265.97, 149292.17, 149318.38, 149344.6, 149370.8, 149397.02, 149423.23, 149449.45, 149475.66, 149501.88, 149528.1, 149554.31, 149580.55, 149606.77, 149632.98, 149659.2, 149685.44, 149711.66, 149737.89, 149764.12, 149790.34, 149816.58, 149842.81, 149869.05, 149895.28, 149921.52, 149947.75, 149973.98, 150000.23, 150026.47, 150052.72, 150078.95, 150105.2, 150131.44, 150157.69, 150183.94, 150210.19, 150236.44, 150262.69, 150288.94, 150315.19, 150341.45, 150367.7, 150393.95, 150420.22, 150446.47, 150472.73, 150499.0, 150525.25, 150551.52, 150577.78, 150604.05, 150630.31, 150656.58, 150682.86, 150709.12, 150735.39, 150761.67, 150787.94, 150814.22, 150840.5, 150866.77, 150893.05, 150919.33, 150945.61, 150971.89, 150998.17, 151024.45, 151050.75, 151077.03, 151103.31, 151129.61, 151155.89, 151182.19, 151208.48, 151234.77, 151261.06, 151287.36, 151313.66, 151339.95, 151366.25, 151392.55, 151418.86, 151445.16, 151471.45, 151497.77, 151524.06, 151550.38, 151576.69, 151603.0, 151629.3, 151655.61, 151681.92, 151708.23, 151734.56, 151760.88, 151787.19, 151813.5, 151839.83, 151866.14, 151892.47, 151918.8, 151945.11, 151971.44, 151997.77, 152024.1, 152050.42, 152076.75, 152103.08, 152129.42, 152155.75, 152182.08, 152208.42, 152234.75, 152261.1, 152287.44, 152313.77, 152340.11, 152366.45, 152392.8, 152419.14, 152445.48, 152471.83, 152498.19, 152524.53, 152550.88, 152577.23, 152603.58, 152629.94, 152656.3, 152682.66, 152709.0, 152735.36, 152761.72, 152788.08, 152814.45, 152840.81, 152867.17, 152893.53, 152919.9, 152946.27, 152972.64, 152999.02, 153025.38, 153051.75, 153078.12, 153104.5, 153130.88, 153157.25, 153183.62, 153210.0, 153236.39, 153262.77, 153289.14, 153315.53, 153341.92, 153368.3, 153394.69, 153421.08, 153447.47, 153473.86, 153500.25, 153526.64, 153553.03, 153579.42, 153605.81, 153632.22, 153658.61, 153685.02, 153711.4, 153737.81, 153764.22, 153790.62, 153817.03, 153843.44, 153869.84, 153896.25, 153922.66, 153949.06, 153975.48, 154001.89, 154028.3, 154054.72, 154081.14, 154107.55, 154133.97, 154160.39, 154186.81, 154213.23, 154239.66, 154266.08, 154292.5, 154318.92, 154345.36, 154371.78, 154398.22, 154424.64, 154451.08, 154477.52, 154503.94, 154530.38, 154556.81, 154583.25, 154609.69, 154636.12, 154662.58, 154689.02, 154715.45, 154741.9, 154768.34, 154794.8, 154821.23, 154847.69, 154874.14, 154900.6, 154927.05, 154953.5, 154979.95, 155006.4, 155032.86, 155059.31, 155085.78, 155112.23, 155138.7, 155165.16, 155191.62, 155218.1, 155244.56, 155271.02, 155297.48, 155323.95, 155350.44, 155376.9, 155403.38, 155429.84, 155456.33, 155482.8, 155509.28, 155535.75, 155562.23, 155588.72, 155615.19, 155641.67, 155668.16, 155694.64, 155721.12, 155747.62, 155774.11, 155800.6, 155827.1, 155853.58, 155880.08, 155906.56, 155933.06, 155959.56, 155986.05, 156012.55, 156039.05, 156065.55, 156092.05, 156118.56, 156145.06, 156171.56, 156198.08, 156224.58, 156251.1, 156277.6, 156304.11, 156330.62, 156357.14, 156383.64, 156410.16, 156436.67, 156463.2, 156489.72, 156516.23, 156542.75, 156569.28, 156595.8, 156622.33, 156648.84, 156675.38, 156701.9, 156728.44, 156754.97, 156781.5, 156808.03, 156834.56, 156861.1, 156887.62, 156914.17, 156940.7, 156967.25, 156993.78, 157020.33, 157046.86, 157073.4, 157099.95, 157126.5, 157153.05, 157179.6, 157206.14, 157232.69, 157259.25, 157285.8, 157312.34, 157338.9, 157365.45, 157392.02, 157418.58, 157445.14, 157471.69, 157498.25, 157524.81, 157551.38, 157577.95, 157604.52, 157631.08, 157657.64, 157684.22, 157710.78, 157737.36, 157763.92, 157790.5, 157817.08, 157843.66, 157870.23, 157896.81, 157923.39, 157949.97, 157976.55, 158003.12, 158029.72, 158056.3, 158082.89, 158109.47, 158136.06, 158162.66, 158189.23, 158215.83, 158242.42, 158269.02, 158295.61, 158322.2, 158348.81, 158375.4, 158402.0, 158428.61, 158455.2, 158481.81, 158508.4, 158535.02, 158561.62, 158588.23, 158614.84, 158641.45, 158668.06, 158694.67, 158721.28, 158747.89, 158774.52, 158801.12, 158827.75, 158854.36, 158880.98, 158907.61, 158934.22, 158960.84, 158987.47, 159014.1, 159040.72, 159067.34, 159093.97, 159120.61, 159147.23, 159173.88, 159200.5, 159227.14, 159253.77, 159280.4, 159307.05, 159333.69, 159360.31, 159386.95, 159413.61, 159440.25, 159466.89, 159493.53, 159520.19, 159546.83, 159573.47, 159600.12, 159626.78, 159653.42, 159680.08, 159706.73, 159733.39, 159760.05, 159786.7, 159813.36, 159840.02, 159866.69, 159893.34, 159920.0, 159946.67, 159973.33, 160000.0, 160026.67, 160053.33, 160080.0, 160106.67, 160133.34, 160160.02, 160186.69, 160213.38, 160240.05, 160266.72, 160293.4, 160320.08, 160346.77, 160373.44, 160400.12, 160426.81, 160453.5, 160480.19, 160506.86, 160533.56, 160560.25, 160586.94, 160613.62, 160640.31, 160667.02, 160693.7, 160720.4, 160747.11, 160773.8, 160800.5, 160827.2, 160853.9, 160880.61, 160907.31, 160934.02, 160960.72, 160987.42, 161014.14, 161040.84, 161067.55, 161094.27, 161120.98, 161147.69, 161174.4, 161201.12, 161227.84, 161254.56, 161281.28, 161308.0, 161334.72, 161361.44, 161388.17, 161414.89, 161441.62, 161468.34, 161495.08, 161521.8, 161548.53, 161575.27, 161602.0, 161628.73, 161655.47, 161682.2, 161708.94, 161735.67, 161762.42, 161789.16, 161815.89, 161842.64, 161869.39, 161896.12, 161922.88, 161949.62, 161976.38, 162003.12, 162029.88, 162056.62, 162083.38, 162110.12, 162136.88, 162163.64, 162190.39, 162217.16, 162243.9, 162270.67, 162297.44, 162324.19, 162350.95, 162377.72, 162404.48, 162431.25, 162458.03, 162484.8, 162511.56, 162538.33, 162565.11, 162591.88, 162618.66, 162645.44, 162672.2, 162698.98, 162725.77, 162752.55, 162779.33, 162806.11, 162832.89, 162859.67, 162886.45, 162913.25, 162940.03, 162966.83, 162993.61, 163020.4, 163047.2, 163073.98, 163100.78, 163127.58, 163154.38, 163181.17, 163207.97, 163234.77, 163261.58, 163288.38, 163315.17, 163341.98, 163368.8, 163395.6, 163422.4, 163449.22, 163476.02, 163502.83, 163529.64, 163556.45, 163583.27, 163610.1, 163636.9, 163663.72, 163690.55, 163717.36, 163744.19, 163771.0, 163797.83, 163824.66, 163851.47, 163878.3, 163905.12, 163931.95, 163958.78, 163985.61, 164012.45, 164039.28, 164066.11, 164092.95, 164119.78, 164146.62, 164173.47, 164200.3, 164227.14, 164253.98, 164280.83, 164307.67, 164334.52, 164361.36, 164388.2, 164415.06, 164441.9, 164468.75, 164495.61, 164522.45, 164549.31, 164576.17, 164603.03, 164629.88, 164656.73, 164683.6, 164710.45, 164737.31, 164764.19, 164791.05, 164817.9, 164844.78, 164871.64, 164898.52, 164925.38, 164952.25, 164979.12, 165006.0, 165032.88, 165059.73, 165086.62]);
}, {IQ_TABLE: "Float32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Contains a mapping of macroblocks to slice groups. Groups is an array of
 *  group slice group indices having a dimension picWidthInMbs x picHeightInMbs
 *  
 *  @author The JCodec project
 *  
 */
var MBToSliceGroupMap = function(groups, indices, inverse) {
    this.groups = groups;
    this.indices = indices;
    this.inverse = inverse;
};
MBToSliceGroupMap = stjs.extend(MBToSliceGroupMap, null, [], function(constructor, prototype) {
    prototype.groups = null;
    prototype.indices = null;
    prototype.inverse = null;
    prototype.getGroups = function() {
        return this.groups;
    };
    prototype.getIndices = function() {
        return this.indices;
    };
    prototype.getInverse = function() {
        return this.inverse;
    };
}, {groups: "Int32Array", indices: "Int32Array", inverse: "Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license. 
 * 
 *  @author in-somnia
 */
var ScaleFactorBands = function() {};
ScaleFactorBands = stjs.extend(ScaleFactorBands, null, [], function(constructor, prototype) {
    constructor.SWB_LONG_WINDOW_COUNT = new Int32Array([41, 41, 47, 49, 49, 51, 47, 47, 43, 43, 43, 40]);
    constructor.SWB_OFFSET_1024_96 = new Int32Array([0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 64, 72, 80, 88, 96, 108, 120, 132, 144, 156, 172, 188, 212, 240, 276, 320, 384, 448, 512, 576, 640, 704, 768, 832, 896, 960, 1024, -1]);
    constructor.SWB_OFFSET_1024_64 = new Int32Array([0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 64, 72, 80, 88, 100, 112, 124, 140, 156, 172, 192, 216, 240, 268, 304, 344, 384, 424, 464, 504, 544, 584, 624, 664, 704, 744, 784, 824, 864, 904, 944, 984, 1024, -1]);
    constructor.SWB_OFFSET_1024_48 = new Int32Array([0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 48, 56, 64, 72, 80, 88, 96, 108, 120, 132, 144, 160, 176, 196, 216, 240, 264, 292, 320, 352, 384, 416, 448, 480, 512, 544, 576, 608, 640, 672, 704, 736, 768, 800, 832, 864, 896, 928, 1024, -1]);
    constructor.SWB_OFFSET_1024_32 = new Int32Array([0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 48, 56, 64, 72, 80, 88, 96, 108, 120, 132, 144, 160, 176, 196, 216, 240, 264, 292, 320, 352, 384, 416, 448, 480, 512, 544, 576, 608, 640, 672, 704, 736, 768, 800, 832, 864, 896, 928, 960, 992, 1024, -1]);
    constructor.SWB_OFFSET_1024_24 = new Int32Array([0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 52, 60, 68, 76, 84, 92, 100, 108, 116, 124, 136, 148, 160, 172, 188, 204, 220, 240, 260, 284, 308, 336, 364, 396, 432, 468, 508, 552, 600, 652, 704, 768, 832, 896, 960, 1024, -1]);
    constructor.SWB_OFFSET_1024_16 = new Int32Array([0, 8, 16, 24, 32, 40, 48, 56, 64, 72, 80, 88, 100, 112, 124, 136, 148, 160, 172, 184, 196, 212, 228, 244, 260, 280, 300, 320, 344, 368, 396, 424, 456, 492, 532, 572, 616, 664, 716, 772, 832, 896, 960, 1024, -1]);
    constructor.SWB_OFFSET_1024_8 = new Int32Array([0, 12, 24, 36, 48, 60, 72, 84, 96, 108, 120, 132, 144, 156, 172, 188, 204, 220, 236, 252, 268, 288, 308, 328, 348, 372, 396, 420, 448, 476, 508, 544, 580, 620, 664, 712, 764, 820, 880, 944, 1024, -1]);
    constructor.SWB_OFFSET_LONG_WINDOW = [ScaleFactorBands.SWB_OFFSET_1024_96, ScaleFactorBands.SWB_OFFSET_1024_96, ScaleFactorBands.SWB_OFFSET_1024_64, ScaleFactorBands.SWB_OFFSET_1024_48, ScaleFactorBands.SWB_OFFSET_1024_48, ScaleFactorBands.SWB_OFFSET_1024_32, ScaleFactorBands.SWB_OFFSET_1024_24, ScaleFactorBands.SWB_OFFSET_1024_24, ScaleFactorBands.SWB_OFFSET_1024_16, ScaleFactorBands.SWB_OFFSET_1024_16, ScaleFactorBands.SWB_OFFSET_1024_16, ScaleFactorBands.SWB_OFFSET_1024_8];
    constructor.SWB_SHORT_WINDOW_COUNT = new Int32Array([12, 12, 12, 14, 14, 14, 15, 15, 15, 15, 15, 15]);
    constructor.SWB_OFFSET_128_96 = new Int32Array([0, 4, 8, 12, 16, 20, 24, 32, 40, 48, 64, 92, 128, -1]);
    constructor.SWB_OFFSET_128_64 = new Int32Array([0, 4, 8, 12, 16, 20, 24, 32, 40, 48, 64, 92, 128, -1]);
    constructor.SWB_OFFSET_128_48 = new Int32Array([0, 4, 8, 12, 16, 20, 28, 36, 44, 56, 68, 80, 96, 112, 128, -1]);
    constructor.SWB_OFFSET_128_24 = new Int32Array([0, 4, 8, 12, 16, 20, 24, 28, 36, 44, 52, 64, 76, 92, 108, 128, -1]);
    constructor.SWB_OFFSET_128_16 = new Int32Array([0, 4, 8, 12, 16, 20, 24, 28, 32, 40, 48, 60, 72, 88, 108, 128, -1]);
    constructor.SWB_OFFSET_128_8 = new Int32Array([0, 4, 8, 12, 16, 20, 24, 28, 36, 44, 52, 60, 72, 88, 108, 128, -1]);
    constructor.SWB_OFFSET_SHORT_WINDOW = [ScaleFactorBands.SWB_OFFSET_128_96, ScaleFactorBands.SWB_OFFSET_128_96, ScaleFactorBands.SWB_OFFSET_128_64, ScaleFactorBands.SWB_OFFSET_128_48, ScaleFactorBands.SWB_OFFSET_128_48, ScaleFactorBands.SWB_OFFSET_128_48, ScaleFactorBands.SWB_OFFSET_128_24, ScaleFactorBands.SWB_OFFSET_128_24, ScaleFactorBands.SWB_OFFSET_128_16, ScaleFactorBands.SWB_OFFSET_128_16, ScaleFactorBands.SWB_OFFSET_128_16, ScaleFactorBands.SWB_OFFSET_128_8];
}, {SWB_LONG_WINDOW_COUNT: "Int32Array", SWB_OFFSET_1024_96: "Int32Array", SWB_OFFSET_1024_64: "Int32Array", SWB_OFFSET_1024_48: "Int32Array", SWB_OFFSET_1024_32: "Int32Array", SWB_OFFSET_1024_24: "Int32Array", SWB_OFFSET_1024_16: "Int32Array", SWB_OFFSET_1024_8: "Int32Array", SWB_OFFSET_LONG_WINDOW: "Array", SWB_SHORT_WINDOW_COUNT: "Int32Array", SWB_OFFSET_128_96: "Int32Array", SWB_OFFSET_128_64: "Int32Array", SWB_OFFSET_128_48: "Int32Array", SWB_OFFSET_128_24: "Int32Array", SWB_OFFSET_128_16: "Int32Array", SWB_OFFSET_128_8: "Int32Array", SWB_OFFSET_SHORT_WINDOW: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var SoundFilter = function() {};
SoundFilter = stjs.extend(SoundFilter, null, [], function(constructor, prototype) {
    constructor.sine = new Int32Array([0, 1, 3, 4, 6, 7, 9, 10, 12, 14, 15, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 32, 34, 36, 37, 39, 40, 42, 43, 45, 47, 48, 50, 51, 53, 54, 56, 57, 59, 61, 62, 64, 65, 67, 68, 70, 72, 73, 75, 76, 78, 79, 81, 82, 84, 85, 87, 89, 90, 92, 93, 95, 96, 98, 99, 101, 102, 104, 106, 107, 109, 110, 112, 113, 115, 116, 118, 119, 121, 122, 124, 125, 127, 128, 130, 132, 133, 135, 136, 138, 139, 141, 142, 144, 145, 147, 148, 150, 151, 153, 154, 156, 157, 159, 160, 162, 163, 165, 166, 168, 169, 171, 172, 173, 175, 176, 178, 179, 181, 182, 184, 185, 187, 188, 190, 191, 193, 194, 195, 197, 198, 200, 201, 203, 204, 206, 207, 208, 210, 211, 213, 214, 216, 217, 218, 220, 221, 223, 224, 225, 227, 228, 230, 231, 233, 234, 235, 237, 238, 239, 241, 242, 244, 245, 246, 248, 249, 250, 252, 253, 255, 256, 257, 259, 260, 261, 263, 264, 265, 267, 268, 269, 271, 272, 273, 275, 276, 277, 279, 280, 281, 283, 284, 285, 287, 288, 289, 290, 292, 293, 294, 296, 297, 298, 299, 301, 302, 303, 304, 306, 307, 308, 310, 311, 312, 313, 314, 316, 317, 318, 319, 321, 322, 323, 324, 326, 327, 328, 329, 330, 332, 333, 334, 335, 336, 337, 339, 340, 341, 342, 343, 345, 346, 347, 348, 349, 350, 351, 353, 354, 355, 356, 357, 358, 359, 360, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 423, 424, 425, 426, 427, 428, 429, 430, 430, 431, 432, 433, 434, 435, 435, 436, 437, 438, 439, 439, 440, 441, 442, 443, 443, 444, 445, 446, 447, 447, 448, 449, 450, 450, 451, 452, 453, 453, 454, 455, 455, 456, 457, 458, 458, 459, 460, 460, 461, 462, 462, 463, 464, 464, 465, 466, 466, 467, 468, 468, 469, 469, 470, 471, 471, 472, 473, 473, 474, 474, 475, 475, 476, 477, 477, 478, 478, 479, 479, 480, 481, 481, 482, 482, 483, 483, 484, 484, 485, 485, 486, 486, 487, 487, 488, 488, 489, 489, 489, 490, 490, 491, 491, 492, 492, 493, 493, 493, 494, 494, 495, 495, 495, 496, 496, 497, 497, 497, 498, 498, 498, 499, 499, 499, 500, 500, 500, 501, 501, 501, 502, 502, 502, 503, 503, 503, 503, 504, 504, 504, 504, 505, 505, 505, 505, 506, 506, 506, 506, 507, 507, 507, 507, 507, 508, 508, 508, 508, 508, 509, 509, 509, 509, 509, 509, 509, 510, 510, 510, 510, 510, 510, 510, 510, 511, 511, 511, 511, 511, 511, 511, 511, 511, 511, 511, 511, 511, 511, 511, 511, 511, 511, 511, 511]);
    constructor.linear = new Int32Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511]);
    constructor.in16BitSignedLE = function(b, nCh, func) {
        var to = Math.min(b.length * nCh * 2, func.length);
        var off = 0;
        for (var i = 0; i < to; i++) {
            for (var j = 0; j < nCh; j++) {
                var sample = ((((b[off] & 255) | ((b[off + 1] & 255) << 8))) << 16 >> 16);
                sample = ((((sample * func[i]) >> 9)) << 16 >> 16);
                b[off] = ((sample & 255) << 24 >> 24);
                b[off + 1] = ((sample >> 8) << 24 >> 24);
                off += 2;
            }
        }
    };
    constructor.out16BitSignedLE = function(b, nCh, func) {
        var to = Math.min(b.length * nCh * 2, func.length);
        var off = b.length - (to * nCh * 2);
        for (var i = 0; i < to; i++) {
            for (var j = 0; j < nCh; j++) {
                var sample = ((((b[off] & 255) | ((b[off + 1] & 255) << 8))) << 16 >> 16);
                sample = ((((sample * func[512 - i - 1]) >> 9)) << 16 >> 16);
                b[off] = ((sample & 255) << 24 >> 24);
                b[off + 1] = ((sample >> 8) << 24 >> 24);
                off += 2;
            }
        }
    };
    constructor._in = function(fmt, samples, func) {
        SoundFilter.in16BitSignedLE(samples, fmt.getChannels(), func);
    };
    constructor.out = function(fmt, samples, func) {
        SoundFilter.out16BitSignedLE(samples, fmt.getChannels(), func);
    };
}, {sine: "Int32Array", linear: "Int32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  @author The JCodec project
 */
var HRDParameters = function() {};
HRDParameters = stjs.extend(HRDParameters, null, [], function(constructor, prototype) {
    prototype.cpb_cnt_minus1 = 0;
    prototype.bit_rate_scale = 0;
    prototype.cpb_size_scale = 0;
    prototype.bit_rate_value_minus1 = null;
    prototype.cpb_size_value_minus1 = null;
    prototype.cbr_flag = null;
    prototype.initial_cpb_removal_delay_length_minus1 = 0;
    prototype.cpb_removal_delay_length_minus1 = 0;
    prototype.dpb_output_delay_length_minus1 = 0;
    prototype.time_offset_length = 0;
}, {bit_rate_value_minus1: "Int32Array", cpb_size_value_minus1: "Int32Array", cbr_flag: "Int8Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Unit = stjs.enumeration("FRAME", "SEC");
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var RateControl = function() {};
RateControl = stjs.extend(RateControl, null, [], function(constructor, prototype) {
    prototype.getSegmentQps = function() {};
    prototype.getSegment = function() {};
    prototype.report = function(bits) {};
    prototype.reset = function() {};
}, {}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  The MSMask indicates, if MS is applied to a specific ICStream.
 *  
 *  @author in-somnia
 */
var MSMask = stjs.enumeration("TYPE_ALL_0", "TYPE_USED", "TYPE_ALL_1", "TYPE_RESERVED");
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  @author in-somnia
 */
var FilterbankTable = function() {};
FilterbankTable = stjs.extend(FilterbankTable, null, [], function(constructor, prototype) {
    constructor.qmf_c = new Float32Array([0.0, -5.5252865E-4, -5.6176924E-4, -4.947518E-4, -4.875228E-4, -4.893791E-4, -5.040714E-4, -5.226564E-4, -5.4665655E-4, -5.677803E-4, -5.8709306E-4, -6.1327475E-4, -6.3124934E-4, -6.540333E-4, -6.777691E-4, -6.9416146E-4, -7.1577367E-4, -7.255043E-4, -7.440942E-4, -7.490598E-4, -7.6813716E-4, -7.7248487E-4, -7.834332E-4, -7.7798695E-4, -7.803665E-4, -7.8014494E-4, -7.7579776E-4, -7.630794E-4, -7.5300015E-4, -7.319357E-4, -7.215392E-4, -6.9179374E-4, -6.650415E-4, -6.341595E-4, -5.946119E-4, -5.564576E-4, -5.1455724E-4, -4.6063255E-4, -4.0951214E-4, -3.501176E-4, -2.8969813E-4, -2.0983373E-4, -1.4463809E-4, -6.173344E-5, 1.3494974E-5, 1.0943831E-4, 2.043017E-4, 2.9495312E-4, 4.0265403E-4, 5.107389E-4, 6.2393764E-4, 7.458026E-4, 8.6084433E-4, 9.885988E-4, 0.0011250156, 0.0012577885, 0.0013902495, 0.001544322, 0.0016868083, 0.0018348265, 0.001984114, 0.0021461584, 0.0023017256, 0.0024625617, 0.002620176, 0.0027870464, 0.0029469447, 0.003112542, 0.0032739614, 0.0034418874, 0.0036008267, 0.0037603923, 0.0039207432, 0.004081975, 0.004226427, 0.004373072, 0.0045209853, 0.004660646, 0.004793256, 0.0049137603, 0.005039302, 0.0051407353, 0.005246117, 0.005347168, 0.0054196776, 0.005487604, 0.0055475715, 0.0055938023, 0.005622064, 0.0056455196, 0.00563892, 0.0056266114, 0.005591713, 0.0055404366, 0.005475378, 0.0053838976, 0.005271576, 0.0051382277, 0.0049839686, 0.004810947, 0.004603953, 0.004380186, 0.0041251644, 0.003845641, 0.0035401247, 0.0032091886, 0.0028446757, 0.002450854, 0.0020274175, 0.0015784682, 0.0010902329, 5.8322644E-4, 2.760452E-5, -5.464281E-4, -0.0011568136, -0.0018039473, -0.0024826725, -0.0031933777, -0.0039401124, -0.0047222595, -0.0055337213, -0.0063792295, -0.0072615817, -0.008179823, -0.009132533, -0.010115022, -0.011131555, -0.012185, 0.013271822, 0.014390467, 0.015540555, 0.016732471, 0.017943338, 0.019187244, 0.02045318, 0.021746755, 0.023068016, 0.024416098, 0.025787584, 0.027185943, 0.028607218, 0.030050267, 0.031501763, 0.03297541, 0.034462094, 0.035969757, 0.037481286, 0.03900537, 0.040534917, 0.04206491, 0.043609753, 0.045148842, 0.046684302, 0.04821657, 0.049738575, 0.051255617, 0.052763075, 0.05424528, 0.055717364, 0.057161644, 0.058591567, 0.05998375, 0.061345518, 0.06268578, 0.06397159, 0.06522471, 0.06643675, 0.0676076, 0.06870438, 0.06976303, 0.07076287, 0.07170027, 0.07256826, 0.07336202, 0.07410037, 0.07474525, 0.07531373, 0.075800836, 0.07619925, 0.076499216, 0.07670935, 0.0768174, 0.076823, 0.07672049, 0.07650507, 0.07617483, 0.07573058, 0.07515763, 0.07446644, 0.0736406, 0.07267746, 0.07158264, 0.07035331, 0.0689664, 0.067452505, 0.06576907, 0.06394448, 0.061960276, 0.05981666, 0.05751527, 0.055046003, 0.05240938, 0.049597867, 0.04663033, 0.04347688, 0.04014583, 0.03664181, 0.032958392, 0.0290824, 0.025030756, 0.020799708, 0.016370125, 0.011762383, 0.006963686, 0.00197656, -0.0032086896, -0.008571175, -0.014128882, -0.019883413, -0.025822729, -0.031953126, -0.038277656, -0.044780683, -0.051480416, -0.058370534, -0.06544098, -0.07269433, -0.08013729, -0.087754756, -0.09555334, -0.103532955, -0.11168269, -0.1200078, -0.12850028, -0.13715518, -0.14597665, -0.1549607, -0.16409588, -0.17338082, -0.18281725, -0.19239667, -0.20212501, -0.2119736, -0.22196527, -0.23206909, -0.24230169, -0.25264803, -0.26310533, -0.2736634, -0.28432143, -0.29507166, -0.30590987, -0.3168279, -0.32781136, -0.33887228, -0.3499914, 0.361159, 0.37237954, 0.383635, 0.39492118, 0.40623176, 0.4175697, 0.42891198, 0.44025537, 0.45159966, 0.4629308, 0.4742453, 0.4855253, 0.49677083, 0.5079818, 0.5191235, 0.5302241, 0.54125535, 0.55220515, 0.56307894, 0.5738524, 0.5845403, 0.5951123, 0.60557836, 0.615911, 0.62612426, 0.636198, 0.646127, 0.6559016, 0.665514, 0.67496634, 0.68423533, 0.69332826, 0.70223886, 0.710941, 0.71944624, 0.7277449, 0.7358212, 0.7436828, 0.75131375, 0.75870806, 0.7658675, 0.7727781, 0.7794288, 0.7858353, 0.7919736, 0.7978466, 0.80344856, 0.8087695, 0.8138191, 0.8185776, 0.823042, 0.82722753, 0.83110386, 0.83469373, 0.83797175, 0.8409541, 0.8436238, 0.84598184, 0.8480316, 0.8497805, 0.8511971, 0.8523047, 0.8531021, 0.8535721, 0.85373855, 0.8535721, 0.8531021, 0.8523047, 0.8511971, 0.8497805, 0.8480316, 0.84598184, 0.8436238, 0.8409541, 0.83797175, 0.83469373, 0.83110386, 0.82722753, 0.823042, 0.8185776, 0.8138191, 0.8087695, 0.80344856, 0.7978466, 0.7919736, 0.7858353, 0.7794288, 0.7727781, 0.7658675, 0.75870806, 0.75131375, 0.7436828, 0.7358212, 0.7277449, 0.71944624, 0.710941, 0.70223886, 0.69332826, 0.68423533, 0.67496634, 0.665514, 0.6559016, 0.646127, 0.636198, 0.62612426, 0.615911, 0.60557836, 0.5951123, 0.5845403, 0.5738524, 0.56307894, 0.55220515, 0.54125535, 0.5302241, 0.5191235, 0.5079818, 0.49677083, 0.4855253, 0.4742453, 0.4629308, 0.45159966, 0.44025537, 0.42891198, 0.4175697, 0.40623176, 0.39492118, 0.383635, 0.37237954, -0.361159, -0.3499914, -0.33887228, -0.32781136, -0.3168279, -0.30590987, -0.29507166, -0.28432143, -0.2736634, -0.26310533, -0.25264803, -0.24230169, -0.23206909, -0.22196527, -0.2119736, -0.20212501, -0.19239667, -0.18281725, -0.17338082, -0.16409588, -0.1549607, -0.14597665, -0.13715518, -0.12850028, -0.1200078, -0.11168269, -0.103532955, -0.09555334, -0.087754756, -0.08013729, -0.07269433, -0.06544098, -0.058370534, -0.051480416, -0.044780683, -0.038277656, -0.031953126, -0.025822729, -0.019883413, -0.014128882, -0.008571175, -0.0032086896, 0.00197656, 0.006963686, 0.011762383, 0.016370125, 0.020799708, 0.025030756, 0.0290824, 0.032958392, 0.03664181, 0.04014583, 0.04347688, 0.04663033, 0.049597867, 0.05240938, 0.055046003, 0.05751527, 0.05981666, 0.061960276, 0.06394448, 0.06576907, 0.067452505, 0.0689664, 0.07035331, 0.07158264, 0.07267746, 0.0736406, 0.07446644, 0.07515763, 0.07573058, 0.07617483, 0.07650507, 0.07672049, 0.076823, 0.0768174, 0.07670935, 0.076499216, 0.07619925, 0.075800836, 0.07531373, 0.07474525, 0.07410037, 0.07336202, 0.07256826, 0.07170027, 0.07076287, 0.06976303, 0.06870438, 0.0676076, 0.06643675, 0.06522471, 0.06397159, 0.06268578, 0.061345518, 0.05998375, 0.058591567, 0.057161644, 0.055717364, 0.05424528, 0.052763075, 0.051255617, 0.049738575, 0.04821657, 0.046684302, 0.045148842, 0.043609753, 0.04206491, 0.040534917, 0.03900537, 0.037481286, 0.035969757, 0.034462094, 0.03297541, 0.031501763, 0.030050267, 0.028607218, 0.027185943, 0.025787584, 0.024416098, 0.023068016, 0.021746755, 0.02045318, 0.019187244, 0.017943338, 0.016732471, 0.015540555, 0.014390467, -0.013271822, -0.012185, -0.011131555, -0.010115022, -0.009132533, -0.008179823, -0.0072615817, -0.0063792295, -0.0055337213, -0.0047222595, -0.0039401124, -0.0031933777, -0.0024826725, -0.0018039473, -0.0011568136, -5.464281E-4, 2.760452E-5, 5.8322644E-4, 0.0010902329, 0.0015784682, 0.0020274175, 0.002450854, 0.0028446757, 0.0032091886, 0.0035401247, 0.003845641, 0.0041251644, 0.004380186, 0.004603953, 0.004810947, 0.0049839686, 0.0051382277, 0.005271576, 0.0053838976, 0.005475378, 0.0055404366, 0.005591713, 0.0056266114, 0.00563892, 0.0056455196, 0.005622064, 0.0055938023, 0.0055475715, 0.005487604, 0.0054196776, 0.005347168, 0.005246117, 0.0051407353, 0.005039302, 0.0049137603, 0.004793256, 0.004660646, 0.0045209853, 0.004373072, 0.004226427, 0.004081975, 0.0039207432, 0.0037603923, 0.0036008267, 0.0034418874, 0.0032739614, 0.003112542, 0.0029469447, 0.0027870464, 0.002620176, 0.0024625617, 0.0023017256, 0.0021461584, 0.001984114, 0.0018348265, 0.0016868083, 0.001544322, 0.0013902495, 0.0012577885, 0.0011250156, 9.885988E-4, 8.6084433E-4, 7.458026E-4, 6.2393764E-4, 5.107389E-4, 4.0265403E-4, 2.9495312E-4, 2.043017E-4, 1.0943831E-4, 1.3494974E-5, -6.173344E-5, -1.4463809E-4, -2.0983373E-4, -2.8969813E-4, -3.501176E-4, -4.0951214E-4, -4.6063255E-4, -5.1455724E-4, -5.564576E-4, -5.946119E-4, -6.341595E-4, -6.650415E-4, -6.9179374E-4, -7.215392E-4, -7.319357E-4, -7.5300015E-4, -7.630794E-4, -7.7579776E-4, -7.8014494E-4, -7.803665E-4, -7.7798695E-4, -7.834332E-4, -7.7248487E-4, -7.6813716E-4, -7.490598E-4, -7.440942E-4, -7.255043E-4, -7.1577367E-4, -6.9416146E-4, -6.777691E-4, -6.540333E-4, -6.3124934E-4, -6.1327475E-4, -5.8709306E-4, -5.677803E-4, -5.4665655E-4, -5.226564E-4, -5.040714E-4, -4.893791E-4, -4.875228E-4, -4.947518E-4, -5.6176924E-4, -5.5252865E-4]);
}, {qmf_c: "Float32Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 * 
 *  @author in-somnia
 */
var DCT = function() {};
DCT = stjs.extend(DCT, null, [], function(constructor, prototype) {
    constructor.n = 32;
    constructor.w_array_real = new Float32Array([1.0, 0.98078525, 0.9238795, 0.8314696, 0.70710677, 0.5555702, 0.3826834, 0.19509028, 0.0, -0.19509037, -0.3826835, -0.5555703, -0.7071068, -0.83146966, -0.92387956, -0.9807853]);
    constructor.w_array_imag = new Float32Array([0.0, -0.19509032, -0.38268346, -0.55557024, -0.70710677, -0.83146966, -0.92387956, -0.9807853, -1.0, -0.98078525, -0.9238795, -0.8314696, -0.7071067, -0.5555702, -0.38268337, -0.19509023]);
    constructor.dct4_64_tab = new Float32Array([0.9999247, 0.9981181, 0.993907, 0.9873014, 0.9783174, 0.96697646, 0.953306, 0.937339, 0.9191139, 0.8986745, 0.8760701, 0.8513552, 0.82458925, 0.7958369, 0.76516724, 0.7326543, 0.69837624, 0.66241574, 0.62485945, 0.58579785, 0.545325, 0.5035384, 0.46053872, 0.41642955, 0.37131715, 0.32531023, 0.2785196, 0.23105814, 0.18303989, 0.13458069, 0.08579727, 0.036807165, -1.0121963, -1.0594388, -1.1041292, -1.1461595, -1.1854287, -1.2218422, -1.255312, -1.2857577, -1.313106, -1.3372908, -1.3582538, -1.3759449, -1.390321, -1.4013479, -1.4089987, -1.4132552, -1.4141071, -1.4115522, -1.4055967, -1.396255, -1.3835497, -1.3675113, -1.3481784, -1.3255975, -1.2998233, -1.2709177, -1.2389501, -1.2039981, -1.1661453, -1.1254834, -1.0821099, -1.0361296, -0.9876532, -0.9367974, -0.88368475, -0.8284433, -0.771206, -0.71211076, -0.6513001, -0.58892035, -0.5251218, -0.46005824, -0.39388633, -0.32676548, -0.25885743, -0.19032592, -0.121335685, -0.052053273, 0.017354608, 0.086720645, 0.15587783, 0.22465932, 0.29289973, 0.3604344, 0.42710093, 0.49273846, 0.5571889, 0.62029713, 0.681911, 0.74188185, 0.8000656, 0.856322, 0.91051537, 0.96251523, 1.0, 0.99879545, 0.9951847, 0.9891765, 0.98078525, 0.97003126, 0.95694035, 0.94154406, 0.9238795, 0.9039893, 0.88192123, 0.8577286, 0.8314696, 0.8032075, 0.77301043, 0.7409511, 0.70710677, 0.6715589, 0.6343933, 0.5956993, 0.5555702, 0.5141027, 0.47139665, 0.4275551, 0.38268343, 0.33688983, 0.29028463, 0.24298012, 0.19509023, 0.1467305, 0.098017134, 0.04906765, -1.0, -1.0478631, -1.0932019, -1.1359069, -1.1758755, -1.2130115, -1.247225, -1.2784339, -1.3065629, -1.3315444, -1.353318, -1.3718314, -1.3870399, -1.3989068, -1.4074037, -1.4125102, 0.0, -1.4125102, -1.4074037, -1.3989068, -1.3870399, -1.3718314, -1.353318, -1.3315444, -1.3065629, -1.2784339, -1.247225, -1.2130114, -1.1758755, -1.135907, -1.0932019, -1.0478631, -1.0, -0.9497278, -0.89716756, -0.842446, -0.78569496, -0.7270511, -0.66665566, -0.6046542, -0.54119605, -0.47643423, -0.4105245, -0.34362584, -0.27589935, -0.2075082, -0.1386171, -0.069392145, 0.0, 0.069392264, 0.13861716, 0.2075082, 0.27589947, 0.34362596, 0.41052464, 0.4764342, 0.5411961, 0.6046542, 0.6666557, 0.72705114, 0.7856951, 0.842446, 0.89716756, 0.9497278]);
    constructor.bit_rev_tab = new Int32Array([0, 16, 8, 24, 4, 20, 12, 28, 2, 18, 10, 26, 6, 22, 14, 30, 1, 17, 9, 25, 5, 21, 13, 29, 3, 19, 11, 27, 7, 23, 15, 31]);
    constructor.fft_dif = function(Real, Imag) {
        var w_real, w_imag;
        var point1_real, point1_imag, point2_real, point2_imag;
        var j, i, i2, w_index;
        for (i = 0; i < 16; i++) {
            point1_real = Real[i];
            point1_imag = Imag[i];
            i2 = i + 16;
            point2_real = Real[i2];
            point2_imag = Imag[i2];
            w_real = DCT.w_array_real[i];
            w_imag = DCT.w_array_imag[i];
            point1_real -= point2_real;
            point1_imag -= point2_imag;
            Real[i] += point2_real;
            Imag[i] += point2_imag;
            Real[i2] = ((point1_real * w_real) - (point1_imag * w_imag));
            Imag[i2] = ((point1_real * w_imag) + (point1_imag * w_real));
        }
        for (j = 0 , w_index = 0; j < 8; j++ , w_index += 2) {
            w_real = DCT.w_array_real[w_index];
            w_imag = DCT.w_array_imag[w_index];
            i = j;
            point1_real = Real[i];
            point1_imag = Imag[i];
            i2 = i + 8;
            point2_real = Real[i2];
            point2_imag = Imag[i2];
            point1_real -= point2_real;
            point1_imag -= point2_imag;
            Real[i] += point2_real;
            Imag[i] += point2_imag;
            Real[i2] = ((point1_real * w_real) - (point1_imag * w_imag));
            Imag[i2] = ((point1_real * w_imag) + (point1_imag * w_real));
            i = j + 16;
            point1_real = Real[i];
            point1_imag = Imag[i];
            i2 = i + 8;
            point2_real = Real[i2];
            point2_imag = Imag[i2];
            point1_real -= point2_real;
            point1_imag -= point2_imag;
            Real[i] += point2_real;
            Imag[i] += point2_imag;
            Real[i2] = ((point1_real * w_real) - (point1_imag * w_imag));
            Imag[i2] = ((point1_real * w_imag) + (point1_imag * w_real));
        }
        for (i = 0; i < DCT.n; i += 8) {
            i2 = i + 4;
            point1_real = Real[i];
            point1_imag = Imag[i];
            point2_real = Real[i2];
            point2_imag = Imag[i2];
            Real[i] += point2_real;
            Imag[i] += point2_imag;
            Real[i2] = point1_real - point2_real;
            Imag[i2] = point1_imag - point2_imag;
        }
        w_real = DCT.w_array_real[4];
        for (i = 1; i < DCT.n; i += 8) {
            i2 = i + 4;
            point1_real = Real[i];
            point1_imag = Imag[i];
            point2_real = Real[i2];
            point2_imag = Imag[i2];
            point1_real -= point2_real;
            point1_imag -= point2_imag;
            Real[i] += point2_real;
            Imag[i] += point2_imag;
            Real[i2] = (point1_real + point1_imag) * w_real;
            Imag[i2] = (point1_imag - point1_real) * w_real;
        }
        for (i = 2; i < DCT.n; i += 8) {
            i2 = i + 4;
            point1_real = Real[i];
            point1_imag = Imag[i];
            point2_real = Real[i2];
            point2_imag = Imag[i2];
            Real[i] += point2_real;
            Imag[i] += point2_imag;
            Real[i2] = point1_imag - point2_imag;
            Imag[i2] = point2_real - point1_real;
        }
        w_real = DCT.w_array_real[12];
        for (i = 3; i < DCT.n; i += 8) {
            i2 = i + 4;
            point1_real = Real[i];
            point1_imag = Imag[i];
            point2_real = Real[i2];
            point2_imag = Imag[i2];
            point1_real -= point2_real;
            point1_imag -= point2_imag;
            Real[i] += point2_real;
            Imag[i] += point2_imag;
            Real[i2] = (point1_real - point1_imag) * w_real;
            Imag[i2] = (point1_real + point1_imag) * w_real;
        }
        for (i = 0; i < DCT.n; i += 4) {
            i2 = i + 2;
            point1_real = Real[i];
            point1_imag = Imag[i];
            point2_real = Real[i2];
            point2_imag = Imag[i2];
            Real[i] += point2_real;
            Imag[i] += point2_imag;
            Real[i2] = point1_real - point2_real;
            Imag[i2] = point1_imag - point2_imag;
        }
        for (i = 1; i < DCT.n; i += 4) {
            i2 = i + 2;
            point1_real = Real[i];
            point1_imag = Imag[i];
            point2_real = Real[i2];
            point2_imag = Imag[i2];
            Real[i] += point2_real;
            Imag[i] += point2_imag;
            Real[i2] = point1_imag - point2_imag;
            Imag[i2] = point2_real - point1_real;
        }
        for (i = 0; i < DCT.n; i += 2) {
            i2 = i + 1;
            point1_real = Real[i];
            point1_imag = Imag[i];
            point2_real = Real[i2];
            point2_imag = Imag[i2];
            Real[i] += point2_real;
            Imag[i] += point2_imag;
            Real[i2] = point1_real - point2_real;
            Imag[i2] = point1_imag - point2_imag;
        }
    };
    constructor.dct4_kernel = function(in_real, in_imag, out_real, out_imag) {
        var i, i_rev;
        for (i = 0; i < 32; i++) {
            var x_re, x_im, tmp;
            x_re = in_real[i];
            x_im = in_imag[i];
            tmp = (x_re + x_im) * DCT.dct4_64_tab[i];
            in_real[i] = (x_im * DCT.dct4_64_tab[i + 64]) + tmp;
            in_imag[i] = (x_re * DCT.dct4_64_tab[i + 32]) + tmp;
        }
        DCT.fft_dif(in_real, in_imag);
        for (i = 0; i < 16; i++) {
            var x_re, x_im, tmp;
            i_rev = DCT.bit_rev_tab[i];
            x_re = in_real[i_rev];
            x_im = in_imag[i_rev];
            tmp = (x_re + x_im) * DCT.dct4_64_tab[i + 3 * 32];
            out_real[i] = (x_im * DCT.dct4_64_tab[i + 5 * 32]) + tmp;
            out_imag[i] = (x_re * DCT.dct4_64_tab[i + 4 * 32]) + tmp;
        }
        out_imag[16] = (in_imag[1] - in_real[1]) * DCT.dct4_64_tab[16 + 3 * 32];
        out_real[16] = (in_real[1] + in_imag[1]) * DCT.dct4_64_tab[16 + 3 * 32];
        for (i = 17; i < 32; i++) {
            var x_re, x_im, tmp;
            i_rev = DCT.bit_rev_tab[i];
            x_re = in_real[i_rev];
            x_im = in_imag[i_rev];
            tmp = (x_re + x_im) * DCT.dct4_64_tab[i + 3 * 32];
            out_real[i] = (x_im * DCT.dct4_64_tab[i + 5 * 32]) + tmp;
            out_imag[i] = (x_re * DCT.dct4_64_tab[i + 4 * 32]) + tmp;
        }
    };
}, {w_array_real: "Float32Array", w_array_imag: "Float32Array", dct4_64_tab: "Float32Array", bit_rev_tab: "Int32Array"}, {});
var LogSink = function() {};
LogSink = stjs.extend(LogSink, null, [], function(constructor, prototype) {
    prototype.postMessage = function(msg) {};
}, {}, {});
var Message = function(level, fileName, className, methodName, lineNumber, message) {
    this.level = level;
    this.fileName = fileName;
    this.className = className;
    this.methodName = methodName;
    this.message = methodName;
    this.lineNumber = lineNumber;
    this.message = message;
};
Message = stjs.extend(Message, null, [], function(constructor, prototype) {
    prototype.level = null;
    prototype.fileName = null;
    prototype.className = null;
    prototype.lineNumber = 0;
    prototype.message = null;
    prototype.methodName = null;
    prototype.getLevel = function() {
        return this.level;
    };
    prototype.getFileName = function() {
        return this.fileName;
    };
    prototype.getClassName = function() {
        return this.className;
    };
    prototype.getMethodName = function() {
        return this.methodName;
    };
    prototype.getLineNumber = function() {
        return this.lineNumber;
    };
    prototype.getMessage = function() {
        return this.message;
    };
}, {level: {name: "Enum", arguments: ["LogLevel"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  This header specifies which component(s) are contained in the scan, specifies
 *  the destinations from which the entropy tables to be used with each component
 *  are retrieved, and (for the progressive DCT) which part of the DCT quantized
 *  coefficient data is contained in the scan. For lossless processes the scan
 *  parameters specify the predictor and the point transform.
 *  
 *  @author The JCodec project
 */
var ScanHeader = function() {};
ScanHeader = stjs.extend(ScanHeader, null, [], function(constructor, prototype) {
    /**
     *  Scan header length. Specifies the length of the scan header shown in
     *  Figure B.4 (see B.1.1.4).
     */
    prototype.ls = 0;
    /**
     *  Number of image components in scan. Specifies the number of source image
     *  components in the scan. The value of Ns shall be equal to the number of
     *  sets of scan component specification parameters (Csj, Tdj, and Taj)
     *  present in the scan header.
     */
    prototype.ns = 0;
    prototype.isInterleaved = function() {
        return this.ns > 1;
    };
    constructor.Component = function() {};
    constructor.Component = stjs.extend(constructor.Component, null, [], function(constructor, prototype) {
        /**
         *  Scan component selector. Selects which of the Nf image components
         *  specified in the frame parameters shall be the jth component in the
         *  scan. Each Csj shall match one of the Ci values specified in the
         *  frame header, and the ordering in the scan header shall follow the
         *  ordering in the frame header. If Ns > 1, the order of interleaved
         *  components in the MCU is Cs1 first, Cs2 second, etc. If Ns > 1, the
         *  following restriction shall be placed on the image components
         *  contained in the scan:
         *  
         *  <pre>
         *  [j=1..Ns](Hj x Vj) &lt;= 10
         *  </pre>
         *  
         *  where Hj and Vj are the horizontal and vertical sampling factors for
         *  scan component j. These sampling factors are specified in the frame
         *  header for component i, where i is the frame component specification
         *  index for which frame component identifier Ci matches scan component
         *  selector Csj. As an example, consider an image having 3 components
         *  with maximum dimensions of 512 lines and 512 samples per line, and
         *  with the following sampling factors: Component Component 1 Component
         *  2 2 0 4 1 1 2 2 2 0 0 1 1 2 H V H V H V = = = = = = , , Then the
         *  summation of Hj Vj is (4 1) + (1 2) + (2 2) = 10. The value of Csj
         *  shall be different from the values of Cs1 to Csj 1.
         */
        prototype.cs = 0;
        /**
         *  DC entropy coding table destination selector. Specifies one of four
         *  possible DC entropy coding table destinations from which the entropy
         *  table needed for decoding of the DC coefficients of component Csj is
         *  retrieved. The DC entropy table shall have been installed in this
         *  destination (see B.2.4.2 and B.2.4.3) by the time the decoder is
         *  ready to decode the current scan. This parameter specifies the
         *  entropy coding table destination for the lossless processes.
         */
        prototype.td = 0;
        /**
         *  AC entropy coding table destination selector. Specifies one of four
         *  possible AC entropy coding table destinations from which the entropy
         *  table needed for decoding of the AC coefficients of component Csj is
         *  retrieved. The AC entropy table selected shall have been installed in
         *  this destination (see B.2.4.2 and B.2.4.3) by the time the decoder is
         *  ready to decode the current scan. This parameter is zero for the
         *  lossless processes.
         */
        prototype.ta = 0;
    }, {}, {});
    prototype.components = null;
    /**
     *  Start of spectral or predictor selection. In the DCT modes of operation,
     *  this parameter specifies the first DCT coefficient in each block in
     *  zig-zag order which shall be coded in the scan. This parameter shall be
     *  set to zero for the sequential DCT processes. In the lossless mode of
     *  operations this parameter is used to select the predictor.
     */
    prototype.ss = 0;
    /**
     *  End of spectral selection. Specifies the last DCT coefficient in each
     *  block in zig-zag order which shall be coded in the scan. This parameter
     *  shall be set to 63 for the sequential DCT processes. In the lossless mode
     *  of operations this parameter has no meaning. It shall be set to zero.
     */
    prototype.se = 0;
    /**
     *  Successive approximation bit position high. This parameter specifies the
     *  point transform used in the preceding scan (i.e. successive approximation
     *  bit position low in the preceding scan) for the band of coefficients
     *  specified by Ss and Se. This parameter shall be set to zero for the first
     *  scan of each band of coefficients. In the lossless mode of operations
     *  this parameter has no meaning. It shall be set to zero.
     */
    prototype.ah = 0;
    /**
     *  Successive approximation bit position low or point transform. In the DCT
     *  modes of operation this parameter specifies the point transform, i.e. bit
     *  position low, used before coding the band of coefficients specified by Ss
     *  and Se. This parameter shall be set to zero for the sequential DCT
     *  processes. In the lossless mode of operations, this parameter specifies
     *  the point transform, Pt.
     */
    prototype.al = 0;
    constructor.read = function(bb) {
        var scan = new ScanHeader();
        scan.ls = bb.getShort() & 65535;
        scan.ns = bb.get() & 255;
        scan.components = Array(scan.ns);
        for (var i = 0; i < scan.components.length; i++) {
            var c = scan.components[i] = new ScanHeader.Component();
            c.cs = bb.get() & 255;
            var tdta = bb.get() & 255;
            c.td = (tdta & 240) >>> 4;
            c.ta = (tdta & 15);
        }
        scan.ss = bb.get() & 255;
        scan.se = bb.get() & 255;
        var ahal = bb.get() & 255;
        scan.ah = (ahal & 240) >>> 4;
        scan.al = (ahal & 15);
        return scan;
    };
}, {components: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Shared constants for H264 CABAC M encoder/decoder
 *  
 *  @author The JCodec project
 *  
 */
var MConst = function() {};
MConst = stjs.extend(MConst, null, [], function(constructor, prototype) {
    constructor.rangeLPS = [new Int32Array([128, 128, 128, 123, 116, 111, 105, 100, 95, 90, 85, 81, 77, 73, 69, 66, 62, 59, 56, 53, 51, 48, 46, 43, 41, 39, 37, 35, 33, 32, 30, 29, 27, 26, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 14, 13, 12, 12, 11, 11, 10, 10, 9, 9, 8, 8, 7, 7, 7, 6, 6, 6, 2]), new Int32Array([176, 167, 158, 150, 142, 135, 128, 122, 116, 110, 104, 99, 94, 89, 85, 80, 76, 72, 69, 65, 62, 59, 56, 53, 50, 48, 45, 43, 41, 39, 37, 35, 33, 31, 30, 28, 27, 26, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 14, 13, 12, 12, 11, 11, 10, 9, 9, 9, 8, 8, 7, 7, 2]), new Int32Array([208, 197, 187, 178, 169, 160, 152, 144, 137, 130, 123, 117, 111, 105, 100, 95, 90, 86, 81, 77, 73, 69, 66, 63, 59, 56, 54, 51, 48, 46, 43, 41, 39, 37, 35, 33, 32, 30, 29, 27, 26, 25, 23, 22, 21, 20, 19, 18, 17, 16, 15, 15, 14, 13, 12, 12, 11, 11, 10, 10, 9, 9, 8, 2]), new Int32Array([240, 227, 216, 205, 195, 185, 175, 166, 158, 150, 142, 135, 128, 122, 116, 110, 104, 99, 94, 89, 85, 80, 76, 72, 69, 65, 62, 59, 56, 53, 50, 48, 45, 43, 41, 39, 37, 35, 33, 31, 30, 28, 27, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 14, 13, 12, 12, 11, 11, 10, 9, 2])];
    constructor.transitLPS = new Int32Array([0, 0, 1, 2, 2, 4, 4, 5, 6, 7, 8, 9, 9, 11, 11, 12, 13, 13, 15, 15, 16, 16, 18, 18, 19, 19, 21, 21, 22, 22, 23, 24, 24, 25, 26, 26, 27, 27, 28, 29, 29, 30, 30, 30, 31, 32, 32, 33, 33, 33, 34, 34, 35, 35, 35, 36, 36, 36, 37, 37, 37, 38, 38, 63]);
}, {rangeLPS: "Array", transitLPS: "Int32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  This header specifies the source image characteristics (see A.1), the
 *  components in the frame, and the sampling factors for each component, and
 *  specifies the destinations from which the quantized tables to be used with
 *  each component are retrieved.
 *  
 *  @author The JCodec project
 */
var FrameHeader = function() {};
FrameHeader = stjs.extend(FrameHeader, null, [], function(constructor, prototype) {
    /**
     *  Frame header length. Specifies the length of the frame header shown in
     *  Figure B.3 (see B.1.1.4).
     */
    prototype.headerLength = 0;
    /**
     *  Sample precision. Specifies the precision in bits for the samples of the
     *  components in the frame.
     */
    prototype.bitsPerSample = 0;
    /**
     *  Number of lines. Specifies the maximum number of lines in the source
     *  image. This shall be equal to the number of lines in the component with
     *  the maximum number of vertical samples (see A.1.1). Value 0 indicates
     *  that the number of lines shall be defined by the DNL marker and
     *  parameters at the end of the first scan (see B.2.5).
     */
    prototype.height = 0;
    /**
     *  Number of samples per line. Specifies the maximum number of samples per
     *  line in the source image. This shall be equal to the number of samples
     *  per line in the component with the maximum number of horizontal samples
     *  (see A.1.1).
     */
    prototype.width = 0;
    /**
     *  Number of image components in frame Specifies the number of source image
     *  components in the frame. The value of Nf shall be equal to the number of
     *  sets of frame component specification parameters (Ci, Hi, Vi, and Tq)
     *  present in the frame header.
     */
    prototype.nComp = 0;
    constructor.Component = function() {};
    constructor.Component = stjs.extend(constructor.Component, null, [], function(constructor, prototype) {
        /**
         *  Component identifier. Assigns a unique label to the ith component in
         *  the sequence of frame component specification parameters. These
         *  values shall be used in the scan headers to identify the components
         *  in the scan. The value of Ci shall be different from the values of C1
         *  through Ci 1.
         */
        prototype.index = 0;
        /**
         *  Horizontal sampling factor. Specifies the relationship between the
         *  component horizontal dimension and maximum image dimension X (see
         *  A.1.1); also specifies the number of horizontal data units of
         *  component Ci in each MCU, when more than one component is encoded in
         *  a scan.
         */
        prototype.subH = 0;
        /**
         *  Vertical sampling factor. Specifies the relationship between the
         *  component vertical dimension and maximum image dimension Y (see
         *  A.1.1); also specifies the number of vertical data units of component
         *  Ci in each MCU, when more than one component is encoded in a scan.
         */
        prototype.subV = 0;
        /**
         *  Quantization table destination selector. Specifies one of four
         *  possible quantization table destinations from which the quantization
         *  table to use for dequantization of DCT coefficients of component Ci
         *  is retrieved. If the decoding process uses the dequantization
         *  procedure, this table shall have been installed in this destination
         *  by the time the decoder is ready to decode the scan(s) containing
         *  component Ci. The destination shall not be re- specified, or its
         *  contents changed, until all scans containing Ci have been completed.
         */
        prototype.quantTable = 0;
    }, {}, {});
    prototype.getHmax = function() {
        var max = 0;
        for (var i = 0; i < this.components.length; i++) {
            var c = this.components[i];
            max = Math.max(max, c.subH);
        }
        return max;
    };
    prototype.getVmax = function() {
        var max = 0;
        for (var i = 0; i < this.components.length; i++) {
            var c = this.components[i];
            max = Math.max(max, c.subV);
        }
        return max;
    };
    prototype.components = null;
    constructor.read = function(is) {
        var frame = new FrameHeader();
        frame.headerLength = is.getShort() & 65535;
        frame.bitsPerSample = is.get() & 255;
        frame.height = is.getShort() & 65535;
        frame.width = is.getShort() & 65535;
        frame.nComp = is.get() & 255;
        frame.components = Array(frame.nComp);
        for (var i = 0; i < frame.components.length; i++) {
            var c = frame.components[i] = new FrameHeader.Component();
            c.index = is.get() & 255;
            var hv = is.get() & 255;
            c.subH = (hv & 240) >>> 4;
            c.subV = (hv & 15);
            c.quantTable = is.get() & 255;
        }
        return frame;
    };
}, {components: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var IDCT4x4 = function() {};
IDCT4x4 = stjs.extend(IDCT4x4, null, [], function(constructor, prototype) {
    constructor.idct = function(blk, off) {
        var i;
        for (i = 0; i < 4; i++) {
            IDCT4x4.idct4row(blk, off + (i << 2));
        }
        for (i = 0; i < 4; i++) {
            IDCT4x4.idct4col_add(blk, off + i);
        }
    };
    constructor.CN_SHIFT = 12;
    constructor.C_FIX = function(x) {
        return (stjs.trunc(((x) * 1.414213562 * (1 << IDCT4x4.CN_SHIFT) + 0.5)));
    };
    constructor.C1 = IDCT4x4.C_FIX(0.6532814824);
    constructor.C2 = IDCT4x4.C_FIX(0.2705980501);
    constructor.C3 = IDCT4x4.C_FIX(0.5);
    constructor.C_SHIFT = (4 + 2 + 12);
    constructor.idct4col_add = function(blk, off) {
        var c0, c1, c2, c3, a0, a1, a2, a3;
        a0 = blk[off];
        a1 = blk[off + 4];
        a2 = blk[off + 8];
        a3 = blk[off + 12];
        c0 = (a0 + a2) * IDCT4x4.C3 + (1 << (IDCT4x4.C_SHIFT - 1));
        c2 = (a0 - a2) * IDCT4x4.C3 + (1 << (IDCT4x4.C_SHIFT - 1));
        c1 = a1 * IDCT4x4.C1 + a3 * IDCT4x4.C2;
        c3 = a1 * IDCT4x4.C2 - a3 * IDCT4x4.C1;
        blk[off] = ((c0 + c1) >> IDCT4x4.C_SHIFT);
        blk[off + 4] = ((c2 + c3) >> IDCT4x4.C_SHIFT);
        blk[off + 8] = ((c2 - c3) >> IDCT4x4.C_SHIFT);
        blk[off + 12] = ((c0 - c1) >> IDCT4x4.C_SHIFT);
    };
    constructor.RN_SHIFT = 15;
    constructor.R_FIX = function(x) {
        return (stjs.trunc(((x) * 1.414213562 * (1 << IDCT4x4.RN_SHIFT) + 0.5)));
    };
    constructor.R1 = IDCT4x4.R_FIX(0.6532814824);
    constructor.R2 = IDCT4x4.R_FIX(0.2705980501);
    constructor.R3 = IDCT4x4.R_FIX(0.5);
    constructor.R_SHIFT = 11;
    constructor.idct4row = function(blk, off) {
        var c0, c1, c2, c3, a0, a1, a2, a3;
        a0 = blk[off];
        a1 = blk[off + 1];
        a2 = blk[off + 2];
        a3 = blk[off + 3];
        c0 = (a0 + a2) * IDCT4x4.R3 + (1 << (IDCT4x4.R_SHIFT - 1));
        c2 = (a0 - a2) * IDCT4x4.R3 + (1 << (IDCT4x4.R_SHIFT - 1));
        c1 = a1 * IDCT4x4.R1 + a3 * IDCT4x4.R2;
        c3 = a1 * IDCT4x4.R2 - a3 * IDCT4x4.R1;
        blk[off] = (c0 + c1) >> IDCT4x4.R_SHIFT;
        blk[off + 1] = (c2 + c3) >> IDCT4x4.R_SHIFT;
        blk[off + 2] = (c2 - c3) >> IDCT4x4.R_SHIFT;
        blk[off + 3] = (c0 - c1) >> IDCT4x4.R_SHIFT;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var ChannelLabel = stjs.enumeration("MONO", "STEREO_LEFT", "STEREO_RIGHT", "LEFT_TOTAL", "RIGHT_TOTAL", "FRONT_LEFT", "FRONT_RIGHT", "CENTER", "LFE", "REAR_LEFT", "REAR_RIGHT", "FRONT_CENTER_LEFT", "FRONT_CENTER_RIGHT", "REAR_CENTER", "SIDE_LEFT", "SIDE_RIGHT");
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var ObjectType = stjs.enumeration("AOT_NULL", "AOT_AAC_MAIN", "AOT_AAC_LC", "AOT_AAC_SSR", "AOT_AAC_LTP", "AOT_SBR", "AOT_AAC_SCALABLE", "AOT_TWINVQ", "AOT_CELP", "AOT_HVXC", "CRAP1", "CRAP2", "AOT_TTSI", "AOT_MAINSYNTH", "AOT_WAVESYNTH", "AOT_MIDI", "AOT_SAFX", "AOT_ER_AAC_LC", "CRAP3", "AOT_ER_AAC_LTP", "AOT_ER_AAC_SCALABLE", "AOT_ER_TWINVQ", "AOT_ER_BSAC", "AOT_ER_AAC_LD", "AOT_ER_CELP", "AOT_ER_HVXC", "AOT_ER_HILN", "AOT_ER_PARAM", "AOT_SSC", "AOT_PS", "AOT_SURROUND", "AOT_ESCAPE", "AOT_L1", "AOT_L2", "AOT_L3", "AOT_DST", "AOT_ALS", "AOT_SLS", "AOT_SLS_NON_CORE", "AOT_ER_AAC_ELD", "AOT_SMR_SIMPLE", "AOT_SMR_MAIN", "AOT_USAC_NOSBR", "AOT_SAOC", "AOT_LD_SURROUND", "AOT_USAC");
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var ReaderLE = function() {};
ReaderLE = stjs.extend(ReaderLE, null, [], function(constructor, prototype) {
    constructor.readShort = function(input) {
        var b2 = input.read();
        var b1 = input.read();
        if (b1 == -1 || b2 == -1) 
            return -1;
        return ((((b1 << 8) + b2)) << 16 >> 16);
    };
    constructor.readInt = function(input) {
        var b4 = input.read();
        var b3 = input.read();
        var b2 = input.read();
        var b1 = input.read();
        if (b1 == -1 || b2 == -1 || b3 == -1 || b4 == -1) 
            return -1;
        return ((((b1 << 24) + (b2 << 16) + (b3 << 8) + b4)) | 0);
    };
    constructor.readLong = function(input) {
        var b8 = input.read();
        var b7 = input.read();
        var b6 = input.read();
        var b5 = input.read();
        var b4 = input.read();
        var b3 = input.read();
        var b2 = input.read();
        var b1 = input.read();
        if (b1 == -1 || b2 == -1 || b3 == -1 || b4 == -1 || b5 == -1 || b6 == -1 || b7 == -1 || b8 == -1) 
            return -1;
        return ((((b1 << 56) + (b2 << 48) + (b3 << 40) + (b4 << 32) + (b5 << 24) + (b6 << 16) + (b7 << 8) + b8)) | 0);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var PredictionWeightTable = function() {
    this.luma_weight = Array(2);
    this.chroma_weight = Array(2);
    this.luma_offset = Array(2);
    this.chroma_offset = Array(2);
};
PredictionWeightTable = stjs.extend(PredictionWeightTable, null, [], function(constructor, prototype) {
    prototype.luma_log2_weight_denom = 0;
    prototype.chroma_log2_weight_denom = 0;
    prototype.luma_weight = null;
    prototype.chroma_weight = null;
    prototype.luma_offset = null;
    prototype.chroma_offset = null;
}, {luma_weight: "Array", chroma_weight: "Array", luma_offset: "Array", chroma_offset: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  @author The JCodec project
 */
var Point = function(x, y) {
    this.x = x;
    this.y = y;
};
Point = stjs.extend(Point, null, [], function(constructor, prototype) {
    prototype.x = 0;
    prototype.y = 0;
    prototype.getX = function() {
        return this.x;
    };
    prototype.getY = function() {
        return this.y;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  FLV packet
 *  
 *  @author Stan Vitvitskyy
 *  
 */
var FLVTag = function(type, position, tagHeader, pts, data, keyFrame, frameNo, streamId, prevPacketSize) {
    this.type = type;
    this.position = position;
    this.tagHeader = tagHeader;
    this.pts = pts;
    this.data = data;
    this.keyFrame = keyFrame;
    this.frameNo = frameNo;
    this.streamId = streamId;
    this.prevPacketSize = prevPacketSize;
};
FLVTag = stjs.extend(FLVTag, null, [], function(constructor, prototype) {
    prototype.type = null;
    prototype.position = 0;
    prototype.tagHeader = null;
    prototype.pts = 0;
    prototype.data = null;
    prototype.keyFrame = false;
    prototype.frameNo = 0;
    prototype.streamId = 0;
    prototype.prevPacketSize = 0;
    constructor.Type = stjs.enumeration("VIDEO", "AUDIO", "SCRIPT");
    prototype.getType = function() {
        return this.type;
    };
    prototype.getPosition = function() {
        return this.position;
    };
    prototype.getTagHeader = function() {
        return this.tagHeader;
    };
    prototype.getPts = function() {
        return this.pts;
    };
    prototype.setPts = function(pts) {
        this.pts = pts;
    };
    prototype.getStreamId = function() {
        return this.streamId;
    };
    prototype.setStreamId = function(streamId) {
        this.streamId = streamId;
    };
    prototype.getPrevPacketSize = function() {
        return this.prevPacketSize;
    };
    prototype.setPrevPacketSize = function(prevPacketSize) {
        this.prevPacketSize = prevPacketSize;
    };
    prototype.getData = function() {
        return this.data;
    };
    prototype.getPtsD = function() {
        return (this.pts) / 1000;
    };
    prototype.isKeyFrame = function() {
        return this.keyFrame;
    };
    prototype.getFrameNo = function() {
        return this.frameNo;
    };
    constructor.TagHeader = function(codec) {
        this.codec = codec;
    };
    constructor.TagHeader = stjs.extend(constructor.TagHeader, null, [], function(constructor, prototype) {
        prototype.codec = null;
        prototype.getCodec = function() {
            return this.codec;
        };
    }, {codec: {name: "Enum", arguments: ["Codec"]}}, {});
    constructor.VideoTagHeader = function(codec, frameType) {
        FLVTag.TagHeader.call(this, codec);
        this.frameType = frameType;
    };
    constructor.VideoTagHeader = stjs.extend(constructor.VideoTagHeader, FLVTag.TagHeader, [], function(constructor, prototype) {
        prototype.frameType = 0;
        prototype.getFrameType = function() {
            return this.frameType;
        };
    }, {codec: {name: "Enum", arguments: ["Codec"]}}, {});
    constructor.AvcVideoTagHeader = function(codec, frameType, avcPacketType, compOffset) {
        FLVTag.VideoTagHeader.call(this, codec, frameType);
        this.avcPacketType = avcPacketType;
        this.compOffset = compOffset;
    };
    constructor.AvcVideoTagHeader = stjs.extend(constructor.AvcVideoTagHeader, FLVTag.VideoTagHeader, [], function(constructor, prototype) {
        prototype.compOffset = 0;
        prototype.avcPacketType = 0;
        prototype.getCompOffset = function() {
            return this.compOffset;
        };
        prototype.getAvcPacketType = function() {
            return this.avcPacketType;
        };
    }, {codec: {name: "Enum", arguments: ["Codec"]}}, {});
    constructor.AudioTagHeader = function(codec, audioFormat) {
        FLVTag.TagHeader.call(this, codec);
        this.audioFormat = audioFormat;
    };
    constructor.AudioTagHeader = stjs.extend(constructor.AudioTagHeader, FLVTag.TagHeader, [], function(constructor, prototype) {
        prototype.audioFormat = null;
        prototype.getAudioFormat = function() {
            return this.audioFormat;
        };
    }, {audioFormat: "AudioFormat", codec: {name: "Enum", arguments: ["Codec"]}}, {});
    constructor.AacAudioTagHeader = function(codec, audioFormat, packetType) {
        FLVTag.AudioTagHeader.call(this, codec, audioFormat);
        this.packetType = packetType;
    };
    constructor.AacAudioTagHeader = stjs.extend(constructor.AacAudioTagHeader, FLVTag.AudioTagHeader, [], function(constructor, prototype) {
        prototype.packetType = 0;
        prototype.getPacketType = function() {
            return this.packetType;
        };
    }, {audioFormat: "AudioFormat", codec: {name: "Enum", arguments: ["Codec"]}}, {});
}, {type: {name: "Enum", arguments: ["FLVTag.Type"]}, tagHeader: "FLVTag.TagHeader", data: "ByteBuffer"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 * 
 *  @author in-somnia
 */
var Windows = function() {};
Windows = stjs.extend(Windows, null, [], function(constructor, prototype) {
    constructor.SINE_256 = new Float32Array([0.0030679568, 0.009203754, 0.015339206, 0.02147408, 0.027608145, 0.033741172, 0.039872926, 0.04600318, 0.052131705, 0.058258265, 0.06438263, 0.070504576, 0.076623864, 0.08274026, 0.08885355, 0.0949635, 0.10106986, 0.10717242, 0.11327095, 0.119365215, 0.12545498, 0.13154003, 0.13762012, 0.14369503, 0.14976454, 0.1558284, 0.1618864, 0.16793829, 0.17398387, 0.1800229, 0.18605515, 0.1920804, 0.1980984, 0.20410897, 0.21011184, 0.2161068, 0.22209363, 0.22807208, 0.23404196, 0.24000302, 0.24595505, 0.2518978, 0.2578311, 0.26375467, 0.2696683, 0.27557182, 0.28146493, 0.28734747, 0.29321915, 0.29907984, 0.30492923, 0.31076714, 0.31659338, 0.3224077, 0.32820985, 0.33399966, 0.33977687, 0.34554133, 0.35129276, 0.35703096, 0.36275572, 0.36846682, 0.37416407, 0.3798472, 0.38551605, 0.39117038, 0.39681, 0.40243465, 0.40804416, 0.41363832, 0.4192169, 0.42477968, 0.4303265, 0.4358571, 0.44137126, 0.44686884, 0.45234957, 0.4578133, 0.4632598, 0.46868882, 0.4741002, 0.47949377, 0.48486924, 0.49022648, 0.49556527, 0.50088537, 0.50618666, 0.5114688, 0.5167318, 0.5219753, 0.52719915, 0.5324031, 0.53758705, 0.5427508, 0.54789406, 0.5530167, 0.5581185, 0.56319934, 0.56825894, 0.57329714, 0.57831377, 0.58330864, 0.5882816, 0.5932323, 0.5981607, 0.6030666, 0.6079498, 0.6128101, 0.6176473, 0.62246126, 0.6272518, 0.63201874, 0.63676184, 0.64148104, 0.64617604, 0.65084666, 0.65549284, 0.66011435, 0.664711, 0.6692826, 0.673829, 0.67835003, 0.68284553, 0.68731534, 0.6917592, 0.6961771, 0.7005688, 0.70493406, 0.7092728, 0.71358484, 0.71787006, 0.7221282, 0.7263591, 0.73056275, 0.7347389, 0.7388873, 0.74300796, 0.7471006, 0.75116515, 0.7552014, 0.7592092, 0.7631884, 0.7671389, 0.7710605, 0.7749531, 0.7788165, 0.7826506, 0.7864552, 0.7902302, 0.7939755, 0.79769087, 0.80137616, 0.80503136, 0.80865616, 0.8122506, 0.81581444, 0.8193475, 0.8228498, 0.82632107, 0.8297612, 0.8331702, 0.83654773, 0.8398938, 0.84320825, 0.8464909, 0.84974176, 0.8529606, 0.85614735, 0.8593018, 0.86242396, 0.8655136, 0.8685707, 0.8715951, 0.87458664, 0.8775453, 0.8804709, 0.88336337, 0.88622254, 0.88904834, 0.8918407, 0.8945995, 0.89732456, 0.9000159, 0.9026733, 0.90529674, 0.9078861, 0.9104413, 0.9129622, 0.9154487, 0.9179008, 0.9203183, 0.9227011, 0.92504925, 0.9273625, 0.9296409, 0.9318843, 0.9340925, 0.93626565, 0.93840355, 0.94050604, 0.9425732, 0.9446048, 0.9466009, 0.9485614, 0.95048606, 0.952375, 0.9542281, 0.95604527, 0.95782644, 0.95957154, 0.96128047, 0.96295327, 0.9645898, 0.96619, 0.9677538, 0.96928126, 0.97077215, 0.9722265, 0.97364426, 0.97502536, 0.97636974, 0.97767735, 0.9789482, 0.9801821, 0.9813792, 0.9825393, 0.9836624, 0.9847485, 0.9857975, 0.9868094, 0.98778415, 0.98872167, 0.989622, 0.9904851, 0.99131083, 0.9920993, 0.9928504, 0.9935641, 0.99424046, 0.9948793, 0.9954808, 0.9960447, 0.9965711, 0.99706006, 0.99751145, 0.9979253, 0.99830157, 0.99864024, 0.9989413, 0.99920475, 0.9994306, 0.9996188, 0.9997694, 0.99988234, 0.9999576, 0.9999953]);
    constructor.SINE_32 = new Float32Array([0.024541229, 0.07356457, 0.12241068, 0.17096189, 0.21910124, 0.26671275, 0.31368175, 0.35989505, 0.4052413, 0.44961134, 0.4928982, 0.53499764, 0.57580817, 0.6152316, 0.65317285, 0.68954057, 0.7242471, 0.7572088, 0.7883464, 0.8175848, 0.8448536, 0.87008697, 0.8932243, 0.9142098, 0.9329928, 0.94952816, 0.96377605, 0.9757021, 0.98527765, 0.99247956, 0.99729043, 0.9996988]);
    constructor.KBD_256 = new Float32Array([5.85123E-4, 9.6421497E-4, 0.0013558208, 0.001777185, 0.0022352533, 0.00273423, 0.0032773002, 0.0038671999, 0.0045064446, 0.0051974338, 0.005942505, 0.00674396, 0.007604081, 0.008525138, 0.009509392, 0.010559099, 0.011676508, 0.012863862, 0.014123397, 0.015457335, 0.01686789, 0.018357255, 0.019927613, 0.02158112, 0.023319913, 0.0251461, 0.027061762, 0.029068947, 0.031169666, 0.03336589, 0.035659555, 0.038052544, 0.040546697, 0.043143805, 0.045845594, 0.048653748, 0.05156988, 0.054595537, 0.057732213, 0.060981322, 0.06434421, 0.06782214, 0.07141632, 0.07512784, 0.07895775, 0.082906984, 0.086976394, 0.09116676, 0.095478736, 0.09991292, 0.10446978, 0.10914971, 0.11395299, 0.118879795, 0.123930216, 0.12910421, 0.13440166, 0.13982232, 0.14536583, 0.15103175, 0.1568195, 0.16272838, 0.16875762, 0.17490631, 0.18117344, 0.18755788, 0.19405837, 0.20067358, 0.20740204, 0.21424216, 0.22119227, 0.22825058, 0.23541516, 0.242684, 0.25005502, 0.25752598, 0.26509452, 0.27275825, 0.28051463, 0.28836104, 0.29629478, 0.304313, 0.31241283, 0.32059127, 0.32884523, 0.33717158, 0.34556705, 0.35402837, 0.3625521, 0.37113485, 0.37977302, 0.38846308, 0.3972014, 0.40598422, 0.41480786, 0.42366847, 0.43256226, 0.4414853, 0.4504337, 0.4594035, 0.46839076, 0.47739145, 0.4864016, 0.49541712, 0.50443405, 0.5134483, 0.5224558, 0.5314526, 0.54043466, 0.5493979, 0.5583384, 0.56725216, 0.5761352, 0.58498365, 0.59379363, 0.6025613, 0.6112828, 0.6199545, 0.62857264, 0.6371336, 0.6456338, 0.6540698, 0.66243804, 0.67073524, 0.67895806, 0.68710333, 0.69516784, 0.7031487, 0.7110428, 0.71884745, 0.72655976, 0.73417705, 0.7416969, 0.7491167, 0.7564342, 0.76364714, 0.7707534, 0.77775085, 0.78463775, 0.79141223, 0.79807264, 0.8046174, 0.8110451, 0.81735444, 0.8235442, 0.8296133, 0.83556086, 0.841386, 0.84708804, 0.8526664, 0.85812056, 0.8634502, 0.8686552, 0.87373537, 0.8786907, 0.88352144, 0.8882277, 0.89280987, 0.8972685, 0.90160406, 0.90581733, 0.909909, 0.91388005, 0.91773146, 0.92146426, 0.9250797, 0.928579, 0.9319635, 0.93523467, 0.93839407, 0.9414432, 0.9443838, 0.94721764, 0.9499464, 0.9525721, 0.95509654, 0.95752174, 0.9598498, 0.9620826, 0.96422243, 0.9662714, 0.9682316, 0.9701054, 0.9718949, 0.9736024, 0.9752302, 0.9767806, 0.9782558, 0.9796582, 0.98099, 0.98225355, 0.9834512, 0.9845851, 0.9856576, 0.9866709, 0.98762727, 0.9885289, 0.989378, 0.9901766, 0.9909269, 0.99163103, 0.9922909, 0.99290866, 0.99348617, 0.99402535, 0.99452806, 0.9949962, 0.9954315, 0.99583566, 0.9962104, 0.9965573, 0.99687797, 0.9971739, 0.9974466, 0.9976974, 0.9979278, 0.9981389, 0.9983321, 0.9985086, 0.9986694, 0.9988157, 0.9989485, 0.99906886, 0.99917763, 0.99927574, 0.999364, 0.99944323, 0.9995141, 0.9995774, 0.9996338, 0.9996838, 0.9997281, 0.9997671, 0.9998014, 0.9998315, 0.9998577, 0.99988055, 0.9999003, 0.99991727, 0.9999318, 0.99994427, 0.99995476, 0.99996364, 0.9999711, 0.99997723, 0.99998236, 0.99998647, 0.99998987, 0.99999255, 0.99999464, 0.99999624, 0.9999975, 0.99999845, 0.9999991, 0.9999995, 0.9999998]);
    constructor.KBD_32 = new Float32Array([8.7591405E-5, 9.32176E-4, 0.0032114612, 0.008100989, 0.017124029, 0.032072075, 0.054830786, 0.08713618, 0.13029234, 0.18489555, 0.2506163, 0.32608742, 0.40893167, 0.4959415, 0.583394, 0.6674602, 0.7446455, 0.8121893, 0.86835593, 0.912565, 0.9453396, 0.9680865, 0.98275816, 0.99147564, 0.9961964, 0.99849564, 0.99948555, 0.9998534, 0.99996716, 0.9999948, 0.9999996, 1.0]);
}, {SINE_256: "Float32Array", SINE_32: "Float32Array", KBD_256: "Float32Array", KBD_32: "Float32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var DCTRef = function() {};
DCTRef = stjs.extend(DCTRef, null, [], function(constructor, prototype) {
    constructor.coefficients = new Float64Array(64);
    constructor.fdct = function(block, off) {
        var i, j, k;
        var out = new Float64Array(8 * 8);
        for (i = 0; i < 64; i += 8) {
            for (j = 0; j < 8; ++j) {
                var tmp = 0;
                for (k = 0; k < 8; ++k) {
                    tmp += DCTRef.coefficients[i + k] * block[k * 8 + j + off];
                }
                out[i + j] = tmp * 4;
            }
        }
        for (j = 0; j < 8; ++j) {
            for (i = 0; i < 64; i += 8) {
                var tmp = 0;
                for (k = 0; k < 8; ++k) {
                    tmp += out[i + k] * DCTRef.coefficients[j * 8 + k];
                }
                block[i + j + off] = stjs.trunc((tmp + 0.499999999999));
            }
        }
    };
    constructor.idct = function(block, off) {
        var i, j, k;
        var out = new Float64Array(8 * 8);
        for (i = 0; i < 64; i += 8) {
            for (j = 0; j < 8; ++j) {
                var tmp = 0;
                for (k = 0; k < 8; ++k) {
                    tmp += block[i + k] * DCTRef.coefficients[k * 8 + j];
                }
                out[i + j] = tmp;
            }
        }
        for (i = 0; i < 8; ++i) {
            for (j = 0; j < 8; ++j) {
                var tmp = 0;
                for (k = 0; k < 64; k += 8) {
                    tmp += DCTRef.coefficients[k + i] * out[k + j];
                }
                block[i * 8 + j] = stjs.trunc((tmp + 0.5));
            }
        }
    };
}, {coefficients: "Float64Array"}, {});
(function() {
    for (var j = 0; j < 8; ++j) {
        DCTRef.coefficients[j] = Math.sqrt(0.125);
        for (var i = 8; i < 64; i += 8) {
            DCTRef.coefficients[i + j] = 0.5 * Math.cos(i * (j + 0.5) * Math.PI / 64.0);
        }
    }
})();
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 * 
 *  @author in-somnia
 */
var PSHuffmanTables = function() {};
PSHuffmanTables = stjs.extend(PSHuffmanTables, null, [], function(constructor, prototype) {
    constructor.f_huff_iid_def = [new Int32Array([-31, 1]), new Int32Array([2, 3]), new Int32Array([-30, -32]), new Int32Array([4, 5]), new Int32Array([-29, -33]), new Int32Array([6, 7]), new Int32Array([-28, -34]), new Int32Array([8, 9]), new Int32Array([-35, -27]), new Int32Array([-26, 10]), new Int32Array([-36, 11]), new Int32Array([-25, 12]), new Int32Array([-37, 13]), new Int32Array([-38, 14]), new Int32Array([-24, 15]), new Int32Array([16, 17]), new Int32Array([-23, -39]), new Int32Array([18, 19]), new Int32Array([-22, -21]), new Int32Array([20, 21]), new Int32Array([-40, -20]), new Int32Array([22, 23]), new Int32Array([-41, 24]), new Int32Array([25, 26]), new Int32Array([-42, -45]), new Int32Array([-44, -43]), new Int32Array([-19, 27]), new Int32Array([-18, -17])];
    constructor.t_huff_iid_def = [new Int32Array([-31, 1]), new Int32Array([-32, 2]), new Int32Array([-30, 3]), new Int32Array([-33, 4]), new Int32Array([-29, 5]), new Int32Array([-34, 6]), new Int32Array([-28, 7]), new Int32Array([-35, 8]), new Int32Array([-27, 9]), new Int32Array([-36, 10]), new Int32Array([-26, 11]), new Int32Array([-37, 12]), new Int32Array([-25, 13]), new Int32Array([-24, 14]), new Int32Array([-38, 15]), new Int32Array([16, 17]), new Int32Array([-23, -39]), new Int32Array([18, 19]), new Int32Array([20, 21]), new Int32Array([22, 23]), new Int32Array([-22, -45]), new Int32Array([-44, -43]), new Int32Array([24, 25]), new Int32Array([26, 27]), new Int32Array([-42, -41]), new Int32Array([-40, -21]), new Int32Array([-20, -19]), new Int32Array([-18, -17])];
    constructor.f_huff_iid_fine = [new Int32Array([1, -31]), new Int32Array([2, 3]), new Int32Array([4, -32]), new Int32Array([-30, 5]), new Int32Array([-33, -29]), new Int32Array([6, 7]), new Int32Array([-34, -28]), new Int32Array([8, 9]), new Int32Array([-35, -27]), new Int32Array([10, 11]), new Int32Array([-36, -26]), new Int32Array([12, 13]), new Int32Array([-37, -25]), new Int32Array([14, 15]), new Int32Array([-24, 16]), new Int32Array([17, 18]), new Int32Array([19, -39]), new Int32Array([-23, 20]), new Int32Array([21, -38]), new Int32Array([-21, 22]), new Int32Array([23, -40]), new Int32Array([-22, 24]), new Int32Array([-42, -20]), new Int32Array([25, 26]), new Int32Array([27, -41]), new Int32Array([28, -43]), new Int32Array([-19, 29]), new Int32Array([30, 31]), new Int32Array([32, -45]), new Int32Array([-17, 33]), new Int32Array([34, -44]), new Int32Array([-18, 35]), new Int32Array([36, 37]), new Int32Array([38, -46]), new Int32Array([-16, 39]), new Int32Array([40, 41]), new Int32Array([42, 43]), new Int32Array([-48, -14]), new Int32Array([44, 45]), new Int32Array([46, 47]), new Int32Array([48, 49]), new Int32Array([-47, -15]), new Int32Array([-52, -10]), new Int32Array([-50, -12]), new Int32Array([-49, -13]), new Int32Array([50, 51]), new Int32Array([52, 53]), new Int32Array([54, 55]), new Int32Array([56, 57]), new Int32Array([58, 59]), new Int32Array([-57, -56]), new Int32Array([-59, -58]), new Int32Array([-53, -9]), new Int32Array([-55, -54]), new Int32Array([-6, -5]), new Int32Array([-8, -7]), new Int32Array([-2, -1]), new Int32Array([-4, -3]), new Int32Array([-61, -60]), new Int32Array([-51, -11])];
    constructor.t_huff_iid_fine = [new Int32Array([1, -31]), new Int32Array([-30, 2]), new Int32Array([3, -32]), new Int32Array([4, 5]), new Int32Array([6, 7]), new Int32Array([-33, -29]), new Int32Array([8, -34]), new Int32Array([-28, 9]), new Int32Array([-35, -27]), new Int32Array([10, 11]), new Int32Array([-26, 12]), new Int32Array([13, 14]), new Int32Array([-37, -25]), new Int32Array([15, 16]), new Int32Array([17, -36]), new Int32Array([18, -38]), new Int32Array([-24, 19]), new Int32Array([20, 21]), new Int32Array([-22, 22]), new Int32Array([23, 24]), new Int32Array([-39, -23]), new Int32Array([25, 26]), new Int32Array([-20, 27]), new Int32Array([28, 29]), new Int32Array([-41, -21]), new Int32Array([30, 31]), new Int32Array([32, -40]), new Int32Array([33, -44]), new Int32Array([-18, 34]), new Int32Array([35, 36]), new Int32Array([37, -43]), new Int32Array([-19, 38]), new Int32Array([39, -42]), new Int32Array([40, 41]), new Int32Array([42, 43]), new Int32Array([44, 45]), new Int32Array([46, -46]), new Int32Array([-16, 47]), new Int32Array([-45, -17]), new Int32Array([48, 49]), new Int32Array([-52, -51]), new Int32Array([-13, -12]), new Int32Array([-50, -49]), new Int32Array([50, 51]), new Int32Array([52, 53]), new Int32Array([54, 55]), new Int32Array([56, -48]), new Int32Array([-14, 57]), new Int32Array([58, -47]), new Int32Array([-15, 59]), new Int32Array([-57, -5]), new Int32Array([-59, -58]), new Int32Array([-2, -1]), new Int32Array([-4, -3]), new Int32Array([-61, -60]), new Int32Array([-56, -6]), new Int32Array([-55, -7]), new Int32Array([-54, -8]), new Int32Array([-53, -9]), new Int32Array([-11, -10])];
    constructor.f_huff_icc = [new Int32Array([-31, 1]), new Int32Array([-30, 2]), new Int32Array([-32, 3]), new Int32Array([-29, 4]), new Int32Array([-33, 5]), new Int32Array([-28, 6]), new Int32Array([-34, 7]), new Int32Array([-27, 8]), new Int32Array([-26, 9]), new Int32Array([-35, 10]), new Int32Array([-25, 11]), new Int32Array([-36, 12]), new Int32Array([-24, 13]), new Int32Array([-37, -38])];
    constructor.t_huff_icc = [new Int32Array([-31, 1]), new Int32Array([-30, 2]), new Int32Array([-32, 3]), new Int32Array([-29, 4]), new Int32Array([-33, 5]), new Int32Array([-28, 6]), new Int32Array([-34, 7]), new Int32Array([-27, 8]), new Int32Array([-35, 9]), new Int32Array([-26, 10]), new Int32Array([-36, 11]), new Int32Array([-25, 12]), new Int32Array([-37, 13]), new Int32Array([-38, -24])];
    constructor.f_huff_ipd = [new Int32Array([1, -31]), new Int32Array([2, 3]), new Int32Array([-30, 4]), new Int32Array([5, 6]), new Int32Array([-27, -26]), new Int32Array([-28, -25]), new Int32Array([-29, -24])];
    constructor.t_huff_ipd = [new Int32Array([1, -31]), new Int32Array([2, 3]), new Int32Array([4, 5]), new Int32Array([-30, -24]), new Int32Array([-26, 6]), new Int32Array([-29, -25]), new Int32Array([-27, -28])];
    constructor.f_huff_opd = [new Int32Array([1, -31]), new Int32Array([2, 3]), new Int32Array([-24, -30]), new Int32Array([4, 5]), new Int32Array([-28, -25]), new Int32Array([-29, 6]), new Int32Array([-26, -27])];
    constructor.t_huff_opd = [new Int32Array([1, -31]), new Int32Array([2, 3]), new Int32Array([4, 5]), new Int32Array([-30, -24]), new Int32Array([-26, -29]), new Int32Array([-25, 6]), new Int32Array([-27, -28])];
}, {f_huff_iid_def: "Array", t_huff_iid_def: "Array", f_huff_iid_fine: "Array", t_huff_iid_fine: "Array", f_huff_icc: "Array", t_huff_icc: "Array", f_huff_ipd: "Array", t_huff_ipd: "Array", f_huff_opd: "Array", t_huff_opd: "Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  Tables of coefficients used for TNS.
 *  The suffix indicates the values of coefCompress and coefRes.
 *  @author in-somnia
 */
var TNSTables = function() {};
TNSTables = stjs.extend(TNSTables, null, [], function(constructor, prototype) {
    constructor.TNS_COEF_1_3 = new Float32Array([0.0, -0.43388373, 0.6427876, 0.34202015]);
    constructor.TNS_COEF_0_3 = new Float32Array([0.0, -0.43388373, -0.7818315, -0.9749279, 0.9848077, 0.8660254, 0.6427876, 0.34202015]);
    constructor.TNS_COEF_1_4 = new Float32Array([0.0, -0.2079117, -0.40673664, -0.58778524, 0.6736956, 0.52643216, 0.36124167, 0.18374951]);
    constructor.TNS_COEF_0_4 = new Float32Array([0.0, -0.2079117, -0.40673664, -0.58778524, -0.7431448, -0.8660254, -0.95105654, -0.9945219, 0.99573416, 0.9618256, 0.8951633, 0.7980172, 0.6736956, 0.52643216, 0.36124167, 0.18374951]);
    constructor.TNS_TABLES = [TNSTables.TNS_COEF_0_3, TNSTables.TNS_COEF_0_4, TNSTables.TNS_COEF_1_3, TNSTables.TNS_COEF_1_4];
}, {TNS_COEF_1_3: "Float32Array", TNS_COEF_0_3: "Float32Array", TNS_COEF_1_4: "Float32Array", TNS_COEF_0_4: "Float32Array", TNS_TABLES: "Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  @author in-somnia
 */
var BitsBuffer = function() {
    this.len = 0;
};
BitsBuffer = stjs.extend(BitsBuffer, null, [], function(constructor, prototype) {
    prototype.bufa = 0;
    prototype.bufb = 0;
    prototype.len = 0;
    constructor.S = new Int32Array([1, 2, 4, 8, 16]);
    constructor.B = new Int32Array([1431655765, 858993459, 252645135, 16711935, 65535]);
    prototype.getLength = function() {
        return this.len;
    };
    prototype.showBits = function(bits) {
        if (bits == 0) 
            return 0;
        if (this.len <= 32) {
            if (this.len >= bits) 
                return ((this.bufa >> (this.len - bits)) & (-1 >> (32 - bits)));
             else 
                return ((this.bufa << (bits - this.len)) & (-1 >> (32 - bits)));
        } else {
            if ((this.len - bits) < 32) 
                return ((this.bufb & (-1 >> (64 - this.len))) << (bits - this.len + 32)) | (this.bufa >> (this.len - bits));
             else 
                return ((this.bufb >> (this.len - bits - 32)) & (-1 >> (32 - bits)));
        }
    };
    prototype.flushBits = function(bits) {
        this.len -= bits;
        var b;
        if (this.len < 0) {
            this.len = 0;
            b = false;
        } else 
            b = true;
        return b;
    };
    prototype.getBits = function(n) {
        var i = this.showBits(n);
        if (!this.flushBits(n)) 
            i = -1;
        return i;
    };
    prototype.getBit = function() {
        var i = this.showBits(1);
        if (!this.flushBits(1)) 
            i = -1;
        return i;
    };
    prototype.rewindReverse = function() {
        if (this.len == 0) 
            return;
        var i = BitsBuffer.rewindReverse64(this.bufb, this.bufa, this.len);
        this.bufb = i[0];
        this.bufa = i[1];
    };
    prototype.concatBits = function(a) {
        if (a.len == 0) 
            return;
        var al = a.bufa;
        var ah = a.bufb;
        var bl, bh;
        if (this.len > 32) {
            bl = this.bufa;
            bh = this.bufb & ((1 << (this.len - 32)) - 1);
            ah = al << (this.len - 32);
            al = 0;
        } else {
            bl = this.bufa & ((1 << (this.len)) - 1);
            bh = 0;
            ah = (ah << (this.len)) | (al >> (32 - this.len));
            al = al << this.len;
        }
        this.bufa = bl | al;
        this.bufb = bh | ah;
        this.len += a.len;
    };
    prototype.readSegment = function(segwidth, _in) {
        this.len = segwidth;
        if (segwidth > 32) {
            this.bufb = _in.readBits(segwidth - 32);
            this.bufa = _in.readBits(32);
        } else {
            this.bufa = _in.readBits(segwidth);
            this.bufb = 0;
        }
    };
    constructor.rewindReverse32 = function(v, len) {
        v = ((v >> BitsBuffer.S[0]) & BitsBuffer.B[0]) | ((v << BitsBuffer.S[0]) & ~BitsBuffer.B[0]);
        v = ((v >> BitsBuffer.S[1]) & BitsBuffer.B[1]) | ((v << BitsBuffer.S[1]) & ~BitsBuffer.B[1]);
        v = ((v >> BitsBuffer.S[2]) & BitsBuffer.B[2]) | ((v << BitsBuffer.S[2]) & ~BitsBuffer.B[2]);
        v = ((v >> BitsBuffer.S[3]) & BitsBuffer.B[3]) | ((v << BitsBuffer.S[3]) & ~BitsBuffer.B[3]);
        v = ((v >> BitsBuffer.S[4]) & BitsBuffer.B[4]) | ((v << BitsBuffer.S[4]) & ~BitsBuffer.B[4]);
        v >>= (32 - len);
        return v;
    };
    constructor.rewindReverse64 = function(hi, lo, len) {
        var i = new Int32Array(2);
        if (len <= 32) {
            i[0] = 0;
            i[1] = BitsBuffer.rewindReverse32(lo, len);
        } else {
            lo = ((lo >> BitsBuffer.S[0]) & BitsBuffer.B[0]) | ((lo << BitsBuffer.S[0]) & ~BitsBuffer.B[0]);
            hi = ((hi >> BitsBuffer.S[0]) & BitsBuffer.B[0]) | ((hi << BitsBuffer.S[0]) & ~BitsBuffer.B[0]);
            lo = ((lo >> BitsBuffer.S[1]) & BitsBuffer.B[1]) | ((lo << BitsBuffer.S[1]) & ~BitsBuffer.B[1]);
            hi = ((hi >> BitsBuffer.S[1]) & BitsBuffer.B[1]) | ((hi << BitsBuffer.S[1]) & ~BitsBuffer.B[1]);
            lo = ((lo >> BitsBuffer.S[2]) & BitsBuffer.B[2]) | ((lo << BitsBuffer.S[2]) & ~BitsBuffer.B[2]);
            hi = ((hi >> BitsBuffer.S[2]) & BitsBuffer.B[2]) | ((hi << BitsBuffer.S[2]) & ~BitsBuffer.B[2]);
            lo = ((lo >> BitsBuffer.S[3]) & BitsBuffer.B[3]) | ((lo << BitsBuffer.S[3]) & ~BitsBuffer.B[3]);
            hi = ((hi >> BitsBuffer.S[3]) & BitsBuffer.B[3]) | ((hi << BitsBuffer.S[3]) & ~BitsBuffer.B[3]);
            lo = ((lo >> BitsBuffer.S[4]) & BitsBuffer.B[4]) | ((lo << BitsBuffer.S[4]) & ~BitsBuffer.B[4]);
            hi = ((hi >> BitsBuffer.S[4]) & BitsBuffer.B[4]) | ((hi << BitsBuffer.S[4]) & ~BitsBuffer.B[4]);
            i[1] = (hi >> (64 - len)) | (lo << (len - 32));
            i[1] = lo >> (64 - len);
        }
        return i;
    };
}, {S: "Int32Array", B: "Int32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A helper class that builds macroblock to slice group maps needed by ASO
 *  (Arbitrary Slice Order)
 *  
 *  @author The JCodec project
 *  
 */
var SliceGroupMapBuilder = function() {};
SliceGroupMapBuilder = stjs.extend(SliceGroupMapBuilder, null, [], function(constructor, prototype) {
    /**
     *  
     *  Interleaved slice group map. Each slice group fills a number of cells
     *  equal to the appropriate run length, then followed by the next slice
     *  group.
     *  
     *  Example:
     *  
     *  1, 1, 1, 1, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2, 1, 1, 1,
     *  
     */
    constructor.buildInterleavedMap = function(picWidthInMbs, picHeightInMbs, runLength) {
        var numSliceGroups = runLength.length;
        var picSizeInMbs = picWidthInMbs * picHeightInMbs;
        var groups = new Int32Array(picSizeInMbs);
        var i = 0;
        do {
            for (var iGroup = 0; iGroup < numSliceGroups && i < picSizeInMbs; i += runLength[iGroup++]) {
                for (var j = 0; j < runLength[iGroup] && i + j < picSizeInMbs; j++) {
                    groups[i + j] = iGroup;
                }
            }
        } while (i < picSizeInMbs);
        return groups;
    };
    /**
     *  A dispersed map. Every odd line starts from the (N / 2)th group
     *  
     *  Example:
     *  
     *  0, 1, 2, 3, 0, 1, 2, 3 2, 3, 0, 1, 2, 3, 0, 1 0, 1, 2, 3, 0, 1, 2, 3 2,
     *  3, 0, 1, 2, 3, 0, 1 0, 1, 2, 3, 0, 1, 2, 3 2, 3, 0, 1, 2, 3, 0, 1 0, 1,
     *  2, 3, 0, 1, 2, 3 2, 3, 0, 1, 2, 3, 0, 1 0, 1, 2, 3, 0, 1, 2, 3 2, 3, 0,
     *  1, 2, 3, 0, 1
     *  
     */
    constructor.buildDispersedMap = function(picWidthInMbs, picHeightInMbs, numSliceGroups) {
        var picSizeInMbs = picWidthInMbs * picHeightInMbs;
        var groups = new Int32Array(picSizeInMbs);
        for (var i = 0; i < picSizeInMbs; i++) {
            var group = ((i % picWidthInMbs) + (stjs.trunc(((stjs.trunc(i / picWidthInMbs)) * numSliceGroups) / 2))) % numSliceGroups;
            groups[i] = group;
        }
        return groups;
    };
    /**
     *  
     *  A foreground macroblock to slice group map. Macroblocks of the last slice
     *  group are the background, all the others represent rectangles covering
     *  areas with top-left corner specified by topLeftAddr[group] and bottom
     *  right corner specified by bottomRightAddr[group].
     *  
     *  @param picWidthInMbs
     *  @param picHeightInMbs
     *  @param numSliceGroups
     *             Total number of slice groups
     *  @param topLeftAddr
     *             Addresses of macroblocks that are top-left corners of
     *             respective slice groups
     *  @param bottomRightAddr
     *             Addresses macroblocks that are bottom-right corners of
     *             respective slice groups
     *  @return
     */
    constructor.buildForegroundMap = function(picWidthInMbs, picHeightInMbs, numSliceGroups, topLeftAddr, bottomRightAddr) {
        var picSizeInMbs = picWidthInMbs * picHeightInMbs;
        var groups = new Int32Array(picSizeInMbs);
        for (var i = 0; i < picSizeInMbs; i++) 
            groups[i] = numSliceGroups - 1;
        var tot = 0;
        for (var iGroup = numSliceGroups - 2; iGroup >= 0; iGroup--) {
            var yTopLeft = stjs.trunc(topLeftAddr[iGroup] / picWidthInMbs);
            var xTopLeft = topLeftAddr[iGroup] % picWidthInMbs;
            var yBottomRight = stjs.trunc(bottomRightAddr[iGroup] / picWidthInMbs);
            var xBottomRight = bottomRightAddr[iGroup] % picWidthInMbs;
            var sz = (yBottomRight - yTopLeft + 1) * (xBottomRight - xTopLeft + 1);
            tot += sz;
            var ind = 0;
            for (var y = yTopLeft; y <= yBottomRight; y++) 
                for (var x = xTopLeft; x <= xBottomRight; x++) {
                    var mbAddr = y * picWidthInMbs + x;
                    groups[mbAddr] = iGroup;
                }
        }
        return groups;
    };
    /**
     *  A boxout macroblock to slice group mapping. Only applicable when there's
     *  exactly 2 slice groups. Slice group 1 is a background, while slice group
     *  0 is a box in the middle of the frame.
     *  
     *  @param picWidthInMbs
     *  @param picHeightInMbs
     *  @param changeDirection
     *  @param numberOfMbsInBox
     *             number of macroblocks in slice group 0
     *  @return
     */
    constructor.buildBoxOutMap = function(picWidthInMbs, picHeightInMbs, changeDirection, numberOfMbsInBox) {
        var picSizeInMbs = picWidthInMbs * picHeightInMbs;
        var groups = new Int32Array(picSizeInMbs);
        var changeDirectionInt = changeDirection ? 1 : 0;
        for (var i = 0; i < picSizeInMbs; i++) 
            groups[i] = 1;
        var x = stjs.trunc((picWidthInMbs - changeDirectionInt) / 2);
        var y = stjs.trunc((picHeightInMbs - changeDirectionInt) / 2);
        var leftBound = x;
        var topBound = y;
        var rightBound = x;
        var bottomBound = y;
        var xDir = changeDirectionInt - 1;
        var yDir = changeDirectionInt;
        var mapUnitVacant = false;
        for (var k = 0; k < numberOfMbsInBox; k += (mapUnitVacant ? 1 : 0)) {
            var mbAddr = y * picWidthInMbs + x;
            mapUnitVacant = (groups[mbAddr] == 1);
            if (mapUnitVacant) {
                groups[mbAddr] = 0;
            }
            if (xDir == -1 && x == leftBound) {
                leftBound = SliceGroupMapBuilder.Max(leftBound - 1, 0);
                x = leftBound;
                xDir = 0;
                yDir = 2 * changeDirectionInt - 1;
            } else if (xDir == 1 && x == rightBound) {
                rightBound = SliceGroupMapBuilder.Min(rightBound + 1, picWidthInMbs - 1);
                x = rightBound;
                xDir = 0;
                yDir = 1 - 2 * changeDirectionInt;
            } else if (yDir == -1 && y == topBound) {
                topBound = SliceGroupMapBuilder.Max(topBound - 1, 0);
                y = topBound;
                xDir = 1 - 2 * changeDirectionInt;
                yDir = 0;
            } else if (yDir == 1 && y == bottomBound) {
                bottomBound = SliceGroupMapBuilder.Min(bottomBound + 1, picHeightInMbs - 1);
                y = bottomBound;
                xDir = 2 * changeDirectionInt - 1;
                yDir = 0;
            } else {
                x += xDir;
                y += yDir;
            }
        }
        return groups;
    };
    constructor.Min = function(i, j) {
        return i < j ? i : j;
    };
    constructor.Max = function(i, j) {
        return i > j ? i : j;
    };
    /**
     *  
     *  A macroblock to slice group map that fills frame in raster scan.
     *  
     *  @param picWidthInMbs
     *  @param picHeightInMbs
     *  @param sizeOfUpperLeftGroup
     *  @param changeDirection
     *  @return
     */
    constructor.buildRasterScanMap = function(picWidthInMbs, picHeightInMbs, sizeOfUpperLeftGroup, changeDirection) {
        var picSizeInMbs = picWidthInMbs * picHeightInMbs;
        var groups = new Int32Array(picSizeInMbs);
        var changeDirectionInt = changeDirection ? 1 : 0;
        var i;
        for (i = 0; i < sizeOfUpperLeftGroup; i++) {
            groups[i] = changeDirectionInt;
        }
        for (; i < picSizeInMbs; i++) {
            groups[i] = 1 - changeDirectionInt;
        }
        return groups;
    };
    /**
     *  A macroblock to slice group map that fills frame column by column
     *  
     *  @param picWidthInMbs
     *  @param picHeightInMbs
     *  @param sizeOfUpperLeftGroup
     *  @param changeDirection
     *  @return
     */
    constructor.buildWipeMap = function(picWidthInMbs, picHeightInMbs, sizeOfUpperLeftGroup, changeDirection) {
        var picSizeInMbs = picWidthInMbs * picHeightInMbs;
        var groups = new Int32Array(picSizeInMbs);
        var changeDirectionInt = changeDirection ? 1 : 0;
        var k = 0;
        for (var j = 0; j < picWidthInMbs; j++) {
            for (var i = 0; i < picHeightInMbs; i++) {
                var mbAddr = i * picWidthInMbs + j;
                if (k++ < sizeOfUpperLeftGroup) {
                    groups[mbAddr] = changeDirectionInt;
                } else {
                    groups[mbAddr] = 1 - changeDirectionInt;
                }
            }
        }
        return groups;
    };
}, {}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 * 
 *  @author in-somnia
 */
var FFTTables = function() {};
FFTTables = stjs.extend(FFTTables, null, [], function(constructor, prototype) {
    constructor.FFT_TABLE_512 = [new Float32Array([1.0, 0.0, 0.0]), new Float32Array([0.9999247, 0.012271538, -0.012271538]), new Float32Array([0.9996989, 0.024541229, -0.024541229]), new Float32Array([0.9993224, 0.036807224, -0.036807224]), new Float32Array([0.9987955, 0.049067676, -0.049067676]), new Float32Array([0.9981182, 0.061320737, -0.061320737]), new Float32Array([0.99729055, 0.07356457, -0.07356457]), new Float32Array([0.9963127, 0.08579732, -0.08579732]), new Float32Array([0.99518484, 0.09801715, -0.09801715]), new Float32Array([0.9939071, 0.11022222, -0.11022222]), new Float32Array([0.9924797, 0.12241069, -0.12241069]), new Float32Array([0.9909028, 0.13458073, -0.13458073]), new Float32Array([0.98917663, 0.1467305, -0.1467305]), new Float32Array([0.9873016, 0.15885818, -0.15885818]), new Float32Array([0.98527783, 0.17096192, -0.17096192]), new Float32Array([0.9831057, 0.18303992, -0.18303992]), new Float32Array([0.9807855, 0.19509035, -0.19509035]), new Float32Array([0.97831756, 0.2071114, -0.2071114]), new Float32Array([0.9757023, 0.21910128, -0.21910128]), new Float32Array([0.97294015, 0.23105815, -0.23105815]), new Float32Array([0.97003144, 0.24298023, -0.24298023]), new Float32Array([0.9669767, 0.2548657, -0.2548657]), new Float32Array([0.96377635, 0.2667128, -0.2667128]), new Float32Array([0.96043086, 0.27851975, -0.27851975]), new Float32Array([0.9569407, 0.29028472, -0.29028472]), new Float32Array([0.95330644, 0.302006, -0.302006]), new Float32Array([0.9495286, 0.3136818, -0.3136818]), new Float32Array([0.9456077, 0.32531038, -0.32531038]), new Float32Array([0.9415445, 0.33688995, -0.33688995]), new Float32Array([0.9373394, 0.3484188, -0.3484188]), new Float32Array([0.93299323, 0.35989517, -0.35989517]), new Float32Array([0.92850655, 0.37131733, -0.37131733]), new Float32Array([0.92388, 0.38268358, -0.38268358]), new Float32Array([0.9191143, 0.3939922, -0.3939922]), new Float32Array([0.9142102, 0.4052415, -0.4052415]), new Float32Array([0.9091684, 0.41642973, -0.41642973]), new Float32Array([0.9039898, 0.42755526, -0.42755526]), new Float32Array([0.89867496, 0.43861642, -0.43861642]), new Float32Array([0.89322484, 0.4496115, -0.4496115]), new Float32Array([0.8876402, 0.4605389, -0.4605389]), new Float32Array([0.8819218, 0.47139695, -0.47139695]), new Float32Array([0.8760707, 0.482184, -0.482184]), new Float32Array([0.8700876, 0.49289843, -0.49289843]), new Float32Array([0.8639735, 0.50353867, -0.50353867]), new Float32Array([0.85772926, 0.51410306, -0.51410306]), new Float32Array([0.85135585, 0.52459, -0.52459]), new Float32Array([0.84485424, 0.53499794, -0.53499794]), new Float32Array([0.83822536, 0.5453253, -0.5453253]), new Float32Array([0.83147025, 0.55557054, -0.55557054]), new Float32Array([0.82458997, 0.5657321, -0.5657321]), new Float32Array([0.8175855, 0.57580847, -0.57580847]), new Float32Array([0.8104579, 0.58579814, -0.58579814]), new Float32Array([0.80320823, 0.5956996, -0.5956996]), new Float32Array([0.79583764, 0.60551137, -0.60551137]), new Float32Array([0.7883472, 0.61523193, -0.61523193]), new Float32Array([0.780738, 0.62485987, -0.62485987]), new Float32Array([0.7730112, 0.6343937, -0.6343937]), new Float32Array([0.7651681, 0.64383197, -0.64383197]), new Float32Array([0.75720966, 0.6531733, -0.6531733]), new Float32Array([0.7491372, 0.6624163, -0.6624163]), new Float32Array([0.74095196, 0.67155945, -0.67155945]), new Float32Array([0.7326551, 0.68060154, -0.68060154]), new Float32Array([0.72424793, 0.6895411, -0.6895411]), new Float32Array([0.7157317, 0.69837683, -0.69837683]), new Float32Array([0.70710766, 0.70710737, -0.70710737]), new Float32Array([0.69837713, 0.71573144, -0.71573144]), new Float32Array([0.68954146, 0.7242477, -0.7242477]), new Float32Array([0.6806019, 0.73265487, -0.73265487]), new Float32Array([0.6715598, 0.7409518, -0.7409518]), new Float32Array([0.66241664, 0.74913704, -0.74913704]), new Float32Array([0.6531737, 0.75720954, -0.75720954]), new Float32Array([0.6438324, 0.765168, -0.765168]), new Float32Array([0.6343941, 0.77301127, -0.77301127]), new Float32Array([0.62486035, 0.78073806, -0.78073806]), new Float32Array([0.61523247, 0.7883473, -0.7883473]), new Float32Array([0.6055119, 0.79583776, -0.79583776]), new Float32Array([0.59570014, 0.8032084, -0.8032084]), new Float32Array([0.58579874, 0.8104581, -0.8104581]), new Float32Array([0.57580906, 0.81758577, -0.81758577]), new Float32Array([0.5657327, 0.82459027, -0.82459027]), new Float32Array([0.5555711, 0.8314706, -0.8314706]), new Float32Array([0.5453258, 0.8382257, -0.8382257]), new Float32Array([0.5349984, 0.8448546, -0.8448546]), new Float32Array([0.52459043, 0.85135627, -0.85135627]), new Float32Array([0.5141035, 0.85772973, -0.85772973]), new Float32Array([0.50353914, 0.86397403, -0.86397403]), new Float32Array([0.49289894, 0.8700882, -0.8700882]), new Float32Array([0.48218453, 0.87607133, -0.87607133]), new Float32Array([0.4713975, 0.88192254, -0.88192254]), new Float32Array([0.46053946, 0.8876409, -0.8876409]), new Float32Array([0.44961208, 0.8932256, -0.8932256]), new Float32Array([0.43861696, 0.8986758, -0.8986758]), new Float32Array([0.4275558, 0.9039906, -0.9039906]), new Float32Array([0.41643026, 0.9091693, -0.9091693]), new Float32Array([0.405242, 0.91421115, -0.91421115]), new Float32Array([0.3939927, 0.91911525, -0.91911525]), new Float32Array([0.38268408, 0.92388093, -0.92388093]), new Float32Array([0.37131783, 0.9285075, -0.9285075]), new Float32Array([0.35989568, 0.93299425, -0.93299425]), new Float32Array([0.3484193, 0.9373405, -0.9373405]), new Float32Array([0.33689046, 0.94154555, -0.94154555]), new Float32Array([0.3253109, 0.94560885, -0.94560885]), new Float32Array([0.31368232, 0.94952977, -0.94952977]), new Float32Array([0.3020065, 0.9533077, -0.9533077]), new Float32Array([0.29028523, 0.956942, -0.956942]), new Float32Array([0.27852023, 0.96043223, -0.96043223]), new Float32Array([0.26671326, 0.9637778, -0.9637778]), new Float32Array([0.25486615, 0.96697825, -0.96697825]), new Float32Array([0.24298064, 0.97003305, -0.97003305]), new Float32Array([0.23105855, 0.97294176, -0.97294176]), new Float32Array([0.21910167, 0.97570395, -0.97570395]), new Float32Array([0.20711178, 0.9783192, -0.9783192]), new Float32Array([0.19509071, 0.98078716, -0.98078716]), new Float32Array([0.18304025, 0.9831074, -0.9831074]), new Float32Array([0.17096223, 0.98527956, -0.98527956]), new Float32Array([0.15885846, 0.9873034, -0.9873034]), new Float32Array([0.14673077, 0.9891785, -0.9891785]), new Float32Array([0.13458098, 0.9909046, -0.9909046]), new Float32Array([0.12241093, 0.9924815, -0.9924815]), new Float32Array([0.11022244, 0.99390894, -0.99390894]), new Float32Array([0.09801734, 0.99518675, -0.99518675]), new Float32Array([0.085797496, 0.99631464, -0.99631464]), new Float32Array([0.07356472, 0.9972925, -0.9972925]), new Float32Array([0.061320875, 0.9981202, -0.9981202]), new Float32Array([0.049067788, 0.99879754, -0.99879754]), new Float32Array([0.03680731, 0.9993245, -0.9993245]), new Float32Array([0.024541289, 0.99970096, -0.99970096]), new Float32Array([0.012271572, 0.99992687, -0.99992687]), new Float32Array([7.4505806E-9, 1.0000021, -1.0000021]), new Float32Array([-0.012271557, 0.99992687, -0.99992687]), new Float32Array([-0.024541274, 0.999701, -0.999701]), new Float32Array([-0.036807295, 0.99932456, -0.99932456]), new Float32Array([-0.049067773, 0.99879766, -0.99879766]), new Float32Array([-0.06132086, 0.99812037, -0.99812037]), new Float32Array([-0.073564716, 0.9972927, -0.9972927]), new Float32Array([-0.085797496, 0.9963148, -0.9963148]), new Float32Array([-0.09801735, 0.995187, -0.995187]), new Float32Array([-0.11022245, 0.99390924, -0.99390924]), new Float32Array([-0.122410946, 0.9924818, -0.9924818]), new Float32Array([-0.13458101, 0.9909049, -0.9909049]), new Float32Array([-0.14673081, 0.9891788, -0.9891788]), new Float32Array([-0.15885851, 0.98730373, -0.98730373]), new Float32Array([-0.17096227, 0.98528, -0.98528]), new Float32Array([-0.1830403, 0.98310786, -0.98310786]), new Float32Array([-0.19509077, 0.98078763, -0.98078763]), new Float32Array([-0.20711185, 0.9783197, -0.9783197]), new Float32Array([-0.21910176, 0.97570443, -0.97570443]), new Float32Array([-0.23105866, 0.9729423, -0.9729423]), new Float32Array([-0.24298076, 0.9700336, -0.9700336]), new Float32Array([-0.25486627, 0.96697885, -0.96697885]), new Float32Array([-0.2667134, 0.9637785, -0.9637785]), new Float32Array([-0.27852038, 0.96043295, -0.96043295]), new Float32Array([-0.29028538, 0.9569428, -0.9569428]), new Float32Array([-0.3020067, 0.95330846, -0.95330846]), new Float32Array([-0.31368253, 0.9495306, -0.9495306]), new Float32Array([-0.32531112, 0.94560975, -0.94560975]), new Float32Array([-0.33689073, 0.9415465, -0.9415465]), new Float32Array([-0.34841958, 0.93734145, -0.93734145]), new Float32Array([-0.35989597, 0.93299526, -0.93299526]), new Float32Array([-0.37131816, 0.9285086, -0.9285086]), new Float32Array([-0.38268444, 0.923882, -0.923882]), new Float32Array([-0.39399308, 0.9191163, -0.9191163]), new Float32Array([-0.40524238, 0.9142122, -0.9142122]), new Float32Array([-0.41643065, 0.90917045, -0.90917045]), new Float32Array([-0.42755622, 0.90399176, -0.90399176]), new Float32Array([-0.4386174, 0.89867693, -0.89867693]), new Float32Array([-0.44961253, 0.89322674, -0.89322674]), new Float32Array([-0.46053994, 0.8876421, -0.8876421]), new Float32Array([-0.471398, 0.88192374, -0.88192374]), new Float32Array([-0.48218507, 0.8760726, -0.8760726]), new Float32Array([-0.49289954, 0.87008953, -0.87008953]), new Float32Array([-0.50353974, 0.8639754, -0.8639754]), new Float32Array([-0.5141041, 0.85773116, -0.85773116]), new Float32Array([-0.52459115, 0.85135776, -0.85135776]), new Float32Array([-0.5349991, 0.84485614, -0.84485614]), new Float32Array([-0.5453265, 0.8382273, -0.8382273]), new Float32Array([-0.55557173, 0.83147216, -0.83147216]), new Float32Array([-0.5657333, 0.8245919, -0.8245919]), new Float32Array([-0.5758097, 0.81758744, -0.81758744]), new Float32Array([-0.58579946, 0.8104598, -0.8104598]), new Float32Array([-0.5957009, 0.8032101, -0.8032101]), new Float32Array([-0.60551274, 0.7958395, -0.7958395]), new Float32Array([-0.6152333, 0.78834903, -0.78834903]), new Float32Array([-0.62486124, 0.7807398, -0.7807398]), new Float32Array([-0.63439506, 0.773013, -0.773013]), new Float32Array([-0.6438334, 0.7651698, -0.7651698]), new Float32Array([-0.65317476, 0.7572114, -0.7572114]), new Float32Array([-0.6624177, 0.74913895, -0.74913895]), new Float32Array([-0.6715609, 0.7409537, -0.7409537]), new Float32Array([-0.68060297, 0.73265684, -0.73265684]), new Float32Array([-0.68954253, 0.72424966, -0.72424966]), new Float32Array([-0.69837826, 0.71573335, -0.71573335]), new Float32Array([-0.70710886, 0.7071093, -0.7071093]), new Float32Array([-0.71573293, 0.69837874, -0.69837874]), new Float32Array([-0.72424924, 0.689543, -0.689543]), new Float32Array([-0.7326565, 0.68060344, -0.68060344]), new Float32Array([-0.7409534, 0.67156136, -0.67156136]), new Float32Array([-0.7491387, 0.6624182, -0.6624182]), new Float32Array([-0.7572112, 0.65317523, -0.65317523]), new Float32Array([-0.7651697, 0.64383394, -0.64383394]), new Float32Array([-0.77301294, 0.63439566, -0.63439566]), new Float32Array([-0.7807398, 0.62486184, -0.62486184]), new Float32Array([-0.78834903, 0.61523396, -0.61523396]), new Float32Array([-0.79583955, 0.6055134, -0.6055134]), new Float32Array([-0.8032102, 0.59570163, -0.59570163]), new Float32Array([-0.8104599, 0.5858002, -0.5858002]), new Float32Array([-0.81758755, 0.5758105, -0.5758105]), new Float32Array([-0.82459205, 0.5657341, -0.5657341]), new Float32Array([-0.83147246, 0.55557245, -0.55557245]), new Float32Array([-0.8382276, 0.5453272, -0.5453272]), new Float32Array([-0.8448565, 0.5349998, -0.5349998]), new Float32Array([-0.8513582, 0.5245918, -0.5245918]), new Float32Array([-0.85773164, 0.5141048, -0.5141048]), new Float32Array([-0.86397594, 0.5035404, -0.5035404]), new Float32Array([-0.8700901, 0.49290016, -0.49290016]), new Float32Array([-0.87607324, 0.48218572, -0.48218572]), new Float32Array([-0.88192445, 0.47139865, -0.47139865]), new Float32Array([-0.88764286, 0.4605406, -0.4605406]), new Float32Array([-0.8932276, 0.44961318, -0.44961318]), new Float32Array([-0.89867777, 0.43861806, -0.43861806]), new Float32Array([-0.90399265, 0.42755687, -0.42755687]), new Float32Array([-0.90917134, 0.4164313, -0.4164313]), new Float32Array([-0.9142132, 0.40524304, -0.40524304]), new Float32Array([-0.9191173, 0.3939937, -0.3939937]), new Float32Array([-0.92388296, 0.38268507, -0.38268507]), new Float32Array([-0.92850953, 0.3713188, -0.3713188]), new Float32Array([-0.9329963, 0.3598966, -0.3598966]), new Float32Array([-0.9373425, 0.3484202, -0.3484202]), new Float32Array([-0.94154763, 0.33689135, -0.33689135]), new Float32Array([-0.94561094, 0.32531175, -0.32531175]), new Float32Array([-0.94953185, 0.31368315, -0.31368315]), new Float32Array([-0.9533098, 0.30200732, -0.30200732]), new Float32Array([-0.9569441, 0.290286, -0.290286]), new Float32Array([-0.9604343, 0.27852097, -0.27852097]), new Float32Array([-0.9637799, 0.26671398, -0.26671398]), new Float32Array([-0.9669804, 0.25486684, -0.25486684]), new Float32Array([-0.97003525, 0.24298131, -0.24298131]), new Float32Array([-0.972944, 0.2310592, -0.2310592]), new Float32Array([-0.9757062, 0.21910228, -0.21910228]), new Float32Array([-0.9783215, 0.20711237, -0.20711237]), new Float32Array([-0.9807894, 0.19509128, -0.19509128]), new Float32Array([-0.98310965, 0.18304078, -0.18304078]), new Float32Array([-0.9852818, 0.17096274, -0.17096274]), new Float32Array([-0.98730564, 0.15885894, -0.15885894]), new Float32Array([-0.98918074, 0.14673121, -0.14673121]), new Float32Array([-0.9909069, 0.1345814, -0.1345814]), new Float32Array([-0.9924838, 0.12241132, -0.12241132]), new Float32Array([-0.9939112, 0.1102228, -0.1102228]), new Float32Array([-0.995189, 0.098017685, -0.098017685]), new Float32Array([-0.9963169, 0.08579781, -0.08579781]), new Float32Array([-0.9972948, 0.073565006, -0.073565006]), new Float32Array([-0.99812245, 0.06132113, -0.06132113]), new Float32Array([-0.9987998, 0.049068015, -0.049068015]), new Float32Array([-0.99932677, 0.036807507, -0.036807507]), new Float32Array([-0.9997032, 0.02454146, -0.02454146]), new Float32Array([-0.99992913, 0.012271715, -0.012271715]), new Float32Array([-1.0000044, 1.2293458E-7, -1.2293458E-7]), new Float32Array([-0.99992913, -0.012271469, 0.012271469]), new Float32Array([-0.9997033, -0.024541214, 0.024541214]), new Float32Array([-0.9993268, -0.03680726, 0.03680726]), new Float32Array([-0.9987999, -0.049067765, 0.049067765]), new Float32Array([-0.99812263, -0.061320882, 0.061320882]), new Float32Array([-0.99729496, -0.07356477, 0.07356477]), new Float32Array([-0.9963171, -0.08579758, 0.08579758]), new Float32Array([-0.99518925, -0.09801746, 0.09801746]), new Float32Array([-0.9939115, -0.110222585, 0.110222585]), new Float32Array([-0.9924841, -0.12241111, 0.12241111]), new Float32Array([-0.9909072, -0.1345812, 0.1345812]), new Float32Array([-0.98918104, -0.14673102, 0.14673102]), new Float32Array([-0.987306, -0.15885875, 0.15885875]), new Float32Array([-0.98528224, -0.17096254, 0.17096254]), new Float32Array([-0.98311013, -0.18304059, 0.18304059]), new Float32Array([-0.9807899, -0.19509108, 0.19509108]), new Float32Array([-0.97832197, -0.2071122, 0.2071122]), new Float32Array([-0.9757067, -0.21910211, 0.21910211]), new Float32Array([-0.97294456, -0.23105904, 0.23105904]), new Float32Array([-0.97003585, -0.24298118, 0.24298118]), new Float32Array([-0.96698105, -0.25486672, 0.25486672]), new Float32Array([-0.96378064, -0.26671386, 0.26671386]), new Float32Array([-0.9604351, -0.27852085, 0.27852085]), new Float32Array([-0.95694494, -0.2902859, 0.2902859]), new Float32Array([-0.9533106, -0.30200723, 0.30200723]), new Float32Array([-0.94953275, -0.31368306, 0.31368306]), new Float32Array([-0.9456119, -0.3253117, 0.3253117]), new Float32Array([-0.94154865, -0.3368913, 0.3368913]), new Float32Array([-0.9373436, -0.34842017, 0.34842017]), new Float32Array([-0.93299735, -0.3598966, 0.3598966]), new Float32Array([-0.92851067, -0.37131882, 0.37131882]), new Float32Array([-0.9238841, -0.38268512, 0.38268512]), new Float32Array([-0.9191184, -0.3939938, 0.3939938]), new Float32Array([-0.9142143, -0.40524313, 0.40524313]), new Float32Array([-0.90917253, -0.41643143, 0.41643143]), new Float32Array([-0.90399384, -0.42755702, 0.42755702]), new Float32Array([-0.898679, -0.43861824, 0.43861824]), new Float32Array([-0.8932288, -0.4496134, 0.4496134]), new Float32Array([-0.8876442, -0.46054083, 0.46054083]), new Float32Array([-0.8819258, -0.47139892, 0.47139892]), new Float32Array([-0.8760746, -0.48218602, 0.48218602]), new Float32Array([-0.8700915, -0.4929005, 0.4929005]), new Float32Array([-0.8639774, -0.50354075, 0.50354075]), new Float32Array([-0.85773313, -0.5141052, 0.5141052]), new Float32Array([-0.8513597, -0.5245922, 0.5245922]), new Float32Array([-0.8448581, -0.5350002, 0.5350002]), new Float32Array([-0.83822924, -0.5453276, 0.5453276]), new Float32Array([-0.8314741, -0.5555729, 0.5555729]), new Float32Array([-0.8245938, -0.56573457, 0.56573457]), new Float32Array([-0.8175893, -0.57581097, 0.57581097]), new Float32Array([-0.81046164, -0.5858007, 0.5858007]), new Float32Array([-0.8032119, -0.59570223, 0.59570223]), new Float32Array([-0.7958413, -0.60551405, 0.60551405]), new Float32Array([-0.78835076, -0.6152347, 0.6152347]), new Float32Array([-0.7807415, -0.6248626, 0.6248626]), new Float32Array([-0.7730147, -0.6343965, 0.6343965]), new Float32Array([-0.7651715, -0.6438348, 0.6438348]), new Float32Array([-0.7572131, -0.6531762, 0.6531762]), new Float32Array([-0.7491407, -0.6624192, 0.6624192]), new Float32Array([-0.7409554, -0.67156243, 0.67156243]), new Float32Array([-0.7326585, -0.6806046, 0.6806046]), new Float32Array([-0.72425133, -0.68954414, 0.68954414]), new Float32Array([-0.715735, -0.6983799, 0.6983799]), new Float32Array([-0.70711094, -0.70711046, 0.70711046]), new Float32Array([-0.69838035, -0.7157346, 0.7157346]), new Float32Array([-0.6895446, -0.7242509, 0.7242509]), new Float32Array([-0.68060505, -0.73265815, 0.73265815]), new Float32Array([-0.67156297, -0.7409551, 0.7409551]), new Float32Array([-0.6624198, -0.74914044, 0.74914044]), new Float32Array([-0.6531768, -0.75721294, 0.75721294]), new Float32Array([-0.6438354, -0.7651714, 0.7651714]), new Float32Array([-0.63439715, -0.77301466, 0.77301466]), new Float32Array([-0.6248633, -0.7807415, 0.7807415]), new Float32Array([-0.6152354, -0.78835076, 0.78835076]), new Float32Array([-0.6055148, -0.7958413, 0.7958413]), new Float32Array([-0.595703, -0.803212, 0.803212]), new Float32Array([-0.58580154, -0.81046176, 0.81046176]), new Float32Array([-0.5758118, -0.8175894, 0.8175894]), new Float32Array([-0.5657354, -0.8245939, 0.8245939]), new Float32Array([-0.55557376, -0.8314743, 0.8314743]), new Float32Array([-0.54532844, -0.8382295, 0.8382295]), new Float32Array([-0.535001, -0.84485835, 0.84485835]), new Float32Array([-0.524593, -0.85136, 0.85136]), new Float32Array([-0.514106, -0.8577335, 0.8577335]), new Float32Array([-0.5035416, -0.8639778, 0.8639778]), new Float32Array([-0.49290136, -0.870092, 0.870092]), new Float32Array([-0.48218688, -0.87607515, 0.87607515]), new Float32Array([-0.47139978, -0.8819264, 0.8819264]), new Float32Array([-0.4605417, -0.8876448, 0.8876448]), new Float32Array([-0.44961426, -0.89322954, 0.89322954]), new Float32Array([-0.4386191, -0.8986798, 0.8986798]), new Float32Array([-0.42755792, -0.9039947, 0.9039947]), new Float32Array([-0.41643232, -0.9091734, 0.9091734]), new Float32Array([-0.40524402, -0.91421527, 0.91421527]), new Float32Array([-0.3939947, -0.9191194, 0.9191194]), new Float32Array([-0.38268602, -0.92388517, 0.92388517]), new Float32Array([-0.3713197, -0.92851174, 0.92851174]), new Float32Array([-0.3598975, -0.9329985, 0.9329985]), new Float32Array([-0.34842107, -0.9373448, 0.9373448]), new Float32Array([-0.3368922, -0.9415499, 0.9415499]), new Float32Array([-0.32531255, -0.9456132, 0.9456132]), new Float32Array([-0.31368393, -0.9495341, 0.9495341]), new Float32Array([-0.3020081, -0.95331204, 0.95331204]), new Float32Array([-0.29028675, -0.9569464, 0.9569464]), new Float32Array([-0.2785217, -0.9604366, 0.9604366]), new Float32Array([-0.26671466, -0.9637822, 0.9637822]), new Float32Array([-0.2548675, -0.96698266, 0.96698266]), new Float32Array([-0.24298194, -0.9700375, 0.9700375]), new Float32Array([-0.23105979, -0.9729463, 0.9729463]), new Float32Array([-0.21910286, -0.9757085, 0.9757085]), new Float32Array([-0.20711292, -0.97832376, 0.97832376]), new Float32Array([-0.1950918, -0.9807917, 0.9807917]), new Float32Array([-0.18304129, -0.9831119, 0.9831119]), new Float32Array([-0.17096321, -0.9852841, 0.9852841]), new Float32Array([-0.15885939, -0.9873079, 0.9873079]), new Float32Array([-0.14673163, -0.989183, 0.989183]), new Float32Array([-0.13458179, -0.99090916, 0.99090916]), new Float32Array([-0.122411676, -0.99248606, 0.99248606]), new Float32Array([-0.11022313, -0.9939135, 0.9939135]), new Float32Array([-0.09801798, -0.9951913, 0.9951913]), new Float32Array([-0.08579808, -0.9963192, 0.9963192]), new Float32Array([-0.073565245, -0.99729705, 0.99729705]), new Float32Array([-0.06132134, -0.9981247, 0.9981247]), new Float32Array([-0.049068198, -0.99880207, 0.99880207]), new Float32Array([-0.036807664, -0.99932903, 0.99932903]), new Float32Array([-0.024541587, -0.9997055, 0.9997055]), new Float32Array([-0.012271815, -0.9999314, 0.9999314]), new Float32Array([-1.9464642E-7, -1.0000067, 1.0000067]), new Float32Array([0.012271426, -0.9999314, 0.9999314]), new Float32Array([0.0245412, -0.99970555, 0.99970555]), new Float32Array([0.036807276, -0.9993291, 0.9993291]), new Float32Array([0.04906781, -0.9988022, 0.9988022]), new Float32Array([0.061320953, -0.9981249, 0.9981249]), new Float32Array([0.073564865, -0.9972972, 0.9972972]), new Float32Array([0.0857977, -0.99631935, 0.99631935]), new Float32Array([0.09801761, -0.9951915, 0.9951915]), new Float32Array([0.110222764, -0.99391377, 0.99391377]), new Float32Array([0.12241132, -0.99248636, 0.99248636]), new Float32Array([0.13458143, -0.99090946, 0.99090946]), new Float32Array([0.14673129, -0.9891833, 0.9891833]), new Float32Array([0.15885904, -0.98730826, 0.98730826]), new Float32Array([0.17096287, -0.9852845, 0.9852845]), new Float32Array([0.18304095, -0.9831124, 0.9831124]), new Float32Array([0.19509147, -0.98079216, 0.98079216]), new Float32Array([0.20711261, -0.97832423, 0.97832423]), new Float32Array([0.21910256, -0.97570896, 0.97570896]), new Float32Array([0.23105952, -0.9729468, 0.9729468]), new Float32Array([0.24298169, -0.9700381, 0.9700381]), new Float32Array([0.25486726, -0.9669833, 0.9669833]), new Float32Array([0.26671442, -0.9637829, 0.9637829]), new Float32Array([0.27852145, -0.96043736, 0.96043736]), new Float32Array([0.2902865, -0.95694715, 0.95694715]), new Float32Array([0.30200788, -0.9533128, 0.9533128]), new Float32Array([0.31368375, -0.94953495, 0.94953495]), new Float32Array([0.3253124, -0.9456141, 0.9456141]), new Float32Array([0.33689204, -0.94155085, 0.94155085]), new Float32Array([0.34842095, -0.9373458, 0.9373458]), new Float32Array([0.3598974, -0.93299955, 0.93299955]), new Float32Array([0.37131965, -0.9285129, 0.9285129]), new Float32Array([0.382686, -0.9238863, 0.9238863]), new Float32Array([0.3939947, -0.9191206, 0.9191206]), new Float32Array([0.40524405, -0.91421646, 0.91421646]), new Float32Array([0.41643238, -0.9091746, 0.9091746]), new Float32Array([0.427558, -0.90399593, 0.90399593]), new Float32Array([0.43861923, -0.89868104, 0.89868104]), new Float32Array([0.4496144, -0.89323086, 0.89323086]), new Float32Array([0.46054187, -0.88764614, 0.88764614]), new Float32Array([0.4714, -0.8819278, 0.8819278]), new Float32Array([0.48218712, -0.8760766, 0.8760766]), new Float32Array([0.49290162, -0.87009346, 0.87009346]), new Float32Array([0.5035419, -0.8639793, 0.8639793]), new Float32Array([0.51410633, -0.85773504, 0.85773504]), new Float32Array([0.52459335, -0.85136163, 0.85136163]), new Float32Array([0.53500134, -0.84486, 0.84486]), new Float32Array([0.5453288, -0.83823115, 0.83823115]), new Float32Array([0.5555741, -0.831476, 0.831476]), new Float32Array([0.56573576, -0.82459563, 0.82459563]), new Float32Array([0.5758122, -0.81759113, 0.81759113]), new Float32Array([0.58580196, -0.8104634, 0.8104634]), new Float32Array([0.5957035, -0.8032137, 0.8032137]), new Float32Array([0.6055153, -0.79584306, 0.79584306]), new Float32Array([0.6152359, -0.78835255, 0.78835255]), new Float32Array([0.6248639, -0.7807433, 0.7807433]), new Float32Array([0.6343978, -0.7730165, 0.7730165]), new Float32Array([0.64383614, -0.7651733, 0.7651733]), new Float32Array([0.65317756, -0.7572149, 0.7572149]), new Float32Array([0.6624206, -0.7491424, 0.7491424]), new Float32Array([0.6715638, -0.7409571, 0.7409571]), new Float32Array([0.68060595, -0.7326602, 0.7326602]), new Float32Array([0.6895456, -0.72425294, 0.72425294]), new Float32Array([0.69838136, -0.7157366, 0.7157366]), new Float32Array([0.70711195, -0.70711255, 0.70711255]), new Float32Array([0.7157361, -0.69838196, 0.69838196]), new Float32Array([0.7242524, -0.6895462, 0.6895462]), new Float32Array([0.73265964, -0.6806066, 0.6806066]), new Float32Array([0.7409566, -0.67156446, 0.67156446]), new Float32Array([0.74914193, -0.6624212, 0.6624212]), new Float32Array([0.7572145, -0.6531782, 0.6531782]), new Float32Array([0.765173, -0.64383686, 0.64383686]), new Float32Array([0.77301633, -0.6343985, 0.6343985]), new Float32Array([0.7807432, -0.6248647, 0.6248647]), new Float32Array([0.7883525, -0.61523676, 0.61523676]), new Float32Array([0.795843, -0.60551614, 0.60551614]), new Float32Array([0.8032137, -0.5957043, 0.5957043]), new Float32Array([0.8104635, -0.58580285, 0.58580285]), new Float32Array([0.81759113, -0.5758131, 0.5758131]), new Float32Array([0.8245957, -0.56573665, 0.56573665]), new Float32Array([0.8314761, -0.55557495, 0.55557495]), new Float32Array([0.83823127, -0.54532963, 0.54532963]), new Float32Array([0.8448602, -0.5350022, 0.5350022]), new Float32Array([0.8513619, -0.5245941, 0.5245941]), new Float32Array([0.8577354, -0.5141071, 0.5141071]), new Float32Array([0.86397976, -0.50354266, 0.50354266]), new Float32Array([0.87009394, -0.4929024, 0.4929024]), new Float32Array([0.8760771, -0.4821879, 0.4821879]), new Float32Array([0.8819284, -0.4714008, 0.4714008]), new Float32Array([0.8876468, -0.46054268, 0.46054268]), new Float32Array([0.8932316, -0.44961524, 0.44961524]), new Float32Array([0.8986818, -0.43862006, 0.43862006]), new Float32Array([0.9039967, -0.42755884, 0.42755884]), new Float32Array([0.90917546, -0.41643322, 0.41643322]), new Float32Array([0.9142173, -0.4052449, 0.4052449]), new Float32Array([0.91912144, -0.39399552, 0.39399552]), new Float32Array([0.9238872, -0.38268682, 0.38268682]), new Float32Array([0.92851377, -0.3713205, 0.3713205]), new Float32Array([0.9330005, -0.35989824, 0.35989824]), new Float32Array([0.9373468, -0.3484218, 0.3484218]), new Float32Array([0.9415519, -0.3368929, 0.3368929]), new Float32Array([0.94561523, -0.32531324, 0.32531324]), new Float32Array([0.94953614, -0.31368458, 0.31368458]), new Float32Array([0.95331407, -0.30200872, 0.30200872]), new Float32Array([0.9569484, -0.29028735, 0.29028735]), new Float32Array([0.9604386, -0.27852228, 0.27852228]), new Float32Array([0.9637842, -0.26671523, 0.26671523]), new Float32Array([0.9669847, -0.25486803, 0.25486803]), new Float32Array([0.97003955, -0.24298245, 0.24298245]), new Float32Array([0.9729483, -0.23106027, 0.23106027]), new Float32Array([0.9757105, -0.2191033, 0.2191033]), new Float32Array([0.9783258, -0.20711334, 0.20711334]), new Float32Array([0.9807937, -0.19509219, 0.19509219]), new Float32Array([0.98311394, -0.18304165, 0.18304165]), new Float32Array([0.9852861, -0.17096354, 0.17096354]), new Float32Array([0.98730993, -0.15885969, 0.15885969]), new Float32Array([0.98918504, -0.14673191, 0.14673191]), new Float32Array([0.9909112, -0.13458204, 0.13458204]), new Float32Array([0.9924881, -0.12241191, 0.12241191]), new Float32Array([0.9939155, -0.11022334, 0.11022334]), new Float32Array([0.9951933, -0.09801817, 0.09801817]), new Float32Array([0.9963212, -0.08579824, 0.08579824]), new Float32Array([0.9972991, -0.073565386, 0.073565386]), new Float32Array([0.99812675, -0.061321456, 0.061321456]), new Float32Array([0.9988041, -0.04906829, 0.04906829]), new Float32Array([0.99933106, -0.03680773, 0.03680773]), new Float32Array([0.9997075, -0.02454163, 0.02454163]), new Float32Array([0.9999334, -0.012271833, 0.012271833])];
    constructor.FFT_TABLE_64 = [new Float32Array([1.0, 0.0]), new Float32Array([0.9951847, 0.09801714]), new Float32Array([0.98078525, 0.19509032]), new Float32Array([0.9569403, 0.2902847]), new Float32Array([0.9238795, 0.38268346]), new Float32Array([0.88192123, 0.47139674]), new Float32Array([0.83146954, 0.55557024]), new Float32Array([0.7730104, 0.6343933]), new Float32Array([0.7071067, 0.70710677]), new Float32Array([0.6343932, 0.77301043]), new Float32Array([0.5555701, 0.8314696]), new Float32Array([0.47139663, 0.88192123]), new Float32Array([0.38268334, 0.92387944]), new Float32Array([0.29028457, 0.95694023]), new Float32Array([0.19509023, 0.9807852]), new Float32Array([0.09801706, 0.9951846]), new Float32Array([-6.7055225E-8, 0.9999999]), new Float32Array([-0.09801719, 0.9951846]), new Float32Array([-0.19509035, 0.98078513]), new Float32Array([-0.2902847, 0.9569402]), new Float32Array([-0.38268346, 0.9238794]), new Float32Array([-0.47139674, 0.8819211]), new Float32Array([-0.55557024, 0.8314694]), new Float32Array([-0.6343933, 0.77301025]), new Float32Array([-0.7071067, 0.7071066]), new Float32Array([-0.7730104, 0.6343931]), new Float32Array([-0.83146954, 0.55557]), new Float32Array([-0.8819212, 0.4713965]), new Float32Array([-0.9238794, 0.38268322]), new Float32Array([-0.9569402, 0.29028445]), new Float32Array([-0.98078513, 0.19509012]), new Float32Array([-0.99518454, 0.09801695]), new Float32Array([-0.99999976, -1.7881393E-7]), new Float32Array([-0.9951845, -0.0980173]), new Float32Array([-0.980785, -0.19509046]), new Float32Array([-0.95694005, -0.29028478]), new Float32Array([-0.92387927, -0.38268352]), new Float32Array([-0.881921, -0.47139677]), new Float32Array([-0.8314693, -0.55557024]), new Float32Array([-0.77301013, -0.6343933]), new Float32Array([-0.7071065, -0.7071067]), new Float32Array([-0.634393, -0.7730104]), new Float32Array([-0.5555699, -0.83146954]), new Float32Array([-0.4713964, -0.8819212]), new Float32Array([-0.3826831, -0.9238794]), new Float32Array([-0.29028434, -0.9569402]), new Float32Array([-0.19509, -0.9807851]), new Float32Array([-0.098016836, -0.9951845]), new Float32Array([2.8312206E-7, -0.9999997]), new Float32Array([0.098017395, -0.9951844]), new Float32Array([0.19509055, -0.98078495]), new Float32Array([0.29028487, -0.95693994]), new Float32Array([0.3826836, -0.92387915]), new Float32Array([0.47139686, -0.8819209]), new Float32Array([0.55557036, -0.8314692]), new Float32Array([0.63439333, -0.77301]), new Float32Array([0.70710677, -0.70710635]), new Float32Array([0.7730104, -0.63439286]), new Float32Array([0.8314695, -0.55556977]), new Float32Array([0.88192105, -0.47139627]), new Float32Array([0.92387927, -0.38268298]), new Float32Array([0.95694005, -0.29028425]), new Float32Array([0.98078495, -0.19508994]), new Float32Array([0.99518436, -0.09801678])];
    constructor.FFT_TABLE_480 = [new Float32Array([1.0, 0.0, 0.0]), new Float32Array([0.99991435, 0.013089596, -0.013089596]), new Float32Array([0.99965733, 0.02617695, -0.02617695]), new Float32Array([0.999229, 0.039259817, -0.039259817]), new Float32Array([0.9986295, 0.05233596, -0.05233596]), new Float32Array([0.99785894, 0.06540313, -0.06540313]), new Float32Array([0.99691737, 0.0784591, -0.0784591]), new Float32Array([0.99580497, 0.09150162, -0.09150162]), new Float32Array([0.994522, 0.10452847, -0.10452847]), new Float32Array([0.9930686, 0.11753741, -0.11753741]), new Float32Array([0.991445, 0.13052621, -0.13052621]), new Float32Array([0.98965156, 0.14349265, -0.14349265]), new Float32Array([0.98768854, 0.1564345, -0.1564345]), new Float32Array([0.9855563, 0.16934955, -0.16934955]), new Float32Array([0.9832552, 0.18223558, -0.18223558]), new Float32Array([0.9807856, 0.1950904, -0.1950904]), new Float32Array([0.978148, 0.20791179, -0.20791179]), new Float32Array([0.9753427, 0.22069755, -0.22069755]), new Float32Array([0.97237027, 0.23344548, -0.23344548]), new Float32Array([0.9692313, 0.24615341, -0.24615341]), new Float32Array([0.96592623, 0.25881916, -0.25881916]), new Float32Array([0.9624557, 0.27144057, -0.27144057]), new Float32Array([0.9588202, 0.28401548, -0.28401548]), new Float32Array([0.9550204, 0.29654172, -0.29654172]), new Float32Array([0.951057, 0.30901715, -0.30901715]), new Float32Array([0.94693065, 0.32143965, -0.32143965]), new Float32Array([0.94264203, 0.33380705, -0.33380705]), new Float32Array([0.9381919, 0.3461173, -0.3461173]), new Float32Array([0.933581, 0.3583682, -0.3583682]), new Float32Array([0.9288101, 0.3705577, -0.3705577]), new Float32Array([0.9238801, 0.3826837, -0.3826837]), new Float32Array([0.9187918, 0.39474413, -0.39474413]), new Float32Array([0.913546, 0.40673694, -0.40673694]), new Float32Array([0.90814376, 0.41866004, -0.41866004]), new Float32Array([0.90258586, 0.43051142, -0.43051142]), new Float32Array([0.89687335, 0.44228902, -0.44228902]), new Float32Array([0.8910071, 0.45399085, -0.45399085]), new Float32Array([0.88498825, 0.46561489, -0.46561489]), new Float32Array([0.87881774, 0.47715914, -0.47715914]), new Float32Array([0.87249666, 0.48862165, -0.48862165]), new Float32Array([0.86602604, 0.5000004, -0.5000004]), new Float32Array([0.85940707, 0.51129353, -0.51129353]), new Float32Array([0.8526408, 0.522499, -0.522499]), new Float32Array([0.8457285, 0.533615, -0.533615]), new Float32Array([0.83867127, 0.5446395, -0.5446395]), new Float32Array([0.8314703, 0.5555707, -0.5555707]), new Float32Array([0.8241269, 0.5664068, -0.5664068]), new Float32Array([0.8166423, 0.57714576, -0.57714576]), new Float32Array([0.8090177, 0.58778584, -0.58778584]), new Float32Array([0.8012545, 0.5983252, -0.5983252]), new Float32Array([0.7933541, 0.608762, -0.608762]), new Float32Array([0.7853177, 0.61909455, -0.61909455]), new Float32Array([0.77714676, 0.629321, -0.629321]), new Float32Array([0.76884264, 0.63943964, -0.63943964]), new Float32Array([0.7604068, 0.6494487, -0.6494487]), new Float32Array([0.75184065, 0.6593465, -0.6593465]), new Float32Array([0.7431457, 0.66913134, -0.66913134]), new Float32Array([0.7343234, 0.6788015, -0.6788015]), new Float32Array([0.72537524, 0.6883554, -0.6883554]), new Float32Array([0.7163028, 0.6977913, -0.6977913]), new Float32Array([0.70710766, 0.7071076, -0.7071076]), new Float32Array([0.69779134, 0.7163028, -0.7163028]), new Float32Array([0.68835545, 0.7253753, -0.7253753]), new Float32Array([0.67880166, 0.7343235, -0.7343235]), new Float32Array([0.6691315, 0.7431459, -0.7431459]), new Float32Array([0.6593467, 0.7518409, -0.7518409]), new Float32Array([0.64944893, 0.7604071, -0.7604071]), new Float32Array([0.6394399, 0.768843, -0.768843]), new Float32Array([0.6293213, 0.7771471, -0.7771471]), new Float32Array([0.61909485, 0.7853181, -0.7853181]), new Float32Array([0.6087623, 0.7933545, -0.7933545]), new Float32Array([0.5983255, 0.801255, -0.801255]), new Float32Array([0.58778614, 0.8090182, -0.8090182]), new Float32Array([0.57714605, 0.81664276, -0.81664276]), new Float32Array([0.56640714, 0.8241274, -0.8241274]), new Float32Array([0.55557114, 0.83147085, -0.83147085]), new Float32Array([0.54463995, 0.8386718, -0.8386718]), new Float32Array([0.5336154, 0.8457291, -0.8457291]), new Float32Array([0.52249944, 0.8526415, -0.8526415]), new Float32Array([0.51129395, 0.85940784, -0.85940784]), new Float32Array([0.50000083, 0.8660269, -0.8660269]), new Float32Array([0.48862207, 0.87249756, -0.87249756]), new Float32Array([0.4771596, 0.8788187, -0.8788187]), new Float32Array([0.46561536, 0.88498926, -0.88498926]), new Float32Array([0.45399132, 0.89100814, -0.89100814]), new Float32Array([0.4422895, 0.8968744, -0.8968744]), new Float32Array([0.4305119, 0.902587, -0.902587]), new Float32Array([0.41866052, 0.9081449, -0.9081449]), new Float32Array([0.40673742, 0.9135472, -0.9135472]), new Float32Array([0.3947446, 0.91879296, -0.91879296]), new Float32Array([0.38268417, 0.92388135, -0.92388135]), new Float32Array([0.37055814, 0.9288114, -0.9288114]), new Float32Array([0.35836864, 0.93358225, -0.93358225]), new Float32Array([0.34611773, 0.93819314, -0.93819314]), new Float32Array([0.3338075, 0.94264334, -0.94264334]), new Float32Array([0.3214401, 0.94693196, -0.94693196]), new Float32Array([0.3090176, 0.9510583, -0.9510583]), new Float32Array([0.29654217, 0.95502174, -0.95502174]), new Float32Array([0.28401592, 0.9588216, -0.9588216]), new Float32Array([0.271441, 0.9624571, -0.9624571]), new Float32Array([0.25881958, 0.9659277, -0.9659277]), new Float32Array([0.2461538, 0.96923286, -0.96923286]), new Float32Array([0.23344585, 0.9723719, -0.9723719]), new Float32Array([0.2206979, 0.9753443, -0.9753443]), new Float32Array([0.20791212, 0.9781496, -0.9781496]), new Float32Array([0.19509073, 0.9807873, -0.9807873]), new Float32Array([0.18223591, 0.98325694, -0.98325694]), new Float32Array([0.16934988, 0.9855581, -0.9855581]), new Float32Array([0.15643482, 0.9876904, -0.9876904]), new Float32Array([0.14349295, 0.98965347, -0.98965347]), new Float32Array([0.1305265, 0.991447, -0.991447]), new Float32Array([0.117537685, 0.9930706, -0.9930706]), new Float32Array([0.104528725, 0.99452406, -0.99452406]), new Float32Array([0.09150185, 0.9958071, -0.9958071]), new Float32Array([0.07845929, 0.9969195, -0.9969195]), new Float32Array([0.0654033, 0.9978611, -0.9978611]), new Float32Array([0.052336097, 0.9986317, -0.9986317]), new Float32Array([0.03925993, 0.9992312, -0.9992312]), new Float32Array([0.026177032, 0.99965954, -0.99965954]), new Float32Array([0.013089649, 0.99991655, -0.99991655]), new Float32Array([2.4214387E-8, 1.0000023, -1.0000023]), new Float32Array([-0.013089602, 0.9999166, -0.9999166]), new Float32Array([-0.026176985, 0.9996596, -0.9996596]), new Float32Array([-0.039259885, 0.9992313, -0.9992313]), new Float32Array([-0.052336056, 0.9986318, -0.9986318]), new Float32Array([-0.06540326, 0.9978612, -0.9978612]), new Float32Array([-0.078459255, 0.99691963, -0.99691963]), new Float32Array([-0.09150181, 0.99580723, -0.99580723]), new Float32Array([-0.10452869, 0.99452424, -0.99452424]), new Float32Array([-0.117537655, 0.99307084, -0.99307084]), new Float32Array([-0.13052648, 0.99144727, -0.99144727]), new Float32Array([-0.14349295, 0.98965377, -0.98965377]), new Float32Array([-0.15643483, 0.98769075, -0.98769075]), new Float32Array([-0.16934991, 0.9855585, -0.9855585]), new Float32Array([-0.18223597, 0.9832574, -0.9832574]), new Float32Array([-0.19509082, 0.9807878, -0.9807878]), new Float32Array([-0.20791222, 0.9781502, -0.9781502]), new Float32Array([-0.220698, 0.9753449, -0.9753449]), new Float32Array([-0.23344596, 0.9723725, -0.9723725]), new Float32Array([-0.24615392, 0.9692335, -0.9692335]), new Float32Array([-0.2588197, 0.96592844, -0.96592844]), new Float32Array([-0.27144113, 0.96245784, -0.96245784]), new Float32Array([-0.28401607, 0.95882237, -0.95882237]), new Float32Array([-0.29654235, 0.9550226, -0.9550226]), new Float32Array([-0.3090178, 0.95105916, -0.95105916]), new Float32Array([-0.3214403, 0.9469328, -0.9469328]), new Float32Array([-0.33380774, 0.9426441, -0.9426441]), new Float32Array([-0.34611797, 0.9381939, -0.9381939]), new Float32Array([-0.3583689, 0.933583, -0.933583]), new Float32Array([-0.37055844, 0.92881215, -0.92881215]), new Float32Array([-0.38268447, 0.9238821, -0.9238821]), new Float32Array([-0.39474493, 0.9187938, -0.9187938]), new Float32Array([-0.40673777, 0.91354805, -0.91354805]), new Float32Array([-0.4186609, 0.9081458, -0.9081458]), new Float32Array([-0.4305123, 0.9025879, -0.9025879]), new Float32Array([-0.44228995, 0.8968753, -0.8968753]), new Float32Array([-0.4539918, 0.8910091, -0.8910091]), new Float32Array([-0.46561587, 0.8849902, -0.8849902]), new Float32Array([-0.47716016, 0.8788197, -0.8788197]), new Float32Array([-0.4886227, 0.8724986, -0.8724986]), new Float32Array([-0.5000015, 0.86602795, -0.86602795]), new Float32Array([-0.5112946, 0.859409, -0.859409]), new Float32Array([-0.5225001, 0.8526427, -0.8526427]), new Float32Array([-0.53361607, 0.84573036, -0.84573036]), new Float32Array([-0.5446406, 0.8386731, -0.8386731]), new Float32Array([-0.5555718, 0.83147216, -0.83147216]), new Float32Array([-0.56640786, 0.82412875, -0.82412875]), new Float32Array([-0.5771468, 0.81664413, -0.81664413]), new Float32Array([-0.587787, 0.80901957, -0.80901957]), new Float32Array([-0.5983263, 0.80125636, -0.80125636]), new Float32Array([-0.6087632, 0.7933559, -0.7933559]), new Float32Array([-0.6190958, 0.78531945, -0.78531945]), new Float32Array([-0.6293223, 0.7771484, -0.7771484]), new Float32Array([-0.63944095, 0.76884425, -0.76884425]), new Float32Array([-0.64945006, 0.76040834, -0.76040834]), new Float32Array([-0.6593479, 0.75184214, -0.75184214]), new Float32Array([-0.66913277, 0.7431472, -0.7431472]), new Float32Array([-0.6788029, 0.7343249, -0.7343249]), new Float32Array([-0.6883568, 0.7253767, -0.7253767]), new Float32Array([-0.69779277, 0.7163043, -0.7163043]), new Float32Array([-0.7071091, 0.70710915, -0.70710915]), new Float32Array([-0.7163043, 0.6977928, -0.6977928]), new Float32Array([-0.7253768, 0.68835694, -0.68835694]), new Float32Array([-0.734325, 0.6788031, -0.6788031]), new Float32Array([-0.7431474, 0.66913295, -0.66913295]), new Float32Array([-0.7518424, 0.65934813, -0.65934813]), new Float32Array([-0.7604086, 0.64945036, -0.64945036]), new Float32Array([-0.7688445, 0.6394413, -0.6394413]), new Float32Array([-0.77714866, 0.62932265, -0.62932265]), new Float32Array([-0.7853197, 0.6190962, -0.6190962]), new Float32Array([-0.7933561, 0.60876364, -0.60876364]), new Float32Array([-0.80125666, 0.59832674, -0.59832674]), new Float32Array([-0.8090199, 0.58778733, -0.58778733]), new Float32Array([-0.8166445, 0.57714725, -0.57714725]), new Float32Array([-0.82412916, 0.5664083, -0.5664083]), new Float32Array([-0.83147264, 0.5555722, -0.5555722]), new Float32Array([-0.83867365, 0.544641, -0.544641]), new Float32Array([-0.84573096, 0.5336164, -0.5336164]), new Float32Array([-0.8526434, 0.52250046, -0.52250046]), new Float32Array([-0.8594097, 0.51129496, -0.51129496]), new Float32Array([-0.8660287, 0.50000185, -0.50000185]), new Float32Array([-0.8724994, 0.48862305, -0.48862305]), new Float32Array([-0.87882054, 0.47716054, -0.47716054]), new Float32Array([-0.8849911, 0.4656163, -0.4656163]), new Float32Array([-0.89101005, 0.45399225, -0.45399225]), new Float32Array([-0.89687634, 0.4422904, -0.4422904]), new Float32Array([-0.9025889, 0.43051276, -0.43051276]), new Float32Array([-0.90814686, 0.41866136, -0.41866136]), new Float32Array([-0.9135492, 0.40673822, -0.40673822]), new Float32Array([-0.918795, 0.39474538, -0.39474538]), new Float32Array([-0.9238834, 0.38268492, -0.38268492]), new Float32Array([-0.9288134, 0.37055886, -0.37055886]), new Float32Array([-0.9335843, 0.35836932, -0.35836932]), new Float32Array([-0.93819517, 0.3461184, -0.3461184]), new Float32Array([-0.9426454, 0.33380815, -0.33380815]), new Float32Array([-0.94693404, 0.32144073, -0.32144073]), new Float32Array([-0.9510605, 0.3090182, -0.3090182]), new Float32Array([-0.95502394, 0.29654273, -0.29654273]), new Float32Array([-0.9588238, 0.28401646, -0.28401646]), new Float32Array([-0.9624593, 0.27144152, -0.27144152]), new Float32Array([-0.9659299, 0.25882006, -0.25882006]), new Float32Array([-0.96923506, 0.24615425, -0.24615425]), new Float32Array([-0.9723741, 0.23344627, -0.23344627]), new Float32Array([-0.9753465, 0.22069828, -0.22069828]), new Float32Array([-0.9781518, 0.20791247, -0.20791247]), new Float32Array([-0.9807895, 0.19509105, -0.19509105]), new Float32Array([-0.98325914, 0.18223621, -0.18223621]), new Float32Array([-0.9855603, 0.16935015, -0.16935015]), new Float32Array([-0.9876926, 0.15643506, -0.15643506]), new Float32Array([-0.9896557, 0.14349316, -0.14349316]), new Float32Array([-0.9914492, 0.13052668, -0.13052668]), new Float32Array([-0.9930728, 0.117537834, -0.117537834]), new Float32Array([-0.99452627, 0.104528844, -0.104528844]), new Float32Array([-0.9958093, 0.091501944, -0.091501944]), new Float32Array([-0.9969217, 0.07845937, -0.07845937]), new Float32Array([-0.9978633, 0.06540334, -0.06540334]), new Float32Array([-0.9986339, 0.05233611, -0.05233611]), new Float32Array([-0.9992334, 0.039259914, -0.039259914]), new Float32Array([-0.99966174, 0.02617699, -0.02617699]), new Float32Array([-0.99991876, 0.013089578, -0.013089578]), new Float32Array([-1.0000044, -7.636845E-8, 7.636845E-8]), new Float32Array([-0.99991876, -0.01308973, 0.01308973]), new Float32Array([-0.99966174, -0.026177142, 0.026177142]), new Float32Array([-0.9992334, -0.039260067, 0.039260067]), new Float32Array([-0.9986339, -0.052336264, 0.052336264]), new Float32Array([-0.99786335, -0.0654035, 0.0654035]), new Float32Array([-0.9969218, -0.07845952, 0.07845952]), new Float32Array([-0.9958094, -0.09150211, 0.09150211]), new Float32Array([-0.9945263, -0.10452901, 0.10452901]), new Float32Array([-0.9930729, -0.117538, 0.117538]), new Float32Array([-0.99144936, -0.13052686, 0.13052686]), new Float32Array([-0.98965585, -0.14349335, 0.14349335]), new Float32Array([-0.98769283, -0.15643525, 0.15643525]), new Float32Array([-0.9855606, -0.16935036, 0.16935036]), new Float32Array([-0.98325944, -0.18223645, 0.18223645]), new Float32Array([-0.98078984, -0.19509132, 0.19509132]), new Float32Array([-0.9781522, -0.20791276, 0.20791276]), new Float32Array([-0.9753469, -0.22069857, 0.22069857]), new Float32Array([-0.9723745, -0.23344655, 0.23344655]), new Float32Array([-0.96923554, -0.24615455, 0.24615455]), new Float32Array([-0.96593046, -0.25882035, 0.25882035]), new Float32Array([-0.96245986, -0.27144182, 0.27144182]), new Float32Array([-0.95882434, -0.2840168, 0.2840168]), new Float32Array([-0.95502454, -0.2965431, 0.2965431]), new Float32Array([-0.9510611, -0.30901858, 0.30901858]), new Float32Array([-0.9469347, -0.3214411, 0.3214411]), new Float32Array([-0.942646, -0.33380857, 0.33380857]), new Float32Array([-0.9381958, -0.34611884, 0.34611884]), new Float32Array([-0.9335849, -0.3583698, 0.3583698]), new Float32Array([-0.928814, -0.37055936, 0.37055936]), new Float32Array([-0.923884, -0.38268542, 0.38268542]), new Float32Array([-0.91879565, -0.39474592, 0.39474592]), new Float32Array([-0.9135499, -0.4067388, 0.4067388]), new Float32Array([-0.9081476, -0.41866195, 0.41866195]), new Float32Array([-0.9025897, -0.43051338, 0.43051338]), new Float32Array([-0.8968771, -0.44229105, 0.44229105]), new Float32Array([-0.8910109, -0.45399293, 0.45399293]), new Float32Array([-0.884992, -0.465617, 0.465617]), new Float32Array([-0.87882143, -0.47716132, 0.47716132]), new Float32Array([-0.8725003, -0.4886239, 0.4886239]), new Float32Array([-0.8660297, -0.50000274, 0.50000274]), new Float32Array([-0.8594107, -0.5112959, 0.5112959]), new Float32Array([-0.85264444, -0.52250147, 0.52250147]), new Float32Array([-0.8457321, -0.5336175, 0.5336175]), new Float32Array([-0.83867484, -0.5446421, 0.5446421]), new Float32Array([-0.8314739, -0.55557334, 0.55557334]), new Float32Array([-0.8241304, -0.5664094, 0.5664094]), new Float32Array([-0.8166458, -0.57714844, 0.57714844]), new Float32Array([-0.8090212, -0.5877886, 0.5877886]), new Float32Array([-0.80125797, -0.598328, 0.598328]), new Float32Array([-0.7933575, -0.6087649, 0.6087649]), new Float32Array([-0.78532106, -0.6190975, 0.6190975]), new Float32Array([-0.77715003, -0.62932396, 0.62932396]), new Float32Array([-0.76884586, -0.6394427, 0.6394427]), new Float32Array([-0.76040995, -0.6494518, 0.6494518]), new Float32Array([-0.75184375, -0.6593496, 0.6593496]), new Float32Array([-0.74314874, -0.6691345, 0.6691345]), new Float32Array([-0.73432636, -0.6788047, 0.6788047]), new Float32Array([-0.7253782, -0.6883586, 0.6883586]), new Float32Array([-0.7163058, -0.69779456, 0.69779456]), new Float32Array([-0.7071106, -0.70711094, 0.70711094]), new Float32Array([-0.6977942, -0.71630615, 0.71630615]), new Float32Array([-0.68835825, -0.72537863, 0.72537863]), new Float32Array([-0.6788044, -0.73432684, 0.73432684]), new Float32Array([-0.66913426, -0.7431492, 0.7431492]), new Float32Array([-0.6593494, -0.7518443, 0.7518443]), new Float32Array([-0.6494516, -0.76041055, 0.76041055]), new Float32Array([-0.63944256, -0.76884645, 0.76884645]), new Float32Array([-0.6293239, -0.77715063, 0.77715063]), new Float32Array([-0.6190974, -0.78532165, 0.78532165]), new Float32Array([-0.6087648, -0.7933581, 0.7933581]), new Float32Array([-0.59832793, -0.8012586, 0.8012586]), new Float32Array([-0.5877885, -0.8090219, 0.8090219]), new Float32Array([-0.5771484, -0.81664646, 0.81664646]), new Float32Array([-0.5664094, -0.82413113, 0.82413113]), new Float32Array([-0.55557334, -0.8314746, 0.8314746]), new Float32Array([-0.5446421, -0.8386756, 0.8386756]), new Float32Array([-0.5336175, -0.8457329, 0.8457329]), new Float32Array([-0.52250147, -0.85264534, 0.85264534]), new Float32Array([-0.5112959, -0.85941166, 0.85941166]), new Float32Array([-0.50000274, -0.8660307, 0.8660307]), new Float32Array([-0.48862392, -0.8725014, 0.8725014]), new Float32Array([-0.47716138, -0.8788225, 0.8788225]), new Float32Array([-0.4656171, -0.8849931, 0.8849931]), new Float32Array([-0.45399302, -0.891012, 0.891012]), new Float32Array([-0.44229114, -0.8968783, 0.8968783]), new Float32Array([-0.4305135, -0.9025909, 0.9025909]), new Float32Array([-0.41866207, -0.9081488, 0.9081488]), new Float32Array([-0.4067389, -0.91355115, 0.91355115]), new Float32Array([-0.39474607, -0.91879696, 0.91879696]), new Float32Array([-0.38268557, -0.92388535, 0.92388535]), new Float32Array([-0.3705595, -0.92881536, 0.92881536]), new Float32Array([-0.35836995, -0.93358624, 0.93358624]), new Float32Array([-0.346119, -0.9381972, 0.9381972]), new Float32Array([-0.33380872, -0.9426474, 0.9426474]), new Float32Array([-0.32144126, -0.9469361, 0.9469361]), new Float32Array([-0.3090187, -0.9510625, 0.9510625]), new Float32Array([-0.2965432, -0.955026, 0.955026]), new Float32Array([-0.2840169, -0.9588258, 0.9588258]), new Float32Array([-0.27144194, -0.96246135, 0.96246135]), new Float32Array([-0.25882047, -0.965932, 0.965932]), new Float32Array([-0.24615464, -0.96923715, 0.96923715]), new Float32Array([-0.23344663, -0.97237617, 0.97237617]), new Float32Array([-0.22069862, -0.97534865, 0.97534865]), new Float32Array([-0.2079128, -0.97815394, 0.97815394]), new Float32Array([-0.19509135, -0.9807916, 0.9807916]), new Float32Array([-0.18223648, -0.9832613, 0.9832613]), new Float32Array([-0.16935039, -0.98556244, 0.98556244]), new Float32Array([-0.15643527, -0.9876948, 0.9876948]), new Float32Array([-0.14349334, -0.9896579, 0.9896579]), new Float32Array([-0.13052683, -0.9914514, 0.9914514]), new Float32Array([-0.11753795, -0.993075, 0.993075]), new Float32Array([-0.104528934, -0.9945285, 0.9945285]), new Float32Array([-0.091502, -0.9958115, 0.9958115]), new Float32Array([-0.0784594, -0.9969239, 0.9969239]), new Float32Array([-0.06540334, -0.9978655, 0.9978655]), new Float32Array([-0.05233608, -0.9986361, 0.9986361]), new Float32Array([-0.03925986, -0.99923563, 0.99923563]), new Float32Array([-0.026176903, -0.99966395, 0.99966395]), new Float32Array([-0.013089463, -0.99992096, 0.99992096]), new Float32Array([2.1979213E-7, -1.0000067, 1.0000067]), new Float32Array([0.013089904, -0.999921, 0.999921]), new Float32Array([0.026177345, -0.999664, 0.999664]), new Float32Array([0.0392603, -0.9992357, 0.9992357]), new Float32Array([0.05233653, -0.9986362, 0.9986362]), new Float32Array([0.06540379, -0.9978656, 0.9978656]), new Float32Array([0.078459844, -0.99692404, 0.99692404]), new Float32Array([0.09150246, -0.99581164, 0.99581164]), new Float32Array([0.104529396, -0.9945286, 0.9945286]), new Float32Array([0.117538415, -0.9930752, 0.9930752]), new Float32Array([0.1305273, -0.9914516, 0.9914516]), new Float32Array([0.14349383, -0.9896581, 0.9896581]), new Float32Array([0.15643576, -0.9876951, 0.9876951]), new Float32Array([0.16935089, -0.98556286, 0.98556286]), new Float32Array([0.18223701, -0.9832617, 0.9832617]), new Float32Array([0.19509192, -0.98079205, 0.98079205]), new Float32Array([0.20791338, -0.97815436, 0.97815436]), new Float32Array([0.22069922, -0.97534907, 0.97534907]), new Float32Array([0.23344724, -0.97237664, 0.97237664]), new Float32Array([0.24615526, -0.9692376, 0.9692376]), new Float32Array([0.2588211, -0.96593255, 0.96593255]), new Float32Array([0.2714426, -0.96246195, 0.96246195]), new Float32Array([0.2840176, -0.9588264, 0.9588264]), new Float32Array([0.29654393, -0.9550266, 0.9550266]), new Float32Array([0.30901945, -0.9510632, 0.9510632]), new Float32Array([0.321442, -0.9469368, 0.9469368]), new Float32Array([0.3338095, -0.9426481, 0.9426481]), new Float32Array([0.3461198, -0.9381979, 0.9381979]), new Float32Array([0.35837078, -0.933587, 0.933587]), new Float32Array([0.37056035, -0.9288161, 0.9288161]), new Float32Array([0.38268644, -0.923886, 0.923886]), new Float32Array([0.39474696, -0.9187976, 0.9187976]), new Float32Array([0.40673983, -0.91355187, 0.91355187]), new Float32Array([0.41866302, -0.90814954, 0.90814954]), new Float32Array([0.43051448, -0.90259165, 0.90259165]), new Float32Array([0.44229218, -0.8968791, 0.8968791]), new Float32Array([0.4539941, -0.89101285, 0.89101285]), new Float32Array([0.4656182, -0.884994, 0.884994]), new Float32Array([0.47716254, -0.8788234, 0.8788234]), new Float32Array([0.4886251, -0.87250227, 0.87250227]), new Float32Array([0.500004, -0.86603165, 0.86603165]), new Float32Array([0.51129717, -0.85941267, 0.85941267]), new Float32Array([0.5225027, -0.8526464, 0.8526464]), new Float32Array([0.53361875, -0.84573406, 0.84573406]), new Float32Array([0.54464334, -0.8386768, 0.8386768]), new Float32Array([0.5555746, -0.83147585, 0.83147585]), new Float32Array([0.5664107, -0.8241324, 0.8241324]), new Float32Array([0.57714975, -0.8166477, 0.8166477]), new Float32Array([0.58778995, -0.8090231, 0.8090231]), new Float32Array([0.59832937, -0.8012598, 0.8012598]), new Float32Array([0.60876626, -0.79335934, 0.79335934]), new Float32Array([0.61909884, -0.7853229, 0.7853229]), new Float32Array([0.62932533, -0.7771519, 0.7771519]), new Float32Array([0.63944405, -0.7688477, 0.7688477]), new Float32Array([0.64945316, -0.7604118, 0.7604118]), new Float32Array([0.65935105, -0.7518456, 0.7518456]), new Float32Array([0.669136, -0.7431506, 0.7431506]), new Float32Array([0.6788062, -0.7343282, 0.7343282]), new Float32Array([0.68836015, -0.72538, 0.72538]), new Float32Array([0.69779617, -0.7163075, 0.7163075]), new Float32Array([0.70711255, -0.7071123, 0.7071123]), new Float32Array([0.7163078, -0.6977959, 0.6977959]), new Float32Array([0.72538036, -0.68836, 0.68836]), new Float32Array([0.7343286, -0.67880607, 0.67880607]), new Float32Array([0.74315107, -0.66913587, 0.66913587]), new Float32Array([0.75184613, -0.659351, 0.659351]), new Float32Array([0.7604124, -0.64945316, 0.64945316]), new Float32Array([0.7688483, -0.63944405, 0.63944405]), new Float32Array([0.7771525, -0.6293254, 0.6293254]), new Float32Array([0.7853235, -0.6190989, 0.6190989]), new Float32Array([0.79335994, -0.60876626, 0.60876626]), new Float32Array([0.8012605, -0.59832937, 0.59832937]), new Float32Array([0.80902374, -0.58778995, 0.58778995]), new Float32Array([0.81664836, -0.5771498, 0.5771498]), new Float32Array([0.82413304, -0.5664108, 0.5664108]), new Float32Array([0.83147657, -0.5555747, 0.5555747]), new Float32Array([0.8386776, -0.54464346, 0.54464346]), new Float32Array([0.84573495, -0.53361887, 0.53361887]), new Float32Array([0.85264736, -0.52250284, 0.52250284]), new Float32Array([0.8594137, -0.5112973, 0.5112973]), new Float32Array([0.8660327, -0.5000041, 0.5000041]), new Float32Array([0.8725034, -0.48862526, 0.48862526]), new Float32Array([0.8788246, -0.4771627, 0.4771627]), new Float32Array([0.88499516, -0.46561837, 0.46561837]), new Float32Array([0.8910141, -0.45399427, 0.45399427]), new Float32Array([0.8968804, -0.44229236, 0.44229236]), new Float32Array([0.90259296, -0.4305147, 0.4305147]), new Float32Array([0.9081509, -0.41866326, 0.41866326]), new Float32Array([0.91355324, -0.40674007, 0.40674007]), new Float32Array([0.91879904, -0.3947472, 0.3947472]), new Float32Array([0.92388743, -0.38268667, 0.38268667]), new Float32Array([0.9288175, -0.3705606, 0.3705606]), new Float32Array([0.93358845, -0.358371, 0.358371]), new Float32Array([0.9381994, -0.34612, 0.34612]), new Float32Array([0.9426496, -0.3338097, 0.3338097]), new Float32Array([0.9469383, -0.32144222, 0.32144222]), new Float32Array([0.9510647, -0.30901963, 0.30901963]), new Float32Array([0.9550282, -0.2965441, 0.2965441]), new Float32Array([0.95882803, -0.28401777, 0.28401777]), new Float32Array([0.96246356, -0.27144277, 0.27144277]), new Float32Array([0.9659342, -0.25882128, 0.25882128]), new Float32Array([0.96923935, -0.24615541, 0.24615541]), new Float32Array([0.9723784, -0.23344737, 0.23344737]), new Float32Array([0.97535086, -0.22069934, 0.22069934]), new Float32Array([0.97815615, -0.20791349, 0.20791349]), new Float32Array([0.98079383, -0.19509201, 0.19509201]), new Float32Array([0.98326355, -0.1822371, 0.1822371]), new Float32Array([0.98556477, -0.16935098, 0.16935098]), new Float32Array([0.9876971, -0.15643583, 0.15643583]), new Float32Array([0.9896602, -0.14349388, 0.14349388]), new Float32Array([0.9914537, -0.13052733, 0.13052733]), new Float32Array([0.99307734, -0.11753843, 0.11753843]), new Float32Array([0.9945308, -0.10452938, 0.10452938]), new Float32Array([0.99581385, -0.09150242, 0.09150242]), new Float32Array([0.9969263, -0.078459784, 0.078459784]), new Float32Array([0.9978679, -0.0654037, 0.0654037]), new Float32Array([0.9986385, -0.05233641, 0.05233641]), new Float32Array([0.999238, -0.039260153, 0.039260153]), new Float32Array([0.99966633, -0.026177168, 0.026177168]), new Float32Array([0.99992335, -0.013089697, 0.013089697])];
    constructor.FFT_TABLE_60 = [new Float32Array([1.0, 0.0]), new Float32Array([0.9945219, 0.104528464]), new Float32Array([0.9781476, 0.2079117]), new Float32Array([0.95105654, 0.309017]), new Float32Array([0.9135455, 0.40673664]), new Float32Array([0.86602545, 0.5]), new Float32Array([0.80901706, 0.58778524]), new Float32Array([0.7431449, 0.66913056]), new Float32Array([0.66913074, 0.7431448]), new Float32Array([0.58778536, 0.809017]), new Float32Array([0.5000001, 0.86602545]), new Float32Array([0.40673676, 0.9135455]), new Float32Array([0.30901712, 0.9510566]), new Float32Array([0.2079118, 0.9781477]), new Float32Array([0.104528576, 0.994522]), new Float32Array([1.0430813E-7, 1.0000001]), new Float32Array([-0.104528375, 0.99452204]), new Float32Array([-0.20791161, 0.97814775]), new Float32Array([-0.30901694, 0.95105666]), new Float32Array([-0.4067366, 0.9135456]), new Float32Array([-0.5, 0.86602557]), new Float32Array([-0.5877853, 0.8090172]), new Float32Array([-0.6691307, 0.74314505]), new Float32Array([-0.7431449, 0.66913086]), new Float32Array([-0.8090172, 0.5877855]), new Float32Array([-0.8660256, 0.5000002]), new Float32Array([-0.9135457, 0.4067368]), new Float32Array([-0.95105684, 0.30901712]), new Float32Array([-0.9781479, 0.20791179]), new Float32Array([-0.9945222, 0.10452853]), new Float32Array([-1.0000004, 3.7252903E-8]), new Float32Array([-0.9945223, -0.104528464]), new Float32Array([-0.978148, -0.20791173]), new Float32Array([-0.9510569, -0.3090171]), new Float32Array([-0.91354585, -0.4067368]), new Float32Array([-0.8660258, -0.5000002]), new Float32Array([-0.80901736, -0.5877855]), new Float32Array([-0.7431452, -0.66913086]), new Float32Array([-0.66913104, -0.7431451]), new Float32Array([-0.58778566, -0.80901736]), new Float32Array([-0.50000036, -0.86602587]), new Float32Array([-0.40673697, -0.91354597]), new Float32Array([-0.30901727, -0.9510571]), new Float32Array([-0.20791191, -0.9781482]), new Float32Array([-0.10452862, -0.9945225]), new Float32Array([-9.685755E-8, -1.0000006]), new Float32Array([0.10452843, -0.9945225]), new Float32Array([0.20791173, -0.9781482]), new Float32Array([0.30901712, -0.95105714]), new Float32Array([0.40673685, -0.9135461]), new Float32Array([0.5000003, -0.86602604]), new Float32Array([0.5877856, -0.8090176]), new Float32Array([0.669131, -0.7431454]), new Float32Array([0.7431453, -0.66913116]), new Float32Array([0.80901754, -0.5877858]), new Float32Array([0.86602604, -0.5000005]), new Float32Array([0.91354614, -0.40673706]), new Float32Array([0.95105726, -0.30901736]), new Float32Array([0.9781484, -0.20791197]), new Float32Array([0.99452275, -0.104528666])];
}, {FFT_TABLE_512: "Array", FFT_TABLE_64: "Array", FFT_TABLE_480: "Array", FFT_TABLE_60: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Frame = function(pic, pts, duration, pixelAspect, frameNo, tapeTimecode, messages) {
    this.pic = pic;
    this.pts = pts;
    this.duration = duration;
    this.pixelAspect = pixelAspect;
    this.tapeTimecode = tapeTimecode;
    this.frameNo = frameNo;
    this.messages = messages;
};
Frame = stjs.extend(Frame, null, [], function(constructor, prototype) {
    prototype.pic = null;
    prototype.pts = null;
    prototype.duration = null;
    prototype.pixelAspect = null;
    prototype.tapeTimecode = null;
    prototype.frameNo = 0;
    prototype.messages = null;
    prototype.getPic = function() {
        return this.pic;
    };
    prototype.getPts = function() {
        return this.pts;
    };
    prototype.getDuration = function() {
        return this.duration;
    };
    prototype.getPixelAspect = function() {
        return this.pixelAspect;
    };
    prototype.getTapeTimecode = function() {
        return this.tapeTimecode;
    };
    prototype.getFrameNo = function() {
        return this.frameNo;
    };
    prototype.getMessages = function() {
        return this.messages;
    };
    prototype.isAvailable = function() {
        return true;
    };
}, {pic: "Picture", pts: "RationalLarge", duration: "RationalLarge", pixelAspect: "Rational", tapeTimecode: "TapeTimecode", messages: {name: "List", arguments: [null]}}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license. 
 * 
 *  @author in-somnia
 */
var NoiseTable = function() {};
NoiseTable = stjs.extend(NoiseTable, null, [], function(constructor, prototype) {
    constructor.NOISE_TABLE = [new Float32Array([-0.99948156, -0.59483415]), new Float32Array([0.97113454, -0.67528516]), new Float32Array([0.14130051, -0.95090985]), new Float32Array([-0.47005495, -0.3734055]), new Float32Array([0.80705065, 0.29653668]), new Float32Array([-0.3898148, 0.8957261]), new Float32Array([-0.010530499, -0.6695906]), new Float32Array([-0.9126637, -0.11522938]), new Float32Array([0.5484042, 0.75221366]), new Float32Array([0.40009254, -0.989294]), new Float32Array([-0.99867976, -0.8814707]), new Float32Array([-0.95531076, 0.9090876]), new Float32Array([-0.45725933, -0.5671632]), new Float32Array([-0.72929674, -0.98008275]), new Float32Array([0.756228, 0.2095033]), new Float32Array([0.070694424, -0.782479]), new Float32Array([0.7449625, -0.91169006]), new Float32Array([-0.96440184, -0.9473992]), new Float32Array([0.3042463, -0.49438268]), new Float32Array([0.6656503, 0.6465294]), new Float32Array([0.9169701, 0.17514098]), new Float32Array([-0.7077492, 0.5254865]), new Float32Array([-0.70051414, -0.45340028]), new Float32Array([-0.99496514, -0.9007191]), new Float32Array([0.9816449, -0.77463156]), new Float32Array([-0.5467158, -0.025709284]), new Float32Array([-0.01689629, 0.0028750645]), new Float32Array([-0.8611035, 0.42548585]), new Float32Array([-0.9889298, -0.8788113]), new Float32Array([0.51756626, 0.66926783]), new Float32Array([-0.9963503, -0.5810773]), new Float32Array([-0.9996937, 0.9836999]), new Float32Array([0.5526626, 0.5944906]), new Float32Array([0.34581178, 0.9487942]), new Float32Array([0.6266421, -0.7440297]), new Float32Array([-0.771497, -0.33883658]), new Float32Array([-0.91592246, 0.036879014]), new Float32Array([-0.76285493, -0.9137187]), new Float32Array([0.7978834, -0.9318097]), new Float32Array([0.5447308, -0.119192064]), new Float32Array([-0.8563928, 0.42429855]), new Float32Array([-0.928824, 0.27871808]), new Float32Array([-0.11708371, -0.99800843]), new Float32Array([0.2135675, -0.90716296]), new Float32Array([-0.76191694, 0.9976812]), new Float32Array([0.98111045, -0.9585446]), new Float32Array([-0.8591327, 0.9576657]), new Float32Array([-0.93307245, 0.4943176]), new Float32Array([0.30485755, -0.70540035]), new Float32Array([0.8528965, 0.46766132]), new Float32Array([0.91328084, -0.998396]), new Float32Array([-0.058902, 0.70741826]), new Float32Array([0.28398687, 0.34633556]), new Float32Array([0.95258164, -0.54893416]), new Float32Array([-0.78566325, -0.7556854]), new Float32Array([-0.957895, -0.20423195]), new Float32Array([0.8241116, 0.9665462]), new Float32Array([-0.65185446, -0.8873499]), new Float32Array([-0.93643606, 0.9987079]), new Float32Array([0.9142716, -0.98290503]), new Float32Array([-0.70395684, 0.587968]), new Float32Array([0.0056377198, 0.617682]), new Float32Array([0.8906505, 0.5278335]), new Float32Array([-0.6868371, 0.80806947]), new Float32Array([0.7216534, -0.6925986]), new Float32Array([-0.6292825, 0.13627037]), new Float32Array([0.29938436, -0.4605133]), new Float32Array([-0.91781956, -0.74012715]), new Float32Array([0.99298716, 0.4081661]), new Float32Array([0.82368296, -0.7403605]), new Float32Array([-0.98512834, -0.9997233]), new Float32Array([-0.9591537, -0.992378]), new Float32Array([-0.21411127, -0.9342482]), new Float32Array([-0.6882148, -0.26892307]), new Float32Array([0.91852, 0.09358229]), new Float32Array([-0.9606277, 0.36099094]), new Float32Array([0.51646185, -0.7137333]), new Float32Array([0.6113072, 0.4695014]), new Float32Array([0.47336128, -0.2733318]), new Float32Array([0.9099831, 0.96715665]), new Float32Array([0.448448, 0.99211574]), new Float32Array([0.6661489, 0.96590173]), new Float32Array([0.7492224, -0.8987986]), new Float32Array([-0.99571586, 0.5278552]), new Float32Array([0.9740108, -0.1685587]), new Float32Array([0.72683746, -0.48060775]), new Float32Array([0.9543219, 0.68849605]), new Float32Array([-0.72962207, -0.76608443]), new Float32Array([-0.8535948, 0.88738126]), new Float32Array([-0.8141243, -0.9748077]), new Float32Array([-0.87930775, 0.7474831]), new Float32Array([-0.7157333, -0.9857061]), new Float32Array([0.835243, 0.83702534]), new Float32Array([-0.48086065, -0.98848504]), new Float32Array([0.97139126, 0.8009362]), new Float32Array([0.5199283, 0.8024763]), new Float32Array([-0.008485912, -0.7667013]), new Float32Array([-0.70294374, 0.5535991]), new Float32Array([-0.95894426, -0.43265504]), new Float32Array([0.97079253, 0.093258575]), new Float32Array([-0.92404294, 0.855077]), new Float32Array([-0.6950647, 0.98633415]), new Float32Array([0.26559204, 0.7331431]), new Float32Array([0.28038442, 0.14537914]), new Float32Array([-0.7413812, 0.9931034]), new Float32Array([-0.01752796, -0.82616633]), new Float32Array([-0.55126774, -0.9889854]), new Float32Array([0.979609, -0.94021446]), new Float32Array([-0.9919631, 0.67019016]), new Float32Array([-0.6768493, 0.12631492]), new Float32Array([0.09140039, -0.20537731]), new Float32Array([-0.7165896, -0.977882]), new Float32Array([0.8101464, 0.5372265]), new Float32Array([0.40616992, -0.26469007]), new Float32Array([-0.67680186, 0.9450205]), new Float32Array([0.8684977, -0.18333599]), new Float32Array([-0.9950038, -0.02634122]), new Float32Array([0.8432919, 0.104069576]), new Float32Array([-0.09215969, 0.6954001]), new Float32Array([0.9995617, -0.12358542]), new Float32Array([-0.7973278, -0.91582525]), new Float32Array([0.9634997, 0.96640456]), new Float32Array([-0.7994278, 0.643239]), new Float32Array([-0.1156604, 0.28587845]), new Float32Array([-0.39922956, 0.94129604]), new Float32Array([0.990892, -0.9206263]), new Float32Array([0.28631285, -0.91035044]), new Float32Array([-0.83302724, -0.6733041]), new Float32Array([0.95404446, 0.49162766]), new Float32Array([-0.06449863, 0.03250561]), new Float32Array([-0.99575055, 0.42389783]), new Float32Array([-0.6550114, 0.82546115]), new Float32Array([-0.8125444, -0.51627237]), new Float32Array([-0.9964637, 0.8449053]), new Float32Array([0.002878406, 0.6476826]), new Float32Array([0.7017699, -0.20453028]), new Float32Array([0.9636188, 0.40706968]), new Float32Array([-0.6888376, 0.91338956]), new Float32Array([-0.34875587, 0.71472293]), new Float32Array([0.9198008, 0.6650745]), new Float32Array([-0.9900905, 0.8586802]), new Float32Array([0.68865794, 0.5566032]), new Float32Array([-0.994844, -0.2005256]), new Float32Array([0.9421451, -0.9969643]), new Float32Array([-0.6741463, 0.4954822]), new Float32Array([-0.47339353, -0.8590433]), new Float32Array([0.14323652, -0.94145596]), new Float32Array([-0.29268295, 0.05759225]), new Float32Array([0.4379386, -0.7890497]), new Float32Array([-0.36345127, 0.64874434]), new Float32Array([-0.08750605, 0.97686946]), new Float32Array([-0.9649527, -0.53960305]), new Float32Array([0.5552694, 0.7889152]), new Float32Array([0.73538214, 0.96452075]), new Float32Array([-0.30889773, -0.8066439]), new Float32Array([0.035749957, -0.9732562]), new Float32Array([0.9872069, 0.48409134]), new Float32Array([-0.816893, -0.90827703]), new Float32Array([0.6786686, 0.81284505]), new Float32Array([-0.1580857, 0.85279554]), new Float32Array([0.8072339, -0.24717419]), new Float32Array([0.47788757, -0.4633315]), new Float32Array([0.96367556, 0.3848675]), new Float32Array([-0.99143875, -0.24945277]), new Float32Array([0.8308188, -0.9478085]), new Float32Array([-0.5875319, 0.012907724]), new Float32Array([0.9553811, -0.8555705]), new Float32Array([-0.9649092, -0.64020973]), new Float32Array([-0.973271, 0.12378128]), new Float32Array([0.9140037, 0.5797247]), new Float32Array([-0.9992584, 0.71084845]), new Float32Array([-0.86875904, -0.202917]), new Float32Array([-0.26240036, -0.68264556]), new Float32Array([-0.24664412, -0.8764227]), new Float32Array([0.024162758, 0.27192914]), new Float32Array([0.8206862, -0.8508779]), new Float32Array([0.8854737, -0.896368]), new Float32Array([-0.18173078, -0.26152146]), new Float32Array([0.093554765, 0.54845124]), new Float32Array([-0.54668415, 0.95980775]), new Float32Array([0.3705099, -0.5991014]), new Float32Array([-0.70373595, 0.9122767]), new Float32Array([-0.34600785, -0.99441427]), new Float32Array([-0.6877448, -0.30238837]), new Float32Array([-0.26843292, 0.8311567]), new Float32Array([0.49072334, -0.4535971]), new Float32Array([0.38975993, 0.9551536]), new Float32Array([-0.97757125, 0.053058945]), new Float32Array([-0.17325553, -0.9277067]), new Float32Array([0.99948037, 0.58285546]), new Float32Array([-0.64946246, 0.6864551]), new Float32Array([-0.12016921, -0.57147324]), new Float32Array([-0.58947456, -0.3484713]), new Float32Array([-0.4181514, 0.16276422]), new Float32Array([0.9988565, 0.11136095]), new Float32Array([-0.56649613, -0.90494865]), new Float32Array([0.9413802, 0.35281917]), new Float32Array([-0.7572508, 0.5365055]), new Float32Array([0.20541973, -0.94435143]), new Float32Array([0.9998037, 0.79835916]), new Float32Array([0.29078278, 0.35393777]), new Float32Array([-0.6285877, 0.38765693]), new Float32Array([0.43440905, -0.9854633]), new Float32Array([-0.98298585, 0.21021524]), new Float32Array([0.19513029, -0.9423983]), new Float32Array([-0.95476663, 0.98364556]), new Float32Array([0.93379635, -0.7088199]), new Float32Array([-0.8523541, -0.08342348]), new Float32Array([-0.86425096, -0.45795026]), new Float32Array([0.3887978, 0.9727443]), new Float32Array([0.9204512, -0.62433654]), new Float32Array([0.89162534, 0.5495096]), new Float32Array([-0.36834338, 0.964583]), new Float32Array([0.93891764, -0.89968354]), new Float32Array([0.99267656, -0.037570342]), new Float32Array([-0.9406347, 0.41332337]), new Float32Array([0.99740225, -0.16830495]), new Float32Array([-0.35899413, -0.46633226]), new Float32Array([0.052372374, -0.25640363]), new Float32Array([0.36703584, -0.38653266]), new Float32Array([0.9165318, -0.30587628]), new Float32Array([0.69000804, 0.9095217]), new Float32Array([-0.3865875, 0.99501574]), new Float32Array([-0.29250816, 0.37444994]), new Float32Array([-0.601822, 0.8677965]), new Float32Array([-0.9741859, 0.96468526]), new Float32Array([0.8846157, 0.57508403]), new Float32Array([0.05198933, 0.21269661]), new Float32Array([-0.5349962, 0.97241557]), new Float32Array([-0.4942956, 0.98183864]), new Float32Array([-0.98935145, -0.4024916]), new Float32Array([-0.9808138, -0.728569]), new Float32Array([-0.2733815, 0.9995092]), new Float32Array([0.06310803, -0.54539585]), new Float32Array([-0.20461677, -0.14209978]), new Float32Array([0.6622384, 0.7252858]), new Float32Array([-0.84764344, 0.023723168]), new Float32Array([-0.8903986, 0.8886658]), new Float32Array([0.9590331, 0.76744926]), new Float32Array([0.73504126, -0.037472032]), new Float32Array([-0.31744435, -0.36834112]), new Float32Array([-0.34110826, 0.40211222]), new Float32Array([0.47803885, -0.39423218]), new Float32Array([0.98299193, 0.019897914]), new Float32Array([-0.30963072, -0.18076721]), new Float32Array([0.9999259, -0.26281872]), new Float32Array([-0.93149734, -0.98313165]), new Float32Array([0.99923474, -0.8014299]), new Float32Array([-0.2602417, -0.7599976]), new Float32Array([-0.35712513, 0.19298963]), new Float32Array([-0.99899083, 0.74645156]), new Float32Array([0.86557174, 0.55593866]), new Float32Array([0.33408043, 0.86185956]), new Float32Array([0.99010736, 0.046023976]), new Float32Array([-0.6669427, -0.91643614]), new Float32Array([0.6401679, 0.1564953]), new Float32Array([0.99570537, 0.45844585]), new Float32Array([-0.63431466, 0.21079117]), new Float32Array([-0.07706847, -0.89581436]), new Float32Array([0.9859009, 0.8824172]), new Float32Array([0.8009933, -0.36851898]), new Float32Array([0.78368133, 0.45507]), new Float32Array([0.087078065, 0.80938995]), new Float32Array([-0.8681188, 0.3934731]), new Float32Array([-0.3946653, -0.66809434]), new Float32Array([0.97875327, -0.7246784]), new Float32Array([-0.95038563, 0.8956322]), new Float32Array([0.1700524, 0.54683053]), new Float32Array([-0.76910794, -0.96226615]), new Float32Array([0.9974328, 0.42697158]), new Float32Array([0.95437384, 0.9700232]), new Float32Array([0.99578905, -0.54106826]), new Float32Array([0.2805826, -0.8536142]), new Float32Array([0.8525652, -0.6456761]), new Float32Array([-0.5060854, -0.65846014]), new Float32Array([-0.97210735, -0.23095213]), new Float32Array([0.9542405, -0.9924015]), new Float32Array([-0.9692657, 0.73775655]), new Float32Array([0.30872163, 0.4151496]), new Float32Array([-0.2452384, 0.6320663]), new Float32Array([-0.33813265, -0.38661778]), new Float32Array([-0.058268283, -0.06940774]), new Float32Array([-0.22898461, 0.9705485]), new Float32Array([-0.18509915, 0.47565764]), new Float32Array([-0.10488238, -0.8776995]), new Float32Array([-0.7188659, 0.7803098]), new Float32Array([0.99793875, 0.9004131]), new Float32Array([0.57563305, -0.91034335]), new Float32Array([0.28909647, 0.96307784]), new Float32Array([0.42189, 0.4814865]), new Float32Array([0.9333505, -0.43537024]), new Float32Array([-0.9708738, 0.8663645]), new Float32Array([0.36722872, 0.65291655]), new Float32Array([-0.81093025, 0.0877837]), new Float32Array([-0.26240602, -0.92774093]), new Float32Array([0.839965, 0.5583985]), new Float32Array([-0.99909616, -0.9602461]), new Float32Array([0.74649465, 0.121448934]), new Float32Array([-0.74774593, -0.26898062]), new Float32Array([0.95781666, -0.79047924]), new Float32Array([0.95472306, -0.08588776]), new Float32Array([0.48708332, 0.9999904]), new Float32Array([0.46332037, 0.10964126]), new Float32Array([-0.76497006, 0.8921093]), new Float32Array([0.5739739, 0.35289705]), new Float32Array([0.7537432, 0.96705216]), new Float32Array([-0.591744, -0.8940537]), new Float32Array([0.75087905, -0.29612672]), new Float32Array([-0.98607856, 0.2503491]), new Float32Array([-0.40761057, -0.9004557]), new Float32Array([0.6692927, 0.9862949]), new Float32Array([-0.974637, -0.001902233]), new Float32Array([0.9014551, 0.9978139]), new Float32Array([-0.87259287, 0.99233586]), new Float32Array([-0.9152946, -0.15698707]), new Float32Array([-0.033057388, -0.37205264]), new Float32Array([0.07223051, -0.88805]), new Float32Array([0.9949801, 0.97094357]), new Float32Array([-0.74904937, 0.99985486]), new Float32Array([0.045852285, 0.99812335]), new Float32Array([-0.89054954, -0.31791914]), new Float32Array([-0.8378214, 0.97637635]), new Float32Array([0.33454806, -0.8623152]), new Float32Array([-0.9970758, 0.9323799]), new Float32Array([-0.22827528, 0.1887476]), new Float32Array([0.67248046, -0.036462113]), new Float32Array([-0.05146538, -0.925997]), new Float32Array([0.999473, 0.9362523]), new Float32Array([0.66951126, 0.98905826]), new Float32Array([-0.99602956, -0.44654715]), new Float32Array([0.82104903, 0.9954074]), new Float32Array([0.9918651, 0.72023]), new Float32Array([-0.6528459, 0.5218672]), new Float32Array([0.93885446, -0.7489531]), new Float32Array([0.9673525, 0.90891814]), new Float32Array([-0.22225969, 0.5712403]), new Float32Array([-0.44132784, -0.9268884]), new Float32Array([-0.85694975, 0.8884453]), new Float32Array([0.9178304, -0.46356893]), new Float32Array([0.7255697, -0.99899554]), new Float32Array([-0.9971158, 0.5821156]), new Float32Array([0.7763898, 0.94321835]), new Float32Array([0.07717324, 0.586384]), new Float32Array([-0.5604983, 0.825223]), new Float32Array([0.98398894, 0.3946744]), new Float32Array([0.47546947, 0.68613046]), new Float32Array([0.6567509, 0.18331636]), new Float32Array([0.032733753, -0.7493311]), new Float32Array([-0.38684145, 0.5133735]), new Float32Array([-0.9734627, -0.9654936]), new Float32Array([-0.53282154, -0.9142327]), new Float32Array([0.9981731, 0.61133575]), new Float32Array([-0.502545, -0.8882934]), new Float32Array([0.019958733, 0.85223514]), new Float32Array([0.9993038, 0.945789]), new Float32Array([0.82907766, -0.063234426]), new Float32Array([-0.5866071, 0.96840775]), new Float32Array([-0.17573737, -0.48166922]), new Float32Array([0.8343429, -0.13023451]), new Float32Array([0.059464913, 0.20511048]), new Float32Array([0.81505483, -0.9468595]), new Float32Array([-0.4497638, 0.40894574]), new Float32Array([-0.89746475, 0.9984658]), new Float32Array([0.39677256, -0.74854666]), new Float32Array([-0.07588948, 0.74096215]), new Float32Array([0.76343197, 0.41746628]), new Float32Array([-0.74490106, 0.9472591]), new Float32Array([0.6488012, 0.41336662]), new Float32Array([0.62319535, -0.9309831]), new Float32Array([0.42215818, -0.077127874]), new Float32Array([0.02704554, -0.05417518]), new Float32Array([0.8000177, 0.91542196]), new Float32Array([-0.7935183, -0.36208898]), new Float32Array([0.6387236, 0.081282526]), new Float32Array([0.5289052, 0.6004887]), new Float32Array([0.7423855, 0.04491915]), new Float32Array([0.9909613, -0.19451183]), new Float32Array([-0.8041233, -0.88513815]), new Float32Array([-0.64612615, 0.7219868]), new Float32Array([0.11657771, -0.8366283]), new Float32Array([-0.95053184, -0.96939903]), new Float32Array([-0.6222887, 0.8276726]), new Float32Array([0.030044759, -0.99738896]), new Float32Array([-0.97987217, 0.3652613]), new Float32Array([-0.9998698, -0.3602161]), new Float32Array([0.8911065, -0.9789425]), new Float32Array([0.104079604, 0.7735779]), new Float32Array([0.95964736, -0.3543582]), new Float32Array([0.5084323, 0.9610769]), new Float32Array([0.17006335, -0.76854026]), new Float32Array([0.25872675, 0.998933]), new Float32Array([-0.011159987, 0.9849602]), new Float32Array([-0.795987, 0.9713841]), new Float32Array([-0.9926471, -0.9954282]), new Float32Array([-0.9982966, 0.018771388]), new Float32Array([-0.70801014, 0.33680686]), new Float32Array([-0.70467055, 0.93272775]), new Float32Array([0.99846023, -0.9872575]), new Float32Array([-0.6336497, -0.16473594]), new Float32Array([-0.16258217, -0.95939124]), new Float32Array([-0.43645594, -0.9480503]), new Float32Array([-0.99848473, 0.9624517]), new Float32Array([-0.1679646, -0.98987514]), new Float32Array([-0.8797923, -0.71725726]), new Float32Array([0.441831, -0.93568975]), new Float32Array([0.9331018, -0.9991331]), new Float32Array([-0.9394193, -0.56409377]), new Float32Array([-0.8859, 0.476246]), new Float32Array([0.9997146, -0.83889955]), new Float32Array([-0.75376385, 0.008146434]), new Float32Array([0.93887687, -0.11284528]), new Float32Array([0.85126436, 0.5234925]), new Float32Array([0.3970142, 0.81779635]), new Float32Array([-0.37024465, -0.8707166]), new Float32Array([-0.36024827, 0.34655735]), new Float32Array([-0.93388814, -0.8447654]), new Float32Array([-0.652988, -0.18439576]), new Float32Array([0.11960319, 0.99899346]), new Float32Array([0.94292563, 0.83163905]), new Float32Array([0.75081146, -0.35533223]), new Float32Array([0.5672198, -0.24076836]), new Float32Array([0.46857765, -0.30140233]), new Float32Array([0.97312313, -0.9954819]), new Float32Array([-0.38299978, 0.9851691]), new Float32Array([0.410258, 0.02116737]), new Float32Array([0.09638062, 0.044119842]), new Float32Array([-0.8528325, 0.91475564]), new Float32Array([0.88866806, -0.99735266]), new Float32Array([-0.48202428, -0.9680561]), new Float32Array([0.2757258, 0.5863475]), new Float32Array([-0.6588913, 0.5883563]), new Float32Array([0.98838085, 0.9999435]), new Float32Array([-0.2065135, 0.54593045]), new Float32Array([-0.62126416, -0.5989368]), new Float32Array([0.20320106, -0.8687918]), new Float32Array([-0.9779055, 0.9629081]), new Float32Array([0.11112535, 0.21484764]), new Float32Array([-0.41368338, 0.2821684]), new Float32Array([0.24133039, 0.5129436]), new Float32Array([-0.6639341, -0.0824968]), new Float32Array([-0.5369783, -0.976499]), new Float32Array([-0.97224736, 0.22081333]), new Float32Array([0.8739248, -0.12796174]), new Float32Array([0.19050361, 0.016026154]), new Float32Array([-0.4635344, -0.9524904]), new Float32Array([-0.07064097, -0.94479805]), new Float32Array([-0.92444086, -0.1045759]), new Float32Array([-0.83822596, -0.016950432]), new Float32Array([0.75214684, -0.99955684]), new Float32Array([-0.42102998, 0.9972094]), new Float32Array([-0.72094786, -0.3500896]), new Float32Array([0.78843313, 0.52851397]), new Float32Array([0.97394025, -0.26695943]), new Float32Array([0.99206465, -0.5701012]), new Float32Array([0.7678961, -0.7651936]), new Float32Array([-0.8200242, -0.7353018]), new Float32Array([0.8192499, 0.99698424]), new Float32Array([-0.2671985, 0.6890337]), new Float32Array([-0.4331126, 0.85321814]), new Float32Array([0.9919498, 0.9187625]), new Float32Array([-0.80692, -0.3262754]), new Float32Array([0.43080005, -0.21919096]), new Float32Array([0.67709494, -0.95478076]), new Float32Array([0.5615177, -0.7069381]), new Float32Array([0.10831863, -0.08628837]), new Float32Array([0.91229415, -0.6598735]), new Float32Array([-0.48972893, 0.56289244]), new Float32Array([-0.8903366, -0.71656567]), new Float32Array([0.65269446, 0.6591601]), new Float32Array([0.6743948, -0.8168438]), new Float32Array([-0.4777083, -0.16789556]), new Float32Array([-0.9971598, -0.93565786]), new Float32Array([-0.9088959, 0.620344]), new Float32Array([-0.06618623, -0.23812217]), new Float32Array([0.9943027, 0.18812555]), new Float32Array([0.97686404, -0.28664535]), new Float32Array([0.9481365, -0.9750664]), new Float32Array([-0.954345, -0.7960798]), new Float32Array([-0.49104783, 0.32895213]), new Float32Array([0.9988117, 0.88993984]), new Float32Array([0.5044917, -0.8599507]), new Float32Array([0.4716289, -0.18680204]), new Float32Array([-0.6208158, 0.75000674]), new Float32Array([-0.43867016, 0.9999807]), new Float32Array([0.98630565, -0.535789]), new Float32Array([-0.6151036, -0.8951502]), new Float32Array([-0.038415175, -0.6988882]), new Float32Array([-0.30102158, -0.07667809]), new Float32Array([0.41881284, 0.02188099]), new Float32Array([-0.86135453, 0.98947483]), new Float32Array([0.6722686, -0.13494389]), new Float32Array([-0.707374, -0.7654735]), new Float32Array([0.9404495, 0.09026201]), new Float32Array([-0.8238635, 0.08924769]), new Float32Array([-0.32070667, 0.5014342]), new Float32Array([0.5759316, -0.98966426]), new Float32Array([-0.36326018, 0.07440243]), new Float32Array([0.99979043, -0.14130287]), new Float32Array([-0.9236602, -0.97979295]), new Float32Array([-0.44607177, -0.54233253]), new Float32Array([0.442268, 0.71326756]), new Float32Array([0.036719073, 0.6360639]), new Float32Array([0.52175426, -0.85396826]), new Float32Array([-0.9470114, -0.018263482]), new Float32Array([-0.9875961, 0.8228871]), new Float32Array([0.8743479, 0.8939949]), new Float32Array([-0.9341204, 0.41374052]), new Float32Array([0.9606394, 0.93116707]), new Float32Array([0.9753425, 0.8615093]), new Float32Array([0.9964247, 0.7019004]), new Float32Array([-0.94705087, -0.29580042]), new Float32Array([0.91599804, -0.98147833])];
}, {NOISE_TABLE: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  @author The JCodec project
 */
var VUIParameters = function() {};
VUIParameters = stjs.extend(VUIParameters, null, [], function(constructor, prototype) {
    constructor.BitstreamRestriction = function() {};
    constructor.BitstreamRestriction = stjs.extend(constructor.BitstreamRestriction, null, [], function(constructor, prototype) {
        prototype.motion_vectors_over_pic_boundaries_flag = false;
        prototype.max_bytes_per_pic_denom = 0;
        prototype.max_bits_per_mb_denom = 0;
        prototype.log2_max_mv_length_horizontal = 0;
        prototype.log2_max_mv_length_vertical = 0;
        prototype.num_reorder_frames = 0;
        prototype.max_dec_frame_buffering = 0;
    }, {}, {});
    prototype.aspect_ratio_info_present_flag = false;
    prototype.sar_width = 0;
    prototype.sar_height = 0;
    prototype.overscan_info_present_flag = false;
    prototype.overscan_appropriate_flag = false;
    prototype.video_signal_type_present_flag = false;
    prototype.video_format = 0;
    prototype.video_full_range_flag = false;
    prototype.colour_description_present_flag = false;
    prototype.colour_primaries = 0;
    prototype.transfer_characteristics = 0;
    prototype.matrix_coefficients = 0;
    prototype.chroma_loc_info_present_flag = false;
    prototype.chroma_sample_loc_type_top_field = 0;
    prototype.chroma_sample_loc_type_bottom_field = 0;
    prototype.timing_info_present_flag = false;
    prototype.num_units_in_tick = 0;
    prototype.time_scale = 0;
    prototype.fixed_frame_rate_flag = false;
    prototype.low_delay_hrd_flag = false;
    prototype.pic_struct_present_flag = false;
    prototype.nalHRDParams = null;
    prototype.vclHRDParams = null;
    prototype.bitstreamRestriction = null;
    prototype.aspect_ratio = null;
}, {nalHRDParams: "HRDParameters", vclHRDParams: "HRDParameters", bitstreamRestriction: "VUIParameters.BitstreamRestriction", aspect_ratio: "AspectRatio"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Quarter pixel image interpolator for inter prediction
 *  
 *  @author The JCodec project
 *  
 */
var Interpolator = function() {};
Interpolator = stjs.extend(Interpolator, null, [], function(constructor, prototype) {
    constructor.PADDING = 16;
    prototype.interpolateChroma = function(src, width, height) {
        var refWidth = (width << 3);
        var refHeight = (height << 3);
        var result = new Int32Array(refWidth * refHeight);
        for (var j = 0; j < height; j++) {
            for (var i = 0; i < width; i++) {
                for (var y = 0; y < 8; y++) {
                    for (var x = 0; x < 8; x++) {
                        var resultOff = ((j << 3) + y) * refWidth + (i << 3) + x;
                        var w00 = j * width + i;
                        var w01 = w00 + (j < height - 1 ? width : 0);
                        var w10 = w00 + (i < width - 1 ? 1 : 0);
                        var w11 = w10 + w01 - w00;
                        var eMx = 8 - x;
                        var eMy = 8 - y;
                        result[resultOff] = (eMx * eMy * src[w00] + x * eMy * src[w10] + eMx * y * src[w01] + x * y * src[w11] + 32) >> 6;
                    }
                }
            }
        }
        return result;
    };
    prototype.interpolateLuma = function(src, width, height) {
        var refWidth = (width + Interpolator.PADDING * 2) * 4;
        var refHeight = (height + Interpolator.PADDING * 2) * 4;
        var result = new Int32Array(refWidth * refHeight);
        this.fillFullPel(src, width, height, result);
        this.scanHPelHorizontalWithRound(refWidth, refHeight, result);
        this.scanHPelVertical(refWidth, refHeight, result);
        this.scanHPelCenterWidhRound(refWidth, refHeight, result);
        this.roundHPelVertical(refWidth, refHeight, result);
        this.scanQPel(refWidth, refHeight, result);
        return result;
    };
    prototype.scanQPel = function(width, height, result) {
        for (var j = 0; j < height; j += 2) {
            for (var i = 0; i < width; i += 2) {
                var pos = j * width + i;
                var bottomHpel = j < height - 2 ? result[pos + 2 * width] : result[pos];
                var rightHpel = i < width - 2 ? result[pos + 2] : result[pos];
                var rightBottomHpel;
                if (j < height - 2 && i < width - 2) 
                    rightBottomHpel = result[pos + 2 * width + 2];
                 else if (j < height - 2) 
                    rightBottomHpel = result[pos + 2 * width];
                 else if (i < width - 2) 
                    rightBottomHpel = result[pos + 2];
                 else 
                    rightBottomHpel = result[pos];
                result[pos + width] = (result[pos] + bottomHpel + 1) >> 1;
                result[pos + 1] = (result[pos] + rightHpel + 1) >> 1;
                if ((i % 4) == (j % 4)) {
                    result[pos + width + 1] = (rightHpel + bottomHpel + 1) >> 1;
                } else {
                    result[pos + width + 1] = (result[pos] + rightBottomHpel + 1) >> 1;
                }
            }
        }
    };
    prototype.fillFullPel = function(src, width, height, result) {
        var stride = (width + Interpolator.PADDING * 2) * 4;
        for (var j = 0; j < height; j++) {
            var y = (j + Interpolator.PADDING) * 4;
            for (var i = 0; i < width; i++) {
                var x = (i + Interpolator.PADDING) * 4;
                result[y * stride + x] = src[j * width + i];
            }
            for (var i = 0; i < Interpolator.PADDING; i++) {
                var x = i * 4;
                result[y * stride + x] = src[j * width];
            }
            for (var i = width + Interpolator.PADDING; i < width + Interpolator.PADDING * 2; i++) {
                var x = i * 4;
                result[y * stride + x] = src[j * width + width - 1];
            }
        }
        for (var j = 0; j < Interpolator.PADDING; j++) {
            var y = j * 4;
            for (var i = 0; i < width; i++) {
                var x = (i + Interpolator.PADDING) * 4;
                result[y * stride + x] = src[i];
            }
            for (var i = 0; i < Interpolator.PADDING; i++) {
                var x = i * 4;
                result[y * stride + x] = src[0];
            }
            for (var i = width + Interpolator.PADDING; i < width + Interpolator.PADDING * 2; i++) {
                var x = i * 4;
                result[y * stride + x] = src[width - 1];
            }
        }
        for (var j = height + Interpolator.PADDING; j < height + Interpolator.PADDING * 2; j++) {
            var y = j * 4;
            for (var i = 0; i < width; i++) {
                var x = (i + Interpolator.PADDING) * 4;
                result[y * stride + x] = src[(height - 1) * width + i];
            }
            for (var i = 0; i < Interpolator.PADDING; i++) {
                var x = i * 4;
                result[y * stride + x] = src[(height - 1) * width];
            }
            for (var i = width + Interpolator.PADDING; i < width + Interpolator.PADDING * 2; i++) {
                var x = i * 4;
                result[y * stride + x] = src[(height - 1) * width + width - 1];
            }
        }
    };
    prototype.scanHPelVertical = function(width, height, result) {
        for (var i = 0; i < width; i += 4) {
            var E = result[i];
            var F = result[i];
            var G = result[i];
            var H = result[i + 4 * width];
            var I = result[i + 8 * width];
            var J = result[i + 12 * width];
            for (var j = 0; j < height; j += 4) {
                var val = E - 5 * F + 20 * G + 20 * H - 5 * I + J;
                result[(j + 2) * width + i] = val;
                E = F;
                F = G;
                G = H;
                H = I;
                I = J;
                var nextPix = j + 16;
                if (nextPix < height) {
                    J = result[nextPix * width + i];
                }
            }
        }
    };
    prototype.roundHPelVertical = function(width, height, result) {
        for (var i = 0; i < width; i += 4) {
            for (var j = 0; j < height; j += 4) {
                result[(j + 2) * width + i] = this.roundAndClip32(result[(j + 2) * width + i]);
            }
        }
    };
    prototype.scanHPelHorizontalWithRound = function(width, height, result) {
        for (var j = 0; j < height; j += 4) {
            var lineStart = j * width;
            var E = result[lineStart];
            var F = result[lineStart];
            var G = result[lineStart];
            var H = result[lineStart + 4];
            var I = result[lineStart + 8];
            var J = result[lineStart + 12];
            for (var i = 0; i < width; i += 4) {
                var val = E - 5 * F + 20 * G + 20 * H - 5 * I + J;
                result[lineStart + i + 2] = this.roundAndClip32(val);
                E = F;
                F = G;
                G = H;
                H = I;
                I = J;
                var nextPix = i + 16;
                if (nextPix < width) {
                    J = result[lineStart + nextPix];
                }
            }
        }
    };
    prototype.scanHPelCenterWidhRound = function(width, height, result) {
        for (var j = 0; j < height; j += 4) {
            var lineStart = (j + 2) * width;
            var E = result[lineStart];
            var F = result[lineStart];
            var G = result[lineStart];
            var H = result[lineStart + 4];
            var I = result[lineStart + 8];
            var J = result[lineStart + 12];
            for (var i = 0; i < width; i += 4) {
                var val = E - 5 * F + 20 * G + 20 * H - 5 * I + J;
                result[lineStart + i + 2] = this.roundAndClip1024(val);
                E = F;
                F = G;
                G = H;
                H = I;
                I = J;
                var nextPix = i + 16;
                if (nextPix < width) {
                    J = result[lineStart + nextPix];
                }
            }
        }
    };
    prototype.roundAndClip32 = function(val) {
        val = (val + 16) >> 5;
        val = val < 0 ? 0 : (val > 255 ? 255 : val);
        return val;
    };
    prototype.roundAndClip1024 = function(val) {
        val = (val + 512) >> 10;
        val = val < 0 ? 0 : (val > 255 ? 255 : val);
        return val;
    };
}, {}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  @author in-somnia
 */
var IMDCTTables = function() {};
IMDCTTables = stjs.extend(IMDCTTables, null, [], function(constructor, prototype) {
    constructor.IMDCT_TABLE_256 = [new Float32Array([1.0, -0.0]), new Float32Array([0.9996988, -0.024541229]), new Float32Array([0.99879545, -0.049067676]), new Float32Array([0.99729043, -0.07356457]), new Float32Array([0.9951847, -0.09801714]), new Float32Array([0.99247956, -0.12241068]), new Float32Array([0.9891765, -0.14673047]), new Float32Array([0.98527765, -0.1709619]), new Float32Array([0.98078525, -0.19509032]), new Float32Array([0.9757021, -0.21910124]), new Float32Array([0.97003126, -0.2429802]), new Float32Array([0.96377605, -0.26671278]), new Float32Array([0.95694035, -0.29028466]), new Float32Array([0.94952816, -0.31368175]), new Float32Array([0.94154406, -0.33688986]), new Float32Array([0.9329928, -0.35989505]), new Float32Array([0.9238795, -0.38268346]), new Float32Array([0.9142097, -0.40524134]), new Float32Array([0.9039893, -0.42755508]), new Float32Array([0.8932243, -0.44961134]), new Float32Array([0.88192123, -0.47139674]), new Float32Array([0.87008697, -0.49289823]), new Float32Array([0.8577286, -0.51410276]), new Float32Array([0.8448536, -0.53499764]), new Float32Array([0.8314696, -0.55557024]), new Float32Array([0.8175848, -0.5758082]), new Float32Array([0.8032075, -0.5956993]), new Float32Array([0.7883464, -0.61523163]), new Float32Array([0.77301043, -0.63439333]), new Float32Array([0.7572088, -0.65317285]), new Float32Array([0.7409511, -0.671559]), new Float32Array([0.7242471, -0.68954057]), new Float32Array([0.70710677, -0.70710677]), new Float32Array([0.6895405, -0.7242471]), new Float32Array([0.6715589, -0.7409512]), new Float32Array([0.6531728, -0.7572089]), new Float32Array([0.6343933, -0.77301043]), new Float32Array([0.6152316, -0.7883464]), new Float32Array([0.5956993, -0.8032075]), new Float32Array([0.57580817, -0.8175848]), new Float32Array([0.5555702, -0.83146966]), new Float32Array([0.53499764, -0.8448536]), new Float32Array([0.5141027, -0.85772866]), new Float32Array([0.4928982, -0.87008697]), new Float32Array([0.47139665, -0.8819213]), new Float32Array([0.4496113, -0.8932243]), new Float32Array([0.4275551, -0.9039893]), new Float32Array([0.40524128, -0.9142098]), new Float32Array([0.38268343, -0.9238795]), new Float32Array([0.35989496, -0.9329928]), new Float32Array([0.33688983, -0.94154406]), new Float32Array([0.31368166, -0.9495282]), new Float32Array([0.29028463, -0.95694035]), new Float32Array([0.26671275, -0.96377605]), new Float32Array([0.24298012, -0.97003126]), new Float32Array([0.21910122, -0.9757021]), new Float32Array([0.19509023, -0.9807853]), new Float32Array([0.17096186, -0.98527765]), new Float32Array([0.1467305, -0.9891765]), new Float32Array([0.122410625, -0.99247956]), new Float32Array([0.098017134, -0.9951847]), new Float32Array([0.07356449, -0.99729043]), new Float32Array([0.04906765, -0.99879545]), new Float32Array([0.024541136, -0.9996988]), new Float32Array([-4.371139E-8, -1.0]), new Float32Array([-0.024541223, -0.9996988]), new Float32Array([-0.04906774, -0.99879545]), new Float32Array([-0.073564574, -0.99729043]), new Float32Array([-0.09801722, -0.9951847]), new Float32Array([-0.12241071, -0.9924795]), new Float32Array([-0.14673057, -0.9891765]), new Float32Array([-0.17096195, -0.98527765]), new Float32Array([-0.19509032, -0.98078525]), new Float32Array([-0.21910131, -0.9757021]), new Float32Array([-0.2429802, -0.97003126]), new Float32Array([-0.26671284, -0.96377605]), new Float32Array([-0.29028472, -0.9569403]), new Float32Array([-0.31368172, -0.94952816]), new Float32Array([-0.33688992, -0.94154406]), new Float32Array([-0.35989505, -0.9329928]), new Float32Array([-0.38268352, -0.9238795]), new Float32Array([-0.40524134, -0.9142097]), new Float32Array([-0.42755508, -0.9039893]), new Float32Array([-0.44961137, -0.8932243]), new Float32Array([-0.47139683, -0.88192123]), new Float32Array([-0.49289817, -0.870087]), new Float32Array([-0.51410276, -0.8577286]), new Float32Array([-0.5349977, -0.8448535]), new Float32Array([-0.55557036, -0.83146954]), new Float32Array([-0.57580817, -0.8175848]), new Float32Array([-0.59569937, -0.8032075]), new Float32Array([-0.6152317, -0.78834635]), new Float32Array([-0.6343933, -0.7730105]), new Float32Array([-0.65317285, -0.7572088]), new Float32Array([-0.67155904, -0.74095106]), new Float32Array([-0.6895407, -0.724247]), new Float32Array([-0.70710677, -0.70710677]), new Float32Array([-0.72424716, -0.6895405]), new Float32Array([-0.74095124, -0.67155886]), new Float32Array([-0.7572088, -0.65317285]), new Float32Array([-0.7730105, -0.6343933]), new Float32Array([-0.78834647, -0.6152315]), new Float32Array([-0.80320764, -0.59569913]), new Float32Array([-0.8175848, -0.57580817]), new Float32Array([-0.83146966, -0.5555702]), new Float32Array([-0.84485364, -0.53499746]), new Float32Array([-0.8577286, -0.51410276]), new Float32Array([-0.870087, -0.49289814]), new Float32Array([-0.88192135, -0.47139663]), new Float32Array([-0.8932243, -0.44961137]), new Float32Array([-0.9039893, -0.42755505]), new Float32Array([-0.9142098, -0.40524122]), new Float32Array([-0.9238796, -0.38268328]), new Float32Array([-0.9329928, -0.35989505]), new Float32Array([-0.9415441, -0.3368898]), new Float32Array([-0.9495282, -0.3136816]), new Float32Array([-0.95694035, -0.29028472]), new Float32Array([-0.96377605, -0.26671273]), new Float32Array([-0.97003126, -0.24298008]), new Float32Array([-0.97570217, -0.21910107]), new Float32Array([-0.9807853, -0.19509031]), new Float32Array([-0.98527765, -0.17096181]), new Float32Array([-0.9891765, -0.14673033]), new Float32Array([-0.9924795, -0.1224107]), new Float32Array([-0.9951847, -0.0980171]), new Float32Array([-0.9972905, -0.07356445]), new Float32Array([-0.99879545, -0.049067486]), new Float32Array([-0.9996988, -0.02454121])];
    constructor.IMDCT_TABLE_32 = [new Float32Array([1.0, -0.0]), new Float32Array([0.98078525, -0.19509032]), new Float32Array([0.9238795, -0.38268346]), new Float32Array([0.8314696, -0.55557024]), new Float32Array([0.70710677, -0.70710677]), new Float32Array([0.5555702, -0.83146966]), new Float32Array([0.38268343, -0.9238795]), new Float32Array([0.19509023, -0.9807853]), new Float32Array([-4.371139E-8, -1.0]), new Float32Array([-0.19509032, -0.98078525]), new Float32Array([-0.38268352, -0.9238795]), new Float32Array([-0.55557036, -0.83146954]), new Float32Array([-0.70710677, -0.70710677]), new Float32Array([-0.83146966, -0.5555702]), new Float32Array([-0.9238796, -0.38268328]), new Float32Array([-0.9807853, -0.19509031])];
    constructor.IMDCT_POST_TABLE_256 = [new Float32Array([0.49232805, 0.50766724, 0.50147516, 0.49840719]), new Float32Array([0.47697723, 0.5229804, 0.50407255, 0.4948688]), new Float32Array([0.46162924, 0.5382531, 0.50619966, 0.49086043]), new Float32Array([0.44629848, 0.5534709, 0.50785726, 0.4863832]), new Float32Array([0.43099934, 0.5686195, 0.5090466, 0.48143846]), new Float32Array([0.41574615, 0.58368444, 0.5097693, 0.47602817]), new Float32Array([0.40055317, 0.5986516, 0.5100275, 0.47015458]), new Float32Array([0.38543463, 0.6135067, 0.50982374, 0.46382055]), new Float32Array([0.37040454, 0.6282357, 0.5091608, 0.45702913]), new Float32Array([0.35547704, 0.64282453, 0.50804234, 0.4497841]), new Float32Array([0.34066594, 0.65725935, 0.506472, 0.44208938]), new Float32Array([0.32598507, 0.6715264, 0.5044541, 0.43394947]), new Float32Array([0.31144798, 0.6856121, 0.5019932, 0.42536932]), new Float32Array([0.29706824, 0.6995029, 0.4990945, 0.41635424]), new Float32Array([0.2828591, 0.7131856, 0.49576342, 0.40690988]), new Float32Array([0.26883373, 0.726647, 0.4920059, 0.39704242]), new Float32Array([0.25500503, 0.73987424, 0.48782825, 0.3867584]), new Float32Array([0.24138579, 0.7528547, 0.48323712, 0.3760647]), new Float32Array([0.22798851, 0.76557565, 0.4782396, 0.36496866]), new Float32Array([0.21482554, 0.7780249, 0.47284314, 0.35347793]), new Float32Array([0.20190886, 0.79019046, 0.46705556, 0.3416006]), new Float32Array([0.18925038, 0.8020605, 0.4608851, 0.3293451]), new Float32Array([0.17686158, 0.8136235, 0.45434028, 0.3167202]), new Float32Array([0.16475382, 0.8248682, 0.44743007, 0.30373502]), new Float32Array([0.15293804, 0.8357836, 0.44016364, 0.2903991]), new Float32Array([0.14142501, 0.84635913, 0.4325506, 0.2767222]), new Float32Array([0.13022512, 0.85658425, 0.42460087, 0.26271448]), new Float32Array([0.11934847, 0.86644906, 0.41632465, 0.24838635]), new Float32Array([0.10880476, 0.8759437, 0.40773243, 0.23374856]), new Float32Array([0.09860358, 0.8850589, 0.39883506, 0.21881217]), new Float32Array([0.08875397, 0.89378536, 0.38964373, 0.20358856]), new Float32Array([0.0792647, 0.9021145, 0.38016963, 0.18808924]), new Float32Array([0.07014418, 0.91003793, 0.37042463, 0.1723262]), new Float32Array([0.061400414, 0.91754776, 0.36042035, 0.1563114]), new Float32Array([0.05304113, 0.92463624, 0.35016915, 0.14005733]), new Float32Array([0.0450736, 0.9312961, 0.3396833, 0.12357649]), new Float32Array([0.037504703, 0.9375206, 0.32897532, 0.106881686]), new Float32Array([0.03034103, 0.9433032, 0.3180581, 0.08998602]), new Float32Array([0.023588628, 0.94863784, 0.30694458, 0.07290262]), new Float32Array([0.01725325, 0.95351887, 0.29564792, 0.055644885]), new Float32Array([0.011340171, 0.95794106, 0.28418133, 0.038226277]), new Float32Array([0.005854279, 0.9618995, 0.27255845, 0.020660654]), new Float32Array([8.0010295E-4, 0.96538985, 0.26079288, 0.0029617846]), new Float32Array([-0.003818363, 0.9684081, 0.24889828, -0.014856413]), new Float32Array([-0.007997453, 0.9709507, 0.23688862, -0.0327797]), new Float32Array([-0.011734039, 0.9730145, 0.22477779, -0.050794043]), new Float32Array([-0.015025228, 0.97459674, 0.21258, -0.06888495]), new Float32Array([-0.017868847, 0.97569525, 0.20030917, -0.08703829]), new Float32Array([-0.020262927, 0.9763082, 0.1879797, -0.10523948]), new Float32Array([-0.022206068, 0.9764342, 0.17560576, -0.12347408]), new Float32Array([-0.023697197, 0.9760722, 0.16320162, -0.14172764]), new Float32Array([-0.024735779, 0.9752219, 0.15078172, -0.15998542]), new Float32Array([-0.025321692, 0.97388303, 0.13836022, -0.17823319]), new Float32Array([-0.025455266, 0.97205615, 0.12595156, -0.19645613]), new Float32Array([-0.025137246, 0.96974206, 0.113570005, -0.21463984]), new Float32Array([-0.024368823, 0.966942, 0.10122979, -0.23276988]), new Float32Array([-0.023151666, 0.96365774, 0.088945225, -0.25083166]), new Float32Array([-0.021487802, 0.9598913, 0.07673041, -0.26881093]), new Float32Array([-0.019379854, 0.9556455, 0.06459953, -0.28669322]), new Float32Array([-0.016830623, 0.95092314, 0.0525665, -0.3044645]), new Float32Array([-0.013843596, 0.9457279, 0.04064539, -0.32211035]), new Float32Array([-0.010422587, 0.9400635, 0.02884984, -0.33961698]), new Float32Array([-0.0065717697, 0.9339343, 0.017193556, -0.35697052]), new Float32Array([-0.002295822, 0.92734504, 0.0056901723, -0.374157]), new Float32Array([0.0024001896, 0.92030096, -0.0056470186, -0.3911631]), new Float32Array([0.0075107515, 0.91280746, -0.016804636, -0.40797502]), new Float32Array([0.013030022, 0.90487075, -0.027769819, -0.4245798]), new Float32Array([0.018951744, 0.896497, -0.038529605, -0.44096428]), new Float32Array([0.025269121, 0.88769305, -0.049071252, -0.4571154]), new Float32Array([0.03197518, 0.8784661, -0.059382424, -0.47302073]), new Float32Array([0.03906241, 0.86882365, -0.06945078, -0.48866767]), new Float32Array([0.046523094, 0.85877365, -0.07926449, -0.5040442]), new Float32Array([0.054348946, 0.84832436, -0.08881168, -0.51913816]), new Float32Array([0.06253144, 0.8374845, -0.09808087, -0.533938]), new Float32Array([0.07106161, 0.82626295, -0.107060805, -0.5484321]), new Float32Array([0.079930276, 0.81466925, -0.11574057, -0.56260943]), new Float32Array([0.0891279, 0.8027128, -0.124109596, -0.57645917]), new Float32Array([0.098644555, 0.7904038, -0.13215744, -0.58997077]), new Float32Array([0.10847002, 0.7777525, -0.13987413, -0.6031339]), new Float32Array([0.11859363, 0.7647697, -0.14724979, -0.61593866]), new Float32Array([0.12900484, 0.75146604, -0.15427522, -0.6283754]), new Float32Array([0.13969228, 0.73785305, -0.16094121, -0.640435]), new Float32Array([0.15064475, 0.7239419, -0.16723916, -0.65210843]), new Float32Array([0.16185057, 0.7097445, -0.17316064, -0.6633872]), new Float32Array([0.1732978, 0.6952729, -0.1786977, -0.674263]), new Float32Array([0.18497421, 0.6805394, -0.18384269, -0.684728]), new Float32Array([0.19686763, 0.6655563, -0.18858838, -0.69477504]), new Float32Array([0.20896536, 0.65033644, -0.1929279, -0.7043968]), new Float32Array([0.22125456, 0.6348928, -0.19685477, -0.71358657]), new Float32Array([0.23372234, 0.61923826, -0.20036295, -0.7223382]), new Float32Array([0.24635552, 0.6033862, -0.20344675, -0.7306459]), new Float32Array([0.2591407, 0.58735025, -0.20610088, -0.73850405]), new Float32Array([0.27206418, 0.5711441, -0.2083205, -0.7459076]), new Float32Array([0.28511274, 0.554781, -0.21010125, -0.752852]), new Float32Array([0.2982724, 0.5382753, -0.21143904, -0.75933313]), new Float32Array([0.31152916, 0.521641, -0.21233031, -0.765347]), new Float32Array([0.3248692, 0.50489205, -0.21277195, -0.7708905]), new Float32Array([0.33827832, 0.48804274, -0.2127612, -0.77596056]), new Float32Array([0.3517424, 0.47110736, -0.21229571, -0.7805547]), new Float32Array([0.365247, 0.4541005, -0.21137378, -0.78467095]), new Float32Array([0.37877813, 0.43703625, -0.20999387, -0.78830767]), new Float32Array([0.39232132, 0.41992924, -0.20815507, -0.79146373]), new Float32Array([0.40586197, 0.40279418, -0.20585686, -0.79413843]), new Float32Array([0.4193862, 0.3856451, -0.20309913, -0.79633147]), new Float32Array([0.43287942, 0.36849675, -0.19988227, -0.798043]), new Float32Array([0.4463272, 0.3513636, -0.19620705, -0.79927367]), new Float32Array([0.45971522, 0.33426026, -0.19207478, -0.80002457]), new Float32Array([0.47302932, 0.3172009, -0.18748704, -0.80029714]), new Float32Array([0.48625526, 0.30019996, -0.18244597, -0.8000933]), new Float32Array([0.49937868, 0.2832719, -0.17695424, -0.79941547]), new Float32Array([0.51238585, 0.2664307, -0.1710147, -0.79826653]), new Float32Array([0.52526253, 0.24969055, -0.16463086, -0.7966496]), new Float32Array([0.53799486, 0.23306563, -0.15780658, -0.7945684]), new Float32Array([0.5505693, 0.21656957, -0.15054607, -0.7920271]), new Float32Array([0.5629722, 0.20021626, -0.14285406, -0.7890301]), new Float32Array([0.5751899, 0.18401925, -0.13473573, -0.7855824]), new Float32Array([0.5872092, 0.1679922, -0.12619662, -0.78168947]), new Float32Array([0.599017, 0.15214804, -0.117242515, -0.77735686]), new Float32Array([0.61060053, 0.13650006, -0.10787988, -0.7725909]), new Float32Array([0.62194663, 0.121061325, -0.09811556, -0.7673981]), new Float32Array([0.6330432, 0.10584408, -0.08795637, -0.7617854]), new Float32Array([0.64387786, 0.09086105, -0.07741001, -0.7557601]), new Float32Array([0.6544384, 0.0761244, -0.06648436, -0.7493299]), new Float32Array([0.6647129, 0.061646253, -0.055187732, -0.74250305]), new Float32Array([0.67469, 0.047438115, -0.043528587, -0.7352879]), new Float32Array([0.6843584, 0.03351158, -0.031515926, -0.7276931]), new Float32Array([0.693707, 0.01987794, -0.019159257, -0.71972805]), new Float32Array([0.70272505, 0.006547779, -0.0064679384, -0.711402])];
    constructor.IMDCT_POST_TABLE_32 = [new Float32Array([0.43864408, 0.56105477, 0.5085104, 0.48396915]), new Float32Array([0.3186977, 0.67859274, 0.5032787, 0.4297141]), new Float32Array([0.20833567, 0.7841439, 0.46999773, 0.34758708]), new Float32Array([0.114034384, 0.87124324, 0.41206735, 0.24110544]), new Float32Array([0.041238904, 0.9344632, 0.33435628, 0.115255035]), new Float32Array([-0.0059630573, 0.9697391, 0.24290696, -0.023805834]), new Float32Array([-0.02508533, 0.9746135, 0.14457026, -0.16911149]), new Float32Array([-0.015391618, 0.9483844, 0.046591163, -0.3133039]), new Float32Array([0.022061408, 0.8921483, -0.043828517, -0.44906986]), new Float32Array([0.0844886, 0.8087357, -0.119964585, -0.5695759]), new Float32Array([0.16754475, 0.7025422, -0.1759777, -0.66887593]), new Float32Array([0.26558587, 0.57926774, -0.20726526, -0.7422629]), new Float32Array([0.37201017, 0.44557464, -0.21074113, -0.7865493]), new Float32Array([0.4796542, 0.30869222, -0.18502301, -0.80025464]), new Float32Array([0.5812251, 0.17598371, -0.13051844, -0.7836913]), new Float32Array([0.66973937, 0.054507732, -0.049402922, -0.73894346])];
}, {IMDCT_TABLE_256: "Array", IMDCT_TABLE_32: "Array", IMDCT_POST_TABLE_256: "Array", IMDCT_POST_TABLE_32: "Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 * 
 *  @author in-somnia
 */
var PQFTables = function() {};
PQFTables = stjs.extend(PQFTables, null, [], function(constructor, prototype) {
    constructor.PROTO_TABLE = new Float32Array([1.2206911E-5, 1.7261988E-5, 1.2300094E-5, -1.0833943E-5, -5.77725E-5, -1.2764768E-4, -2.0965187E-4, -2.8166673E-4, -3.123486E-4, -2.673852E-4, -1.19494245E-4, 1.396514E-4, 4.886414E-4, 8.7044627E-4, 0.001194943, 0.0013519708, 0.0012346314, 7.695321E-4, -5.2242434E-5, -0.0011516092, -0.002353847, -0.0034033123, -0.004002855, -0.0038745415, -0.0028321072, -8.503889E-4, 0.0018856751, 0.004968874, 0.0078056706, 0.0097027905, 0.009996043, 0.008201936, 0.0041642073, -0.0018364454, -0.0090384865, -0.016241528, -0.021939551, -0.02453318, -0.022591664, -0.015122066, -0.0017971713, 0.016903413, 0.039672315, 0.064487524, 0.08885003, 0.11011329, 0.12585402, 0.13422394, 0.13422394, 0.12585402, 0.11011329, 0.08885003, 0.064487524, 0.039672315, 0.016903413, -0.0017971713, -0.015122066, -0.022591664, -0.02453318, -0.021939551, -0.016241528, -0.0090384865, -0.0018364454, 0.0041642073, 0.008201936, 0.009996043, 0.0097027905, 0.0078056706, 0.004968874, 0.0018856751, -8.503889E-4, -0.0028321072, -0.0038745415, -0.004002855, -0.0034033123, -0.002353847, -0.0011516092, -5.2242434E-5, 7.695321E-4, 0.0012346314, 0.0013519708, 0.001194943, 8.7044627E-4, 4.886414E-4, 1.396514E-4, -1.19494245E-4, -2.673852E-4, -3.123486E-4, -2.8166673E-4, -2.0965187E-4, -1.2764768E-4, -5.77725E-5, -1.0833943E-5, 1.2300094E-5, 1.7261988E-5, 1.2206911E-5]);
    constructor.COEFS_Q0 = [new Float32Array([1.6629392, -0.39018065, -1.9615706, -1.11114]), new Float32Array([1.9615705, 1.6629392, 1.1111404, 0.39018047]), new Float32Array([1.9615705, 1.6629392, 1.1111404, 0.39018047]), new Float32Array([1.6629392, -0.39018065, -1.9615706, -1.11114])];
    constructor.COEFS_Q1 = [new Float32Array([1.1111404, -1.9615706, 0.39018083, 1.6629387]), new Float32Array([0.39018047, -1.11114, 1.6629387, -1.9615704]), new Float32Array([-0.39018065, 1.1111408, -1.6629395, 1.9615709]), new Float32Array([-1.1111407, 1.9615705, -0.39018044, -1.6629392])];
    constructor.COEFS_T0 = [new Float32Array([4.8827646E-5, 0.0012493944, 0.0049385256, 0.011328429, 0.016656829, 0.0071886852, 0.53689575, 0.060488265, 0.032807745, 0.015498166, 0.0054078833, 0.0011266669]), new Float32Array([6.904795E-5, 0.0010695409, 0.0030781284, 0.0034015556, -0.0073457817, -0.067613654, 0.50341606, 0.090366654, 0.03998417, 0.01601142, 0.004779772, 8.386075E-4]), new Float32Array([4.9200375E-5, 4.7797698E-4, -2.0896974E-4, -0.0075427005, -0.036153946, -0.15868926, 0.44045317, 0.09813272, 0.038811162, 0.013613249, 0.003481785, 5.1059073E-4]), new Float32Array([-4.333577E-5, -5.586056E-4, -0.004606437, -0.019875497, -0.06496611, -0.2579501, 0.35540012, 0.087758206, 0.031222682, 0.009415388, 0.0019545655, 2.3109E-4])];
    constructor.COEFS_T1 = [new Float32Array([-2.3109E-4, -0.0019545655, -0.009415388, -0.031222682, -0.087758206, -0.35540012, 0.2579501, 0.06496611, 0.019875497, 0.004606437, 5.586056E-4, 4.333577E-5]), new Float32Array([-5.1059073E-4, -0.003481785, -0.013613249, -0.038811162, -0.09813272, -0.44045317, 0.15868926, 0.036153946, 0.0075427005, 2.0896974E-4, -4.7797698E-4, -4.9200375E-5]), new Float32Array([-8.386075E-4, -0.004779772, -0.01601142, -0.03998417, -0.090366654, -0.50341606, 0.067613654, 0.0073457817, -0.0034015556, -0.0030781284, -0.0010695409, -6.904795E-5]), new Float32Array([-0.0011266669, -0.0054078833, -0.015498166, -0.032807745, -0.060488265, -0.53689575, -0.0071886852, -0.016656829, -0.011328429, -0.0049385256, -0.0012493944, -4.8827646E-5])];
}, {PROTO_TABLE: "Float32Array", COEFS_Q0: "Array", COEFS_Q1: "Array", COEFS_T0: "Array", COEFS_T1: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var VPXDCT = function() {};
VPXDCT = stjs.extend(VPXDCT, null, [], function(constructor, prototype) {
    constructor.fdct4x4 = function(coef) {
        for (var i = 0; i < 16; i += 4) {
            var a1 = ((coef[i] + coef[i + 3]) << 3);
            var b1 = ((coef[i + 1] + coef[i + 2]) << 3);
            var c1 = ((coef[i + 1] - coef[i + 2]) << 3);
            var d1 = ((coef[i] - coef[i + 3]) << 3);
            coef[i] = a1 + b1;
            coef[i + 2] = a1 - b1;
            coef[i + 1] = (c1 * 2217 + d1 * 5352 + 14500) >> 12;
            coef[i + 3] = (d1 * 2217 - c1 * 5352 + 7500) >> 12;
        }
        for (var i = 0; i < 4; i++) {
            var a1 = coef[i] + coef[i + 12];
            var b1 = coef[i + 4] + coef[i + 8];
            var c1 = coef[i + 4] - coef[i + 8];
            var d1 = coef[i] - coef[i + 12];
            coef[i] = (a1 + b1 + 7) >> 4;
            coef[i + 8] = (a1 - b1 + 7) >> 4;
            coef[i + 4] = ((c1 * 2217 + d1 * 5352 + 12000) >> 16) + (d1 != 0 ? 1 : 0);
            coef[i + 12] = (d1 * 2217 - c1 * 5352 + 51000) >> 16;
        }
    };
    constructor.walsh4x4 = function(coef) {
        for (var i = 0; i < 16; i += 4) {
            var a1 = ((coef[i] + coef[i + 2]) << 2);
            var d1 = ((coef[i + 1] + coef[i + 3]) << 2);
            var c1 = ((coef[i + 1] - coef[i + 3]) << 2);
            var b1 = ((coef[i] - coef[i + 2]) << 2);
            coef[i] = a1 + d1 + (a1 != 0 ? 1 : 0);
            coef[i + 1] = b1 + c1;
            coef[i + 2] = b1 - c1;
            coef[i + 3] = a1 - d1;
        }
        for (var i = 0; i < 4; i++) {
            var a1 = coef[i] + coef[i + 8];
            var d1 = coef[i + 4] + coef[i + 12];
            var c1 = coef[i + 4] - coef[i + 12];
            var b1 = coef[i] - coef[i + 8];
            var a2 = a1 + d1;
            var b2 = b1 + c1;
            var c2 = b1 - c1;
            var d2 = a1 - d1;
            a2 += a2 < 0 ? 1 : 0;
            b2 += b2 < 0 ? 1 : 0;
            c2 += c2 < 0 ? 1 : 0;
            d2 += d2 < 0 ? 1 : 0;
            coef[i] = (a2 + 3) >> 3;
            coef[i + 4] = (b2 + 3) >> 3;
            coef[i + 8] = (c2 + 3) >> 3;
            coef[i + 12] = (d2 + 3) >> 3;
        }
    };
    constructor.cospi8sqrt2minus1 = 20091;
    constructor.sinpi8sqrt2 = 35468;
    constructor.idct4x4 = function(coef) {
        for (var i = 0; i < 4; i++) {
            var a1 = coef[i] + coef[i + 8];
            var b1 = coef[i] - coef[i + 8];
            var temp1 = (coef[i + 4] * VPXDCT.sinpi8sqrt2) >> 16;
            var temp2 = coef[i + 12] + ((coef[i + 12] * VPXDCT.cospi8sqrt2minus1) >> 16);
            var c1 = temp1 - temp2;
            temp1 = coef[i + 4] + ((coef[i + 4] * VPXDCT.cospi8sqrt2minus1) >> 16);
            temp2 = (coef[i + 12] * VPXDCT.sinpi8sqrt2) >> 16;
            var d1 = temp1 + temp2;
            coef[i] = a1 + d1;
            coef[i + 12] = a1 - d1;
            coef[i + 4] = b1 + c1;
            coef[i + 8] = b1 - c1;
        }
        for (var i = 0; i < 16; i += 4) {
            var a1 = coef[i] + coef[i + 2];
            var b1 = coef[i] - coef[i + 2];
            var temp1 = (coef[i + 1] * VPXDCT.sinpi8sqrt2) >> 16;
            var temp2 = coef[i + 3] + ((coef[i + 3] * VPXDCT.cospi8sqrt2minus1) >> 16);
            var c1 = temp1 - temp2;
            temp1 = coef[i + 1] + ((coef[i + 1] * VPXDCT.cospi8sqrt2minus1) >> 16);
            temp2 = (coef[i + 3] * VPXDCT.sinpi8sqrt2) >> 16;
            var d1 = temp1 + temp2;
            coef[i] = (a1 + d1 + 4) >> 3;
            coef[i + 3] = (a1 - d1 + 4) >> 3;
            coef[i + 1] = (b1 + c1 + 4) >> 3;
            coef[i + 2] = (b1 - c1 + 4) >> 3;
        }
    };
    constructor.iwalsh4x4 = function(coef) {
        for (var i = 0; i < 4; i++) {
            var a1 = coef[i] + coef[i + 12];
            var b1 = coef[i + 4] + coef[i + 8];
            var c1 = coef[i + 4] - coef[i + 8];
            var d1 = coef[i] - coef[i + 12];
            coef[i] = a1 + b1;
            coef[i + 4] = c1 + d1;
            coef[i + 8] = a1 - b1;
            coef[i + 12] = d1 - c1;
        }
        for (var i = 0; i < 16; i += 4) {
            var a1 = coef[i] + coef[i + 3];
            var b1 = coef[i + 1] + coef[i + 2];
            var c1 = coef[i + 1] - coef[i + 2];
            var d1 = coef[i] - coef[i + 3];
            var a2 = a1 + b1;
            var b2 = c1 + d1;
            var c2 = a1 - b1;
            var d2 = d1 - c1;
            coef[i] = (a2 + 3) >> 3;
            coef[i + 1] = (b2 + 3) >> 3;
            coef[i + 2] = (c2 + 3) >> 3;
            coef[i + 3] = (d2 + 3) >> 3;
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var WriterLE = function() {};
WriterLE = stjs.extend(WriterLE, null, [], function(constructor, prototype) {
    constructor.writeShort = function(out, s) {
        out.write(s & 255);
        out.write((s >> 8) & 255);
    };
    constructor.writeInt = function(out, i) {
        out.write(i & 255);
        out.write((i >> 8) & 255);
        out.write((i >> 16) & 255);
        out.write((i >> 24) & 255);
    };
    constructor.writeLong = function(out, l) {
        out.write((((l & 255)) | 0));
        out.write(((((l >> 8) & 255)) | 0));
        out.write(((((l >> 16) & 255)) | 0));
        out.write(((((l >> 24) & 255)) | 0));
        out.write(((((l >> 32) & 255)) | 0));
        out.write(((((l >> 40) & 255)) | 0));
        out.write(((((l >> 48) & 255)) | 0));
        out.write(((((l >> 56) & 255)) | 0));
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var RawDataBlockType = stjs.enumeration("TYPE_SCE", "TYPE_CPE", "TYPE_CCE", "TYPE_LFE", "TYPE_DSE", "TYPE_PCE", "TYPE_FIL", "TYPE_END");
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var ChannelUtils = function() {};
ChannelUtils = stjs.extend(ChannelUtils, null, [], null, {}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 * 
 *  @author in-somnia
 */
var FFT = function() {};
FFT = stjs.extend(FFT, null, [], function(constructor, prototype) {
    constructor.FFT_TABLE_128 = [new Float32Array([1.0, -0.0]), new Float32Array([0.99879545, -0.049067676]), new Float32Array([0.9951847, -0.09801714]), new Float32Array([0.9891765, -0.14673047]), new Float32Array([0.98078525, -0.19509032]), new Float32Array([0.97003126, -0.24298018]), new Float32Array([0.95694035, -0.29028466]), new Float32Array([0.94154406, -0.33688986]), new Float32Array([0.9238795, -0.38268343]), new Float32Array([0.9039893, -0.42755508]), new Float32Array([0.8819213, -0.47139674]), new Float32Array([0.8577286, -0.51410276]), new Float32Array([0.8314696, -0.55557024]), new Float32Array([0.8032075, -0.5956993]), new Float32Array([0.77301043, -0.6343933]), new Float32Array([0.7409511, -0.671559]), new Float32Array([0.70710677, -0.70710677]), new Float32Array([0.671559, -0.7409511]), new Float32Array([0.6343933, -0.77301043]), new Float32Array([0.5956993, -0.8032075]), new Float32Array([0.55557024, -0.8314696]), new Float32Array([0.51410276, -0.8577286]), new Float32Array([0.47139674, -0.8819213]), new Float32Array([0.42755508, -0.9039893]), new Float32Array([0.38268343, -0.9238795]), new Float32Array([0.33688986, -0.94154406]), new Float32Array([0.29028466, -0.95694035]), new Float32Array([0.24298018, -0.97003126]), new Float32Array([0.19509032, -0.98078525]), new Float32Array([0.14673047, -0.9891765]), new Float32Array([0.09801714, -0.9951847]), new Float32Array([0.049067676, -0.99879545]), new Float32Array([6.123234E-17, -1.0]), new Float32Array([-0.049067676, -0.99879545]), new Float32Array([-0.09801714, -0.9951847]), new Float32Array([-0.14673047, -0.9891765]), new Float32Array([-0.19509032, -0.98078525]), new Float32Array([-0.24298018, -0.97003126]), new Float32Array([-0.29028466, -0.95694035]), new Float32Array([-0.33688986, -0.94154406]), new Float32Array([-0.38268343, -0.9238795]), new Float32Array([-0.42755508, -0.9039893]), new Float32Array([-0.47139674, -0.8819213]), new Float32Array([-0.51410276, -0.8577286]), new Float32Array([-0.55557024, -0.8314696]), new Float32Array([-0.5956993, -0.8032075]), new Float32Array([-0.6343933, -0.77301043]), new Float32Array([-0.671559, -0.7409511]), new Float32Array([-0.70710677, -0.70710677]), new Float32Array([-0.7409511, -0.671559]), new Float32Array([-0.77301043, -0.6343933]), new Float32Array([-0.8032075, -0.5956993]), new Float32Array([-0.8314696, -0.55557024]), new Float32Array([-0.8577286, -0.51410276]), new Float32Array([-0.8819213, -0.47139674]), new Float32Array([-0.9039893, -0.42755508]), new Float32Array([-0.9238795, -0.38268343]), new Float32Array([-0.94154406, -0.33688986]), new Float32Array([-0.95694035, -0.29028466]), new Float32Array([-0.97003126, -0.24298018]), new Float32Array([-0.98078525, -0.19509032]), new Float32Array([-0.9891765, -0.14673047]), new Float32Array([-0.9951847, -0.09801714]), new Float32Array([-0.99879545, -0.049067676])];
    constructor.FFT_TABLE_16 = [new Float32Array([1.0, -0.0]), new Float32Array([0.9238795, -0.38268343]), new Float32Array([0.70710677, -0.70710677]), new Float32Array([0.38268343, -0.9238795]), new Float32Array([6.123234E-17, -1.0]), new Float32Array([-0.38268343, -0.9238795]), new Float32Array([-0.70710677, -0.70710677]), new Float32Array([-0.9238795, -0.38268343])];
    constructor.process = function(_in, n) {
        var ln = ((Math.round(Math.log(n) / Math.log(2))) | 0);
        var table = (n == 128) ? FFT.FFT_TABLE_128 : FFT.FFT_TABLE_16;
        var rev = Array.apply(null, Array(n)).map(function() {
            return new Float32Array(2);
        });
        var i, ii = 0;
        for (i = 0; i < n; i++) {
            rev[i][0] = _in[ii][0];
            rev[i][1] = _in[ii][1];
            var k = n >> 1;
             while (ii >= k && k > 0){
                ii -= k;
                k >>= 1;
            }
            ii += k;
        }
        for (i = 0; i < n; i++) {
            _in[i][0] = rev[i][0];
            _in[i][1] = rev[i][1];
        }
        var blocks = stjs.trunc(n / 2);
        var size = 2;
        var j, k, l, k0, k1, size2;
        var a = new Float32Array(2);
        for (i = 0; i < ln; i++) {
            size2 = stjs.trunc(size / 2);
            k0 = 0;
            k1 = size2;
            for (j = 0; j < blocks; ++j) {
                l = 0;
                for (k = 0; k < size2; ++k) {
                    a[0] = _in[k1][0] * table[l][0] - _in[k1][1] * table[l][1];
                    a[1] = _in[k1][0] * table[l][1] + _in[k1][1] * table[l][0];
                    _in[k1][0] = _in[k0][0] - a[0];
                    _in[k1][1] = _in[k0][1] - a[1];
                    _in[k0][0] += a[0];
                    _in[k0][1] += a[1];
                    l += blocks;
                    k0++;
                    k1++;
                }
                k0 += size2;
                k1 += size2;
            }
            blocks = stjs.trunc(blocks / 2);
            size = size * 2;
        }
    };
}, {FFT_TABLE_128: "Array", FFT_TABLE_16: "Array"}, {});
/**
 *  A reader for H.264 macroblocks
 *  
 *  @author The JCodec project
 */
var MBlockReader = function() {};
MBlockReader = stjs.extend(MBlockReader, null, [], null, {}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license. 
 * 
 *  @author in-somnia
 */
var TFGrid = function() {};
TFGrid = stjs.extend(TFGrid, null, [SBRConstants], function(constructor, prototype) {
    constructor.envelope_time_border_vector = function(sbr, ch) {
        var l, border, temp;
        var t_E_temp = new Int32Array(6);
        t_E_temp[0] = sbr.rate * sbr.abs_bord_lead[ch];
        t_E_temp[sbr.L_E[ch]] = sbr.rate * sbr.abs_bord_trail[ch];
        switch (sbr.bs_frame_class[ch]) {
            case SBRConstants.FIXFIX:
                switch (sbr.L_E[ch]) {
                    case 4:
                        temp = (stjs.trunc(sbr.numTimeSlots / 4));
                        t_E_temp[3] = sbr.rate * 3 * temp;
                        t_E_temp[2] = sbr.rate * 2 * temp;
                        t_E_temp[1] = sbr.rate * temp;
                        break;
                    case 2:
                        t_E_temp[1] = sbr.rate * (stjs.trunc(sbr.numTimeSlots / 2));
                        break;
                    default:
                        break;
                }
                break;
            case SBRConstants.FIXVAR:
                if (sbr.L_E[ch] > 1) {
                    var i = sbr.L_E[ch];
                    border = sbr.abs_bord_trail[ch];
                    for (l = 0; l < (sbr.L_E[ch] - 1); l++) {
                        if (border < sbr.bs_rel_bord[ch][l]) 
                            return 1;
                        border -= sbr.bs_rel_bord[ch][l];
                        t_E_temp[--i] = sbr.rate * border;
                    }
                }
                break;
            case SBRConstants.VARFIX:
                if (sbr.L_E[ch] > 1) {
                    var i = 1;
                    border = sbr.abs_bord_lead[ch];
                    for (l = 0; l < (sbr.L_E[ch] - 1); l++) {
                        border += sbr.bs_rel_bord[ch][l];
                        if (sbr.rate * border + sbr.tHFAdj > sbr.numTimeSlotsRate + sbr.tHFGen) 
                            return 1;
                        t_E_temp[i++] = sbr.rate * border;
                    }
                }
                break;
            case SBRConstants.VARVAR:
                if (sbr.bs_num_rel_0[ch] != 0) {
                    var i = 1;
                    border = sbr.abs_bord_lead[ch];
                    for (l = 0; l < sbr.bs_num_rel_0[ch]; l++) {
                        border += sbr.bs_rel_bord_0[ch][l];
                        if (sbr.rate * border + sbr.tHFAdj > sbr.numTimeSlotsRate + sbr.tHFGen) 
                            return 1;
                        t_E_temp[i++] = sbr.rate * border;
                    }
                }
                if (sbr.bs_num_rel_1[ch] != 0) {
                    var i = sbr.L_E[ch];
                    border = sbr.abs_bord_trail[ch];
                    for (l = 0; l < sbr.bs_num_rel_1[ch]; l++) {
                        if (border < sbr.bs_rel_bord_1[ch][l]) 
                            return 1;
                        border -= sbr.bs_rel_bord_1[ch][l];
                        t_E_temp[--i] = sbr.rate * border;
                    }
                }
                break;
        }
        for (l = 0; l < 6; l++) {
            sbr.t_E[ch][l] = t_E_temp[l];
        }
        return 0;
    };
    constructor.noise_floor_time_border_vector = function(sbr, ch) {
        sbr.t_Q[ch][0] = sbr.t_E[ch][0];
        if (sbr.L_E[ch] == 1) {
            sbr.t_Q[ch][1] = sbr.t_E[ch][1];
            sbr.t_Q[ch][2] = 0;
        } else {
            var index = TFGrid.middleBorder(sbr, ch);
            sbr.t_Q[ch][1] = sbr.t_E[ch][index];
            sbr.t_Q[ch][2] = sbr.t_E[ch][sbr.L_E[ch]];
        }
    };
    constructor.middleBorder = function(sbr, ch) {
        var retval = 0;
        switch (sbr.bs_frame_class[ch]) {
            case SBRConstants.FIXFIX:
                retval = stjs.trunc(sbr.L_E[ch] / 2);
                break;
            case SBRConstants.VARFIX:
                if (sbr.bs_pointer[ch] == 0) 
                    retval = 1;
                 else if (sbr.bs_pointer[ch] == 1) 
                    retval = sbr.L_E[ch] - 1;
                 else 
                    retval = sbr.bs_pointer[ch] - 1;
                break;
            case SBRConstants.FIXVAR:
            case SBRConstants.VARVAR:
                if (sbr.bs_pointer[ch] > 1) 
                    retval = sbr.L_E[ch] + 1 - sbr.bs_pointer[ch];
                 else 
                    retval = sbr.L_E[ch] - 1;
                break;
        }
        return (retval > 0) ? retval : 0;
    };
}, {startMinTable: "Int32Array", offsetIndexTable: "Int32Array", OFFSET: "Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license. 
 * 
 *  @author in-somnia
 */
var NoiseEnvelope = function() {};
NoiseEnvelope = stjs.extend(NoiseEnvelope, null, [SBRConstants], function(constructor, prototype) {
    constructor.E_deq_tab = new Float32Array([64.0, 128.0, 256.0, 512.0, 1024.0, 2048.0, 4096.0, 8192.0, 16384.0, 32768.0, 65536.0, 131072.0, 262144.0, 524288.0, 1048580.0, 2097150.0, 4194300.0, 8388610.0, 1.67772E7, 3.35544E7, 6.7108896E7, 1.34218E8, 2.68435008E8, 5.3687098E8, 1.07374003E9, 2.14748006E9, 4.2949699E9, 8.58993E9, 1.71798999E10, 3.43596995E10, 6.8719501E10, 1.37439003E11, 2.74878005E11, 5.4975601E11, 1.09950999E12, 2.19901998E12, 4.3980502E12, 8.7960899E12, 1.75922007E13, 3.5184401E13, 7.0368698E13, 1.40737002E14, 2.8147501E14, 5.6295002E14, 1.12590004E15, 2.25180008E15, 4.5036002E15, 9.0072003E15, 1.80144007E16, 3.6028801E16, 7.2057603E16, 1.44114999E17, 2.88229998E17, 5.7646103E17, 1.15291999E18, 2.30583999E18, 4.6116899E18, 9.2233698E18, 1.84467E19, 3.68935E19, 7.3787E19, 1.47574E20, 2.95148E20, 5.90296E20]);
    constructor.Q_div2_tab = new Float32Array([0.984615, 0.969697, 0.941176, 0.888889, 0.8, 0.666667, 0.5, 0.333333, 0.2, 0.111111, 0.0588235, 0.030303, 0.0153846, 0.00775194, 0.00389105, 0.00194932, 9.7561E-4, 4.88043E-4, 2.44081E-4, 1.22055E-4, 6.10314E-5, 3.05166E-5, 1.52586E-5, 7.62934E-6, 3.81468E-6, 1.90734E-6, 9.53673E-7, 4.76837E-7, 2.38419E-7, 1.19209E-7, 5.96046E-8]);
    constructor.Q_div2_tab_left = [new Float32Array([0.0302959, 0.111015, 0.332468, 0.663212, 0.882759, 0.962406, 0.984615, 0.990329, 0.991768, 0.992128, 0.992218, 0.992241, 0.992246]), new Float32Array([0.0153809, 0.0587695, 0.199377, 0.496124, 0.790123, 0.927536, 0.969697, 0.980843, 0.98367, 0.984379, 0.984556, 0.984601, 0.984612]), new Float32Array([0.00775006, 0.0302744, 0.110727, 0.329897, 0.653061, 0.864865, 0.941176, 0.962406, 0.967864, 0.969238, 0.969582, 0.969668, 0.96969]), new Float32Array([0.0038901, 0.0153698, 0.0586081, 0.197531, 0.484848, 0.761905, 0.888889, 0.927536, 0.937729, 0.940312, 0.94096, 0.941122, 0.941163]), new Float32Array([0.00194884, 0.00774443, 0.0301887, 0.109589, 0.32, 0.615385, 0.8, 0.864865, 0.882759, 0.887348, 0.888503, 0.888792, 0.888865]), new Float32Array([9.75372E-4, 0.00388727, 0.0153257, 0.057971, 0.190476, 0.444444, 0.666667, 0.761905, 0.790123, 0.797508, 0.799375, 0.799844, 0.799961]), new Float32Array([4.87924E-4, 0.00194742, 0.00772201, 0.0298507, 0.105263, 0.285714, 0.5, 0.615385, 0.653061, 0.663212, 0.6658, 0.66645, 0.666612]), new Float32Array([2.44021E-4, 9.74659E-4, 0.00387597, 0.0151515, 0.0555556, 0.166667, 0.333333, 0.444444, 0.484848, 0.496124, 0.499025, 0.499756, 0.499939]), new Float32Array([1.22026E-4, 4.87567E-4, 0.00194175, 0.00763359, 0.0285714, 0.0909091, 0.2, 0.285714, 0.32, 0.329897, 0.332468, 0.333116, 0.333279]), new Float32Array([6.10165E-5, 2.43843E-4, 9.71817E-4, 0.00383142, 0.0144928, 0.047619, 0.111111, 0.166667, 0.190476, 0.197531, 0.199377, 0.199844, 0.199961]), new Float32Array([3.05092E-5, 1.21936E-4, 4.86145E-4, 0.00191939, 0.00729927, 0.0243902, 0.0588235, 0.0909091, 0.105263, 0.109589, 0.110727, 0.111015, 0.111087]), new Float32Array([1.52548E-5, 6.09719E-5, 2.43132E-4, 9.60615E-4, 0.003663, 0.0123457, 0.030303, 0.047619, 0.0555556, 0.057971, 0.0586081, 0.0587695, 0.05881]), new Float32Array([7.62747E-6, 3.04869E-5, 1.21581E-4, 4.80538E-4, 0.00183486, 0.00621118, 0.0153846, 0.0243902, 0.0285714, 0.0298507, 0.0301887, 0.0302744, 0.0302959]), new Float32Array([3.81375E-6, 1.52437E-5, 6.0794E-5, 2.40327E-4, 9.18274E-4, 0.00311526, 0.00775194, 0.0123457, 0.0144928, 0.0151515, 0.0153257, 0.0153698, 0.0153809]), new Float32Array([1.90688E-6, 7.62189E-6, 3.03979E-5, 1.20178E-4, 4.59348E-4, 0.00156006, 0.00389105, 0.00621118, 0.00729927, 0.00763359, 0.00772201, 0.00774443, 0.00775006]), new Float32Array([9.53441E-7, 3.81096E-6, 1.51992E-5, 6.00925E-5, 2.29727E-4, 7.8064E-4, 0.00194932, 0.00311526, 0.003663, 0.00383142, 0.00387597, 0.00388727, 0.0038901]), new Float32Array([4.76721E-7, 1.90548E-6, 7.59965E-6, 3.00472E-5, 1.14877E-4, 3.90472E-4, 9.7561E-4, 0.00156006, 0.00183486, 0.00191939, 0.00194175, 0.00194742, 0.00194884]), new Float32Array([2.3836E-7, 9.52743E-7, 3.79984E-6, 1.50238E-5, 5.74416E-5, 1.95274E-4, 4.88043E-4, 7.8064E-4, 9.18274E-4, 9.60615E-4, 9.71817E-4, 9.74659E-4, 9.75372E-4]), new Float32Array([1.1918E-7, 4.76372E-7, 1.89992E-6, 7.51196E-6, 2.87216E-5, 9.76467E-5, 2.44081E-4, 3.90472E-4, 4.59348E-4, 4.80538E-4, 4.86145E-4, 4.87567E-4, 4.87924E-4]), new Float32Array([5.95901E-8, 2.38186E-7, 9.49963E-7, 3.756E-6, 1.4361E-5, 4.88257E-5, 1.22055E-4, 1.95274E-4, 2.29727E-4, 2.40327E-4, 2.43132E-4, 2.43843E-4, 2.44021E-4]), new Float32Array([2.9795E-8, 1.19093E-7, 4.74982E-7, 1.878E-6, 7.18056E-6, 2.44135E-5, 6.10314E-5, 9.76467E-5, 1.14877E-4, 1.20178E-4, 1.21581E-4, 1.21936E-4, 1.22026E-4]), new Float32Array([1.48975E-8, 5.95465E-8, 2.37491E-7, 9.39002E-7, 3.59029E-6, 1.22069E-5, 3.05166E-5, 4.88257E-5, 5.74416E-5, 6.00925E-5, 6.0794E-5, 6.09719E-5, 6.10165E-5]), new Float32Array([7.44876E-9, 2.97732E-8, 1.18745E-7, 4.69501E-7, 1.79515E-6, 6.10348E-6, 1.52586E-5, 2.44135E-5, 2.87216E-5, 3.00472E-5, 3.03979E-5, 3.04869E-5, 3.05092E-5]), new Float32Array([3.72438E-9, 1.48866E-8, 5.93727E-8, 2.34751E-7, 8.97575E-7, 3.05175E-6, 7.62934E-6, 1.22069E-5, 1.4361E-5, 1.50238E-5, 1.51992E-5, 1.52437E-5, 1.52548E-5]), new Float32Array([1.86219E-9, 7.44331E-9, 2.96864E-8, 1.17375E-7, 4.48788E-7, 1.52588E-6, 3.81468E-6, 6.10348E-6, 7.18056E-6, 7.51196E-6, 7.59965E-6, 7.62189E-6, 7.62747E-6]), new Float32Array([9.31095E-10, 3.72166E-9, 1.48432E-8, 5.86876E-8, 2.24394E-7, 7.62939E-7, 1.90734E-6, 3.05175E-6, 3.59029E-6, 3.756E-6, 3.79984E-6, 3.81096E-6, 3.81375E-6]), new Float32Array([4.65548E-10, 1.86083E-9, 7.42159E-9, 2.93438E-8, 1.12197E-7, 3.8147E-7, 9.53673E-7, 1.52588E-6, 1.79515E-6, 1.878E-6, 1.89992E-6, 1.90548E-6, 1.90688E-6]), new Float32Array([2.32774E-10, 9.30414E-10, 3.71079E-9, 1.46719E-8, 5.60985E-8, 1.90735E-7, 4.76837E-7, 7.62939E-7, 8.97575E-7, 9.39002E-7, 9.49963E-7, 9.52743E-7, 9.53441E-7]), new Float32Array([1.16387E-10, 4.65207E-10, 1.8554E-9, 7.33596E-9, 2.80492E-8, 9.53674E-8, 2.38419E-7, 3.8147E-7, 4.48788E-7, 4.69501E-7, 4.74982E-7, 4.76372E-7, 4.76721E-7]), new Float32Array([5.81935E-11, 2.32603E-10, 9.27699E-10, 3.66798E-9, 1.40246E-8, 4.76837E-8, 1.19209E-7, 1.90735E-7, 2.24394E-7, 2.34751E-7, 2.37491E-7, 2.38186E-7, 2.3836E-7]), new Float32Array([2.90967E-11, 1.16302E-10, 4.63849E-10, 1.83399E-9, 7.01231E-9, 2.38419E-8, 5.96046E-8, 9.53674E-8, 1.12197E-7, 1.17375E-7, 1.18745E-7, 1.19093E-7, 1.1918E-7])];
    constructor.Q_div2_tab_right = [new Float32Array([0.992246, 0.992241, 0.992218, 0.992128, 0.991768, 0.990329, 0.984615, 0.962406, 0.882759, 0.663212, 0.332468, 0.111015, 0.0302959]), new Float32Array([0.984612, 0.984601, 0.984556, 0.984379, 0.98367, 0.980843, 0.969697, 0.927536, 0.790123, 0.496124, 0.199377, 0.0587695, 0.0153809]), new Float32Array([0.96969, 0.969668, 0.969582, 0.969238, 0.967864, 0.962406, 0.941176, 0.864865, 0.653061, 0.329897, 0.110727, 0.0302744, 0.00775006]), new Float32Array([0.941163, 0.941122, 0.94096, 0.940312, 0.937729, 0.927536, 0.888889, 0.761905, 0.484848, 0.197531, 0.0586081, 0.0153698, 0.0038901]), new Float32Array([0.888865, 0.888792, 0.888503, 0.887348, 0.882759, 0.864865, 0.8, 0.615385, 0.32, 0.109589, 0.0301887, 0.00774443, 0.00194884]), new Float32Array([0.799961, 0.799844, 0.799375, 0.797508, 0.790123, 0.761905, 0.666667, 0.444444, 0.190476, 0.057971, 0.0153257, 0.00388727, 9.75372E-4]), new Float32Array([0.666612, 0.66645, 0.6658, 0.663212, 0.653061, 0.615385, 0.5, 0.285714, 0.105263, 0.0298507, 0.00772201, 0.00194742, 4.87924E-4]), new Float32Array([0.499939, 0.499756, 0.499025, 0.496124, 0.484848, 0.444444, 0.333333, 0.166667, 0.0555556, 0.0151515, 0.00387597, 9.74659E-4, 2.44021E-4]), new Float32Array([0.333279, 0.333116, 0.332468, 0.329897, 0.32, 0.285714, 0.2, 0.0909091, 0.0285714, 0.00763359, 0.00194175, 4.87567E-4, 1.22026E-4]), new Float32Array([0.199961, 0.199844, 0.199377, 0.197531, 0.190476, 0.166667, 0.111111, 0.047619, 0.0144928, 0.00383142, 9.71817E-4, 2.43843E-4, 6.10165E-5]), new Float32Array([0.111087, 0.111015, 0.110727, 0.109589, 0.105263, 0.0909091, 0.0588235, 0.0243902, 0.00729927, 0.00191939, 4.86145E-4, 1.21936E-4, 3.05092E-5]), new Float32Array([0.05881, 0.0587695, 0.0586081, 0.057971, 0.0555556, 0.047619, 0.030303, 0.0123457, 0.003663, 9.60615E-4, 2.43132E-4, 6.09719E-5, 1.52548E-5]), new Float32Array([0.0302959, 0.0302744, 0.0301887, 0.0298507, 0.0285714, 0.0243902, 0.0153846, 0.00621118, 0.00183486, 4.80538E-4, 1.21581E-4, 3.04869E-5, 7.62747E-6]), new Float32Array([0.0153809, 0.0153698, 0.0153257, 0.0151515, 0.0144928, 0.0123457, 0.00775194, 0.00311526, 9.18274E-4, 2.40327E-4, 6.0794E-5, 1.52437E-5, 3.81375E-6]), new Float32Array([0.00775006, 0.00774443, 0.00772201, 0.00763359, 0.00729927, 0.00621118, 0.00389105, 0.00156006, 4.59348E-4, 1.20178E-4, 3.03979E-5, 7.62189E-6, 1.90688E-6]), new Float32Array([0.0038901, 0.00388727, 0.00387597, 0.00383142, 0.003663, 0.00311526, 0.00194932, 7.8064E-4, 2.29727E-4, 6.00925E-5, 1.51992E-5, 3.81096E-6, 9.53441E-7]), new Float32Array([0.00194884, 0.00194742, 0.00194175, 0.00191939, 0.00183486, 0.00156006, 9.7561E-4, 3.90472E-4, 1.14877E-4, 3.00472E-5, 7.59965E-6, 1.90548E-6, 4.76721E-7]), new Float32Array([9.75372E-4, 9.74659E-4, 9.71817E-4, 9.60615E-4, 9.18274E-4, 7.8064E-4, 4.88043E-4, 1.95274E-4, 5.74416E-5, 1.50238E-5, 3.79984E-6, 9.52743E-7, 2.3836E-7]), new Float32Array([4.87924E-4, 4.87567E-4, 4.86145E-4, 4.80538E-4, 4.59348E-4, 3.90472E-4, 2.44081E-4, 9.76467E-5, 2.87216E-5, 7.51196E-6, 1.89992E-6, 4.76372E-7, 1.1918E-7]), new Float32Array([2.44021E-4, 2.43843E-4, 2.43132E-4, 2.40327E-4, 2.29727E-4, 1.95274E-4, 1.22055E-4, 4.88257E-5, 1.4361E-5, 3.756E-6, 9.49963E-7, 2.38186E-7, 5.95901E-8]), new Float32Array([1.22026E-4, 1.21936E-4, 1.21581E-4, 1.20178E-4, 1.14877E-4, 9.76467E-5, 6.10314E-5, 2.44135E-5, 7.18056E-6, 1.878E-6, 4.74982E-7, 1.19093E-7, 2.9795E-8]), new Float32Array([6.10165E-5, 6.09719E-5, 6.0794E-5, 6.00925E-5, 5.74416E-5, 4.88257E-5, 3.05166E-5, 1.22069E-5, 3.59029E-6, 9.39002E-7, 2.37491E-7, 5.95465E-8, 1.48975E-8]), new Float32Array([3.05092E-5, 3.04869E-5, 3.03979E-5, 3.00472E-5, 2.87216E-5, 2.44135E-5, 1.52586E-5, 6.10348E-6, 1.79515E-6, 4.69501E-7, 1.18745E-7, 2.97732E-8, 7.44876E-9]), new Float32Array([1.52548E-5, 1.52437E-5, 1.51992E-5, 1.50238E-5, 1.4361E-5, 1.22069E-5, 7.62934E-6, 3.05175E-6, 8.97575E-7, 2.34751E-7, 5.93727E-8, 1.48866E-8, 3.72438E-9]), new Float32Array([7.62747E-6, 7.62189E-6, 7.59965E-6, 7.51196E-6, 7.18056E-6, 6.10348E-6, 3.81468E-6, 1.52588E-6, 4.48788E-7, 1.17375E-7, 2.96864E-8, 7.44331E-9, 1.86219E-9]), new Float32Array([3.81375E-6, 3.81096E-6, 3.79984E-6, 3.756E-6, 3.59029E-6, 3.05175E-6, 1.90734E-6, 7.62939E-7, 2.24394E-7, 5.86876E-8, 1.48432E-8, 3.72166E-9, 9.31095E-10]), new Float32Array([1.90688E-6, 1.90548E-6, 1.89992E-6, 1.878E-6, 1.79515E-6, 1.52588E-6, 9.53673E-7, 3.8147E-7, 1.12197E-7, 2.93438E-8, 7.42159E-9, 1.86083E-9, 4.65548E-10]), new Float32Array([9.53441E-7, 9.52743E-7, 9.49963E-7, 9.39002E-7, 8.97575E-7, 7.62939E-7, 4.76837E-7, 1.90735E-7, 5.60985E-8, 1.46719E-8, 3.71079E-9, 9.30414E-10, 2.32774E-10]), new Float32Array([4.76721E-7, 4.76372E-7, 4.74982E-7, 4.69501E-7, 4.48788E-7, 3.8147E-7, 2.38419E-7, 9.53674E-8, 2.80492E-8, 7.33596E-9, 1.8554E-9, 4.65207E-10, 1.16387E-10]), new Float32Array([2.3836E-7, 2.38186E-7, 2.37491E-7, 2.34751E-7, 2.24394E-7, 1.90735E-7, 1.19209E-7, 4.76837E-8, 1.40246E-8, 3.66798E-9, 9.27699E-10, 2.32603E-10, 5.81935E-11]), new Float32Array([1.1918E-7, 1.19093E-7, 1.18745E-7, 1.17375E-7, 1.12197E-7, 9.53674E-8, 5.96046E-8, 2.38419E-8, 7.01231E-9, 1.83399E-9, 4.63849E-10, 1.16302E-10, 2.90967E-11])];
    constructor.Q_div_tab = new Float32Array([0.0153846, 0.030303, 0.0588235, 0.111111, 0.2, 0.333333, 0.5, 0.666667, 0.8, 0.888889, 0.941176, 0.969697, 0.984615, 0.992248, 0.996109, 0.998051, 0.999024, 0.999512, 0.999756, 0.999878, 0.999939, 0.999969, 0.999985, 0.999992, 0.999996, 0.999998, 0.999999, 1.0, 1.0, 1.0, 1.0]);
    constructor.Q_div_tab_left = [new Float32Array([0.969704, 0.888985, 0.667532, 0.336788, 0.117241, 0.037594, 0.0153846, 0.00967118, 0.00823245, 0.00787211, 0.00778198, 0.00775945, 0.00775382]), new Float32Array([0.984619, 0.94123, 0.800623, 0.503876, 0.209877, 0.0724638, 0.030303, 0.0191571, 0.0163305, 0.0156212, 0.0154438, 0.0153994, 0.0153883]), new Float32Array([0.99225, 0.969726, 0.889273, 0.670103, 0.346939, 0.135135, 0.0588235, 0.037594, 0.0321361, 0.0307619, 0.0304178, 0.0303317, 0.0303102]), new Float32Array([0.99611, 0.98463, 0.941392, 0.802469, 0.515152, 0.238095, 0.111111, 0.0724638, 0.0622711, 0.0596878, 0.0590397, 0.0588776, 0.058837]), new Float32Array([0.998051, 0.992256, 0.969811, 0.890411, 0.68, 0.384615, 0.2, 0.135135, 0.117241, 0.112652, 0.111497, 0.111208, 0.111135]), new Float32Array([0.999025, 0.996113, 0.984674, 0.942029, 0.809524, 0.555556, 0.333333, 0.238095, 0.209877, 0.202492, 0.200625, 0.200156, 0.200039]), new Float32Array([0.999512, 0.998053, 0.992278, 0.970149, 0.894737, 0.714286, 0.5, 0.384615, 0.346939, 0.336788, 0.3342, 0.33355, 0.333388]), new Float32Array([0.999756, 0.999025, 0.996124, 0.984848, 0.944444, 0.833333, 0.666667, 0.555556, 0.515152, 0.503876, 0.500975, 0.500244, 0.500061]), new Float32Array([0.999878, 0.999512, 0.998058, 0.992366, 0.971429, 0.909091, 0.8, 0.714286, 0.68, 0.670103, 0.667532, 0.666884, 0.666721]), new Float32Array([0.999939, 0.999756, 0.999028, 0.996169, 0.985507, 0.952381, 0.888889, 0.833333, 0.809524, 0.802469, 0.800623, 0.800156, 0.800039]), new Float32Array([0.999969, 0.999878, 0.999514, 0.998081, 0.992701, 0.97561, 0.941176, 0.909091, 0.894737, 0.890411, 0.889273, 0.888985, 0.888913]), new Float32Array([0.999985, 0.999939, 0.999757, 0.999039, 0.996337, 0.987654, 0.969697, 0.952381, 0.944444, 0.942029, 0.941392, 0.94123, 0.94119]), new Float32Array([0.999992, 0.99997, 0.999878, 0.999519, 0.998165, 0.993789, 0.984615, 0.97561, 0.971429, 0.970149, 0.969811, 0.969726, 0.969704]), new Float32Array([0.999996, 0.999985, 0.999939, 0.99976, 0.999082, 0.996885, 0.992248, 0.987654, 0.985507, 0.984848, 0.984674, 0.98463, 0.984619]), new Float32Array([0.999998, 0.999992, 0.99997, 0.99988, 0.999541, 0.99844, 0.996109, 0.993789, 0.992701, 0.992366, 0.992278, 0.992256, 0.99225]), new Float32Array([0.999999, 0.999996, 0.999985, 0.99994, 0.99977, 0.999219, 0.998051, 0.996885, 0.996337, 0.996169, 0.996124, 0.996113, 0.99611]), new Float32Array([1.0, 0.999998, 0.999992, 0.99997, 0.999885, 0.99961, 0.999024, 0.99844, 0.998165, 0.998081, 0.998058, 0.998053, 0.998051]), new Float32Array([1.0, 0.999999, 0.999996, 0.999985, 0.999943, 0.999805, 0.999512, 0.999219, 0.999082, 0.999039, 0.999028, 0.999025, 0.999025]), new Float32Array([1.0, 1.0, 0.999998, 0.999992, 0.999971, 0.999902, 0.999756, 0.99961, 0.999541, 0.999519, 0.999514, 0.999512, 0.999512]), new Float32Array([1.0, 1.0, 0.999999, 0.999996, 0.999986, 0.999951, 0.999878, 0.999805, 0.99977, 0.99976, 0.999757, 0.999756, 0.999756]), new Float32Array([1.0, 1.0, 1.0, 0.999998, 0.999993, 0.999976, 0.999939, 0.999902, 0.999885, 0.99988, 0.999878, 0.999878, 0.999878]), new Float32Array([1.0, 1.0, 1.0, 0.999999, 0.999996, 0.999988, 0.999969, 0.999951, 0.999943, 0.99994, 0.999939, 0.999939, 0.999939]), new Float32Array([1.0, 1.0, 1.0, 1.0, 0.999998, 0.999994, 0.999985, 0.999976, 0.999971, 0.99997, 0.99997, 0.99997, 0.999969]), new Float32Array([1.0, 1.0, 1.0, 1.0, 0.999999, 0.999997, 0.999992, 0.999988, 0.999986, 0.999985, 0.999985, 0.999985, 0.999985]), new Float32Array([1.0, 1.0, 1.0, 1.0, 1.0, 0.999998, 0.999996, 0.999994, 0.999993, 0.999992, 0.999992, 0.999992, 0.999992]), new Float32Array([1.0, 1.0, 1.0, 1.0, 1.0, 0.999999, 0.999998, 0.999997, 0.999996, 0.999996, 0.999996, 0.999996, 0.999996]), new Float32Array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.999999, 0.999998, 0.999998, 0.999998, 0.999998, 0.999998, 0.999998]), new Float32Array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.999999, 0.999999, 0.999999, 0.999999, 0.999999, 0.999999]), new Float32Array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]), new Float32Array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]), new Float32Array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0])];
    constructor.Q_div_tab_right = [new Float32Array([0.00775382, 0.00775945, 0.00778198, 0.00787211, 0.00823245, 0.00967118, 0.0153846, 0.037594, 0.117241, 0.336788, 0.667532, 0.888985, 0.969704]), new Float32Array([0.0153883, 0.0153994, 0.0154438, 0.0156212, 0.0163305, 0.0191571, 0.030303, 0.0724638, 0.209877, 0.503876, 0.800623, 0.94123, 0.984619]), new Float32Array([0.0303102, 0.0303317, 0.0304178, 0.0307619, 0.0321361, 0.037594, 0.0588235, 0.135135, 0.346939, 0.670103, 0.889273, 0.969726, 0.99225]), new Float32Array([0.058837, 0.0588776, 0.0590397, 0.0596878, 0.0622711, 0.0724638, 0.111111, 0.238095, 0.515152, 0.802469, 0.941392, 0.98463, 0.99611]), new Float32Array([0.111135, 0.111208, 0.111497, 0.112652, 0.117241, 0.135135, 0.2, 0.384615, 0.68, 0.890411, 0.969811, 0.992256, 0.998051]), new Float32Array([0.200039, 0.200156, 0.200625, 0.202492, 0.209877, 0.238095, 0.333333, 0.555556, 0.809524, 0.942029, 0.984674, 0.996113, 0.999025]), new Float32Array([0.333388, 0.33355, 0.3342, 0.336788, 0.346939, 0.384615, 0.5, 0.714286, 0.894737, 0.970149, 0.992278, 0.998053, 0.999512]), new Float32Array([0.500061, 0.500244, 0.500975, 0.503876, 0.515152, 0.555556, 0.666667, 0.833333, 0.944444, 0.984848, 0.996124, 0.999025, 0.999756]), new Float32Array([0.666721, 0.666884, 0.667532, 0.670103, 0.68, 0.714286, 0.8, 0.909091, 0.971429, 0.992366, 0.998058, 0.999512, 0.999878]), new Float32Array([0.800039, 0.800156, 0.800623, 0.802469, 0.809524, 0.833333, 0.888889, 0.952381, 0.985507, 0.996169, 0.999028, 0.999756, 0.999939]), new Float32Array([0.888913, 0.888985, 0.889273, 0.890411, 0.894737, 0.909091, 0.941176, 0.97561, 0.992701, 0.998081, 0.999514, 0.999878, 0.999969]), new Float32Array([0.94119, 0.94123, 0.941392, 0.942029, 0.944444, 0.952381, 0.969697, 0.987654, 0.996337, 0.999039, 0.999757, 0.999939, 0.999985]), new Float32Array([0.969704, 0.969726, 0.969811, 0.970149, 0.971429, 0.97561, 0.984615, 0.993789, 0.998165, 0.999519, 0.999878, 0.99997, 0.999992]), new Float32Array([0.984619, 0.98463, 0.984674, 0.984848, 0.985507, 0.987654, 0.992248, 0.996885, 0.999082, 0.99976, 0.999939, 0.999985, 0.999996]), new Float32Array([0.99225, 0.992256, 0.992278, 0.992366, 0.992701, 0.993789, 0.996109, 0.99844, 0.999541, 0.99988, 0.99997, 0.999992, 0.999998]), new Float32Array([0.99611, 0.996113, 0.996124, 0.996169, 0.996337, 0.996885, 0.998051, 0.999219, 0.99977, 0.99994, 0.999985, 0.999996, 0.999999]), new Float32Array([0.998051, 0.998053, 0.998058, 0.998081, 0.998165, 0.99844, 0.999024, 0.99961, 0.999885, 0.99997, 0.999992, 0.999998, 1.0]), new Float32Array([0.999025, 0.999025, 0.999028, 0.999039, 0.999082, 0.999219, 0.999512, 0.999805, 0.999943, 0.999985, 0.999996, 0.999999, 1.0]), new Float32Array([0.999512, 0.999512, 0.999514, 0.999519, 0.999541, 0.99961, 0.999756, 0.999902, 0.999971, 0.999992, 0.999998, 1.0, 1.0]), new Float32Array([0.999756, 0.999756, 0.999757, 0.99976, 0.99977, 0.999805, 0.999878, 0.999951, 0.999986, 0.999996, 0.999999, 1.0, 1.0]), new Float32Array([0.999878, 0.999878, 0.999878, 0.99988, 0.999885, 0.999902, 0.999939, 0.999976, 0.999993, 0.999998, 1.0, 1.0, 1.0]), new Float32Array([0.999939, 0.999939, 0.999939, 0.99994, 0.999943, 0.999951, 0.999969, 0.999988, 0.999996, 0.999999, 1.0, 1.0, 1.0]), new Float32Array([0.999969, 0.99997, 0.99997, 0.99997, 0.999971, 0.999976, 0.999985, 0.999994, 0.999998, 1.0, 1.0, 1.0, 1.0]), new Float32Array([0.999985, 0.999985, 0.999985, 0.999985, 0.999986, 0.999988, 0.999992, 0.999997, 0.999999, 1.0, 1.0, 1.0, 1.0]), new Float32Array([0.999992, 0.999992, 0.999992, 0.999992, 0.999993, 0.999994, 0.999996, 0.999998, 1.0, 1.0, 1.0, 1.0, 1.0]), new Float32Array([0.999996, 0.999996, 0.999996, 0.999996, 0.999996, 0.999997, 0.999998, 0.999999, 1.0, 1.0, 1.0, 1.0, 1.0]), new Float32Array([0.999998, 0.999998, 0.999998, 0.999998, 0.999998, 0.999998, 0.999999, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]), new Float32Array([0.999999, 0.999999, 0.999999, 0.999999, 0.999999, 0.999999, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]), new Float32Array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]), new Float32Array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]), new Float32Array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0])];
    constructor.extract_envelope_data = function(sbr, ch) {
        var l, k;
        for (l = 0; l < sbr.L_E[ch]; l++) {
            if (sbr.bs_df_env[ch][l] == 0) {
                for (k = 1; k < sbr.n[sbr.f[ch][l]]; k++) {
                    sbr.E[ch][k][l] = sbr.E[ch][k - 1][l] + sbr.E[ch][k][l];
                    if (sbr.E[ch][k][l] < 0) 
                        sbr.E[ch][k][l] = 0;
                }
            } else {
                var g = (l == 0) ? sbr.f_prev[ch] : sbr.f[ch][l - 1];
                var E_prev;
                if (sbr.f[ch][l] == g) {
                    for (k = 0; k < sbr.n[sbr.f[ch][l]]; k++) {
                        if (l == 0) 
                            E_prev = sbr.E_prev[ch][k];
                         else 
                            E_prev = sbr.E[ch][k][l - 1];
                        sbr.E[ch][k][l] = E_prev + sbr.E[ch][k][l];
                    }
                } else if ((g == 1) && (sbr.f[ch][l] == 0)) {
                    var i;
                    for (k = 0; k < sbr.n[sbr.f[ch][l]]; k++) {
                        for (i = 0; i < sbr.N_high; i++) {
                            if (sbr.f_table_res[SBRConstants.HI_RES][i] == sbr.f_table_res[SBRConstants.LO_RES][k]) {
                                if (l == 0) 
                                    E_prev = sbr.E_prev[ch][i];
                                 else 
                                    E_prev = sbr.E[ch][i][l - 1];
                                sbr.E[ch][k][l] = E_prev + sbr.E[ch][k][l];
                            }
                        }
                    }
                } else if ((g == 0) && (sbr.f[ch][l] == 1)) {
                    var i;
                    for (k = 0; k < sbr.n[sbr.f[ch][l]]; k++) {
                        for (i = 0; i < sbr.N_low; i++) {
                            if ((sbr.f_table_res[SBRConstants.LO_RES][i] <= sbr.f_table_res[SBRConstants.HI_RES][k]) && (sbr.f_table_res[SBRConstants.HI_RES][k] < sbr.f_table_res[SBRConstants.LO_RES][i + 1])) {
                                if (l == 0) 
                                    E_prev = sbr.E_prev[ch][i];
                                 else 
                                    E_prev = sbr.E[ch][i][l - 1];
                                sbr.E[ch][k][l] = E_prev + sbr.E[ch][k][l];
                            }
                        }
                    }
                }
            }
        }
    };
    constructor.extract_noise_floor_data = function(sbr, ch) {
        var l, k;
        for (l = 0; l < sbr.L_Q[ch]; l++) {
            if (sbr.bs_df_noise[ch][l] == 0) {
                for (k = 1; k < sbr.N_Q; k++) {
                    sbr.Q[ch][k][l] = sbr.Q[ch][k][l] + sbr.Q[ch][k - 1][l];
                }
            } else {
                if (l == 0) {
                    for (k = 0; k < sbr.N_Q; k++) {
                        sbr.Q[ch][k][l] = sbr.Q_prev[ch][k] + sbr.Q[ch][k][0];
                    }
                } else {
                    for (k = 0; k < sbr.N_Q; k++) {
                        sbr.Q[ch][k][l] = sbr.Q[ch][k][l - 1] + sbr.Q[ch][k][l];
                    }
                }
            }
        }
    };
    constructor.calc_Q_div = function(sbr, ch, m, l) {
        if (sbr.bs_coupling) {
            if ((sbr.Q[0][m][l] < 0 || sbr.Q[0][m][l] > 30) || (sbr.Q[1][m][l] < 0 || sbr.Q[1][m][l] > 24)) {
                return 0;
            } else {
                if (ch == 0) {
                    return NoiseEnvelope.Q_div_tab_left[sbr.Q[0][m][l]][sbr.Q[1][m][l] >> 1];
                } else {
                    return NoiseEnvelope.Q_div_tab_right[sbr.Q[0][m][l]][sbr.Q[1][m][l] >> 1];
                }
            }
        } else {
            if (sbr.Q[ch][m][l] < 0 || sbr.Q[ch][m][l] > 30) {
                return 0;
            } else {
                return NoiseEnvelope.Q_div_tab[sbr.Q[ch][m][l]];
            }
        }
    };
    constructor.calc_Q_div2 = function(sbr, ch, m, l) {
        if (sbr.bs_coupling) {
            if ((sbr.Q[0][m][l] < 0 || sbr.Q[0][m][l] > 30) || (sbr.Q[1][m][l] < 0 || sbr.Q[1][m][l] > 24)) {
                return 0;
            } else {
                if (ch == 0) {
                    return NoiseEnvelope.Q_div2_tab_left[sbr.Q[0][m][l]][sbr.Q[1][m][l] >> 1];
                } else {
                    return NoiseEnvelope.Q_div2_tab_right[sbr.Q[0][m][l]][sbr.Q[1][m][l] >> 1];
                }
            }
        } else {
            if (sbr.Q[ch][m][l] < 0 || sbr.Q[ch][m][l] > 30) {
                return 0;
            } else {
                return NoiseEnvelope.Q_div2_tab[sbr.Q[ch][m][l]];
            }
        }
    };
    constructor.dequantChannel = function(sbr, ch) {
        if (!sbr.bs_coupling) {
            var exp;
            var l, k;
            var amp = (sbr.amp_res[ch]) ? 0 : 1;
            for (l = 0; l < sbr.L_E[ch]; l++) {
                for (k = 0; k < sbr.n[sbr.f[ch][l]]; k++) {
                    exp = (sbr.E[ch][k][l] >> amp);
                    if ((exp < 0) || (exp >= 64)) {
                        sbr.E_orig[ch][k][l] = 0;
                    } else {
                        sbr.E_orig[ch][k][l] = NoiseEnvelope.E_deq_tab[exp];
                        if (amp != 0 && (sbr.E[ch][k][l] & 1) != 0) {
                            sbr.E_orig[ch][k][l] = (sbr.E_orig[ch][k][l] * 1.4142135);
                        }
                    }
                }
            }
            for (l = 0; l < sbr.L_Q[ch]; l++) {
                for (k = 0; k < sbr.N_Q; k++) {
                    sbr.Q_div[ch][k][l] = NoiseEnvelope.calc_Q_div(sbr, ch, k, l);
                    sbr.Q_div2[ch][k][l] = NoiseEnvelope.calc_Q_div2(sbr, ch, k, l);
                }
            }
        }
    };
    constructor.E_pan_tab = new Float32Array([2.44081E-4, 4.88043E-4, 9.7561E-4, 0.00194932, 0.00389105, 0.00775194, 0.0153846, 0.030303, 0.0588235, 0.111111, 0.2, 0.333333, 0.5, 0.666667, 0.8, 0.888889, 0.941176, 0.969697, 0.984615, 0.992248, 0.996109, 0.998051, 0.999024, 0.999512, 0.999756]);
    constructor.unmap = function(sbr) {
        var tmp;
        var exp0, exp1;
        var l, k;
        var amp0 = (sbr.amp_res[0]) ? 0 : 1;
        var amp1 = (sbr.amp_res[1]) ? 0 : 1;
        for (l = 0; l < sbr.L_E[0]; l++) {
            for (k = 0; k < sbr.n[sbr.f[0][l]]; k++) {
                exp0 = (sbr.E[0][k][l] >> amp0) + 1;
                exp1 = (sbr.E[1][k][l] >> amp1);
                if ((exp0 < 0) || (exp0 >= 64) || (exp1 < 0) || (exp1 > 24)) {
                    sbr.E_orig[1][k][l] = 0;
                    sbr.E_orig[0][k][l] = 0;
                } else {
                    tmp = NoiseEnvelope.E_deq_tab[exp0];
                    if (amp0 != 0 && (sbr.E[0][k][l] & 1) != 0) {
                        tmp *= 1.414213562;
                    }
                    sbr.E_orig[0][k][l] = (tmp * NoiseEnvelope.E_pan_tab[exp1]);
                    sbr.E_orig[1][k][l] = (tmp * NoiseEnvelope.E_pan_tab[24 - exp1]);
                }
            }
        }
        for (l = 0; l < sbr.L_Q[0]; l++) {
            for (k = 0; k < sbr.N_Q; k++) {
                sbr.Q_div[0][k][l] = NoiseEnvelope.calc_Q_div(sbr, 0, k, l);
                sbr.Q_div[1][k][l] = NoiseEnvelope.calc_Q_div(sbr, 1, k, l);
                sbr.Q_div2[0][k][l] = NoiseEnvelope.calc_Q_div2(sbr, 0, k, l);
                sbr.Q_div2[1][k][l] = NoiseEnvelope.calc_Q_div2(sbr, 1, k, l);
            }
        }
    };
}, {E_deq_tab: "Float32Array", Q_div2_tab: "Float32Array", Q_div2_tab_left: "Array", Q_div2_tab_right: "Array", Q_div_tab: "Float32Array", Q_div_tab_left: "Array", Q_div_tab_right: "Array", E_pan_tab: "Float32Array", startMinTable: "Int32Array", offsetIndexTable: "Int32Array", OFFSET: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A filter that removes DCT artifacts on block boundaries.
 *  
 *  It's operation is dependant on QP and is designed the way that the strenth is
 *  adjusted to the likelyhood of appearence of blocking artifacts on the
 *  specific edges.
 *  
 *  Builds a parameter for deblocking filter based on the properties of specific
 *  macroblocks.
 *  
 *  A parameter specifies the behavior of deblocking filter on each of 8 edges
 *  that need to filtered for a macroblock.
 *  
 *  For each edge the following things are evaluated on it's both sides: presence
 *  of DCT coded residual; motion vector difference; spatial location.
 *  
 *  
 *  @author The JCodec project
 *  
 */
var DeblockingFilter = function(bitDepthLuma, bitDepthChroma, di) {
    this.di = di;
};
DeblockingFilter = stjs.extend(DeblockingFilter, null, [], function(constructor, prototype) {
    constructor.alphaTab = new Int32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 5, 6, 7, 8, 9, 10, 12, 13, 15, 17, 20, 22, 25, 28, 32, 36, 40, 45, 50, 56, 63, 71, 80, 90, 101, 113, 127, 144, 162, 182, 203, 226, 255, 255]);
    constructor.betaTab = new Int32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18]);
    constructor.tcs = [new Int32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 6, 6, 7, 8, 9, 10, 11, 13]), new Int32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 4, 4, 5, 5, 6, 7, 8, 8, 10, 11, 12, 13, 15, 17]), new Int32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 6, 6, 7, 8, 9, 10, 11, 13, 14, 16, 18, 20, 23, 25])];
    prototype.di = null;
    prototype.deblockFrame = function(result) {
        var color = result.getColor();
        var bsV = Array.apply(null, Array(4)).map(function() {
            return new Int32Array(4);
        }), bsH = Array.apply(null, Array(4)).map(function() {
            return new Int32Array(4);
        });
        for (var i = 0; i < this.di.shs.length; i++) {
            this.calcBsH(result, i, bsH);
            this.calcBsV(result, i, bsV);
            for (var c = 0; c < color.nComp; c++) {
                this.fillVerticalEdge(result, c, i, bsV);
                this.fillHorizontalEdge(result, c, i, bsH);
            }
        }
    };
    constructor.inverse = new Int32Array([0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15]);
    prototype.calcBoundaryStrenth = function(atMbBoundary, leftIntra, rightIntra, leftCoeff, rightCoeff, mvA0, mvB0, mvA1, mvB1, mbAddrA, mbAddrB) {
        if (atMbBoundary && (leftIntra || rightIntra)) 
            return 4;
         else if (leftIntra || rightIntra) 
            return 3;
         else {
            if (leftCoeff > 0 || rightCoeff > 0) 
                return 2;
            var nA = (mvA0[2] == -1 ? 0 : 1) + (mvA1[2] == -1 ? 0 : 1);
            var nB = (mvB0[2] == -1 ? 0 : 1) + (mvB1[2] == -1 ? 0 : 1);
            if (nA != nB) 
                return 1;
            var ra0 = mvA0[2] < 0 ? null : this.di.refsUsed[mbAddrA][0][mvA0[2]];
            var ra1 = mvA1[2] < 0 ? null : this.di.refsUsed[mbAddrA][1][mvA1[2]];
            var rb0 = mvB0[2] < 0 ? null : this.di.refsUsed[mbAddrB][0][mvB0[2]];
            var rb1 = mvB1[2] < 0 ? null : this.di.refsUsed[mbAddrB][1][mvB1[2]];
            if (ra0 != rb0 && ra0 != rb1 || ra1 != rb0 && ra1 != rb1 || rb0 != ra0 && rb0 != ra1 || rb1 != ra0 && rb1 != ra1) 
                return 1;
            if (ra0 == ra1 && ra1 == rb0 && rb0 == rb1) {
                return ra0 != null && (this.mvThresh(mvA0, mvB0) || this.mvThresh(mvA1, mvB0) || this.mvThresh(mvA0, mvB1) || this.mvThresh(mvA1, mvB1)) ? 1 : 0;
            } else if (ra0 == rb0 && ra1 == rb1) {
                return ra0 != null && this.mvThresh(mvA0, mvB0) || ra1 != null && this.mvThresh(mvA1, mvB1) ? 1 : 0;
            } else if (ra0 == rb1 && ra1 == rb0) {
                return ra0 != null && this.mvThresh(mvA0, mvB1) || ra1 != null && this.mvThresh(mvA1, mvB0) ? 1 : 0;
            }
        }
        return 0;
    };
    prototype.mvThresh = function(v0, v1) {
        return Math.abs(v0[0] - v1[0]) >= 4 || Math.abs(v0[1] - v1[1]) >= 4;
    };
    constructor.getIdxBeta = function(sliceBetaOffset, avgQp) {
        return MathUtil.clip(avgQp + sliceBetaOffset, 0, 51);
    };
    constructor.getIdxAlpha = function(sliceAlphaC0Offset, avgQp) {
        return MathUtil.clip(avgQp + sliceAlphaC0Offset, 0, 51);
    };
    prototype.calcBsH = function(pic, mbAddr, bs) {
        var sh = this.di.shs[mbAddr];
        var mbWidth = sh.sps.pic_width_in_mbs_minus1 + 1;
        var mbX = mbAddr % mbWidth;
        var mbY = stjs.trunc(mbAddr / mbWidth);
        var topAvailable = mbY > 0 && (sh.disable_deblocking_filter_idc != 2 || this.di.shs[mbAddr - mbWidth] == sh);
        var thisIntra = this.di.mbTypes[mbAddr] != null && this.di.mbTypes[mbAddr].isIntra();
        if (topAvailable) {
            var topIntra = this.di.mbTypes[mbAddr - mbWidth] != null && this.di.mbTypes[mbAddr - mbWidth].isIntra();
            for (var blkX = 0; blkX < 4; blkX++) {
                var thisBlkX = (mbX << 2) + blkX;
                var thisBlkY = (mbY << 2);
                bs[0][blkX] = this.calcBoundaryStrenth(true, topIntra, thisIntra, this.di.nCoeff[thisBlkY][thisBlkX], this.di.nCoeff[thisBlkY - 1][thisBlkX], this.di.mvs[0][thisBlkY][thisBlkX], this.di.mvs[0][thisBlkY - 1][thisBlkX], this.di.mvs[1][thisBlkY][thisBlkX], this.di.mvs[1][thisBlkY - 1][thisBlkX], mbAddr, mbAddr - mbWidth);
            }
        }
        for (var blkY = 1; blkY < 4; blkY++) {
            for (var blkX = 0; blkX < 4; blkX++) {
                var thisBlkX = (mbX << 2) + blkX;
                var thisBlkY = (mbY << 2) + blkY;
                bs[blkY][blkX] = this.calcBoundaryStrenth(false, thisIntra, thisIntra, this.di.nCoeff[thisBlkY][thisBlkX], this.di.nCoeff[thisBlkY - 1][thisBlkX], this.di.mvs[0][thisBlkY][thisBlkX], this.di.mvs[0][thisBlkY - 1][thisBlkX], this.di.mvs[1][thisBlkY][thisBlkX], this.di.mvs[1][thisBlkY - 1][thisBlkX], mbAddr, mbAddr);
            }
        }
    };
    prototype.fillHorizontalEdge = function(pic, comp, mbAddr, bs) {
        var sh = this.di.shs[mbAddr];
        var mbWidth = sh.sps.pic_width_in_mbs_minus1 + 1;
        var alpha = sh.slice_alpha_c0_offset_div2 << 1;
        var beta = sh.slice_beta_offset_div2 << 1;
        var mbX = mbAddr % mbWidth;
        var mbY = stjs.trunc(mbAddr / mbWidth);
        var topAvailable = mbY > 0 && (sh.disable_deblocking_filter_idc != 2 || this.di.shs[mbAddr - mbWidth] == sh);
        var curQp = this.di.mbQps[comp][mbAddr];
        var cW = 2 - pic.getColor().compWidth[comp];
        var cH = 2 - pic.getColor().compHeight[comp];
        if (topAvailable) {
            var topQp = this.di.mbQps[comp][mbAddr - mbWidth];
            var avgQp = (topQp + curQp + 1) >> 1;
            for (var blkX = 0; blkX < 4; blkX++) {
                var thisBlkX = (mbX << 2) + blkX;
                var thisBlkY = (mbY << 2);
                this.filterBlockEdgeHoris(pic, comp, thisBlkX << cW, thisBlkY << cH, DeblockingFilter.getIdxAlpha(alpha, avgQp), DeblockingFilter.getIdxBeta(beta, avgQp), bs[0][blkX], 1 << cW);
            }
        }
        var skip4x4 = comp == 0 && this.di.tr8x8Used[mbAddr] || cH == 1;
        for (var blkY = 1; blkY < 4; blkY++) {
            if (skip4x4 && (blkY & 1) == 1) 
                continue;
            for (var blkX = 0; blkX < 4; blkX++) {
                var thisBlkX = (mbX << 2) + blkX;
                var thisBlkY = (mbY << 2) + blkY;
                this.filterBlockEdgeHoris(pic, comp, thisBlkX << cW, thisBlkY << cH, DeblockingFilter.getIdxAlpha(alpha, curQp), DeblockingFilter.getIdxBeta(beta, curQp), bs[blkY][blkX], 1 << cW);
            }
        }
    };
    prototype.calcBsV = function(pic, mbAddr, bs) {
        var sh = this.di.shs[mbAddr];
        var mbWidth = sh.sps.pic_width_in_mbs_minus1 + 1;
        var mbX = mbAddr % mbWidth;
        var mbY = stjs.trunc(mbAddr / mbWidth);
        var leftAvailable = mbX > 0 && (sh.disable_deblocking_filter_idc != 2 || this.di.shs[mbAddr - 1] == sh);
        var thisIntra = this.di.mbTypes[mbAddr] != null && this.di.mbTypes[mbAddr].isIntra();
        if (leftAvailable) {
            var leftIntra = this.di.mbTypes[mbAddr - 1] != null && this.di.mbTypes[mbAddr - 1].isIntra();
            for (var blkY = 0; blkY < 4; blkY++) {
                var thisBlkX = (mbX << 2);
                var thisBlkY = (mbY << 2) + blkY;
                bs[blkY][0] = this.calcBoundaryStrenth(true, leftIntra, thisIntra, this.di.nCoeff[thisBlkY][thisBlkX], this.di.nCoeff[thisBlkY][thisBlkX - 1], this.di.mvs[0][thisBlkY][thisBlkX], this.di.mvs[0][thisBlkY][thisBlkX - 1], this.di.mvs[1][thisBlkY][thisBlkX], this.di.mvs[1][thisBlkY][thisBlkX - 1], mbAddr, mbAddr - 1);
            }
        }
        for (var blkX = 1; blkX < 4; blkX++) {
            for (var blkY = 0; blkY < (1 << 2); blkY++) {
                var thisBlkX = (mbX << 2) + blkX;
                var thisBlkY = (mbY << 2) + blkY;
                bs[blkY][blkX] = this.calcBoundaryStrenth(false, thisIntra, thisIntra, this.di.nCoeff[thisBlkY][thisBlkX], this.di.nCoeff[thisBlkY][thisBlkX - 1], this.di.mvs[0][thisBlkY][thisBlkX], this.di.mvs[0][thisBlkY][thisBlkX - 1], this.di.mvs[1][thisBlkY][thisBlkX], this.di.mvs[1][thisBlkY][thisBlkX - 1], mbAddr, mbAddr);
            }
        }
    };
    prototype.fillVerticalEdge = function(pic, comp, mbAddr, bs) {
        var sh = this.di.shs[mbAddr];
        var mbWidth = sh.sps.pic_width_in_mbs_minus1 + 1;
        var alpha = sh.slice_alpha_c0_offset_div2 << 1;
        var beta = sh.slice_beta_offset_div2 << 1;
        var mbX = mbAddr % mbWidth;
        var mbY = stjs.trunc(mbAddr / mbWidth);
        var leftAvailable = mbX > 0 && (sh.disable_deblocking_filter_idc != 2 || this.di.shs[mbAddr - 1] == sh);
        var curQp = this.di.mbQps[comp][mbAddr];
        var cW = 2 - pic.getColor().compWidth[comp];
        var cH = 2 - pic.getColor().compHeight[comp];
        if (leftAvailable) {
            var leftQp = this.di.mbQps[comp][mbAddr - 1];
            var avgQpV = (leftQp + curQp + 1) >> 1;
            for (var blkY = 0; blkY < 4; blkY++) {
                var thisBlkX = (mbX << 2);
                var thisBlkY = (mbY << 2) + blkY;
                this.filterBlockEdgeVert(pic, comp, thisBlkX << cW, thisBlkY << cH, DeblockingFilter.getIdxAlpha(alpha, avgQpV), DeblockingFilter.getIdxBeta(beta, avgQpV), bs[blkY][0], 1 << cH);
            }
        }
        var skip4x4 = comp == 0 && this.di.tr8x8Used[mbAddr] || cW == 1;
        for (var blkX = 1; blkX < 4; blkX++) {
            if (skip4x4 && (blkX & 1) == 1) 
                continue;
            for (var blkY = 0; blkY < 4; blkY++) {
                var thisBlkX = (mbX << 2) + blkX;
                var thisBlkY = (mbY << 2) + blkY;
                this.filterBlockEdgeVert(pic, comp, thisBlkX << cW, thisBlkY << cH, DeblockingFilter.getIdxAlpha(alpha, curQp), DeblockingFilter.getIdxBeta(beta, curQp), bs[blkY][blkX], 1 << cH);
            }
        }
    };
    prototype.filterBlockEdgeHoris = function(pic, comp, x, y, indexAlpha, indexBeta, bs, blkW) {
        var stride = pic.getPlaneWidth(comp);
        var offset = y * stride + x;
        for (var pixOff = 0; pixOff < blkW; pixOff++) {
            var p2Idx = offset - 3 * stride + pixOff;
            var p1Idx = offset - 2 * stride + pixOff;
            var p0Idx = offset - stride + pixOff;
            var q0Idx = offset + pixOff;
            var q1Idx = offset + stride + pixOff;
            var q2Idx = offset + 2 * stride + pixOff;
            if (bs == 4) {
                var p3Idx = offset - 4 * stride + pixOff;
                var q3Idx = offset + 3 * stride + pixOff;
                DeblockingFilter.filterBs4(indexAlpha, indexBeta, pic.getPlaneData(comp), pic.getPlaneData(comp), p3Idx, p2Idx, p1Idx, p0Idx, q0Idx, q1Idx, q2Idx, q3Idx, comp != 0);
            } else if (bs > 0) {
                DeblockingFilter.filterBs(bs, indexAlpha, indexBeta, pic.getPlaneData(comp), pic.getPlaneData(comp), p2Idx, p1Idx, p0Idx, q0Idx, q1Idx, q2Idx, comp != 0);
            }
        }
    };
    prototype.filterBlockEdgeVert = function(pic, comp, x, y, indexAlpha, indexBeta, bs, blkH) {
        var stride = pic.getPlaneWidth(comp);
        for (var i = 0; i < blkH; i++) {
            var offsetQ = (y + i) * stride + x;
            var p2Idx = offsetQ - 3;
            var p1Idx = offsetQ - 2;
            var p0Idx = offsetQ - 1;
            var q0Idx = offsetQ;
            var q1Idx = offsetQ + 1;
            var q2Idx = offsetQ + 2;
            if (bs == 4) {
                var p3Idx = offsetQ - 4;
                var q3Idx = offsetQ + 3;
                DeblockingFilter.filterBs4(indexAlpha, indexBeta, pic.getPlaneData(comp), pic.getPlaneData(comp), p3Idx, p2Idx, p1Idx, p0Idx, q0Idx, q1Idx, q2Idx, q3Idx, comp != 0);
            } else if (bs > 0) {
                DeblockingFilter.filterBs(bs, indexAlpha, indexBeta, pic.getPlaneData(comp), pic.getPlaneData(comp), p2Idx, p1Idx, p0Idx, q0Idx, q1Idx, q2Idx, comp != 0);
            }
        }
    };
    constructor.filterBs = function(bs, indexAlpha, indexBeta, pelsP, pelsQ, p2Idx, p1Idx, p0Idx, q0Idx, q1Idx, q2Idx, isChroma) {
        var p1 = pelsP[p1Idx];
        var p0 = pelsP[p0Idx];
        var q0 = pelsQ[q0Idx];
        var q1 = pelsQ[q1Idx];
        var alphaThresh = DeblockingFilter.alphaTab[indexAlpha];
        var betaThresh = DeblockingFilter.betaTab[indexBeta];
        var filterEnabled = Math.abs(p0 - q0) < alphaThresh && Math.abs(p1 - p0) < betaThresh && Math.abs(q1 - q0) < betaThresh;
        if (!filterEnabled) 
            return;
        var tC0 = DeblockingFilter.tcs[bs - 1][indexAlpha];
        var conditionP, conditionQ;
        var tC;
        if (!isChroma) {
            var ap = Math.abs(pelsP[p2Idx] - p0);
            var aq = Math.abs(pelsQ[q2Idx] - q0);
            tC = tC0 + ((ap < betaThresh) ? 1 : 0) + ((aq < betaThresh) ? 1 : 0);
            conditionP = ap < betaThresh;
            conditionQ = aq < betaThresh;
        } else {
            tC = tC0 + 1;
            conditionP = false;
            conditionQ = false;
        }
        var sigma = ((((q0 - p0) << 2) + (p1 - q1) + 4) >> 3);
        sigma = sigma < -tC ? -tC : (sigma > tC ? tC : sigma);
        var p0n = p0 + sigma;
        p0n = p0n < -128 ? -128 : p0n;
        var q0n = q0 - sigma;
        q0n = q0n < -128 ? -128 : q0n;
        if (conditionP) {
            var p2 = pelsP[p2Idx];
            var diff = (p2 + ((p0 + q0 + 1) >> 1) - (p1 << 1)) >> 1;
            diff = diff < -tC0 ? -tC0 : (diff > tC0 ? tC0 : diff);
            var p1n = p1 + diff;
            pelsP[p1Idx] = (MathUtil.clip(p1n, -128, 127) << 24 >> 24);
        }
        if (conditionQ) {
            var q2 = pelsQ[q2Idx];
            var diff = (q2 + ((p0 + q0 + 1) >> 1) - (q1 << 1)) >> 1;
            diff = diff < -tC0 ? -tC0 : (diff > tC0 ? tC0 : diff);
            var q1n = q1 + diff;
            pelsQ[q1Idx] = (MathUtil.clip(q1n, -128, 127) << 24 >> 24);
        }
        pelsQ[q0Idx] = (MathUtil.clip(q0n, -128, 127) << 24 >> 24);
        pelsP[p0Idx] = (MathUtil.clip(p0n, -128, 127) << 24 >> 24);
    };
    constructor.filterBs4 = function(indexAlpha, indexBeta, pelsP, pelsQ, p3Idx, p2Idx, p1Idx, p0Idx, q0Idx, q1Idx, q2Idx, q3Idx, isChroma) {
        var p0 = pelsP[p0Idx];
        var q0 = pelsQ[q0Idx];
        var p1 = pelsP[p1Idx];
        var q1 = pelsQ[q1Idx];
        var alphaThresh = DeblockingFilter.alphaTab[indexAlpha];
        var betaThresh = DeblockingFilter.betaTab[indexBeta];
        var filterEnabled = Math.abs(p0 - q0) < alphaThresh && Math.abs(p1 - p0) < betaThresh && Math.abs(q1 - q0) < betaThresh;
        if (!filterEnabled) 
            return;
        var conditionP, conditionQ;
        if (isChroma) {
            conditionP = false;
            conditionQ = false;
        } else {
            var ap = Math.abs(pelsP[p2Idx] - p0);
            var aq = Math.abs(pelsQ[q2Idx] - q0);
            conditionP = ap < betaThresh && Math.abs(p0 - q0) < ((alphaThresh >> 2) + 2);
            conditionQ = aq < betaThresh && Math.abs(p0 - q0) < ((alphaThresh >> 2) + 2);
        }
        if (conditionP) {
            var p3 = pelsP[p3Idx];
            var p2 = pelsP[p2Idx];
            var p0n = (p2 + 2 * p1 + 2 * p0 + 2 * q0 + q1 + 4) >> 3;
            var p1n = (p2 + p1 + p0 + q0 + 2) >> 2;
            var p2n = (2 * p3 + 3 * p2 + p1 + p0 + q0 + 4) >> 3;
            pelsP[p0Idx] = (MathUtil.clip(p0n, -128, 127) << 24 >> 24);
            pelsP[p1Idx] = (MathUtil.clip(p1n, -128, 127) << 24 >> 24);
            pelsP[p2Idx] = (MathUtil.clip(p2n, -128, 127) << 24 >> 24);
        } else {
            var p0n = (2 * p1 + p0 + q1 + 2) >> 2;
            pelsP[p0Idx] = (MathUtil.clip(p0n, -128, 127) << 24 >> 24);
        }
        if (conditionQ && !isChroma) {
            var q2 = pelsQ[q2Idx];
            var q3 = pelsQ[q3Idx];
            var q0n = (p1 + 2 * p0 + 2 * q0 + 2 * q1 + q2 + 4) >> 3;
            var q1n = (p0 + q0 + q1 + q2 + 2) >> 2;
            var q2n = (2 * q3 + 3 * q2 + q1 + q0 + p0 + 4) >> 3;
            pelsQ[q0Idx] = (MathUtil.clip(q0n, -128, 127) << 24 >> 24);
            pelsQ[q1Idx] = (MathUtil.clip(q1n, -128, 127) << 24 >> 24);
            pelsQ[q2Idx] = (MathUtil.clip(q2n, -128, 127) << 24 >> 24);
        } else {
            var q0n = (2 * q1 + q0 + p1 + 2) >> 2;
            pelsQ[q0Idx] = (MathUtil.clip(q0n, -128, 127) << 24 >> 24);
        }
    };
}, {alphaTab: "Int32Array", betaTab: "Int32Array", tcs: "Array", di: "DeblockerInput", inverse: "Int32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var MBEncoderHelper = function() {};
MBEncoderHelper = stjs.extend(MBEncoderHelper, null, [], function(constructor, prototype) {
    constructor.takeSubtract = function(planeData, planeWidth, planeHeight, x, y, coeff, pred, blkW, blkH) {
        if (x + blkW < planeWidth && y + blkH < planeHeight) 
            MBEncoderHelper.takeSubtractSafe(planeData, planeWidth, planeHeight, x, y, coeff, pred, blkW, blkH);
         else 
            MBEncoderHelper.takeSubtractUnsafe(planeData, planeWidth, planeHeight, x, y, coeff, pred, blkW, blkH);
    };
    constructor.takeSubtractSafe = function(planeData, planeWidth, planeHeight, x, y, coeff, pred, blkW, blkH) {
        for (var i = 0, srcOff = y * planeWidth + x, dstOff = 0; i < blkH; i++ , srcOff += planeWidth) {
            for (var j = 0, srcOff1 = srcOff; j < blkW; j += 4 , dstOff += 4 , srcOff1 += 4) {
                coeff[dstOff] = planeData[srcOff1] - pred[dstOff];
                coeff[dstOff + 1] = planeData[srcOff1 + 1] - pred[dstOff + 1];
                coeff[dstOff + 2] = planeData[srcOff1 + 2] - pred[dstOff + 2];
                coeff[dstOff + 3] = planeData[srcOff1 + 3] - pred[dstOff + 3];
            }
        }
    };
    constructor.take = function(planeData, planeWidth, planeHeight, x, y, patch, blkW, blkH) {
        if (x + blkW < planeWidth && y + blkH < planeHeight) 
            MBEncoderHelper.takeSafe(planeData, planeWidth, planeHeight, x, y, patch, blkW, blkH);
         else 
            MBEncoderHelper.takeExtendBorder(planeData, planeWidth, planeHeight, x, y, patch, blkW, blkH);
    };
    constructor.takeSafe = function(planeData, planeWidth, planeHeight, x, y, patch, blkW, blkH) {
        for (var i = 0, srcOff = y * planeWidth + x, dstOff = 0; i < blkH; i++ , srcOff += planeWidth) {
            for (var j = 0, srcOff1 = srcOff; j < blkW; ++j , ++dstOff , ++srcOff1) {
                patch[dstOff] = planeData[srcOff1];
            }
        }
    };
    constructor.takeExtendBorder = function(planeData, planeWidth, planeHeight, x, y, patch, blkW, blkH) {
        var outOff = 0;
        var i;
        for (i = y; i < Math.min(y + blkH, planeHeight); i++) {
            var off = i * planeWidth + Math.min(x, planeWidth);
            var j;
            for (j = x; j < Math.min(x + blkW, planeWidth); j++ , outOff++ , off++) {
                patch[outOff] = planeData[off];
            }
            --off;
            for (; j < x + blkW; j++ , outOff++) {
                patch[outOff] = planeData[off];
            }
        }
        for (; i < y + blkH; i++) {
            var off = planeHeight * planeWidth - planeWidth + Math.min(x, planeWidth);
            var j;
            for (j = x; j < Math.min(x + blkW, planeWidth); j++ , outOff++ , off++) {
                patch[outOff] = planeData[off];
            }
            --off;
            for (; j < x + blkW; j++ , outOff++) {
                patch[outOff] = planeData[off];
            }
        }
    };
    constructor.takeSafe2 = function(planeData, planeWidth, planeHeight, x, y, coeff, blkW, blkH) {
        for (var i = 0, srcOff = y * planeWidth + x, dstOff = 0; i < blkH; i++ , srcOff += planeWidth) {
            for (var j = 0, srcOff1 = srcOff; j < blkW; ++j , ++dstOff , ++srcOff1) {
                coeff[dstOff] = planeData[srcOff1];
            }
        }
    };
    constructor.takeSubtractUnsafe = function(planeData, planeWidth, planeHeight, x, y, coeff, pred, blkW, blkH) {
        var outOff = 0;
        var i;
        for (i = y; i < Math.min(y + blkH, planeHeight); i++) {
            var off = i * planeWidth + Math.min(x, planeWidth);
            var j;
            for (j = x; j < Math.min(x + blkW, planeWidth); j++ , outOff++ , off++) {
                coeff[outOff] = planeData[off] - pred[outOff];
            }
            --off;
            for (; j < x + blkW; j++ , outOff++) {
                coeff[outOff] = planeData[off] - pred[outOff];
            }
        }
        for (; i < y + blkH; i++) {
            var off = planeHeight * planeWidth - planeWidth + Math.min(x, planeWidth);
            var j;
            for (j = x; j < Math.min(x + blkW, planeWidth); j++ , outOff++ , off++) {
                coeff[outOff] = planeData[off] - pred[outOff];
            }
            --off;
            for (; j < x + blkW; j++ , outOff++) {
                coeff[outOff] = planeData[off] - pred[outOff];
            }
        }
    };
    constructor.putBlk = function(planeData, block, pred, log2stride, blkX, blkY, blkW, blkH) {
        var stride = 1 << log2stride;
        for (var line = 0, srcOff = 0, dstOff = (blkY << log2stride) + blkX; line < blkH; line++) {
            var dstOff1 = dstOff;
            for (var row = 0; row < blkW; row += 4) {
                planeData[dstOff1] = (MathUtil.clip(block[srcOff] + pred[srcOff], -128, 127) << 24 >> 24);
                planeData[dstOff1 + 1] = (MathUtil.clip(block[srcOff + 1] + pred[srcOff + 1], -128, 127) << 24 >> 24);
                planeData[dstOff1 + 2] = (MathUtil.clip(block[srcOff + 2] + pred[srcOff + 2], -128, 127) << 24 >> 24);
                planeData[dstOff1 + 3] = (MathUtil.clip(block[srcOff + 3] + pred[srcOff + 3], -128, 127) << 24 >> 24);
                srcOff += 4;
                dstOff1 += 4;
            }
            dstOff += stride;
        }
    };
    constructor.putBlkPic = function(dest, src, x, y) {
        if (dest.getColor() != src.getColor()) 
             throw new RuntimeException("Incompatible color");
        for (var c = 0; c < dest.getColor().nComp; c++) {
            MBEncoderHelper.pubBlkOnePlane(dest.getPlaneData(c), dest.getPlaneWidth(c), src.getPlaneData(c), src.getPlaneWidth(c), src.getPlaneHeight(c), x >> dest.getColor().compWidth[c], y >> dest.getColor().compHeight[c]);
        }
    };
    constructor.pubBlkOnePlane = function(dest, destWidth, src, srcWidth, srcHeight, x, y) {
        var destOff = y * destWidth + x;
        var srcOff = 0;
        for (var i = 0; i < srcHeight; i++) {
            for (var j = 0; j < srcWidth; j++ , ++destOff , ++srcOff) 
                dest[destOff] = src[srcOff];
            destOff += destWidth - srcWidth;
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Builds intra prediction for intra 4x4 coded macroblocks
 *  
 *  @author The JCodec project
 *  
 */
var Intra4x4PredictionBuilder = function() {};
Intra4x4PredictionBuilder = stjs.extend(Intra4x4PredictionBuilder, null, [], function(constructor, prototype) {
    constructor.predictWithMode = function(mode, residual, leftAvailable, topAvailable, topRightAvailable, leftRow, topLine, topLeft, mbOffX, blkX, blkY, pixOut) {
        switch (mode) {
            case 0:
                Intra4x4PredictionBuilder.predictVertical(residual, topAvailable, topLine, mbOffX, blkX, blkY, pixOut);
                break;
            case 1:
                Intra4x4PredictionBuilder.predictHorizontal(residual, leftAvailable, leftRow, mbOffX, blkX, blkY, pixOut);
                break;
            case 2:
                Intra4x4PredictionBuilder.predictDC(residual, leftAvailable, topAvailable, leftRow, topLine, mbOffX, blkX, blkY, pixOut);
                break;
            case 3:
                Intra4x4PredictionBuilder.predictDiagonalDownLeft(residual, topAvailable, topRightAvailable, topLine, mbOffX, blkX, blkY, pixOut);
                break;
            case 4:
                Intra4x4PredictionBuilder.predictDiagonalDownRight(residual, leftAvailable, topAvailable, leftRow, topLine, topLeft, mbOffX, blkX, blkY, pixOut);
                break;
            case 5:
                Intra4x4PredictionBuilder.predictVerticalRight(residual, leftAvailable, topAvailable, leftRow, topLine, topLeft, mbOffX, blkX, blkY, pixOut);
                break;
            case 6:
                Intra4x4PredictionBuilder.predictHorizontalDown(residual, leftAvailable, topAvailable, leftRow, topLine, topLeft, mbOffX, blkX, blkY, pixOut);
                break;
            case 7:
                Intra4x4PredictionBuilder.predictVerticalLeft(residual, topAvailable, topRightAvailable, topLine, mbOffX, blkX, blkY, pixOut);
                break;
            case 8:
                Intra4x4PredictionBuilder.predictHorizontalUp(residual, leftAvailable, leftRow, mbOffX, blkX, blkY, pixOut);
                break;
        }
        var oo1 = mbOffX + blkX;
        var off1 = (blkY << 4) + blkX + 3;
        topLeft[blkY >> 2] = topLine[oo1 + 3];
        leftRow[blkY] = pixOut[off1];
        leftRow[blkY + 1] = pixOut[off1 + 16];
        leftRow[blkY + 2] = pixOut[off1 + 32];
        leftRow[blkY + 3] = pixOut[off1 + 48];
        var off2 = (blkY << 4) + blkX + 48;
        topLine[oo1] = pixOut[off2];
        topLine[oo1 + 1] = pixOut[off2 + 1];
        topLine[oo1 + 2] = pixOut[off2 + 2];
        topLine[oo1 + 3] = pixOut[off2 + 3];
    };
    constructor.predictVertical = function(residual, topAvailable, topLine, mbOffX, blkX, blkY, pixOut) {
        var pixOff = (blkY << 4) + blkX;
        var toff = mbOffX + blkX;
        var rOff = 0;
        for (var j = 0; j < 4; ++j) {
            pixOut[pixOff] = (MathUtil.clip(residual[rOff] + topLine[toff], -128, 127) << 24 >> 24);
            pixOut[pixOff + 1] = (MathUtil.clip(residual[rOff + 1] + topLine[toff + 1], -128, 127) << 24 >> 24);
            pixOut[pixOff + 2] = (MathUtil.clip(residual[rOff + 2] + topLine[toff + 2], -128, 127) << 24 >> 24);
            pixOut[pixOff + 3] = (MathUtil.clip(residual[rOff + 3] + topLine[toff + 3], -128, 127) << 24 >> 24);
            rOff += 4;
            pixOff += 16;
        }
    };
    constructor.predictHorizontal = function(residual, leftAvailable, leftRow, mbOffX, blkX, blkY, pixOut) {
        var pixOff = (blkY << 4) + blkX;
        var rOff = 0;
        for (var j = 0; j < 4; j++) {
            var l = leftRow[blkY + j];
            pixOut[pixOff] = (MathUtil.clip(residual[rOff] + l, -128, 127) << 24 >> 24);
            pixOut[pixOff + 1] = (MathUtil.clip(residual[rOff + 1] + l, -128, 127) << 24 >> 24);
            pixOut[pixOff + 2] = (MathUtil.clip(residual[rOff + 2] + l, -128, 127) << 24 >> 24);
            pixOut[pixOff + 3] = (MathUtil.clip(residual[rOff + 3] + l, -128, 127) << 24 >> 24);
            rOff += 4;
            pixOff += 16;
        }
    };
    constructor.predictDC = function(residual, leftAvailable, topAvailable, leftRow, topLine, mbOffX, blkX, blkY, pixOut) {
        var val;
        if (leftAvailable && topAvailable) {
            val = (leftRow[blkY] + leftRow[blkY + 1] + leftRow[blkY + 2] + leftRow[blkY + 3] + topLine[mbOffX + blkX] + topLine[mbOffX + blkX + 1] + topLine[mbOffX + blkX + 2] + topLine[mbOffX + blkX + 3] + 4) >> 3;
        } else if (leftAvailable) {
            val = (leftRow[blkY] + leftRow[blkY + 1] + leftRow[blkY + 2] + leftRow[blkY + 3] + 2) >> 2;
        } else if (topAvailable) {
            val = (topLine[mbOffX + blkX] + topLine[mbOffX + blkX + 1] + topLine[mbOffX + blkX + 2] + topLine[mbOffX + blkX + 3] + 2) >> 2;
        } else {
            val = 0;
        }
        var pixOff = (blkY << 4) + blkX;
        var rOff = 0;
        for (var j = 0; j < 4; j++) {
            pixOut[pixOff] = (MathUtil.clip(residual[rOff] + val, -128, 127) << 24 >> 24);
            pixOut[pixOff + 1] = (MathUtil.clip(residual[rOff + 1] + val, -128, 127) << 24 >> 24);
            pixOut[pixOff + 2] = (MathUtil.clip(residual[rOff + 2] + val, -128, 127) << 24 >> 24);
            pixOut[pixOff + 3] = (MathUtil.clip(residual[rOff + 3] + val, -128, 127) << 24 >> 24);
            pixOff += 16;
            rOff += 4;
        }
    };
    constructor.predictDiagonalDownLeft = function(residual, topAvailable, topRightAvailable, topLine, mbOffX, blkX, blkY, pixOut) {
        var to = mbOffX + blkX;
        var tr0 = topLine[to + 3], tr1 = topLine[to + 3], tr2 = topLine[to + 3], tr3 = topLine[to + 3];
        if (topRightAvailable) {
            tr0 = topLine[to + 4];
            tr1 = topLine[to + 5];
            tr2 = topLine[to + 6];
            tr3 = topLine[to + 7];
        }
        var c0 = ((topLine[to] + topLine[to + 2] + (topLine[to + 1] << 1) + 2) >> 2);
        var c1 = ((topLine[to + 1] + topLine[to + 3] + (topLine[to + 2] << 1) + 2) >> 2);
        var c2 = ((topLine[to + 2] + tr0 + (topLine[to + 3] << 1) + 2) >> 2);
        var c3 = ((topLine[to + 3] + tr1 + (tr0 << 1) + 2) >> 2);
        var c4 = ((tr0 + tr2 + (tr1 << 1) + 2) >> 2);
        var c5 = ((tr1 + tr3 + (tr2 << 1) + 2) >> 2);
        var c6 = ((tr2 + 3 * (tr3) + 2) >> 2);
        var off = (blkY << 4) + blkX;
        pixOut[off] = (MathUtil.clip(residual[0] + c0, -128, 127) << 24 >> 24);
        pixOut[off + 1] = (MathUtil.clip(residual[1] + c1, -128, 127) << 24 >> 24);
        pixOut[off + 2] = (MathUtil.clip(residual[2] + c2, -128, 127) << 24 >> 24);
        pixOut[off + 3] = (MathUtil.clip(residual[3] + c3, -128, 127) << 24 >> 24);
        pixOut[off + 16] = (MathUtil.clip(residual[4] + c1, -128, 127) << 24 >> 24);
        pixOut[off + 17] = (MathUtil.clip(residual[5] + c2, -128, 127) << 24 >> 24);
        pixOut[off + 18] = (MathUtil.clip(residual[6] + c3, -128, 127) << 24 >> 24);
        pixOut[off + 19] = (MathUtil.clip(residual[7] + c4, -128, 127) << 24 >> 24);
        pixOut[off + 32] = (MathUtil.clip(residual[8] + c2, -128, 127) << 24 >> 24);
        pixOut[off + 33] = (MathUtil.clip(residual[9] + c3, -128, 127) << 24 >> 24);
        pixOut[off + 34] = (MathUtil.clip(residual[10] + c4, -128, 127) << 24 >> 24);
        pixOut[off + 35] = (MathUtil.clip(residual[11] + c5, -128, 127) << 24 >> 24);
        pixOut[off + 48] = (MathUtil.clip(residual[12] + c3, -128, 127) << 24 >> 24);
        pixOut[off + 49] = (MathUtil.clip(residual[13] + c4, -128, 127) << 24 >> 24);
        pixOut[off + 50] = (MathUtil.clip(residual[14] + c5, -128, 127) << 24 >> 24);
        pixOut[off + 51] = (MathUtil.clip(residual[15] + c6, -128, 127) << 24 >> 24);
    };
    constructor.predictDiagonalDownRight = function(residual, leftAvailable, topAvailable, leftRow, topLine, topLeft, mbOffX, blkX, blkY, pixOut) {
        var off = (blkY << 4) + blkX;
        var c0 = ((topLine[mbOffX + blkX] + 2 * topLeft[blkY >> 2] + leftRow[blkY] + 2) >> 2);
        var c1 = ((topLeft[blkY >> 2] + (topLine[mbOffX + blkX + 0] << 1) + topLine[mbOffX + blkX + 1] + 2) >> 2);
        var c2 = ((topLine[mbOffX + blkX] + (topLine[mbOffX + blkX + 1] << 1) + topLine[mbOffX + blkX + 2] + 2) >> 2);
        var c3 = ((topLine[mbOffX + blkX + 1] + (topLine[mbOffX + blkX + 2] << 1) + topLine[mbOffX + blkX + 3] + 2) >> 2);
        pixOut[off] = (MathUtil.clip(residual[0] + c0, -128, 127) << 24 >> 24);
        pixOut[off + 1] = (MathUtil.clip(residual[1] + c1, -128, 127) << 24 >> 24);
        pixOut[off + 2] = (MathUtil.clip(residual[2] + c2, -128, 127) << 24 >> 24);
        pixOut[off + 3] = (MathUtil.clip(residual[3] + c3, -128, 127) << 24 >> 24);
        var c4 = ((topLeft[blkY >> 2] + (leftRow[blkY] << 1) + leftRow[blkY + 1] + 2) >> 2);
        var c6 = ((topLeft[blkY >> 2] + (topLine[mbOffX + blkX] << 1) + topLine[mbOffX + blkX + 1] + 2) >> 2);
        var c7 = ((topLine[mbOffX + blkX] + (topLine[mbOffX + blkX + 1] << 1) + topLine[mbOffX + blkX + 2] + 2) >> 2);
        pixOut[off + 16] = (MathUtil.clip(residual[4] + c4, -128, 127) << 24 >> 24);
        pixOut[off + 17] = (MathUtil.clip(residual[5] + c0, -128, 127) << 24 >> 24);
        pixOut[off + 18] = (MathUtil.clip(residual[6] + c6, -128, 127) << 24 >> 24);
        pixOut[off + 19] = (MathUtil.clip(residual[7] + c7, -128, 127) << 24 >> 24);
        var c8 = ((leftRow[blkY + 0] + (leftRow[blkY + 1] << 1) + leftRow[blkY + 2] + 2) >> 2);
        var c9 = ((topLeft[blkY >> 2] + (leftRow[blkY] << 1) + leftRow[blkY + 1] + 2) >> 2);
        var c11 = ((topLeft[blkY >> 2] + (topLine[mbOffX + blkX] << 1) + topLine[mbOffX + blkX + 1] + 2) >> 2);
        pixOut[off + 32] = (MathUtil.clip(residual[8] + c8, -128, 127) << 24 >> 24);
        pixOut[off + 33] = (MathUtil.clip(residual[9] + c9, -128, 127) << 24 >> 24);
        pixOut[off + 34] = (MathUtil.clip(residual[10] + c0, -128, 127) << 24 >> 24);
        pixOut[off + 35] = (MathUtil.clip(residual[11] + c11, -128, 127) << 24 >> 24);
        var c12 = ((leftRow[blkY + 1] + (leftRow[blkY + 2] << 1) + leftRow[blkY + 3] + 2) >> 2);
        var c13 = ((leftRow[blkY] + (leftRow[blkY + 1] << 1) + leftRow[blkY + 2] + 2) >> 2);
        var c14 = ((topLeft[blkY >> 2] + (leftRow[blkY] << 1) + leftRow[blkY + 1] + 2) >> 2);
        pixOut[off + 48] = (MathUtil.clip(residual[12] + c12, -128, 127) << 24 >> 24);
        pixOut[off + 49] = (MathUtil.clip(residual[13] + c13, -128, 127) << 24 >> 24);
        pixOut[off + 50] = (MathUtil.clip(residual[14] + c14, -128, 127) << 24 >> 24);
        pixOut[off + 51] = (MathUtil.clip(residual[15] + c0, -128, 127) << 24 >> 24);
    };
    constructor.predictVerticalRight = function(residual, leftAvailable, topAvailable, leftRow, topLine, topLeft, mbOffX, blkX, blkY, pixOut) {
        var v1 = (topLeft[blkY >> 2] + topLine[mbOffX + blkX + 0] + 1) >> 1;
        var v2 = (topLine[mbOffX + blkX + 0] + topLine[mbOffX + blkX + 1] + 1) >> 1;
        var v3 = (topLine[mbOffX + blkX + 1] + topLine[mbOffX + blkX + 2] + 1) >> 1;
        var v4 = (topLine[mbOffX + blkX + 2] + topLine[mbOffX + blkX + 3] + 1) >> 1;
        var v5 = (leftRow[blkY] + 2 * topLeft[blkY >> 2] + topLine[mbOffX + blkX + 0] + 2) >> 2;
        var v6 = (topLeft[blkY >> 2] + 2 * topLine[mbOffX + blkX + 0] + topLine[mbOffX + blkX + 1] + 2) >> 2;
        var v7 = (topLine[mbOffX + blkX + 0] + 2 * topLine[mbOffX + blkX + 1] + topLine[mbOffX + blkX + 2] + 2) >> 2;
        var v8 = (topLine[mbOffX + blkX + 1] + 2 * topLine[mbOffX + blkX + 2] + topLine[mbOffX + blkX + 3] + 2) >> 2;
        var v9 = (topLeft[blkY >> 2] + 2 * leftRow[blkY] + leftRow[blkY + 1] + 2) >> 2;
        var v10 = (leftRow[blkY] + 2 * leftRow[blkY + 1] + leftRow[blkY + 2] + 2) >> 2;
        var off = (blkY << 4) + blkX;
        pixOut[off] = (MathUtil.clip(residual[0] + v1, -128, 127) << 24 >> 24);
        pixOut[off + 1] = (MathUtil.clip(residual[1] + v2, -128, 127) << 24 >> 24);
        pixOut[off + 2] = (MathUtil.clip(residual[2] + v3, -128, 127) << 24 >> 24);
        pixOut[off + 3] = (MathUtil.clip(residual[3] + v4, -128, 127) << 24 >> 24);
        pixOut[off + 16] = (MathUtil.clip(residual[4] + v5, -128, 127) << 24 >> 24);
        pixOut[off + 17] = (MathUtil.clip(residual[5] + v6, -128, 127) << 24 >> 24);
        pixOut[off + 18] = (MathUtil.clip(residual[6] + v7, -128, 127) << 24 >> 24);
        pixOut[off + 19] = (MathUtil.clip(residual[7] + v8, -128, 127) << 24 >> 24);
        pixOut[off + 32] = (MathUtil.clip(residual[8] + v9, -128, 127) << 24 >> 24);
        pixOut[off + 33] = (MathUtil.clip(residual[9] + v1, -128, 127) << 24 >> 24);
        pixOut[off + 34] = (MathUtil.clip(residual[10] + v2, -128, 127) << 24 >> 24);
        pixOut[off + 35] = (MathUtil.clip(residual[11] + v3, -128, 127) << 24 >> 24);
        pixOut[off + 48] = (MathUtil.clip(residual[12] + v10, -128, 127) << 24 >> 24);
        pixOut[off + 49] = (MathUtil.clip(residual[13] + v5, -128, 127) << 24 >> 24);
        pixOut[off + 50] = (MathUtil.clip(residual[14] + v6, -128, 127) << 24 >> 24);
        pixOut[off + 51] = (MathUtil.clip(residual[15] + v7, -128, 127) << 24 >> 24);
    };
    constructor.predictHorizontalDown = function(residual, leftAvailable, topAvailable, leftRow, topLine, topLeft, mbOffX, blkX, blkY, pixOut) {
        var c0 = (topLeft[blkY >> 2] + leftRow[blkY] + 1) >> 1;
        var c1 = (leftRow[blkY] + 2 * topLeft[blkY >> 2] + topLine[mbOffX + blkX + 0] + 2) >> 2;
        var c2 = (topLeft[blkY >> 2] + 2 * topLine[mbOffX + blkX + 0] + topLine[mbOffX + blkX + 1] + 2) >> 2;
        var c3 = (topLine[mbOffX + blkX + 0] + 2 * topLine[mbOffX + blkX + 1] + topLine[mbOffX + blkX + 2] + 2) >> 2;
        var c4 = (leftRow[blkY] + leftRow[blkY + 1] + 1) >> 1;
        var c5 = (topLeft[blkY >> 2] + 2 * leftRow[blkY] + leftRow[blkY + 1] + 2) >> 2;
        var c6 = (leftRow[blkY + 1] + leftRow[blkY + 2] + 1) >> 1;
        var c7 = (leftRow[blkY] + 2 * leftRow[blkY + 1] + leftRow[blkY + 2] + 2) >> 2;
        var c8 = (leftRow[blkY + 2] + leftRow[blkY + 3] + 1) >> 1;
        var c9 = (leftRow[blkY + 1] + 2 * leftRow[blkY + 2] + leftRow[blkY + 3] + 2) >> 2;
        var off = (blkY << 4) + blkX;
        pixOut[off] = (MathUtil.clip(residual[0] + c0, -128, 127) << 24 >> 24);
        pixOut[off + 1] = (MathUtil.clip(residual[1] + c1, -128, 127) << 24 >> 24);
        pixOut[off + 2] = (MathUtil.clip(residual[2] + c2, -128, 127) << 24 >> 24);
        pixOut[off + 3] = (MathUtil.clip(residual[3] + c3, -128, 127) << 24 >> 24);
        pixOut[off + 16] = (MathUtil.clip(residual[4] + c4, -128, 127) << 24 >> 24);
        pixOut[off + 17] = (MathUtil.clip(residual[5] + c5, -128, 127) << 24 >> 24);
        pixOut[off + 18] = (MathUtil.clip(residual[6] + c0, -128, 127) << 24 >> 24);
        pixOut[off + 19] = (MathUtil.clip(residual[7] + c1, -128, 127) << 24 >> 24);
        pixOut[off + 32] = (MathUtil.clip(residual[8] + c6, -128, 127) << 24 >> 24);
        pixOut[off + 33] = (MathUtil.clip(residual[9] + c7, -128, 127) << 24 >> 24);
        pixOut[off + 34] = (MathUtil.clip(residual[10] + c4, -128, 127) << 24 >> 24);
        pixOut[off + 35] = (MathUtil.clip(residual[11] + c5, -128, 127) << 24 >> 24);
        pixOut[off + 48] = (MathUtil.clip(residual[12] + c8, -128, 127) << 24 >> 24);
        pixOut[off + 49] = (MathUtil.clip(residual[13] + c9, -128, 127) << 24 >> 24);
        pixOut[off + 50] = (MathUtil.clip(residual[14] + c6, -128, 127) << 24 >> 24);
        pixOut[off + 51] = (MathUtil.clip(residual[15] + c7, -128, 127) << 24 >> 24);
    };
    constructor.predictVerticalLeft = function(residual, topAvailable, topRightAvailable, topLine, mbOffX, blkX, blkY, pixOut) {
        var to = mbOffX + blkX;
        var tr0 = topLine[to + 3], tr1 = topLine[to + 3], tr2 = topLine[to + 3];
        if (topRightAvailable) {
            tr0 = topLine[to + 4];
            tr1 = topLine[to + 5];
            tr2 = topLine[to + 6];
        }
        var c0 = ((topLine[to] + topLine[to + 1] + 1) >> 1);
        var c1 = ((topLine[to + 1] + topLine[to + 2] + 1) >> 1);
        var c2 = ((topLine[to + 2] + topLine[to + 3] + 1) >> 1);
        var c3 = ((topLine[to + 3] + tr0 + 1) >> 1);
        var c4 = ((tr0 + tr1 + 1) >> 1);
        var c5 = ((topLine[to] + 2 * topLine[to + 1] + topLine[to + 2] + 2) >> 2);
        var c6 = ((topLine[to + 1] + 2 * topLine[to + 2] + topLine[to + 3] + 2) >> 2);
        var c7 = ((topLine[to + 2] + 2 * topLine[to + 3] + tr0 + 2) >> 2);
        var c8 = ((topLine[to + 3] + 2 * tr0 + tr1 + 2) >> 2);
        var c9 = ((tr0 + 2 * tr1 + tr2 + 2) >> 2);
        var off = (blkY << 4) + blkX;
        pixOut[off] = (MathUtil.clip(residual[0] + c0, -128, 127) << 24 >> 24);
        pixOut[off + 1] = (MathUtil.clip(residual[1] + c1, -128, 127) << 24 >> 24);
        pixOut[off + 2] = (MathUtil.clip(residual[2] + c2, -128, 127) << 24 >> 24);
        pixOut[off + 3] = (MathUtil.clip(residual[3] + c3, -128, 127) << 24 >> 24);
        pixOut[off + 16] = (MathUtil.clip(residual[4] + c5, -128, 127) << 24 >> 24);
        pixOut[off + 17] = (MathUtil.clip(residual[5] + c6, -128, 127) << 24 >> 24);
        pixOut[off + 18] = (MathUtil.clip(residual[6] + c7, -128, 127) << 24 >> 24);
        pixOut[off + 19] = (MathUtil.clip(residual[7] + c8, -128, 127) << 24 >> 24);
        pixOut[off + 32] = (MathUtil.clip(residual[8] + c1, -128, 127) << 24 >> 24);
        pixOut[off + 33] = (MathUtil.clip(residual[9] + c2, -128, 127) << 24 >> 24);
        pixOut[off + 34] = (MathUtil.clip(residual[10] + c3, -128, 127) << 24 >> 24);
        pixOut[off + 35] = (MathUtil.clip(residual[11] + c4, -128, 127) << 24 >> 24);
        pixOut[off + 48] = (MathUtil.clip(residual[12] + c6, -128, 127) << 24 >> 24);
        pixOut[off + 49] = (MathUtil.clip(residual[13] + c7, -128, 127) << 24 >> 24);
        pixOut[off + 50] = (MathUtil.clip(residual[14] + c8, -128, 127) << 24 >> 24);
        pixOut[off + 51] = (MathUtil.clip(residual[15] + c9, -128, 127) << 24 >> 24);
    };
    constructor.predictHorizontalUp = function(residual, leftAvailable, leftRow, mbOffX, blkX, blkY, pixOut) {
        var c0 = ((leftRow[blkY] + leftRow[blkY + 1] + 1) >> 1);
        var c1 = ((leftRow[blkY] + (leftRow[blkY + 1] << 1) + leftRow[blkY + 2] + 2) >> 2);
        var c2 = ((leftRow[blkY + 1] + leftRow[blkY + 2] + 1) >> 1);
        var c3 = ((leftRow[blkY + 1] + (leftRow[blkY + 2] << 1) + leftRow[blkY + 3] + 2) >> 2);
        var c4 = ((leftRow[blkY + 2] + leftRow[blkY + 3] + 1) >> 1);
        var c5 = ((leftRow[blkY + 2] + (leftRow[blkY + 3] << 1) + leftRow[blkY + 3] + 2) >> 2);
        var c6 = leftRow[blkY + 3];
        var off = (blkY << 4) + blkX;
        pixOut[off] = (MathUtil.clip(residual[0] + c0, -128, 127) << 24 >> 24);
        pixOut[off + 1] = (MathUtil.clip(residual[1] + c1, -128, 127) << 24 >> 24);
        pixOut[off + 2] = (MathUtil.clip(residual[2] + c2, -128, 127) << 24 >> 24);
        pixOut[off + 3] = (MathUtil.clip(residual[3] + c3, -128, 127) << 24 >> 24);
        pixOut[off + 16] = (MathUtil.clip(residual[4] + c2, -128, 127) << 24 >> 24);
        pixOut[off + 17] = (MathUtil.clip(residual[5] + c3, -128, 127) << 24 >> 24);
        pixOut[off + 18] = (MathUtil.clip(residual[6] + c4, -128, 127) << 24 >> 24);
        pixOut[off + 19] = (MathUtil.clip(residual[7] + c5, -128, 127) << 24 >> 24);
        pixOut[off + 32] = (MathUtil.clip(residual[8] + c4, -128, 127) << 24 >> 24);
        pixOut[off + 33] = (MathUtil.clip(residual[9] + c5, -128, 127) << 24 >> 24);
        pixOut[off + 34] = (MathUtil.clip(residual[10] + c6, -128, 127) << 24 >> 24);
        pixOut[off + 35] = (MathUtil.clip(residual[11] + c6, -128, 127) << 24 >> 24);
        pixOut[off + 48] = (MathUtil.clip(residual[12] + c6, -128, 127) << 24 >> 24);
        pixOut[off + 49] = (MathUtil.clip(residual[13] + c6, -128, 127) << 24 >> 24);
        pixOut[off + 50] = (MathUtil.clip(residual[14] + c6, -128, 127) << 24 >> 24);
        pixOut[off + 51] = (MathUtil.clip(residual[15] + c6, -128, 127) << 24 >> 24);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  @author The JCodec project
 */
var CVTColorFilter = function() {};
CVTColorFilter = stjs.extend(CVTColorFilter, null, [], function(constructor, prototype) {
    prototype.yuv422BitTObgr24 = function(yuv, rgb32) {
        var y = ByteBuffer.wrap(yuv.getPlaneData(0));
        var cb = ByteBuffer.wrap(yuv.getPlaneData(1));
        var cr = ByteBuffer.wrap(yuv.getPlaneData(2));
         while (y.hasRemaining()){
            var c1 = (y.get() + 112) << 2;
            var c2 = (y.get() + 112) << 2;
            var d = cb.get() << 2;
            var e = cr.get() << 2;
            rgb32.put(CVTColorFilter.blue(d, c1));
            rgb32.put(CVTColorFilter.green(d, e, c1));
            rgb32.put(CVTColorFilter.red(e, c1));
            rgb32.put(CVTColorFilter.blue(d, c2));
            rgb32.put(CVTColorFilter.green(d, e, c2));
            rgb32.put(CVTColorFilter.red(e, c2));
        }
    };
    constructor.blue = function(d, c) {
        var blue = (1192 * c + 2064 * d + 512) >> 10;
        blue = blue < 0 ? 0 : (blue > 1023 ? 1023 : blue);
        return (((blue >> 2) & 255) << 24 >> 24);
    };
    constructor.green = function(d, e, c) {
        var green = (1192 * c - 400 * d - 832 * e + 512) >> 10;
        green = green < 0 ? 0 : (green > 1023 ? 1023 : green);
        return (((green >> 2) & 255) << 24 >> 24);
    };
    constructor.red = function(e, c) {
        var red = (1192 * c + 1636 * e + 512) >> 10;
        red = red < 0 ? 0 : (red > 1023 ? 1023 : red);
        return (((red >> 2) & 255) << 24 >> 24);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var AudioFrame = function(buffer, format, nFrames, pts, duration, timescale, frameNo) {
    AudioBuffer.call(this, buffer, format, nFrames);
    this.pts = pts;
    this.duration = duration;
    this.timescale = timescale;
    this.frameNo = frameNo;
};
AudioFrame = stjs.extend(AudioFrame, AudioBuffer, [], function(constructor, prototype) {
    prototype.pts = 0;
    prototype.duration = 0;
    prototype.timescale = 0;
    prototype.frameNo = 0;
    prototype.getPts = function() {
        return this.pts;
    };
    prototype.getDuration = function() {
        return this.duration;
    };
    prototype.getTimescale = function() {
        return this.timescale;
    };
    prototype.getFrameNo = function() {
        return this.frameNo;
    };
}, {data: "ByteBuffer", format: "AudioFormat"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  @author The JCodec project
 */
var ProresConsts = function() {};
ProresConsts = stjs.extend(ProresConsts, null, [], function(constructor, prototype) {
    constructor.firstDCCodebook = new Codebook(5, 6, 0);
    constructor.dcCodebooks = [new Codebook(0, 1, 0), new Codebook(1, 2, 0), new Codebook(1, 2, 0), new Codebook(2, 3, 1), new Codebook(2, 3, 1), new Codebook(3, 4, 0), new Codebook(3, 4, 0)];
    constructor.runCodebooks = [new Codebook(0, 1, 2), new Codebook(0, 1, 2), new Codebook(0, 1, 1), new Codebook(0, 1, 1), new Codebook(0, 1, 0), new Codebook(1, 2, 1), new Codebook(1, 2, 1), new Codebook(1, 2, 1), new Codebook(1, 2, 1), new Codebook(1, 2, 0), new Codebook(1, 2, 0), new Codebook(1, 2, 0), new Codebook(1, 2, 0), new Codebook(1, 2, 0), new Codebook(1, 2, 0), new Codebook(2, 3, 0)];
    constructor.levCodebooks = [new Codebook(0, 1, 0), new Codebook(0, 2, 2), new Codebook(0, 1, 1), new Codebook(0, 1, 2), new Codebook(0, 1, 0), new Codebook(1, 2, 0), new Codebook(1, 2, 0), new Codebook(1, 2, 0), new Codebook(1, 2, 0), new Codebook(2, 3, 0)];
    constructor.progressive_scan = new Int32Array([0, 1, 8, 9, 2, 3, 10, 11, 16, 17, 24, 25, 18, 19, 26, 27, 4, 5, 12, 20, 13, 6, 7, 14, 21, 28, 29, 22, 15, 23, 30, 31, 32, 33, 40, 48, 41, 34, 35, 42, 49, 56, 57, 50, 43, 36, 37, 44, 51, 58, 59, 52, 45, 38, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]);
    constructor.interlaced_scan = new Int32Array([0, 8, 1, 9, 16, 24, 17, 25, 2, 10, 3, 11, 18, 26, 19, 27, 32, 40, 33, 34, 41, 48, 56, 49, 42, 35, 43, 50, 57, 58, 51, 59, 4, 12, 5, 6, 13, 20, 28, 21, 14, 7, 15, 22, 29, 36, 44, 37, 30, 23, 31, 38, 45, 52, 60, 53, 46, 39, 47, 54, 61, 62, 55, 63]);
    constructor.QMAT_LUMA_APCH = new Int32Array([4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 4, 4, 4, 4, 4, 4, 5, 5, 4, 4, 4, 4, 4, 5, 5, 6, 4, 4, 4, 4, 5, 5, 6, 7, 4, 4, 4, 4, 5, 6, 7, 7]);
    constructor.QMAT_CHROMA_APCH = new Int32Array([4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 4, 4, 4, 4, 4, 4, 5, 5, 4, 4, 4, 4, 4, 5, 5, 6, 4, 4, 4, 4, 5, 5, 6, 7, 4, 4, 4, 4, 5, 6, 7, 7]);
    constructor.QMAT_LUMA_APCO = new Int32Array([4, 7, 9, 11, 13, 14, 15, 63, 7, 7, 11, 12, 14, 15, 63, 63, 9, 11, 13, 14, 15, 63, 63, 63, 11, 11, 13, 14, 63, 63, 63, 63, 11, 13, 14, 63, 63, 63, 63, 63, 13, 14, 63, 63, 63, 63, 63, 63, 13, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63]);
    constructor.QMAT_CHROMA_APCO = new Int32Array([4, 7, 9, 11, 13, 14, 63, 63, 7, 7, 11, 12, 14, 63, 63, 63, 9, 11, 13, 14, 63, 63, 63, 63, 11, 11, 13, 14, 63, 63, 63, 63, 11, 13, 14, 63, 63, 63, 63, 63, 13, 14, 63, 63, 63, 63, 63, 63, 13, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63]);
    constructor.QMAT_LUMA_APCN = new Int32Array([4, 4, 5, 5, 6, 7, 7, 9, 4, 4, 5, 6, 7, 7, 9, 9, 5, 5, 6, 7, 7, 9, 9, 10, 5, 5, 6, 7, 7, 9, 9, 10, 5, 6, 7, 7, 8, 9, 10, 12, 6, 7, 7, 8, 9, 10, 12, 15, 6, 7, 7, 9, 10, 11, 14, 17, 7, 7, 9, 10, 11, 14, 17, 21]);
    constructor.QMAT_CHROMA_APCN = new Int32Array([4, 4, 5, 5, 6, 7, 7, 9, 4, 4, 5, 6, 7, 7, 9, 9, 5, 5, 6, 7, 7, 9, 9, 10, 5, 5, 6, 7, 7, 9, 9, 10, 5, 6, 7, 7, 8, 9, 10, 12, 6, 7, 7, 8, 9, 10, 12, 15, 6, 7, 7, 9, 10, 11, 14, 17, 7, 7, 9, 10, 11, 14, 17, 21]);
    constructor.QMAT_LUMA_APCS = new Int32Array([4, 5, 6, 7, 9, 11, 13, 15, 5, 5, 7, 8, 11, 13, 15, 17, 6, 7, 9, 11, 13, 15, 15, 17, 7, 7, 9, 11, 13, 15, 17, 19, 7, 9, 11, 13, 14, 16, 19, 23, 9, 11, 13, 14, 16, 19, 23, 29, 9, 11, 13, 15, 17, 21, 28, 35, 11, 13, 16, 17, 21, 28, 35, 41]);
    constructor.QMAT_CHROMA_APCS = new Int32Array([4, 5, 6, 7, 9, 11, 13, 15, 5, 5, 7, 8, 11, 13, 15, 17, 6, 7, 9, 11, 13, 15, 15, 17, 7, 7, 9, 11, 13, 15, 17, 19, 7, 9, 11, 13, 14, 16, 19, 23, 9, 11, 13, 14, 16, 19, 23, 29, 9, 11, 13, 15, 17, 21, 28, 35, 11, 13, 16, 17, 21, 28, 35, 41]);
    constructor.FrameHeader = function(frameSize, width, height, frameType, topFieldFirst, scan, qMatLuma, qMatChroma, chromaType) {
        this.payloadSize = frameSize;
        this.width = width;
        this.height = height;
        this.frameType = frameType;
        this.topFieldFirst = topFieldFirst;
        this.scan = scan;
        this.qMatChroma = qMatChroma;
        this.qMatLuma = qMatLuma;
        this.chromaType = chromaType;
    };
    constructor.FrameHeader = stjs.extend(constructor.FrameHeader, null, [], function(constructor, prototype) {
        prototype.payloadSize = 0;
        prototype.width = 0;
        prototype.height = 0;
        prototype.frameType = 0;
        prototype.topFieldFirst = false;
        prototype.chromaType = 0;
        prototype.scan = null;
        prototype.qMatLuma = null;
        prototype.qMatChroma = null;
    }, {scan: "Int32Array", qMatLuma: "Int32Array", qMatChroma: "Int32Array"}, {});
    constructor.PictureHeader = function(log2SliceMbWidth, sliceSizes) {
        this.log2SliceMbWidth = log2SliceMbWidth;
        this.sliceSizes = sliceSizes;
    };
    constructor.PictureHeader = stjs.extend(constructor.PictureHeader, null, [], function(constructor, prototype) {
        prototype.log2SliceMbWidth = 0;
        prototype.sliceSizes = null;
    }, {sliceSizes: "Int16Array"}, {});
}, {firstDCCodebook: "Codebook", dcCodebooks: "Array", runCodebooks: "Array", levCodebooks: "Array", progressive_scan: "Int32Array", interlaced_scan: "Int32Array", QMAT_LUMA_APCH: "Int32Array", QMAT_CHROMA_APCH: "Int32Array", QMAT_LUMA_APCO: "Int32Array", QMAT_CHROMA_APCO: "Int32Array", QMAT_LUMA_APCN: "Int32Array", QMAT_CHROMA_APCN: "Int32Array", QMAT_LUMA_APCS: "Int32Array", QMAT_CHROMA_APCS: "Int32Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 * 
 *  @author in-somnia
 */
var SyntaxConstants = function() {};
SyntaxConstants = stjs.extend(SyntaxConstants, null, [], function(constructor, prototype) {
    constructor.LOGGER = Logger.getLogger("jaad");
    constructor.MAX_ELEMENTS = 16;
    constructor.BYTE_MASK = 255;
    constructor.MIN_INPUT_SIZE = 768;
    constructor.WINDOW_LEN_LONG = 1024;
    constructor.WINDOW_LEN_SHORT = stjs.trunc(SyntaxConstants.WINDOW_LEN_LONG / 8);
    constructor.WINDOW_SMALL_LEN_LONG = 960;
    constructor.WINDOW_SMALL_LEN_SHORT = stjs.trunc(SyntaxConstants.WINDOW_SMALL_LEN_LONG / 8);
    constructor.ELEMENT_SCE = 0;
    constructor.ELEMENT_CPE = 1;
    constructor.ELEMENT_CCE = 2;
    constructor.ELEMENT_LFE = 3;
    constructor.ELEMENT_DSE = 4;
    constructor.ELEMENT_PCE = 5;
    constructor.ELEMENT_FIL = 6;
    constructor.ELEMENT_END = 7;
    constructor.MAX_WINDOW_COUNT = 8;
    constructor.MAX_WINDOW_GROUP_COUNT = SyntaxConstants.MAX_WINDOW_COUNT;
    constructor.MAX_LTP_SFB = 40;
    constructor.MAX_SECTIONS = 120;
    constructor.MAX_MS_MASK = 128;
    constructor.SQRT2 = 1.4142135;
}, {LOGGER: "Logger"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var ToAACTrack = function() {};
ToAACTrack = stjs.extend(ToAACTrack, null, [VirtualTrack], function(constructor, prototype) {
    prototype.nextPacket = function() {
        return null;
    };
    prototype.getCodecMeta = function() {
        return null;
    };
    prototype.getEdits = function() {
        return null;
    };
    prototype.getPreferredTimescale = function() {
        return 0;
    };
    prototype.close = function() {};
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var ToVorbisTrack = function() {};
ToVorbisTrack = stjs.extend(ToVorbisTrack, null, [VirtualTrack], function(constructor, prototype) {
    prototype.nextPacket = function() {
        return null;
    };
    prototype.getCodecMeta = function() {
        return null;
    };
    prototype.getEdits = function() {
        return null;
    };
    prototype.getPreferredTimescale = function() {
        return 0;
    };
    prototype.close = function() {};
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Virtual movie frame or PCM raw packet
 *  
 *  @author The JCodec project
 *  
 */
var VirtualPacket = function() {};
VirtualPacket = stjs.extend(VirtualPacket, null, [], function(constructor, prototype) {
    prototype.getData = function() {};
    prototype.getDataLen = function() {};
    prototype.getPts = function() {};
    prototype.getDuration = function() {};
    prototype.isKeyframe = function() {};
    prototype.getFrameNo = function() {};
    constructor.byPts = new (stjs.extend(function VirtualPacket$1() {}, null, [Comparator], function(constructor, prototype) {
        prototype.compare = function(o1, o2) {
            if (o1 == null && o2 == null) 
                return 0;
             else if (o1 == null) 
                return -1;
             else if (o2 == null) 
                return 1;
             else 
                return o1.getPts() < o2.getPts() ? -1 : (o1.getPts() == o2.getPts() ? 0 : 1);
        };
    }, {}, {}))();
}, {byPts: {name: "Comparator", arguments: ["Object"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Yuv420pToYuv422p8Bit = function() {};
Yuv420pToYuv422p8Bit = stjs.extend(Yuv420pToYuv422p8Bit, null, [Transform8Bit], function(constructor, prototype) {
    prototype.transform = function(src, dst) {
        Yuv420pToYuv422p8Bit.copy(src.getPlaneData(0), dst.getPlaneData(0), src.getWidth(), dst.getWidth(), dst.getHeight());
        Yuv420pToYuv422p8Bit._copy(src.getPlaneData(1), dst.getPlaneData(1), 0, 0, 1, 2, src.getWidth() >> 1, dst.getWidth() >> 1, src.getHeight() >> 1, dst.getHeight());
        Yuv420pToYuv422p8Bit._copy(src.getPlaneData(1), dst.getPlaneData(1), 0, 1, 1, 2, src.getWidth() >> 1, dst.getWidth() >> 1, src.getHeight() >> 1, dst.getHeight());
        Yuv420pToYuv422p8Bit._copy(src.getPlaneData(2), dst.getPlaneData(2), 0, 0, 1, 2, src.getWidth() >> 1, dst.getWidth() >> 1, src.getHeight() >> 1, dst.getHeight());
        Yuv420pToYuv422p8Bit._copy(src.getPlaneData(2), dst.getPlaneData(2), 0, 1, 1, 2, src.getWidth() >> 1, dst.getWidth() >> 1, src.getHeight() >> 1, dst.getHeight());
    };
    constructor._copy = function(src, dest, offX, offY, stepX, stepY, strideSrc, strideDest, heightSrc, heightDst) {
        var offD = offX + offY * strideDest, srcOff = 0;
        for (var i = 0; i < heightSrc; i++) {
            for (var j = 0; j < strideSrc; j++) {
                dest[offD] = src[srcOff++];
                offD += stepX;
            }
            var lastOff = offD - stepX;
            for (var j = strideSrc * stepX; j < strideDest; j += stepX) {
                dest[offD] = dest[lastOff];
                offD += stepX;
            }
            offD += (stepY - 1) * strideDest;
        }
        var lastLine = offD - stepY * strideDest;
        for (var i = heightSrc * stepY; i < heightDst; i += stepY) {
            for (var j = 0; j < strideDest; j += stepX) {
                dest[offD] = dest[lastLine + j];
                offD += stepX;
            }
            offD += (stepY - 1) * strideDest;
        }
    };
    constructor.copy = function(src, dest, srcWidth, dstWidth, dstHeight) {
        var height = stjs.trunc(src.length / srcWidth);
        var dstOff = 0, srcOff = 0;
        for (var i = 0; i < height; i++) {
            for (var j = 0; j < srcWidth; j++) {
                dest[dstOff++] = src[srcOff++];
            }
            for (var j = srcWidth; j < dstWidth; j++) 
                dest[dstOff++] = dest[srcWidth - 1];
        }
        var lastLine = (height - 1) * dstWidth;
        for (var i = height; i < dstHeight; i++) {
            for (var j = 0; j < dstWidth; j++) {
                dest[dstOff++] = dest[lastLine + j];
            }
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Yuv420pToRgb8Bit = function() {};
Yuv420pToRgb8Bit = stjs.extend(Yuv420pToRgb8Bit, null, [Transform8Bit], function(constructor, prototype) {
    prototype.transform = function(src, dst) {
        var y = src.getPlaneData(0);
        var u = src.getPlaneData(1);
        var v = src.getPlaneData(2);
        var data = dst.getPlaneData(0);
        var offLuma = 0, offChroma = 0;
        var stride = dst.getWidth();
        for (var i = 0; i < (dst.getHeight() >> 1); i++) {
            for (var k = 0; k < (dst.getWidth() >> 1); k++) {
                var j = k << 1;
                Yuv420pToRgb8Bit.YUV420pToRGB(y[offLuma + j], u[offChroma], v[offChroma], data, (offLuma + j) * 3);
                Yuv420pToRgb8Bit.YUV420pToRGB(y[offLuma + j + 1], u[offChroma], v[offChroma], data, (offLuma + j + 1) * 3);
                Yuv420pToRgb8Bit.YUV420pToRGB(y[offLuma + j + stride], u[offChroma], v[offChroma], data, (offLuma + j + stride) * 3);
                Yuv420pToRgb8Bit.YUV420pToRGB(y[offLuma + j + stride + 1], u[offChroma], v[offChroma], data, (offLuma + j + stride + 1) * 3);
                ++offChroma;
            }
            if ((dst.getWidth() & 1) != 0) {
                var j = dst.getWidth() - 1;
                Yuv420pToRgb8Bit.YUV420pToRGB(y[offLuma + j], u[offChroma], v[offChroma], data, (offLuma + j) * 3);
                Yuv420pToRgb8Bit.YUV420pToRGB(y[offLuma + j + stride], u[offChroma], v[offChroma], data, (offLuma + j + stride) * 3);
                ++offChroma;
            }
            offLuma += 2 * stride;
        }
        if ((dst.getHeight() & 1) != 0) {
            for (var k = 0; k < (dst.getWidth() >> 1); k++) {
                var j = k << 1;
                Yuv420pToRgb8Bit.YUV420pToRGB(y[offLuma + j], u[offChroma], v[offChroma], data, (offLuma + j) * 3);
                Yuv420pToRgb8Bit.YUV420pToRGB(y[offLuma + j + 1], u[offChroma], v[offChroma], data, (offLuma + j + 1) * 3);
                ++offChroma;
            }
            if ((dst.getWidth() & 1) != 0) {
                var j = dst.getWidth() - 1;
                Yuv420pToRgb8Bit.YUV420pToRGB(y[offLuma + j], u[offChroma], v[offChroma], data, (offLuma + j) * 3);
                ++offChroma;
            }
        }
    };
    constructor.YUV420pToRGB = function(y, u, v, data, off) {
        var c = y + 112;
        var r = (298 * c + 409 * v + 128) >> 8;
        var g = (298 * c - 100 * u - 208 * v + 128) >> 8;
        var b = (298 * c + 516 * u + 128) >> 8;
        data[off] = ((Yuv420pToRgb8Bit.crop(r) - 128) << 24 >> 24);
        data[off + 1] = ((Yuv420pToRgb8Bit.crop(g) - 128) << 24 >> 24);
        data[off + 2] = ((Yuv420pToRgb8Bit.crop(b) - 128) << 24 >> 24);
    };
    constructor.crop = function(val) {
        return val < 0 ? 0 : (val > 255 ? 255 : val);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Transforms Picture in RGB colorspace ( one plane, 3 integers per pixel ) to
 *  Yuv420 colorspace output picture ( 3 planes, luma - 0th plane, cb - 1th
 *  plane, cr - 2nd plane; cb and cr planes are half width and half haight )
 *  
 *  TODO: implement jpeg colorspace instead of NTSC
 *  
 *  @author The JCodec project
 *  
 */
var RgbToYuv420p8Bit = function() {};
RgbToYuv420p8Bit = stjs.extend(RgbToYuv420p8Bit, null, [Transform8Bit], function(constructor, prototype) {
    prototype.transform = function(img, dst) {
        var y = img.getData()[0];
        var dstData = dst.getData();
        var out = Array.apply(null, Array(4)).map(function() {
            return new Int8Array(3);
        });
        var offChr = 0, offLuma = 0, offSrc = 0, strideSrc = img.getWidth() * 3, strideDst = dst.getWidth();
        for (var i = 0; i < img.getHeight() >> 1; i++) {
            for (var j = 0; j < img.getWidth() >> 1; j++) {
                dstData[1][offChr] = 0;
                dstData[2][offChr] = 0;
                RgbToYuv420p8Bit.rgb2yuv(y[offSrc], y[offSrc + 1], y[offSrc + 2], out[0]);
                dstData[0][offLuma] = out[0][0];
                RgbToYuv420p8Bit.rgb2yuv(y[offSrc + strideSrc], y[offSrc + strideSrc + 1], y[offSrc + strideSrc + 2], out[1]);
                dstData[0][offLuma + strideDst] = out[1][0];
                ++offLuma;
                RgbToYuv420p8Bit.rgb2yuv(y[offSrc + 3], y[offSrc + 4], y[offSrc + 5], out[2]);
                dstData[0][offLuma] = out[2][0];
                RgbToYuv420p8Bit.rgb2yuv(y[offSrc + strideSrc + 3], y[offSrc + strideSrc + 4], y[offSrc + strideSrc + 5], out[3]);
                dstData[0][offLuma + strideDst] = out[3][0];
                ++offLuma;
                dstData[1][offChr] = (((out[0][1] + out[1][1] + out[2][1] + out[3][1] + 2) >> 2) << 24 >> 24);
                dstData[2][offChr] = (((out[0][2] + out[1][2] + out[2][2] + out[3][2] + 2) >> 2) << 24 >> 24);
                ++offChr;
                offSrc += 6;
            }
            offLuma += strideDst;
            offSrc += strideSrc;
        }
    };
    constructor.rgb2yuv = function(r, g, b, out) {
        var rS = r + 128;
        var gS = g + 128;
        var bS = b + 128;
        var y = 66 * rS + 129 * gS + 25 * bS;
        var u = -38 * rS - 74 * gS + 112 * bS;
        var v = 112 * rS - 94 * gS - 18 * bS;
        y = (y + 128) >> 8;
        u = (u + 128) >> 8;
        v = (v + 128) >> 8;
        out[0] = (MathUtil.clip(y - 112, -128, 127) << 24 >> 24);
        out[1] = (MathUtil.clip(u, -128, 127) << 24 >> 24);
        out[2] = (MathUtil.clip(v, -128, 127) << 24 >> 24);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Yuv420jToRgb8Bit = function() {};
Yuv420jToRgb8Bit = stjs.extend(Yuv420jToRgb8Bit, null, [Transform8Bit], function(constructor, prototype) {
    prototype.transform = function(src, dst) {
        var y = src.getPlaneData(0);
        var u = src.getPlaneData(1);
        var v = src.getPlaneData(2);
        var data = dst.getPlaneData(0);
        var offLuma = 0, offChroma = 0;
        var stride = dst.getWidth();
        for (var i = 0; i < (dst.getHeight() >> 1); i++) {
            for (var k = 0; k < (dst.getWidth() >> 1); k++) {
                var j = k << 1;
                Yuv420jToRgb8Bit.YUVJtoRGB(y[offLuma + j], u[offChroma], v[offChroma], data, (offLuma + j) * 3);
                Yuv420jToRgb8Bit.YUVJtoRGB(y[offLuma + j + 1], u[offChroma], v[offChroma], data, (offLuma + j + 1) * 3);
                Yuv420jToRgb8Bit.YUVJtoRGB(y[offLuma + j + stride], u[offChroma], v[offChroma], data, (offLuma + j + stride) * 3);
                Yuv420jToRgb8Bit.YUVJtoRGB(y[offLuma + j + stride + 1], u[offChroma], v[offChroma], data, (offLuma + j + stride + 1) * 3);
                ++offChroma;
            }
            if ((dst.getWidth() & 1) != 0) {
                var j = dst.getWidth() - 1;
                Yuv420jToRgb8Bit.YUVJtoRGB(y[offLuma + j], u[offChroma], v[offChroma], data, (offLuma + j) * 3);
                Yuv420jToRgb8Bit.YUVJtoRGB(y[offLuma + j + stride], u[offChroma], v[offChroma], data, (offLuma + j + stride) * 3);
                ++offChroma;
            }
            offLuma += 2 * stride;
        }
        if ((dst.getHeight() & 1) != 0) {
            for (var k = 0; k < (dst.getWidth() >> 1); k++) {
                var j = k << 1;
                Yuv420jToRgb8Bit.YUVJtoRGB(y[offLuma + j], u[offChroma], v[offChroma], data, (offLuma + j) * 3);
                Yuv420jToRgb8Bit.YUVJtoRGB(y[offLuma + j + 1], u[offChroma], v[offChroma], data, (offLuma + j + 1) * 3);
                ++offChroma;
            }
            if ((dst.getWidth() & 1) != 0) {
                var j = dst.getWidth() - 1;
                Yuv420jToRgb8Bit.YUVJtoRGB(y[offLuma + j], u[offChroma], v[offChroma], data, (offLuma + j) * 3);
                ++offChroma;
            }
        }
    };
    constructor.SCALEBITS = 10;
    constructor.ONE_HALF = (1 << (Yuv420jToRgb8Bit.SCALEBITS - 1));
    constructor.FIX = function(x) {
        return (stjs.trunc(((x) * (1 << Yuv420jToRgb8Bit.SCALEBITS) + 0.5)));
    };
    constructor.FIX_0_71414 = Yuv420jToRgb8Bit.FIX(0.71414);
    constructor.FIX_1_772 = Yuv420jToRgb8Bit.FIX(1.772);
    constructor._FIX_0_34414 = -Yuv420jToRgb8Bit.FIX(0.34414);
    constructor.FIX_1_402 = Yuv420jToRgb8Bit.FIX(1.402);
    constructor.YUVJtoRGB = function(y, cb, cr, data, off) {
        var y_ = (y + 128) << Yuv420jToRgb8Bit.SCALEBITS;
        var add_r = Yuv420jToRgb8Bit.FIX_1_402 * cr + Yuv420jToRgb8Bit.ONE_HALF;
        var add_g = Yuv420jToRgb8Bit._FIX_0_34414 * cb - Yuv420jToRgb8Bit.FIX_0_71414 * cr + Yuv420jToRgb8Bit.ONE_HALF;
        var add_b = Yuv420jToRgb8Bit.FIX_1_772 * cb + Yuv420jToRgb8Bit.ONE_HALF;
        var r = (y_ + add_r) >> Yuv420jToRgb8Bit.SCALEBITS;
        var g = (y_ + add_g) >> Yuv420jToRgb8Bit.SCALEBITS;
        var b = (y_ + add_b) >> Yuv420jToRgb8Bit.SCALEBITS;
        data[off] = (MathUtil.clip(r - 128, -128, 127) << 24 >> 24);
        data[off + 1] = (MathUtil.clip(g - 128, -128, 127) << 24 >> 24);
        data[off + 2] = (MathUtil.clip(b - 128, -128, 127) << 24 >> 24);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Yuv422pToRgb8Bit = function() {};
Yuv422pToRgb8Bit = stjs.extend(Yuv422pToRgb8Bit, null, [Transform8Bit], function(constructor, prototype) {
    prototype.transform = function(src, dst) {
        var y = src.getPlaneData(0);
        var u = src.getPlaneData(1);
        var v = src.getPlaneData(2);
        var data = dst.getPlaneData(0);
        var offLuma = 0, offChroma = 0;
        for (var i = 0; i < dst.getHeight(); i++) {
            for (var j = 0; j < dst.getWidth(); j += 2) {
                Yuv422pToRgb8Bit.YUV444toRGB888(y[offLuma], u[offChroma], v[offChroma], data, offLuma * 3);
                Yuv422pToRgb8Bit.YUV444toRGB888(y[offLuma + 1], u[offChroma], v[offChroma], data, (offLuma + 1) * 3);
                offLuma += 2;
                ++offChroma;
            }
        }
    };
    constructor.YUV444toRGB888 = function(y, u, v, data, off) {
        var c = y + 112;
        var d = u;
        var e = v;
        var r = (298 * c + 409 * e + 128) >> 8;
        var g = (298 * c - 100 * d - 208 * e + 128) >> 8;
        var b = (298 * c + 516 * d + 128) >> 8;
        data[off] = ((MathUtil.clip(r, 0, 255) - 128) << 24 >> 24);
        data[off + 1] = ((MathUtil.clip(g, 0, 255) - 128) << 24 >> 24);
        data[off + 2] = ((MathUtil.clip(b, 0, 255) - 128) << 24 >> 24);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Transforms Picture in RGB colorspace ( one plane, 3 integers per pixel ) to
 *  Yuv420 colorspace output picture ( 3 planes, luma - 0th plane, cb - 1th
 *  plane, cr - 2nd plane; cb and cr planes are half width and half haight )
 *  
 *  TODO: implement jpeg colorspace instead of NTSC
 *  
 *  @author The JCodec project
 *  
 */
var RgbToYuv420j8Bit = function() {};
RgbToYuv420j8Bit = stjs.extend(RgbToYuv420j8Bit, null, [Transform8Bit], function(constructor, prototype) {
    prototype.transform = function(img, dst) {
        var y = img.getData()[0];
        var dstData = dst.getData();
        var out = Array.apply(null, Array(4)).map(function() {
            return new Int32Array(3);
        });
        var offChr = 0, offLuma = 0, offSrc = 0, strideSrc = img.getWidth() * 3, strideDst = dst.getWidth();
        for (var i = 0; i < img.getHeight() >> 1; i++) {
            for (var j = 0; j < img.getWidth() >> 1; j++) {
                dstData[1][offChr] = 0;
                dstData[2][offChr] = 0;
                RgbToYuv420j8Bit.rgb2yuv(y[offSrc], y[offSrc + 1], y[offSrc + 2], out[0]);
                dstData[0][offLuma] = (out[0][0] << 24 >> 24);
                RgbToYuv420j8Bit.rgb2yuv(y[offSrc + strideSrc], y[offSrc + strideSrc + 1], y[offSrc + strideSrc + 2], out[1]);
                dstData[0][offLuma + strideDst] = (out[1][0] << 24 >> 24);
                ++offLuma;
                RgbToYuv420j8Bit.rgb2yuv(y[offSrc + 3], y[offSrc + 4], y[offSrc + 5], out[2]);
                dstData[0][offLuma] = (out[2][0] << 24 >> 24);
                RgbToYuv420j8Bit.rgb2yuv(y[offSrc + strideSrc + 3], y[offSrc + strideSrc + 4], y[offSrc + strideSrc + 5], out[3]);
                dstData[0][offLuma + strideDst] = (out[3][0] << 24 >> 24);
                ++offLuma;
                dstData[1][offChr] = (((out[0][1] + out[1][1] + out[2][1] + out[3][1] + 2) >> 2) << 24 >> 24);
                dstData[2][offChr] = (((out[0][2] + out[1][2] + out[2][2] + out[3][2] + 2) >> 2) << 24 >> 24);
                ++offChr;
                offSrc += 6;
            }
            offLuma += strideDst;
            offSrc += strideSrc;
        }
    };
    constructor.rgb2yuv = function(r, g, b, out) {
        var rS = r + 128;
        var gS = g + 128;
        var bS = b + 128;
        var y = 77 * rS + 150 * gS + 15 * bS;
        var u = -43 * rS - 85 * gS + 128 * bS;
        var v = 128 * rS - 107 * gS - 21 * bS;
        y = (y + 128) >> 8;
        u = (u + 128) >> 8;
        v = (v + 128) >> 8;
        out[0] = MathUtil.clip(y - 128, -128, 127);
        out[1] = MathUtil.clip(u, -128, 127);
        out[2] = MathUtil.clip(v, -128, 127);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var VideoCodecMeta = function(fourcc, codecPrivate) {
    CodecMeta.call(this, fourcc, codecPrivate);
};
VideoCodecMeta = stjs.extend(VideoCodecMeta, CodecMeta, [], function(constructor, prototype) {
    constructor.createVideoCodecMeta = function(fourcc, codecPrivate, size, pasp) {
        var self = new VideoCodecMeta(fourcc, codecPrivate);
        self.size = size;
        self.pasp = pasp;
        return self;
    };
    constructor.createVideoCodecMeta2 = function(fourcc, codecPrivate, size, pasp, interlaced, topFieldFirst) {
        var self = new VideoCodecMeta(fourcc, codecPrivate);
        self.size = size;
        self.pasp = pasp;
        self.interlaced = interlaced;
        self.topFieldFirst = topFieldFirst;
        return self;
    };
    prototype.size = null;
    prototype.pasp = null;
    prototype.interlaced = false;
    prototype.topFieldFirst = false;
    prototype.getSize = function() {
        return this.size;
    };
    prototype.getPasp = function() {
        return this.pasp;
    };
    prototype.isInterlaced = function() {
        return this.interlaced;
    };
    prototype.isTopFieldFirst = function() {
        return this.topFieldFirst;
    };
}, {size: "Size", pasp: "Rational", codecPrivate: "ByteBuffer"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MPEGUtil = function() {};
MPEGUtil = stjs.extend(MPEGUtil, null, [], function(constructor, prototype) {
    /**
     *  Finds next MPEG bitstream marker 0x000001xx and returns the data that
     *  preceeds it as a ByteBuffer slice
     *  
     *  Segment byte order is always little endian
     *  
     *  @param buf
     *  @return
     */
    constructor.gotoNextMarker = function(buf) {
        return MPEGUtil.gotoMarker(buf, 0, 256, 511);
    };
    /**
     *  Finds next Nth MPEG bitstream marker 0x000001xx and returns the data that
     *  preceeds it as a ByteBuffer slice
     *  
     *  Segment byte order is always little endian
     *  
     *  @param buf
     *  @return
     */
    constructor.gotoMarker = function(buf, n, mmin, mmax) {
        if (!buf.hasRemaining()) 
            return null;
        var from = buf.position();
        var result = buf.slice();
        result.order(ByteOrder.BIG_ENDIAN);
        var val = -1;
         while (buf.hasRemaining()){
            val = (val << 8) | (buf.get() & 255);
            if (val >= mmin && val <= mmax) {
                if (n == 0) {
                    buf.setPosition(buf.position() - 4);
                    result.setLimit(buf.position() - from);
                    break;
                }
                --n;
            }
        }
        return result;
    };
    /**
     *  Returns next segment between two MPEG marker
     *  
     *  i.e. searches for the next marker if the stream is not at the marker
     *  boundary already
     *  
     *  @param buf
     *  @return
     */
    constructor.nextSegment = function(buf) {
        MPEGUtil.gotoMarker(buf, 0, 256, 511);
        return MPEGUtil.gotoMarker(buf, 1, 256, 511);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var AudioCodecMeta = function(fourcc, codecPrivate) {
    CodecMeta.call(this, fourcc, codecPrivate);
};
AudioCodecMeta = stjs.extend(AudioCodecMeta, CodecMeta, [], function(constructor, prototype) {
    constructor.createAudioCodecMeta = function(fourcc, sampleSize, channelCount, sampleRate, endian, pcm, labels, codecPrivate) {
        var self = new AudioCodecMeta(fourcc, codecPrivate);
        self.sampleSize = sampleSize;
        self.channelCount = channelCount;
        self.sampleRate = sampleRate;
        self.endian = endian;
        self.pcm = pcm;
        self.labels = labels;
        return self;
    };
    constructor.createAudioCodecMeta2 = function(fourcc, sampleSize, channelCount, sampleRate, endian, pcm, labels, samplesPerPacket, bytesPerPacket, bytesPerFrame, codecPrivate) {
        var self = new AudioCodecMeta(fourcc, codecPrivate);
        self.sampleSize = sampleSize;
        self.channelCount = channelCount;
        self.sampleRate = sampleRate;
        self.endian = endian;
        self.samplesPerPacket = samplesPerPacket;
        self.bytesPerPacket = bytesPerPacket;
        self.bytesPerFrame = bytesPerFrame;
        self.pcm = pcm;
        self.labels = labels;
        return self;
    };
    constructor.createAudioCodecMeta3 = function(fourcc, codecPrivate, format, pcm, labels) {
        var self = new AudioCodecMeta(fourcc, codecPrivate);
        self.sampleSize = format.getSampleSizeInBits() >> 3;
        self.channelCount = format.getChannels();
        self.sampleRate = format.getSampleRate();
        self.endian = format.isBigEndian() ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN;
        self.pcm = pcm;
        self.labels = labels;
        return self;
    };
    prototype.sampleSize = 0;
    prototype.channelCount = 0;
    prototype.sampleRate = 0;
    prototype.endian = null;
    prototype.samplesPerPacket = 0;
    prototype.bytesPerPacket = 0;
    prototype.bytesPerFrame = 0;
    prototype.pcm = false;
    prototype.labels = null;
    prototype.getFrameSize = function() {
        return this.sampleSize * this.channelCount;
    };
    prototype.getSampleRate = function() {
        return this.sampleRate;
    };
    prototype.getSampleSize = function() {
        return this.sampleSize;
    };
    prototype.getChannelCount = function() {
        return this.channelCount;
    };
    prototype.getSamplesPerPacket = function() {
        return this.samplesPerPacket;
    };
    prototype.getBytesPerPacket = function() {
        return this.bytesPerPacket;
    };
    prototype.getBytesPerFrame = function() {
        return this.bytesPerFrame;
    };
    prototype.getEndian = function() {
        return this.endian;
    };
    prototype.isPCM = function() {
        return this.pcm;
    };
    prototype.getFormat = function() {
        return new AudioFormat(this.sampleRate, this.sampleSize << 3, this.channelCount, true, this.endian == ByteOrder.BIG_ENDIAN);
    };
    prototype.getChannelLabels = function() {
        return this.labels;
    };
}, {endian: "ByteOrder", labels: "Array", codecPrivate: "ByteBuffer"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Yuv422pToYuv420p8Bit = function() {};
Yuv422pToYuv420p8Bit = stjs.extend(Yuv422pToYuv420p8Bit, null, [Transform8Bit], function(constructor, prototype) {
    prototype.transform = function(src, dst) {
        var lumaSize = src.getWidth() * src.getHeight();
        System.arraycopy(src.getPlaneData(0), 0, dst.getPlaneData(0), 0, lumaSize);
        this.copyAvg(src.getPlaneData(1), dst.getPlaneData(1), src.getPlaneWidth(1), src.getPlaneHeight(1));
        this.copyAvg(src.getPlaneData(2), dst.getPlaneData(2), src.getPlaneWidth(2), src.getPlaneHeight(2));
    };
    prototype.copyAvg = function(src, dst, width, height) {
        var offSrc = 0, offDst = 0;
        for (var y = 0; y < stjs.trunc(height / 2); y++) {
            for (var x = 0; x < width; x++ , offDst++ , offSrc++) {
                dst[offDst] = (((src[offSrc] + src[offSrc + width] + 1) >> 1) << 24 >> 24);
            }
            offSrc += width;
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  The encoder for yuv 10 bit 422
 *  
 *  x|x|9876543210(cr0)|9876543210(y0) |9876543210(cb0) x|x|9876543210(y2)
 *  |9876543210(cb1)|9876543210(y1) x|x|9876543210(cb2)|9876543210(y3)
 *  |9876543210(cr1) x|x|9876543210(y5) |9876543210(cr2)|9876543210(y4)
 *  
 *  @author The JCodec project
 *  
 */
var V210Encoder = function() {};
V210Encoder = stjs.extend(V210Encoder, null, [], function(constructor, prototype) {
    prototype.encodeFrame8Bit = function(_out, frame) {
        var out = _out.duplicate();
        out.order(ByteOrder.LITTLE_ENDIAN);
        var tgtStride = (stjs.trunc((frame.getPlaneWidth(0) + 47) / 48)) * 48;
        var data = frame.getData();
        var tmpY = new Int8Array(tgtStride);
        var tmpCb = new Int8Array(tgtStride >> 1);
        var tmpCr = new Int8Array(tgtStride >> 1);
        var yOff = 0, cbOff = 0, crOff = 0;
        for (var yy = 0; yy < frame.getHeight(); yy++) {
            System.arraycopy(data[0], yOff, tmpY, 0, frame.getPlaneWidth(0));
            System.arraycopy(data[1], cbOff, tmpCb, 0, frame.getPlaneWidth(1));
            System.arraycopy(data[2], crOff, tmpCr, 0, frame.getPlaneWidth(2));
            for (var yi = 0, cbi = 0, cri = 0; yi < tgtStride; ) {
                var i = 0;
                i |= V210Encoder.clip(tmpCr[cri++]) << 20;
                i |= V210Encoder.clip(tmpY[yi++]) << 10;
                i |= V210Encoder.clip(tmpCb[cbi++]);
                out.putInt(i);
                i = 0;
                i |= V210Encoder.clip(tmpY[yi++]);
                i |= V210Encoder.clip(tmpY[yi++]) << 20;
                i |= V210Encoder.clip(tmpCb[cbi++]) << 10;
                out.putInt(i);
                i = 0;
                i |= V210Encoder.clip(tmpCb[cbi++]) << 20;
                i |= V210Encoder.clip(tmpY[yi++]) << 10;
                i |= V210Encoder.clip(tmpCr[cri++]);
                out.putInt(i);
                i = 0;
                i |= V210Encoder.clip(tmpY[yi++]);
                i |= V210Encoder.clip(tmpY[yi++]) << 20;
                i |= V210Encoder.clip(tmpCr[cri++]) << 10;
                out.putInt(i);
            }
            yOff += frame.getPlaneWidth(0);
            cbOff += frame.getPlaneWidth(1);
            crOff += frame.getPlaneWidth(2);
        }
        out.flip();
        return out;
    };
    constructor.clip = function(val) {
        return MathUtil.clip((val + 128) << 2, 8, 1019);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Interpolator that operates on block level
 *  
 *  @author The JCodec project
 *  
 */
var BlockInterpolator = function() {
    this.tmp1 = new Int32Array(1024);
    this.tmp2 = new Int32Array(1024);
    this.tmp3 = new Int8Array(1024);
    this.safe = this.initSafe();
    this.unsafe = this.initUnsafe();
};
BlockInterpolator = stjs.extend(BlockInterpolator, null, [], function(constructor, prototype) {
    prototype.tmp1 = null;
    prototype.tmp2 = null;
    prototype.tmp3 = null;
    prototype.safe = null;
    prototype.unsafe = null;
    /**
     *  Get block of ( possibly interpolated ) luma pixels
     */
    prototype.getBlockLuma = function(pic, out, off, x, y, w, h) {
        var xInd = x & 3;
        var yInd = y & 3;
        var xFp = x >> 2;
        var yFp = y >> 2;
        if (xFp < 2 || yFp < 2 || xFp > pic.getWidth() - w - 5 || yFp > pic.getHeight() - h - 5) {
            this.unsafe[(yInd << 2) + xInd].getLuma(pic.getData()[0], pic.getWidth(), pic.getHeight(), out.getPlaneData(0), off, out.getPlaneWidth(0), xFp, yFp, w, h);
        } else {
            this.safe[(yInd << 2) + xInd].getLuma(pic.getData()[0], pic.getWidth(), pic.getHeight(), out.getPlaneData(0), off, out.getPlaneWidth(0), xFp, yFp, w, h);
        }
    };
    prototype.getBlockChroma = function(pels, picW, picH, blk, blkOff, blkStride, x, y, blkW, blkH) {
        var xInd = x & 7;
        var yInd = y & 7;
        var xFull = x >> 3;
        var yFull = y >> 3;
        if (xFull < 0 || xFull > picW - blkW - 1 || yFull < 0 || yFull > picH - blkH - 1) {
            if (xInd == 0 && yInd == 0) {
                this.getChroma00Unsafe(pels, picW, picH, blk, blkOff, blkStride, xFull, yFull, blkW, blkH);
            } else if (yInd == 0) {
                this.getChromaX0Unsafe(pels, picW, picH, blk, blkOff, blkStride, xFull, yFull, xInd, blkW, blkH);
            } else if (xInd == 0) {
                this.getChroma0XUnsafe(pels, picW, picH, blk, blkOff, blkStride, xFull, yFull, yInd, blkW, blkH);
            } else {
                this.getChromaXXUnsafe(pels, picW, picH, blk, blkOff, blkStride, xFull, yFull, xInd, yInd, blkW, blkH);
            }
        } else {
            if (xInd == 0 && yInd == 0) {
                this.getChroma00(pels, picW, picH, blk, blkOff, blkStride, xFull, yFull, blkW, blkH);
            } else if (yInd == 0) {
                this.getChromaX0(pels, picW, picH, blk, blkOff, blkStride, xFull, yFull, xInd, blkW, blkH);
            } else if (xInd == 0) {
                this.getChroma0X(pels, picW, picH, blk, blkOff, blkStride, xFull, yFull, yInd, blkW, blkH);
            } else {
                this.getChromaXX(pels, picW, picH, blk, blkOff, blkStride, xFull, yFull, xInd, yInd, blkW, blkH);
            }
        }
    };
    /**
     *  Fullpel (0, 0)
     */
    prototype.getLuma00 = function(pic, picW, blk, blkOff, blkStride, x, y, blkW, blkH) {
        var off = y * picW + x;
        for (var j = 0; j < blkH; j++) {
            System.arraycopy(pic, off, blk, blkOff, blkW);
            off += picW;
            blkOff += blkStride;
        }
    };
    /**
     *  Fullpel (0, 0) unsafe
     */
    prototype.getLuma00Unsafe = function(pic, picW, picH, blk, blkOff, blkStride, x, y, blkW, blkH) {
        var maxH = picH - 1;
        var maxW = picW - 1;
        for (var j = 0; j < blkH; j++) {
            var lineStart = MathUtil.clip(j + y, 0, maxH) * picW;
            for (var i = 0; i < blkW; i++) {
                blk[blkOff + i] = pic[lineStart + MathUtil.clip(x + i, 0, maxW)];
            }
            blkOff += blkStride;
        }
    };
    /**
     *  Halfpel (2,0) horizontal, int argument version
     */
    prototype.getLuma20NoRoundInt = function(pic, picW, blk, blkOff, blkStride, x, y, blkW, blkH) {
        var off = y * picW + x;
        for (var j = 0; j < blkH; j++) {
            var off1 = -2;
            for (var i = 0; i < blkW; i++) {
                var a = pic[off + off1] + pic[off + off1 + 5];
                var b = pic[off + off1 + 1] + pic[off + off1 + 4];
                var c = pic[off + off1 + 2] + pic[off + off1 + 3];
                blk[blkOff + i] = a + 5 * ((c << 2) - b);
                ++off1;
            }
            off += picW;
            blkOff += blkStride;
        }
    };
    /**
     *  Halfpel (2,0) horizontal
     */
    prototype.getLuma20NoRound = function(pic, picW, blk, blkOff, blkStride, x, y, blkW, blkH) {
        var off = y * picW + x;
        for (var j = 0; j < blkH; j++) {
            var off1 = -2;
            for (var i = 0; i < blkW; i++) {
                var a = pic[off + off1] + pic[off + off1 + 5];
                var b = pic[off + off1 + 1] + pic[off + off1 + 4];
                var c = pic[off + off1 + 2] + pic[off + off1 + 3];
                blk[blkOff + i] = a + 5 * ((c << 2) - b);
                ++off1;
            }
            off += picW;
            blkOff += blkStride;
        }
    };
    prototype.getLuma20 = function(pic, picW, blk, blkOff, blkStride, x, y, blkW, blkH) {
        var off = y * picW + x;
        for (var j = 0; j < blkH; j++) {
            var off1 = -2;
            for (var i = 0; i < blkW; i++) {
                var a = pic[off + off1] + pic[off + off1 + 5];
                var b = pic[off + off1 + 1] + pic[off + off1 + 4];
                var c = pic[off + off1 + 2] + pic[off + off1 + 3];
                blk[blkOff + i] = (MathUtil.clip((a + 5 * ((c << 2) - b) + 16) >> 5, -128, 127) << 24 >> 24);
                ++off1;
            }
            off += picW;
            blkOff += blkStride;
        }
    };
    /**
     *  Halfpel (2, 0) horizontal unsafe
     */
    prototype.getLuma20UnsafeNoRound = function(pic, picW, picH, blk, blkOff, blkStride, x, y, blkW, blkH) {
        var maxW = picW - 1;
        var maxH = picH - 1;
        for (var i = 0; i < blkW; i++) {
            var ipos_m2 = MathUtil.clip(x + i - 2, 0, maxW);
            var ipos_m1 = MathUtil.clip(x + i - 1, 0, maxW);
            var ipos = MathUtil.clip(x + i, 0, maxW);
            var ipos_p1 = MathUtil.clip(x + i + 1, 0, maxW);
            var ipos_p2 = MathUtil.clip(x + i + 2, 0, maxW);
            var ipos_p3 = MathUtil.clip(x + i + 3, 0, maxW);
            var boff = blkOff;
            for (var j = 0; j < blkH; j++) {
                var lineStart = MathUtil.clip(j + y, 0, maxH) * picW;
                var a = pic[lineStart + ipos_m2] + pic[lineStart + ipos_p3];
                var b = pic[lineStart + ipos_m1] + pic[lineStart + ipos_p2];
                var c = pic[lineStart + ipos] + pic[lineStart + ipos_p1];
                blk[boff + i] = a + 5 * ((c << 2) - b);
                boff += blkStride;
            }
        }
    };
    prototype.getLuma20Unsafe = function(pic, picW, picH, blk, blkOff, blkStride, x, y, blkW, blkH) {
        this.getLuma20UnsafeNoRound(pic, picW, picH, this.tmp1, blkOff, blkStride, x, y, blkW, blkH);
        for (var i = 0; i < blkW; i++) {
            var boff = blkOff;
            for (var j = 0; j < blkH; j++) {
                blk[boff + i] = (MathUtil.clip((this.tmp1[boff + i] + 16) >> 5, -128, 127) << 24 >> 24);
                boff += blkStride;
            }
        }
    };
    /**
     *  Halfpel (0, 2) vertical
     */
    prototype.getLuma02NoRoundInt = function(pic, picW, blk, blkOff, blkStride, x, y, blkW, blkH) {
        var off = (y - 2) * picW + x, picWx2 = picW + picW, picWx3 = picWx2 + picW, picWx4 = picWx3 + picW, picWx5 = picWx4 + picW;
        for (var j = 0; j < blkH; j++) {
            for (var i = 0; i < blkW; i++) {
                var a = pic[off + i] + pic[off + i + picWx5];
                var b = pic[off + i + picW] + pic[off + i + picWx4];
                var c = pic[off + i + picWx2] + pic[off + i + picWx3];
                blk[blkOff + i] = a + 5 * ((c << 2) - b);
            }
            off += picW;
            blkOff += blkStride;
        }
    };
    /**
     *  Halfpel (0, 2) vertical
     */
    prototype.getLuma02NoRound = function(pic, picW, blk, blkOff, blkStride, x, y, blkW, blkH) {
        var off = (y - 2) * picW + x, picWx2 = picW + picW, picWx3 = picWx2 + picW, picWx4 = picWx3 + picW, picWx5 = picWx4 + picW;
        for (var j = 0; j < blkH; j++) {
            for (var i = 0; i < blkW; i++) {
                var a = pic[off + i] + pic[off + i + picWx5];
                var b = pic[off + i + picW] + pic[off + i + picWx4];
                var c = pic[off + i + picWx2] + pic[off + i + picWx3];
                blk[blkOff + i] = a + 5 * ((c << 2) - b);
            }
            off += picW;
            blkOff += blkStride;
        }
    };
    prototype.getLuma02 = function(pic, picW, blk, blkOff, blkStride, x, y, blkW, blkH) {
        var off = (y - 2) * picW + x, picWx2 = picW + picW, picWx3 = picWx2 + picW, picWx4 = picWx3 + picW, picWx5 = picWx4 + picW;
        for (var j = 0; j < blkH; j++) {
            for (var i = 0; i < blkW; i++) {
                var a = pic[off + i] + pic[off + i + picWx5];
                var b = pic[off + i + picW] + pic[off + i + picWx4];
                var c = pic[off + i + picWx2] + pic[off + i + picWx3];
                blk[blkOff + i] = (MathUtil.clip((a + 5 * ((c << 2) - b) + 16) >> 5, -128, 127) << 24 >> 24);
            }
            off += picW;
            blkOff += blkStride;
        }
    };
    /**
     *  Hpel (0, 2) vertical unsafe
     */
    prototype.getLuma02UnsafeNoRound = function(pic, picW, picH, blk, blkOff, blkStride, x, y, blkW, blkH) {
        var maxH = picH - 1;
        var maxW = picW - 1;
        for (var j = 0; j < blkH; j++) {
            var offP0 = MathUtil.clip(y + j - 2, 0, maxH) * picW;
            var offP1 = MathUtil.clip(y + j - 1, 0, maxH) * picW;
            var offP2 = MathUtil.clip(y + j, 0, maxH) * picW;
            var offP3 = MathUtil.clip(y + j + 1, 0, maxH) * picW;
            var offP4 = MathUtil.clip(y + j + 2, 0, maxH) * picW;
            var offP5 = MathUtil.clip(y + j + 3, 0, maxH) * picW;
            for (var i = 0; i < blkW; i++) {
                var pres_x = MathUtil.clip(x + i, 0, maxW);
                var a = pic[pres_x + offP0] + pic[pres_x + offP5];
                var b = pic[pres_x + offP1] + pic[pres_x + offP4];
                var c = pic[pres_x + offP2] + pic[pres_x + offP3];
                blk[blkOff + i] = a + 5 * ((c << 2) - b);
            }
            blkOff += blkStride;
        }
    };
    prototype.getLuma02Unsafe = function(pic, picW, picH, blk, blkOff, blkStride, x, y, blkW, blkH) {
        this.getLuma02UnsafeNoRound(pic, picW, picH, this.tmp1, blkOff, blkStride, x, y, blkW, blkH);
        for (var j = 0; j < blkH; j++) {
            for (var i = 0; i < blkW; i++) {
                blk[blkOff + i] = (MathUtil.clip((this.tmp1[blkOff + i] + 16) >> 5, -128, 127) << 24 >> 24);
            }
            blkOff += blkStride;
        }
    };
    /**
     *  Qpel: (1,0) horizontal
     */
    prototype.getLuma10 = function(pic, picW, blk, blkOff, blkStride, x, y, blkW, blkH) {
        this.getLuma20(pic, picW, blk, blkOff, blkStride, x, y, blkW, blkH);
        var off = y * picW + x;
        for (var j = 0; j < blkH; j++) {
            for (var i = 0; i < blkW; i++) {
                blk[blkOff + i] = (((blk[blkOff + i] + pic[off + i] + 1) >> 1) << 24 >> 24);
            }
            off += picW;
            blkOff += blkStride;
        }
    };
    /**
     *  Qpel: (1,0) horizontal unsafe
     */
    prototype.getLuma10Unsafe = function(pic, picW, picH, blk, blkOff, blkStride, x, y, blkW, blkH) {
        var maxH = picH - 1;
        var maxW = picW - 1;
        this.getLuma20Unsafe(pic, picW, picH, blk, blkOff, blkStride, x, y, blkW, blkH);
        for (var j = 0; j < blkH; j++) {
            var lineStart = MathUtil.clip(j + y, 0, maxH) * picW;
            for (var i = 0; i < blkW; i++) {
                blk[blkOff + i] = (((blk[blkOff + i] + pic[lineStart + MathUtil.clip(x + i, 0, maxW)] + 1) >> 1) << 24 >> 24);
            }
            blkOff += blkStride;
        }
    };
    /**
     *  Qpel (3,0) horizontal
     */
    prototype.getLuma30 = function(pic, picW, blk, blkOff, blkStride, x, y, blkW, blkH) {
        this.getLuma20(pic, picW, blk, blkOff, blkStride, x, y, blkW, blkH);
        var off = y * picW + x;
        for (var j = 0; j < blkH; j++) {
            for (var i = 0; i < blkW; i++) {
                blk[blkOff + i] = (((pic[off + i + 1] + blk[blkOff + i] + 1) >> 1) << 24 >> 24);
            }
            off += picW;
            blkOff += blkStride;
        }
    };
    /**
     *  Qpel horizontal (3, 0) unsafe
     */
    prototype.getLuma30Unsafe = function(pic, picW, picH, blk, blkOff, blkStride, x, y, blkW, blkH) {
        var maxH = picH - 1;
        var maxW = picW - 1;
        this.getLuma20Unsafe(pic, picW, picH, blk, blkOff, blkStride, x, y, blkW, blkH);
        for (var j = 0; j < blkH; j++) {
            var lineStart = MathUtil.clip(j + y, 0, maxH) * picW;
            for (var i = 0; i < blkW; i++) {
                blk[blkOff + i] = (((blk[blkOff + i] + pic[lineStart + MathUtil.clip(x + i + 1, 0, maxW)] + 1) >> 1) << 24 >> 24);
            }
            blkOff += blkStride;
        }
    };
    /**
     *  Qpel vertical (0, 1)
     */
    prototype.getLuma01 = function(pic, picW, blk, blkOff, blkStride, x, y, blkW, blkH) {
        this.getLuma02(pic, picW, blk, blkOff, blkStride, x, y, blkW, blkH);
        var off = y * picW + x;
        for (var j = 0; j < blkH; j++) {
            for (var i = 0; i < blkW; i++) {
                blk[blkOff + i] = (((blk[blkOff + i] + pic[off + i] + 1) >> 1) << 24 >> 24);
            }
            off += picW;
            blkOff += blkStride;
        }
    };
    /**
     *  Qpel vertical (0, 1) unsafe
     */
    prototype.getLuma01Unsafe = function(pic, picW, picH, blk, blkOff, blkStride, x, y, blkW, blkH) {
        var maxH = picH - 1;
        var maxW = picW - 1;
        this.getLuma02Unsafe(pic, picW, picH, blk, blkOff, blkStride, x, y, blkW, blkH);
        for (var j = 0; j < blkH; j++) {
            var lineStart = MathUtil.clip(y + j, 0, maxH) * picW;
            for (var i = 0; i < blkW; i++) {
                blk[blkOff + i] = (((blk[blkOff + i] + pic[lineStart + MathUtil.clip(x + i, 0, maxW)] + 1) >> 1) << 24 >> 24);
            }
            blkOff += blkStride;
        }
    };
    /**
     *  Qpel vertical (0, 3)
     */
    prototype.getLuma03 = function(pic, picW, blk, blkOff, blkStride, x, y, blkW, blkH) {
        this.getLuma02(pic, picW, blk, blkOff, blkStride, x, y, blkW, blkH);
        var off = y * picW + x;
        for (var j = 0; j < blkH; j++) {
            for (var i = 0; i < blkW; i++) {
                blk[blkOff + i] = (((blk[blkOff + i] + pic[off + i + picW] + 1) >> 1) << 24 >> 24);
            }
            off += picW;
            blkOff += blkStride;
        }
    };
    /**
     *  Qpel vertical (0, 3) unsafe
     */
    prototype.getLuma03Unsafe = function(pic, picW, picH, blk, blkOff, blkStride, x, y, blkW, blkH) {
        var maxH = picH - 1;
        var maxW = picW - 1;
        this.getLuma02Unsafe(pic, picW, picH, blk, blkOff, blkStride, x, y, blkW, blkH);
        for (var j = 0; j < blkH; j++) {
            var lineStart = MathUtil.clip(y + j + 1, 0, maxH) * picW;
            for (var i = 0; i < blkW; i++) {
                blk[blkOff + i] = (((blk[blkOff + i] + pic[lineStart + MathUtil.clip(x + i, 0, maxW)] + 1) >> 1) << 24 >> 24);
            }
            blkOff += blkStride;
        }
    };
    /**
     *  Hpel horizontal, Qpel vertical (2, 1)
     *  
     */
    prototype.getLuma21 = function(pic, picW, blk, blkOff, blkStride, x, y, blkW, blkH) {
        this.getLuma20NoRound(pic, picW, this.tmp1, 0, blkW, x, y - 2, blkW, blkH + 7);
        this.getLuma02NoRoundInt(this.tmp1, blkW, this.tmp2, blkOff, blkStride, 0, 2, blkW, blkH);
        var off = blkW << 1;
        for (var j = 0; j < blkH; j++) {
            for (var i = 0; i < blkW; i++) {
                var rounded = MathUtil.clip((this.tmp2[blkOff + i] + 512) >> 10, -128, 127);
                var rounded2 = MathUtil.clip((this.tmp1[off + i] + 16) >> 5, -128, 127);
                blk[blkOff + i] = (((rounded + rounded2 + 1) >> 1) << 24 >> 24);
            }
            blkOff += blkStride;
            off += blkW;
        }
    };
    /**
     *  Qpel vertical (2, 1) unsafe
     */
    prototype.getLuma21Unsafe = function(pic, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
        this.getLuma20UnsafeNoRound(pic, picW, imgH, this.tmp1, 0, blkW, x, y - 2, blkW, blkH + 7);
        this.getLuma02NoRoundInt(this.tmp1, blkW, this.tmp2, blkOff, blkStride, 0, 2, blkW, blkH);
        var off = blkW << 1;
        for (var j = 0; j < blkH; j++) {
            for (var i = 0; i < blkW; i++) {
                var rounded = MathUtil.clip((this.tmp2[blkOff + i] + 512) >> 10, -128, 127);
                var rounded2 = MathUtil.clip((this.tmp1[off + i] + 16) >> 5, -128, 127);
                blk[blkOff + i] = (((rounded + rounded2 + 1) >> 1) << 24 >> 24);
            }
            blkOff += blkStride;
            off += blkW;
        }
    };
    /**
     *  Hpel horizontal, Hpel vertical (2, 2)
     */
    prototype.getLuma22 = function(pic, picW, blk, blkOff, blkStride, x, y, blkW, blkH) {
        this.getLuma20NoRound(pic, picW, this.tmp1, 0, blkW, x, y - 2, blkW, blkH + 7);
        this.getLuma02NoRoundInt(this.tmp1, blkW, this.tmp2, blkOff, blkStride, 0, 2, blkW, blkH);
        for (var j = 0; j < blkH; j++) {
            for (var i = 0; i < blkW; i++) {
                blk[blkOff + i] = ((MathUtil.clip((this.tmp2[blkOff + i] + 512) >> 10, -128, 127)) << 24 >> 24);
            }
            blkOff += blkStride;
        }
    };
    /**
     *  Hpel (2, 2) unsafe
     */
    prototype.getLuma22Unsafe = function(pic, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
        this.getLuma20UnsafeNoRound(pic, picW, imgH, this.tmp1, 0, blkW, x, y - 2, blkW, blkH + 7);
        this.getLuma02NoRoundInt(this.tmp1, blkW, this.tmp2, blkOff, blkStride, 0, 2, blkW, blkH);
        for (var j = 0; j < blkH; j++) {
            for (var i = 0; i < blkW; i++) {
                blk[blkOff + i] = (MathUtil.clip((this.tmp2[blkOff + i] + 512) >> 10, -128, 127) << 24 >> 24);
            }
            blkOff += blkStride;
        }
    };
    /**
     *  Hpel horizontal, Qpel vertical (2, 3)
     *  
     */
    prototype.getLuma23 = function(pic, picW, blk, blkOff, blkStride, x, y, blkW, blkH) {
        this.getLuma20NoRound(pic, picW, this.tmp1, 0, blkW, x, y - 2, blkW, blkH + 7);
        this.getLuma02NoRoundInt(this.tmp1, blkW, this.tmp2, blkOff, blkStride, 0, 2, blkW, blkH);
        var off = blkW << 1;
        for (var j = 0; j < blkH; j++) {
            for (var i = 0; i < blkW; i++) {
                var rounded = MathUtil.clip((this.tmp2[blkOff + i] + 512) >> 10, -128, 127);
                var rounded2 = MathUtil.clip((this.tmp1[off + i + blkW] + 16) >> 5, -128, 127);
                blk[blkOff + i] = (((rounded + rounded2 + 1) >> 1) << 24 >> 24);
            }
            blkOff += blkStride;
            off += blkW;
        }
    };
    /**
     *  Qpel (2, 3) unsafe
     */
    prototype.getLuma23Unsafe = function(pic, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
        this.getLuma20UnsafeNoRound(pic, picW, imgH, this.tmp1, 0, blkW, x, y - 2, blkW, blkH + 7);
        this.getLuma02NoRoundInt(this.tmp1, blkW, this.tmp2, blkOff, blkStride, 0, 2, blkW, blkH);
        var off = blkW << 1;
        for (var j = 0; j < blkH; j++) {
            for (var i = 0; i < blkW; i++) {
                var rounded = MathUtil.clip((this.tmp2[blkOff + i] + 512) >> 10, -128, 127);
                var rounded2 = MathUtil.clip((this.tmp1[off + i + blkW] + 16) >> 5, -128, 127);
                blk[blkOff + i] = (((rounded + rounded2 + 1) >> 1) << 24 >> 24);
            }
            blkOff += blkStride;
            off += blkW;
        }
    };
    /**
     *  Qpel horizontal, Hpel vertical (1, 2)
     */
    prototype.getLuma12 = function(pic, picW, blk, blkOff, blkStride, x, y, blkW, blkH) {
        var tmpW = blkW + 7;
        this.getLuma02NoRound(pic, picW, this.tmp1, 0, tmpW, x - 2, y, tmpW, blkH);
        this.getLuma20NoRoundInt(this.tmp1, tmpW, this.tmp2, blkOff, blkStride, 2, 0, blkW, blkH);
        var off = 2;
        for (var j = 0; j < blkH; j++) {
            for (var i = 0; i < blkW; i++) {
                var rounded = MathUtil.clip((this.tmp2[blkOff + i] + 512) >> 10, -128, 127);
                var rounded2 = MathUtil.clip((this.tmp1[off + i] + 16) >> 5, -128, 127);
                blk[blkOff + i] = (((rounded + rounded2 + 1) >> 1) << 24 >> 24);
            }
            blkOff += blkStride;
            off += tmpW;
        }
    };
    /**
     *  Qpel (1, 2) unsafe
     */
    prototype.getLuma12Unsafe = function(pic, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
        var tmpW = blkW + 7;
        this.getLuma02UnsafeNoRound(pic, picW, imgH, this.tmp1, 0, tmpW, x - 2, y, tmpW, blkH);
        this.getLuma20NoRoundInt(this.tmp1, tmpW, this.tmp2, blkOff, blkStride, 2, 0, blkW, blkH);
        var off = 2;
        for (var j = 0; j < blkH; j++) {
            for (var i = 0; i < blkW; i++) {
                var rounded = MathUtil.clip((this.tmp2[blkOff + i] + 512) >> 10, -128, 127);
                var rounded2 = MathUtil.clip((this.tmp1[off + i] + 16) >> 5, -128, 127);
                blk[blkOff + i] = (((rounded + rounded2 + 1) >> 1) << 24 >> 24);
            }
            blkOff += blkStride;
            off += tmpW;
        }
    };
    /**
     *  Qpel horizontal, Hpel vertical (3, 2)
     */
    prototype.getLuma32 = function(pic, picW, blk, blkOff, blkStride, x, y, blkW, blkH) {
        var tmpW = blkW + 7;
        this.getLuma02NoRound(pic, picW, this.tmp1, 0, tmpW, x - 2, y, tmpW, blkH);
        this.getLuma20NoRoundInt(this.tmp1, tmpW, this.tmp2, blkOff, blkStride, 2, 0, blkW, blkH);
        var off = 2;
        for (var j = 0; j < blkH; j++) {
            for (var i = 0; i < blkW; i++) {
                var rounded = MathUtil.clip((this.tmp2[blkOff + i] + 512) >> 10, -128, 127);
                var rounded2 = MathUtil.clip((this.tmp1[off + i + 1] + 16) >> 5, -128, 127);
                blk[blkOff + i] = (((rounded + rounded2 + 1) >> 1) << 24 >> 24);
            }
            blkOff += blkStride;
            off += tmpW;
        }
    };
    /**
     *  Qpel (3, 2) unsafe
     */
    prototype.getLuma32Unsafe = function(pic, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
        var tmpW = blkW + 7;
        this.getLuma02UnsafeNoRound(pic, picW, imgH, this.tmp1, 0, tmpW, x - 2, y, tmpW, blkH);
        this.getLuma20NoRoundInt(this.tmp1, tmpW, this.tmp2, blkOff, blkStride, 2, 0, blkW, blkH);
        var off = 2;
        for (var j = 0; j < blkH; j++) {
            for (var i = 0; i < blkW; i++) {
                var rounded = MathUtil.clip((this.tmp2[blkOff + i] + 512) >> 10, -128, 127);
                var rounded2 = MathUtil.clip((this.tmp1[off + i + 1] + 16) >> 5, -128, 127);
                blk[blkOff + i] = (((rounded + rounded2 + 1) >> 1) << 24 >> 24);
            }
            blkOff += blkStride;
            off += tmpW;
        }
    };
    /**
     *  Qpel horizontal, Qpel vertical (3, 3)
     */
    prototype.getLuma33 = function(pic, picW, blk, blkOff, blkStride, x, y, blkW, blkH) {
        this.getLuma20(pic, picW, blk, blkOff, blkStride, x, y + 1, blkW, blkH);
        this.getLuma02(pic, picW, this.tmp3, 0, blkW, x + 1, y, blkW, blkH);
        this.merge(blk, this.tmp3, blkOff, blkStride, blkW, blkH);
    };
    /**
     *  Qpel (3, 3) unsafe
     */
    prototype.getLuma33Unsafe = function(pic, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
        this.getLuma20Unsafe(pic, picW, imgH, blk, blkOff, blkStride, x, y + 1, blkW, blkH);
        this.getLuma02Unsafe(pic, picW, imgH, this.tmp3, 0, blkW, x + 1, y, blkW, blkH);
        this.merge(blk, this.tmp3, blkOff, blkStride, blkW, blkH);
    };
    /**
     *  Qpel horizontal, Qpel vertical (1, 1)
     */
    prototype.getLuma11 = function(pic, picW, blk, blkOff, blkStride, x, y, blkW, blkH) {
        this.getLuma20(pic, picW, blk, blkOff, blkStride, x, y, blkW, blkH);
        this.getLuma02(pic, picW, this.tmp3, 0, blkW, x, y, blkW, blkH);
        this.merge(blk, this.tmp3, blkOff, blkStride, blkW, blkH);
    };
    /**
     *  Qpel (1, 1) unsafe
     */
    prototype.getLuma11Unsafe = function(pic, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
        this.getLuma20Unsafe(pic, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH);
        this.getLuma02Unsafe(pic, picW, imgH, this.tmp3, 0, blkW, x, y, blkW, blkH);
        this.merge(blk, this.tmp3, blkOff, blkStride, blkW, blkH);
    };
    /**
     *  Qpel horizontal, Qpel vertical (1, 3)
     */
    prototype.getLuma13 = function(pic, picW, blk, blkOff, blkStride, x, y, blkW, blkH) {
        this.getLuma20(pic, picW, blk, blkOff, blkStride, x, y + 1, blkW, blkH);
        this.getLuma02(pic, picW, this.tmp3, 0, blkW, x, y, blkW, blkH);
        this.merge(blk, this.tmp3, blkOff, blkStride, blkW, blkH);
    };
    /**
     *  Qpel (1, 3) unsafe
     */
    prototype.getLuma13Unsafe = function(pic, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
        this.getLuma20Unsafe(pic, picW, imgH, blk, blkOff, blkStride, x, y + 1, blkW, blkH);
        this.getLuma02Unsafe(pic, picW, imgH, this.tmp3, 0, blkW, x, y, blkW, blkH);
        this.merge(blk, this.tmp3, blkOff, blkStride, blkW, blkH);
    };
    /**
     *  Qpel horizontal, Qpel vertical (3, 1)
     */
    prototype.getLuma31 = function(pels, picW, blk, blkOff, blkStride, x, y, blkW, blkH) {
        this.getLuma20(pels, picW, blk, blkOff, blkStride, x, y, blkW, blkH);
        this.getLuma02(pels, picW, this.tmp3, 0, blkW, x + 1, y, blkW, blkH);
        this.merge(blk, this.tmp3, blkOff, blkStride, blkW, blkH);
    };
    /**
     *  Qpel (3, 1) unsafe
     */
    prototype.getLuma31Unsafe = function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
        this.getLuma20Unsafe(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH);
        this.getLuma02Unsafe(pels, picW, imgH, this.tmp3, 0, blkW, x + 1, y, blkW, blkH);
        this.merge(blk, this.tmp3, blkOff, blkStride, blkW, blkH);
    };
    prototype.merge = function(first, second, blkOff, blkStride, blkW, blkH) {
        var tOff = 0;
        for (var j = 0; j < blkH; j++) {
            for (var i = 0; i < blkW; i++) {
                first[blkOff + i] = (((first[blkOff + i] + second[tOff + i] + 1) >> 1) << 24 >> 24);
            }
            blkOff += blkStride;
            tOff += blkW;
        }
    };
    /**
     *  Chroma (0,0)
     */
    prototype.getChroma00 = function(pic, picW, picH, blk, blkOff, blkStride, x, y, blkW, blkH) {
        var off = y * picW + x;
        for (var j = 0; j < blkH; j++) {
            System.arraycopy(pic, off, blk, blkOff, blkW);
            off += picW;
            blkOff += blkStride;
        }
    };
    prototype.getChroma00Unsafe = function(pic, picW, picH, blk, blkOff, blkStride, x, y, blkW, blkH) {
        var maxH = picH - 1;
        var maxW = picW - 1;
        for (var j = 0; j < blkH; j++) {
            var lineStart = MathUtil.clip(j + y, 0, maxH) * picW;
            for (var i = 0; i < blkW; i++) {
                blk[blkOff + i] = pic[lineStart + MathUtil.clip(x + i, 0, maxW)];
            }
            blkOff += blkStride;
        }
    };
    /**
     *  Chroma (X,0)
     */
    prototype.getChroma0X = function(pels, picW, picH, blk, blkOff, blkStride, fullX, fullY, fracY, blkW, blkH) {
        var w00 = fullY * picW + fullX;
        var w01 = w00 + (fullY < picH - 1 ? picW : 0);
        var eMy = 8 - fracY;
        for (var j = 0; j < blkH; j++) {
            for (var i = 0; i < blkW; i++) {
                blk[blkOff + i] = (((eMy * pels[w00 + i] + fracY * pels[w01 + i] + 4) >> 3) << 24 >> 24);
            }
            w00 += picW;
            w01 += picW;
            blkOff += blkStride;
        }
    };
    prototype.getChroma0XUnsafe = function(pels, picW, picH, blk, blkOff, blkStride, fullX, fullY, fracY, blkW, blkH) {
        var maxW = picW - 1;
        var maxH = picH - 1;
        var eMy = 8 - fracY;
        for (var j = 0; j < blkH; j++) {
            var off00 = MathUtil.clip(fullY + j, 0, maxH) * picW;
            var off01 = MathUtil.clip(fullY + j + 1, 0, maxH) * picW;
            for (var i = 0; i < blkW; i++) {
                var w00 = MathUtil.clip(fullX + i, 0, maxW) + off00;
                var w01 = MathUtil.clip(fullX + i, 0, maxW) + off01;
                blk[blkOff + i] = (((eMy * pels[w00] + fracY * pels[w01] + 4) >> 3) << 24 >> 24);
            }
            blkOff += blkStride;
        }
    };
    /**
     *  Chroma (X,0)
     */
    prototype.getChromaX0 = function(pels, picW, imgH, blk, blkOff, blkStride, fullX, fullY, fracX, blkW, blkH) {
        var w00 = fullY * picW + fullX;
        var w10 = w00 + (fullX < picW - 1 ? 1 : 0);
        var eMx = 8 - fracX;
        for (var j = 0; j < blkH; j++) {
            for (var i = 0; i < blkW; i++) {
                blk[blkOff + i] = (((eMx * pels[w00 + i] + fracX * pels[w10 + i] + 4) >> 3) << 24 >> 24);
            }
            w00 += picW;
            w10 += picW;
            blkOff += blkStride;
        }
    };
    prototype.getChromaX0Unsafe = function(pels, picW, picH, blk, blkOff, blkStride, fullX, fullY, fracX, blkW, blkH) {
        var eMx = 8 - fracX;
        var maxW = picW - 1;
        var maxH = picH - 1;
        for (var j = 0; j < blkH; j++) {
            for (var i = 0; i < blkW; i++) {
                var w00 = MathUtil.clip(fullY + j, 0, maxH) * picW + MathUtil.clip(fullX + i, 0, maxW);
                var w10 = MathUtil.clip(fullY + j, 0, maxH) * picW + MathUtil.clip(fullX + i + 1, 0, maxW);
                blk[blkOff + i] = (((eMx * pels[w00] + fracX * pels[w10] + 4) >> 3) << 24 >> 24);
            }
            blkOff += blkStride;
        }
    };
    /**
     *  Chroma (X,X)
     */
    prototype.getChromaXX = function(pels, picW, picH, blk, blkOff, blkStride, fullX, fullY, fracX, fracY, blkW, blkH) {
        var w00 = fullY * picW + fullX;
        var w01 = w00 + (fullY < picH - 1 ? picW : 0);
        var w10 = w00 + (fullX < picW - 1 ? 1 : 0);
        var w11 = w10 + w01 - w00;
        var eMx = 8 - fracX;
        var eMy = 8 - fracY;
        for (var j = 0; j < blkH; j++) {
            for (var i = 0; i < blkW; i++) {
                blk[blkOff + i] = (((eMx * eMy * pels[w00 + i] + fracX * eMy * pels[w10 + i] + eMx * fracY * pels[w01 + i] + fracX * fracY * pels[w11 + i] + 32) >> 6) << 24 >> 24);
            }
            blkOff += blkStride;
            w00 += picW;
            w01 += picW;
            w10 += picW;
            w11 += picW;
        }
    };
    prototype.getChromaXXUnsafe = function(pels, picW, picH, blk, blkOff, blkStride, fullX, fullY, fracX, fracY, blkW, blkH) {
        var maxH = picH - 1;
        var maxW = picW - 1;
        var eMx = 8 - fracX;
        var eMy = 8 - fracY;
        for (var j = 0; j < blkH; j++) {
            for (var i = 0; i < blkW; i++) {
                var w00 = MathUtil.clip(fullY + j, 0, maxH) * picW + MathUtil.clip(fullX + i, 0, maxW);
                var w01 = MathUtil.clip(fullY + j + 1, 0, maxH) * picW + MathUtil.clip(fullX + i, 0, maxW);
                var w10 = MathUtil.clip(fullY + j, 0, maxH) * picW + MathUtil.clip(fullX + i + 1, 0, maxW);
                var w11 = MathUtil.clip(fullY + j + 1, 0, maxH) * picW + MathUtil.clip(fullX + i + 1, 0, maxW);
                blk[blkOff + i] = (((eMx * eMy * pels[w00] + fracX * eMy * pels[w10] + eMx * fracY * pels[w01] + fracX * fracY * pels[w11] + 32) >> 6) << 24 >> 24);
            }
            blkOff += blkStride;
        }
    };
    constructor.LumaInterpolator = function() {};
    constructor.LumaInterpolator = stjs.extend(constructor.LumaInterpolator, null, [], function(constructor, prototype) {
        prototype.getLuma = function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {};
    }, {}, {});
    prototype.initSafe = function() {
        var self = this;
        return [new (stjs.extend(function BlockInterpolator$1() {}, null, [BlockInterpolator.LumaInterpolator], function(constructor, prototype) {
            prototype.getLuma = function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
                self.getLuma00(pels, picW, blk, blkOff, blkStride, x, y, blkW, blkH);
            };
        }, {}, {}))(), new (stjs.extend(function BlockInterpolator$2() {}, null, [BlockInterpolator.LumaInterpolator], function(constructor, prototype) {
            prototype.getLuma = function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
                self.getLuma10(pels, picW, blk, blkOff, blkStride, x, y, blkW, blkH);
            };
        }, {}, {}))(), new (stjs.extend(function BlockInterpolator$3() {}, null, [BlockInterpolator.LumaInterpolator], function(constructor, prototype) {
            prototype.getLuma = function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
                self.getLuma20(pels, picW, blk, blkOff, blkStride, x, y, blkW, blkH);
            };
        }, {}, {}))(), new (stjs.extend(function BlockInterpolator$4() {}, null, [BlockInterpolator.LumaInterpolator], function(constructor, prototype) {
            prototype.getLuma = function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
                self.getLuma30(pels, picW, blk, blkOff, blkStride, x, y, blkW, blkH);
            };
        }, {}, {}))(), new (stjs.extend(function BlockInterpolator$5() {}, null, [BlockInterpolator.LumaInterpolator], function(constructor, prototype) {
            prototype.getLuma = function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
                self.getLuma01(pels, picW, blk, blkOff, blkStride, x, y, blkW, blkH);
            };
        }, {}, {}))(), new (stjs.extend(function BlockInterpolator$6() {}, null, [BlockInterpolator.LumaInterpolator], function(constructor, prototype) {
            prototype.getLuma = function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
                self.getLuma11(pels, picW, blk, blkOff, blkStride, x, y, blkW, blkH);
            };
        }, {}, {}))(), new (stjs.extend(function BlockInterpolator$7() {}, null, [BlockInterpolator.LumaInterpolator], function(constructor, prototype) {
            prototype.getLuma = function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
                self.getLuma21(pels, picW, blk, blkOff, blkStride, x, y, blkW, blkH);
            };
        }, {}, {}))(), new (stjs.extend(function BlockInterpolator$8() {}, null, [BlockInterpolator.LumaInterpolator], function(constructor, prototype) {
            prototype.getLuma = function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
                self.getLuma31(pels, picW, blk, blkOff, blkStride, x, y, blkW, blkH);
            };
        }, {}, {}))(), new (stjs.extend(function BlockInterpolator$9() {}, null, [BlockInterpolator.LumaInterpolator], function(constructor, prototype) {
            prototype.getLuma = function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
                self.getLuma02(pels, picW, blk, blkOff, blkStride, x, y, blkW, blkH);
            };
        }, {}, {}))(), new (stjs.extend(function BlockInterpolator$10() {}, null, [BlockInterpolator.LumaInterpolator], function(constructor, prototype) {
            prototype.getLuma = function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
                self.getLuma12(pels, picW, blk, blkOff, blkStride, x, y, blkW, blkH);
            };
        }, {}, {}))(), new (stjs.extend(function BlockInterpolator$11() {}, null, [BlockInterpolator.LumaInterpolator], function(constructor, prototype) {
            prototype.getLuma = function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
                self.getLuma22(pels, picW, blk, blkOff, blkStride, x, y, blkW, blkH);
            };
        }, {}, {}))(), new (stjs.extend(function BlockInterpolator$12() {}, null, [BlockInterpolator.LumaInterpolator], function(constructor, prototype) {
            prototype.getLuma = function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
                self.getLuma32(pels, picW, blk, blkOff, blkStride, x, y, blkW, blkH);
            };
        }, {}, {}))(), new (stjs.extend(function BlockInterpolator$13() {}, null, [BlockInterpolator.LumaInterpolator], function(constructor, prototype) {
            prototype.getLuma = function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
                self.getLuma03(pels, picW, blk, blkOff, blkStride, x, y, blkW, blkH);
            };
        }, {}, {}))(), new (stjs.extend(function BlockInterpolator$14() {}, null, [BlockInterpolator.LumaInterpolator], function(constructor, prototype) {
            prototype.getLuma = function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
                self.getLuma13(pels, picW, blk, blkOff, blkStride, x, y, blkW, blkH);
            };
        }, {}, {}))(), new (stjs.extend(function BlockInterpolator$15() {}, null, [BlockInterpolator.LumaInterpolator], function(constructor, prototype) {
            prototype.getLuma = function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
                self.getLuma23(pels, picW, blk, blkOff, blkStride, x, y, blkW, blkH);
            };
        }, {}, {}))(), new (stjs.extend(function BlockInterpolator$16() {}, null, [BlockInterpolator.LumaInterpolator], function(constructor, prototype) {
            prototype.getLuma = function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
                self.getLuma33(pels, picW, blk, blkOff, blkStride, x, y, blkW, blkH);
            };
        }, {}, {}))()];
    };
    prototype.initUnsafe = function() {
        var self = this;
        return [new (stjs.extend(function BlockInterpolator$17() {}, null, [BlockInterpolator.LumaInterpolator], function(constructor, prototype) {
            prototype.getLuma = function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
                self.getLuma00Unsafe(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH);
            };
        }, {}, {}))(), new (stjs.extend(function BlockInterpolator$18() {}, null, [BlockInterpolator.LumaInterpolator], function(constructor, prototype) {
            prototype.getLuma = function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
                self.getLuma10Unsafe(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH);
            };
        }, {}, {}))(), new (stjs.extend(function BlockInterpolator$19() {}, null, [BlockInterpolator.LumaInterpolator], function(constructor, prototype) {
            prototype.getLuma = function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
                self.getLuma20Unsafe(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH);
            };
        }, {}, {}))(), new (stjs.extend(function BlockInterpolator$20() {}, null, [BlockInterpolator.LumaInterpolator], function(constructor, prototype) {
            prototype.getLuma = function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
                self.getLuma30Unsafe(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH);
            };
        }, {}, {}))(), new (stjs.extend(function BlockInterpolator$21() {}, null, [BlockInterpolator.LumaInterpolator], function(constructor, prototype) {
            prototype.getLuma = function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
                self.getLuma01Unsafe(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH);
            };
        }, {}, {}))(), new (stjs.extend(function BlockInterpolator$22() {}, null, [BlockInterpolator.LumaInterpolator], function(constructor, prototype) {
            prototype.getLuma = function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
                self.getLuma11Unsafe(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH);
            };
        }, {}, {}))(), new (stjs.extend(function BlockInterpolator$23() {}, null, [BlockInterpolator.LumaInterpolator], function(constructor, prototype) {
            prototype.getLuma = function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
                self.getLuma21Unsafe(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH);
            };
        }, {}, {}))(), new (stjs.extend(function BlockInterpolator$24() {}, null, [BlockInterpolator.LumaInterpolator], function(constructor, prototype) {
            prototype.getLuma = function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
                self.getLuma31Unsafe(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH);
            };
        }, {}, {}))(), new (stjs.extend(function BlockInterpolator$25() {}, null, [BlockInterpolator.LumaInterpolator], function(constructor, prototype) {
            prototype.getLuma = function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
                self.getLuma02Unsafe(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH);
            };
        }, {}, {}))(), new (stjs.extend(function BlockInterpolator$26() {}, null, [BlockInterpolator.LumaInterpolator], function(constructor, prototype) {
            prototype.getLuma = function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
                self.getLuma12Unsafe(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH);
            };
        }, {}, {}))(), new (stjs.extend(function BlockInterpolator$27() {}, null, [BlockInterpolator.LumaInterpolator], function(constructor, prototype) {
            prototype.getLuma = function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
                self.getLuma22Unsafe(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH);
            };
        }, {}, {}))(), new (stjs.extend(function BlockInterpolator$28() {}, null, [BlockInterpolator.LumaInterpolator], function(constructor, prototype) {
            prototype.getLuma = function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
                self.getLuma32Unsafe(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH);
            };
        }, {}, {}))(), new (stjs.extend(function BlockInterpolator$29() {}, null, [BlockInterpolator.LumaInterpolator], function(constructor, prototype) {
            prototype.getLuma = function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
                self.getLuma03Unsafe(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH);
            };
        }, {}, {}))(), new (stjs.extend(function BlockInterpolator$30() {}, null, [BlockInterpolator.LumaInterpolator], function(constructor, prototype) {
            prototype.getLuma = function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
                self.getLuma13Unsafe(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH);
            };
        }, {}, {}))(), new (stjs.extend(function BlockInterpolator$31() {}, null, [BlockInterpolator.LumaInterpolator], function(constructor, prototype) {
            prototype.getLuma = function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
                self.getLuma23Unsafe(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH);
            };
        }, {}, {}))(), new (stjs.extend(function BlockInterpolator$32() {}, null, [BlockInterpolator.LumaInterpolator], function(constructor, prototype) {
            prototype.getLuma = function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
                self.getLuma33Unsafe(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH);
            };
        }, {}, {}))()];
    };
}, {tmp1: "Int32Array", tmp2: "Int32Array", tmp3: "Int8Array", safe: "Array", unsafe: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var ImageOP = function() {};
ImageOP = stjs.extend(ImageOP, null, [], function(constructor, prototype) {
    /**
     *  
     *  @param src
     *  @param area
     *  @return
     */
    constructor.subImageWithFillInt = function(src, width, height, dst, dstW, dstH, offX, offY) {
        var srcHeight = Math.min(height - offY, dstH);
        var srcWidth = Math.min(width - offX, dstW);
        var srcStride = width;
        var dstOff = 0, srcOff = offY * srcStride + offX;
        var i;
        for (i = 0; i < srcHeight; i++) {
            var j;
            for (j = 0; j < srcWidth; j++) {
                dst[dstOff + j] = src[srcOff + j];
            }
            var lastPix = dst[j - 1];
            for (; j < dstW; j++) 
                dst[dstOff + j] = lastPix;
            srcOff += srcStride;
            dstOff += dstW;
        }
        var lastLine = dstOff - dstW;
        for (; i < dstH; i++) {
            System.arraycopy(dst, lastLine, dst, dstOff, dstW);
            dstOff += dstW;
        }
    };
    constructor.subImageWithFill = function(src, width, height, dst, dstW, dstH, offX, offY) {
        var srcHeight = Math.min(height - offY, dstH);
        var srcWidth = Math.min(width - offX, dstW);
        var srcStride = width;
        var dstOff = 0, srcOff = offY * srcStride + offX;
        var i;
        for (i = 0; i < srcHeight; i++) {
            var j;
            for (j = 0; j < srcWidth; j++) {
                dst[dstOff + j] = src[srcOff + j];
            }
            var lastPix = dst[j - 1];
            for (; j < dstW; j++) 
                dst[dstOff + j] = lastPix;
            srcOff += srcStride;
            dstOff += dstW;
        }
        var lastLine = dstOff - dstW;
        for (; i < dstH; i++) {
            System.arraycopy(dst, lastLine, dst, dstOff, dstW);
            dstOff += dstW;
        }
    };
    constructor.subImageWithFillPic = function(_in, out, rect) {
        var width = _in.getWidth();
        var height = _in.getHeight();
        var color = _in.getColor();
        var data = _in.getData();
        for (var i = 0; i < data.length; i++) {
            ImageOP.subImageWithFillInt(data[i], width >> color.compWidth[i], height >> color.compHeight[i], out.getPlaneData(i), rect.getWidth() >> color.compWidth[i], rect.getHeight() >> color.compHeight[i], rect.getX() >> color.compWidth[i], rect.getY() >> color.compHeight[i]);
        }
    };
    constructor.subImageWithFillPic8 = function(_in, out, rect) {
        var width = _in.getWidth();
        var height = _in.getHeight();
        var color = _in.getColor();
        var data = _in.getData();
        for (var i = 0; i < data.length; i++) {
            ImageOP.subImageWithFill(data[i], width >> color.compWidth[i], height >> color.compHeight[i], out.getPlaneData(i), rect.getWidth() >> color.compWidth[i], rect.getHeight() >> color.compHeight[i], rect.getX() >> color.compWidth[i], rect.getY() >> color.compHeight[i]);
        }
    };
}, {}, {});
var BaseInputStream = function() {
    InputStream.call(this);
};
BaseInputStream = stjs.extend(BaseInputStream, InputStream, [], function(constructor, prototype) {
    prototype.readByte = function() {};
    prototype.readBuffer = function(b, from, len) {};
}, {}, {});
var BaseOutputStream = function() {
    OutputStream.call(this);
};
BaseOutputStream = stjs.extend(BaseOutputStream, OutputStream, [], function(constructor, prototype) {
    prototype.writeByte = function(b) {};
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var RgbToBgr8Bit = function() {};
RgbToBgr8Bit = stjs.extend(RgbToBgr8Bit, null, [Transform8Bit], function(constructor, prototype) {
    prototype.transform = function(src, dst) {
        if (src.getColor() != ColorSpace.RGB && src.getColor() != ColorSpace.BGR || dst.getColor() != ColorSpace.RGB && dst.getColor() != ColorSpace.BGR) {
             throw new IllegalArgumentException("Expected RGB or BGR inputs, was: " + src.getColor() + ", " + dst.getColor());
        }
        var dataSrc = src.getPlaneData(0);
        var dataDst = dst.getPlaneData(0);
        for (var i = 0; i < dataSrc.length; i += 3) {
            var tmp = dataSrc[i + 2];
            dataDst[i + 2] = dataSrc[i];
            dataDst[i] = tmp;
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var BitReader = function(bb) {
    this.bb = bb;
    this.initPos = bb.position();
};
BitReader = stjs.extend(BitReader, null, [], function(constructor, prototype) {
    constructor.createBitReader = function(bb) {
        var r = new BitReader(bb);
        r.curInt = r.readInt();
        r.deficit = 0;
        return r;
    };
    prototype.deficit = -1;
    prototype.curInt = -1;
    prototype.bb = null;
    prototype.initPos = 0;
    prototype.fork = function() {
        var fork = new BitReader(this.bb.duplicate());
        fork.initPos = 0;
        fork.curInt = this.curInt;
        fork.deficit = this.deficit;
        return fork;
    };
    prototype.readInt = function() {
        if (this.bb.remaining() >= 4) {
            this.deficit -= 32;
            return ((this.bb.get() & 255) << 24) | ((this.bb.get() & 255) << 16) | ((this.bb.get() & 255) << 8) | (this.bb.get() & 255);
        } else 
            return this.readIntSafe();
    };
    prototype.readIntSafe = function() {
        this.deficit -= (this.bb.remaining() << 3);
        var res = 0;
        if (this.bb.hasRemaining()) 
            res |= this.bb.get() & 255;
        res <<= 8;
        if (this.bb.hasRemaining()) 
            res |= this.bb.get() & 255;
        res <<= 8;
        if (this.bb.hasRemaining()) 
            res |= this.bb.get() & 255;
        res <<= 8;
        if (this.bb.hasRemaining()) 
            res |= this.bb.get() & 255;
        return res;
    };
    prototype.read1Bit = function() {
        var ret = this.curInt >>> 31;
        this.curInt <<= 1;
        ++this.deficit;
        if (this.deficit == 32) {
            this.curInt = this.readInt();
        }
        return ret;
    };
    prototype.readNBit = function(n) {
        if (n > 32) 
             throw new IllegalArgumentException("Can not read more then 32 bit");
        var nn = n;
        var ret = 0;
        if (n + this.deficit > 31) {
            ret |= (this.curInt >>> this.deficit);
            n -= 32 - this.deficit;
            ret <<= n;
            this.deficit = 32;
            this.curInt = this.readInt();
        }
        if (n != 0) {
            ret |= this.curInt >>> (32 - n);
            this.curInt <<= n;
            this.deficit += n;
        }
        return ret;
    };
    prototype.moreData = function() {
        var remaining = this.bb.remaining() + 4 - ((this.deficit + 7) >> 3);
        return remaining > 1 || (remaining == 1 && this.curInt != 0);
    };
    prototype.remaining = function() {
        return (this.bb.remaining() << 3) + 32 - this.deficit;
    };
    prototype.isByteAligned = function() {
        return (this.deficit & 7) == 0;
    };
    prototype.skip = function(bits) {
        var left = bits;
        if (left + this.deficit > 31) {
            left -= 32 - this.deficit;
            this.deficit = 32;
            if (left > 31) {
                var skip = Math.min(left >> 3, this.bb.remaining());
                this.bb.setPosition(this.bb.position() + skip);
                left -= skip << 3;
            }
            this.curInt = this.readInt();
        }
        this.deficit += left;
        this.curInt <<= left;
        return bits;
    };
    prototype.skipFast = function(bits) {
        this.deficit += bits;
        this.curInt <<= bits;
        return bits;
    };
    prototype.align = function() {
        return (this.deficit & 7) > 0 ? this.skip(8 - (this.deficit & 7)) : 0;
    };
    prototype.check24Bits = function() {
        if (this.deficit > 16) {
            this.deficit -= 16;
            this.curInt |= this.nextIgnore16() << this.deficit;
        }
        if (this.deficit > 8) {
            this.deficit -= 8;
            this.curInt |= this.nextIgnore() << this.deficit;
        }
        return this.curInt >>> 8;
    };
    prototype.check16Bits = function() {
        if (this.deficit > 16) {
            this.deficit -= 16;
            this.curInt |= this.nextIgnore16() << this.deficit;
        }
        return this.curInt >>> 16;
    };
    prototype.readFast16 = function(n) {
        if (n == 0) 
            return 0;
        if (this.deficit > 16) {
            this.deficit -= 16;
            this.curInt |= this.nextIgnore16() << this.deficit;
        }
        var ret = this.curInt >>> (32 - n);
        this.deficit += n;
        this.curInt <<= n;
        return ret;
    };
    prototype.checkNBit = function(n) {
        if (n > 24) 
             throw new IllegalArgumentException("Can not check more then 24 bit");
         while (this.deficit + n > 32){
            this.deficit -= 8;
            this.curInt |= this.nextIgnore() << this.deficit;
        }
        var res = this.curInt >>> (32 - n);
        return res;
    };
    prototype.nextIgnore16 = function() {
        return this.bb.remaining() > 1 ? this.bb.getShort() & 65535 : (this.bb.hasRemaining() ? ((this.bb.get() & 255) << 8) : 0);
    };
    prototype.nextIgnore = function() {
        return this.bb.hasRemaining() ? this.bb.get() & 255 : 0;
    };
    prototype.curBit = function() {
        return this.deficit & 7;
    };
    prototype.lastByte = function() {
        return this.bb.remaining() + 4 - (this.deficit >> 3) <= 1;
    };
    prototype.terminate = function() {
        var putBack = (32 - this.deficit) >> 3;
        this.bb.setPosition(this.bb.position() - putBack);
    };
    prototype.position = function() {
        return ((this.bb.position() - this.initPos - 4) << 3) + this.deficit;
    };
    /**
     *  Stops this bit reader. Returns underlying ByteBuffer pointer to the next
     *  byte unread byte
     */
    prototype.stop = function() {
        this.bb.setPosition(this.bb.position() - ((32 - this.deficit) >> 3));
    };
    prototype.checkAllBits = function() {
        return this.curInt;
    };
}, {bb: "ByteBuffer"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A YUV picture
 *  
 *  @author The JCodec project
 *  @deprecated Use org.jcodec.common.model.Picture8Bit and related APIs
 *  
 */
var Picture = function(width, height, data, color, bitDepth, crop) {
    this.width = width;
    this.height = height;
    this.data = data;
    this.color = color;
    this.crop = crop;
    this.bitDepth = bitDepth;
};
Picture = stjs.extend(Picture, null, [], function(constructor, prototype) {
    prototype.color = null;
    prototype.width = 0;
    prototype.height = 0;
    prototype.data = null;
    prototype.crop = null;
    prototype.bitDepth = 0;
    constructor.createPicture = function(width, height, data, color) {
        return new Picture(width, height, data, color, 8, new Rect(0, 0, width, height));
    };
    constructor.createPictureWithDepth = function(width, height, data, color, bitDepth) {
        return new Picture(width, height, data, color, bitDepth, new Rect(0, 0, width, height));
    };
    constructor.createPictureCropped = function(width, height, data, color, crop) {
        return new Picture(width, height, data, color, 8, crop);
    };
    constructor.clonePicture = function(other) {
        return new Picture(other.width, other.height, other.data, other.color, other.bitDepth, other.crop);
    };
    constructor.create = function(width, height, colorSpace) {
        return Picture.doCreate(width, height, colorSpace, 8, null);
    };
    constructor.createWithDepth = function(width, height, colorSpace, bitDepth) {
        return Picture.doCreate(width, height, colorSpace, bitDepth, null);
    };
    constructor.createCropped = function(width, height, colorSpace, crop) {
        return Picture.doCreate(width, height, colorSpace, 8, crop);
    };
    constructor.doCreate = function(width, height, colorSpace, bitDepth, crop) {
        var planeSizes = new Int32Array(ColorSpace.MAX_PLANES);
        for (var i = 0; i < colorSpace.nComp; i++) {
            planeSizes[colorSpace.compPlane[i]] += (width >> colorSpace.compWidth[i]) * (height >> colorSpace.compHeight[i]);
        }
        var nPlanes = 0;
        for (var i = 0; i < ColorSpace.MAX_PLANES; i++) 
            nPlanes += planeSizes[i] != 0 ? 1 : 0;
        var data = Array(nPlanes);
        for (var i = 0, plane = 0; i < ColorSpace.MAX_PLANES; i++) {
            if (planeSizes[i] != 0) {
                data[plane++] = new Int32Array(planeSizes[i]);
            }
        }
        return new Picture(width, height, data, colorSpace, 8, crop);
    };
    prototype.getWidth = function() {
        return this.width;
    };
    prototype.getHeight = function() {
        return this.height;
    };
    prototype.getPlaneData = function(plane) {
        return this.data[plane];
    };
    prototype.getColor = function() {
        return this.color;
    };
    prototype.getData = function() {
        return this.data;
    };
    prototype.getBitDepth = function() {
        return this.bitDepth;
    };
    prototype.getCrop = function() {
        return this.crop;
    };
    prototype.getPlaneWidth = function(plane) {
        return this.width >> this.color.compWidth[plane];
    };
    prototype.getPlaneHeight = function(plane) {
        return this.height >> this.color.compHeight[plane];
    };
    prototype.compatible = function(src) {
        return src.color == this.color && src.width == this.width && src.height == this.height && src.bitDepth == this.bitDepth;
    };
    prototype.createCompatible = function() {
        return Picture.create(this.width, this.height, this.color);
    };
    prototype.copyFrom = function(src) {
        if (!this.compatible(src)) 
             throw new IllegalArgumentException("Can not copy to incompatible picture");
        for (var plane = 0; plane < this.color.nComp; plane++) {
            if (this.data[plane] == null) 
                continue;
            System.arraycopy(src.data[plane], 0, this.data[plane], 0, (this.width >> this.color.compWidth[plane]) * (this.height >> this.color.compHeight[plane]));
        }
    };
    prototype.cropped = function() {
        if (this.crop == null || (this.crop.getX() == 0 && this.crop.getY() == 0 && this.crop.getWidth() == this.width && this.crop.getHeight() == this.height)) 
            return this;
        var result = Picture.createWithDepth(this.crop.getWidth(), this.crop.getHeight(), this.color, this.bitDepth);
        for (var plane = 0; plane < this.color.nComp; plane++) {
            if (this.data[plane] == null) 
                continue;
            this.cropSub(this.data[plane], this.crop.getX() >> this.color.compWidth[plane], this.crop.getY() >> this.color.compHeight[plane], this.crop.getWidth() >> this.color.compWidth[plane], this.crop.getHeight() >> this.color.compHeight[plane], this.width >> this.color.compWidth[plane], result.data[plane]);
        }
        return result;
    };
    prototype.cropSub = function(src, x, y, w, h, srcStride, tgt) {
        var srcOff = y * srcStride + x, dstOff = 0;
        for (var i = 0; i < h; i++) {
            for (var j = 0; j < w; j++) 
                tgt[dstOff + j] = src[srcOff + j];
            srcOff += srcStride;
            dstOff += w;
        }
    };
    prototype.setCrop = function(crop) {
        this.crop = crop;
    };
    prototype.getCroppedWidth = function() {
        return this.crop == null ? this.width : this.crop.getWidth();
    };
    prototype.getCroppedHeight = function() {
        return this.crop == null ? this.height : this.crop.getHeight();
    };
    prototype.setBitDepth = function(bitDepth) {
        this.bitDepth = bitDepth;
    };
    prototype.equals = function(obj) {
        if (obj == null || !(stjs.isInstanceOf(obj.constructor, Picture))) 
            return false;
        var other = obj;
        if (other.getCroppedWidth() != this.getCroppedWidth() || other.getCroppedHeight() != this.getCroppedHeight() || other.getColor() != this.color) 
            return false;
        for (var i = 0; i < this.getData().length; i++) 
            if (!this.planeEquals(other, i)) 
                return false;
        return true;
    };
    prototype.planeEquals = function(other, plane) {
        var cw = this.color.compWidth[plane];
        var ch = this.color.compHeight[plane];
        var offA = other.getCrop() == null ? 0 : ((other.getCrop().getX() >> cw) + (other.getCrop().getY() >> ch) * (other.getWidth() >> cw));
        var offB = this.crop == null ? 0 : ((this.crop.getX() >> cw) + (this.crop.getY() >> ch) * (this.width >> cw));
        var planeData = other.getPlaneData(plane);
        for (var i = 0; i < this.getCroppedHeight() >> ch; i++ , offA += (other.getWidth() >> cw) , offB += (this.width >> cw)) {
            for (var j = 0; j < this.getCroppedWidth() >> cw; j++) {
                if (planeData[offA + j] != this.data[plane][offB + j]) 
                    return false;
            }
        }
        return true;
    };
}, {color: "ColorSpace", data: "Array", crop: "Rect"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A dummy implementation of H264 RBSP reading
 *  
 *  @author The JCodec project
 *  
 */
var DummyBitstreamReader = function(is) {
    this.is = is;
    this.curByte = is.read();
    this.nextByte = is.read();
    this.secondByte = is.read();
};
DummyBitstreamReader = stjs.extend(DummyBitstreamReader, null, [], function(constructor, prototype) {
    prototype.is = null;
    prototype.curByte = 0;
    prototype.nextByte = 0;
    prototype.secondByte = 0;
    prototype.nBit = 0;
    constructor.bitsRead = 0;
    prototype.cnt = 0;
    prototype.read1Bit = function() {
        return this.read1BitInt();
    };
    prototype.read1BitInt = function() {
        if (this.nBit == 8) {
            this.advance();
            if (this.curByte == -1) {
                return -1;
            }
        }
        var res = (this.curByte >> (7 - this.nBit)) & 1;
        this.nBit++;
        ++DummyBitstreamReader.bitsRead;
        return res;
    };
    prototype.readNBit = function(n) {
        if (n > 32) 
             throw new IllegalArgumentException("Can not read more then 32 bit");
        var val = 0;
        for (var i = 0; i < n; i++) {
            val <<= 1;
            val |= this.read1BitInt();
        }
        return val;
    };
    prototype.advance1 = function() {
        this.curByte = this.nextByte;
        this.nextByte = this.secondByte;
        this.secondByte = this.is.read();
    };
    prototype.advance = function() {
        this.advance1();
        this.nBit = 0;
    };
    prototype.readByte = function() {
        if (this.nBit > 0) {
            this.advance();
        }
        var res = this.curByte;
        this.advance();
        return res;
    };
    prototype.moreRBSPData = function() {
        if (this.nBit == 8) {
            this.advance();
        }
        var tail = 1 << (8 - this.nBit - 1);
        var mask = ((tail << 1) - 1);
        var hasTail = (this.curByte & mask) == tail;
        return !(this.curByte == -1 || (this.nextByte == -1 && hasTail));
    };
    prototype.getBitPosition = function() {
        return (DummyBitstreamReader.bitsRead * 8 + (this.nBit % 8));
    };
    prototype.moreData = function() {
        if (this.nBit == 8) 
            this.advance();
        if (this.curByte == -1) 
            return false;
        if (this.nextByte == -1 || (this.nextByte == 0 && this.secondByte == -1)) {
            var mask = (1 << (8 - this.nBit)) - 1;
            return (this.curByte & mask) != 0;
        }
        return true;
    };
    prototype.readRemainingByte = function() {
        return this.readNBit(8 - this.nBit);
    };
    prototype.peakNextBits = function(n) {
        if (n > 8) 
             throw new IllegalArgumentException("N should be less then 8");
        if (this.nBit == 8) {
            this.advance();
            if (this.curByte == -1) {
                return -1;
            }
        }
        var bits = new Int32Array(16 - this.nBit);
        var cnt = 0;
        for (var i = this.nBit; i < 8; i++) {
            bits[cnt++] = (this.curByte >> (7 - i)) & 1;
        }
        for (var i = 0; i < 8; i++) {
            bits[cnt++] = (this.nextByte >> (7 - i)) & 1;
        }
        var result = 0;
        for (var i = 0; i < n; i++) {
            result <<= 1;
            result |= bits[i];
        }
        return result;
    };
    prototype.isByteAligned = function() {
        return (this.nBit % 8) == 0;
    };
    prototype.close = function() {
        this.is.close();
    };
    prototype.getCurBit = function() {
        return this.nBit;
    };
    prototype.skip = function(bits) {
        this.nBit += bits;
        var was = this.nBit;
         while (this.nBit >= 8 && this.curByte != -1){
            this.advance1();
            this.nBit -= 8;
        }
        return was - this.nBit;
    };
    prototype.align = function() {
        var n = (8 - this.nBit) & 7;
        this.skip((8 - this.nBit) & 7);
        return n;
    };
    prototype.checkNBit = function(n) {
        return this.peakNextBits(n);
    };
    prototype.curBit = function() {
        return this.nBit;
    };
    prototype.lastByte = function() {
        return this.nextByte == -1 && this.secondByte == -1;
    };
}, {is: "InputStream"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Bitstream writer
 *  
 *  @author The JCodec project
 *  
 */
var BitWriter = function(buf) {
    this.buf = buf;
    this.initPos = buf.position();
};
BitWriter = stjs.extend(BitWriter, null, [], function(constructor, prototype) {
    prototype.buf = null;
    prototype.curInt = 0;
    prototype._curBit = 0;
    prototype.initPos = 0;
    prototype.fork = function() {
        var fork = new BitWriter(this.buf.duplicate());
        fork._curBit = this._curBit;
        fork.curInt = this.curInt;
        fork.initPos = this.initPos;
        return fork;
    };
    prototype.flush = function() {
        var toWrite = (this._curBit + 7) >> 3;
        for (var i = 0; i < toWrite; i++) {
            this.buf.put(((this.curInt >>> 24) << 24 >> 24));
            this.curInt <<= 8;
        }
    };
    prototype.putInt = function(i) {
        this.buf.put(((i >>> 24) << 24 >> 24));
        this.buf.put(((i >> 16) << 24 >> 24));
        this.buf.put(((i >> 8) << 24 >> 24));
        this.buf.put((i << 24 >> 24));
    };
    prototype.writeNBit = function(value, n) {
        if (n > 32) 
             throw new IllegalArgumentException("Max 32 bit to write");
        if (n == 0) 
            return;
        value &= -1 >>> (32 - n);
        if (32 - this._curBit >= n) {
            this.curInt |= value << (32 - this._curBit - n);
            this._curBit += n;
            if (this._curBit == 32) {
                this.putInt(this.curInt);
                this._curBit = 0;
                this.curInt = 0;
            }
        } else {
            var secPart = n - (32 - this._curBit);
            this.curInt |= value >>> secPart;
            this.putInt(this.curInt);
            this.curInt = value << (32 - secPart);
            this._curBit = secPart;
        }
    };
    prototype.write1Bit = function(bit) {
        this.curInt |= bit << (32 - this._curBit - 1);
        ++this._curBit;
        if (this._curBit == 32) {
            this.putInt(this.curInt);
            this._curBit = 0;
            this.curInt = 0;
        }
    };
    prototype.curBit = function() {
        return this._curBit & 7;
    };
    prototype.position = function() {
        return ((this.buf.position() - this.initPos) << 3) + this._curBit;
    };
    prototype.getBuffer = function() {
        return this.buf;
    };
}, {buf: "ByteBuffer"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Virtual movie. A movie constructed on-the-fly from virtual track data.
 *  
 *  Generic muxing
 *  
 *  @author The JCodec project
 *  
 */
var VirtualMovie = function(_arguments) {
    this.tracks = arguments;
};
VirtualMovie = stjs.extend(VirtualMovie, null, [], function(constructor, prototype) {
    prototype.chunks = null;
    prototype._headerChunk = null;
    prototype._size = 0;
    prototype.tracks = null;
    prototype.muxTracks = function() {
        var chch = new ArrayList();
        var heads = Array(this.tracks.length), tails = Array(this.tracks.length);
        for (var curChunk = 1; ; curChunk++) {
            var min = -1;
            for (var i = 0; i < heads.length; i++) {
                if (heads[i] == null) {
                    heads[i] = this.tracks[i].nextPacket();
                    if (heads[i] == null) 
                        continue;
                }
                min = min == -1 || heads[i].getPts() < heads[min].getPts() ? i : min;
            }
            if (min == -1) 
                break;
            chch.add(this.packetChunk(this.tracks[min], heads[min], curChunk, min, this._size));
            if (heads[min].getDataLen() >= 0) 
                this._size += heads[min].getDataLen();
             else 
                System.err.println("WARN: Negative frame data len!!!");
            tails[min] = heads[min];
            heads[min] = this.tracks[min].nextPacket();
        }
        this._headerChunk = this.headerChunk(chch, this.tracks, this._size);
        this._size += this._headerChunk.getDataLen();
        this.chunks = chch.toArray(Array(0));
    };
    prototype.packetChunk = function(track, pkt, chunkNo, trackNo, pos) {};
    prototype.headerChunk = function(chunks, tracks, dataSize) {};
    prototype.close = function() {
        for (var virtualTrack in this.tracks) {
            virtualTrack.close();
        }
    };
    prototype.getPacketAt = function(position) {
        if (position >= 0 && position < this._headerChunk.getDataLen()) 
            return this._headerChunk;
        for (var i = 0; i < this.chunks.length - 1; i++) {
            if (this.chunks[i + 1].getPos() > position) 
                return this.chunks[i];
        }
        if (position < this._size) 
            return this.chunks[this.chunks.length - 1];
        return null;
    };
    prototype.getPacketByNo = function(no) {
        if (no > this.chunks.length) 
            return null;
        if (no == 0) 
            return this._headerChunk;
        return this.chunks[no - 1];
    };
    prototype.size = function() {
        return this._size;
    };
}, {chunks: "Array", _headerChunk: "MovieSegment", tracks: "Array"}, {});
var MTSStreamType = function(tag, video, audio) {
    this.tag = tag;
    this.video = video;
    this.audio = audio;
    MTSStreamType._values.add(this);
};
MTSStreamType = stjs.extend(MTSStreamType, null, [], function(constructor, prototype) {
    constructor._values = new ArrayList();
    constructor.RESERVED = new MTSStreamType(0, false, false);
    constructor.VIDEO_MPEG1 = new MTSStreamType(1, true, false);
    constructor.VIDEO_MPEG2 = new MTSStreamType(2, true, false);
    constructor.AUDIO_MPEG1 = new MTSStreamType(3, false, true);
    constructor.AUDIO_MPEG2 = new MTSStreamType(4, false, true);
    constructor.PRIVATE_SECTION = new MTSStreamType(5, false, false);
    constructor.PRIVATE_DATA = new MTSStreamType(6, false, false);
    constructor.MHEG = new MTSStreamType(7, false, false);
    constructor.DSM_CC = new MTSStreamType(8, false, false);
    constructor.ATM_SYNC = new MTSStreamType(9, false, false);
    constructor.DSM_CC_A = new MTSStreamType(10, false, false);
    constructor.DSM_CC_B = new MTSStreamType(11, false, false);
    constructor.DSM_CC_C = new MTSStreamType(12, false, false);
    constructor.DSM_CC_D = new MTSStreamType(13, false, false);
    constructor.MPEG_AUX = new MTSStreamType(14, false, false);
    constructor.AUDIO_AAC_ADTS = new MTSStreamType(15, false, true);
    constructor.VIDEO_MPEG4 = new MTSStreamType(16, true, false);
    constructor.AUDIO_AAC_LATM = new MTSStreamType(17, false, true);
    constructor.FLEXMUX_PES = new MTSStreamType(18, false, false);
    constructor.FLEXMUX_SEC = new MTSStreamType(19, false, false);
    constructor.DSM_CC_SDP = new MTSStreamType(20, false, false);
    constructor.META_PES = new MTSStreamType(21, false, false);
    constructor.META_SEC = new MTSStreamType(22, false, false);
    constructor.DSM_CC_DATA_CAROUSEL = new MTSStreamType(23, false, false);
    constructor.DSM_CC_OBJ_CAROUSEL = new MTSStreamType(24, false, false);
    constructor.DSM_CC_SDP1 = new MTSStreamType(25, false, false);
    constructor.IPMP = new MTSStreamType(26, false, false);
    constructor.VIDEO_H264 = new MTSStreamType(27, true, false);
    constructor.AUDIO_AAC_RAW = new MTSStreamType(28, false, true);
    constructor.SUBS = new MTSStreamType(29, false, false);
    constructor.AUX_3D = new MTSStreamType(30, false, false);
    constructor.VIDEO_AVC_SVC = new MTSStreamType(31, true, false);
    constructor.VIDEO_AVC_MVC = new MTSStreamType(32, true, false);
    constructor.VIDEO_J2K = new MTSStreamType(33, true, false);
    constructor.VIDEO_MPEG2_3D = new MTSStreamType(34, true, false);
    constructor.VIDEO_H264_3D = new MTSStreamType(35, true, false);
    constructor.VIDEO_CAVS = new MTSStreamType(66, false, true);
    constructor.IPMP_STREAM = new MTSStreamType(127, false, false);
    constructor.AUDIO_AC3 = new MTSStreamType(129, false, true);
    constructor.AUDIO_DTS = new MTSStreamType(138, false, true);
    prototype.tag = 0;
    prototype.video = false;
    prototype.audio = false;
    constructor.values = function() {
        return MTSStreamType._values.toArray(Array(0));
    };
    constructor.fromTag = function(streamTypeTag) {
        var values = MTSStreamType.values();
        for (var i = 0; i < values.length; i++) {
            var streamType = values[i];
            if (streamType.tag == streamTypeTag) 
                return streamType;
        }
        return null;
    };
    prototype.getTag = function() {
        return this.tag;
    };
    prototype.isVideo = function() {
        return this.video;
    };
    prototype.isAudio = function() {
        return this.audio;
    };
}, {_values: {name: "List", arguments: ["MTSStreamType"]}, RESERVED: "MTSStreamType", VIDEO_MPEG1: "MTSStreamType", VIDEO_MPEG2: "MTSStreamType", AUDIO_MPEG1: "MTSStreamType", AUDIO_MPEG2: "MTSStreamType", PRIVATE_SECTION: "MTSStreamType", PRIVATE_DATA: "MTSStreamType", MHEG: "MTSStreamType", DSM_CC: "MTSStreamType", ATM_SYNC: "MTSStreamType", DSM_CC_A: "MTSStreamType", DSM_CC_B: "MTSStreamType", DSM_CC_C: "MTSStreamType", DSM_CC_D: "MTSStreamType", MPEG_AUX: "MTSStreamType", AUDIO_AAC_ADTS: "MTSStreamType", VIDEO_MPEG4: "MTSStreamType", AUDIO_AAC_LATM: "MTSStreamType", FLEXMUX_PES: "MTSStreamType", FLEXMUX_SEC: "MTSStreamType", DSM_CC_SDP: "MTSStreamType", META_PES: "MTSStreamType", META_SEC: "MTSStreamType", DSM_CC_DATA_CAROUSEL: "MTSStreamType", DSM_CC_OBJ_CAROUSEL: "MTSStreamType", DSM_CC_SDP1: "MTSStreamType", IPMP: "MTSStreamType", VIDEO_H264: "MTSStreamType", AUDIO_AAC_RAW: "MTSStreamType", SUBS: "MTSStreamType", AUX_3D: "MTSStreamType", VIDEO_AVC_SVC: "MTSStreamType", VIDEO_AVC_MVC: "MTSStreamType", VIDEO_J2K: "MTSStreamType", VIDEO_MPEG2_3D: "MTSStreamType", VIDEO_H264_3D: "MTSStreamType", VIDEO_CAVS: "MTSStreamType", IPMP_STREAM: "MTSStreamType", AUDIO_AC3: "MTSStreamType", AUDIO_DTS: "MTSStreamType"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  MXF demuxer
 *  
 *  @author The JCodec project
 *  
 */
var MXFUtil = function() {};
MXFUtil = stjs.extend(MXFUtil, null, [], function(constructor, prototype) {
    constructor.resolveRef = function(metadata, refs, class1) {
        var res = MXFUtil.resolveRefs(metadata, [refs], class1);
        return res.size() > 0 ? res.get(0) : null;
    };
    constructor.resolveRefs = function(metadata, refs, class1) {
        var copy = new ArrayList(metadata);
        for (var iterator = copy.iterator(); iterator.hasNext(); ) {
            var next = iterator.next();
            if (next.getUid() == null || !class1.isAssignableFrom(next.getClass())) 
                iterator.remove();
        }
        var result = new ArrayList();
        for (var i = 0; i < refs.length; i++) {
            for (var iterator$meta = copy.iterator(); iterator$meta.hasNext(); ) {
                var meta = iterator$meta.next();
                if (meta.getUid().equals(refs[i])) {
                    result.add(meta);
                }
            }
        }
        return result;
    };
    constructor.findMeta = function(metadata, class1) {
        for (var iterator$mxfMetadata = metadata.iterator(); iterator$mxfMetadata.hasNext(); ) {
            var mxfMetadata = iterator$mxfMetadata.next();
            if (mxfMetadata.getClass().isAssignableFrom(class1)) 
                return mxfMetadata;
        }
        return null;
    };
    constructor.findAllMeta = function(metadata, class1) {
        var result = new ArrayList();
        for (var iterator$mxfMetadata = metadata.iterator(); iterator$mxfMetadata.hasNext(); ) {
            var mxfMetadata = iterator$mxfMetadata.next();
            if (class1.isAssignableFrom(mxfMetadata.getClass())) 
                result.add(mxfMetadata);
        }
        return result;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var IntIntMap = function() {
    this.storage = this.createArray(IntIntMap.GROW_BY);
    Arrays.fill(this.storage, Integer.MIN_VALUE);
};
IntIntMap = stjs.extend(IntIntMap, null, [], function(constructor, prototype) {
    constructor.GROW_BY = 128;
    prototype.storage = null;
    prototype._size = 0;
    prototype.put = function(key, val) {
        if (val == Integer.MIN_VALUE) 
             throw new IllegalArgumentException("This implementation can not store " + Integer.MIN_VALUE);
        if (this.storage.length <= key) {
            var ns = this.createArray(key + IntIntMap.GROW_BY);
            System.arraycopy(this.storage, 0, ns, 0, this.storage.length);
            Arrays.fill(ns, this.storage.length, ns.length, Integer.MIN_VALUE);
            this.storage = ns;
        }
        if (this.storage[key] == Integer.MIN_VALUE) 
            this._size++;
        this.storage[key] = val;
    };
    prototype.get = function(key) {
        return key >= this.storage.length ? Integer.MIN_VALUE : this.storage[key];
    };
    prototype.contains = function(key) {
        return key >= 0 && key < this.storage.length;
    };
    prototype.keys = function() {
        var result = new Int32Array(this._size);
        for (var i = 0, r = 0; i < this.storage.length; i++) {
            if (this.storage[i] != Integer.MIN_VALUE) 
                result[r++] = i;
        }
        return result;
    };
    prototype.clear = function() {
        for (var i = 0; i < this.storage.length; i++) 
            this.storage[i] = Integer.MIN_VALUE;
        this._size = 0;
    };
    prototype.size = function() {
        return this._size;
    };
    prototype.remove = function(key) {
        if (this.storage[key] != Integer.MIN_VALUE) 
            this._size--;
        this.storage[key] = Integer.MIN_VALUE;
    };
    prototype.values = function() {
        var result = this.createArray(this._size);
        for (var i = 0, r = 0; i < this.storage.length; i++) {
            if (this.storage[i] != Integer.MIN_VALUE) 
                result[r++] = this.storage[i];
        }
        return result;
    };
    prototype.createArray = function(size) {
        return new Int32Array(size);
    };
}, {storage: "Int32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var IntArrayList = function(growAmount) {
    this.growAmount = growAmount;
    this.storage = new Int32Array(growAmount);
};
IntArrayList = stjs.extend(IntArrayList, null, [], function(constructor, prototype) {
    constructor.DEFAULT_GROW_AMOUNT = 128;
    prototype.storage = null;
    prototype._size = 0;
    prototype.growAmount = 0;
    constructor.createIntArrayList = function() {
        return new IntArrayList(IntArrayList.DEFAULT_GROW_AMOUNT);
    };
    prototype.toArray = function() {
        var result = new Int32Array(this._size);
        System.arraycopy(this.storage, 0, result, 0, this._size);
        return result;
    };
    prototype.add = function(val) {
        if (this._size >= this.storage.length) {
            var ns = new Int32Array(this.storage.length + this.growAmount);
            System.arraycopy(this.storage, 0, ns, 0, this.storage.length);
            this.storage = ns;
        }
        this.storage[this._size++] = val;
    };
    prototype.push = function(id) {
        this.add(id);
    };
    prototype.pop = function() {
        if (this._size == 0) 
            return;
        this._size--;
    };
    prototype.set = function(index, value) {
        this.storage[index] = value;
    };
    prototype.get = function(index) {
        return this.storage[index];
    };
    prototype.fill = function(start, end, val) {
        if (end > this.storage.length) {
            var ns = new Int32Array(end + this.growAmount);
            System.arraycopy(this.storage, 0, ns, 0, this.storage.length);
            this.storage = ns;
        }
        Arrays.fill(this.storage, start, end, val);
        this._size = Math.max(this._size, end);
    };
    prototype.size = function() {
        return this._size;
    };
    prototype.addAll = function(other) {
        if (this._size + other.length >= this.storage.length) {
            var ns = new Int32Array(this._size + this.growAmount + other.length);
            System.arraycopy(this.storage, 0, ns, 0, this._size);
            this.storage = ns;
        }
        System.arraycopy(other, 0, this.storage, this._size, other.length);
        this._size += other.length;
    };
    prototype.clear = function() {
        this._size = 0;
    };
    prototype.contains = function(needle) {
        for (var i = 0; i < this._size; i++) 
            if (this.storage[i] == needle) 
                return true;
        return false;
    };
}, {storage: "Int32Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 * 
 *  @author in-somnia
 */
var FBT = function() {};
FBT = stjs.extend(FBT, null, [SBRConstants], function(constructor, prototype) {
    constructor.qmf_start_channel = function(bs_start_freq, bs_samplerate_mode, sample_rate) {
        var startMin = SBRConstants.startMinTable[sample_rate.getIndex()];
        var offsetIndex = SBRConstants.offsetIndexTable[sample_rate.getIndex()];
        if (bs_samplerate_mode != 0) {
            return startMin + SBRConstants.OFFSET[offsetIndex][bs_start_freq];
        } else {
            return startMin + SBRConstants.OFFSET[6][bs_start_freq];
        }
    };
    constructor.stopMinTable = new Int32Array([13, 15, 20, 21, 23, 32, 32, 35, 48, 64, 70, 96]);
    constructor.STOP_OFFSET_TABLE = [new Int32Array([0, 2, 4, 6, 8, 11, 14, 18, 22, 26, 31, 37, 44, 51]), new Int32Array([0, 2, 4, 6, 8, 11, 14, 18, 22, 26, 31, 36, 42, 49]), new Int32Array([0, 2, 4, 6, 8, 11, 14, 17, 21, 25, 29, 34, 39, 44]), new Int32Array([0, 2, 4, 6, 8, 11, 14, 17, 20, 24, 28, 33, 38, 43]), new Int32Array([0, 2, 4, 6, 8, 11, 14, 17, 20, 24, 28, 32, 36, 41]), new Int32Array([0, 2, 4, 6, 8, 10, 12, 14, 17, 20, 23, 26, 29, 32]), new Int32Array([0, 2, 4, 6, 8, 10, 12, 14, 17, 20, 23, 26, 29, 32]), new Int32Array([0, 1, 3, 5, 7, 9, 11, 13, 15, 17, 20, 23, 26, 29]), new Int32Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 14, 16]), new Int32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), new Int32Array([0, -1, -2, -3, -4, -5, -6, -6, -6, -6, -6, -6, -6, -6]), new Int32Array([0, -3, -6, -9, -12, -15, -18, -20, -22, -24, -26, -28, -30, -32])];
    constructor.qmf_stop_channel = function(bs_stop_freq, sample_rate, k0) {
        if (bs_stop_freq == 15) {
            return Math.min(64, k0 * 3);
        } else if (bs_stop_freq == 14) {
            return Math.min(64, k0 * 2);
        } else {
            var stopMin = FBT.stopMinTable[sample_rate.getIndex()];
            return Math.min(64, stopMin + FBT.STOP_OFFSET_TABLE[sample_rate.getIndex()][Math.min(bs_stop_freq, 13)]);
        }
    };
    constructor.master_frequency_table_fs0 = function(sbr, k0, k2, bs_alter_scale) {
        var incr;
        var k;
        var dk;
        var nrBands, k2Achieved;
        var k2Diff;
        var vDk = new Int32Array(64);
        if (k2 <= k0) {
            sbr.N_master = 0;
            return 1;
        }
        dk = bs_alter_scale ? 2 : 1;
        if (bs_alter_scale) {
            nrBands = (((k2 - k0 + 2) >> 2) << 1);
        } else {
            nrBands = (((k2 - k0) >> 1) << 1);
        }
        nrBands = Math.min(nrBands, 63);
        if (nrBands <= 0) 
            return 1;
        k2Achieved = k0 + nrBands * dk;
        k2Diff = k2 - k2Achieved;
        for (k = 0; k < nrBands; k++) {
            vDk[k] = dk;
        }
        if (k2Diff != 0) {
            incr = (k2Diff > 0) ? -1 : 1;
            k = ((k2Diff > 0) ? (nrBands - 1) : 0);
             while (k2Diff != 0){
                vDk[k] -= incr;
                k += incr;
                k2Diff += incr;
            }
        }
        sbr.f_master[0] = k0;
        for (k = 1; k <= nrBands; k++) {
            sbr.f_master[k] = (sbr.f_master[k - 1] + vDk[k - 1]);
        }
        sbr.N_master = nrBands;
        sbr.N_master = Math.min(sbr.N_master, 64);
        return 0;
    };
    constructor.find_bands = function(warp, bands, a0, a1) {
        var div = Math.log(2.0);
        if (warp != 0) 
            div *= 1.3;
        return stjs.trunc((bands * Math.log(a1 / a0) / div + 0.5));
    };
    constructor.find_initial_power = function(bands, a0, a1) {
        return Math.pow(a1 / a0, 1.0 / bands);
    };
    constructor.master_frequency_table = function(sbr, k0, k2, bs_freq_scale, bs_alter_scale) {
        var k, bands;
        var twoRegions;
        var k1;
        var nrBand0, nrBand1;
        var vDk0 = new Int32Array(64), vDk1 = new Int32Array(64);
        var vk0 = new Int32Array(64), vk1 = new Int32Array(64);
        var temp1 = new Int32Array([6, 5, 4]);
        var q, qk;
        var A_1;
        if (k2 <= k0) {
            sbr.N_master = 0;
            return 1;
        }
        bands = temp1[bs_freq_scale - 1];
        if (k2 / k0 > 2.2449) {
            twoRegions = true;
            k1 = k0 << 1;
        } else {
            twoRegions = false;
            k1 = k2;
        }
        nrBand0 = (2 * FBT.find_bands(0, bands, k0, k1));
        nrBand0 = Math.min(nrBand0, 63);
        if (nrBand0 <= 0) 
            return 1;
        q = FBT.find_initial_power(nrBand0, k0, k1);
        qk = k0;
        A_1 = stjs.trunc((qk + 0.5));
        for (k = 0; k <= nrBand0; k++) {
            var A_0 = A_1;
            qk *= q;
            A_1 = stjs.trunc((qk + 0.5));
            vDk0[k] = A_1 - A_0;
        }
        Arrays.sort(vDk0, 0, nrBand0);
        vk0[0] = k0;
        for (k = 1; k <= nrBand0; k++) {
            vk0[k] = vk0[k - 1] + vDk0[k - 1];
            if (vDk0[k - 1] == 0) 
                return 1;
        }
        if (!twoRegions) {
            for (k = 0; k <= nrBand0; k++) {
                sbr.f_master[k] = vk0[k];
            }
            sbr.N_master = nrBand0;
            sbr.N_master = Math.min(sbr.N_master, 64);
            return 0;
        }
        nrBand1 = (2 * FBT.find_bands(1, bands, k1, k2));
        nrBand1 = Math.min(nrBand1, 63);
        q = FBT.find_initial_power(nrBand1, k1, k2);
        qk = k1;
        A_1 = stjs.trunc((qk + 0.5));
        for (k = 0; k <= nrBand1 - 1; k++) {
            var A_0 = A_1;
            qk *= q;
            A_1 = stjs.trunc((qk + 0.5));
            vDk1[k] = A_1 - A_0;
        }
        if (vDk1[0] < vDk0[nrBand0 - 1]) {
            var change;
            Arrays.sort(vDk1, 0, nrBand1 + 1);
            change = vDk0[nrBand0 - 1] - vDk1[0];
            vDk1[0] = vDk0[nrBand0 - 1];
            vDk1[nrBand1 - 1] = vDk1[nrBand1 - 1] - change;
        }
        Arrays.sort(vDk1, 0, nrBand1);
        vk1[0] = k1;
        for (k = 1; k <= nrBand1; k++) {
            vk1[k] = vk1[k - 1] + vDk1[k - 1];
            if (vDk1[k - 1] == 0) 
                return 1;
        }
        sbr.N_master = nrBand0 + nrBand1;
        sbr.N_master = Math.min(sbr.N_master, 64);
        for (k = 0; k <= nrBand0; k++) {
            sbr.f_master[k] = vk0[k];
        }
        for (k = nrBand0 + 1; k <= sbr.N_master; k++) {
            sbr.f_master[k] = vk1[k - nrBand0];
        }
        return 0;
    };
    constructor.derived_frequency_table = function(sbr, bs_xover_band, k2) {
        var k, i = 0;
        var minus;
        if (sbr.N_master <= bs_xover_band) 
            return 1;
        sbr.N_high = sbr.N_master - bs_xover_band;
        sbr.N_low = (sbr.N_high >> 1) + (sbr.N_high - ((sbr.N_high >> 1) << 1));
        sbr.n[0] = sbr.N_low;
        sbr.n[1] = sbr.N_high;
        for (k = 0; k <= sbr.N_high; k++) {
            sbr.f_table_res[SBRConstants.HI_RES][k] = sbr.f_master[k + bs_xover_band];
        }
        sbr.M = sbr.f_table_res[SBRConstants.HI_RES][sbr.N_high] - sbr.f_table_res[SBRConstants.HI_RES][0];
        sbr.kx = sbr.f_table_res[SBRConstants.HI_RES][0];
        if (sbr.kx > 32) 
            return 1;
        if (sbr.kx + sbr.M > 64) 
            return 1;
        minus = ((sbr.N_high & 1) != 0) ? 1 : 0;
        for (k = 0; k <= sbr.N_low; k++) {
            if (k == 0) 
                i = 0;
             else 
                i = (2 * k - minus);
            sbr.f_table_res[SBRConstants.LO_RES][k] = sbr.f_table_res[SBRConstants.HI_RES][i];
        }
        sbr.N_Q = 0;
        if (sbr.bs_noise_bands == 0) {
            sbr.N_Q = 1;
        } else {
            sbr.N_Q = (Math.max(1, FBT.find_bands(0, sbr.bs_noise_bands, sbr.kx, k2)));
            sbr.N_Q = Math.min(5, sbr.N_Q);
        }
        for (k = 0; k <= sbr.N_Q; k++) {
            if (k == 0) {
                i = 0;
            } else {
                i += stjs.trunc((sbr.N_low - i) / (sbr.N_Q + 1 - k));
            }
            sbr.f_table_noise[k] = sbr.f_table_res[SBRConstants.LO_RES][i];
        }
        for (k = 0; k < 64; k++) {
            var g;
            for (g = 0; g < sbr.N_Q; g++) {
                if ((sbr.f_table_noise[g] <= k) && (k < sbr.f_table_noise[g + 1])) {
                    sbr.table_map_k_to_g[k] = g;
                    break;
                }
            }
        }
        return 0;
    };
    constructor.limiterBandsCompare = new Float32Array([1.327152, 1.185093, 1.119872]);
    constructor.limiter_frequency_table = function(sbr) {
        var k, s;
        var nrLim;
        sbr.f_table_lim[0][0] = sbr.f_table_res[SBRConstants.LO_RES][0] - sbr.kx;
        sbr.f_table_lim[0][1] = sbr.f_table_res[SBRConstants.LO_RES][sbr.N_low] - sbr.kx;
        sbr.N_L[0] = 1;
        for (s = 1; s < 4; s++) {
            var limTable = new Int32Array(100);
            var patchBorders = new Int32Array(64);
            patchBorders[0] = sbr.kx;
            for (k = 1; k <= sbr.noPatches; k++) {
                patchBorders[k] = patchBorders[k - 1] + sbr.patchNoSubbands[k - 1];
            }
            for (k = 0; k <= sbr.N_low; k++) {
                limTable[k] = sbr.f_table_res[SBRConstants.LO_RES][k];
            }
            for (k = 1; k < sbr.noPatches; k++) {
                limTable[k + sbr.N_low] = patchBorders[k];
            }
            Arrays.sort(limTable, 0, sbr.noPatches + sbr.N_low);
            k = 1;
            nrLim = sbr.noPatches + sbr.N_low - 1;
            if (nrLim < 0) 
                return;
            restart:
                 while (k <= nrLim){
                    var nOctaves;
                    if (limTable[k - 1] != 0) 
                        nOctaves = limTable[k] / limTable[k - 1];
                     else 
                        nOctaves = 0;
                    if (nOctaves < FBT.limiterBandsCompare[s - 1]) {
                        var i;
                        if (limTable[k] != limTable[k - 1]) {
                            var found = false, found2 = false;
                            for (i = 0; i <= sbr.noPatches; i++) {
                                if (limTable[k] == patchBorders[i]) 
                                    found = true;
                            }
                            if (found) {
                                found2 = false;
                                for (i = 0; i <= sbr.noPatches; i++) {
                                    if (limTable[k - 1] == patchBorders[i]) 
                                        found2 = true;
                                }
                                if (found2) {
                                    k++;
                                    continue;
                                } else {
                                    limTable[k - 1] = sbr.f_table_res[SBRConstants.LO_RES][sbr.N_low];
                                    Arrays.sort(limTable, 0, sbr.noPatches + sbr.N_low);
                                    nrLim--;
                                    continue;
                                }
                            }
                        }
                        limTable[k] = sbr.f_table_res[SBRConstants.LO_RES][sbr.N_low];
                        Arrays.sort(limTable, 0, nrLim);
                        nrLim--;
                    } else {
                        k++;
                    }
                }
            sbr.N_L[s] = nrLim;
            for (k = 0; k <= nrLim; k++) {
                sbr.f_table_lim[s][k] = limTable[k] - sbr.kx;
            }
        }
    };
}, {stopMinTable: "Int32Array", STOP_OFFSET_TABLE: "Array", limiterBandsCompare: "Float32Array", startMinTable: "Int32Array", offsetIndexTable: "Int32Array", OFFSET: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var ByteArrayList = function(growAmount) {
    this.growAmount = growAmount;
    this.storage = new Int8Array(growAmount);
};
ByteArrayList = stjs.extend(ByteArrayList, null, [], function(constructor, prototype) {
    constructor.DEFAULT_GROW_AMOUNT = 2048;
    constructor.createByteArrayList = function() {
        return new ByteArrayList(ByteArrayList.DEFAULT_GROW_AMOUNT);
    };
    prototype.storage = null;
    prototype._size = 0;
    prototype.growAmount = 0;
    prototype.toArray = function() {
        var result = new Int8Array(this._size);
        System.arraycopy(this.storage, 0, result, 0, this._size);
        return result;
    };
    prototype.add = function(val) {
        if (this._size >= this.storage.length) {
            var ns = new Int8Array(this.storage.length + this.growAmount);
            System.arraycopy(this.storage, 0, ns, 0, this.storage.length);
            this.storage = ns;
        }
        this.storage[this._size++] = val;
    };
    prototype.push = function(id) {
        this.add(id);
    };
    prototype.pop = function() {
        if (this._size == 0) 
            return;
        this._size--;
    };
    prototype.set = function(index, value) {
        this.storage[index] = value;
    };
    prototype.get = function(index) {
        return this.storage[index];
    };
    prototype.fill = function(start, end, val) {
        if (end > this.storage.length) {
            var ns = new Int8Array(end + this.growAmount);
            System.arraycopy(this.storage, 0, ns, 0, this.storage.length);
            this.storage = ns;
        }
        Arrays.fill(this.storage, start, end, val);
        this._size = Math.max(this._size, end);
    };
    prototype.size = function() {
        return this._size;
    };
    prototype.addAll = function(other) {
        if (this._size + other.length >= this.storage.length) {
            var ns = new Int8Array(this._size + this.growAmount + other.length);
            System.arraycopy(this.storage, 0, ns, 0, this._size);
            this.storage = ns;
        }
        System.arraycopy(other, 0, this.storage, this._size, other.length);
        this._size += other.length;
    };
    prototype.contains = function(needle) {
        for (var i = 0; i < this._size; i++) 
            if (this.storage[i] == needle) 
                return true;
        return false;
    };
}, {storage: "Int8Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var LongArrayList = function(growAmount) {
    this.growAmount = growAmount;
    this.storage = Array(growAmount);
};
LongArrayList = stjs.extend(LongArrayList, null, [], function(constructor, prototype) {
    constructor.DEFAULT_GROW_AMOUNT = 128;
    prototype.storage = null;
    prototype._size = 0;
    prototype.growAmount = 0;
    constructor.createLongArrayList = function() {
        return new LongArrayList(LongArrayList.DEFAULT_GROW_AMOUNT);
    };
    prototype.toArray = function() {
        var result = Array(this._size);
        System.arraycopy(this.storage, 0, result, 0, this._size);
        return result;
    };
    prototype.add = function(val) {
        if (this._size >= this.storage.length) {
            var ns = Array(this.storage.length + this.growAmount);
            System.arraycopy(this.storage, 0, ns, 0, this.storage.length);
            this.storage = ns;
        }
        this.storage[this._size++] = val;
    };
    prototype.push = function(id) {
        this.add(id);
    };
    prototype.pop = function() {
        if (this._size == 0) 
            return;
        this._size--;
    };
    prototype.set = function(index, value) {
        this.storage[index] = value;
    };
    prototype.get = function(index) {
        return this.storage[index];
    };
    prototype.fill = function(start, end, val) {
        if (end > this.storage.length) {
            var ns = Array(end + this.growAmount);
            System.arraycopy(this.storage, 0, ns, 0, this.storage.length);
            this.storage = ns;
        }
        Arrays.fill(this.storage, start, end, val);
        this._size = Math.max(this._size, end);
    };
    prototype.size = function() {
        return this._size;
    };
    prototype.addAll = function(other) {
        if (this._size + other.length >= this.storage.length) {
            var ns = Array(this._size + this.growAmount + other.length);
            System.arraycopy(this.storage, 0, ns, 0, this._size);
            this.storage = ns;
        }
        System.arraycopy(other, 0, this.storage, this._size, other.length);
        this._size += other.length;
    };
    prototype.clear = function() {
        this._size = 0;
    };
    prototype.contains = function(needle) {
        for (var i = 0; i < this._size; i++) 
            if (this.storage[i] == needle) 
                return true;
        return false;
    };
}, {storage: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A block map that that maps macroblocks sequentially in scan order
 *  
 *  @author The JCodec project
 *  
 */
var FlatMBlockMapper = function(frameWidthInMbs, firstMBAddr) {
    this.frameWidthInMbs = frameWidthInMbs;
    this.firstMBAddr = firstMBAddr;
};
FlatMBlockMapper = stjs.extend(FlatMBlockMapper, null, [Mapper], function(constructor, prototype) {
    prototype.frameWidthInMbs = 0;
    prototype.firstMBAddr = 0;
    prototype.leftAvailable = function(index) {
        var mbAddr = index + this.firstMBAddr;
        var atTheBorder = mbAddr % this.frameWidthInMbs == 0;
        return !atTheBorder && (mbAddr > this.firstMBAddr);
    };
    prototype.topAvailable = function(index) {
        var mbAddr = index + this.firstMBAddr;
        return mbAddr - this.frameWidthInMbs >= this.firstMBAddr;
    };
    prototype.getAddress = function(index) {
        return this.firstMBAddr + index;
    };
    prototype.getMbX = function(index) {
        return this.getAddress(index) % this.frameWidthInMbs;
    };
    prototype.getMbY = function(index) {
        return stjs.trunc(this.getAddress(index) / this.frameWidthInMbs);
    };
    prototype.topRightAvailable = function(index) {
        var mbAddr = index + this.firstMBAddr;
        var atTheBorder = (mbAddr + 1) % this.frameWidthInMbs == 0;
        return !atTheBorder && mbAddr - this.frameWidthInMbs + 1 >= this.firstMBAddr;
    };
    prototype.topLeftAvailable = function(index) {
        var mbAddr = index + this.firstMBAddr;
        var atTheBorder = mbAddr % this.frameWidthInMbs == 0;
        return !atTheBorder && mbAddr - this.frameWidthInMbs - 1 >= this.firstMBAddr;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A macrboblock to slice group mapper that operates on prebuilt map, passed to
 *  it in the constructor
 *  
 *  @author The JCodec project
 *  
 */
var PrebuiltMBlockMapper = function(map, firstMBInSlice, picWidthInMbs) {
    this.map = map;
    this.firstMBInSlice = firstMBInSlice;
    this.groupId = map.getGroups()[firstMBInSlice];
    this.picWidthInMbs = picWidthInMbs;
    this.indexOfFirstMb = map.getIndices()[firstMBInSlice];
};
PrebuiltMBlockMapper = stjs.extend(PrebuiltMBlockMapper, null, [Mapper], function(constructor, prototype) {
    prototype.map = null;
    prototype.firstMBInSlice = 0;
    prototype.groupId = 0;
    prototype.picWidthInMbs = 0;
    prototype.indexOfFirstMb = 0;
    prototype.getAddress = function(mbIndex) {
        return this.map.getInverse()[this.groupId][mbIndex + this.indexOfFirstMb];
    };
    prototype.leftAvailable = function(mbIndex) {
        var mbAddr = this.map.getInverse()[this.groupId][mbIndex + this.indexOfFirstMb];
        var leftMBAddr = mbAddr - 1;
        return !((leftMBAddr < this.firstMBInSlice) || ((mbAddr % this.picWidthInMbs) == 0) || (this.map.getGroups()[leftMBAddr] != this.groupId));
    };
    prototype.topAvailable = function(mbIndex) {
        var mbAddr = this.map.getInverse()[this.groupId][mbIndex + this.indexOfFirstMb];
        var topMBAddr = mbAddr - this.picWidthInMbs;
        return !((topMBAddr < this.firstMBInSlice) || (this.map.getGroups()[topMBAddr] != this.groupId));
    };
    prototype.getMbX = function(index) {
        return this.getAddress(index) % this.picWidthInMbs;
    };
    prototype.getMbY = function(index) {
        return stjs.trunc(this.getAddress(index) / this.picWidthInMbs);
    };
    prototype.topRightAvailable = function(mbIndex) {
        var mbAddr = this.map.getInverse()[this.groupId][mbIndex + this.indexOfFirstMb];
        var topRMBAddr = mbAddr - this.picWidthInMbs + 1;
        return !((topRMBAddr < this.firstMBInSlice) || (((mbAddr + 1) % this.picWidthInMbs) == 0) || (this.map.getGroups()[topRMBAddr] != this.groupId));
    };
    prototype.topLeftAvailable = function(mbIndex) {
        var mbAddr = this.map.getInverse()[this.groupId][mbIndex + this.indexOfFirstMb];
        var topLMBAddr = mbAddr - this.picWidthInMbs - 1;
        return !((topLMBAddr < this.firstMBInSlice) || ((mbAddr % this.picWidthInMbs) == 0) || (this.map.getGroups()[topLMBAddr] != this.groupId));
    };
}, {map: "MBToSliceGroupMap"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Network abstraction layer (NAL) unit
 *  
 *  @author The JCodec project
 *  
 */
var NALUnit = function(type, nal_ref_idc) {
    this.type = type;
    this.nal_ref_idc = nal_ref_idc;
};
NALUnit = stjs.extend(NALUnit, null, [], function(constructor, prototype) {
    prototype.type = null;
    prototype.nal_ref_idc = 0;
    constructor.read = function(_in) {
        var nalu = _in.get() & 255;
        var nal_ref_idc = (nalu >> 5) & 3;
        var nb = nalu & 31;
        var type = NALUnitType.fromValue(nb);
        return new NALUnit(type, nal_ref_idc);
    };
    prototype.write = function(out) {
        var nalu = this.type.getValue() | (this.nal_ref_idc << 5);
        out.put((nalu << 24 >> 24));
    };
}, {type: "NALUnitType"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Tuple = function() {};
Tuple = stjs.extend(Tuple, null, [], function(constructor, prototype) {
    constructor._1 = function(v0) {
        this.v0 = v0;
    };
    constructor._1 = stjs.extend(constructor._1, null, [], function(constructor, prototype) {
        prototype.v0 = null;
    }, {}, {});
    constructor._2 = function(v0, v1) {
        this.v0 = v0;
        this.v1 = v1;
    };
    constructor._2 = stjs.extend(constructor._2, null, [], function(constructor, prototype) {
        prototype.v0 = null;
        prototype.v1 = null;
    }, {}, {});
    constructor._3 = function(v0, v1, v2) {
        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;
    };
    constructor._3 = stjs.extend(constructor._3, null, [], function(constructor, prototype) {
        prototype.v0 = null;
        prototype.v1 = null;
        prototype.v2 = null;
    }, {}, {});
    constructor._4 = function(v0, v1, v2, v3) {
        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;
        this.v3 = v3;
    };
    constructor._4 = stjs.extend(constructor._4, null, [], function(constructor, prototype) {
        prototype.v0 = null;
        prototype.v1 = null;
        prototype.v2 = null;
        prototype.v3 = null;
    }, {}, {});
    constructor._1 = function(v0) {
        return new Tuple._1(v0);
    };
    constructor._2 = function(v0, v1) {
        return new Tuple._2(v0, v1);
    };
    constructor._3 = function(v0, v1, v2) {
        return new Tuple._3(v0, v1, v2);
    };
    constructor._4 = function(v0, v1, v2, v3) {
        return new Tuple._4(v0, v1, v2, v3);
    };
    constructor.asMap = function(it) {
        var result = new HashMap();
        for (var iterator$el = it.iterator(); iterator$el.hasNext(); ) {
            var el = iterator$el.next();
            result.put(el.v0, el.v1);
        }
        return result;
    };
    constructor.arrayAsMap = function(arr) {
        var result = new HashMap();
        for (var i = 0; i < arr.length; i++) {
            var el = arr[i];
            result.put(el.v0, el.v1);
        }
        return result;
    };
    constructor.asList = function(m) {
        var result = new LinkedList();
        var entrySet = m.entrySet();
        for (var iterator$entry = entrySet.iterator(); iterator$entry.hasNext(); ) {
            var entry = iterator$entry.next();
            result.add(Tuple._2(entry.getKey(), entry.getValue()));
        }
        return result;
    };
    constructor._1_project0 = function(temp) {
        var result = new LinkedList();
        for (var iterator$_1 = temp.iterator(); iterator$_1.hasNext(); ) {
            var _1 = iterator$_1.next();
            result.add(_1.v0);
        }
        return result;
    };
    constructor._2_project0 = function(temp) {
        var result = new LinkedList();
        for (var iterator$_2 = temp.iterator(); iterator$_2.hasNext(); ) {
            var _2 = iterator$_2.next();
            result.add(_2.v0);
        }
        return result;
    };
    constructor._2_project1 = function(temp) {
        var result = new LinkedList();
        for (var iterator$_2 = temp.iterator(); iterator$_2.hasNext(); ) {
            var _2 = iterator$_2.next();
            result.add(_2.v1);
        }
        return result;
    };
    constructor._3_project0 = function(temp) {
        var result = new LinkedList();
        for (var iterator$_3 = temp.iterator(); iterator$_3.hasNext(); ) {
            var _3 = iterator$_3.next();
            result.add(_3.v0);
        }
        return result;
    };
    constructor._3_project1 = function(temp) {
        var result = new LinkedList();
        for (var iterator$_3 = temp.iterator(); iterator$_3.hasNext(); ) {
            var _3 = iterator$_3.next();
            result.add(_3.v1);
        }
        return result;
    };
    constructor._3_project2 = function(temp) {
        var result = new LinkedList();
        for (var iterator$_3 = temp.iterator(); iterator$_3.hasNext(); ) {
            var _3 = iterator$_3.next();
            result.add(_3.v2);
        }
        return result;
    };
    constructor._4_project0 = function(temp) {
        var result = new LinkedList();
        for (var iterator$_4 = temp.iterator(); iterator$_4.hasNext(); ) {
            var _4 = iterator$_4.next();
            result.add(_4.v0);
        }
        return result;
    };
    constructor._4_project1 = function(temp) {
        var result = new LinkedList();
        for (var iterator$_4 = temp.iterator(); iterator$_4.hasNext(); ) {
            var _4 = iterator$_4.next();
            result.add(_4.v1);
        }
        return result;
    };
    constructor._4_project2 = function(temp) {
        var result = new LinkedList();
        for (var iterator$_4 = temp.iterator(); iterator$_4.hasNext(); ) {
            var _4 = iterator$_4.next();
            result.add(_4.v2);
        }
        return result;
    };
    constructor._4_project3 = function(temp) {
        var result = new LinkedList();
        for (var iterator$_4 = temp.iterator(); iterator$_4.hasNext(); ) {
            var _4 = iterator$_4.next();
            result.add(_4.v3);
        }
        return result;
    };
    constructor.Mapper = function() {};
    constructor.Mapper = stjs.extend(constructor.Mapper, null, [], function(constructor, prototype) {
        prototype.map = function(t) {};
    }, {}, {});
    constructor._1map0 = function(l, mapper) {
        var result = new LinkedList();
        for (var iterator$_1 = l.iterator(); iterator$_1.hasNext(); ) {
            var _1 = iterator$_1.next();
            result.add(Tuple._1(mapper.map(_1.v0)));
        }
        return result;
    };
    constructor._2map0 = function(l, mapper) {
        var result = new LinkedList();
        for (var iterator$_2 = l.iterator(); iterator$_2.hasNext(); ) {
            var _2 = iterator$_2.next();
            result.add(Tuple._2(mapper.map(_2.v0), _2.v1));
        }
        return result;
    };
    constructor._2map1 = function(l, mapper) {
        var result = new LinkedList();
        for (var iterator$_2 = l.iterator(); iterator$_2.hasNext(); ) {
            var _2 = iterator$_2.next();
            result.add(Tuple._2(_2.v0, mapper.map(_2.v1)));
        }
        return result;
    };
    constructor._3map0 = function(l, mapper) {
        var result = new LinkedList();
        for (var iterator$_3 = l.iterator(); iterator$_3.hasNext(); ) {
            var _3 = iterator$_3.next();
            result.add(Tuple._3(mapper.map(_3.v0), _3.v1, _3.v2));
        }
        return result;
    };
    constructor._3map1 = function(l, mapper) {
        var result = new LinkedList();
        for (var iterator$_3 = l.iterator(); iterator$_3.hasNext(); ) {
            var _3 = iterator$_3.next();
            result.add(Tuple._3(_3.v0, mapper.map(_3.v1), _3.v2));
        }
        return result;
    };
    constructor._3map3 = function(l, mapper) {
        var result = new LinkedList();
        for (var iterator$_3 = l.iterator(); iterator$_3.hasNext(); ) {
            var _3 = iterator$_3.next();
            result.add(Tuple._3(_3.v0, _3.v1, mapper.map(_3.v2)));
        }
        return result;
    };
    constructor._4map0 = function(l, mapper) {
        var result = new LinkedList();
        for (var iterator$_4 = l.iterator(); iterator$_4.hasNext(); ) {
            var _4 = iterator$_4.next();
            result.add(Tuple._4(mapper.map(_4.v0), _4.v1, _4.v2, _4.v3));
        }
        return result;
    };
    constructor._4map1 = function(l, mapper) {
        var result = new LinkedList();
        for (var iterator$_4 = l.iterator(); iterator$_4.hasNext(); ) {
            var _4 = iterator$_4.next();
            result.add(Tuple._4(_4.v0, mapper.map(_4.v1), _4.v2, _4.v3));
        }
        return result;
    };
    constructor._4map3 = function(l, mapper) {
        var result = new LinkedList();
        for (var iterator$_4 = l.iterator(); iterator$_4.hasNext(); ) {
            var _4 = iterator$_4.next();
            result.add(Tuple._4(_4.v0, _4.v1, mapper.map(_4.v2), _4.v3));
        }
        return result;
    };
    constructor._4map4 = function(l, mapper) {
        var result = new LinkedList();
        for (var iterator$_4 = l.iterator(); iterator$_4.hasNext(); ) {
            var _4 = iterator$_4.next();
            result.add(Tuple._4(_4.v0, _4.v1, _4.v2, mapper.map(_4.v3)));
        }
        return result;
    };
}, {}, {});
var Boxes = function() {
    this.mappings = new HashMap();
};
Boxes = stjs.extend(Boxes, null, [], function(constructor, prototype) {
    prototype.mappings = null;
    prototype.toClass = function(fourcc) {
        return this.mappings.get(fourcc);
    };
    prototype.override = function(fourcc, cls) {
        this.mappings.put(fourcc, cls);
    };
    prototype.clear = function() {
        this.mappings.clear();
    };
}, {mappings: {name: "Map", arguments: [null, {name: "Class", arguments: ["Object"]}]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Transforms Picture in RGB colorspace ( one plane, 3 integers per pixel ) to
 *  Yuv420 colorspace output picture ( 3 planes, luma - 0th plane, cb - 1th
 *  plane, cr - 2nd plane; cb and cr planes are half width and half haight )
 *  
 *  TODO: implement jpeg colorspace instead of NTSC
 *  
 *  @author The JCodec project
 *  
 */
var RgbToYuv420j = function() {};
RgbToYuv420j = stjs.extend(RgbToYuv420j, null, [Transform], function(constructor, prototype) {
    prototype.transform = function(img, dst) {
        var y = img.getData()[0];
        var dstData = dst.getData();
        var offChr = 0, offLuma = 0, offSrc = 0, strideSrc = img.getWidth() * 3, strideDst = dst.getWidth();
        for (var i = 0; i < img.getHeight() >> 1; i++) {
            for (var j = 0; j < img.getWidth() >> 1; j++) {
                dstData[1][offChr] = 0;
                dstData[2][offChr] = 0;
                RgbToYuv420j.rgb2yuv(y[offSrc], y[offSrc + 1], y[offSrc + 2], dstData[0], offLuma, dstData[1], offChr, dstData[2], offChr);
                dstData[0][offLuma] = dstData[0][offLuma];
                RgbToYuv420j.rgb2yuv(y[offSrc + strideSrc], y[offSrc + strideSrc + 1], y[offSrc + strideSrc + 2], dstData[0], offLuma + strideDst, dstData[1], offChr, dstData[2], offChr);
                dstData[0][offLuma + strideDst] = dstData[0][offLuma + strideDst];
                ++offLuma;
                RgbToYuv420j.rgb2yuv(y[offSrc + 3], y[offSrc + 4], y[offSrc + 5], dstData[0], offLuma, dstData[1], offChr, dstData[2], offChr);
                dstData[0][offLuma] = dstData[0][offLuma];
                RgbToYuv420j.rgb2yuv(y[offSrc + strideSrc + 3], y[offSrc + strideSrc + 4], y[offSrc + strideSrc + 5], dstData[0], offLuma + strideDst, dstData[1], offChr, dstData[2], offChr);
                dstData[0][offLuma + strideDst] = dstData[0][offLuma + strideDst];
                ++offLuma;
                dstData[1][offChr] = dstData[1][offChr] >> 2;
                dstData[2][offChr] = dstData[2][offChr] >> 2;
                ++offChr;
                offSrc += 6;
            }
            offLuma += strideDst;
            offSrc += strideSrc;
        }
    };
    constructor.rgb2yuv = function(r, g, b, Y, offY, U, offU, V, offV) {
        var y = 77 * r + 150 * g + 15 * b;
        var u = -43 * r - 85 * g + 128 * b;
        var v = 128 * r - 107 * g - 21 * b;
        y = (y + 128) >> 8;
        u = (u + 128) >> 8;
        v = (v + 128) >> 8;
        Y[offY] = RgbToYuv420j.clip(y);
        U[offU] += RgbToYuv420j.clip(u + 128);
        V[offV] += RgbToYuv420j.clip(v + 128);
    };
    constructor.clip = function(val) {
        return val < 0 ? 0 : (val > 255 ? 255 : val);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Yuv422pToYuv420j = function(upshift, downshift) {
    this.shift = downshift + 13 - upshift;
    if (this.shift < 0) {
         throw new IllegalArgumentException("Maximum upshift allowed: " + (downshift + 13));
    }
    this.halfSrc = 128 << Math.max(downshift - upshift, 0);
    this.halfDst = 128 << Math.max(upshift - downshift, 0);
};
Yuv422pToYuv420j = stjs.extend(Yuv422pToYuv420j, null, [Transform], function(constructor, prototype) {
    constructor.COEFF = 9362;
    prototype.shift = 0;
    prototype.halfSrc = 0;
    prototype.halfDst = 0;
    prototype.transform = function(src, dst) {
        var sy = src.getPlaneData(0);
        var dy = dst.getPlaneData(0);
        for (var i = 0; i < src.getPlaneWidth(0) * src.getPlaneHeight(0); i++) 
            dy[i] = (sy[i] - 16) * Yuv422pToYuv420j.COEFF >> this.shift;
        this.copyAvg(src.getPlaneData(1), dst.getPlaneData(1), src.getPlaneWidth(1), src.getPlaneHeight(1));
        this.copyAvg(src.getPlaneData(2), dst.getPlaneData(2), src.getPlaneWidth(2), src.getPlaneHeight(2));
    };
    prototype.copyAvg = function(src, dst, width, height) {
        var offSrc = 0, offDst = 0;
        for (var y = 0; y < stjs.trunc(height / 2); y++) {
            for (var x = 0; x < width; x++ , offDst++ , offSrc++) {
                var a = ((src[offSrc] - this.halfSrc) * Yuv422pToYuv420j.COEFF >> this.shift) + this.halfDst;
                var b = ((src[offSrc + width] - this.halfSrc) * Yuv422pToYuv420j.COEFF >> this.shift) + this.halfDst;
                dst[offDst] = (a + b + 1) >> 1;
            }
            offSrc += width;
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Yuv444jToYuv420p = function() {};
Yuv444jToYuv420p = stjs.extend(Yuv444jToYuv420p, null, [Transform], function(constructor, prototype) {
    constructor.Y_COEFF = 7168;
    prototype.transform = function(src, dst) {
        var sy = src.getPlaneData(0);
        var dy = dst.getPlaneData(0);
        for (var i = 0; i < src.getPlaneWidth(0) * src.getPlaneHeight(0); i++) 
            dy[i] = (sy[i] * Yuv444jToYuv420p.Y_COEFF >> 13) + 16;
        this.copyAvg(src.getPlaneData(1), dst.getPlaneData(1), src.getPlaneWidth(1), src.getPlaneHeight(1));
        this.copyAvg(src.getPlaneData(2), dst.getPlaneData(2), src.getPlaneWidth(2), src.getPlaneHeight(2));
    };
    prototype.copyAvg = function(src, dst, width, height) {
        var offSrc = 0, offDst = 0;
        for (var y = 0; y < (height >> 1); y++) {
            for (var x = 0; x < width; x += 2 , offDst++ , offSrc += 2) {
                var a = ((src[offSrc] - 128) * Yuv444jToYuv420p.Y_COEFF >> 13) + 128;
                var b = ((src[offSrc + 1] - 128) * Yuv444jToYuv420p.Y_COEFF >> 13) + 128;
                var c = ((src[offSrc + width] - 128) * Yuv444jToYuv420p.Y_COEFF >> 13) + 128;
                var d = ((src[offSrc + width + 1] - 128) * Yuv444jToYuv420p.Y_COEFF >> 13) + 128;
                dst[offDst] = (a + b + c + d + 2) >> 2;
            }
            offSrc += width;
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Yuv420jToRgb = function() {};
Yuv420jToRgb = stjs.extend(Yuv420jToRgb, null, [Transform], function(constructor, prototype) {
    prototype.transform = function(src, dst) {
        var y = src.getPlaneData(0);
        var u = src.getPlaneData(1);
        var v = src.getPlaneData(2);
        var data = dst.getPlaneData(0);
        var offLuma = 0, offChroma = 0;
        var stride = dst.getWidth();
        for (var i = 0; i < (dst.getHeight() >> 1); i++) {
            for (var k = 0; k < (dst.getWidth() >> 1); k++) {
                var j = k << 1;
                Yuv420jToRgb.YUVJtoRGB(y[offLuma + j], u[offChroma], v[offChroma], data, (offLuma + j) * 3);
                Yuv420jToRgb.YUVJtoRGB(y[offLuma + j + 1], u[offChroma], v[offChroma], data, (offLuma + j + 1) * 3);
                Yuv420jToRgb.YUVJtoRGB(y[offLuma + j + stride], u[offChroma], v[offChroma], data, (offLuma + j + stride) * 3);
                Yuv420jToRgb.YUVJtoRGB(y[offLuma + j + stride + 1], u[offChroma], v[offChroma], data, (offLuma + j + stride + 1) * 3);
                ++offChroma;
            }
            if ((dst.getWidth() & 1) != 0) {
                var j = dst.getWidth() - 1;
                Yuv420jToRgb.YUVJtoRGB(y[offLuma + j], u[offChroma], v[offChroma], data, (offLuma + j) * 3);
                Yuv420jToRgb.YUVJtoRGB(y[offLuma + j + stride], u[offChroma], v[offChroma], data, (offLuma + j + stride) * 3);
                ++offChroma;
            }
            offLuma += 2 * stride;
        }
        if ((dst.getHeight() & 1) != 0) {
            for (var k = 0; k < (dst.getWidth() >> 1); k++) {
                var j = k << 1;
                Yuv420jToRgb.YUVJtoRGB(y[offLuma + j], u[offChroma], v[offChroma], data, (offLuma + j) * 3);
                Yuv420jToRgb.YUVJtoRGB(y[offLuma + j + 1], u[offChroma], v[offChroma], data, (offLuma + j + 1) * 3);
                ++offChroma;
            }
            if ((dst.getWidth() & 1) != 0) {
                var j = dst.getWidth() - 1;
                Yuv420jToRgb.YUVJtoRGB(y[offLuma + j], u[offChroma], v[offChroma], data, (offLuma + j) * 3);
                ++offChroma;
            }
        }
    };
    constructor.SCALEBITS = 10;
    constructor.ONE_HALF = (1 << (Yuv420jToRgb.SCALEBITS - 1));
    constructor.FIX = function(x) {
        return (stjs.trunc(((x) * (1 << Yuv420jToRgb.SCALEBITS) + 0.5)));
    };
    constructor.FIX_0_71414 = Yuv420jToRgb.FIX(0.71414);
    constructor.FIX_1_772 = Yuv420jToRgb.FIX(1.772);
    constructor._FIX_0_34414 = -Yuv420jToRgb.FIX(0.34414);
    constructor.FIX_1_402 = Yuv420jToRgb.FIX(1.402);
    constructor.YUVJtoRGB = function(y, cb, cr, data, off) {
        y = y << Yuv420jToRgb.SCALEBITS;
        cb = cb - 128;
        cr = cr - 128;
        var add_r = Yuv420jToRgb.FIX_1_402 * cr + Yuv420jToRgb.ONE_HALF;
        var add_g = Yuv420jToRgb._FIX_0_34414 * cb - Yuv420jToRgb.FIX_0_71414 * cr + Yuv420jToRgb.ONE_HALF;
        var add_b = Yuv420jToRgb.FIX_1_772 * cb + Yuv420jToRgb.ONE_HALF;
        var r = (y + add_r) >> Yuv420jToRgb.SCALEBITS;
        var g = (y + add_g) >> Yuv420jToRgb.SCALEBITS;
        var b = (y + add_b) >> Yuv420jToRgb.SCALEBITS;
        data[off] = MathUtil.clip(r, 0, 255);
        data[off + 1] = MathUtil.clip(g, 0, 255);
        data[off + 2] = MathUtil.clip(b, 0, 255);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Yuv422jToYuv420p = function() {};
Yuv422jToYuv420p = stjs.extend(Yuv422jToYuv420p, null, [Transform], function(constructor, prototype) {
    constructor.Y_COEFF = 7168;
    prototype.transform = function(src, dst) {
        var sy = src.getPlaneData(0);
        var dy = dst.getPlaneData(0);
        for (var i = 0; i < src.getPlaneWidth(0) * src.getPlaneHeight(0); i++) 
            dy[i] = (sy[i] * Yuv422jToYuv420p.Y_COEFF >> 13) + 16;
        this.copyAvg(src.getPlaneData(1), dst.getPlaneData(1), src.getPlaneWidth(1), src.getPlaneHeight(1));
        this.copyAvg(src.getPlaneData(2), dst.getPlaneData(2), src.getPlaneWidth(2), src.getPlaneHeight(2));
    };
    prototype.copyAvg = function(src, dst, width, height) {
        var offSrc = 0, offDst = 0;
        for (var y = 0; y < stjs.trunc(height / 2); y++) {
            for (var x = 0; x < width; x++ , offDst++ , offSrc++) {
                var a = ((src[offSrc] - 128) * Yuv422jToYuv420p.Y_COEFF >> 13) + 128;
                var b = ((src[offSrc + width] - 128) * Yuv422jToYuv420p.Y_COEFF >> 13) + 128;
                dst[offDst] = (a + b + 1) >> 1;
            }
            offSrc += width;
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Transforms Picture in RGB colorspace ( one plane, 3 integers per pixel ) to
 *  Yuv420 colorspace output picture ( 3 planes, luma - 0th plane, cb - 1th
 *  plane, cr - 2nd plane; cb and cr planes are half width and half haight )
 *  
 *  @author The JCodec project
 *  
 */
var RgbToYuv420p = function(upShift, downShift) {
    this.upShift = upShift;
    this.downShift = downShift;
    this.downShiftChr = downShift + 2;
};
RgbToYuv420p = stjs.extend(RgbToYuv420p, null, [Transform], function(constructor, prototype) {
    prototype.upShift = 0;
    prototype.downShift = 0;
    prototype.downShiftChr = 0;
    prototype.transform = function(img, dst) {
        var y = img.getData()[0];
        var dstData = dst.getData();
        var offChr = 0, offLuma = 0, offSrc = 0, strideSrc = img.getWidth() * 3, strideDst = dst.getWidth();
        for (var i = 0; i < img.getHeight() >> 1; i++) {
            for (var j = 0; j < img.getWidth() >> 1; j++) {
                dstData[1][offChr] = 0;
                dstData[2][offChr] = 0;
                RgbToYuv420p.rgb2yuv(y[offSrc], y[offSrc + 1], y[offSrc + 2], dstData[0], offLuma, dstData[1], offChr, dstData[2], offChr);
                dstData[0][offLuma] = (dstData[0][offLuma] << this.upShift) >> this.downShift;
                RgbToYuv420p.rgb2yuv(y[offSrc + strideSrc], y[offSrc + strideSrc + 1], y[offSrc + strideSrc + 2], dstData[0], offLuma + strideDst, dstData[1], offChr, dstData[2], offChr);
                dstData[0][offLuma + strideDst] = (dstData[0][offLuma + strideDst] << this.upShift) >> this.downShift;
                ++offLuma;
                RgbToYuv420p.rgb2yuv(y[offSrc + 3], y[offSrc + 4], y[offSrc + 5], dstData[0], offLuma, dstData[1], offChr, dstData[2], offChr);
                dstData[0][offLuma] = (dstData[0][offLuma] << this.upShift) >> this.downShift;
                RgbToYuv420p.rgb2yuv(y[offSrc + strideSrc + 3], y[offSrc + strideSrc + 4], y[offSrc + strideSrc + 5], dstData[0], offLuma + strideDst, dstData[1], offChr, dstData[2], offChr);
                dstData[0][offLuma + strideDst] = (dstData[0][offLuma + strideDst] << this.upShift) >> this.downShift;
                ++offLuma;
                dstData[1][offChr] = (dstData[1][offChr] << this.upShift) >> this.downShiftChr;
                dstData[2][offChr] = (dstData[2][offChr] << this.upShift) >> this.downShiftChr;
                ++offChr;
                offSrc += 6;
            }
            offLuma += strideDst;
            offSrc += strideSrc;
        }
    };
    constructor.rgb2yuv = function(r, g, b, Y, offY, U, offU, V, offV) {
        var y = 66 * r + 129 * g + 25 * b;
        var u = -38 * r - 74 * g + 112 * b;
        var v = 112 * r - 94 * g - 18 * b;
        y = (y + 128) >> 8;
        u = (u + 128) >> 8;
        v = (v + 128) >> 8;
        Y[offY] = RgbToYuv420p.clip(y + 16);
        U[offU] += RgbToYuv420p.clip(u + 128);
        V[offV] += RgbToYuv420p.clip(v + 128);
    };
    constructor.clip = function(val) {
        return val < 0 ? 0 : (val > 255 ? 255 : val);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Yuv420pToYuv422p = function(shiftUp, shiftDown) {
    this.shiftUp = shiftUp;
    this.shiftDown = shiftDown;
};
Yuv420pToYuv422p = stjs.extend(Yuv420pToYuv422p, null, [Transform], function(constructor, prototype) {
    prototype.shiftUp = 0;
    prototype.shiftDown = 0;
    prototype.transform = function(src, dst) {
        Yuv420pToYuv422p.copy(src.getPlaneData(0), dst.getPlaneData(0), src.getWidth(), dst.getWidth(), dst.getHeight(), this.shiftUp, this.shiftDown);
        Yuv420pToYuv422p._copy(src.getPlaneData(1), dst.getPlaneData(1), 0, 0, 1, 2, src.getWidth() >> 1, dst.getWidth() >> 1, src.getHeight() >> 1, dst.getHeight(), this.shiftUp, this.shiftDown);
        Yuv420pToYuv422p._copy(src.getPlaneData(1), dst.getPlaneData(1), 0, 1, 1, 2, src.getWidth() >> 1, dst.getWidth() >> 1, src.getHeight() >> 1, dst.getHeight(), this.shiftUp, this.shiftDown);
        Yuv420pToYuv422p._copy(src.getPlaneData(2), dst.getPlaneData(2), 0, 0, 1, 2, src.getWidth() >> 1, dst.getWidth() >> 1, src.getHeight() >> 1, dst.getHeight(), this.shiftUp, this.shiftDown);
        Yuv420pToYuv422p._copy(src.getPlaneData(2), dst.getPlaneData(2), 0, 1, 1, 2, src.getWidth() >> 1, dst.getWidth() >> 1, src.getHeight() >> 1, dst.getHeight(), this.shiftUp, this.shiftDown);
    };
    constructor._copy = function(src, dest, offX, offY, stepX, stepY, strideSrc, strideDest, heightSrc, heightDst, upShift, downShift) {
        var offD = offX + offY * strideDest, srcOff = 0;
        for (var i = 0; i < heightSrc; i++) {
            for (var j = 0; j < strideSrc; j++) {
                dest[offD] = (src[srcOff++] & 255) << 2;
                offD += stepX;
            }
            var lastOff = offD - stepX;
            for (var j = strideSrc * stepX; j < strideDest; j += stepX) {
                dest[offD] = dest[lastOff];
                offD += stepX;
            }
            offD += (stepY - 1) * strideDest;
        }
        var lastLine = offD - stepY * strideDest;
        for (var i = heightSrc * stepY; i < heightDst; i += stepY) {
            for (var j = 0; j < strideDest; j += stepX) {
                dest[offD] = dest[lastLine + j];
                offD += stepX;
            }
            offD += (stepY - 1) * strideDest;
        }
    };
    constructor.copy = function(src, dest, srcWidth, dstWidth, dstHeight, shiftUp, shiftDown) {
        var height = stjs.trunc(src.length / srcWidth);
        var dstOff = 0, srcOff = 0;
        for (var i = 0; i < height; i++) {
            for (var j = 0; j < srcWidth; j++) {
                dest[dstOff++] = (src[srcOff++] & 255) << 2;
            }
            for (var j = srcWidth; j < dstWidth; j++) 
                dest[dstOff++] = dest[srcWidth - 1];
        }
        var lastLine = (height - 1) * dstWidth;
        for (var i = height; i < dstHeight; i++) {
            for (var j = 0; j < dstWidth; j++) {
                dest[dstOff++] = dest[lastLine + j];
            }
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Yuv422pToYuv420p = function(shiftUp, shiftDown) {
    this.shiftUp = shiftUp;
    this.shiftDown = shiftDown;
};
Yuv422pToYuv420p = stjs.extend(Yuv422pToYuv420p, null, [Transform], function(constructor, prototype) {
    prototype.shiftUp = 0;
    prototype.shiftDown = 0;
    prototype.transform = function(src, dst) {
        var lumaSize = src.getWidth() * src.getHeight();
        System.arraycopy(src.getPlaneData(0), 0, dst.getPlaneData(0), 0, lumaSize);
        this.copyAvg(src.getPlaneData(1), dst.getPlaneData(1), src.getPlaneWidth(1), src.getPlaneHeight(1));
        this.copyAvg(src.getPlaneData(2), dst.getPlaneData(2), src.getPlaneWidth(2), src.getPlaneHeight(2));
        if (this.shiftUp > this.shiftDown) {
            this.up(dst.getPlaneData(0), this.shiftUp - this.shiftDown);
            this.up(dst.getPlaneData(1), this.shiftUp - this.shiftDown);
            this.up(dst.getPlaneData(2), this.shiftUp - this.shiftDown);
        } else if (this.shiftDown > this.shiftUp) {
            this.down(dst.getPlaneData(0), this.shiftDown - this.shiftUp);
            this.down(dst.getPlaneData(1), this.shiftDown - this.shiftUp);
            this.down(dst.getPlaneData(2), this.shiftDown - this.shiftUp);
        }
    };
    prototype.down = function(dst, down) {
        for (var i = 0; i < dst.length; i++) {
            dst[i] >>= down;
        }
    };
    prototype.up = function(dst, up) {
        for (var i = 0; i < dst.length; i++) {
            dst[i] <<= up;
        }
    };
    prototype.copyAvg = function(src, dst, width, height) {
        var offSrc = 0, offDst = 0;
        for (var y = 0; y < stjs.trunc(height / 2); y++) {
            for (var x = 0; x < width; x++ , offDst++ , offSrc++) {
                dst[offDst] = (src[offSrc] + src[offSrc + width] + 1) >> 1;
            }
            offSrc += width;
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Yuv422pToRgb = function(downShift, upShift) {
    this.downShift = downShift;
    this.upShift = upShift;
};
Yuv422pToRgb = stjs.extend(Yuv422pToRgb, null, [Transform], function(constructor, prototype) {
    prototype.downShift = 0;
    prototype.upShift = 0;
    prototype.transform = function(src, dst) {
        var y = src.getPlaneData(0);
        var u = src.getPlaneData(1);
        var v = src.getPlaneData(2);
        var data = dst.getPlaneData(0);
        var offLuma = 0, offChroma = 0;
        for (var i = 0; i < dst.getHeight(); i++) {
            for (var j = 0; j < dst.getWidth(); j += 2) {
                Yuv422pToRgb.YUV444toRGB888((y[offLuma] << this.upShift) >> this.downShift, (u[offChroma] << this.upShift) >> this.downShift, (v[offChroma] << this.upShift) >> this.downShift, data, offLuma * 3);
                Yuv422pToRgb.YUV444toRGB888((y[offLuma + 1] << this.upShift) >> this.downShift, (u[offChroma] << this.upShift) >> this.downShift, (v[offChroma] << this.upShift) >> this.downShift, data, (offLuma + 1) * 3);
                offLuma += 2;
                ++offChroma;
            }
        }
    };
    constructor.YUV444toRGB888 = function(y, u, v, data, off) {
        var c = y - 16;
        var d = u - 128;
        var e = v - 128;
        var r = (298 * c + 409 * e + 128) >> 8;
        var g = (298 * c - 100 * d - 208 * e + 128) >> 8;
        var b = (298 * c + 516 * d + 128) >> 8;
        data[off] = Yuv422pToRgb.crop(r);
        data[off + 1] = Yuv422pToRgb.crop(g);
        data[off + 2] = Yuv422pToRgb.crop(b);
    };
    constructor.crop = function(val) {
        return val < 0 ? 0 : (val > 255 ? 255 : val);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Yuv444pToRgb = function(downShift, upShift) {
    this.downShift = downShift;
    this.upShift = upShift;
};
Yuv444pToRgb = stjs.extend(Yuv444pToRgb, null, [Transform], function(constructor, prototype) {
    prototype.downShift = 0;
    prototype.upShift = 0;
    prototype.transform = function(src, dst) {
        var y = src.getPlaneData(0);
        var u = src.getPlaneData(1);
        var v = src.getPlaneData(2);
        var data = dst.getPlaneData(0);
        for (var i = 0, srcOff = 0, dstOff = 0; i < dst.getHeight(); i++) {
            for (var j = 0; j < dst.getWidth(); j++ , srcOff++ , dstOff += 3) {
                Yuv444pToRgb.YUV444toRGB888((y[srcOff] << this.upShift) >> this.downShift, (u[srcOff] << this.upShift) >> this.downShift, (v[srcOff] << this.upShift) >> this.downShift, data, dstOff);
            }
        }
    };
    constructor.YUV444toRGB888 = function(y, u, v, data, off) {
        var c = y - 16;
        var d = u - 128;
        var e = v - 128;
        var r = (298 * c + 409 * e + 128) >> 8;
        var g = (298 * c - 100 * d - 208 * e + 128) >> 8;
        var b = (298 * c + 516 * d + 128) >> 8;
        data[off] = Yuv444pToRgb.crop(r);
        data[off + 1] = Yuv444pToRgb.crop(g);
        data[off + 2] = Yuv444pToRgb.crop(b);
    };
    constructor.crop = function(val) {
        return val < 0 ? 0 : (val > 255 ? 255 : val);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Performs color scaling from JPEG to NTSC
 *  
 *  @author The JCodec project
 *  
 */
var Yuv420jToYuv420 = function() {};
Yuv420jToYuv420 = stjs.extend(Yuv420jToYuv420, null, [Transform], function(constructor, prototype) {
    constructor.Y_COEFF = 7168;
    prototype.transform = function(src, dst) {
        var sy = src.getPlaneData(0);
        var dy = dst.getPlaneData(0);
        for (var i = 0; i < src.getPlaneWidth(0) * src.getPlaneHeight(0); i++) 
            dy[i] = (sy[i] * Yuv420jToYuv420.Y_COEFF >> 13) + 16;
        var su = src.getPlaneData(1);
        var du = dst.getPlaneData(1);
        for (var i = 0; i < src.getPlaneWidth(1) * src.getPlaneHeight(1); i++) 
            du[i] = ((su[i] - 128) * Yuv420jToYuv420.Y_COEFF >> 13) + 128;
        var sv = src.getPlaneData(2);
        var dv = dst.getPlaneData(2);
        for (var i = 0; i < src.getPlaneWidth(2) * src.getPlaneHeight(2); i++) 
            dv[i] = ((sv[i] - 128) * Yuv420jToYuv420.Y_COEFF >> 13) + 128;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Yuv444pToYuv420p = function(shiftUp, shiftDown) {
    this.shiftUp = shiftUp;
    this.shiftDown = shiftDown;
};
Yuv444pToYuv420p = stjs.extend(Yuv444pToYuv420p, null, [Transform], function(constructor, prototype) {
    prototype.shiftUp = 0;
    prototype.shiftDown = 0;
    prototype.transform = function(src, dst) {
        var lumaSize = src.getWidth() * src.getHeight();
        System.arraycopy(src.getPlaneData(0), 0, dst.getPlaneData(0), 0, lumaSize);
        this.copyAvg(src.getPlaneData(1), dst.getPlaneData(1), src.getPlaneWidth(1), src.getPlaneHeight(1));
        this.copyAvg(src.getPlaneData(2), dst.getPlaneData(2), src.getPlaneWidth(2), src.getPlaneHeight(2));
        if (this.shiftUp > this.shiftDown) {
            this.up(dst.getPlaneData(0), this.shiftUp - this.shiftDown);
            this.up(dst.getPlaneData(1), this.shiftUp - this.shiftDown);
            this.up(dst.getPlaneData(2), this.shiftUp - this.shiftDown);
        } else if (this.shiftDown > this.shiftUp) {
            this.down(dst.getPlaneData(0), this.shiftDown - this.shiftUp);
            this.down(dst.getPlaneData(1), this.shiftDown - this.shiftUp);
            this.down(dst.getPlaneData(2), this.shiftDown - this.shiftUp);
        }
    };
    prototype.down = function(dst, down) {
        for (var i = 0; i < dst.length; i++) {
            dst[i] >>= down;
        }
    };
    prototype.up = function(dst, up) {
        for (var i = 0; i < dst.length; i++) {
            dst[i] <<= up;
        }
    };
    prototype.copyAvg = function(src, dst, width, height) {
        var offSrc = 0, offDst = 0;
        for (var y = 0; y < (height >> 1); y++) {
            for (var x = 0; x < width; x += 2 , offDst++ , offSrc += 2) {
                dst[offDst] = (src[offSrc] + src[offSrc + 1] + src[offSrc + width] + src[offSrc + width + 1] + 2) >> 2;
            }
            offSrc += width;
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  @author The JCodec project
 */
var DCT = function() {};
DCT = stjs.extend(DCT, null, [], function(constructor, prototype) {
    prototype.encode = function(orig) {
         throw new NotSupportedException();
    };
    prototype.decode = function(orig) {};
    prototype.decodeAll = function(src) {
        for (var i = 0; i < src.length; i++) {
            src[i] = this.decode(src[i]);
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var AudioUtil = function() {};
AudioUtil = stjs.extend(AudioUtil, null, [], function(constructor, prototype) {
    constructor.f24 = 8388607.0;
    constructor.f16 = 32767.0;
    constructor.r16 = 1.0 / 32768.0;
    constructor.r24 = 1.0 / 8388608.0;
    /**
     *  Converts PCM samples stored in buf and described with format to float
     *  array representation
     *  
     *  @param format
     *             Supported formats - *_*_S16_LE, *_*_S24_LE, *_*_S16_BE,
     *             *_*_S24_LE
     *  @param buf
     *  @param floatBuf
     *  @return Total number of samples read from the buffer
     */
    constructor.toFloat = function(format, buf, floatBuf) {
        if (!format.isSigned()) 
             throw new NotSupportedException("Unsigned PCM is not supported ( yet? ).");
        if (format.getSampleSizeInBits() != 16 && format.getSampleSizeInBits() != 24) 
             throw new NotSupportedException(format.getSampleSizeInBits() + " bit PCM is not supported ( yet? ).");
        if (format.isBigEndian()) {
            if (format.getSampleSizeInBits() == 16) {
                AudioUtil.toFloat16BE(buf, floatBuf);
            } else {
                AudioUtil.toFloat24BE(buf, floatBuf);
            }
        } else {
            if (format.getSampleSizeInBits() == 16) {
                AudioUtil.toFloat16LE(buf, floatBuf);
            } else {
                AudioUtil.toFloat24LE(buf, floatBuf);
            }
        }
    };
    /**
     *  Converts float PCM samples stored in floatBuf to integer representation
     *  according to format and stores them in buf
     *  
     *  @param format
     *             Supported formats - *_*_S16_LE, *_*_S24_LE, *_*_S16_BE,
     *             *_*_S24_LE
     *  @param buf
     *  @param floatBuf
     *  @return Total number of samples written to the buffer
     */
    constructor.fromFloat = function(floatBuf, format, buf) {
        if (!format.isSigned()) 
             throw new NotSupportedException("Unsigned PCM is not supported ( yet? ).");
        if (format.getSampleSizeInBits() != 16 && format.getSampleSizeInBits() != 24) 
             throw new NotSupportedException(format.getSampleSizeInBits() + " bit PCM is not supported ( yet? ).");
        if (format.isBigEndian()) {
            if (format.getSampleSizeInBits() == 16) {
                AudioUtil.fromFloat16BE(buf, floatBuf);
            } else {
                AudioUtil.fromFloat24BE(buf, floatBuf);
            }
        } else {
            if (format.getSampleSizeInBits() == 16) {
                AudioUtil.fromFloat16LE(buf, floatBuf);
            } else {
                AudioUtil.fromFloat24LE(buf, floatBuf);
            }
        }
    };
    constructor.toFloat24LE = function(buf, out) {
         while (buf.remaining() >= 3 && out.hasRemaining()){
            out.put(AudioUtil.r24 * ((((buf.get() & 255) << 8) | ((buf.get() & 255) << 16) | ((buf.get() & 255) << 24)) >> 8));
        }
    };
    constructor.toFloat16LE = function(buf, out) {
         while (buf.remaining() >= 2 && out.hasRemaining()){
            out.put(AudioUtil.r16 * ((((buf.get() & 255) | ((buf.get() & 255) << 8))) << 16 >> 16));
        }
    };
    constructor.toFloat24BE = function(buf, out) {
         while (buf.remaining() >= 3 && out.hasRemaining()){
            out.put(AudioUtil.r24 * ((((buf.get() & 255) << 24) | ((buf.get() & 255) << 16) | ((buf.get() & 255) << 8)) >> 8));
        }
    };
    constructor.toFloat16BE = function(buf, out) {
         while (buf.remaining() >= 2 && out.hasRemaining()){
            out.put(AudioUtil.r16 * (((((buf.get() & 255) << 8) | (buf.get() & 255))) << 16 >> 16));
        }
    };
    constructor.fromFloat24LE = function(buf, _in) {
         while (buf.remaining() >= 3 && _in.hasRemaining()){
            var val = MathUtil.clip(stjs.trunc((_in.get() * AudioUtil.f24)), -8388608, 8388607) & 16777215;
            buf.put((val << 24 >> 24));
            buf.put(((val >> 8) << 24 >> 24));
            buf.put(((val >> 16) << 24 >> 24));
        }
    };
    constructor.fromFloat16LE = function(buf, _in) {
         while (buf.remaining() >= 2 && _in.hasRemaining()){
            var val = MathUtil.clip(stjs.trunc((_in.get() * AudioUtil.f16)), -32768, 32767) & 65535;
            buf.put((val << 24 >> 24));
            buf.put(((val >> 8) << 24 >> 24));
        }
    };
    constructor.fromFloat24BE = function(buf, _in) {
         while (buf.remaining() >= 3 && _in.hasRemaining()){
            var val = MathUtil.clip(stjs.trunc((_in.get() * AudioUtil.f24)), -8388608, 8388607) & 16777215;
            buf.put(((val >> 16) << 24 >> 24));
            buf.put(((val >> 8) << 24 >> 24));
            buf.put((val << 24 >> 24));
        }
    };
    constructor.fromFloat16BE = function(buf, _in) {
         while (buf.remaining() >= 2 && _in.hasRemaining()){
            var val = MathUtil.clip(stjs.trunc((_in.get() * AudioUtil.f16)), -32768, 32767) & 65535;
            buf.put(((val >> 8) << 24 >> 24));
            buf.put((val << 24 >> 24));
        }
    };
    constructor.fromInt = function(data, len, format, buf) {
        if (!format.isSigned()) 
             throw new NotSupportedException("Unsigned PCM is not supported ( yet? ).");
        if (format.getSampleSizeInBits() != 16 && format.getSampleSizeInBits() != 24) 
             throw new NotSupportedException(format.getSampleSizeInBits() + " bit PCM is not supported ( yet? ).");
        if (format.isBigEndian()) {
            if (format.getSampleSizeInBits() == 16) {
                return AudioUtil.fromInt16BE(buf, data, len);
            } else {
                return AudioUtil.fromInt24BE(buf, data, len);
            }
        } else {
            if (format.getSampleSizeInBits() == 16) {
                return AudioUtil.fromInt16LE(buf, data, len);
            } else {
                return AudioUtil.fromInt24LE(buf, data, len);
            }
        }
    };
    constructor.fromInt24LE = function(buf, out, len) {
        var samples = 0;
         while (buf.remaining() >= 3 && samples < len){
            var val = out[samples++];
            buf.put((val << 24 >> 24));
            buf.put(((val >> 8) << 24 >> 24));
            buf.put(((val >> 16) << 24 >> 24));
        }
        return samples;
    };
    constructor.fromInt16LE = function(buf, out, len) {
        var samples = 0;
         while (buf.remaining() >= 2 && samples < len){
            var val = out[samples++];
            buf.put((val << 24 >> 24));
            buf.put(((val >> 8) << 24 >> 24));
        }
        return samples;
    };
    constructor.fromInt24BE = function(buf, out, len) {
        var samples = 0;
         while (buf.remaining() >= 3 && samples < len){
            var val = out[samples++];
            buf.put(((val >> 16) << 24 >> 24));
            buf.put(((val >> 8) << 24 >> 24));
            buf.put((val << 24 >> 24));
        }
        return samples;
    };
    constructor.fromInt16BE = function(buf, out, len) {
        var samples = 0;
         while (buf.remaining() >= 2 && samples < len){
            var val = out[samples++];
            buf.put(((val >> 8) << 24 >> 24));
            buf.put((val << 24 >> 24));
        }
        return samples;
    };
    constructor.toInt = function(format, buf, samples) {
        if (!format.isSigned()) 
             throw new NotSupportedException("Unsigned PCM is not supported ( yet? ).");
        if (format.getSampleSizeInBits() != 16 && format.getSampleSizeInBits() != 24) 
             throw new NotSupportedException(format.getSampleSizeInBits() + " bit PCM is not supported ( yet? ).");
        if (format.isBigEndian()) {
            if (format.getSampleSizeInBits() == 16) {
                return AudioUtil.toInt16BE(buf, samples);
            } else {
                return AudioUtil.toInt24BE(buf, samples);
            }
        } else {
            if (format.getSampleSizeInBits() == 16) {
                return AudioUtil.toInt16LE(buf, samples);
            } else {
                return AudioUtil.toInt24LE(buf, samples);
            }
        }
    };
    constructor.toInt24LE = function(buf, out) {
        var samples = 0;
         while (buf.remaining() >= 3 && samples < out.length){
            out[samples++] = (((buf.get() & 255) << 8) | ((buf.get() & 255) << 16) | ((buf.get() & 255) << 24)) >> 8;
        }
        return samples;
    };
    constructor.toInt16LE = function(buf, out) {
        var samples = 0;
         while (buf.remaining() >= 2 && samples < out.length){
            out[samples++] = ((((buf.get() & 255) | ((buf.get() & 255) << 8))) << 16 >> 16);
        }
        return samples;
    };
    constructor.toInt24BE = function(buf, out) {
        var samples = 0;
         while (buf.remaining() >= 3 && samples < out.length){
            out[samples++] = (((buf.get() & 255) << 24) | ((buf.get() & 255) << 16) | ((buf.get() & 255) << 8)) >> 8;
        }
        return samples;
    };
    constructor.toInt16BE = function(buf, out) {
        var samples = 0;
         while (buf.remaining() >= 2 && samples < out.length){
            out[samples++] = (((((buf.get() & 255) << 8) | (buf.get() & 255))) << 16 >> 16);
        }
        return samples;
    };
    /**
     *  Interleaves audio samples in ins into outb using sample size from the
     *  format
     *  
     *  @param format
     *  @param ins
     *  @param outb
     */
    constructor.interleave = function(format, ins, outb) {
        var bytesPerSample = format.getSampleSizeInBits() >> 3;
        var bytesPerFrame = bytesPerSample * ins.length;
        var max = 0;
        for (var i = 0; i < ins.length; i++) 
            if (ins[i].remaining() > max) 
                max = ins[i].remaining();
        for (var frames = 0; frames < max && outb.remaining() >= bytesPerFrame; frames++) {
            for (var j = 0; j < ins.length; j++) {
                if (ins[j].remaining() < bytesPerSample) {
                    for (var i = 0; i < bytesPerSample; i++) 
                        outb.put((0 << 24 >> 24));
                } else {
                    for (var i = 0; i < bytesPerSample; i++) {
                        outb.put(ins[j].get());
                    }
                }
            }
        }
    };
    /**
     *  Deinterleaves audio samples from inb into outs using sample size from
     *  format
     *  
     *  @param format
     *  @param inb
     *  @param outs
     */
    constructor.deinterleave = function(format, inb, outs) {
        var bytesPerSample = format.getSampleSizeInBits() >> 3;
        var bytesPerFrame = bytesPerSample * outs.length;
         while (inb.remaining() >= bytesPerFrame){
            for (var j = 0; j < outs.length; j++) {
                for (var i = 0; i < bytesPerSample; i++) {
                    outs[j].put(inb.get());
                }
            }
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Integer to byte and vice versa conversion routines
 *  
 *  @author The JCodec project
 *  
 */
var DataConvert = function() {};
DataConvert = stjs.extend(DataConvert, null, [], function(constructor, prototype) {
    constructor.from16BE = function(b) {
        var result = new Int32Array(b.length >> 1);
        var off = 0;
        for (var i = 0; i < result.length; i++) {
            result[i] = ((b[off++] & 255) << 8) | (b[off++] & 255);
        }
        return result;
    };
    constructor.from24BE = function(b) {
        var result = new Int32Array(stjs.trunc(b.length / 3));
        var off = 0;
        for (var i = 0; i < result.length; i++) {
            result[i] = ((b[off++] & 255) << 16) | ((b[off++] & 255) << 8) | (b[off++] & 255);
        }
        return result;
    };
    constructor.from16LE = function(b) {
        var result = new Int32Array(b.length >> 1);
        var off = 0;
        for (var i = 0; i < result.length; i++) {
            result[i] = (b[off++] & 255) | ((b[off++] & 255) << 8);
        }
        return result;
    };
    constructor.from24LE = function(b) {
        var result = new Int32Array(stjs.trunc(b.length / 3));
        var off = 0;
        for (var i = 0; i < result.length; i++) {
            result[i] = (b[off++] & 255) | ((b[off++] & 255) << 8) | ((b[off++] & 255) << 16);
        }
        return result;
    };
    constructor.to16BE = function(ia) {
        var result = new Int8Array(ia.length << 1);
        var off = 0;
        for (var i = 0; i < ia.length; i++) {
            result[off++] = (((ia[i] >> 8) & 255) << 24 >> 24);
            result[off++] = ((ia[i] & 255) << 24 >> 24);
        }
        return result;
    };
    constructor.to24BE = function(ia) {
        var result = new Int8Array(ia.length * 3);
        var off = 0;
        for (var i = 0; i < ia.length; i++) {
            result[off++] = (((ia[i] >> 16) & 255) << 24 >> 24);
            result[off++] = (((ia[i] >> 8) & 255) << 24 >> 24);
            result[off++] = ((ia[i] & 255) << 24 >> 24);
        }
        return result;
    };
    constructor.to16LE = function(ia) {
        var result = new Int8Array(ia.length << 1);
        var off = 0;
        for (var i = 0; i < ia.length; i++) {
            result[off++] = ((ia[i] & 255) << 24 >> 24);
            result[off++] = (((ia[i] >> 8) & 255) << 24 >> 24);
        }
        return result;
    };
    constructor.to24LE = function(ia) {
        var result = new Int8Array(ia.length * 3);
        var off = 0;
        for (var i = 0; i < ia.length; i++) {
            result[off++] = ((ia[i] & 255) << 24 >> 24);
            result[off++] = (((ia[i] >> 8) & 255) << 24 >> 24);
            result[off++] = (((ia[i] >> 16) & 255) << 24 >> 24);
        }
        return result;
    };
    /**
     *  Generic byte-array to integer-array conversion
     *  
     *  Converts each depth-bit sequence from the input byte array into integer
     *  
     *  @param b
     *             Input bytes
     *  @param depth
     *             Bit depth of the integers
     *  @param isBe
     *             If integers are big-endian or little-endian
     *  @return
     */
    constructor.fromByte = function(b, depth, isBe) {
        if (depth == 24) 
            if (isBe) 
                return DataConvert.from24BE(b);
             else 
                return DataConvert.from24LE(b);
         else if (depth == 16) 
            if (isBe) 
                return DataConvert.from16BE(b);
             else 
                return DataConvert.from16LE(b);
         throw new NotSupportedException("Conversion from " + depth + "bit " + (isBe ? "big endian" : "little endian") + " is not supported.");
    };
    /**
     *  Generic integer-array to byte-array conversion
     *  
     *  Converts each integer into depth-bit sequence in the output byte array
     *  
     *  @param ia
     *             Integer array
     *  @param depth
     *             Bit depth of the integers
     *  @param isBe
     *             If integers are big-endian or little-endian
     *  @return
     */
    constructor.toByte = function(ia, depth, isBe) {
        if (depth == 24) 
            if (isBe) 
                return DataConvert.to24BE(ia);
             else 
                return DataConvert.to24LE(ia);
         else if (depth == 16) 
            if (isBe) 
                return DataConvert.to16BE(ia);
             else 
                return DataConvert.to16LE(ia);
         throw new NotSupportedException("Conversion to " + depth + "bit " + (isBe ? "big endian" : "little endian") + " is not supported.");
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var RgbToBgr = function() {};
RgbToBgr = stjs.extend(RgbToBgr, null, [Transform], function(constructor, prototype) {
    prototype.transform = function(src, dst) {
        if (src.getColor() != ColorSpace.RGB && src.getColor() != ColorSpace.BGR || dst.getColor() != ColorSpace.RGB && dst.getColor() != ColorSpace.BGR) {
             throw new IllegalArgumentException("Expected RGB or BGR inputs, was: " + src.getColor() + ", " + dst.getColor());
        }
        if (src.getCrop() != null || dst.getCrop() != null) 
             throw new NotSupportedException("Cropped images not supported");
        var dataSrc = src.getPlaneData(0);
        var dataDst = dst.getPlaneData(0);
        for (var i = 0; i < dataSrc.length; i += 3) {
            var tmp = dataSrc[i + 2];
            dataDst[i + 2] = dataSrc[i];
            dataDst[i] = tmp;
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 * 
 *  Dumb rate control policy, always maintains the same QP for the whole video
 *  
 *  @author The JCodec project
 *  
 */
var DumbRateControl = function() {};
DumbRateControl = stjs.extend(DumbRateControl, null, [RateControl], function(constructor, prototype) {
    constructor.QP = 20;
    prototype.getInitQp = function(sliceType) {
        return DumbRateControl.QP + (sliceType == SliceType.P ? 6 : 0);
    };
    prototype.getQpDelta = function() {
        return 0;
    };
    prototype.accept = function(bits) {
        return true;
    };
    prototype.reset = function() {};
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  H.264 rate control policy that would produce frames of exactly equal size
 *  
 *  @author The JCodec project
 *  
 */
var H264FixedRateControl = function(bitsPer256) {
    this.perMb = bitsPer256;
    this.curQp = H264FixedRateControl.INIT_QP;
};
H264FixedRateControl = stjs.extend(H264FixedRateControl, null, [RateControl], function(constructor, prototype) {
    constructor.INIT_QP = 26;
    prototype.balance = 0;
    prototype.perMb = 0;
    prototype.curQp = 0;
    prototype.getInitQp = function(sliceType) {
        return H264FixedRateControl.INIT_QP + (sliceType == SliceType.P ? 4 : 0);
    };
    prototype.getQpDelta = function() {
        var qpDelta = this.balance < 0 ? (this.balance < -(this.perMb >> 1) ? 2 : 1) : (this.balance > this.perMb ? (this.balance > (this.perMb << 2) ? -2 : -1) : 0);
        var prevQp = this.curQp;
        this.curQp = MathUtil.clip(this.curQp + qpDelta, 12, 30);
        return this.curQp - prevQp;
    };
    prototype.accept = function(bits) {
        this.balance += this.perMb - bits;
        return true;
    };
    prototype.reset = function() {
        this.balance = 0;
        this.curQp = H264FixedRateControl.INIT_QP;
    };
    prototype.calcFrameSize = function(nMB) {
        return ((256 + nMB * (this.perMb + 9)) >> 3) + (nMB >> 6);
    };
    prototype.setRate = function(rate) {
        this.perMb = rate;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A codec macroblock
 *  
 *  @author The JCodec project
 *  
 */
var MBlock = function(chromaFormat) {
    this.pb8x8 = new MBlock.PB8x8();
    this.pb16x16 = new MBlock.PB16x16();
    this.pb168x168 = new MBlock.PB168x168();
    this.dc = new Int32Array(16);
    this.ac = [Array.apply(null, Array(16)).map(function() {
        return new Int32Array(64);
    }), Array.apply(null, Array(4)).map(function() {
        return new Int32Array(16);
    }), Array.apply(null, Array(4)).map(function() {
        return new Int32Array(16);
    })];
    this.lumaModes = new Int32Array(16);
    this.nCoeff = new Int32Array(16);
    this.dc1 = new Int32Array((16 >> chromaFormat.compWidth[1]) >> chromaFormat.compHeight[1]);
    this.dc2 = new Int32Array((16 >> chromaFormat.compWidth[2]) >> chromaFormat.compHeight[2]);
    this.ipcm = new MBlock.IPCM(chromaFormat);
};
MBlock = stjs.extend(MBlock, null, [], function(constructor, prototype) {
    prototype.chromaPredictionMode = 0;
    prototype.mbQPDelta = 0;
    prototype.dc = null;
    prototype.ac = null;
    prototype.transform8x8Used = false;
    prototype.lumaModes = null;
    prototype.dc1 = null;
    prototype.dc2 = null;
    prototype._cbp = 0;
    prototype.mbType = 0;
    prototype.curMbType = null;
    prototype.pb16x16 = null;
    prototype.pb168x168 = null;
    prototype.pb8x8 = null;
    prototype.ipcm = null;
    prototype.mbIdx = 0;
    prototype.fieldDecoding = false;
    prototype.prevMbType = null;
    prototype.luma16x16Mode = 0;
    prototype.skipped = false;
    prototype.nCoeff = null;
    prototype.cbpLuma = function() {
        return this._cbp & 15;
    };
    prototype.cbpChroma = function() {
        return this._cbp >> 4;
    };
    prototype.cbp = function(cbpLuma, cbpChroma) {
        this._cbp = (cbpLuma & 15) | (cbpChroma << 4);
    };
    constructor.PB16x16 = function() {
        this.refIdx = new Int32Array(2);
        this.mvdX = new Int32Array(2);
        this.mvdY = new Int32Array(2);
    };
    constructor.PB16x16 = stjs.extend(constructor.PB16x16, null, [], function(constructor, prototype) {
        prototype.refIdx = null;
        prototype.mvdX = null;
        prototype.mvdY = null;
        prototype.clean = function() {
            this.refIdx[0] = this.refIdx[1] = 0;
            this.mvdX[0] = this.mvdX[1] = 0;
            this.mvdY[0] = this.mvdY[1] = 0;
        };
    }, {refIdx: "Int32Array", mvdX: "Int32Array", mvdY: "Int32Array"}, {});
    constructor.PB168x168 = function() {
        this.refIdx1 = new Int32Array(2);
        this.refIdx2 = new Int32Array(2);
        this.mvdX1 = new Int32Array(2);
        this.mvdY1 = new Int32Array(2);
        this.mvdX2 = new Int32Array(2);
        this.mvdY2 = new Int32Array(2);
    };
    constructor.PB168x168 = stjs.extend(constructor.PB168x168, null, [], function(constructor, prototype) {
        prototype.refIdx1 = null;
        prototype.refIdx2 = null;
        prototype.mvdX1 = null;
        prototype.mvdY1 = null;
        prototype.mvdX2 = null;
        prototype.mvdY2 = null;
        prototype.clean = function() {
            this.refIdx1[0] = this.refIdx1[1] = 0;
            this.refIdx2[0] = this.refIdx2[1] = 0;
            this.mvdX1[0] = this.mvdX1[1] = 0;
            this.mvdY1[0] = this.mvdY1[1] = 0;
            this.mvdX2[0] = this.mvdX2[1] = 0;
            this.mvdY2[0] = this.mvdY2[1] = 0;
        };
    }, {refIdx1: "Int32Array", refIdx2: "Int32Array", mvdX1: "Int32Array", mvdY1: "Int32Array", mvdX2: "Int32Array", mvdY2: "Int32Array"}, {});
    constructor.PB8x8 = function() {
        this.refIdx = Array.apply(null, Array(2)).map(function() {
            return new Int32Array(4);
        });
        this.subMbTypes = new Int32Array(4);
        this.mvdX1 = Array.apply(null, Array(2)).map(function() {
            return new Int32Array(4);
        });
        this.mvdY1 = Array.apply(null, Array(2)).map(function() {
            return new Int32Array(4);
        });
        this.mvdX2 = Array.apply(null, Array(2)).map(function() {
            return new Int32Array(4);
        });
        this.mvdY2 = Array.apply(null, Array(2)).map(function() {
            return new Int32Array(4);
        });
        this.mvdX3 = Array.apply(null, Array(2)).map(function() {
            return new Int32Array(4);
        });
        this.mvdY3 = Array.apply(null, Array(2)).map(function() {
            return new Int32Array(4);
        });
        this.mvdX4 = Array.apply(null, Array(2)).map(function() {
            return new Int32Array(4);
        });
        this.mvdY4 = Array.apply(null, Array(2)).map(function() {
            return new Int32Array(4);
        });
    };
    constructor.PB8x8 = stjs.extend(constructor.PB8x8, null, [], function(constructor, prototype) {
        prototype.refIdx = null;
        prototype.subMbTypes = null;
        prototype.mvdX1 = null;
        prototype.mvdY1 = null;
        prototype.mvdX2 = null;
        prototype.mvdY2 = null;
        prototype.mvdX3 = null;
        prototype.mvdY3 = null;
        prototype.mvdX4 = null;
        prototype.mvdY4 = null;
        prototype.clean = function() {
            this.mvdX1[0][0] = this.mvdX1[0][1] = this.mvdX1[0][2] = this.mvdX1[0][3] = 0;
            this.mvdX2[0][0] = this.mvdX2[0][1] = this.mvdX2[0][2] = this.mvdX2[0][3] = 0;
            this.mvdX3[0][0] = this.mvdX3[0][1] = this.mvdX3[0][2] = this.mvdX3[0][3] = 0;
            this.mvdX4[0][0] = this.mvdX4[0][1] = this.mvdX4[0][2] = this.mvdX4[0][3] = 0;
            this.mvdY1[0][0] = this.mvdY1[0][1] = this.mvdY1[0][2] = this.mvdY1[0][3] = 0;
            this.mvdY2[0][0] = this.mvdY2[0][1] = this.mvdY2[0][2] = this.mvdY2[0][3] = 0;
            this.mvdY3[0][0] = this.mvdY3[0][1] = this.mvdY3[0][2] = this.mvdY3[0][3] = 0;
            this.mvdY4[0][0] = this.mvdY4[0][1] = this.mvdY4[0][2] = this.mvdY4[0][3] = 0;
            this.mvdX1[1][0] = this.mvdX1[1][1] = this.mvdX1[1][2] = this.mvdX1[1][3] = 0;
            this.mvdX2[1][0] = this.mvdX2[1][1] = this.mvdX2[1][2] = this.mvdX2[1][3] = 0;
            this.mvdX3[1][0] = this.mvdX3[1][1] = this.mvdX3[1][2] = this.mvdX3[1][3] = 0;
            this.mvdX4[1][0] = this.mvdX4[1][1] = this.mvdX4[1][2] = this.mvdX4[1][3] = 0;
            this.mvdY1[1][0] = this.mvdY1[1][1] = this.mvdY1[1][2] = this.mvdY1[1][3] = 0;
            this.mvdY2[1][0] = this.mvdY2[1][1] = this.mvdY2[1][2] = this.mvdY2[1][3] = 0;
            this.mvdY3[1][0] = this.mvdY3[1][1] = this.mvdY3[1][2] = this.mvdY3[1][3] = 0;
            this.mvdY4[1][0] = this.mvdY4[1][1] = this.mvdY4[1][2] = this.mvdY4[1][3] = 0;
            this.subMbTypes[0] = this.subMbTypes[1] = this.subMbTypes[2] = this.subMbTypes[3] = 0;
            this.refIdx[0][0] = this.refIdx[0][1] = this.refIdx[0][2] = this.refIdx[0][3] = 0;
            this.refIdx[1][0] = this.refIdx[1][1] = this.refIdx[1][2] = this.refIdx[1][3] = 0;
        };
    }, {refIdx: "Array", subMbTypes: "Int32Array", mvdX1: "Array", mvdY1: "Array", mvdX2: "Array", mvdY2: "Array", mvdX3: "Array", mvdY3: "Array", mvdX4: "Array", mvdY4: "Array"}, {});
    constructor.IPCM = function(chromaFormat) {
        this.samplesLuma = new Int32Array(256);
        var MbWidthC = 16 >> chromaFormat.compWidth[1];
        var MbHeightC = 16 >> chromaFormat.compHeight[1];
        this.samplesChroma = new Int32Array(2 * MbWidthC * MbHeightC);
    };
    constructor.IPCM = stjs.extend(constructor.IPCM, null, [], function(constructor, prototype) {
        prototype.samplesLuma = null;
        prototype.samplesChroma = null;
        prototype.clean = function() {
            Arrays.fill(this.samplesLuma, 0);
            Arrays.fill(this.samplesChroma, 0);
        };
    }, {samplesLuma: "Int32Array", samplesChroma: "Int32Array"}, {});
    prototype.clear = function() {
        this.chromaPredictionMode = 0;
        this.mbQPDelta = 0;
        Arrays.fill(this.dc, 0);
        for (var i = 0; i < this.ac.length; i++) 
            for (var j = 0; j < this.ac[i].length; j++) 
                for (var k = 0; k < this.ac[i][j].length; k++) 
                    this.ac[i][j][k] = 0;
        this.transform8x8Used = false;
        Arrays.fill(this.lumaModes, 0);
        Arrays.fill(this.dc1, 0);
        Arrays.fill(this.dc2, 0);
        Arrays.fill(this.nCoeff, 0);
        this._cbp = 0;
        this.mbType = 0;
        this.pb16x16.clean();
        this.pb168x168.clean();
        this.pb8x8.clean();
        if (this.curMbType == MBType.I_PCM) 
            this.ipcm.clean();
        this.mbIdx = 0;
        this.fieldDecoding = false;
        this.prevMbType = null;
        this.luma16x16Mode = 0;
        this.skipped = false;
        this.curMbType = null;
    };
}, {dc: "Int32Array", ac: "Array", lumaModes: "Int32Array", dc1: "Int32Array", dc2: "Int32Array", curMbType: "MBType", pb16x16: "MBlock.PB16x16", pb168x168: "MBlock.PB168x168", pb8x8: "MBlock.PB8x8", ipcm: "MBlock.IPCM", prevMbType: "MBType", nCoeff: "Int32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var UnsupportedFormatException = function(arg0) {
    JCodecException.call(this, arg0);
};
UnsupportedFormatException = stjs.extend(UnsupportedFormatException, JCodecException, [], null, {}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  Standard exception, thrown when decoding of an AAC frame fails. The message
 *  gives more detailed information about the error.
 *  
 *  @author in-somnia
 */
var AACException = function(message) {
    IOException.call(this, message);
};
AACException = stjs.extend(AACException, IOException, [], function(constructor, prototype) {
    constructor.endOfStream = function() {
        var ex = new AACException("end of stream");
        ex.eos = true;
        return ex;
    };
    prototype.eos = false;
    prototype.isEndOfStream = function() {
        return this.eos;
    };
    constructor.wrap = function(e) {
        if (e != null && stjs.isInstanceOf(e.constructor, AACException)) {
            return e;
        }
        if (e != null && e.getMessage() != null) {
            return new AACException(e.getMessage());
        }
        return new AACException("" + e);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed under FreeBSD License
 *  
 *  EBML IO implementation
 *  
 *  @author The JCodec project
 *  
 */
var EbmlUtil = function() {};
EbmlUtil = stjs.extend(EbmlUtil, null, [], function(constructor, prototype) {
    /**
     *  Encodes unsigned integer with given length
     *  
     *  @param value
     *             unsigned integer to be encoded
     *  @param length
     *             ebml sequence length
     *  @return
     */
    constructor.ebmlEncodeLen = function(value, length) {
        var b = new Int8Array(length);
        for (var idx = 0; idx < length; idx++) {
            b[length - idx - 1] = (((value >>> (8 * idx)) & 255) << 24 >> 24);
        }
        b[0] |= 128 >>> (length - 1);
        return b;
    };
    /**
     *  Encodes unsigned integer value according to ebml convention
     *  
     *  @param value
     *             unsigned integer to be encoded
     *  @return
     */
    constructor.ebmlEncode = function(value) {
        return EbmlUtil.ebmlEncodeLen(value, EbmlUtil.ebmlLength(value));
    };
    constructor.lengthOptions = new Int8Array([0, (128 << 24 >> 24), 64, 32, 16, 8, 4, 2, 1]);
    /**
     *  This method is used mostly during reading EBML bitstream. It asnwers the question "What is the length of an integer (signed/unsigned) encountered in the bitstream"
     *  
     *  @param b
     *  @return
     */
    constructor.computeLength = function(b) {
        if (b == 0) 
             throw new RuntimeException("Invalid head element for ebml sequence");
        var i = 1;
         while ((b & EbmlUtil.lengthOptions[i]) == 0)
            i++;
        return i;
    };
    constructor.one = 127;
    constructor.two = 16256;
    constructor.three = 2080768;
    constructor.four = 266338304;
    constructor.five = 34091302912;
    constructor.six = 4363686772736;
    constructor.seven = 558551906910208;
    constructor.eight = 71494644084506624;
    constructor.ebmlLengthMasks = [0, EbmlUtil.one, EbmlUtil.two, EbmlUtil.three, EbmlUtil.four, EbmlUtil.five, EbmlUtil.six, EbmlUtil.seven, EbmlUtil.eight];
    /**
     *  This method is used mostly during writing EBML bitstream. It answers the following question "How many bytes should be used to encode unsigned integer value"
     *  
     *  @param v
     *             unsigned integer to be encoded
     *  @return
     */
    constructor.ebmlLength = function(v) {
        if (v == 0) 
            return 1;
        var length = 8;
         while (length > 0 && (v & EbmlUtil.ebmlLengthMasks[length]) == 0)
            length--;
        return length;
    };
    constructor.toHexString = function(a) {
        var sb = new StringBuilder();
        for (var b in a) 
            sb.append(String.format("0x%02x ", b & 255));
        return sb.toString();
    };
}, {lengthOptions: "Int8Array", ebmlLengthMasks: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  An UL class that wraps UL bytes, introduced to implement custom comparison
 *  rules
 *  
 *  @author The JCodec project
 *  
 */
var UL = function(bytes) {
    this.bytes = bytes;
};
UL = stjs.extend(UL, null, [], function(constructor, prototype) {
    prototype.bytes = null;
    constructor.newUL = function(_arguments) {
        var bytes = new Int8Array(arguments.length);
        for (var i = 0; i < arguments.length; i++) {
            bytes[i] = (arguments[i] << 24 >> 24);
        }
        return new UL(bytes);
    };
    prototype.hashCode = function() {
        return ((this.bytes[4] & 255) << 24) | ((this.bytes[5] & 255) << 16) | ((this.bytes[6] & 255) << 8) | (this.bytes[7] & 255);
    };
    prototype.equals = function(obj) {
        if (!(stjs.isInstanceOf(obj.constructor, UL))) 
            return false;
        var other = (obj).bytes;
        for (var i = 4; i < Math.min(this.bytes.length, other.length); i++) 
            if (this.bytes[i] != other[i]) 
                return false;
        return true;
    };
    prototype.maskEquals = function(o, mask) {
        if (o == null) 
            return false;
        var other = (o).bytes;
        mask >>= 4;
        for (var i = 4; i < Math.min(this.bytes.length, other.length); i++ , mask >>= 1) 
            if ((mask & 1) == 1 && this.bytes[i] != other[i]) 
                return false;
        return true;
    };
    prototype.toString = function() {
        var sb = new StringBuilder();
        sb.append("06:0E:2B:34:");
        for (var i = 4; i < this.bytes.length; i++) {
            sb.append(this.hex((this.bytes[i] >> 4) & 15));
            sb.append(this.hex(this.bytes[i] & 15));
            if (i < this.bytes.length - 1) 
                sb.append(":");
        }
        return sb.toString();
    };
    prototype.hex = function(i) {
        return (((i < 10 ? '0' + i : 'A' + (i - 10))) & 65535);
    };
    prototype.get = function(i) {
        return this.bytes[i];
    };
    constructor.read = function(_bb) {
        var umid = new Int8Array(16);
        _bb.getBuf(umid);
        return new UL(umid);
    };
}, {bytes: "Int8Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  This code is borrowed from Apache Commons String Utils
 *  
 *  @author The JCodec project
 */
var StringUtils = function() {};
StringUtils = stjs.extend(StringUtils, null, [], function(constructor, prototype) {
    constructor.splitWorker4 = function(str, separatorChars, max, preserveAllTokens) {
        if (str == null) {
            return null;
        }
        var len = str.length;
        if (len == 0) {
            return Array(0);
        }
        var list = new ArrayList();
        var sizePlus1 = 1;
        var i = 0, start = 0;
        var match = false;
        var lastMatch = false;
        if (separatorChars == null) {
             while (i < len){
                if (Character.isWhitespace(str.charAt(i))) {
                    if (match || preserveAllTokens) {
                        lastMatch = true;
                        if (sizePlus1++ == max) {
                            i = len;
                            lastMatch = false;
                        }
                        list.add(str.substring(start, i));
                        match = false;
                    }
                    start = ++i;
                    continue;
                }
                lastMatch = false;
                match = true;
                i++;
            }
        } else if (separatorChars.length == 1) {
            var sep = separatorChars.charAt(0);
             while (i < len){
                if (str.charAt(i) == sep) {
                    if (match || preserveAllTokens) {
                        lastMatch = true;
                        if (sizePlus1++ == max) {
                            i = len;
                            lastMatch = false;
                        }
                        list.add(str.substring(start, i));
                        match = false;
                    }
                    start = ++i;
                    continue;
                }
                lastMatch = false;
                match = true;
                i++;
            }
        } else {
             while (i < len){
                if (separatorChars.indexOf(str.charAt(i)) >= 0) {
                    if (match || preserveAllTokens) {
                        lastMatch = true;
                        if (sizePlus1++ == max) {
                            i = len;
                            lastMatch = false;
                        }
                        list.add(str.substring(start, i));
                        match = false;
                    }
                    start = ++i;
                    continue;
                }
                lastMatch = false;
                match = true;
                i++;
            }
        }
        if (match || (preserveAllTokens && lastMatch)) {
            list.add(str.substring(start, i));
        }
        return list.toArray(Array(list.size()));
    };
    constructor.splitWorker = function(str, separatorChar, preserveAllTokens) {
        if (str == null) {
            return null;
        }
        var len = str.length;
        if (len == 0) {
            return Array(0);
        }
        var list = new ArrayList();
        var i = 0, start = 0;
        var match = false;
        var lastMatch = false;
         while (i < len){
            if (str.charAt(i) == separatorChar) {
                if (match || preserveAllTokens) {
                    list.add(str.substring(start, i));
                    match = false;
                    lastMatch = true;
                }
                start = ++i;
                continue;
            }
            lastMatch = false;
            match = true;
            i++;
        }
        if (match || (preserveAllTokens && lastMatch)) {
            list.add(str.substring(start, i));
        }
        return list.toArray(Array(list.size()));
    };
    constructor.split = function(str) {
        return StringUtils.splitS3(str, null, -1);
    };
    constructor.splitS = function(str, separatorChars) {
        return StringUtils.splitWorker4(str, separatorChars, -1, false);
    };
    constructor.splitS3 = function(str, separatorChars, max) {
        return StringUtils.splitWorker4(str, separatorChars, max, false);
    };
    constructor.splitC = function(str, separatorChar) {
        return StringUtils.splitWorker(str, separatorChar, false);
    };
    constructor.isEmpty = function(str) {
        return str == null || str.length == 0;
    };
    constructor.isDelimiter = function(ch, delimiters) {
        if (delimiters == null) {
            return Character.isWhitespace(ch);
        }
        for (var i = 0, isize = delimiters.length; i < isize; i++) {
            if (ch == delimiters[i]) {
                return true;
            }
        }
        return false;
    };
    constructor.capitaliseAllWords = function(str) {
        return StringUtils.capitalize(str);
    };
    constructor.capitalize = function(str) {
        return StringUtils.capitalizeD(str, null);
    };
    constructor.capitalizeD = function(str, delimiters) {
        var delimLen = (delimiters == null ? -1 : delimiters.length);
        if (str == null || str.length == 0 || delimLen == 0) {
            return str;
        }
        var strLen = str.length;
        var buffer = new StringBuilder(strLen);
        var capitalizeNext = true;
        for (var i = 0; i < strLen; i++) {
            var ch = str.charAt(i);
            if (StringUtils.isDelimiter(ch, delimiters)) {
                buffer.append(ch);
                capitalizeNext = true;
            } else if (capitalizeNext) {
                buffer.append(Character.toTitleCase(ch));
                capitalizeNext = false;
            } else {
                buffer.append(ch);
            }
        }
        return buffer.toString();
    };
    constructor.join = function(array) {
        return StringUtils.joinS(array, null);
    };
    constructor.join2 = function(array, separator) {
        if (array == null) {
            return null;
        }
        return StringUtils.join4(array, separator, 0, array.length);
    };
    constructor.join4 = function(array, separator, startIndex, endIndex) {
        if (array == null) {
            return null;
        }
        var bufSize = (endIndex - startIndex);
        if (bufSize <= 0) {
            return "";
        }
        bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length) + 1);
        var buf = new StringBuilder(bufSize);
        for (var i = startIndex; i < endIndex; i++) {
            if (i > startIndex) {
                buf.append(separator);
            }
            if (array[i] != null) {
                buf.append(array[i]);
            }
        }
        return buf.toString();
    };
    constructor.joinS = function(array, separator) {
        if (array == null) {
            return null;
        }
        return StringUtils.joinS4(array, separator, 0, array.length);
    };
    constructor.joinS4 = function(array, separator, startIndex, endIndex) {
        if (array == null) {
            return null;
        }
        if (separator == null) {
            separator = "";
        }
        var bufSize = (endIndex - startIndex);
        if (bufSize <= 0) {
            return "";
        }
        bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length) + separator.length);
        var buf = new StringBuilder(bufSize);
        for (var i = startIndex; i < endIndex; i++) {
            if (i > startIndex) {
                buf.append(separator);
            }
            if (array[i] != null) {
                buf.append(array[i]);
            }
        }
        return buf.toString();
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var FilterUtil = function() {};
FilterUtil = stjs.extend(FilterUtil, null, [], function(constructor, prototype) {
    /**
     *   Clamp, then convert signed number back to pixel value. 
     */
    constructor.clipPlus128 = function(v) {
        return stjs.trunc((FilterUtil.clipSigned(v) + 128));
    };
    constructor.Segment = function() {};
    constructor.Segment = stjs.extend(constructor.Segment, null, [], function(constructor, prototype) {
        /**
         *  pixels before edge
         */
        prototype.p0 = 0;
        /**
         *  pixels before edge
         */
        prototype.p1 = 0;
        /**
         *  pixels before edge
         */
        prototype.p2 = 0;
        /**
         *  pixels before edge
         */
        prototype.p3 = 0;
        /**
         *  pixels after edge
         */
        prototype.q0 = 0;
        /**
         *  pixels after edge
         */
        prototype.q1 = 0;
        /**
         *  pixels after edge
         */
        prototype.q2 = 0;
        /**
         *  pixels after edge
         */
        prototype.q3 = 0;
        /**
         *  All functions take (among other things) a segment (of length at most 4 + 4 = 8) symmetrically 
         *  straddling an edge. The pixel values (or pointers) are always given in order, from the 
         *  "beforemost" to the "aftermost". So, for a horizontal edge (written "|"), an 8-pixel segment 
         *  would be ordered p3 p2 p1 p0 | q0 q1 q2 q3.
         * 
         *  Filtering is disabled if the difference between any two adjacent "interior" pixels in the 
         *  8-pixel segment exceeds the relevant threshold (I). A more complex thresholding calculation 
         *  is done for the group of four pixels that straddle the edge, in line with the calculation in simple_segment() above.
         *  @interior limit on interior differences 
         *  @edge limit at the edge 
         */
        prototype.isFilterRequired = function(interior, edge) {
            return ((Math.abs(this.p0 - this.q0) << 2) + (Math.abs(this.p1 - this.q1) >> 2)) <= edge && Math.abs(this.p3 - this.p2) <= interior && Math.abs(this.p2 - this.p1) <= interior && Math.abs(this.p1 - this.p0) <= interior && Math.abs(this.q3 - this.q2) <= interior && Math.abs(this.q2 - this.q1) <= interior && Math.abs(this.q1 - this.q0) <= interior;
        };
        /**
         *   HEV - Hight Edge Variance. Filtering is altered 
         *   if (at least) one of the differences on either side of 
         *   the edge exceeds a threshold (we have "high edge variance").
         *  @param threshold
         *  @param p1 before
         *  @param p0 before
         *  @param q0 after
         *  @param q1 after
         *  @return
         */
        prototype.isHighVariance = function(threshold) {
            return Math.abs(this.p1 - this.p0) > threshold || Math.abs(this.q1 - this.q0) > threshold;
        };
        prototype.getSigned = function() {
            var seg = new FilterUtil.Segment();
            seg.p3 = FilterUtil.minus128(this.p3);
            seg.p2 = FilterUtil.minus128(this.p2);
            seg.p1 = FilterUtil.minus128(this.p1);
            seg.p0 = FilterUtil.minus128(this.p0);
            seg.q0 = FilterUtil.minus128(this.q0);
            seg.q1 = FilterUtil.minus128(this.q1);
            seg.q2 = FilterUtil.minus128(this.q2);
            seg.q3 = FilterUtil.minus128(this.q3);
            return seg;
        };
        constructor.horizontal = function(right, left, a) {
            var seg = new FilterUtil.Segment();
            seg.p0 = left.val[3 * 4 + a];
            seg.p1 = left.val[2 * 4 + a];
            seg.p2 = left.val[1 * 4 + a];
            seg.p3 = left.val[0 * 4 + a];
            seg.q0 = right.val[0 * 4 + a];
            seg.q1 = right.val[1 * 4 + a];
            seg.q2 = right.val[2 * 4 + a];
            seg.q3 = right.val[3 * 4 + a];
            return seg;
        };
        constructor.vertical = function(lower, upper, a) {
            var seg = new FilterUtil.Segment();
            seg.p0 = upper.val[a * 4 + 3];
            seg.p1 = upper.val[a * 4 + 2];
            seg.p2 = upper.val[a * 4 + 1];
            seg.p3 = upper.val[a * 4 + 0];
            seg.q0 = lower.val[a * 4 + 0];
            seg.q1 = lower.val[a * 4 + 1];
            seg.q2 = lower.val[a * 4 + 2];
            seg.q3 = lower.val[a * 4 + 3];
            return seg;
        };
        prototype.applyHorizontally = function(right, left, a) {
            left.val[3 * 4 + a] = this.p0;
            left.val[2 * 4 + a] = this.p1;
            left.val[1 * 4 + a] = this.p2;
            left.val[0 * 4 + a] = this.p3;
            right.val[0 * 4 + a] = this.q0;
            right.val[1 * 4 + a] = this.q1;
            right.val[2 * 4 + a] = this.q2;
            right.val[3 * 4 + a] = this.q3;
        };
        prototype.applyVertically = function(lower, upper, a) {
            upper.val[a * 4 + 3] = this.p0;
            upper.val[a * 4 + 2] = this.p1;
            upper.val[a * 4 + 1] = this.p2;
            upper.val[a * 4 + 0] = this.p3;
            lower.val[a * 4 + 0] = this.q0;
            lower.val[a * 4 + 1] = this.q1;
            lower.val[a * 4 + 2] = this.q2;
            lower.val[a * 4 + 3] = this.q3;
        };
        /**
         *  
         *  @param hevThreshold detect high edge variance
         *  @param interiorLimit possibly disable filter
         *  @param edgeLimit
         *  @param this
         */
        prototype.filterMb = function(hevThreshold, interiorLimit, edgeLimit) {
            var signedSeg = this.getSigned();
            if (signedSeg.isFilterRequired(interiorLimit, edgeLimit)) {
                if (!signedSeg.isHighVariance(hevThreshold)) {
                    var w = FilterUtil.clipSigned(FilterUtil.clipSigned(signedSeg.p1 - signedSeg.q1) + 3 * (signedSeg.q0 - signedSeg.p0));
                    var a = (27 * w + 63) >> 7;
                    this.q0 = FilterUtil.clipPlus128(signedSeg.q0 - a);
                    this.p0 = FilterUtil.clipPlus128(signedSeg.p0 + a);
                    a = (18 * w + 63) >> 7;
                    this.q1 = FilterUtil.clipPlus128(signedSeg.q1 - a);
                    this.p1 = FilterUtil.clipPlus128(signedSeg.p1 + a);
                    a = (9 * w + 63) >> 7;
                    this.q2 = FilterUtil.clipPlus128(signedSeg.q2 - a);
                    this.p2 = FilterUtil.clipPlus128(signedSeg.p2 + a);
                } else 
                    this.adjust(true);
            }
        };
        /**
         *  
         *  @param hev_threshold detect high edge variance
         *  @param interior_limit disable filter
         *  @param edge_limit
         *  @param this
         */
        prototype.filterSb = function(hev_threshold, interior_limit, edge_limit) {
            var signedSeg = this.getSigned();
            if (signedSeg.isFilterRequired(interior_limit, edge_limit)) {
                var hv = signedSeg.isHighVariance(hev_threshold);
                var a = (this.adjust(hv) + 1) >> 1;
                if (!hv) {
                    this.q1 = FilterUtil.clipPlus128(signedSeg.q1 - a);
                    this.p1 = FilterUtil.clipPlus128(signedSeg.p1 + a);
                }
            }
        };
        /**
         *  filter is 2 or 4 taps wide
         */
        prototype.adjust = function(use_outer_taps) {
            var p1 = FilterUtil.minus128(this.p1);
            var p0 = FilterUtil.minus128(this.p0);
            var q0 = FilterUtil.minus128(this.q0);
            var q1 = FilterUtil.minus128(this.q1);
            var a = FilterUtil.clipSigned((use_outer_taps ? FilterUtil.clipSigned(p1 - q1) : 0) + 3 * (q0 - p0));
            var b = (FilterUtil.clipSigned(a + 3)) >> 3;
            a = FilterUtil.clipSigned(a + 4) >> 3;
            this.q0 = FilterUtil.clipPlus128(q0 - a);
            this.p0 = FilterUtil.clipPlus128(p0 + b);
            return a;
        };
    }, {}, {});
    constructor.clipSigned = function(v) {
        return stjs.trunc((v < -128 ? -128 : (v > 127 ? 127 : v)));
    };
    constructor.minus128 = function(v) {
        return stjs.trunc((v - 128));
    };
    constructor.loopFilterUV = function(mbs, sharpnessLevel, keyFrame) {
        for (var y = 0; y < (mbs.length - 2); y++) {
            for (var x = 0; x < (mbs[0].length - 2); x++) {
                var rmb = mbs[y + 1][x + 1];
                var bmb = mbs[y + 1][x + 1];
                var loop_filter_level = rmb.filterLevel;
                if (loop_filter_level != 0) {
                    var interior_limit = rmb.filterLevel;
                    if (sharpnessLevel > 0) {
                        interior_limit >>= sharpnessLevel > 4 ? 2 : 1;
                        if (interior_limit > 9 - sharpnessLevel) 
                            interior_limit = 9 - sharpnessLevel;
                    }
                    if (interior_limit == 0) 
                        interior_limit = 1;
                    var hev_threshold = 0;
                    if (keyFrame) {
                        if (loop_filter_level >= 40) 
                            hev_threshold = 2;
                         else if (loop_filter_level >= 15) 
                            hev_threshold = 1;
                    } else {
                         throw new NotImplementedException("TODO: non-key frames are not supported yet.");
                    }
                    var mbedge_limit = ((loop_filter_level + 2) * 2) + interior_limit;
                    var sub_bedge_limit = (loop_filter_level * 2) + interior_limit;
                    if (x > 0) {
                        var lmb = mbs[y + 1][x + 1 - 1];
                        for (var b = 0; b < 2; b++) {
                            var rsbU = rmb.uSubblocks[b][0];
                            var lsbU = lmb.uSubblocks[b][1];
                            var rsbV = rmb.vSubblocks[b][0];
                            var lsbV = lmb.vSubblocks[b][1];
                            for (var a = 0; a < 4; a++) {
                                var seg = FilterUtil.Segment.horizontal(rsbU, lsbU, a);
                                seg.filterMb(hev_threshold, interior_limit, mbedge_limit);
                                seg.applyHorizontally(rsbU, lsbU, a);
                                seg = FilterUtil.Segment.horizontal(rsbV, lsbV, a);
                                seg.filterMb(hev_threshold, interior_limit, mbedge_limit);
                                seg.applyHorizontally(rsbV, lsbV, a);
                            }
                        }
                    }
                    if (!rmb.skipFilter) {
                        for (var a = 1; a < 2; a++) {
                            for (var b = 0; b < 2; b++) {
                                var lsbU = rmb.uSubblocks[b][a - 1];
                                var rsbU = rmb.uSubblocks[b][a];
                                var lsbV = rmb.vSubblocks[b][a - 1];
                                var rsbV = rmb.vSubblocks[b][a];
                                for (var c = 0; c < 4; c++) {
                                    var seg = FilterUtil.Segment.horizontal(rsbU, lsbU, c);
                                    seg.filterSb(hev_threshold, interior_limit, sub_bedge_limit);
                                    seg.applyHorizontally(rsbU, lsbU, c);
                                    seg = FilterUtil.Segment.horizontal(rsbV, lsbV, c);
                                    seg.filterSb(hev_threshold, interior_limit, sub_bedge_limit);
                                    seg.applyHorizontally(rsbV, lsbV, c);
                                }
                            }
                        }
                    }
                    if (y > 0) {
                        var tmb = mbs[y + 1 - 1][x + 1];
                        for (var b = 0; b < 2; b++) {
                            var tsbU = tmb.uSubblocks[1][b];
                            var bsbU = bmb.uSubblocks[0][b];
                            var tsbV = tmb.vSubblocks[1][b];
                            var bsbV = bmb.vSubblocks[0][b];
                            for (var a = 0; a < 4; a++) {
                                var seg = FilterUtil.Segment.vertical(bsbU, tsbU, a);
                                seg.filterMb(hev_threshold, interior_limit, mbedge_limit);
                                seg.applyVertically(bsbU, tsbU, a);
                                seg = FilterUtil.Segment.vertical(bsbV, tsbV, a);
                                seg.filterMb(hev_threshold, interior_limit, mbedge_limit);
                                seg.applyVertically(bsbV, tsbV, a);
                            }
                        }
                    }
                    if (!rmb.skipFilter) {
                        for (var a = 1; a < 2; a++) {
                            for (var b = 0; b < 2; b++) {
                                var tsbU = bmb.uSubblocks[a - 1][b];
                                var bsbU = bmb.uSubblocks[a][b];
                                var tsbV = bmb.vSubblocks[a - 1][b];
                                var bsbV = bmb.vSubblocks[a][b];
                                for (var c = 0; c < 4; c++) {
                                    var seg = FilterUtil.Segment.vertical(bsbU, tsbU, c);
                                    seg.filterSb(hev_threshold, interior_limit, sub_bedge_limit);
                                    seg.applyVertically(bsbU, tsbU, c);
                                    seg = FilterUtil.Segment.vertical(bsbV, tsbV, c);
                                    seg.filterSb(hev_threshold, interior_limit, sub_bedge_limit);
                                    seg.applyVertically(bsbV, tsbV, c);
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    constructor.loopFilterY = function(mbs, sharpnessLevel, keyFrame) {
        for (var y = 0; y < (mbs.length - 2); y++) {
            for (var x = 0; x < (mbs[0].length - 2); x++) {
                var rmb = mbs[y + 1][x + 1];
                var bmb = mbs[y + 1][x + 1];
                var loopFilterLevel = rmb.filterLevel;
                if (loopFilterLevel != 0) {
                    var interiorLimit = rmb.filterLevel;
                    if (sharpnessLevel > 0) {
                        interiorLimit >>= sharpnessLevel > 4 ? 2 : 1;
                        if (interiorLimit > 9 - sharpnessLevel) 
                            interiorLimit = 9 - sharpnessLevel;
                    }
                    if (interiorLimit == 0) 
                        interiorLimit = 1;
                    var varianceThreshold = 0;
                    if (keyFrame) {
                        if (loopFilterLevel >= 40) 
                            varianceThreshold = 2;
                         else if (loopFilterLevel >= 15) 
                            varianceThreshold = 1;
                    } else {
                         throw new NotImplementedException("TODO: non-key frames are not supported yet");
                    }
                    var edgeLimitMb = ((loopFilterLevel + 2) * 2) + interiorLimit;
                    var edgeLimitSb = (loopFilterLevel * 2) + interiorLimit;
                    if (x > 0) {
                        var lmb = mbs[y + 1][x - 1 + 1];
                        for (var b = 0; b < 4; b++) {
                            var rsb = rmb.ySubblocks[b][0];
                            var lsb = lmb.ySubblocks[b][3];
                            for (var a = 0; a < 4; a++) {
                                var seg = FilterUtil.Segment.horizontal(rsb, lsb, a);
                                seg.filterMb(varianceThreshold, interiorLimit, edgeLimitMb);
                                seg.applyHorizontally(rsb, lsb, a);
                            }
                        }
                    }
                    if (!rmb.skipFilter) {
                        for (var a = 1; a < 4; a++) {
                            for (var b = 0; b < 4; b++) {
                                var lsb = rmb.ySubblocks[b][a - 1];
                                var rsb = rmb.ySubblocks[b][a];
                                for (var c = 0; c < 4; c++) {
                                    var seg = FilterUtil.Segment.horizontal(rsb, lsb, c);
                                    seg.filterSb(varianceThreshold, interiorLimit, edgeLimitSb);
                                    seg.applyHorizontally(rsb, lsb, c);
                                }
                            }
                        }
                    }
                    if (y > 0) {
                        var tmb = mbs[y - 1 + 1][x + 1];
                        for (var b = 0; b < 4; b++) {
                            var tsb = tmb.ySubblocks[3][b];
                            var bsb = bmb.ySubblocks[0][b];
                            for (var a = 0; a < 4; a++) {
                                var seg = FilterUtil.Segment.vertical(bsb, tsb, a);
                                seg.filterMb(varianceThreshold, interiorLimit, edgeLimitMb);
                                seg.applyVertically(bsb, tsb, a);
                            }
                        }
                    }
                    if (!rmb.skipFilter) {
                        for (var a = 1; a < 4; a++) {
                            for (var b = 0; b < 4; b++) {
                                var tsb = bmb.ySubblocks[a - 1][b];
                                var bsb = bmb.ySubblocks[a][b];
                                for (var c = 0; c < 4; c++) {
                                    var seg = FilterUtil.Segment.vertical(bsb, tsb, c);
                                    seg.filterSb(varianceThreshold, interiorLimit, edgeLimitSb);
                                    seg.applyVertically(bsb, tsb, c);
                                }
                            }
                        }
                    }
                }
            }
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Macroblock = function(y, x) {
    this.ySubblocks = Array.apply(null, Array(4)).map(function() {
        return Array(4);
    });
    this.y2 = new Macroblock.Subblock(this, 0, 0, VP8Util.PLANE.Y2);
    this.uSubblocks = Array.apply(null, Array(2)).map(function() {
        return Array(2);
    });
    this.vSubblocks = Array.apply(null, Array(2)).map(function() {
        return Array(2);
    });
    this.Rrow = y;
    this.column = x;
    for (var row = 0; row < 4; row++) 
        for (var col = 0; col < 4; col++) 
            this.ySubblocks[row][col] = new Macroblock.Subblock(this, row, col, VP8Util.PLANE.Y1);
    for (var row = 0; row < 2; row++) 
        for (var col = 0; col < 2; col++) {
            this.uSubblocks[row][col] = new Macroblock.Subblock(this, row, col, VP8Util.PLANE.U);
            this.vSubblocks[row][col] = new Macroblock.Subblock(this, row, col, VP8Util.PLANE.V);
        }
};
Macroblock = stjs.extend(Macroblock, null, [], function(constructor, prototype) {
    prototype.filterLevel = 0;
    prototype.chromaMode = 0;
    prototype.skipCoeff = 0;
    prototype.ySubblocks = null;
    prototype.y2 = null;
    prototype.uSubblocks = null;
    prototype.vSubblocks = null;
    prototype.Rrow = 0;
    prototype.column = 0;
    prototype.lumaMode = 0;
    prototype.skipFilter = false;
    prototype.segment = 0;
    prototype.debug = true;
    prototype.dequantMacroBlock = function(mbs, p) {
        if (this.lumaMode != VP8Util.SubblockConstants.B_PRED) {
            var acQValue = p.y2AC;
            var dcQValue = p.y2DC;
            var input = new Int32Array(16);
            input[0] = this.y2.tokens[0] * dcQValue;
            for (var x = 1; x < 16; x++) 
                input[x] = this.y2.tokens[x] * acQValue;
            this.y2.residue = VP8DCT.decodeWHT(input);
            for (var row = 0; row < 4; row++) 
                for (var col = 0; col < 4; col++) 
                    this.ySubblocks[row][col].dequantSubblock(p.yDC, p.yAC, this.y2.residue[row * 4 + col]);
            this.predictY(mbs);
            this.predictUV(mbs);
            for (var row = 0; row < 2; row++) {
                for (var col = 0; col < 2; col++) {
                    this.uSubblocks[row][col].dequantSubblock(p.chromaDC, p.chromaAC, null);
                    this.vSubblocks[row][col].dequantSubblock(p.chromaDC, p.chromaAC, null);
                }
            }
            this.reconstruct();
        } else {
            for (var row = 0; row < 4; row++) {
                for (var col = 0; col < 4; col++) {
                    var sb = this.ySubblocks[row][col];
                    sb.dequantSubblock(p.yDC, p.yAC, null);
                    sb.predict(mbs);
                    sb.reconstruct();
                }
            }
            this.predictUV(mbs);
            for (var row = 0; row < 2; row++) {
                for (var col = 0; col < 2; col++) {
                    var sb = this.uSubblocks[row][col];
                    sb.dequantSubblock(p.chromaDC, p.chromaAC, null);
                    sb.reconstruct();
                }
            }
            for (var row = 0; row < 2; row++) {
                for (var col = 0; col < 2; col++) {
                    var sb = this.vSubblocks[row][col];
                    sb.dequantSubblock(p.chromaDC, p.chromaAC, null);
                    sb.reconstruct();
                }
            }
        }
    };
    prototype.reconstruct = function() {
        for (var row = 0; row < 4; row++) 
            for (var col = 0; col < 4; col++) 
                this.ySubblocks[row][col].reconstruct();
        for (var row = 0; row < 2; row++) 
            for (var col = 0; col < 2; col++) 
                this.uSubblocks[row][col].reconstruct();
        for (var row = 0; row < 2; row++) 
            for (var col = 0; col < 2; col++) 
                this.vSubblocks[row][col].reconstruct();
    };
    prototype.predictUV = function(mbs) {
        var aboveMb = mbs[this.Rrow - 1][this.column];
        var leftMb = mbs[this.Rrow][this.column - 1];
        switch (this.chromaMode) {
            case VP8Util.SubblockConstants.DC_PRED:
                var up_available = false;
                var left_available = false;
                var uAvg = 0;
                var vAvg = 0;
                var expected_udc = 128;
                var expected_vdc = 128;
                if (this.column > 1) 
                    left_available = true;
                if (this.Rrow > 1) 
                    up_available = true;
                if (up_available || left_available) {
                    if (up_available) {
                        for (var j = 0; j < 2; j++) {
                            var usb = aboveMb.uSubblocks[1][j];
                            var vsb = aboveMb.vSubblocks[1][j];
                            for (var i = 0; i < 4; i++) {
                                uAvg += usb.val[3 * 4 + i];
                                vAvg += vsb.val[3 * 4 + i];
                            }
                        }
                    }
                    if (left_available) {
                        for (var j = 0; j < 2; j++) {
                            var usb = leftMb.uSubblocks[j][1];
                            var vsb = leftMb.vSubblocks[j][1];
                            for (var i = 0; i < 4; i++) {
                                uAvg += usb.val[i * 4 + 3];
                                vAvg += vsb.val[i * 4 + 3];
                            }
                        }
                    }
                    var shift = 2;
                    if (up_available) 
                        shift++;
                    if (left_available) 
                        shift++;
                    expected_udc = (uAvg + (1 << (shift - 1))) >> shift;
                    expected_vdc = (vAvg + (1 << (shift - 1))) >> shift;
                }
                var ufill = new Int32Array(16);
                for (var aRow = 0; aRow < 4; aRow++) 
                    for (var aCol = 0; aCol < 4; aCol++) 
                        ufill[aRow * 4 + aCol] = expected_udc;
                var vfill = new Int32Array(16);
                for (var aRow = 0; aRow < 4; aRow++) 
                    for (var aCol = 0; aCol < 4; aCol++) 
                        vfill[aRow * 4 + aCol] = expected_vdc;
                for (var aRow = 0; aRow < 2; aRow++) {
                    for (var aCol = 0; aCol < 2; aCol++) {
                        var usb = this.uSubblocks[aRow][aCol];
                        var vsb = this.vSubblocks[aRow][aCol];
                        usb._predict = ufill;
                        vsb._predict = vfill;
                    }
                }
                break;
            case VP8Util.SubblockConstants.V_PRED:
                var aboveUSb = Array(2);
                var aboveVSb = Array(2);
                for (var aCol = 0; aCol < 2; aCol++) {
                    aboveUSb[aCol] = aboveMb.uSubblocks[1][aCol];
                    aboveVSb[aCol] = aboveMb.vSubblocks[1][aCol];
                }
                for (var aRow = 0; aRow < 2; aRow++) 
                    for (var aCol = 0; aCol < 2; aCol++) {
                        var usb = this.uSubblocks[aRow][aCol];
                        var vsb = this.vSubblocks[aRow][aCol];
                        var ublock = new Int32Array(16);
                        var vblock = new Int32Array(16);
                        for (var pRow = 0; pRow < 4; pRow++) 
                            for (var pCol = 0; pCol < 4; pCol++) {
                                ublock[pRow * 4 + pCol] = aboveUSb[aCol].val != null ? aboveUSb[aCol].val[3 * 4 + pCol] : 127;
                                vblock[pRow * 4 + pCol] = aboveVSb[aCol].val != null ? aboveVSb[aCol].val[3 * 4 + pCol] : 127;
                            }
                        usb._predict = ublock;
                        vsb._predict = vblock;
                    }
                break;
            case VP8Util.SubblockConstants.H_PRED:
                var leftUSb = Array(2);
                var leftVSb = Array(2);
                for (var aCol = 0; aCol < 2; aCol++) {
                    leftUSb[aCol] = leftMb.uSubblocks[aCol][1];
                    leftVSb[aCol] = leftMb.vSubblocks[aCol][1];
                }
                for (var aRow = 0; aRow < 2; aRow++) 
                    for (var aCol = 0; aCol < 2; aCol++) {
                        var usb = this.uSubblocks[aRow][aCol];
                        var vsb = this.vSubblocks[aRow][aCol];
                        var ublock = new Int32Array(16);
                        var vblock = new Int32Array(16);
                        for (var pRow = 0; pRow < 4; pRow++) 
                            for (var pCol = 0; pCol < 4; pCol++) {
                                ublock[pRow * 4 + pCol] = leftUSb[aRow].val != null ? leftUSb[aRow].val[pRow * 4 + 3] : 129;
                                vblock[pRow * 4 + pCol] = leftVSb[aRow].val != null ? leftVSb[aRow].val[pRow * 4 + 3] : 129;
                            }
                        usb._predict = ublock;
                        vsb._predict = vblock;
                    }
                break;
            case VP8Util.SubblockConstants.TM_PRED:
                var ALMb = mbs[this.Rrow - 1][this.column - 1];
                var ALUSb = ALMb.uSubblocks[1][1];
                var alu = ALUSb.val[3 * 4 + 3];
                var ALVSb = ALMb.vSubblocks[1][1];
                var alv = ALVSb.val[3 * 4 + 3];
                aboveUSb = Array(2);
                leftUSb = Array(2);
                aboveVSb = Array(2);
                leftVSb = Array(2);
                for (var x = 0; x < 2; x++) {
                    aboveUSb[x] = aboveMb.uSubblocks[1][x];
                    leftUSb[x] = leftMb.uSubblocks[x][1];
                    aboveVSb[x] = aboveMb.vSubblocks[1][x];
                    leftVSb[x] = leftMb.vSubblocks[x][1];
                }
                for (var sbRow = 0; sbRow < 2; sbRow++) {
                    for (var pRow = 0; pRow < 4; pRow++) {
                        for (var sbCol = 0; sbCol < 2; sbCol++) {
                            if (this.uSubblocks[sbRow][sbCol].val == null) 
                                this.uSubblocks[sbRow][sbCol].val = new Int32Array(16);
                            if (this.vSubblocks[sbRow][sbCol].val == null) 
                                this.vSubblocks[sbRow][sbCol].val = new Int32Array(16);
                            for (var pCol = 0; pCol < 4; pCol++) {
                                var upred = leftUSb[sbRow].val[pRow * 4 + 3] + aboveUSb[sbCol].val[3 * 4 + pCol] - alu;
                                upred = VP8Util.QuantizationParams.clip255(upred);
                                this.uSubblocks[sbRow][sbCol].val[pRow * 4 + pCol] = upred;
                                var vpred = leftVSb[sbRow].val[pRow * 4 + 3] + aboveVSb[sbCol].val[3 * 4 + pCol] - alv;
                                vpred = VP8Util.QuantizationParams.clip255(vpred);
                                this.vSubblocks[sbRow][sbCol].val[pRow * 4 + pCol] = vpred;
                            }
                        }
                    }
                }
                break;
            default:
                System.err.println("TODO predict_mb_uv: " + this.lumaMode);
                System.exit(0);
        }
    };
    prototype.predictY = function(mbs) {
        var aboveMb = mbs[this.Rrow - 1][this.column];
        var leftMb = mbs[this.Rrow][this.column - 1];
        switch (this.lumaMode) {
            case VP8Util.SubblockConstants.DC_PRED:
                this.predictLumaDC(aboveMb, leftMb);
                break;
            case VP8Util.SubblockConstants.V_PRED:
                this.predictLumaV(aboveMb);
                break;
            case VP8Util.SubblockConstants.H_PRED:
                this.predictLumaH(leftMb);
                break;
            case VP8Util.SubblockConstants.TM_PRED:
                var upperLeft = mbs[this.Rrow - 1][this.column - 1];
                var ALSb = upperLeft.ySubblocks[3][3];
                var aboveLeft = ALSb.val[3 * 4 + 3];
                this.predictLumaTM(aboveMb, leftMb, aboveLeft);
                break;
            default:
                System.err.println("TODO predict_mb_y: " + this.lumaMode);
                System.exit(0);
        }
    };
    prototype.predictLumaDC = function(above, left) {
        var hasAbove = this.Rrow > 1;
        var hasLeft = this.column > 1;
        var expected_dc = 128;
        if (hasAbove || hasLeft) {
            var average = 0;
            if (hasAbove) {
                for (var j = 0; j < 4; j++) {
                    var sb = above.ySubblocks[3][j];
                    for (var i = 0; i < 4; i++) 
                        average += sb.val[3 * 4 + i];
                }
            }
            if (hasLeft) {
                for (var j = 0; j < 4; j++) {
                    var sb = left.ySubblocks[j][3];
                    for (var i = 0; i < 4; i++) 
                        average += sb.val[i * 4 + 3];
                }
            }
            var shift = 3;
            if (hasAbove) 
                shift++;
            if (hasLeft) 
                shift++;
            expected_dc = (average + (1 << (shift - 1))) >> shift;
        }
        var fill = new Int32Array(16);
        for (var i = 0; i < 16; i++) 
            fill[i] = expected_dc;
        for (var y = 0; y < 4; y++) 
            for (var x = 0; x < 4; x++) 
                this.ySubblocks[y][x]._predict = fill;
    };
    prototype.predictLumaH = function(leftMb) {
        var leftYSb = Array(4);
        for (var row = 0; row < 4; row++) 
            leftYSb[row] = leftMb.ySubblocks[row][3];
        for (var row = 0; row < 4; row++) 
            for (var col = 0; col < 4; col++) {
                var sb = this.ySubblocks[row][col];
                var block = new Int32Array(16);
                for (var bRow = 0; bRow < 4; bRow++) 
                    for (var bCol = 0; bCol < 4; bCol++) {
                        block[bRow * 4 + bCol] = leftYSb[row].val != null ? leftYSb[row].val[bRow * 4 + 3] : 129;
                    }
                sb._predict = block;
            }
    };
    prototype.predictLumaTM = function(above, left, aboveLeft) {
        var leftYSb;
        var aboveYSb = Array(4);
        leftYSb = Array(4);
        for (var col = 0; col < 4; col++) 
            aboveYSb[col] = above.ySubblocks[3][col];
        for (var row = 0; row < 4; row++) 
            leftYSb[row] = left.ySubblocks[row][3];
        for (var row = 0; row < 4; row++) 
            for (var pRow = 0; pRow < 4; pRow++) 
                for (var col = 0; col < 4; col++) {
                    if (this.ySubblocks[row][col].val == null) 
                        this.ySubblocks[row][col].val = new Int32Array(16);
                    for (var pCol = 0; pCol < 4; pCol++) {
                        var pred = leftYSb[row].val[pRow * 4 + 3] + aboveYSb[col].val[3 * 4 + pCol] - aboveLeft;
                        this.ySubblocks[row][col].val[pRow * 4 + pCol] = VP8Util.QuantizationParams.clip255(pred);
                    }
                }
    };
    prototype.predictLumaV = function(above) {
        var aboveYSb = Array(4);
        for (var col = 0; col < 4; col++) 
            aboveYSb[col] = above.ySubblocks[3][col];
        for (var row = 0; row < 4; row++) {
            for (var col = 0; col < 4; col++) {
                var sb = this.ySubblocks[row][col];
                var block = new Int32Array(16);
                for (var j = 0; j < 4; j++) 
                    for (var i = 0; i < 4; i++) {
                        block[j * 4 + i] = aboveYSb[col].val != null ? aboveYSb[col].val[3 * 4 + i] : 127;
                    }
                sb._predict = block;
            }
        }
    };
    prototype.getBottomSubblock = function(x, plane) {
        if (plane == VP8Util.PLANE.Y1) {
            return this.ySubblocks[3][x];
        } else if (plane == VP8Util.PLANE.U) {
            return this.uSubblocks[1][x];
        } else if (plane == VP8Util.PLANE.V) {
            return this.vSubblocks[1][x];
        } else if (plane == VP8Util.PLANE.Y2) {
            return this.y2;
        }
        return null;
    };
    prototype.getRightSubBlock = function(y, plane) {
        if (plane == VP8Util.PLANE.Y1) {
            return this.ySubblocks[y][3];
        } else if (plane == VP8Util.PLANE.U) {
            return this.uSubblocks[y][1];
        } else if (plane == VP8Util.PLANE.V) {
            return this.vSubblocks[y][1];
        } else if (plane == VP8Util.PLANE.Y2) {
            return this.y2;
        }
        return null;
    };
    prototype.decodeMacroBlock = function(mbs, tockenDecoder, coefProbs) {
        if (this.skipCoeff > 0) {
            this.skipFilter = this.lumaMode != VP8Util.SubblockConstants.B_PRED;
        } else if (this.lumaMode != VP8Util.SubblockConstants.B_PRED) 
            this.decodeMacroBlockTokens(true, mbs, tockenDecoder, coefProbs);
         else 
            this.decodeMacroBlockTokens(false, mbs, tockenDecoder, coefProbs);
    };
    prototype.decodeMacroBlockTokens = function(withY2, mbs, decoder, coefProbs) {
        this.skipFilter = false;
        if (withY2) {
            this.skipFilter = this.skipFilter | this.decodePlaneTokens(1, VP8Util.PLANE.Y2, false, mbs, decoder, coefProbs);
        }
        this.skipFilter = this.skipFilter | this.decodePlaneTokens(4, VP8Util.PLANE.Y1, withY2, mbs, decoder, coefProbs);
        this.skipFilter = this.skipFilter | this.decodePlaneTokens(2, VP8Util.PLANE.U, false, mbs, decoder, coefProbs);
        this.skipFilter = this.skipFilter | this.decodePlaneTokens(2, VP8Util.PLANE.V, false, mbs, decoder, coefProbs);
        this.skipFilter = !this.skipFilter;
    };
    prototype.decodePlaneTokens = function(dimentions, plane, withY2, mbs, decoder, coefProbs) {
        var r = false;
        for (var row = 0; row < dimentions; row++) {
            for (var col = 0; col < dimentions; col++) {
                var lc = 0;
                var sb = null;
                if (VP8Util.PLANE.Y1.equals(plane)) {
                    sb = this.ySubblocks[row][col];
                } else if (VP8Util.PLANE.U.equals(plane)) {
                    sb = this.uSubblocks[row][col];
                } else if (VP8Util.PLANE.V.equals(plane)) {
                    sb = this.vSubblocks[row][col];
                } else if (VP8Util.PLANE.Y2.equals(plane)) {
                    sb = this.y2;
                }
                var l = sb.getLeft(plane, mbs);
                var a = sb.getAbove(plane, mbs);
                lc = (l.someValuePresent ? 1 : 0) + (a.someValuePresent ? 1 : 0);
                sb.decodeSubBlock(decoder, coefProbs, lc, VP8Util.planeToType(plane, withY2), withY2);
                r = r | sb.someValuePresent;
            }
        }
        return r;
    };
    constructor.Subblock = function(self, row, col, plane) {
        this.self = self;
        this.row = row;
        this.col = col;
        this.plane = plane;
        this.tokens = new Int32Array(16);
    };
    constructor.Subblock = stjs.extend(constructor.Subblock, null, [], function(constructor, prototype) {
        prototype.val = null;
        prototype._predict = null;
        prototype.residue = null;
        prototype.col = 0;
        prototype.row = 0;
        prototype.plane = null;
        prototype.mode = 0;
        prototype.someValuePresent = false;
        prototype.tokens = null;
        prototype.self = null;
        prototype.predict = function(mbs) {
            var aboveSb = this.getAbove(this.plane, mbs);
            var leftSb = this.getLeft(this.plane, mbs);
            var above = new Int32Array(4);
            var left = new Int32Array(4);
            var aboveValues = aboveSb.val != null ? aboveSb.val : VP8Util.PRED_BLOCK_127;
            above[0] = aboveValues[0 + 4 * 3];
            above[1] = aboveValues[1 + 4 * 3];
            above[2] = aboveValues[2 + 4 * 3];
            above[3] = aboveValues[3 + 4 * 3];
            var leftValues = leftSb.val != null ? leftSb.val : VP8Util.pickDefaultPrediction(this.mode);
            left[0] = leftValues[3 + 4 * 0];
            left[1] = leftValues[3 + 4 * 1];
            left[2] = leftValues[3 + 4 * 2];
            left[3] = leftValues[3 + 4 * 3];
            var aboveLeftSb = aboveSb.getLeft(this.plane, mbs);
            var aboveLeft;
            if (leftSb.val == null && aboveSb.val == null) {
                aboveLeft = 127;
            } else if (aboveSb.val == null) {
                aboveLeft = 127;
            } else {
                aboveLeft = aboveLeftSb.val != null ? aboveLeftSb.val[3 + 4 * 3] : VP8Util.pickDefaultPrediction(this.mode)[3 + 4 * 3];
            }
            var ar = this.getAboveRightLowestRow(mbs);
            switch (this.mode) {
                case VP8Util.SubblockConstants.B_DC_PRED:
                    this._predict = VP8Util.predictDC(above, left);
                    break;
                case VP8Util.SubblockConstants.B_TM_PRED:
                    this._predict = VP8Util.predictTM(above, left, aboveLeft);
                    break;
                case VP8Util.SubblockConstants.B_VE_PRED:
                    this._predict = VP8Util.predictVE(above, aboveLeft, ar);
                    break;
                case VP8Util.SubblockConstants.B_HE_PRED:
                    this._predict = VP8Util.predictHE(left, aboveLeft);
                    break;
                case VP8Util.SubblockConstants.B_LD_PRED:
                    this._predict = VP8Util.predictLD(above, ar);
                    break;
                case VP8Util.SubblockConstants.B_RD_PRED:
                    this._predict = VP8Util.predictRD(above, left, aboveLeft);
                    break;
                case VP8Util.SubblockConstants.B_VR_PRED:
                    this._predict = VP8Util.predictVR(above, left, aboveLeft);
                    break;
                case VP8Util.SubblockConstants.B_VL_PRED:
                    this._predict = VP8Util.predictVL(above, ar);
                    break;
                case VP8Util.SubblockConstants.B_HD_PRED:
                    this._predict = VP8Util.predictHD(above, left, aboveLeft);
                    break;
                case VP8Util.SubblockConstants.B_HU_PRED:
                    this._predict = VP8Util.predictHU(left);
                    break;
                default:
                     throw new NotSupportedException("TODO: unknowwn mode: " + this.mode);
            }
        };
        prototype.reconstruct = function() {
            var aRow, aCol;
            var p = this.val != null ? this.val : this._predict;
            var dest = new Int32Array(16);
            for (aRow = 0; aRow < 4; aRow++) {
                for (aCol = 0; aCol < 4; aCol++) {
                    var a = VP8Util.QuantizationParams.clip255(this.residue[aRow * 4 + aCol] + p[aRow * 4 + aCol]);
                    dest[aRow * 4 + aCol] = a;
                }
            }
            this.val = dest;
        };
        prototype.getAbove = function(plane, mbs) {
            if (this.row > 0) 
                if (VP8Util.PLANE.Y1.equals(this.plane)) 
                    return this.self.ySubblocks[this.row - 1][this.col];
                 else if (VP8Util.PLANE.U.equals(this.plane)) 
                    return this.self.uSubblocks[this.row - 1][this.col];
                 else if (VP8Util.PLANE.V.equals(this.plane)) 
                    return this.self.vSubblocks[this.row - 1][this.col];
            var x = this.col;
            var mb2 = mbs[this.self.Rrow - 1][this.self.column];
            if (plane == VP8Util.PLANE.Y2) {
                 while (mb2.lumaMode == VP8Util.SubblockConstants.B_PRED)
                    mb2 = mbs[mb2.Rrow - 1][mb2.column];
            }
            return mb2.getBottomSubblock(x, plane);
        };
        prototype.getLeft = function(p, mbs) {
            if (this.col > 0) 
                if (VP8Util.PLANE.Y1.equals(this.plane)) 
                    return this.self.ySubblocks[this.row][this.col - 1];
                 else if (VP8Util.PLANE.U.equals(this.plane)) 
                    return this.self.uSubblocks[this.row][this.col - 1];
                 else if (VP8Util.PLANE.V.equals(this.plane)) 
                    return this.self.vSubblocks[this.row][this.col - 1];
            var y = this.row;
            var mb2 = mbs[this.self.Rrow][this.self.column - 1];
            if (p == VP8Util.PLANE.Y2) 
                 while (mb2.lumaMode == VP8Util.SubblockConstants.B_PRED)
                    mb2 = mbs[mb2.Rrow][mb2.column - 1];
            return mb2.getRightSubBlock(y, p);
        };
        prototype.getAboveRightLowestRow = function(mbs) {
            if (!VP8Util.PLANE.Y1.equals(this.plane)) 
                 throw new NotImplementedException("Decoder.getAboveRight: not implemented for Y2 and chroma planes");
            var aboveRightDistValues;
            if (this.row == 0 && this.col < 3) {
                var mb2 = mbs[this.self.Rrow - 1][this.self.column];
                var aboveRight = mb2.ySubblocks[3][this.col + 1];
                aboveRightDistValues = aboveRight.val;
            } else if (this.row > 0 && this.col < 3) {
                var aboveRight = this.self.ySubblocks[this.row - 1][this.col + 1];
                aboveRightDistValues = aboveRight.val;
            } else if (this.row == 0 && this.col == 3) {
                var aboveRightMb = mbs[this.self.Rrow - 1][this.self.column + 1];
                if (aboveRightMb.column < (mbs[0].length - 1)) {
                    var aboveRightSb = aboveRightMb.ySubblocks[3][0];
                    aboveRightDistValues = aboveRightSb.val;
                } else {
                    aboveRightDistValues = new Int32Array(16);
                    var fillVal = aboveRightMb.Rrow == 0 ? 127 : mbs[this.self.Rrow - 1][this.self.column].ySubblocks[3][3].val[3 * 4 + 3];
                    Arrays.fill(aboveRightDistValues, fillVal);
                }
            } else {
                var sb2 = this.self.ySubblocks[0][3];
                return sb2.getAboveRightLowestRow(mbs);
            }
            if (aboveRightDistValues == null) 
                aboveRightDistValues = VP8Util.PRED_BLOCK_127;
            var ar = new Int32Array(4);
            ar[0] = aboveRightDistValues[0 + 4 * 3];
            ar[1] = aboveRightDistValues[1 + 4 * 3];
            ar[2] = aboveRightDistValues[2 + 4 * 3];
            ar[3] = aboveRightDistValues[3 + 4 * 3];
            return ar;
        };
        prototype.decodeSubBlock = function(decoder, allProbs, ilc, type, withY2) {
            var startAt = 0;
            if (withY2) 
                startAt = 1;
            var lc = ilc;
            var count = 0;
            var v = 1;
            var skip = false;
            this.someValuePresent = false;
             while (!(v == VP8Util.SubblockConstants.dct_eob) && count + startAt < 16){
                var probs = allProbs[type][VP8Util.SubblockConstants.vp8CoefBands[count + startAt]][lc];
                if (!skip) {
                    v = decoder.readTree(VP8Util.SubblockConstants.vp8CoefTree, probs);
                } else {
                    v = decoder.readTreeSkip(VP8Util.SubblockConstants.vp8CoefTree, probs, 1);
                }
                var dv = this.decodeToken(decoder, v);
                lc = 0;
                skip = false;
                if (dv == 1 || dv == -1) 
                    lc = 1;
                 else if (dv > 1 || dv < -1) 
                    lc = 2;
                 else if (dv == VP8Util.SubblockConstants.DCT_0) 
                    skip = true;
                if (v != VP8Util.SubblockConstants.dct_eob) 
                    this.tokens[VP8Util.SubblockConstants.vp8defaultZigZag1d[count + startAt]] = dv;
                count++;
            }
            for (var x = 0; x < 16; x++) 
                if (this.tokens[x] != 0) 
                    this.someValuePresent = true;
        };
        prototype.decodeToken = function(decoder, initialValue) {
            var token = initialValue;
            if (initialValue == VP8Util.SubblockConstants.cat_5_6) {
                token = 5 + this.DCTextra(decoder, VP8Util.SubblockConstants.Pcat1);
            }
            if (initialValue == VP8Util.SubblockConstants.cat_7_10) {
                token = 7 + this.DCTextra(decoder, VP8Util.SubblockConstants.Pcat2);
            }
            if (initialValue == VP8Util.SubblockConstants.cat_11_18) {
                token = 11 + this.DCTextra(decoder, VP8Util.SubblockConstants.Pcat3);
            }
            if (initialValue == VP8Util.SubblockConstants.cat_19_34) {
                token = 19 + this.DCTextra(decoder, VP8Util.SubblockConstants.Pcat4);
            }
            if (initialValue == VP8Util.SubblockConstants.cat_35_66) {
                token = 35 + this.DCTextra(decoder, VP8Util.SubblockConstants.Pcat5);
            }
            if (initialValue == VP8Util.SubblockConstants.cat_67_2048) {
                token = 67 + this.DCTextra(decoder, VP8Util.SubblockConstants.Pcat6);
            }
            if (initialValue != VP8Util.SubblockConstants.DCT_0 && initialValue != VP8Util.SubblockConstants.dct_eob) {
                if (decoder.decodeBit() > 0) 
                    token = -token;
            }
            return token;
        };
        prototype.DCTextra = function(decoder, p) {
            var v = 0;
            var offset = 0;
            do {
                v += v + decoder.decodeBool(p[offset]);
                offset++;
            } while (p[offset] > 0);
            return v;
        };
        prototype.dequantSubblock = function(dc, ac, Dc) {
            var adjustedValues = new Int32Array(16);
            adjustedValues[0] = this.tokens[0] * dc;
            for (var i = 1; i < 16; i++) 
                adjustedValues[i] = this.tokens[i] * ac;
            if (Dc != null) 
                adjustedValues[0] = Dc;
            this.residue = VP8DCT.decodeDCT(adjustedValues);
        };
    }, {val: "Int32Array", _predict: "Int32Array", residue: "Int32Array", plane: {name: "Enum", arguments: ["VP8Util.PLANE"]}, tokens: "Int32Array", self: "Macroblock"}, {});
}, {ySubblocks: "Array", y2: "Macroblock.Subblock", uSubblocks: "Array", vSubblocks: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var VPXBitstream = function(tokenBinProbs, mbWidth) {
    this.dctNzLeft = [new Int32Array(4), new Int32Array(2), new Int32Array(2)];
    this.tokenBinProbs = tokenBinProbs;
    this.whtNzTop = new Int32Array(mbWidth);
    this.dctNzTop = [new Int32Array(mbWidth << 2), new Int32Array(mbWidth << 1), new Int32Array(mbWidth << 1)];
};
VPXBitstream = stjs.extend(VPXBitstream, null, [], function(constructor, prototype) {
    constructor.coeffBandMapping = new Int32Array([0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7]);
    prototype.tokenBinProbs = null;
    prototype.whtNzLeft = 0;
    prototype.whtNzTop = null;
    prototype.dctNzLeft = null;
    prototype.dctNzTop = null;
    prototype.encodeCoeffsWHT = function(bc, coeffs, mbX) {
        var nCoeff = this.fastCountCoeffWHT(coeffs);
        this.encodeCoeffs(bc, coeffs, 0, nCoeff, 1, (mbX == 0 || this.whtNzLeft <= 0 ? 0 : 1) + (this.whtNzTop[mbX] > 0 ? 1 : 0));
        this.whtNzLeft = nCoeff;
        this.whtNzTop[mbX] = nCoeff;
    };
    prototype.encodeCoeffsDCT15 = function(bc, coeffs, mbX, blkX, blkY) {
        var nCoeff = this.countCoeff(coeffs, 16);
        var blkAbsX = (mbX << 2) + blkX;
        this.encodeCoeffs(bc, coeffs, 1, nCoeff, 0, (blkAbsX == 0 || this.dctNzLeft[0][blkY] <= 0 ? 0 : 1) + (this.dctNzTop[0][blkAbsX] > 0 ? 1 : 0));
        this.dctNzLeft[0][blkY] = Math.max(nCoeff - 1, 0);
        this.dctNzTop[0][blkAbsX] = Math.max(nCoeff - 1, 0);
    };
    prototype.encodeCoeffsDCT16 = function(bc, coeffs, mbX, blkX, blkY) {
        var nCoeff = this.countCoeff(coeffs, 16);
        var blkAbsX = (mbX << 2) + blkX;
        this.encodeCoeffs(bc, coeffs, 0, nCoeff, 3, (blkAbsX == 0 || this.dctNzLeft[0][blkY] <= 0 ? 0 : 1) + (this.dctNzTop[0][blkAbsX] > 0 ? 1 : 0));
        this.dctNzLeft[0][blkY] = nCoeff;
        this.dctNzTop[0][blkAbsX] = nCoeff;
    };
    prototype.encodeCoeffsDCTUV = function(bc, coeffs, comp, mbX, blkX, blkY) {
        var nCoeff = this.countCoeff(coeffs, 16);
        var blkAbsX = (mbX << 1) + blkX;
        this.encodeCoeffs(bc, coeffs, 0, nCoeff, 2, (blkAbsX == 0 || this.dctNzLeft[comp][blkY] <= 0 ? 0 : 1) + (this.dctNzTop[comp][blkAbsX] > 0 ? 1 : 0));
        this.dctNzLeft[comp][blkY] = nCoeff;
        this.dctNzTop[comp][blkAbsX] = nCoeff;
    };
    /**
     *  Encodes DCT/WHT coefficients into the provided instance of a boolean
     *  encoder
     *  
     *  @param bc
     *  @param coeffs
     */
    prototype.encodeCoeffs = function(bc, coeffs, firstCoeff, nCoeff, blkType, ctx) {
        var prevZero = false;
        var i;
        for (i = firstCoeff; i < nCoeff; i++) {
            var probs = this.tokenBinProbs[blkType][VPXBitstream.coeffBandMapping[i]][ctx];
            var coeffAbs = MathUtil.abs(coeffs[i]);
            if (!prevZero) 
                bc.writeBit(probs[0], 1);
            if (coeffAbs == 0) {
                bc.writeBit(probs[1], 0);
                ctx = 0;
            } else {
                bc.writeBit(probs[1], 1);
                if (coeffAbs == 1) {
                    bc.writeBit(probs[2], 0);
                    ctx = 1;
                } else {
                    ctx = 2;
                    bc.writeBit(probs[2], 1);
                    if (coeffAbs <= 4) {
                        bc.writeBit(probs[3], 0);
                        if (coeffAbs == 2) 
                            bc.writeBit(probs[4], 0);
                         else {
                            bc.writeBit(probs[4], 1);
                            bc.writeBit(probs[5], coeffAbs - 3);
                        }
                    } else {
                        bc.writeBit(probs[3], 1);
                        if (coeffAbs <= 10) {
                            bc.writeBit(probs[6], 0);
                            if (coeffAbs <= 6) {
                                bc.writeBit(probs[7], 0);
                                bc.writeBit(159, coeffAbs - 5);
                            } else {
                                bc.writeBit(probs[7], 1);
                                var d = coeffAbs - 7;
                                bc.writeBit(165, d >> 1);
                                bc.writeBit(145, d & 1);
                            }
                        } else {
                            bc.writeBit(probs[6], 1);
                            if (coeffAbs <= 34) {
                                bc.writeBit(probs[8], 0);
                                if (coeffAbs <= 18) {
                                    bc.writeBit(probs[9], 0);
                                    VPXBitstream.writeCat3Ext(bc, coeffAbs);
                                } else {
                                    bc.writeBit(probs[9], 1);
                                    VPXBitstream.writeCat4Ext(bc, coeffAbs);
                                }
                            } else {
                                bc.writeBit(probs[8], 1);
                                if (coeffAbs <= 66) {
                                    bc.writeBit(probs[10], 0);
                                    VPXBitstream.writeCatExt(bc, coeffAbs, 35, VPXConst.probCoeffExtCat5);
                                } else {
                                    bc.writeBit(probs[10], 1);
                                    VPXBitstream.writeCatExt(bc, coeffAbs, 67, VPXConst.probCoeffExtCat6);
                                }
                            }
                        }
                    }
                }
                bc.writeBit(128, MathUtil.sign(coeffs[i]));
            }
            prevZero = coeffAbs == 0;
        }
        if (nCoeff < 16) {
            var probs = this.tokenBinProbs[blkType][VPXBitstream.coeffBandMapping[i]][ctx];
            bc.writeBit(probs[0], 0);
        }
    };
    constructor.writeCat3Ext = function(bc, coeff) {
        var d = coeff - 11;
        bc.writeBit(173, d >> 2);
        bc.writeBit(148, (d >> 1) & 1);
        bc.writeBit(140, d & 1);
    };
    constructor.writeCat4Ext = function(bc, coeff) {
        var d = coeff - 19;
        bc.writeBit(176, d >> 3);
        bc.writeBit(155, (d >> 2) & 1);
        bc.writeBit(140, (d >> 1) & 1);
        bc.writeBit(135, d & 1);
    };
    constructor.writeCatExt = function(bc, coeff, catOff, cat) {
        var d = coeff - catOff;
        for (var b = cat.length - 1, i = 0; b >= 0; b--) {
            bc.writeBit(cat[i++], (d >> b) & 1);
        }
    };
    /**
     *  Counts number of non-zero coefficients for a WHT block, with shortcut as
     *  most of them are likely to be non-zero
     *  
     *  @param coeffs
     *  @return
     */
    prototype.fastCountCoeffWHT = function(coeffs) {
        if (coeffs[15] != 0) 
            return 16;
         else 
            return this.countCoeff(coeffs, 15);
    };
    /**
     *  Counts number of non-zero coefficients
     *  
     *  @param coeffs
     *  @param nCoeff
     *  @return
     */
    prototype.countCoeff = function(coeffs, nCoeff) {
         while (nCoeff > 0){
            --nCoeff;
            if (coeffs[nCoeff] != 0) 
                return nCoeff + 1;
        }
        return nCoeff;
    };
}, {coeffBandMapping: "Int32Array", tokenBinProbs: "Array", whtNzTop: "Int32Array", dctNzLeft: "Array", dctNzTop: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Containes boolean encoder from VPx codecs
 *  
 *  @author The JCodec project
 *  
 */
var VPxBooleanEncoder = function(out) {
    this.out = out;
    this.lowvalue = 0;
    this.range = 255;
    this.count = -24;
};
VPxBooleanEncoder = stjs.extend(VPxBooleanEncoder, null, [], function(constructor, prototype) {
    prototype.out = null;
    prototype.lowvalue = 0;
    prototype.range = 0;
    prototype.count = 0;
    prototype.writeBit = function(prob, bb) {
        var split = 1 + (((this.range - 1) * prob) >> 8);
        if (bb != 0) {
            this.lowvalue += split;
            this.range -= split;
        } else {
            this.range = split;
        }
        var shift = VPXConst.vp8Norm[this.range];
        this.range <<= shift;
        this.count += shift;
        if (this.count >= 0) {
            var offset = shift - this.count;
            if (((this.lowvalue << (offset - 1)) & -2147483648) != 0) {
                var x = this.out.position() - 1;
                 while (x >= 0 && this.out.getAt(x) == -1){
                    this.out.putAt(x, (0 << 24 >> 24));
                    x--;
                }
                this.out.putAt(x, (((this.out.getAt(x) & 255) + 1) << 24 >> 24));
            }
            this.out.put(((this.lowvalue >> (24 - offset)) << 24 >> 24));
            this.lowvalue <<= offset;
            shift = this.count;
            this.lowvalue &= 16777215;
            this.count -= 8;
        }
        this.lowvalue <<= shift;
    };
    prototype.stop = function() {
        var i;
        for (i = 0; i < 32; i++) 
            this.writeBit(128, 0);
    };
    prototype.position = function() {
        return this.out.position() + ((this.count + 24) >> 3);
    };
}, {out: "ByteBuffer"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var VPXQuantizer = function() {};
VPXQuantizer = stjs.extend(VPXQuantizer, null, [], function(constructor, prototype) {
    prototype.y1_dc_delta_q = 0;
    prototype.uv_dc_delta_q = 0;
    prototype.uv_ac_delta_q = 0;
    prototype.y2_dc_delta_q = 0;
    prototype.y2_ac_delta_q = 0;
    prototype.quantizeY = function(coeffs, qp) {
        var factDC = MathUtil.clip(VPXConst.dc_qlookup[qp + this.y1_dc_delta_q], 8, 132);
        var invFactAC = MathUtil.clip(VPXConst.ac_qlookup[qp], 8, 132);
        this.quantize(coeffs, factDC, invFactAC);
    };
    prototype.quantizeUV = function(coeffs, qp) {
        var factDC = MathUtil.clip(VPXConst.dc_qlookup[qp + this.uv_dc_delta_q], 8, 132);
        var invFactAC = MathUtil.clip(VPXConst.ac_qlookup[qp + this.uv_ac_delta_q], 8, 132);
        this.quantize(coeffs, factDC, invFactAC);
    };
    prototype.quantizeY2 = function(coeffs, qp) {
        var factDC = MathUtil.clip(VPXConst.dc_qlookup[qp + this.y2_dc_delta_q] * 2, 8, 132);
        var invFactAC = MathUtil.clip(stjs.trunc(VPXConst.ac_qlookup[qp + this.y2_ac_delta_q] * 155 / 100), 8, 132);
        this.quantize(coeffs, factDC, invFactAC);
    };
    prototype.quantize = function(coeffs, factDC, factAC) {
        coeffs[0] = stjs.trunc(coeffs[0] / (factDC));
        for (var i = 1; i < 16; i++) 
            coeffs[i] = stjs.trunc(coeffs[i] / factAC);
    };
    prototype.dequantizeY = function(coeffs, qp) {
        var factDC = MathUtil.clip(VPXConst.dc_qlookup[qp + this.y1_dc_delta_q], 8, 132);
        var factAC = MathUtil.clip(VPXConst.ac_qlookup[qp], 8, 132);
        this.dequantize(coeffs, factDC, factAC);
    };
    prototype.dequantizeUV = function(coeffs, qp) {
        var factDC = MathUtil.clip(VPXConst.dc_qlookup[qp + this.uv_dc_delta_q], 8, 132);
        var factAC = MathUtil.clip(VPXConst.ac_qlookup[qp + this.uv_ac_delta_q], 8, 132);
        this.dequantize(coeffs, factDC, factAC);
    };
    prototype.dequantizeY2 = function(coeffs, qp) {
        var factDC = MathUtil.clip(VPXConst.dc_qlookup[qp + this.y2_dc_delta_q] * 2, 8, 132);
        var factAC = MathUtil.clip(stjs.trunc(VPXConst.ac_qlookup[qp + this.y2_ac_delta_q] * 155 / 100), 8, 132);
        this.dequantize(coeffs, factDC, factAC);
    };
    prototype.dequantize = function(coeffs, factDC, factAC) {
        coeffs[0] *= factDC;
        for (var i = 1; i < 16; i++) 
            coeffs[i] *= factAC;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  @author The JCodec project
 */
var Asserts = function() {};
Asserts = stjs.extend(Asserts, null, [], function(constructor, prototype) {
    constructor.assertEquals = function(expected, actual) {
        if (expected != actual) {
             throw new AssertionException("assert failed: " + expected + " != " + actual);
        }
    };
    constructor.assertInRange = function(message, low, up, val) {
        if (val < low || val > up) {
             throw new AssertionException(message);
        }
    };
    constructor.assertEpsilonEqualsInt = function(expected, actual, eps) {
        if (expected.length != actual.length) 
             throw new AssertionException("arrays of different size");
        for (var i = 0; i < expected.length; i++) {
            var e = expected[i];
            var a = actual[i];
            if (Math.abs(e - a) > eps) {
                 throw new AssertionException("array element out of expected diff range");
            }
        }
    };
    constructor.assertEpsilonEquals = function(expected, actual, eps) {
        if (expected.length != actual.length) 
             throw new AssertionException("arrays of different size");
        for (var i = 0; i < expected.length; i++) {
            var e = expected[i] & 255;
            var a = actual[i] & 255;
            if (Math.abs(e - a) > eps) {
                 throw new AssertionException("array element out of expected diff range: " + (Math.abs(e - a)));
            }
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  Binarization and context modeling using binary search tree
 *  
 *  @author The JCodec project
 *  
 */
var TreeBinarizer = function() {
    this.initContextModels();
};
TreeBinarizer = stjs.extend(TreeBinarizer, null, [], function(constructor, prototype) {
    prototype.models = null;
    prototype.initContextModels = function() {
        this.models = Array(255);
        for (var i = 0; i < 255; i++) {
            this.models[i] = new Context(0, 0);
        }
    };
    prototype.binarize = function(symbol, encoder) {
        var inverted = 0;
        var nextModel = 0;
        var levelOffset = 0;
        for (var i = 0; i < 8; ++i) {
            var bin = (symbol >> (7 - i)) & 1;
            encoder.encode(bin, this.models[nextModel]);
            inverted |= bin << i;
            levelOffset += (1 << i);
            nextModel = levelOffset + inverted;
        }
    };
    prototype.debinarize = function(decoder) {
        var symbol = 0;
        var inverted = 0;
        var nextModel = 0;
        var levelOffset = 0;
        for (var i = 0; i < 8; ++i) {
            var bin = decoder.decode(this.models[nextModel]);
            symbol |= (bin << (7 - i));
            inverted |= bin << i;
            levelOffset += (1 << i);
            nextModel = levelOffset + inverted;
        }
        return symbol;
    };
}, {models: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  Binary ariphmetic decoder
 *  
 *  Half-way to MQ Coder
 *  
 *  @author The JCodec project
 */
var MQDecoder = function(is) {
    this.is = is;
    this.range = 32768;
    this.value = 0;
    this.fetchByte();
    this.value <<= 8;
    this.fetchByte();
    this.value <<= (this.availableBits - 1);
    this.availableBits = 1;
};
MQDecoder = stjs.extend(MQDecoder, null, [], function(constructor, prototype) {
    prototype.range = 0;
    prototype.value = 0;
    prototype.availableBits = 0;
    prototype.lastByte = 0;
    prototype.decodedBytes = 0;
    prototype.is = null;
    prototype.decode = function(cm) {
        var rangeLps = MQConst.pLps[cm.getState()];
        var decoded;
        if (this.value > rangeLps) {
            this.range -= rangeLps;
            this.value -= rangeLps;
            if (this.range < 32768) {
                 while (this.range < 32768)
                    this.renormalize();
                cm.setState(MQConst.transitMPS[cm.getState()]);
            }
            decoded = cm.getMps();
        } else {
            this.range = rangeLps;
             while (this.range < 32768)
                this.renormalize();
            if (MQConst.mpsSwitch[cm.getState()] != 0) 
                cm.setMps(1 - cm.getMps());
            cm.setState(MQConst.transitLPS[cm.getState()]);
            decoded = 1 - cm.getMps();
        }
        return decoded;
    };
    prototype.fetchByte = function() {
        this.availableBits = 8;
        if (this.decodedBytes > 0 && this.lastByte == 255) {
            this.availableBits = 7;
        }
        this.lastByte = this.is.read();
        var shiftCarry = 8 - this.availableBits;
        this.value += (this.lastByte << shiftCarry);
        ++this.decodedBytes;
    };
    prototype.renormalize = function() {
        this.value <<= 1;
        this.range <<= 1;
        this.range &= 65535;
        --this.availableBits;
        if (this.availableBits == 0) 
            this.fetchByte();
    };
}, {is: "InputStream"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Binary ariphmetic encoder
 *  
 *  Half-way to MQ Coder
 *  
 *  @author The JCodec project
 *  
 */
var MQEncoder = function(out) {
    this.range = 32768;
    this.offset = 0;
    this.bitsToCode = 12;
    this.out = out;
};
MQEncoder = stjs.extend(MQEncoder, null, [], function(constructor, prototype) {
    constructor.CARRY_MASK = (1 << 27);
    prototype.range = 0;
    prototype.offset = 0;
    prototype.bitsToCode = 0;
    prototype.bytesOutput = 0;
    prototype.byteToGo = 0;
    prototype.out = null;
    /**
     *  Encodes one symbol either 0 or 1
     *  
     *  @param symbol
     *  @throws IOException
     */
    prototype.encode = function(symbol, cm) {
        var rangeLps = MQConst.pLps[cm.getState()];
        if (symbol == cm.getMps()) {
            this.range -= rangeLps;
            this.offset += rangeLps;
            if (this.range < 32768) {
                 while (this.range < 32768)
                    this.renormalize();
                cm.setState(MQConst.transitMPS[cm.getState()]);
            }
        } else {
            this.range = rangeLps;
             while (this.range < 32768)
                this.renormalize();
            if (MQConst.mpsSwitch[cm.getState()] != 0) 
                cm.setMps(1 - cm.getMps());
            cm.setState(MQConst.transitLPS[cm.getState()]);
        }
    };
    prototype.finish = function() {
        this.finalizeValue();
        this.offset <<= this.bitsToCode;
        var bitsToOutput = 12 - this.bitsToCode;
        this.outputByte();
        bitsToOutput -= this.bitsToCode;
        if (bitsToOutput > 0) {
            this.offset <<= this.bitsToCode;
            this.outputByte();
        }
        this.out.write(this.byteToGo);
    };
    prototype.finalizeValue = function() {
        var halfBit = this.offset & 32768;
        this.offset &= -65536;
        if (halfBit == 0) {
            this.offset |= 32768;
        } else {
            this.offset += 65536;
        }
    };
    prototype.renormalize = function() {
        this.offset <<= 1;
        this.range <<= 1;
        this.range &= 65535;
        --this.bitsToCode;
        if (this.bitsToCode == 0) 
            this.outputByte();
    };
    prototype.outputByte = function() {
        if (this.bytesOutput == 0) 
            this.outputByteNoStuffing();
         else {
            if (this.byteToGo == 255) 
                this.outputByteWithStuffing();
             else {
                if ((this.offset & MQEncoder.CARRY_MASK) != 0) {
                    ++this.byteToGo;
                    this.offset &= 134217727;
                    if (this.byteToGo == 255) 
                        this.outputByteWithStuffing();
                     else 
                        this.outputByteNoStuffing();
                } else 
                    this.outputByteNoStuffing();
            }
        }
    };
    prototype.outputByteWithStuffing = function() {
        this.bitsToCode = 7;
        if (this.bytesOutput > 0) {
            this.out.write(this.byteToGo);
        }
        this.byteToGo = (this.offset >> 20) & 255;
        this.offset &= 1048575;
        ++this.bytesOutput;
    };
    prototype.outputByteNoStuffing = function() {
        this.bitsToCode = 8;
        if (this.bytesOutput > 0) {
            this.out.write(this.byteToGo);
        }
        this.byteToGo = (this.offset >> 19) & 255;
        this.offset &= 524287;
        ++this.bytesOutput;
    };
}, {out: "OutputStream"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Writes blocks to form AAC frame
 *  
 *  @author The JCodec project
 *  
 */
var BlockWriter = function() {};
BlockWriter = stjs.extend(BlockWriter, null, [], function(constructor, prototype) {
    prototype.nextBlock = function(bits, block) {
        bits.writeNBit(block.getType().ordinal(), 3);
        if (block.getType() == BlockType.TYPE_END) 
            return;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Reads blocks of AAC frame
 *  
 *  @author The JCodec project
 *  
 */
var BlockReader = function() {};
BlockReader = stjs.extend(BlockReader, null, [], function(constructor, prototype) {
    prototype.nextBlock = function(bits) {
        var type = BlockType.values()[((stjs.trunc(bits.readNBit(3))) | 0)];
        if (type == BlockType.TYPE_END) 
            return null;
        var id = stjs.trunc(bits.readNBit(4));
        return null;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var BlockFil = function() {
    Block.call(this);
};
BlockFil = stjs.extend(BlockFil, Block, [], function(constructor, prototype) {
    prototype.parse = function(_in) {
        var num = stjs.trunc(_in.readNBit(4));
        if (num == 15) 
            num += stjs.trunc(_in.readNBit(8)) - 1;
        if (num > 0) 
            if (_in.skip(8 * num) != 8 * num) 
                 throw new RuntimeException("Overread");
    };
}, {type: {name: "Enum", arguments: ["BlockType"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Skip data_stream_element; reference: table 4.10.
 *  
 *  @author The JCodec project
 *  
 */
var BlockDSE = function() {
    Block.call(this);
};
BlockDSE = stjs.extend(BlockDSE, Block, [], function(constructor, prototype) {
    prototype.parse = function(_in) {
        var elemType = stjs.trunc(_in.readNBit(4));
        var byte_align = _in.read1Bit();
        var count = stjs.trunc(_in.readNBit(8));
        if (count == 255) 
            count += _in.readNBit(8);
        if (byte_align != 0) 
            _in.align();
        if (_in.skip(8 * count) != 8 * count) {
             throw new RuntimeException("Overread");
        }
    };
}, {type: {name: "Enum", arguments: ["BlockType"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  @author Alex Zhukov
 */
var FfmpegIntDct = function() {};
FfmpegIntDct = stjs.extend(FfmpegIntDct, null, [], function(constructor, prototype) {
    constructor.DCTSIZE = 8;
    constructor.DCTSIZE_6 = FfmpegIntDct.DCTSIZE * 6;
    constructor.DCTSIZE_5 = FfmpegIntDct.DCTSIZE * 5;
    constructor.DCTSIZE_4 = FfmpegIntDct.DCTSIZE * 4;
    constructor.DCTSIZE_3 = FfmpegIntDct.DCTSIZE * 3;
    constructor.DCTSIZE_2 = FfmpegIntDct.DCTSIZE * 2;
    constructor.DCTSIZE_1 = FfmpegIntDct.DCTSIZE * 1;
    constructor.DCTSIZE_7 = FfmpegIntDct.DCTSIZE * 7;
    constructor.DCTSIZE_0 = FfmpegIntDct.DCTSIZE * 0;
    constructor.PASS1_BITS = 2;
    constructor.CONST_BITS = 13;
    constructor.D1 = FfmpegIntDct.CONST_BITS - FfmpegIntDct.PASS1_BITS;
    constructor.D2 = FfmpegIntDct.CONST_BITS + FfmpegIntDct.PASS1_BITS + 3;
    constructor.ONEHALF_11 = (1 << (FfmpegIntDct.D1 - 1));
    constructor.ONEHALF_18 = (1 << (FfmpegIntDct.D2 - 1));
    prototype.decode = function(orig) {
        var data = ShortBuffer.wrap(orig);
        FfmpegIntDct.pass1(data);
        FfmpegIntDct.pass2(data);
        return orig;
    };
    constructor.advance = function(dataptr, size) {
        dataptr.position(dataptr.position() + size);
        return dataptr.slice();
    };
    constructor.FIX_0_211164243 = 1730;
    constructor.FIX_0_275899380 = 2260;
    constructor.FIX_0_298631336 = 2446;
    constructor.FIX_0_390180644 = 3196;
    constructor.FIX_0_509795579 = 4176;
    constructor.FIX_0_541196100 = 4433;
    constructor.FIX_0_601344887 = 4926;
    constructor.FIX_0_765366865 = 6270;
    constructor.FIX_0_785694958 = 6436;
    constructor.FIX_0_899976223 = 7373;
    constructor.FIX_1_061594337 = 8697;
    constructor.FIX_1_111140466 = 9102;
    constructor.FIX_1_175875602 = 9633;
    constructor.FIX_1_306562965 = 10703;
    constructor.FIX_1_387039845 = 11363;
    constructor.FIX_1_451774981 = 11893;
    constructor.FIX_1_501321110 = 12299;
    constructor.FIX_1_662939225 = 13623;
    constructor.FIX_1_847759065 = 15137;
    constructor.FIX_1_961570560 = 16069;
    constructor.FIX_2_053119869 = 16819;
    constructor.FIX_2_172734803 = 17799;
    constructor.FIX_2_562915447 = 20995;
    constructor.FIX_3_072711026 = 25172;
    constructor.pass1 = function(data) {
        var z1;
        var tmp2;
        var tmp3;
        var tmp0;
        var tmp1;
        var tmp10;
        var tmp13;
        var tmp11;
        var tmp12;
        var z2;
        var z3;
        var z4;
        var z5;
        var dataptr = data.duplicate();
        for (var rowctr = FfmpegIntDct.DCTSIZE - 1; rowctr >= 0; rowctr--) {
            var d0 = dataptr.get(0);
            var d2 = dataptr.get(1);
            var d4 = dataptr.get(2);
            var d6 = dataptr.get(3);
            var d1 = dataptr.get(4);
            var d3 = dataptr.get(5);
            var d5 = dataptr.get(6);
            var d7 = dataptr.get(7);
            if ((d1 | d2 | d3 | d4 | d5 | d6 | d7) == 0) {
                if (d0 != 0) {
                    var dcval = stjs.trunc((d0 << FfmpegIntDct.PASS1_BITS));
                    for (var i = 0; i < 8; i++) {
                        dataptr.put(i, ((dcval) << 16 >> 16));
                    }
                }
                dataptr = FfmpegIntDct.advance(dataptr, FfmpegIntDct.DCTSIZE);
                continue;
            }
            if (d6 != 0) {
                if (d2 != 0) {
                    z1 = FfmpegIntDct.MULTIPLY(d2 + d6, FfmpegIntDct.FIX_0_541196100);
                    tmp2 = z1 + FfmpegIntDct.MULTIPLY(-d6, FfmpegIntDct.FIX_1_847759065);
                    tmp3 = z1 + FfmpegIntDct.MULTIPLY(d2, FfmpegIntDct.FIX_0_765366865);
                    tmp0 = (d0 + d4) << FfmpegIntDct.CONST_BITS;
                    tmp1 = (d0 - d4) << FfmpegIntDct.CONST_BITS;
                    tmp10 = tmp0 + tmp3;
                    tmp13 = tmp0 - tmp3;
                    tmp11 = tmp1 + tmp2;
                    tmp12 = tmp1 - tmp2;
                } else {
                    tmp2 = FfmpegIntDct.MULTIPLY(-d6, FfmpegIntDct.FIX_1_306562965);
                    tmp3 = FfmpegIntDct.MULTIPLY(d6, FfmpegIntDct.FIX_0_541196100);
                    tmp0 = (d0 + d4) << FfmpegIntDct.CONST_BITS;
                    tmp1 = (d0 - d4) << FfmpegIntDct.CONST_BITS;
                    tmp10 = tmp0 + tmp3;
                    tmp13 = tmp0 - tmp3;
                    tmp11 = tmp1 + tmp2;
                    tmp12 = tmp1 - tmp2;
                }
            } else {
                if (d2 != 0) {
                    tmp2 = FfmpegIntDct.MULTIPLY(d2, FfmpegIntDct.FIX_0_541196100);
                    tmp3 = FfmpegIntDct.MULTIPLY(d2, FfmpegIntDct.FIX_1_306562965);
                    tmp0 = (d0 + d4) << FfmpegIntDct.CONST_BITS;
                    tmp1 = (d0 - d4) << FfmpegIntDct.CONST_BITS;
                    tmp10 = tmp0 + tmp3;
                    tmp13 = tmp0 - tmp3;
                    tmp11 = tmp1 + tmp2;
                    tmp12 = tmp1 - tmp2;
                } else {
                    tmp10 = tmp13 = (d0 + d4) << FfmpegIntDct.CONST_BITS;
                    tmp11 = tmp12 = (d0 - d4) << FfmpegIntDct.CONST_BITS;
                }
            }
            if (d7 != 0) {
                if (d5 != 0) {
                    if (d3 != 0) {
                        if (d1 != 0) {
                            z1 = d7 + d1;
                            z2 = d5 + d3;
                            z3 = d7 + d3;
                            z4 = d5 + d1;
                            z5 = FfmpegIntDct.MULTIPLY(z3 + z4, FfmpegIntDct.FIX_1_175875602);
                            tmp0 = FfmpegIntDct.MULTIPLY(d7, FfmpegIntDct.FIX_0_298631336);
                            tmp1 = FfmpegIntDct.MULTIPLY(d5, FfmpegIntDct.FIX_2_053119869);
                            tmp2 = FfmpegIntDct.MULTIPLY(d3, FfmpegIntDct.FIX_3_072711026);
                            tmp3 = FfmpegIntDct.MULTIPLY(d1, FfmpegIntDct.FIX_1_501321110);
                            z1 = FfmpegIntDct.MULTIPLY(-z1, FfmpegIntDct.FIX_0_899976223);
                            z2 = FfmpegIntDct.MULTIPLY(-z2, FfmpegIntDct.FIX_2_562915447);
                            z3 = FfmpegIntDct.MULTIPLY(-z3, FfmpegIntDct.FIX_1_961570560);
                            z4 = FfmpegIntDct.MULTIPLY(-z4, FfmpegIntDct.FIX_0_390180644);
                            z3 += z5;
                            z4 += z5;
                            tmp0 += z1 + z3;
                            tmp1 += z2 + z4;
                            tmp2 += z2 + z3;
                            tmp3 += z1 + z4;
                        } else {
                            z2 = d5 + d3;
                            z3 = d7 + d3;
                            z5 = FfmpegIntDct.MULTIPLY(z3 + d5, FfmpegIntDct.FIX_1_175875602);
                            tmp0 = FfmpegIntDct.MULTIPLY(d7, FfmpegIntDct.FIX_0_298631336);
                            tmp1 = FfmpegIntDct.MULTIPLY(d5, FfmpegIntDct.FIX_2_053119869);
                            tmp2 = FfmpegIntDct.MULTIPLY(d3, FfmpegIntDct.FIX_3_072711026);
                            z1 = FfmpegIntDct.MULTIPLY(-d7, FfmpegIntDct.FIX_0_899976223);
                            z2 = FfmpegIntDct.MULTIPLY(-z2, FfmpegIntDct.FIX_2_562915447);
                            z3 = FfmpegIntDct.MULTIPLY(-z3, FfmpegIntDct.FIX_1_961570560);
                            z4 = FfmpegIntDct.MULTIPLY(-d5, FfmpegIntDct.FIX_0_390180644);
                            z3 += z5;
                            z4 += z5;
                            tmp0 += z1 + z3;
                            tmp1 += z2 + z4;
                            tmp2 += z2 + z3;
                            tmp3 = z1 + z4;
                        }
                    } else {
                        if (d1 != 0) {
                            z1 = d7 + d1;
                            z4 = d5 + d1;
                            z5 = FfmpegIntDct.MULTIPLY(d7 + z4, FfmpegIntDct.FIX_1_175875602);
                            tmp0 = FfmpegIntDct.MULTIPLY(d7, FfmpegIntDct.FIX_0_298631336);
                            tmp1 = FfmpegIntDct.MULTIPLY(d5, FfmpegIntDct.FIX_2_053119869);
                            tmp3 = FfmpegIntDct.MULTIPLY(d1, FfmpegIntDct.FIX_1_501321110);
                            z1 = FfmpegIntDct.MULTIPLY(-z1, FfmpegIntDct.FIX_0_899976223);
                            z2 = FfmpegIntDct.MULTIPLY(-d5, FfmpegIntDct.FIX_2_562915447);
                            z3 = FfmpegIntDct.MULTIPLY(-d7, FfmpegIntDct.FIX_1_961570560);
                            z4 = FfmpegIntDct.MULTIPLY(-z4, FfmpegIntDct.FIX_0_390180644);
                            z3 += z5;
                            z4 += z5;
                            tmp0 += z1 + z3;
                            tmp1 += z2 + z4;
                            tmp2 = z2 + z3;
                            tmp3 += z1 + z4;
                        } else {
                            tmp0 = FfmpegIntDct.MULTIPLY(-d7, FfmpegIntDct.FIX_0_601344887);
                            z1 = FfmpegIntDct.MULTIPLY(-d7, FfmpegIntDct.FIX_0_899976223);
                            z3 = FfmpegIntDct.MULTIPLY(-d7, FfmpegIntDct.FIX_1_961570560);
                            tmp1 = FfmpegIntDct.MULTIPLY(-d5, FfmpegIntDct.FIX_0_509795579);
                            z2 = FfmpegIntDct.MULTIPLY(-d5, FfmpegIntDct.FIX_2_562915447);
                            z4 = FfmpegIntDct.MULTIPLY(-d5, FfmpegIntDct.FIX_0_390180644);
                            z5 = FfmpegIntDct.MULTIPLY(d5 + d7, FfmpegIntDct.FIX_1_175875602);
                            z3 += z5;
                            z4 += z5;
                            tmp0 += z3;
                            tmp1 += z4;
                            tmp2 = z2 + z3;
                            tmp3 = z1 + z4;
                        }
                    }
                } else {
                    if (d3 != 0) {
                        if (d1 != 0) {
                            z1 = d7 + d1;
                            z3 = d7 + d3;
                            z5 = FfmpegIntDct.MULTIPLY(z3 + d1, FfmpegIntDct.FIX_1_175875602);
                            tmp0 = FfmpegIntDct.MULTIPLY(d7, FfmpegIntDct.FIX_0_298631336);
                            tmp2 = FfmpegIntDct.MULTIPLY(d3, FfmpegIntDct.FIX_3_072711026);
                            tmp3 = FfmpegIntDct.MULTIPLY(d1, FfmpegIntDct.FIX_1_501321110);
                            z1 = FfmpegIntDct.MULTIPLY(-z1, FfmpegIntDct.FIX_0_899976223);
                            z2 = FfmpegIntDct.MULTIPLY(-d3, FfmpegIntDct.FIX_2_562915447);
                            z3 = FfmpegIntDct.MULTIPLY(-z3, FfmpegIntDct.FIX_1_961570560);
                            z4 = FfmpegIntDct.MULTIPLY(-d1, FfmpegIntDct.FIX_0_390180644);
                            z3 += z5;
                            z4 += z5;
                            tmp0 += z1 + z3;
                            tmp1 = z2 + z4;
                            tmp2 += z2 + z3;
                            tmp3 += z1 + z4;
                        } else {
                            z3 = d7 + d3;
                            tmp0 = FfmpegIntDct.MULTIPLY(-d7, FfmpegIntDct.FIX_0_601344887);
                            z1 = FfmpegIntDct.MULTIPLY(-d7, FfmpegIntDct.FIX_0_899976223);
                            tmp2 = FfmpegIntDct.MULTIPLY(d3, FfmpegIntDct.FIX_0_509795579);
                            z2 = FfmpegIntDct.MULTIPLY(-d3, FfmpegIntDct.FIX_2_562915447);
                            z5 = FfmpegIntDct.MULTIPLY(z3, FfmpegIntDct.FIX_1_175875602);
                            z3 = FfmpegIntDct.MULTIPLY(-z3, FfmpegIntDct.FIX_0_785694958);
                            tmp0 += z3;
                            tmp1 = z2 + z5;
                            tmp2 += z3;
                            tmp3 = z1 + z5;
                        }
                    } else {
                        if (d1 != 0) {
                            z1 = d7 + d1;
                            z5 = FfmpegIntDct.MULTIPLY(z1, FfmpegIntDct.FIX_1_175875602);
                            z1 = FfmpegIntDct.MULTIPLY(z1, FfmpegIntDct.FIX_0_275899380);
                            z3 = FfmpegIntDct.MULTIPLY(-d7, FfmpegIntDct.FIX_1_961570560);
                            tmp0 = FfmpegIntDct.MULTIPLY(-d7, FfmpegIntDct.FIX_1_662939225);
                            z4 = FfmpegIntDct.MULTIPLY(-d1, FfmpegIntDct.FIX_0_390180644);
                            tmp3 = FfmpegIntDct.MULTIPLY(d1, FfmpegIntDct.FIX_1_111140466);
                            tmp0 += z1;
                            tmp1 = z4 + z5;
                            tmp2 = z3 + z5;
                            tmp3 += z1;
                        } else {
                            tmp0 = FfmpegIntDct.MULTIPLY(-d7, FfmpegIntDct.FIX_1_387039845);
                            tmp1 = FfmpegIntDct.MULTIPLY(d7, FfmpegIntDct.FIX_1_175875602);
                            tmp2 = FfmpegIntDct.MULTIPLY(-d7, FfmpegIntDct.FIX_0_785694958);
                            tmp3 = FfmpegIntDct.MULTIPLY(d7, FfmpegIntDct.FIX_0_275899380);
                        }
                    }
                }
            } else {
                if (d5 != 0) {
                    if (d3 != 0) {
                        if (d1 != 0) {
                            z2 = d5 + d3;
                            z4 = d5 + d1;
                            z5 = FfmpegIntDct.MULTIPLY(d3 + z4, FfmpegIntDct.FIX_1_175875602);
                            tmp1 = FfmpegIntDct.MULTIPLY(d5, FfmpegIntDct.FIX_2_053119869);
                            tmp2 = FfmpegIntDct.MULTIPLY(d3, FfmpegIntDct.FIX_3_072711026);
                            tmp3 = FfmpegIntDct.MULTIPLY(d1, FfmpegIntDct.FIX_1_501321110);
                            z1 = FfmpegIntDct.MULTIPLY(-d1, FfmpegIntDct.FIX_0_899976223);
                            z2 = FfmpegIntDct.MULTIPLY(-z2, FfmpegIntDct.FIX_2_562915447);
                            z3 = FfmpegIntDct.MULTIPLY(-d3, FfmpegIntDct.FIX_1_961570560);
                            z4 = FfmpegIntDct.MULTIPLY(-z4, FfmpegIntDct.FIX_0_390180644);
                            z3 += z5;
                            z4 += z5;
                            tmp0 = z1 + z3;
                            tmp1 += z2 + z4;
                            tmp2 += z2 + z3;
                            tmp3 += z1 + z4;
                        } else {
                            z2 = d5 + d3;
                            z5 = FfmpegIntDct.MULTIPLY(z2, FfmpegIntDct.FIX_1_175875602);
                            tmp1 = FfmpegIntDct.MULTIPLY(d5, FfmpegIntDct.FIX_1_662939225);
                            z4 = FfmpegIntDct.MULTIPLY(-d5, FfmpegIntDct.FIX_0_390180644);
                            z2 = FfmpegIntDct.MULTIPLY(-z2, FfmpegIntDct.FIX_1_387039845);
                            tmp2 = FfmpegIntDct.MULTIPLY(d3, FfmpegIntDct.FIX_1_111140466);
                            z3 = FfmpegIntDct.MULTIPLY(-d3, FfmpegIntDct.FIX_1_961570560);
                            tmp0 = z3 + z5;
                            tmp1 += z2;
                            tmp2 += z2;
                            tmp3 = z4 + z5;
                        }
                    } else {
                        if (d1 != 0) {
                            z4 = d5 + d1;
                            z5 = FfmpegIntDct.MULTIPLY(z4, FfmpegIntDct.FIX_1_175875602);
                            z1 = FfmpegIntDct.MULTIPLY(-d1, FfmpegIntDct.FIX_0_899976223);
                            tmp3 = FfmpegIntDct.MULTIPLY(d1, FfmpegIntDct.FIX_0_601344887);
                            tmp1 = FfmpegIntDct.MULTIPLY(-d5, FfmpegIntDct.FIX_0_509795579);
                            z2 = FfmpegIntDct.MULTIPLY(-d5, FfmpegIntDct.FIX_2_562915447);
                            z4 = FfmpegIntDct.MULTIPLY(z4, FfmpegIntDct.FIX_0_785694958);
                            tmp0 = z1 + z5;
                            tmp1 += z4;
                            tmp2 = z2 + z5;
                            tmp3 += z4;
                        } else {
                            tmp0 = FfmpegIntDct.MULTIPLY(d5, FfmpegIntDct.FIX_1_175875602);
                            tmp1 = FfmpegIntDct.MULTIPLY(d5, FfmpegIntDct.FIX_0_275899380);
                            tmp2 = FfmpegIntDct.MULTIPLY(-d5, FfmpegIntDct.FIX_1_387039845);
                            tmp3 = FfmpegIntDct.MULTIPLY(d5, FfmpegIntDct.FIX_0_785694958);
                        }
                    }
                } else {
                    if (d3 != 0) {
                        if (d1 != 0) {
                            z5 = d1 + d3;
                            tmp3 = FfmpegIntDct.MULTIPLY(d1, FfmpegIntDct.FIX_0_211164243);
                            tmp2 = FfmpegIntDct.MULTIPLY(-d3, FfmpegIntDct.FIX_1_451774981);
                            z1 = FfmpegIntDct.MULTIPLY(d1, FfmpegIntDct.FIX_1_061594337);
                            z2 = FfmpegIntDct.MULTIPLY(-d3, FfmpegIntDct.FIX_2_172734803);
                            z4 = FfmpegIntDct.MULTIPLY(z5, FfmpegIntDct.FIX_0_785694958);
                            z5 = FfmpegIntDct.MULTIPLY(z5, FfmpegIntDct.FIX_1_175875602);
                            tmp0 = z1 - z4;
                            tmp1 = z2 + z4;
                            tmp2 += z5;
                            tmp3 += z5;
                        } else {
                            tmp0 = FfmpegIntDct.MULTIPLY(-d3, FfmpegIntDct.FIX_0_785694958);
                            tmp1 = FfmpegIntDct.MULTIPLY(-d3, FfmpegIntDct.FIX_1_387039845);
                            tmp2 = FfmpegIntDct.MULTIPLY(-d3, FfmpegIntDct.FIX_0_275899380);
                            tmp3 = FfmpegIntDct.MULTIPLY(d3, FfmpegIntDct.FIX_1_175875602);
                        }
                    } else {
                        if (d1 != 0) {
                            tmp0 = FfmpegIntDct.MULTIPLY(d1, FfmpegIntDct.FIX_0_275899380);
                            tmp1 = FfmpegIntDct.MULTIPLY(d1, FfmpegIntDct.FIX_0_785694958);
                            tmp2 = FfmpegIntDct.MULTIPLY(d1, FfmpegIntDct.FIX_1_175875602);
                            tmp3 = FfmpegIntDct.MULTIPLY(d1, FfmpegIntDct.FIX_1_387039845);
                        } else {
                            tmp0 = tmp1 = tmp2 = tmp3 = 0;
                        }
                    }
                }
            }
            dataptr.put(0, FfmpegIntDct.DESCALE11(tmp10 + tmp3));
            dataptr.put(7, FfmpegIntDct.DESCALE11(tmp10 - tmp3));
            dataptr.put(1, FfmpegIntDct.DESCALE11(tmp11 + tmp2));
            dataptr.put(6, FfmpegIntDct.DESCALE11(tmp11 - tmp2));
            dataptr.put(2, FfmpegIntDct.DESCALE11(tmp12 + tmp1));
            dataptr.put(5, FfmpegIntDct.DESCALE11(tmp12 - tmp1));
            dataptr.put(3, FfmpegIntDct.DESCALE11(tmp13 + tmp0));
            dataptr.put(4, FfmpegIntDct.DESCALE11(tmp13 - tmp0));
            dataptr = FfmpegIntDct.advance(dataptr, FfmpegIntDct.DCTSIZE);
        }
    };
    constructor.MULTIPLY = function(x, y) {
        return y * ((x) << 16 >> 16);
    };
    /**
     *  Perform the inverse DCT on one block of coefficients.
     */
    constructor.pass2 = function(data) {
        var tmp0, tmp1, tmp2, tmp3;
        var tmp10, tmp11, tmp12, tmp13;
        var z1, z2, z3, z4, z5;
        var d0, d1, d2, d3, d4, d5, d6, d7;
        var dataptr = data.duplicate();
        for (var rowctr = FfmpegIntDct.DCTSIZE - 1; rowctr >= 0; rowctr--) {
            d0 = dataptr.get(FfmpegIntDct.DCTSIZE_0);
            d1 = dataptr.get(FfmpegIntDct.DCTSIZE_1);
            d2 = dataptr.get(FfmpegIntDct.DCTSIZE_2);
            d3 = dataptr.get(FfmpegIntDct.DCTSIZE_3);
            d4 = dataptr.get(FfmpegIntDct.DCTSIZE_4);
            d5 = dataptr.get(FfmpegIntDct.DCTSIZE_5);
            d6 = dataptr.get(FfmpegIntDct.DCTSIZE_6);
            d7 = dataptr.get(FfmpegIntDct.DCTSIZE_7);
            if (d6 != 0) {
                if (d2 != 0) {
                    z1 = FfmpegIntDct.MULTIPLY(d2 + d6, FfmpegIntDct.FIX_0_541196100);
                    tmp2 = z1 + FfmpegIntDct.MULTIPLY(-d6, FfmpegIntDct.FIX_1_847759065);
                    tmp3 = z1 + FfmpegIntDct.MULTIPLY(d2, FfmpegIntDct.FIX_0_765366865);
                    tmp0 = (d0 + d4) << FfmpegIntDct.CONST_BITS;
                    tmp1 = (d0 - d4) << FfmpegIntDct.CONST_BITS;
                    tmp10 = tmp0 + tmp3;
                    tmp13 = tmp0 - tmp3;
                    tmp11 = tmp1 + tmp2;
                    tmp12 = tmp1 - tmp2;
                } else {
                    tmp2 = FfmpegIntDct.MULTIPLY(-d6, FfmpegIntDct.FIX_1_306562965);
                    tmp3 = FfmpegIntDct.MULTIPLY(d6, FfmpegIntDct.FIX_0_541196100);
                    tmp0 = (d0 + d4) << FfmpegIntDct.CONST_BITS;
                    tmp1 = (d0 - d4) << FfmpegIntDct.CONST_BITS;
                    tmp10 = tmp0 + tmp3;
                    tmp13 = tmp0 - tmp3;
                    tmp11 = tmp1 + tmp2;
                    tmp12 = tmp1 - tmp2;
                }
            } else {
                if (d2 != 0) {
                    tmp2 = FfmpegIntDct.MULTIPLY(d2, FfmpegIntDct.FIX_0_541196100);
                    tmp3 = FfmpegIntDct.MULTIPLY(d2, FfmpegIntDct.FIX_1_306562965);
                    tmp0 = (d0 + d4) << FfmpegIntDct.CONST_BITS;
                    tmp1 = (d0 - d4) << FfmpegIntDct.CONST_BITS;
                    tmp10 = tmp0 + tmp3;
                    tmp13 = tmp0 - tmp3;
                    tmp11 = tmp1 + tmp2;
                    tmp12 = tmp1 - tmp2;
                } else {
                    tmp10 = tmp13 = (d0 + d4) << FfmpegIntDct.CONST_BITS;
                    tmp11 = tmp12 = (d0 - d4) << FfmpegIntDct.CONST_BITS;
                }
            }
            if (d7 != 0) {
                if (d5 != 0) {
                    if (d3 != 0) {
                        if (d1 != 0) {
                            z1 = d7 + d1;
                            z2 = d5 + d3;
                            z3 = d7 + d3;
                            z4 = d5 + d1;
                            z5 = FfmpegIntDct.MULTIPLY(z3 + z4, FfmpegIntDct.FIX_1_175875602);
                            tmp0 = FfmpegIntDct.MULTIPLY(d7, FfmpegIntDct.FIX_0_298631336);
                            tmp1 = FfmpegIntDct.MULTIPLY(d5, FfmpegIntDct.FIX_2_053119869);
                            tmp2 = FfmpegIntDct.MULTIPLY(d3, FfmpegIntDct.FIX_3_072711026);
                            tmp3 = FfmpegIntDct.MULTIPLY(d1, FfmpegIntDct.FIX_1_501321110);
                            z1 = FfmpegIntDct.MULTIPLY(-z1, FfmpegIntDct.FIX_0_899976223);
                            z2 = FfmpegIntDct.MULTIPLY(-z2, FfmpegIntDct.FIX_2_562915447);
                            z3 = FfmpegIntDct.MULTIPLY(-z3, FfmpegIntDct.FIX_1_961570560);
                            z4 = FfmpegIntDct.MULTIPLY(-z4, FfmpegIntDct.FIX_0_390180644);
                            z3 += z5;
                            z4 += z5;
                            tmp0 += z1 + z3;
                            tmp1 += z2 + z4;
                            tmp2 += z2 + z3;
                            tmp3 += z1 + z4;
                        } else {
                            z1 = d7;
                            z2 = d5 + d3;
                            z3 = d7 + d3;
                            z5 = FfmpegIntDct.MULTIPLY(z3 + d5, FfmpegIntDct.FIX_1_175875602);
                            tmp0 = FfmpegIntDct.MULTIPLY(d7, FfmpegIntDct.FIX_0_298631336);
                            tmp1 = FfmpegIntDct.MULTIPLY(d5, FfmpegIntDct.FIX_2_053119869);
                            tmp2 = FfmpegIntDct.MULTIPLY(d3, FfmpegIntDct.FIX_3_072711026);
                            z1 = FfmpegIntDct.MULTIPLY(-d7, FfmpegIntDct.FIX_0_899976223);
                            z2 = FfmpegIntDct.MULTIPLY(-z2, FfmpegIntDct.FIX_2_562915447);
                            z3 = FfmpegIntDct.MULTIPLY(-z3, FfmpegIntDct.FIX_1_961570560);
                            z4 = FfmpegIntDct.MULTIPLY(-d5, FfmpegIntDct.FIX_0_390180644);
                            z3 += z5;
                            z4 += z5;
                            tmp0 += z1 + z3;
                            tmp1 += z2 + z4;
                            tmp2 += z2 + z3;
                            tmp3 = z1 + z4;
                        }
                    } else {
                        if (d1 != 0) {
                            z1 = d7 + d1;
                            z2 = d5;
                            z3 = d7;
                            z4 = d5 + d1;
                            z5 = FfmpegIntDct.MULTIPLY(z3 + z4, FfmpegIntDct.FIX_1_175875602);
                            tmp0 = FfmpegIntDct.MULTIPLY(d7, FfmpegIntDct.FIX_0_298631336);
                            tmp1 = FfmpegIntDct.MULTIPLY(d5, FfmpegIntDct.FIX_2_053119869);
                            tmp3 = FfmpegIntDct.MULTIPLY(d1, FfmpegIntDct.FIX_1_501321110);
                            z1 = FfmpegIntDct.MULTIPLY(-z1, FfmpegIntDct.FIX_0_899976223);
                            z2 = FfmpegIntDct.MULTIPLY(-d5, FfmpegIntDct.FIX_2_562915447);
                            z3 = FfmpegIntDct.MULTIPLY(-d7, FfmpegIntDct.FIX_1_961570560);
                            z4 = FfmpegIntDct.MULTIPLY(-z4, FfmpegIntDct.FIX_0_390180644);
                            z3 += z5;
                            z4 += z5;
                            tmp0 += z1 + z3;
                            tmp1 += z2 + z4;
                            tmp2 = z2 + z3;
                            tmp3 += z1 + z4;
                        } else {
                            tmp0 = FfmpegIntDct.MULTIPLY(-d7, FfmpegIntDct.FIX_0_601344887);
                            z1 = FfmpegIntDct.MULTIPLY(-d7, FfmpegIntDct.FIX_0_899976223);
                            z3 = FfmpegIntDct.MULTIPLY(-d7, FfmpegIntDct.FIX_1_961570560);
                            tmp1 = FfmpegIntDct.MULTIPLY(-d5, FfmpegIntDct.FIX_0_509795579);
                            z2 = FfmpegIntDct.MULTIPLY(-d5, FfmpegIntDct.FIX_2_562915447);
                            z4 = FfmpegIntDct.MULTIPLY(-d5, FfmpegIntDct.FIX_0_390180644);
                            z5 = FfmpegIntDct.MULTIPLY(d5 + d7, FfmpegIntDct.FIX_1_175875602);
                            z3 += z5;
                            z4 += z5;
                            tmp0 += z3;
                            tmp1 += z4;
                            tmp2 = z2 + z3;
                            tmp3 = z1 + z4;
                        }
                    }
                } else {
                    if (d3 != 0) {
                        if (d1 != 0) {
                            z1 = d7 + d1;
                            z3 = d7 + d3;
                            z5 = FfmpegIntDct.MULTIPLY(z3 + d1, FfmpegIntDct.FIX_1_175875602);
                            tmp0 = FfmpegIntDct.MULTIPLY(d7, FfmpegIntDct.FIX_0_298631336);
                            tmp2 = FfmpegIntDct.MULTIPLY(d3, FfmpegIntDct.FIX_3_072711026);
                            tmp3 = FfmpegIntDct.MULTIPLY(d1, FfmpegIntDct.FIX_1_501321110);
                            z1 = FfmpegIntDct.MULTIPLY(-z1, FfmpegIntDct.FIX_0_899976223);
                            z2 = FfmpegIntDct.MULTIPLY(-d3, FfmpegIntDct.FIX_2_562915447);
                            z3 = FfmpegIntDct.MULTIPLY(-z3, FfmpegIntDct.FIX_1_961570560);
                            z4 = FfmpegIntDct.MULTIPLY(-d1, FfmpegIntDct.FIX_0_390180644);
                            z3 += z5;
                            z4 += z5;
                            tmp0 += z1 + z3;
                            tmp1 = z2 + z4;
                            tmp2 += z2 + z3;
                            tmp3 += z1 + z4;
                        } else {
                            z3 = d7 + d3;
                            tmp0 = FfmpegIntDct.MULTIPLY(-d7, FfmpegIntDct.FIX_0_601344887);
                            z1 = FfmpegIntDct.MULTIPLY(-d7, FfmpegIntDct.FIX_0_899976223);
                            tmp2 = FfmpegIntDct.MULTIPLY(d3, FfmpegIntDct.FIX_0_509795579);
                            z2 = FfmpegIntDct.MULTIPLY(-d3, FfmpegIntDct.FIX_2_562915447);
                            z5 = FfmpegIntDct.MULTIPLY(z3, FfmpegIntDct.FIX_1_175875602);
                            z3 = FfmpegIntDct.MULTIPLY(-z3, FfmpegIntDct.FIX_0_785694958);
                            tmp0 += z3;
                            tmp1 = z2 + z5;
                            tmp2 += z3;
                            tmp3 = z1 + z5;
                        }
                    } else {
                        if (d1 != 0) {
                            z1 = d7 + d1;
                            z5 = FfmpegIntDct.MULTIPLY(z1, FfmpegIntDct.FIX_1_175875602);
                            z1 = FfmpegIntDct.MULTIPLY(z1, FfmpegIntDct.FIX_0_275899380);
                            z3 = FfmpegIntDct.MULTIPLY(-d7, FfmpegIntDct.FIX_1_961570560);
                            tmp0 = FfmpegIntDct.MULTIPLY(-d7, FfmpegIntDct.FIX_1_662939225);
                            z4 = FfmpegIntDct.MULTIPLY(-d1, FfmpegIntDct.FIX_0_390180644);
                            tmp3 = FfmpegIntDct.MULTIPLY(d1, FfmpegIntDct.FIX_1_111140466);
                            tmp0 += z1;
                            tmp1 = z4 + z5;
                            tmp2 = z3 + z5;
                            tmp3 += z1;
                        } else {
                            tmp0 = FfmpegIntDct.MULTIPLY(-d7, FfmpegIntDct.FIX_1_387039845);
                            tmp1 = FfmpegIntDct.MULTIPLY(d7, FfmpegIntDct.FIX_1_175875602);
                            tmp2 = FfmpegIntDct.MULTIPLY(-d7, FfmpegIntDct.FIX_0_785694958);
                            tmp3 = FfmpegIntDct.MULTIPLY(d7, FfmpegIntDct.FIX_0_275899380);
                        }
                    }
                }
            } else {
                if (d5 != 0) {
                    if (d3 != 0) {
                        if (d1 != 0) {
                            z2 = d5 + d3;
                            z4 = d5 + d1;
                            z5 = FfmpegIntDct.MULTIPLY(d3 + z4, FfmpegIntDct.FIX_1_175875602);
                            tmp1 = FfmpegIntDct.MULTIPLY(d5, FfmpegIntDct.FIX_2_053119869);
                            tmp2 = FfmpegIntDct.MULTIPLY(d3, FfmpegIntDct.FIX_3_072711026);
                            tmp3 = FfmpegIntDct.MULTIPLY(d1, FfmpegIntDct.FIX_1_501321110);
                            z1 = FfmpegIntDct.MULTIPLY(-d1, FfmpegIntDct.FIX_0_899976223);
                            z2 = FfmpegIntDct.MULTIPLY(-z2, FfmpegIntDct.FIX_2_562915447);
                            z3 = FfmpegIntDct.MULTIPLY(-d3, FfmpegIntDct.FIX_1_961570560);
                            z4 = FfmpegIntDct.MULTIPLY(-z4, FfmpegIntDct.FIX_0_390180644);
                            z3 += z5;
                            z4 += z5;
                            tmp0 = z1 + z3;
                            tmp1 += z2 + z4;
                            tmp2 += z2 + z3;
                            tmp3 += z1 + z4;
                        } else {
                            z2 = d5 + d3;
                            z5 = FfmpegIntDct.MULTIPLY(z2, FfmpegIntDct.FIX_1_175875602);
                            tmp1 = FfmpegIntDct.MULTIPLY(d5, FfmpegIntDct.FIX_1_662939225);
                            z4 = FfmpegIntDct.MULTIPLY(-d5, FfmpegIntDct.FIX_0_390180644);
                            z2 = FfmpegIntDct.MULTIPLY(-z2, FfmpegIntDct.FIX_1_387039845);
                            tmp2 = FfmpegIntDct.MULTIPLY(d3, FfmpegIntDct.FIX_1_111140466);
                            z3 = FfmpegIntDct.MULTIPLY(-d3, FfmpegIntDct.FIX_1_961570560);
                            tmp0 = z3 + z5;
                            tmp1 += z2;
                            tmp2 += z2;
                            tmp3 = z4 + z5;
                        }
                    } else {
                        if (d1 != 0) {
                            z4 = d5 + d1;
                            z5 = FfmpegIntDct.MULTIPLY(z4, FfmpegIntDct.FIX_1_175875602);
                            z1 = FfmpegIntDct.MULTIPLY(-d1, FfmpegIntDct.FIX_0_899976223);
                            tmp3 = FfmpegIntDct.MULTIPLY(d1, FfmpegIntDct.FIX_0_601344887);
                            tmp1 = FfmpegIntDct.MULTIPLY(-d5, FfmpegIntDct.FIX_0_509795579);
                            z2 = FfmpegIntDct.MULTIPLY(-d5, FfmpegIntDct.FIX_2_562915447);
                            z4 = FfmpegIntDct.MULTIPLY(z4, FfmpegIntDct.FIX_0_785694958);
                            tmp0 = z1 + z5;
                            tmp1 += z4;
                            tmp2 = z2 + z5;
                            tmp3 += z4;
                        } else {
                            tmp0 = FfmpegIntDct.MULTIPLY(d5, FfmpegIntDct.FIX_1_175875602);
                            tmp1 = FfmpegIntDct.MULTIPLY(d5, FfmpegIntDct.FIX_0_275899380);
                            tmp2 = FfmpegIntDct.MULTIPLY(-d5, FfmpegIntDct.FIX_1_387039845);
                            tmp3 = FfmpegIntDct.MULTIPLY(d5, FfmpegIntDct.FIX_0_785694958);
                        }
                    }
                } else {
                    if (d3 != 0) {
                        if (d1 != 0) {
                            z5 = d1 + d3;
                            tmp3 = FfmpegIntDct.MULTIPLY(d1, FfmpegIntDct.FIX_0_211164243);
                            tmp2 = FfmpegIntDct.MULTIPLY(-d3, FfmpegIntDct.FIX_1_451774981);
                            z1 = FfmpegIntDct.MULTIPLY(d1, FfmpegIntDct.FIX_1_061594337);
                            z2 = FfmpegIntDct.MULTIPLY(-d3, FfmpegIntDct.FIX_2_172734803);
                            z4 = FfmpegIntDct.MULTIPLY(z5, FfmpegIntDct.FIX_0_785694958);
                            z5 = FfmpegIntDct.MULTIPLY(z5, FfmpegIntDct.FIX_1_175875602);
                            tmp0 = z1 - z4;
                            tmp1 = z2 + z4;
                            tmp2 += z5;
                            tmp3 += z5;
                        } else {
                            tmp0 = FfmpegIntDct.MULTIPLY(-d3, FfmpegIntDct.FIX_0_785694958);
                            tmp1 = FfmpegIntDct.MULTIPLY(-d3, FfmpegIntDct.FIX_1_387039845);
                            tmp2 = FfmpegIntDct.MULTIPLY(-d3, FfmpegIntDct.FIX_0_275899380);
                            tmp3 = FfmpegIntDct.MULTIPLY(d3, FfmpegIntDct.FIX_1_175875602);
                        }
                    } else {
                        if (d1 != 0) {
                            tmp0 = FfmpegIntDct.MULTIPLY(d1, FfmpegIntDct.FIX_0_275899380);
                            tmp1 = FfmpegIntDct.MULTIPLY(d1, FfmpegIntDct.FIX_0_785694958);
                            tmp2 = FfmpegIntDct.MULTIPLY(d1, FfmpegIntDct.FIX_1_175875602);
                            tmp3 = FfmpegIntDct.MULTIPLY(d1, FfmpegIntDct.FIX_1_387039845);
                        } else {
                            tmp0 = tmp1 = tmp2 = tmp3 = 0;
                        }
                    }
                }
            }
            dataptr.put(FfmpegIntDct.DCTSIZE_0, FfmpegIntDct.DESCALE18(tmp10 + tmp3));
            dataptr.put(FfmpegIntDct.DCTSIZE_7, FfmpegIntDct.DESCALE18(tmp10 - tmp3));
            dataptr.put(FfmpegIntDct.DCTSIZE_1, FfmpegIntDct.DESCALE18(tmp11 + tmp2));
            dataptr.put(FfmpegIntDct.DCTSIZE_6, FfmpegIntDct.DESCALE18(tmp11 - tmp2));
            dataptr.put(FfmpegIntDct.DCTSIZE_2, FfmpegIntDct.DESCALE18(tmp12 + tmp1));
            dataptr.put(FfmpegIntDct.DCTSIZE_5, FfmpegIntDct.DESCALE18(tmp12 - tmp1));
            dataptr.put(FfmpegIntDct.DCTSIZE_3, FfmpegIntDct.DESCALE18(tmp13 + tmp0));
            dataptr.put(FfmpegIntDct.DCTSIZE_4, FfmpegIntDct.DESCALE18(tmp13 - tmp0));
            dataptr = FfmpegIntDct.advance(dataptr, 1);
        }
    };
    constructor.DESCALE = function(x, n) {
        return ((x) + (1 << ((n) - 1))) >> n;
    };
    constructor.DESCALE11 = function(x) {
        return ((((x + FfmpegIntDct.ONEHALF_11) >> 11)) << 16 >> 16);
    };
    constructor.DESCALE18 = function(x) {
        return ((((x + FfmpegIntDct.ONEHALF_18) >> 18)) << 16 >> 16);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Base for all filters that use convolution with kernel
 *  
 *  @author The JCodec project
 *  
 */
var ConvolutionFilter = function() {};
ConvolutionFilter = stjs.extend(ConvolutionFilter, null, [AudioFilter], function(constructor, prototype) {
    prototype.kernel = null;
    prototype.buildKernel = function() {};
    prototype.filter = function(_in, pos, out) {
        if (_in.length != 1) 
             throw new IllegalArgumentException(this.getClass().getName() + " filter is designed to work only on one input");
        if (out.length != 1) 
             throw new IllegalArgumentException(this.getClass().getName() + " filter is designed to work only on one output");
        var in0 = _in[0];
        var out0 = out[0];
        if (this.kernel == null) {
            this.kernel = this.buildKernel();
        }
        if (out0.remaining() < in0.remaining() - this.kernel.length) 
             throw new IllegalArgumentException("Output buffer is too small");
        if (in0.remaining() <= this.kernel.length) 
             throw new IllegalArgumentException("Input buffer should contain > kernel lenght (" + this.kernel.length + ") samples.");
        var halfKernel = stjs.trunc(this.kernel.length / 2);
        var i;
        for (i = in0.position() + halfKernel; i < in0.limit() - halfKernel; i++) {
            var result = 0;
            for (var j = 0; j < this.kernel.length; j++) {
                result += this.kernel[j] * in0.get(i + j - halfKernel);
            }
            out0.put(result);
        }
        in0.position(i - halfKernel);
    };
    prototype.getDelay = function() {
        if (this.kernel == null) {
            this.kernel = this.buildKernel();
        }
        return stjs.trunc(this.kernel.length / 2);
    };
    prototype.getNInputs = function() {
        return 1;
    };
    prototype.getNOutputs = function() {
        return 1;
    };
}, {kernel: "Float64Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Lanczos resampler
 *  
 *  @author The JCodec project
 *  
 */
var LanczosInterpolator = function(fromRate, toRate) {
    this.rateStep = fromRate / toRate;
};
LanczosInterpolator = stjs.extend(LanczosInterpolator, null, [AudioFilter], function(constructor, prototype) {
    constructor.lanczos = function(x, a) {
        return x < -a ? 0 : x > a ? 0 : (a * Math.sin(Math.PI * x) * Math.sin(Math.PI * x / a)) / (Math.PI * Math.PI * x * x);
    };
    prototype.rateStep = 0.0;
    prototype.filter = function(_in, pos, out) {
        if (_in.length != 1) 
             throw new IllegalArgumentException(this.getClass().getName() + " filter is designed to work only on one input");
        if (out.length != 1) 
             throw new IllegalArgumentException(this.getClass().getName() + " filter is designed to work only on one output");
        var in0 = _in[0];
        var out0 = out[0];
        if (out0.remaining() < (in0.remaining() - 6) / this.rateStep) 
             throw new IllegalArgumentException("Output buffer is too small");
        if (in0.remaining() <= 6) 
             throw new IllegalArgumentException("Input buffer should contain > 6 samples.");
        for (var outSample = 0; ; outSample++) {
            var inSample = 3 + outSample * this.rateStep + Math.ceil(pos[0] / this.rateStep) * this.rateStep - pos[0];
            var p0i = stjs.trunc(Math.floor(inSample));
            var q0i = stjs.trunc(Math.ceil(inSample));
            if (p0i >= in0.limit() - 3) {
                in0.position(p0i - 3);
                break;
            }
            var p0d = p0i - inSample;
            if (p0d < -0.001) {
                var q0d = q0i - inSample;
                var p0c = LanczosInterpolator.lanczos(p0d, 3);
                var q0c = LanczosInterpolator.lanczos(q0d, 3);
                var p1c = LanczosInterpolator.lanczos(p0d - 1, 3);
                var q1c = LanczosInterpolator.lanczos(q0d + 1, 3);
                var p2c = LanczosInterpolator.lanczos(p0d - 2, 3);
                var q2c = LanczosInterpolator.lanczos(q0d + 2, 3);
                var factor = 1.0 / (p0c + p1c + p2c + q0c + q1c + q2c);
                out0.put(((in0.get(q0i) * q0c + in0.get(q0i + 1) * q1c + in0.get(q0i + 2) * q2c + in0.get(p0i) * p0c + in0.get(p0i - 1) * p1c + in0.get(p0i - 2) * p2c) * factor));
            } else {
                out0.put(in0.get(p0i));
            }
        }
    };
    prototype.getDelay = function() {
        return 3;
    };
    prototype.getNInputs = function() {
        return 1;
    };
    prototype.getNOutputs = function() {
        return 1;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A class with many audio helper functions
 *  
 *  @author The JCodec project
 *  
 */
var Audio = function() {};
Audio = stjs.extend(Audio, null, [], function(constructor, prototype) {
    constructor.transfer = function(src, sink) {
        Audio.filterTransfer(src, new Audio.DummyFilter(1), sink);
    };
    constructor.filterTransfer = function(src, filter, sink) {
        if (filter.getNInputs() != 1) 
             throw new IllegalArgumentException("Audio filter has # inputs != 1");
        if (filter.getNOutputs() != 1) 
             throw new IllegalArgumentException("Audio filter has # outputs != 1");
        if (filter.getDelay() != 0) 
             throw new IllegalArgumentException("Audio filter has delay");
        var ins = [FloatBuffer.allocate(4096)];
        var outs = [FloatBuffer.allocate(8192)];
        var pos = Array(1);
         while (src.readFloat(ins[0]) != -1){
            ins[0].flip();
            filter.filter(ins, pos, outs);
            pos[0] += ins[0].position();
            Audio.rotate(ins[0]);
            outs[0].flip();
            sink.writeFloat(outs[0]);
            outs[0].clear();
        }
    };
    constructor.print = function(buf) {
        var dup = buf.duplicate();
         while (dup.hasRemaining())
            System.out.print(String.format("%.3f,", dup.get()));
        System.out.println();
    };
    constructor.rotate = function(buf) {
        var pos;
        for (pos = 0; buf.hasRemaining(); pos++) 
            buf.put(pos, buf.get());
        buf.position(pos);
        buf.limit(buf.capacity());
    };
    constructor.DummyFilter = function(nInputs) {
        this.nInputs = nInputs;
    };
    constructor.DummyFilter = stjs.extend(constructor.DummyFilter, null, [AudioFilter], function(constructor, prototype) {
        prototype.nInputs = 0;
        prototype.filter = function(_in, inPos, out) {
            for (var i = 0; i < _in.length; i++) {
                if (out[i].remaining() >= _in[i].remaining()) 
                    out[i].put(_in[i]);
                 else {
                    var duplicate = _in[i].duplicate();
                    duplicate.limit(_in[i].position() + out[i].remaining());
                    out[i].put(duplicate);
                }
            }
        };
        prototype.getDelay = function() {
            return 0;
        };
        prototype.getNInputs = function() {
            return this.nInputs;
        };
        prototype.getNOutputs = function() {
            return this.nInputs;
        };
    }, {}, {});
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A fork that splits the channels into different streams
 *  
 *  @author The JCodec project
 *  
 */
var ChannelSplit = function(format) {
    this.format = format;
};
ChannelSplit = stjs.extend(ChannelSplit, null, [AudioFilter], function(constructor, prototype) {
    prototype.format = null;
    prototype.filter = function(_in, inPos, out) {
        if (_in.length != 1) {
             throw new IllegalArgumentException("Channel split invoked on more then one input");
        }
        if (out.length != this.format.getChannels()) {
             throw new IllegalArgumentException("Channel split must be supplied with " + this.format.getChannels() + " output buffers to hold the channels.");
        }
        var in0 = _in[0];
        var outSampleCount = stjs.trunc(in0.remaining() / out.length);
        for (var i = 0; i < out.length; i++) {
            if (out[i].remaining() < outSampleCount) 
                 throw new IllegalArgumentException("Supplied buffer for " + i + "th channel doesn't have sufficient space to put the samples ( required: " + outSampleCount + ", actual: " + out[i].remaining() + ")");
        }
         while (in0.remaining() >= this.format.getChannels()){
            for (var i = 0; i < out.length; i++) {
                out[i].put(in0.get());
            }
        }
    };
    prototype.getDelay = function() {
        return 0;
    };
    prototype.getNInputs = function() {
        return 1;
    };
    prototype.getNOutputs = function() {
        return this.format.getChannels();
    };
}, {format: "AudioFormat"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  Reversable variable length coding
 *  Decodes scalefactors if error resilience is used.
 *  
 *  @author in-somnia
 */
var RVLC = function() {};
RVLC = stjs.extend(RVLC, null, [RVLCTables], function(constructor, prototype) {
    constructor.ESCAPE_FLAG = 7;
    prototype.decode = function(_in, ics, scaleFactors) {
        var bits = (ics.getInfo().isEightShortFrame()) ? 11 : 9;
        var sfConcealment = _in.readBool();
        var revGlobalGain = _in.readBits(8);
        var rvlcSFLen = _in.readBits(bits);
        var info = ics.getInfo();
        var windowGroupCount = info.getWindowGroupCount();
        var maxSFB = info.getMaxSFB();
        var sfbCB = [new Int32Array()];
        var sf = ics.getGlobalGain();
        var intensityPosition = 0;
        var noiseEnergy = sf - 90 - 256;
        var intensityUsed = false, noiseUsed = false;
        var sfb;
        for (var g = 0; g < windowGroupCount; g++) {
            for (sfb = 0; sfb < maxSFB; sfb++) {
                switch (sfbCB[g][sfb]) {
                    case HCB.ZERO_HCB:
                        scaleFactors[g][sfb] = 0;
                        break;
                    case HCB.INTENSITY_HCB:
                    case HCB.INTENSITY_HCB2:
                        if (!intensityUsed) 
                            intensityUsed = true;
                        intensityPosition += this.decodeHuffman(_in);
                        scaleFactors[g][sfb] = intensityPosition;
                        break;
                    case HCB.NOISE_HCB:
                        if (noiseUsed) {
                            noiseEnergy += this.decodeHuffman(_in);
                            scaleFactors[g][sfb] = noiseEnergy;
                        } else {
                            noiseUsed = true;
                            noiseEnergy = this.decodeHuffman(_in);
                        }
                        break;
                    default:
                        sf += this.decodeHuffman(_in);
                        scaleFactors[g][sfb] = sf;
                        break;
                }
            }
        }
        var lastIntensityPosition = 0;
        if (intensityUsed) 
            lastIntensityPosition = this.decodeHuffman(_in);
        noiseUsed = false;
        if (_in.readBool()) 
            this.decodeEscapes(_in, ics, scaleFactors);
    };
    prototype.decodeEscapes = function(_in, ics, scaleFactors) {
        var info = ics.getInfo();
        var windowGroupCount = info.getWindowGroupCount();
        var maxSFB = info.getMaxSFB();
        var sfbCB = [new Int32Array()];
        var escapesLen = _in.readBits(8);
        var noiseUsed = false;
        var sfb, val;
        for (var g = 0; g < windowGroupCount; g++) {
            for (sfb = 0; sfb < maxSFB; sfb++) {
                if (sfbCB[g][sfb] == HCB.NOISE_HCB && !noiseUsed) 
                    noiseUsed = true;
                 else if (Math.abs(sfbCB[g][sfb]) == RVLC.ESCAPE_FLAG) {
                    val = this.decodeHuffmanEscape(_in);
                    if (sfbCB[g][sfb] == -RVLC.ESCAPE_FLAG) 
                        scaleFactors[g][sfb] -= val;
                     else 
                        scaleFactors[g][sfb] += val;
                }
            }
        }
    };
    prototype.decodeHuffman = function(_in) {
        var off = 0;
        var i = RVLCTables.RVLC_BOOK[off][1];
        var cw = _in.readBits(i);
        var j;
         while ((cw != RVLCTables.RVLC_BOOK[off][2]) && (i < 10)){
            off++;
            j = RVLCTables.RVLC_BOOK[off][1] - i;
            i += j;
            cw <<= j;
            cw |= _in.readBits(j);
        }
        return RVLCTables.RVLC_BOOK[off][0];
    };
    prototype.decodeHuffmanEscape = function(_in) {
        var off = 0;
        var i = RVLCTables.ESCAPE_BOOK[off][1];
        var cw = _in.readBits(i);
        var j;
         while ((cw != RVLCTables.ESCAPE_BOOK[off][2]) && (i < 21)){
            off++;
            j = RVLCTables.ESCAPE_BOOK[off][1] - i;
            i += j;
            cw <<= j;
            cw |= _in.readBits(j);
        }
        return RVLCTables.ESCAPE_BOOK[off][0];
    };
}, {RVLC_BOOK: "Array", ESCAPE_BOOK: "Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 * 
 *  @author in-somnia
 */
var PSTables = function() {};
PSTables = stjs.extend(PSTables, null, [PSConstants], function(constructor, prototype) {
    constructor.nr_iid_par_tab = new Int32Array([10, 20, 34, 10, 20, 34, 0, 0]);
    constructor.nr_icc_par_tab = new Int32Array([10, 20, 34, 10, 20, 34, 0, 0]);
    constructor.nr_ipdopd_par_tab = new Int32Array([5, 11, 17, 5, 11, 17, 0, 0]);
    constructor.num_env_tab = [new Int32Array([0, 1, 2, 4]), new Int32Array([1, 2, 3, 4])];
    constructor.filter_a = new Float32Array([0.6514391, 0.5647181, 0.48954165]);
    constructor.group_border20 = new Int32Array([6, 7, 0, 1, 2, 3, 9, 8, 10, 11, 3, 4, 5, 6, 7, 8, 9, 11, 14, 18, 23, 35, 64]);
    constructor.group_border34 = new Int32Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32 - 27, 33 - 27, 34 - 27, 35 - 27, 36 - 27, 37 - 27, 38 - 27, 40 - 27, 42 - 27, 44 - 27, 46 - 27, 48 - 27, 51 - 27, 54 - 27, 57 - 27, 60 - 27, 64 - 27, 68 - 27, 91 - 27]);
    constructor.map_group2bk20 = new Int32Array([(PSConstants.NEGATE_IPD_MASK | 1), (PSConstants.NEGATE_IPD_MASK | 0), 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]);
    constructor.map_group2bk34 = new Int32Array([0, 1, 2, 3, 4, 5, 6, 6, 7, (PSConstants.NEGATE_IPD_MASK | 2), (PSConstants.NEGATE_IPD_MASK | 1), (PSConstants.NEGATE_IPD_MASK | 0), 10, 10, 4, 5, 6, 7, 8, 9, 10, 11, 12, 9, 14, 11, 12, 13, 14, 15, 16, 13, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33]);
    constructor.delay_length_d = new Int32Array([3, 4, 5]);
    constructor.p8_13_20 = new Float32Array([0.0074608293, 0.02270421, 0.04546866, 0.07266114, 0.098851085, 0.1179371, 0.125]);
    constructor.p2_13_20 = new Float32Array([0.0, 0.018994875, 0.0, -0.072931394, 0.0, 0.30596632, 0.5]);
    constructor.p12_13_34 = new Float32Array([0.0408118, 0.03812811, 0.051449083, 0.06399831, 0.07428314, 0.08100348, 0.083333336]);
    constructor.p8_13_34 = new Float32Array([0.015656756, 0.037527163, 0.054178912, 0.08417044, 0.10307344, 0.122224525, 0.125]);
    constructor.p4_13_34 = new Float32Array([-0.059082113, -0.048714984, 0.0, 0.07778724, 0.16486304, 0.23279856, 0.25]);
    constructor.Phi_Fract_Qmf = [new Float32Array([0.81814975, 0.57500523]), new Float32Array([-0.26387304, 0.9645574]), new Float32Array([-0.9969173, 0.0784591]), new Float32Array([-0.41151437, -0.9114033]), new Float32Array([0.7181263, -0.6959128]), new Float32Array([0.8980276, 0.43993917]), new Float32Array([-0.10973431, 0.993961]), new Float32Array([-0.9723699, 0.23344536]), new Float32Array([-0.5490228, -0.8358074]), new Float32Array([0.60042024, -0.79968464]), new Float32Array([0.955793, 0.29404032]), new Float32Array([0.047106452, 0.99888986]), new Float32Array([-0.9238795, 0.38268343]), new Float32Array([-0.6730125, -0.7396311]), new Float32Array([0.4679298, -0.88376564]), new Float32Array([0.9900237, 0.14090124]), new Float32Array([0.2027873, 0.97922283]), new Float32Array([-0.85264015, 0.52249855]), new Float32Array([-0.78043044, -0.62524265]), new Float32Array([0.32391742, -0.94608533]), new Float32Array([0.9998766, -0.015707318]), new Float32Array([0.35347486, 0.93544406]), new Float32Array([-0.76040596, 0.64944804]), new Float32Array([-0.86863154, -0.49545866]), new Float32Array([0.1719291, -0.9851093]), new Float32Array([0.9851093, -0.1719291]), new Float32Array([0.49545866, 0.86863154]), new Float32Array([-0.64944804, 0.76040596]), new Float32Array([-0.93544406, -0.35347486]), new Float32Array([0.015707318, -0.9998766]), new Float32Array([0.94608533, -0.32391742]), new Float32Array([0.62524265, 0.78043044]), new Float32Array([-0.52249855, 0.85264015]), new Float32Array([-0.97922283, -0.2027873]), new Float32Array([-0.14090124, -0.9900237]), new Float32Array([0.88376564, -0.4679298]), new Float32Array([0.7396311, 0.6730125]), new Float32Array([-0.38268343, 0.9238795]), new Float32Array([-0.99888986, -0.047106452]), new Float32Array([-0.29404032, -0.955793]), new Float32Array([0.79968464, -0.60042024]), new Float32Array([0.8358074, 0.5490228]), new Float32Array([-0.23344536, 0.9723699]), new Float32Array([-0.993961, 0.10973431]), new Float32Array([-0.43993917, -0.8980276]), new Float32Array([0.6959128, -0.7181263]), new Float32Array([0.9114033, 0.41151437]), new Float32Array([-0.0784591, 0.9969173]), new Float32Array([-0.9645574, 0.26387304]), new Float32Array([-0.57500523, -0.81814975]), new Float32Array([0.57500523, -0.81814975]), new Float32Array([0.9645574, 0.26387304]), new Float32Array([0.0784591, 0.9969173]), new Float32Array([-0.9114033, 0.41151437]), new Float32Array([-0.6959128, -0.7181263]), new Float32Array([0.43993917, -0.8980276]), new Float32Array([0.993961, 0.10973431]), new Float32Array([0.23344536, 0.9723699]), new Float32Array([-0.8358074, 0.5490228]), new Float32Array([-0.79968464, -0.60042024]), new Float32Array([0.29404032, -0.955793]), new Float32Array([0.99888986, -0.047106452]), new Float32Array([0.38268343, 0.9238795]), new Float32Array([-0.7396311, 0.6730125])];
    constructor.Phi_Fract_SubQmf20 = [new Float32Array([0.988295, 0.15255463]), new Float32Array([0.89629304, 0.4434623]), new Float32Array([0.72085357, 0.69308734]), new Float32Array([0.4783087, 0.87819177]), new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0]), new Float32Array([0.89629304, -0.4434623]), new Float32Array([0.988295, -0.15255463]), new Float32Array([-0.54244155, 0.84009355]), new Float32Array([0.039259817, 0.999229]), new Float32Array([-0.9268566, 0.37541556]), new Float32Array([-0.97417337, -0.22580127])];
    constructor.Phi_Fract_SubQmf34 = [new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0]), new Float32Array([0.33873793, 0.9408808]), new Float32Array([0.33873793, 0.9408808]), new Float32Array([0.33873793, 0.9408808]), new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0]), new Float32Array([-0.77051324, 0.637424]), new Float32Array([-0.77051324, 0.637424]), new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0]), new Float32Array([0.33873793, 0.9408808]), new Float32Array([0.33873793, 0.9408808]), new Float32Array([0.33873793, 0.9408808]), new Float32Array([0.33873793, 0.9408808]), new Float32Array([-0.77051324, 0.637424]), new Float32Array([-0.77051324, 0.637424]), new Float32Array([-0.86074203, -0.5090414]), new Float32Array([0.33873793, 0.9408808]), new Float32Array([0.18738131, -0.9822872]), new Float32Array([-0.77051324, 0.637424]), new Float32Array([-0.86074203, -0.5090414]), new Float32Array([-0.86074203, -0.5090414]), new Float32Array([0.18738131, -0.9822872]), new Float32Array([0.18738131, -0.9822872]), new Float32Array([0.98768836, -0.15643446]), new Float32Array([-0.86074203, -0.5090414])];
    constructor.Q_Fract_allpass_Qmf = [[new Float32Array([0.7804304, 0.62524265]), new Float32Array([0.38268343, 0.9238795]), new Float32Array([0.8550929, 0.5184748])], [new Float32Array([-0.4399392, 0.89802754]), new Float32Array([-0.9238795, -0.38268343]), new Float32Array([-0.06435815, 0.9979269])], [new Float32Array([-0.9723699, -0.23344542]), new Float32Array([0.9238795, -0.38268343]), new Float32Array([-0.91460717, 0.40434358])], [new Float32Array([0.015707396, -0.9998766]), new Float32Array([-0.38268343, 0.9238795]), new Float32Array([-0.7814115, -0.624016])], [new Float32Array([0.97922283, -0.20278719]), new Float32Array([-0.38268343, -0.9238795]), new Float32Array([0.19200818, -0.98139334])], [new Float32Array([0.41151425, 0.9114033]), new Float32Array([0.9238795, 0.38268343]), new Float32Array([0.95896834, -0.28351322])], [new Float32Array([-0.79968476, 0.6004201]), new Float32Array([-0.9238795, 0.38268343]), new Float32Array([0.69478387, 0.7192186])], [new Float32Array([-0.76040584, -0.64944816]), new Float32Array([0.38268343, -0.9238795]), new Float32Array([-0.31647703, 0.9486002])], [new Float32Array([0.46793, -0.8837655]), new Float32Array([0.38268343, 0.9238795]), new Float32Array([-0.9874414, 0.15798566])], [new Float32Array([0.96455735, 0.26387325]), new Float32Array([-0.9238795, -0.38268343]), new Float32Array([-0.59664506, -0.80250525])], [new Float32Array([-0.047106687, 0.99888986]), new Float32Array([0.9238795, -0.38268343]), new Float32Array([0.43570253, -0.9000907])], [new Float32Array([-0.9851094, 0.17192885]), new Float32Array([-0.38268343, 0.9238795]), new Float32Array([0.9995547, -0.029840596])], [new Float32Array([-0.3826832, -0.9238796]), new Float32Array([-0.38268343, -0.9238795]), new Float32Array([0.48862115, 0.87249607])], [new Float32Array([0.81814986, -0.575005]), new Float32Array([0.9238795, 0.38268343]), new Float32Array([-0.54770935, 0.83666867])], [new Float32Array([0.7396309, 0.67301273]), new Float32Array([-0.9238795, 0.38268343]), new Float32Array([-0.9951074, -0.098798856])], [new Float32Array([-0.49545896, 0.86863136]), new Float32Array([0.38268343, -0.9238795]), new Float32Array([-0.3725018, -0.9280315])], [new Float32Array([-0.9557929, -0.29404068]), new Float32Array([0.38268343, 0.9238795]), new Float32Array([0.6506418, -0.75938475])], [new Float32Array([0.07845949, -0.9969173]), new Float32Array([-0.9238795, -0.38268343]), new Float32Array([0.97417337, 0.22580142])], [new Float32Array([0.99002373, -0.14090082]), new Float32Array([0.9238795, -0.38268343]), new Float32Array([0.25021085, 0.9681914])], [new Float32Array([0.35347444, 0.9354442]), new Float32Array([-0.38268343, 0.9238795]), new Float32Array([-0.7427945, 0.6695195])], [new Float32Array([-0.8358076, 0.54902244]), new Float32Array([-0.38268343, -0.9238795]), new Float32Array([-0.9370993, -0.34906292])], [new Float32Array([-0.71812594, -0.69591314]), new Float32Array([0.9238795, 0.38268343]), new Float32Array([-0.12377448, -0.99231035])], [new Float32Array([0.522499, -0.8526399]), new Float32Array([-0.9238795, 0.38268343]), new Float32Array([0.82264066, -0.5685617])], [new Float32Array([0.9460852, 0.32391793]), new Float32Array([0.38268343, -0.9238795]), new Float32Array([0.8844995, 0.4665412])], [new Float32Array([-0.109734856, 0.9939609]), new Float32Array([0.38268343, 0.9238795]), new Float32Array([-0.004712592, 0.9999889])], [new Float32Array([-0.99396104, 0.10973374]), new Float32Array([-0.9238795, -0.38268343]), new Float32Array([-0.88885736, 0.458184])], [new Float32Array([-0.32391685, -0.9460856]), new Float32Array([0.9238795, -0.38268343]), new Float32Array([-0.81724536, -0.5762899])], [new Float32Array([0.8526405, -0.522498]), new Float32Array([-0.38268343, 0.9238795]), new Float32Array([0.13312158, -0.9910997])], [new Float32Array([0.69591236, 0.7181267]), new Float32Array([-0.38268343, -0.9238795]), new Float32Array([0.9403476, -0.3402152])], [new Float32Array([-0.5490234, 0.835807]), new Float32Array([0.9238795, 0.38268343]), new Float32Array([0.7364512, 0.67649066])], [new Float32Array([-0.93544376, -0.35347548]), new Float32Array([-0.9238795, 0.38268343]), new Float32Array([-0.25932503, 0.9657901])], [new Float32Array([0.14090194, -0.99002355]), new Float32Array([0.38268343, -0.9238795]), new Float32Array([-0.9762583, 0.21660973])], [new Float32Array([0.99691737, -0.07845837]), new Float32Array([0.38268343, 0.9238795]), new Float32Array([-0.6434556, -0.7654834])], [new Float32Array([0.2940396, 0.95579326]), new Float32Array([-0.9238795, -0.38268343]), new Float32Array([0.38123202, -0.9244794])], [new Float32Array([-0.8686319, 0.495458]), new Float32Array([0.9238795, -0.38268343]), new Float32Array([0.9959944, -0.0894155])], [new Float32Array([-0.6730119, -0.73963165]), new Float32Array([-0.38268343, 0.9238795]), new Float32Array([0.5397994, 0.8417937])], [new Float32Array([0.57500595, -0.81814927]), new Float32Array([-0.38268343, -0.9238795]), new Float32Array([-0.49682277, 0.86785203])], [new Float32Array([0.9238792, 0.3826842]), new Float32Array([0.9238795, 0.38268343]), new Float32Array([-0.999229, -0.039260153])], [new Float32Array([-0.17192996, 0.98510915]), new Float32Array([-0.9238795, 0.38268343]), new Float32Array([-0.42719975, -0.9041573])], [new Float32Array([-0.9988899, 0.047105566]), new Float32Array([0.38268343, -0.9238795]), new Float32Array([0.60418224, -0.79684615])], [new Float32Array([-0.26387218, -0.96455765]), new Float32Array([0.38268343, 0.9238795]), new Float32Array([0.9859085, 0.16728535])], [new Float32Array([0.88376606, -0.46792898]), new Float32Array([-0.9238795, -0.38268343]), new Float32Array([0.30752236, 0.9515409])], [new Float32Array([0.6494473, 0.7604066]), new Float32Array([0.9238795, -0.38268343]), new Float32Array([-0.7015317, 0.71263826])], [new Float32Array([-0.600421, 0.79968405]), new Float32Array([-0.38268343, 0.9238795]), new Float32Array([-0.9562536, -0.29253897])], [new Float32Array([-0.9114029, -0.41151527]), new Float32Array([-0.38268343, -0.9238795]), new Float32Array([-0.18274994, -0.9831594])], [new Float32Array([0.2027883, -0.9792226]), new Float32Array([0.9238795, 0.38268343]), new Float32Array([0.78725827, -0.6166234])], [new Float32Array([0.9998767, -0.015706273]), new Float32Array([-0.9238795, 0.38268343]), new Float32Array([0.9107556, 0.41294587])], [new Float32Array([0.23344433, 0.97237015]), new Float32Array([0.38268343, -0.9238795]), new Float32Array([0.054949753, 0.99848914])], [new Float32Array([-0.8980281, 0.4399382]), new Float32Array([0.38268343, 0.9238795]), new Float32Array([-0.8599416, 0.5103925])], [new Float32Array([-0.6252418, -0.7804311]), new Float32Array([-0.9238795, -0.38268343]), new Float32Array([-0.8501682, -0.5265111])], [new Float32Array([0.62524354, -0.7804297]), new Float32Array([0.9238795, -0.38268343]), new Float32Array([0.07376083, -0.99727595])], [new Float32Array([0.89802706, 0.4399402]), new Float32Array([-0.38268343, 0.9238795]), new Float32Array([0.9183775, -0.39570537])], [new Float32Array([-0.23344651, 0.9723697]), new Float32Array([-0.38268343, -0.9238795]), new Float32Array([0.77549547, 0.63135314])], [new Float32Array([-0.9998766, -0.01570852]), new Float32Array([0.9238795, 0.38268343]), new Float32Array([-0.20124936, 0.97954005])], [new Float32Array([-0.2027861, -0.9792231]), new Float32Array([-0.9238795, 0.38268343]), new Float32Array([-0.96159786, 0.27446228])], [new Float32Array([0.9114038, -0.4115132]), new Float32Array([0.38268343, -0.9238795]), new Float32Array([-0.68797433, -0.725735])], [new Float32Array([0.6004192, 0.7996854]), new Float32Array([0.38268343, 0.9238795]), new Float32Array([0.3254036, -0.94557524])], [new Float32Array([-0.64944905, 0.7604051]), new Float32Array([-0.9238795, -0.38268343]), new Float32Array([0.9888866, -0.14867193])], [new Float32Array([-0.88376504, -0.46793097]), new Float32Array([0.9238795, -0.38268343]), new Float32Array([0.5890549, 0.808093])], [new Float32Array([0.26387435, -0.96455705]), new Float32Array([-0.38268343, 0.9238795]), new Float32Array([-0.4441666, 0.89594424])], [new Float32Array([0.9988898, 0.04710781]), new Float32Array([-0.38268343, -0.9238795]), new Float32Array([-0.9997915, 0.020418389])], [new Float32Array([0.17192774, 0.98510957]), new Float32Array([0.9238795, 0.38268343]), new Float32Array([-0.4803761, -0.8770626])], [new Float32Array([-0.92388004, 0.38268214]), new Float32Array([-0.9238795, 0.38268343]), new Float32Array([0.5555707, -0.8314693])], [new Float32Array([-0.5750041, -0.8181505]), new Float32Array([0.38268343, -0.9238795]), new Float32Array([0.99413204, 0.10817343])]];
    constructor.Q_Fract_allpass_SubQmf20 = [[new Float32Array([0.9857769, 0.16805927]), new Float32Array([0.95694035, 0.29028466]), new Float32Array([0.99073005, 0.13584526])], [new Float32Array([0.87440807, 0.4851912]), new Float32Array([0.6343933, 0.77301043]), new Float32Array([0.9175986, 0.39750826])], [new Float32Array([0.6642524, 0.74750835]), new Float32Array([0.09801714, 0.9951847]), new Float32Array([0.7767339, 0.62982893])], [new Float32Array([0.3790524, 0.9253752]), new Float32Array([-0.47139674, 0.8819213]), new Float32Array([0.578534, 0.8156583])], [new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0])], [new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0])], [new Float32Array([0.87440807, -0.4851912]), new Float32Array([0.6343933, -0.77301043]), new Float32Array([0.9175986, -0.39750826])], [new Float32Array([0.9857769, -0.16805927]), new Float32Array([0.95694035, -0.29028466]), new Float32Array([0.99073005, -0.13584526])], [new Float32Array([-0.71263856, 0.7015314]), new Float32Array([-0.55557024, -0.8314696]), new Float32Array([-0.33059677, 0.9437721])], [new Float32Array([-0.117537424, 0.99306846]), new Float32Array([-0.98078525, 0.19509032]), new Float32Array([0.20663111, 0.97841895])], [new Float32Array([-0.99479216, 0.101924405]), new Float32Array([0.55557024, -0.8314696]), new Float32Array([-0.772013, 0.6356067])], [new Float32Array([-0.8400935, -0.5424416]), new Float32Array([0.98078525, 0.19509032]), new Float32Array([-0.98968893, 0.14323351])]];
    constructor.Q_Fract_allpass_SubQmf34 = [[new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0])], [new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0])], [new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0])], [new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0])], [new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0])], [new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0])], [new Float32Array([0.21814322, 0.97591674]), new Float32Array([-0.70710677, 0.70710677]), new Float32Array([0.46236774, 0.88668823])], [new Float32Array([0.21814322, 0.97591674]), new Float32Array([-0.70710677, 0.70710677]), new Float32Array([0.46236774, 0.88668823])], [new Float32Array([0.21814322, 0.97591674]), new Float32Array([-0.70710677, 0.70710677]), new Float32Array([0.46236774, 0.88668823])], [new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0])], [new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0])], [new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0])], [new Float32Array([-0.90482706, 0.42577925]), new Float32Array([-0.0, -1.0]), new Float32Array([-0.57243216, 0.8199521])], [new Float32Array([-0.90482706, 0.42577925]), new Float32Array([-0.0, -1.0]), new Float32Array([-0.57243216, 0.8199521])], [new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0])], [new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0])], [new Float32Array([0.21814322, 0.97591674]), new Float32Array([-0.70710677, 0.70710677]), new Float32Array([0.46236774, 0.88668823])], [new Float32Array([0.21814322, 0.97591674]), new Float32Array([-0.70710677, 0.70710677]), new Float32Array([0.46236774, 0.88668823])], [new Float32Array([0.21814322, 0.97591674]), new Float32Array([-0.70710677, 0.70710677]), new Float32Array([0.46236774, 0.88668823])], [new Float32Array([0.21814322, 0.97591674]), new Float32Array([-0.70710677, 0.70710677]), new Float32Array([0.46236774, 0.88668823])], [new Float32Array([-0.90482706, 0.42577925]), new Float32Array([-0.0, -1.0]), new Float32Array([-0.57243216, 0.8199521])], [new Float32Array([-0.90482706, 0.42577925]), new Float32Array([-0.0, -1.0]), new Float32Array([-0.57243216, 0.8199521])], [new Float32Array([-0.612907, -0.79015505]), new Float32Array([0.70710677, 0.70710677]), new Float32Array([-0.991716, -0.12844945])], [new Float32Array([0.21814322, 0.97591674]), new Float32Array([-0.70710677, 0.70710677]), new Float32Array([0.46236774, 0.88668823])], [new Float32Array([0.63742405, -0.7705132]), new Float32Array([-1.0, 0.0]), new Float32Array([-0.34464288, -0.9387339])], [new Float32Array([-0.90482706, 0.42577925]), new Float32Array([-0.0, -1.0]), new Float32Array([-0.57243216, 0.8199521])], [new Float32Array([-0.612907, -0.79015505]), new Float32Array([0.70710677, 0.70710677]), new Float32Array([-0.991716, -0.12844945])], [new Float32Array([-0.612907, -0.79015505]), new Float32Array([0.70710677, 0.70710677]), new Float32Array([-0.991716, -0.12844945])], [new Float32Array([0.63742405, -0.7705132]), new Float32Array([-1.0, 0.0]), new Float32Array([-0.34464288, -0.9387339])], [new Float32Array([0.63742405, -0.7705132]), new Float32Array([-1.0, 0.0]), new Float32Array([-0.34464288, -0.9387339])], [new Float32Array([0.89100647, 0.4539906]), new Float32Array([0.70710677, -0.70710677]), new Float32Array([0.67301255, -0.73963106])], [new Float32Array([-0.612907, -0.79015505]), new Float32Array([0.70710677, 0.70710677]), new Float32Array([-0.991716, -0.12844945])]];
    constructor.cos_alphas = new Float32Array([1.0, 0.98412395, 0.95947385, 0.8946843, 0.8269341, 0.70710677, 0.4533211, 0.0]);
    constructor.sin_alphas = new Float32Array([0.0, 0.17748243, 0.28179777, 0.446699, 0.56229883, 0.70710677, 0.8913473, 1.0]);
    constructor.cos_betas_normal = [new Float32Array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]), new Float32Array([1.0, 0.9995872, 0.9989419, 0.99722046, 0.9953791, 0.99201125, 0.98434085, 0.9681727]), new Float32Array([1.0, 0.9984498, 0.99602795, 0.98957384, 0.98268145, 0.9701058, 0.94160986, 0.8822106]), new Float32Array([1.0, 0.9959399, 0.9896038, 0.97275895, 0.95483553, 0.922307, 0.849435, 0.70130056]), new Float32Array([1.0, 0.9932417, 0.9827072, 0.9547731, 0.9251669, 0.8717462, 0.7535521, 0.51988274]), new Float32Array([1.0, 0.99020684, 0.9749614, 0.9346539, 0.8921231, 0.8158851, 0.64959645, 0.33133706]), new Float32Array([1.0, 0.9880511, 0.96946704, 0.9204348, 0.8688623, 0.77685165, 0.5782162, 0.20699704]), new Float32Array([1.0, 0.9858997, 0.9639899, 0.90630347, 0.84582144, 0.7384262, 0.5089811, 0.09054659])];
    constructor.sin_betas_normal = [new Float32Array([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]), new Float32Array([0.0, -0.028731337, -0.045989715, -0.07450743, -0.09602333, -0.12614924, -0.17627579, -0.25028294]), new Float32Array([0.0, -0.05566011, -0.08904127, -0.14402643, -0.18530284, -0.24268231, -0.33670583, -0.47085506]), new Float32Array([0.0, -0.09002074, -0.14382043, -0.23181884, -0.29713482, -0.38645792, -0.52769333, -0.7128657]), new Float32Array([0.0, -0.116063975, -0.18516637, -0.2973354, -0.37956056, -0.48995778, -0.6573882, -0.8542376]), new Float32Array([0.0, -0.1396083, -0.22237422, -0.35555896, -0.45179233, -0.57821405, -0.76027924, -0.94351244]), new Float32Array([0.0, -0.15412669, -0.2452217, -0.39089614, -0.49505386, -0.6296836, -0.8158836, -0.9783416]), new Float32Array([0.0, -0.16733736, -0.2659389, -0.4226275, -0.5334661, -0.6743343, -0.8607777, -0.9958922])];
    constructor.cos_betas_fine = [new Float32Array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]), new Float32Array([1.0, 0.9995872, 0.9989419, 0.99722046, 0.9953791, 0.99201125, 0.98434085, 0.9681727]), new Float32Array([1.0, 0.9984498, 0.99602795, 0.98957384, 0.98268145, 0.9701058, 0.94160986, 0.8822106]), new Float32Array([1.0, 0.9968361, 0.9918968, 0.97875404, 0.96475154, 0.9392903, 0.8820167, 0.76453257]), new Float32Array([1.0, 0.9950263, 0.9872675, 0.9666585, 0.94475883, 0.9050918, 0.8165997, 0.6383825]), new Float32Array([1.0, 0.9932417, 0.9827072, 0.9547731, 0.9251669, 0.8717462, 0.7535521, 0.51988274]), new Float32Array([1.0, 0.9908828, 0.9766856, 0.93912494, 0.89945316, 0.82823527, 0.6723983, 0.37194732]), new Float32Array([1.0, 0.98902404, 0.971946, 0.92684484, 0.87933886, 0.7944023, 0.6101812, 0.2621501]), new Float32Array([1.0, 0.987635, 0.96840733, 0.91769737, 0.864393, 0.7693796, 0.56467205, 0.18388996]), new Float32Array([1.0, 0.9866247, 0.965835, 0.9110591, 0.8535668, 0.75131655, 0.5320915, 0.1289531]), new Float32Array([1.0, 0.9858997, 0.9639899, 0.90630347, 0.84582144, 0.7384262, 0.5089811, 0.09054659]), new Float32Array([1.0, 0.9851246, 0.962018, 0.9012266, 0.8375623, 0.7247108, 0.48452044, 0.0504115]), new Float32Array([1.0, 0.984687, 0.96090525, 0.89836395, 0.8329098, 0.71699834, 0.47082454, 0.028173251]), new Float32Array([1.0, 0.9844406, 0.96027887, 0.8967534, 0.83029366, 0.7126658, 0.46314928, 0.015785115]), new Float32Array([1.0, 0.98430204, 0.95992655, 0.89584774, 0.8288229, 0.7102316, 0.45884293, 0.008857806]), new Float32Array([1.0, 0.98422414, 0.9597284, 0.89533854, 0.82799613, 0.70886356, 0.45642468, 0.0049751354])];
    constructor.sin_betas_fine = [new Float32Array([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]), new Float32Array([0.0, -0.028731337, -0.045989715, -0.07450743, -0.09602333, -0.12614924, -0.17627579, -0.25028294]), new Float32Array([0.0, -0.05566011, -0.08904127, -0.14402643, -0.18530284, -0.24268231, -0.33670583, -0.47085506]), new Float32Array([0.0, -0.07948406, -0.12704612, -0.20503783, -0.26316252, -0.3431235, -0.47121814, -0.64458513]), new Float32Array([0.0, -0.099612646, -0.15906878, -0.25606918, -0.3277662, -0.42521614, -0.57720435, -0.7697193]), new Float32Array([0.0, -0.116063975, -0.18516637, -0.2973354, -0.37956056, -0.48995778, -0.6573882, -0.8542376]), new Float32Array([0.0, -0.13472667, -0.21467477, -0.34357587, -0.43701714, -0.5603805, -0.7401895, -0.9282538]), new Float32Array([0.0, -0.14775485, -0.23520416, -0.37544465, -0.4761966, -0.6073919, -0.7922619, -0.9650271]), new Float32Array([0.0, -0.15677059, -0.24937364, -0.39728013, -0.5028168, -0.63879186, -0.82531536, -0.9829468]), new Float32Array([0.0, -0.16300823, -0.2591579, -0.41227582, -0.5209834, -0.65994203, -0.84668684, -0.9916507]), new Float32Array([0.0, -0.16733736, -0.2659389, -0.4226275, -0.5334661, -0.6743343, -0.8607777, -0.9958922]), new Float32Array([0.0, -0.17184179, -0.27298594, -0.43334824, -0.5463418, -0.6890532, -0.87477994, -0.9987285]), new Float32Array([0.0, -0.1743317, -0.27687746, -0.43925187, -0.5534087, -0.6970749, -0.8822269, -0.99960303]), new Float32Array([0.0, -0.1757175, -0.27904215, -0.44253063, -0.5573262, -0.7015037, -0.8862803, -0.9998754]), new Float32Array([0.0, -0.17649214, -0.28025177, -0.44436115, -0.559511, -0.7039681, -0.8885174, -0.9999608]), new Float32Array([0.0, -0.17692624, -0.28092957, -0.4453863, -0.5607338, -0.70534563, -0.88976204, -0.9999876])];
    constructor.sincos_alphas_B_normal = [new Float32Array([0.05614541, 0.052638587, 0.047293734, 0.033841062, 0.020726107, 0.0028205635, 0.0028205635, 0.0028205635]), new Float32Array([0.12490651, 0.11736977, 0.10578883, 0.07619851, 0.04687327, 0.0063956105, 0.0063956105, 0.0063956105]), new Float32Array([0.19566931, 0.18460901, 0.16736451, 0.122062184, 0.07573625, 0.010388263, 0.010388263, 0.010388263]), new Float32Array([0.30151132, 0.28705257, 0.2637739, 0.19845739, 0.12607498, 0.017560013, 0.017560013, 0.017560013]), new Float32Array([0.40784496, 0.39298525, 0.36805892, 0.29110292, 0.19345124, 0.027868671, 0.027868671, 0.027868671]), new Float32Array([0.53361714, 0.5226638, 0.5033653, 0.43491626, 0.32246822, 0.052199904, 0.052199904, 0.052199904]), new Float32Array([0.62198323, 0.6161847, 0.6057251, 0.5654343, 0.482615, 0.10580447, 0.10580447, 0.10580447]), new Float32Array([0.70710677, 0.70710677, 0.70710677, 0.70710677, 0.70710677, 0.70710677, 0.70710677, 0.70710677]), new Float32Array([0.78303057, 0.78760165, 0.79567397, 0.82479334, 0.8758326, 0.994387, 0.994387, 0.994387]), new Float32Array([0.8457262, 0.8525389, 0.86407375, 0.9004709, 0.9465803, 0.99863666, 0.99863666, 0.99863666]), new Float32Array([0.9130512, 0.91954476, 0.9298024, 0.95669174, 0.98110986, 0.9996116, 0.9996116, 0.9996116]), new Float32Array([0.9534626, 0.9579148, 0.9645845, 0.9801095, 0.9920207, 0.9998458, 0.9998458, 0.9998458]), new Float32Array([0.9806699, 0.98281205, 0.9858951, 0.9925224, 0.9971279, 0.99994606, 0.99994606, 0.99994606]), new Float32Array([0.9921685, 0.99308825, 0.99438864, 0.99709266, 0.99890083, 0.99997956, 0.99997956, 0.99997956]), new Float32Array([0.9984226, 0.99861366, 0.99888104, 0.9994272, 0.9997852, 0.999996, 0.999996, 0.999996])];
    constructor.sincos_alphas_B_fine = [new Float32Array([0.0031622157, 0.0029630181, 0.0026599893, 0.0019002703, 0.0011626042, 1.580278E-4, 1.580278E-4, 1.580278E-4]), new Float32Array([0.0056232675, 0.0052689826, 0.0047302824, 0.0033791757, 0.0020674015, 2.81171E-4, 2.81171E-4, 2.81171E-4]), new Float32Array([0.009999422, 0.0093696695, 0.008411742, 0.0060093794, 0.003676601, 5.000392E-4, 5.000392E-4, 5.000392E-4]), new Float32Array([0.01777992, 0.01666071, 0.014958138, 0.010687581, 0.0065392544, 8.893767E-4, 8.893767E-4, 8.893767E-4]), new Float32Array([0.03160697, 0.029621158, 0.02659873, 0.019011382, 0.011634997, 0.0015826974, 0.0015826974, 0.0015826974]), new Float32Array([0.05614541, 0.052638587, 0.047293734, 0.033841062, 0.020726107, 0.0028205635, 0.0028205635, 0.0028205635]), new Float32Array([0.07918341, 0.07427981, 0.06679073, 0.047870528, 0.029350074, 0.0039966754, 0.0039966754, 0.0039966754]), new Float32Array([0.11150212, 0.1047142, 0.094305314, 0.067812055, 0.041666914, 0.0056813215, 0.0056813215, 0.0056813215]), new Float32Array([0.1565355, 0.14732584, 0.1330924, 0.09632822, 0.05945091, 0.008127795, 0.008127795, 0.008127795]), new Float32Array([0.21846437, 0.20645796, 0.18762654, 0.13757442, 0.08568967, 0.0117817335, 0.0117817335, 0.0117817335]), new Float32Array([0.30151132, 0.28705257, 0.2637739, 0.19845739, 0.12607498, 0.017560013, 0.017560013, 0.017560013]), new Float32Array([0.36987412, 0.35477272, 0.32982522, 0.2556266, 0.166599, 0.023634454, 0.023634454, 0.023634454]), new Float32Array([0.4480624, 0.433941, 0.4098614, 0.33227092, 0.22667848, 0.033409413, 0.033409413, 0.033409413]), new Float32Array([0.53361714, 0.5226638, 0.5033653, 0.43491626, 0.32246822, 0.052199904, 0.052199904, 0.052199904]), new Float32Array([0.62198323, 0.6161847, 0.6057251, 0.5654343, 0.482615, 0.10580447, 0.10580447, 0.10580447]), new Float32Array([0.70710677, 0.70710677, 0.70710677, 0.70710677, 0.70710677, 0.70710677, 0.70710677, 0.70710677]), new Float32Array([0.78303057, 0.78760165, 0.79567397, 0.82479334, 0.8758326, 0.994387, 0.994387, 0.994387]), new Float32Array([0.8457262, 0.8525389, 0.86407375, 0.9004709, 0.9465803, 0.99863666, 0.99863666, 0.99863666]), new Float32Array([0.8940022, 0.90094125, 0.91214776, 0.94318396, 0.97396964, 0.99944174, 0.99944174, 0.99944174]), new Float32Array([0.92908186, 0.93495256, 0.944042, 0.9667756, 0.98602474, 0.9997207, 0.9997207, 0.9997207]), new Float32Array([0.9534626, 0.9579148, 0.9645845, 0.9801095, 0.9920207, 0.9998458, 0.9998458, 0.9998458]), new Float32Array([0.9758449, 0.9784555, 0.98224044, 0.99049145, 0.99632186, 0.9999306, 0.9999306, 0.9999306]), new Float32Array([0.9876723, 0.989088, 0.99110365, 0.99534965, 0.99823123, 0.999967, 0.999967, 0.999967]), new Float32Array([0.99376416, 0.99450237, 0.9955433, 0.9976981, 0.99913156, 0.99998385, 0.99998385, 0.99998385]), new Float32Array([0.9968601, 0.99723744, 0.99776703, 0.99885356, 0.9995692, 0.999992, 0.999992, 0.999992]), new Float32Array([0.9984226, 0.99861366, 0.99888104, 0.9994272, 0.9997852, 0.999996, 0.999996, 0.999996]), new Float32Array([0.9995004, 0.9995612, 0.9996462, 0.9998193, 0.9999323, 0.99999875, 0.99999875, 0.99999875]), new Float32Array([0.9998419, 0.9998612, 0.9998881, 0.9999429, 0.9999786, 0.9999996, 0.9999996, 0.9999996]), new Float32Array([0.99995, 0.99995613, 0.9999646, 0.99998194, 0.99999326, 0.9999999, 0.9999999, 0.9999999]), new Float32Array([0.9999842, 0.9999861, 0.9999888, 0.9999943, 0.99999785, 0.99999994, 0.99999994, 0.99999994]), new Float32Array([0.999995, 0.9999956, 0.9999965, 0.9999982, 0.99999934, 1.0, 1.0, 1.0])];
    constructor.cos_gammas_normal = [new Float32Array([1.0, 0.98412395, 0.95947385, 0.8946843, 0.8269341, 0.72456884, 0.72456884, 0.72456884]), new Float32Array([1.0, 0.9849691, 0.9617777, 0.9020941, 0.84368306, 0.7846833, 0.7846833, 0.7846833]), new Float32Array([1.0, 0.98716563, 0.9676775, 0.9199103, 0.8785067, 0.8464232, 0.8464232, 0.8464232]), new Float32Array([1.0, 0.9913534, 0.9786, 0.94960636, 0.9277157, 0.9133354, 0.9133354, 0.9133354]), new Float32Array([1.0, 0.9948924, 0.9875319, 0.97163296, 0.9604805, 0.953595, 0.953595, 0.953595]), new Float32Array([1.0, 0.9977406, 0.99454236, 0.9878737, 0.983398, 0.98072076, 0.98072076, 0.98072076]), new Float32Array([1.0, 0.9990607, 0.99774176, 0.99503237, 0.9932453, 0.99218845, 0.99218845, 0.99218845]), new Float32Array([1.0, 0.9998082, 0.99954003, 0.99899364, 0.99863654, 0.99842656, 0.99842656, 0.99842656])];
    constructor.cos_gammas_fine = [new Float32Array([1.0, 0.98412395, 0.95947385, 0.8946843, 0.8269341, 0.72456884, 0.72456884, 0.72456884]), new Float32Array([1.0, 0.9849691, 0.9617777, 0.9020941, 0.84368306, 0.7846833, 0.7846833, 0.7846833]), new Float32Array([1.0, 0.98716563, 0.9676775, 0.9199103, 0.8785067, 0.8464232, 0.8464232, 0.8464232]), new Float32Array([1.0, 0.9899597, 0.97500986, 0.9402334, 0.9129699, 0.8943766, 0.8943766, 0.8943766]), new Float32Array([1.0, 0.99266076, 0.9819296, 0.95801604, 0.94049937, 0.9293004, 0.9293004, 0.9293004]), new Float32Array([1.0, 0.9948924, 0.9875319, 0.97163296, 0.9604805, 0.953595, 0.953595, 0.953595]), new Float32Array([1.0, 0.99720746, 0.9932414, 0.9849198, 0.97929263, 0.97590923, 0.97590923, 0.97590923]), new Float32Array([1.0, 0.99853617, 0.9964742, 0.9922136, 0.98938453, 0.98770416, 0.98770416, 0.98770416]), new Float32Array([1.0, 0.99924946, 0.9981967, 0.9960387, 0.9946186, 0.99378, 0.99378, 0.99378]), new Float32Array([1.0, 0.9996195, 0.9990869, 0.9979996, 0.9972874, 0.99686795, 0.99686795, 0.99686795]), new Float32Array([1.0, 0.9998082, 0.99954003, 0.99899364, 0.99863654, 0.99842656, 0.99842656, 0.99842656]), new Float32Array([1.0, 0.9999391, 0.999854, 0.99968094, 0.999568, 0.99950165, 0.99950165, 0.99950165]), new Float32Array([1.0, 0.9999807, 0.9999538, 0.999899, 0.99986327, 0.99984235, 0.99984235, 0.99984235]), new Float32Array([1.0, 0.9999939, 0.9999854, 0.99996805, 0.9999568, 0.9999501, 0.9999501, 0.9999501]), new Float32Array([1.0, 0.9999981, 0.99999535, 0.99998987, 0.99998635, 0.9999842, 0.9999842, 0.9999842]), new Float32Array([1.0, 0.9999994, 0.99999857, 0.9999968, 0.99999565, 0.999995, 0.999995, 0.999995])];
    constructor.sin_gammas_normal = [new Float32Array([0.0, 0.17748243, 0.28179777, 0.446699, 0.56229883, 0.6892024, 0.6892024, 0.6892024]), new Float32Array([0.0, 0.17273088, 0.27383152, 0.43153927, 0.53684163, 0.6198969, 0.6198969, 0.6198969]), new Float32Array([0.0, 0.1596999, 0.252191, 0.39212888, 0.47773004, 0.53251076, 0.53251076, 0.53251076]), new Float32Array([0.0, 0.13121906, 0.20577173, 0.31344506, 0.37328747, 0.40720809, 0.40720809, 0.40720809]), new Float32Array([0.0, 0.100940704, 0.1574189, 0.23649386, 0.2783472, 0.30109245, 0.30109245, 0.30109245]), new Float32Array([0.0, 0.06718363, 0.10433334, 0.15525985, 0.1814615, 0.19541448, 0.19541448, 0.19541448]), new Float32Array([0.0, 0.043332487, 0.06716661, 0.09955164, 0.11603327, 0.12474787, 0.12474787, 0.12474787]), new Float32Array([0.0, 0.019586058, 0.030326985, 0.04485193, 0.052202202, 0.056075003, 0.056075003, 0.056075003])];
    constructor.sin_gammas_fine = [new Float32Array([0.0, 0.17748243, 0.28179777, 0.446699, 0.56229883, 0.6892024, 0.6892024, 0.6892024]), new Float32Array([0.0, 0.17273088, 0.27383152, 0.43153927, 0.53684163, 0.6198969, 0.6198969, 0.6198969]), new Float32Array([0.0, 0.1596999, 0.252191, 0.39212888, 0.47773004, 0.53251076, 0.53251076, 0.53251076]), new Float32Array([0.0, 0.14134967, 0.22216155, 0.34053072, 0.40802696, 0.44731477, 0.44731477, 0.44731477]), new Float32Array([0.0, 0.12093227, 0.18924671, 0.2867147, 0.33979544, 0.36932462, 0.36932462, 0.36932462]), new Float32Array([0.0, 0.100940704, 0.1574189, 0.23649386, 0.2783472, 0.30109245, 0.30109245, 0.30109245]), new Float32Array([0.0, 0.07468114, 0.11606665, 0.17301174, 0.20244971, 0.21817683, 0.21817683, 0.21817683]), new Float32Array([0.0, 0.05408753, 0.08389972, 0.12454762, 0.14532112, 0.1563347, 0.1563347, 0.1563347]), new Float32Array([0.0, 0.038737107, 0.06002761, 0.08892122, 0.103604406, 0.11136096, 0.11136096, 0.11136096]), new Float32Array([0.0, 0.02758461, 0.042723317, 0.063219815, 0.07360646, 0.07908376, 0.07908376, 0.07908376]), new Float32Array([0.0, 0.019586058, 0.030326985, 0.04485193, 0.052202202, 0.056075003, 0.056075003, 0.056075003]), new Float32Array([0.0, 0.011036395, 0.017085798, 0.025259212, 0.029391602, 0.031567305, 0.031567305, 0.031567305]), new Float32Array([0.0, 0.0062101283, 0.00961382, 0.014210965, 0.016534565, 0.017757632, 0.017757632, 0.017757632]), new Float32Array([0.0, 0.0034934508, 0.0054071187, 0.007992832, 0.009299404, 0.009987163, 0.009987163, 0.009987163]), new Float32Array([0.0, 0.0019645398, 0.0030419906, 0.004495151, 0.0052291853, 0.00561665, 0.00561665, 0.00561665]), new Float32Array([0.0, 0.0011053943, 0.0017089869, 0.002528367, 0.0029398552, 0.0031573684, 0.0031573684, 0.0031573684])];
    constructor.sf_iid_normal = new Float32Array([1.4119828, 1.4031382, 1.3868767, 1.3483998, 1.2912494, 1.1960374, 1.1073724, 1.0, 0.87961715, 0.75464857, 0.5767799, 0.42640144, 0.2767183, 0.17664462, 0.07940163]);
    constructor.sf_iid_fine = new Float32Array([1.4142065, 1.4141912, 1.4141428, 1.41399, 1.413507, 1.4119828, 1.409773, 1.4053948, 1.3967797, 1.380053, 1.3483998, 1.3139201, 1.2643101, 1.1960374, 1.1073724, 1.0, 0.87961715, 0.75464857, 0.6336561, 0.52308106, 0.42640144, 0.3089554, 0.22137465, 0.15768789, 0.11198225, 0.07940163, 0.044699017, 0.025144693, 0.014141428, 0.007952581, 0.0044721137]);
    constructor.ipdopd_cos_tab = new Float32Array([1.0, 0.70710677, 0.0, -0.70710677, -1.0, -0.70710677, -0.0, 0.70710677, 1.0]);
    constructor.ipdopd_sin_tab = new Float32Array([0.0, 0.70710677, 1.0, 0.70710677, 0.0, -0.70710677, -1.0, -0.70710677, -0.0]);
}, {nr_iid_par_tab: "Int32Array", nr_icc_par_tab: "Int32Array", nr_ipdopd_par_tab: "Int32Array", num_env_tab: "Array", filter_a: "Float32Array", group_border20: "Int32Array", group_border34: "Int32Array", map_group2bk20: "Int32Array", map_group2bk34: "Int32Array", delay_length_d: "Int32Array", p8_13_20: "Float32Array", p2_13_20: "Float32Array", p12_13_34: "Float32Array", p8_13_34: "Float32Array", p4_13_34: "Float32Array", Phi_Fract_Qmf: "Array", Phi_Fract_SubQmf20: "Array", Phi_Fract_SubQmf34: "Array", Q_Fract_allpass_Qmf: "Array", Q_Fract_allpass_SubQmf20: "Array", Q_Fract_allpass_SubQmf34: "Array", cos_alphas: "Float32Array", sin_alphas: "Float32Array", cos_betas_normal: "Array", sin_betas_normal: "Array", cos_betas_fine: "Array", sin_betas_fine: "Array", sincos_alphas_B_normal: "Array", sincos_alphas_B_fine: "Array", cos_gammas_normal: "Array", cos_gammas_fine: "Array", sin_gammas_normal: "Array", sin_gammas_fine: "Array", sf_iid_normal: "Float32Array", sf_iid_fine: "Float32Array", ipdopd_cos_tab: "Float32Array", ipdopd_sin_tab: "Float32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  SMPTE 302m decoder
 *  
 *  @author The JCodec project
 *  
 */
var S302MDecoder = function() {};
S302MDecoder = stjs.extend(S302MDecoder, null, [AudioDecoder], function(constructor, prototype) {
    constructor.SAMPLE_RATE = 48000;
    prototype.decodeFrame = function(frame, dst) {
        frame.order(ByteOrder.BIG_ENDIAN);
        var dup = dst.duplicate();
        var h = frame.getInt();
        var frameSize = (h >> 16) & 65535;
        if (frame.remaining() != frameSize) 
             throw new IllegalArgumentException("Wrong s302m frame");
        var channels = ((h >> 14) & 3) * 2 + 2;
        var sampleSizeInBits = ((h >> 4) & 3) * 4 + 16;
        if (sampleSizeInBits == 24) {
            var nSamples = (stjs.trunc(frame.remaining() / 7)) * 2;
             while (frame.remaining() > 6){
                var c = (MathUtil.reverse(frame.get() & 255) << 24 >> 24);
                var b = (MathUtil.reverse(frame.get() & 255) << 24 >> 24);
                var a = (MathUtil.reverse(frame.get() & 255) << 24 >> 24);
                var g = MathUtil.reverse(frame.get() & 15);
                var f = MathUtil.reverse(frame.get() & 255);
                var e = MathUtil.reverse(frame.get() & 255);
                var d = MathUtil.reverse(frame.get() & 240);
                dup.put(a);
                dup.put(b);
                dup.put(c);
                dup.put((((d << 4) | (e >> 4)) << 24 >> 24));
                dup.put((((e << 4) | (f >> 4)) << 24 >> 24));
                dup.put((((f << 4) | (g >> 4)) << 24 >> 24));
            }
            dup.flip();
            return new AudioBuffer(dup, new AudioFormat(S302MDecoder.SAMPLE_RATE, 24, channels, true, true), stjs.trunc(nSamples / channels));
        } else if (sampleSizeInBits == 20) {
            var nSamples = (stjs.trunc(frame.remaining() / 6)) * 2;
             while (frame.remaining() > 5){
                var c = MathUtil.reverse(frame.get() & 255);
                var b = MathUtil.reverse(frame.get() & 255);
                var a = MathUtil.reverse(frame.get() & 240);
                dup.put((((a << 4) | (b >> 4)) << 24 >> 24));
                dup.put((((b << 4) | (c >> 4)) << 24 >> 24));
                dup.put(((c << 4) << 24 >> 24));
                var cc = MathUtil.reverse(frame.get() & 255);
                var bb = MathUtil.reverse(frame.get() & 255);
                var aa = MathUtil.reverse(frame.get() & 240);
                dup.put((((aa << 4) | (bb >> 4)) << 24 >> 24));
                dup.put((((bb << 4) | (cc >> 4)) << 24 >> 24));
                dup.put(((cc << 4) << 24 >> 24));
            }
            dup.flip();
            return new AudioBuffer(dup, new AudioFormat(S302MDecoder.SAMPLE_RATE, 24, channels, true, true), stjs.trunc(nSamples / channels));
        } else {
            var nSamples = (stjs.trunc(frame.remaining() / 5)) * 2;
             while (frame.remaining() > 4){
                var bb = (MathUtil.reverse(frame.get() & 255) << 24 >> 24);
                var aa = (MathUtil.reverse(frame.get() & 255) << 24 >> 24);
                var c = MathUtil.reverse(frame.get() & 255);
                var b = MathUtil.reverse(frame.get() & 255);
                var a = MathUtil.reverse(frame.get() & 240);
                dst.put(aa);
                dst.put(bb);
                dst.put((((a << 4) | (b >> 4)) << 24 >> 24));
                dst.put((((b << 4) | (c >> 4)) << 24 >> 24));
            }
            dup.flip();
            return new AudioBuffer(dup, new AudioFormat(S302MDecoder.SAMPLE_RATE, 16, channels, true, true), stjs.trunc(nSamples / channels));
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var SeekableDemuxerTrack = function() {};
SeekableDemuxerTrack = stjs.extend(SeekableDemuxerTrack, null, [DemuxerTrack], function(constructor, prototype) {
    /**
     *  Goes to exactly frameNo.
     *  
     *  @param frameNo
     *             Frame number, zero based, to go to.
     *  @return Weather or not the operation was successful. Will fail if the
     *          frameNo is out of range.
     *  @throws IOException
     */
    prototype.gotoFrame = function(frameNo) {};
    /**
     *  Goes to a a frame that's a sync frame (key frame) and is prior or at
     *  frame frameNo.
     *  
     *  @param frameNo
     *             Frame number, zero based, related to which a sync frame will
     *             be selected.
     *  @return If the operation was successful.
     *  @throws IOException
     */
    prototype.gotoSyncFrame = function(frameNo) {};
    /**
     *  Gets an index of the frame that the next call to 'nextFrame' will return,
     *  zero based.
     *  
     *  @return An index of the next frame, zero based.
     */
    prototype.getCurFrame = function() {};
    /**
     *  Seeks this container to the second provided so that the next call to
     *  nextFrame will return a frame at that second.
     *  
     *  @param second
     *             A second to seek to.
     *  @throws IOException
     */
    prototype.seek = function(second) {};
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Like MP4Edit
 *  
 *  @author The JCodec project
 *  
 */
var CompoundMP4Edit = function(edits) {
    this.edits = edits;
};
CompoundMP4Edit = stjs.extend(CompoundMP4Edit, null, [MP4Edit], function(constructor, prototype) {
    prototype.edits = null;
    prototype.applyToFragment = function(mov, fragmentBox) {
        for (var iterator$command = this.edits.iterator(); iterator$command.hasNext(); ) {
            var command = iterator$command.next();
            command.applyToFragment(mov, fragmentBox);
        }
    };
    prototype.apply = function(mov) {
        for (var iterator$command = this.edits.iterator(); iterator$command.hasNext(); ) {
            var command = iterator$command.next();
            command.apply(mov);
        }
    };
}, {edits: {name: "List", arguments: ["MP4Edit"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Performs IDCT of 8x8 block.
 *  
 *  See MPEGDecoder for example.
 *  
 *  @author The JCodec project
 *  
 */
var SparseIDCT = function() {};
SparseIDCT = stjs.extend(SparseIDCT, null, [], function(constructor, prototype) {
    constructor.COEFF = Array(64);
    constructor.PRECISION = 13;
    constructor.DC_SHIFT = SparseIDCT.PRECISION - 3;
    /**
     *  Starts DCT reconstruction
     *  
     *  Faster then call to 'coeff' with ind = 0
     *  
     *  @param block
     *  @param dc
     */
    constructor.start = function(block, dc) {
        dc <<= SparseIDCT.DC_SHIFT;
        for (var i = 0; i < 64; i += 4) {
            block[i + 0] = dc;
            block[i + 1] = dc;
            block[i + 2] = dc;
            block[i + 3] = dc;
        }
    };
    /**
     *  Recalculates image based on new DCT coefficient
     *  
     *  @param block
     *  @param ind
     *  @param level
     */
    constructor.coeff = function(block, ind, level) {
        for (var i = 0; i < 64; i += 4) {
            block[i] += SparseIDCT.COEFF[ind][i] * level;
            block[i + 1] += SparseIDCT.COEFF[ind][i + 1] * level;
            block[i + 2] += SparseIDCT.COEFF[ind][i + 2] * level;
            block[i + 3] += SparseIDCT.COEFF[ind][i + 3] * level;
        }
    };
    /**
     *  Finalizes DCT calculation
     *  
     *  @param block
     */
    constructor.finish = function(block) {
        for (var i = 0; i < 64; i += 4) {
            block[i] = SparseIDCT.div(block[i]);
            block[i + 1] = SparseIDCT.div(block[i + 1]);
            block[i + 2] = SparseIDCT.div(block[i + 2]);
            block[i + 3] = SparseIDCT.div(block[i + 3]);
        }
    };
    constructor.div = function(x) {
        var m = x >> 31;
        var n = x >>> 31;
        return ((((x ^ m) + n) >> SparseIDCT.PRECISION) ^ m) + n;
    };
}, {COEFF: "Array"}, {});
(function() {
    SparseIDCT.COEFF[0] = new Int32Array(64);
    Arrays.fill(SparseIDCT.COEFF[0], 1 << SparseIDCT.DC_SHIFT);
    var ac = 1 << SparseIDCT.PRECISION;
    for (var i = 1; i < 64; i++) {
        SparseIDCT.COEFF[i] = new Int32Array(64);
        SparseIDCT.COEFF[i][i] = ac;
        SimpleIDCT10Bit.idct10(SparseIDCT.COEFF[i], 0);
    }
})();
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  This class is analogous to DataInputStream, it's backed by the Channel and
 *  buffers the IO
 *  
 *  @author The JCodec project
 *  
 */
var DataReader = function(channel, order, bufferSize) {
    this.channel = channel;
    this.buffer = ByteBuffer.allocate(bufferSize);
    this.buffer.setLimit(0);
    this.buffer.order(order);
};
DataReader = stjs.extend(DataReader, null, [Closeable], function(constructor, prototype) {
    constructor.DEFAULT_BUFFER_SIZE = 1 << 20;
    prototype.channel = null;
    prototype.buffer = null;
    constructor.createDataReader = function(channel, order) {
        return new DataReader(channel, order, DataReader.DEFAULT_BUFFER_SIZE);
    };
    prototype.readFully3 = function(b, off, len) {
        var initOff = off;
         while (len > 0){
            this.fetchIfNeeded(len);
            if (this.buffer.remaining() == 0) 
                break;
            var toRead = Math.min(this.buffer.remaining(), len);
            this.buffer.getBuf3(b, off, toRead);
            off += toRead;
            len -= toRead;
        }
        return off - initOff;
    };
    prototype.skipBytes = function(n) {
        var oldPosition = this.position();
        if (n < this.buffer.remaining()) {
            this.buffer.setPosition(this.buffer.position() + n);
        } else {
            this.setPosition(oldPosition + n);
        }
        return (((this.position() - oldPosition)) | 0);
    };
    prototype.readByte = function() {
        this.fetchIfNeeded(1);
        return this.buffer.get();
    };
    prototype.readShort = function() {
        this.fetchIfNeeded(2);
        return this.buffer.getShort();
    };
    prototype.readChar = function() {
        this.fetchIfNeeded(2);
        return this.buffer.getChar();
    };
    prototype.readInt = function() {
        this.fetchIfNeeded(4);
        return this.buffer.getInt();
    };
    prototype.readLong = function() {
        this.fetchIfNeeded(8);
        return this.buffer.getLong();
    };
    prototype.readFloat = function() {
        this.fetchIfNeeded(4);
        return this.buffer.getFloat();
    };
    prototype.readDouble = function() {
        this.fetchIfNeeded(8);
        return this.buffer.getDouble();
    };
    prototype.position = function() {
        return this.channel.position() - this.buffer.limit() + this.buffer.position();
    };
    prototype.setPosition = function(newPos) {
        var relative = (((newPos - (this.channel.position() - this.buffer.limit()))) | 0);
        if (relative >= 0 && relative < this.buffer.limit()) {
            this.buffer.setPosition(relative);
        } else {
            this.buffer.setLimit(0);
            this.channel.setPosition(newPos);
        }
        return this.position();
    };
    prototype.close = function() {
        this.channel.close();
    };
    prototype.fetchIfNeeded = function(length) {
        if (this.buffer.remaining() < length) {
            DataReader.moveRemainderToTheStart(this.buffer);
            this.channel.read(this.buffer);
        }
    };
    constructor.moveRemainderToTheStart = function(readBuf) {
        var rem = readBuf.remaining();
        for (var i = 0; i < rem; i++) {
            readBuf.putAt(i, readBuf.get());
        }
        readBuf.clear();
        readBuf.setPosition(rem);
    };
    prototype.size = function() {
        return this.channel.size();
    };
    prototype.readFully = function(b) {
        return this.readFully3(b, 0, b.length);
    };
}, {channel: "SeekableByteChannel", buffer: "ByteBuffer"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var IntObjectMap = function() {
    this.storage = Array(IntObjectMap.GROW_BY);
};
IntObjectMap = stjs.extend(IntObjectMap, null, [], function(constructor, prototype) {
    constructor.GROW_BY = 128;
    prototype.storage = null;
    prototype._size = 0;
    prototype.put = function(key, val) {
        if (this.storage.length <= key) {
            var ns = Array(key + IntObjectMap.GROW_BY);
            System.arraycopy(this.storage, 0, ns, 0, this.storage.length);
            this.storage = ns;
        }
        if (this.storage[key] == null) 
            this._size++;
        this.storage[key] = val;
    };
    prototype.get = function(key) {
        return key >= this.storage.length ? null : this.storage[key];
    };
    prototype.keys = function() {
        var result = new Int32Array(this._size);
        for (var i = 0, r = 0; i < this.storage.length; i++) {
            if (this.storage[i] != null) 
                result[r++] = i;
        }
        return result;
    };
    prototype.clear = function() {
        for (var i = 0; i < this.storage.length; i++) 
            this.storage[i] = null;
        this._size = 0;
    };
    prototype.size = function() {
        return this._size;
    };
    prototype.remove = function(key) {
        if (this.storage[key] != null) 
            this._size--;
        this.storage[key] = null;
    };
    prototype.values = function(runtime) {
        var result = jslang.reflect.Array.newInstance(runtime.getClass().getComponentType(), this._size);
        for (var i = 0, r = 0; i < this.storage.length; i++) {
            if (this.storage[i] != null) 
                result[r++] = this.storage[i];
        }
        return result;
    };
}, {storage: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author Jay Codec
 *  
 */
var ArrayUtil = function() {};
ArrayUtil = stjs.extend(ArrayUtil, null, [], function(constructor, prototype) {
    constructor.shiftRight1 = function(array) {
        for (var i = 1; i < array.length; i++) {
            array[i] = array[i - 1];
        }
        array[0] = null;
    };
    constructor.shiftLeft1 = function(array) {
        for (var i = 0; i < array.length - 1; i++) {
            array[i] = array[i + 1];
        }
        array[array.length - 1] = null;
    };
    constructor.shiftRight3 = function(array, from, to) {
        for (var i = to - 1; i > from; i--) {
            array[i] = array[i - 1];
        }
        array[from] = null;
    };
    constructor.shiftLeft3 = function(array, from, to) {
        for (var i = from; i < to - 1; i++) {
            array[i] = array[i + 1];
        }
        array[to - 1] = null;
    };
    constructor.shiftLeft2 = function(array, from) {
        ArrayUtil.shiftLeft3(array, from, array.length);
    };
    constructor.shiftRight2 = function(array, to) {
        ArrayUtil.shiftRight3(array, 0, to);
    };
    constructor.swap = function(arr, ind1, ind2) {
        var tmp = arr[ind1];
        arr[ind1] = arr[ind2];
        arr[ind2] = tmp;
    };
    constructor.sumInt = function(array) {
        var result = 0;
        for (var i = 0; i < array.length; i++) {
            result += array[i];
        }
        return result;
    };
    constructor.sumByte = function(array) {
        var result = 0;
        for (var i = 0; i < array.length; i++) {
            result += array[i];
        }
        return result;
    };
    constructor.sumInt3 = function(array, from, count) {
        var result = 0;
        for (var i = from; i < from + count; i++) {
            result += array[i];
        }
        return result;
    };
    constructor.sumByte3 = function(array, from, count) {
        var result = 0;
        for (var i = from; i < from + count; i++) {
            result += array[i];
        }
        return result;
    };
    constructor.addInt = function(array, val) {
        for (var i = 0; i < array.length; i++) 
            array[i] += val;
    };
    constructor.addAllInt = function(array1, array2) {
        if (array1 == null) {
            return ArrayUtil.cloneInt(array2);
        } else if (array2 == null) {
            return ArrayUtil.cloneInt(array1);
        }
        var joinedArray = new Int32Array(array1.length + array2.length);
        System.arraycopy(array1, 0, joinedArray, 0, array1.length);
        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
        return joinedArray;
    };
    constructor.addAllLong = function(array1, array2) {
        if (array1 == null) {
            return ArrayUtil.cloneLong(array2);
        } else if (array2 == null) {
            return ArrayUtil.cloneLong(array1);
        }
        var joinedArray = Array(array1.length + array2.length);
        System.arraycopy(array1, 0, joinedArray, 0, array1.length);
        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
        return joinedArray;
    };
    constructor.addAllObj = function(array1, array2) {
        if (array1 == null) {
            return ArrayUtil.cloneObj(array2);
        } else if (array2 == null) {
            return ArrayUtil.cloneObj(array1);
        }
        var joinedArray = jslang.reflect.Array.newInstance(array1.getClass().getComponentType(), array1.length + array2.length);
        System.arraycopy(array1, 0, joinedArray, 0, array1.length);
        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
        return joinedArray;
    };
    constructor.cloneInt = function(array) {
        if (array == null) {
            return null;
        }
        return array.clone();
    };
    constructor.cloneLong = function(array) {
        if (array == null) {
            return null;
        }
        return array.clone();
    };
    constructor.cloneObj = function(array) {
        if (array == null) {
            return null;
        }
        return array.clone();
    };
    constructor.toByteArrayShifted = function(_arguments) {
        var result = new Int8Array(arguments.length);
        for (var i = 0; i < arguments.length; i++) 
            result[i] = ((arguments[i] - 128) << 24 >> 24);
        return result;
    };
    constructor.toByteArrayShifted2 = function(intArray) {
        var result = Array(intArray.length);
        for (var i = 0; i < intArray.length; i++) {
            result[i] = ArrayUtil.toByteArrayShifted(intArray[i]);
        }
        return result;
    };
    constructor.toIntArrayUnshifted = function(_arguments) {
        var result = new Int32Array(arguments.length);
        for (var i = 0; i < result.length; i++) 
            result[i] = ((arguments[i] + 128) << 24 >> 24);
        return result;
    };
    constructor.toByteArray = function(_arguments) {
        var result = new Int8Array(arguments.length);
        for (var i = 0; i < arguments.length; i++) 
            result[i] = (arguments[i] << 24 >> 24);
        return result;
    };
    constructor.toIntArray = function(_arguments) {
        var result = new Int32Array(arguments.length);
        for (var i = 0; i < result.length; i++) 
            result[i] = arguments[i];
        return result;
    };
    constructor.toUnsignedIntArray = function(val) {
        var result = new Int32Array(val.length);
        for (var i = 0; i < val.length; i++) 
            result[i] = val[i] & 255;
        return result;
    };
    constructor.reverse = function(frames) {
        for (var i = 0, j = frames.length - 1; i < frames.length >> 1; ++i , --j) {
            var tmp = frames[i];
            frames[i] = frames[j];
            frames[j] = tmp;
        }
    };
    constructor.max = function(array) {
        var max = Integer.MIN_VALUE;
        for (var i = 0; i < array.length; i++) {
            if (array[i] > max) {
                max = array[i];
            }
        }
        return max;
    };
    constructor.rotate = function(src) {
        var dst = Array.apply(null, Array(src[0].length)).map(function() {
            return new Int32Array(src.length);
        });
        for (var i = 0; i < src.length; i++) {
            for (var j = 0; j < src[0].length; j++) {
                dst[j][i] = src[i][j];
            }
        }
        return dst;
    };
    constructor.create2D = function(width, height) {
        var result = Array(height);
        for (var i = 0; i < height; i++) 
            result[i] = new Int8Array(width);
        return result;
    };
    constructor.printMatrix = function(array, format, width) {
        var strings = Array(array.length);
        var maxLen = 0;
        for (var i = 0; i < array.length; i++) {
            strings[i] = String.format(format, array[i]);
            maxLen = Math.max(maxLen, strings[i].length);
        }
        for (var ind = 0; ind < strings.length; ) {
            var builder = new StringBuilder();
            for (var i = 0; i < width && ind < strings.length; i++ , ind++) {
                for (var j = 0; j < maxLen - strings[ind].length + 1; j++) 
                    builder.append(' ');
                builder.append(strings[ind]);
            }
            System.out.println(builder);
        }
    };
    constructor.padLeft = function(array, padLength) {
        var result = new Int8Array(array.length + padLength);
        for (var i = padLength; i < result.length; i++) 
            result[i] = array[i - padLength];
        return result;
    };
    constructor.randomIntArray = function(size, from, to) {
        var width = to - from;
        var result = new Int32Array(size);
        for (var i = 0; i < size; i++) 
            result[i] = stjs.trunc(((Math.random() * width) % width)) + from;
        return result;
    };
    constructor.randomByteArray = function(size, from, to) {
        var width = ((to - from) << 24 >> 24);
        var result = new Int8Array(size);
        for (var i = 0; i < size; i++) 
            result[i] = stjs.trunc((((Math.random() * width) % width) + from));
        return result;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var PriorityFuture = function(other, priority) {
    this.src = other;
    this.priority = priority;
};
PriorityFuture = stjs.extend(PriorityFuture, null, [RunnableFuture], function(constructor, prototype) {
    prototype.src = null;
    prototype.priority = 0;
    prototype.getPriority = function() {
        return this.priority;
    };
    prototype.cancel = function(mayInterruptIfRunning) {
        return this.src.cancel(mayInterruptIfRunning);
    };
    prototype.isCancelled = function() {
        return this.src.isCancelled();
    };
    prototype.isDone = function() {
        return this.src.isDone();
    };
    prototype.get = function(_arguments) {
        return this.src.get(arguments);
    };
    prototype.run = function() {
        this.src.run();
    };
    constructor.COMP = new (stjs.extend(function PriorityFuture$1() {}, null, [Comparator], function(constructor, prototype) {
        prototype.compare = function(o1, o2) {
            if (o1 == null && o2 == null) 
                return 0;
             else if (o1 == null) 
                return -1;
             else if (o2 == null) 
                return 1;
             else {
                var p1 = (o1).getPriority();
                var p2 = (o2).getPriority();
                return p1 > p2 ? 1 : (p1 == p2 ? 0 : -1);
            }
        };
    }, {}, {}))();
}, {src: {name: "RunnableFuture", arguments: ["T"]}, COMP: {name: "Comparator", arguments: ["Runnable"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Makes all frames of a fixed size
 *  
 *  @author The JCodec project
 *  
 */
var VP8FixedRateControl = function(rate) {
    this.rate = rate;
};
VP8FixedRateControl = stjs.extend(VP8FixedRateControl, null, [RateControl], function(constructor, prototype) {
    prototype.rate = 0;
    prototype.getSegmentQps = function() {
        return null;
    };
    prototype.getSegment = function() {
        return 0;
    };
    prototype.report = function(bits) {};
    prototype.reset = function() {};
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Rate control that does nothing
 *  
 *  @author The JCodec project
 *  
 */
var NopRateControl = function(qp) {
    this.qp = qp;
};
NopRateControl = stjs.extend(NopRateControl, null, [RateControl], function(constructor, prototype) {
    prototype.qp = 0;
    prototype.getSegmentQps = function() {
        return new Int32Array([this.qp]);
    };
    prototype.getSegment = function() {
        return 0;
    };
    prototype.report = function(bits) {};
    prototype.reset = function() {};
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Label = function(val) {
    this.labelVal = val;
    this.bitmapVal = (this.labelVal > 18 || this.labelVal < 1) ? 0 : 1 << (this.labelVal - 1);
    Label._values.add(this);
};
Label = stjs.extend(Label, null, [], function(constructor, prototype) {
    constructor._values = new ArrayList();
    /**
     * unknown role or unspecified other use for channel 
     */
    constructor.Unknown = new Label(-1);
    /**
     * channel is present, but has no intended role or destination 
     */
    constructor.Unused = new Label(0);
    /**
     * channel is described solely by the mCoordinates fields 
     */
    constructor.UseCoordinates = new Label(100);
    constructor.Left = new Label(1);
    constructor.Right = new Label(2);
    constructor.Center = new Label(3);
    constructor.LFEScreen = new Label(4);
    /**
     * WAVE (.wav files): "Back Left" 
     */
    constructor.LeftSurround = new Label(5);
    /**
     * WAVE: "Back Right" 
     */
    constructor.RightSurround = new Label(6);
    constructor.LeftCenter = new Label(7);
    constructor.RightCenter = new Label(8);
    /**
     * WAVE: "Back  Center or  plain "Rear Surround" 
     */
    constructor.CenterSurround = new Label(9);
    /**
     * WAVE: "Side Left" 
     */
    constructor.LeftSurroundDirect = new Label(10);
    /**
     * WAVE: "Side Right" 
     */
    constructor.RightSurroundDirect = new Label(11);
    constructor.TopCenterSurround = new Label(12);
    /**
     * WAVE: "Top Front Left" 
     */
    constructor.VerticalHeightLeft = new Label(13);
    /**
     * WAVE: "Top Front Center" 
     */
    constructor.VerticalHeightCenter = new Label(14);
    /**
     * WAVE: "Top Front Right" 
     */
    constructor.VerticalHeightRight = new Label(15);
    constructor.TopBackLeft = new Label(16);
    constructor.TopBackCenter = new Label(17);
    constructor.TopBackRight = new Label(18);
    constructor.RearSurroundLeft = new Label(33);
    constructor.RearSurroundRight = new Label(34);
    constructor.LeftWide = new Label(35);
    constructor.RightWide = new Label(36);
    constructor.LFE2 = new Label(37);
    /**
     * matrix encoded 4 channels 
     */
    constructor.LeftTotal = new Label(38);
    /**
     * matrix encoded 4 channels 
     */
    constructor.RightTotal = new Label(39);
    constructor.HearingImpaired = new Label(40);
    constructor.Narration = new Label(41);
    constructor.Mono = new Label(42);
    constructor.DialogCentricMix = new Label(43);
    /**
     * center, non diffuse first order ambisonic channels 
     */
    constructor.CenterSurroundDirect = new Label(44);
    constructor.Ambisonic_W = new Label(200);
    constructor.Ambisonic_X = new Label(201);
    constructor.Ambisonic_Y = new Label(202);
    constructor.Ambisonic_Z = new Label(203);
    /**
     * Mid/Side Recording 
     */
    constructor.MS_Mid = new Label(204);
    constructor.MS_Side = new Label(205);
    /**
     * X-Y Recording 
     */
    constructor.XY_X = new Label(206);
    constructor.XY_Y = new Label(207);
    constructor.HeadphonesLeft = new Label(301);
    constructor.HeadphonesRight = new Label(302);
    constructor.ClickTrack = new Label(304);
    constructor.ForeignLanguage = new Label(305);
    constructor.Discrete = new Label(400);
    constructor.Discrete_0 = new Label((1 << 16) | 0);
    constructor.Discrete_1 = new Label((1 << 16) | 1);
    constructor.Discrete_2 = new Label((1 << 16) | 2);
    constructor.Discrete_3 = new Label((1 << 16) | 3);
    constructor.Discrete_4 = new Label((1 << 16) | 4);
    constructor.Discrete_5 = new Label((1 << 16) | 5);
    constructor.Discrete_6 = new Label((1 << 16) | 6);
    constructor.Discrete_7 = new Label((1 << 16) | 7);
    constructor.Discrete_8 = new Label((1 << 16) | 8);
    constructor.Discrete_9 = new Label((1 << 16) | 9);
    constructor.Discrete_10 = new Label((1 << 16) | 10);
    constructor.Discrete_11 = new Label((1 << 16) | 11);
    constructor.Discrete_12 = new Label((1 << 16) | 12);
    constructor.Discrete_13 = new Label((1 << 16) | 13);
    constructor.Discrete_14 = new Label((1 << 16) | 14);
    constructor.Discrete_15 = new Label((1 << 16) | 15);
    constructor.Discrete_65535 = new Label((1 << 16) | 65535);
    prototype.labelVal = 0;
    prototype.bitmapVal = 0;
    constructor.channelMappingRegex = Pattern.compile("[_\\ \\.][a-zA-Z]+$");
    constructor.values = function() {
        return Label._values.toArray(Array(0));
    };
    constructor.getByVal = function(val) {
        var values = Label.values();
        for (var i = 0; i < values.length; i++) {
            var label = values[i];
            if (label.labelVal == val) 
                return label;
        }
        return Label.Mono;
    };
    prototype.getVal = function() {
        return this.labelVal;
    };
}, {_values: {name: "List", arguments: ["Label"]}, Unknown: "Label", Unused: "Label", UseCoordinates: "Label", Left: "Label", Right: "Label", Center: "Label", LFEScreen: "Label", LeftSurround: "Label", RightSurround: "Label", LeftCenter: "Label", RightCenter: "Label", CenterSurround: "Label", LeftSurroundDirect: "Label", RightSurroundDirect: "Label", TopCenterSurround: "Label", VerticalHeightLeft: "Label", VerticalHeightCenter: "Label", VerticalHeightRight: "Label", TopBackLeft: "Label", TopBackCenter: "Label", TopBackRight: "Label", RearSurroundLeft: "Label", RearSurroundRight: "Label", LeftWide: "Label", RightWide: "Label", LFE2: "Label", LeftTotal: "Label", RightTotal: "Label", HearingImpaired: "Label", Narration: "Label", Mono: "Label", DialogCentricMix: "Label", CenterSurroundDirect: "Label", Ambisonic_W: "Label", Ambisonic_X: "Label", Ambisonic_Y: "Label", Ambisonic_Z: "Label", MS_Mid: "Label", MS_Side: "Label", XY_X: "Label", XY_Y: "Label", HeadphonesLeft: "Label", HeadphonesRight: "Label", ClickTrack: "Label", ForeignLanguage: "Label", Discrete: "Label", Discrete_0: "Label", Discrete_1: "Label", Discrete_2: "Label", Discrete_3: "Label", Discrete_4: "Label", Discrete_5: "Label", Discrete_6: "Label", Discrete_7: "Label", Discrete_8: "Label", Discrete_9: "Label", Discrete_10: "Label", Discrete_11: "Label", Discrete_12: "Label", Discrete_13: "Label", Discrete_14: "Label", Discrete_15: "Label", Discrete_65535: "Label", channelMappingRegex: "Pattern"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license. 
 * 
 *  @author in-somnia
 */
var SynthesisFilterbank = function(channels) {
    this.channels = channels;
    this.v = new Float32Array(2 * channels * 20);
    this.v_index = 0;
};
SynthesisFilterbank = stjs.extend(SynthesisFilterbank, null, [FilterbankTable], function(constructor, prototype) {
    constructor.qmf32_pre_twiddle = [new Float32Array([0.9999247, -0.012271538]), new Float32Array([0.99932235, -0.036807224]), new Float32Array([0.9981181, -0.061320737]), new Float32Array([0.9963126, -0.08579731]), new Float32Array([0.993907, -0.110222206]), new Float32Array([0.99090266, -0.1345807]), new Float32Array([0.9873014, -0.15885815]), new Float32Array([0.9831055, -0.18303989]), new Float32Array([0.9783174, -0.20711137]), new Float32Array([0.97293997, -0.2310581]), new Float32Array([0.96697646, -0.25486565]), new Float32Array([0.9604305, -0.2785197]), new Float32Array([0.953306, -0.30200595]), new Float32Array([0.9456073, -0.3253103]), new Float32Array([0.937339, -0.34841868]), new Float32Array([0.9285061, -0.3713172]), new Float32Array([0.9191139, -0.39399204]), new Float32Array([0.909168, -0.41642955]), new Float32Array([0.8986745, -0.43861625]), new Float32Array([0.88763964, -0.46053872]), new Float32Array([0.8760701, -0.48218378]), new Float32Array([0.86397284, -0.50353837]), new Float32Array([0.8513552, -0.52458966]), new Float32Array([0.8382247, -0.545325]), new Float32Array([0.8245893, -0.5657318]), new Float32Array([0.81045717, -0.58579785]), new Float32Array([0.7958369, -0.60551107]), new Float32Array([0.7807372, -0.6248595]), new Float32Array([0.76516724, -0.64383155]), new Float32Array([0.7491364, -0.6624158]), new Float32Array([0.7326543, -0.680601]), new Float32Array([0.71573085, -0.69837624])];
    prototype.v = null;
    prototype.v_index = 0;
    prototype.channels = 0;
    prototype.reset = function() {
        Arrays.fill(this.v, 0);
    };
    prototype.sbr_qmf_synthesis_32 = function(sbr, X, output) {
        var x1 = new Float32Array(32), x2 = new Float32Array(32);
        var scale = 1.0 / 64.0;
        var n, k, out = 0;
        var l;
        for (l = 0; l < sbr.numTimeSlotsRate; l++) {
            for (k = 0; k < 32; k++) {
                x1[k] = (X[l][k][0] * SynthesisFilterbank.qmf32_pre_twiddle[k][0]) - (X[l][k][1] * SynthesisFilterbank.qmf32_pre_twiddle[k][1]);
                x2[k] = (X[l][k][1] * SynthesisFilterbank.qmf32_pre_twiddle[k][0]) + (X[l][k][0] * SynthesisFilterbank.qmf32_pre_twiddle[k][1]);
                x1[k] *= scale;
                x2[k] *= scale;
            }
            this.DCT4_32(x1, x1);
            this.DST4_32(x2, x2);
            for (n = 0; n < 32; n++) {
                this.v[this.v_index + n] = this.v[this.v_index + 640 + n] = -x1[n] + x2[n];
                this.v[this.v_index + 63 - n] = this.v[this.v_index + 640 + 63 - n] = x1[n] + x2[n];
            }
            for (k = 0; k < 32; k++) {
                output[out++] = (this.v[this.v_index + k] * FilterbankTable.qmf_c[2 * k]) + (this.v[this.v_index + 96 + k] * FilterbankTable.qmf_c[64 + 2 * k]) + (this.v[this.v_index + 128 + k] * FilterbankTable.qmf_c[128 + 2 * k]) + (this.v[this.v_index + 224 + k] * FilterbankTable.qmf_c[192 + 2 * k]) + (this.v[this.v_index + 256 + k] * FilterbankTable.qmf_c[256 + 2 * k]) + (this.v[this.v_index + 352 + k] * FilterbankTable.qmf_c[320 + 2 * k]) + (this.v[this.v_index + 384 + k] * FilterbankTable.qmf_c[384 + 2 * k]) + (this.v[this.v_index + 480 + k] * FilterbankTable.qmf_c[448 + 2 * k]) + (this.v[this.v_index + 512 + k] * FilterbankTable.qmf_c[512 + 2 * k]) + (this.v[this.v_index + 608 + k] * FilterbankTable.qmf_c[576 + 2 * k]);
            }
            this.v_index -= 64;
            if (this.v_index < 0) 
                this.v_index = (640 - 64);
        }
    };
    prototype.sbr_qmf_synthesis_64 = function(sbr, X, output) {
        var in_real1 = new Float32Array(32), in_imag1 = new Float32Array(32), out_real1 = new Float32Array(32), out_imag1 = new Float32Array(32);
        var in_real2 = new Float32Array(32), in_imag2 = new Float32Array(32), out_real2 = new Float32Array(32), out_imag2 = new Float32Array(32);
        var pX;
        var scale = 1.0 / 64.0;
        var n, k, out = 0;
        var l;
        for (l = 0; l < sbr.numTimeSlotsRate; l++) {
            pX = X[l];
            in_imag1[31] = scale * pX[1][0];
            in_real1[0] = scale * pX[0][0];
            in_imag2[31] = scale * pX[63 - 1][1];
            in_real2[0] = scale * pX[63 - 0][1];
            for (k = 1; k < 31; k++) {
                in_imag1[31 - k] = scale * pX[2 * k + 1][0];
                in_real1[k] = scale * pX[2 * k][0];
                in_imag2[31 - k] = scale * pX[63 - (2 * k + 1)][1];
                in_real2[k] = scale * pX[63 - (2 * k)][1];
            }
            in_imag1[0] = scale * pX[63][0];
            in_real1[31] = scale * pX[62][0];
            in_imag2[0] = scale * pX[63 - 63][1];
            in_real2[31] = scale * pX[63 - 62][1];
            DCT.dct4_kernel(in_real1, in_imag1, out_real1, out_imag1);
            DCT.dct4_kernel(in_real2, in_imag2, out_real2, out_imag2);
            var pring_buffer_1 = this.v_index;
            var pring_buffer_3 = pring_buffer_1 + 1280;
            for (n = 0; n < 32; n++) {
                this.v[pring_buffer_1 + 2 * n] = this.v[pring_buffer_3 + 2 * n] = out_real2[n] - out_real1[n];
                this.v[pring_buffer_1 + 127 - 2 * n] = this.v[pring_buffer_3 + 127 - 2 * n] = out_real2[n] + out_real1[n];
                this.v[pring_buffer_1 + 2 * n + 1] = this.v[pring_buffer_3 + 2 * n + 1] = out_imag2[31 - n] + out_imag1[31 - n];
                this.v[pring_buffer_1 + 127 - (2 * n + 1)] = this.v[pring_buffer_3 + 127 - (2 * n + 1)] = out_imag2[31 - n] - out_imag1[31 - n];
            }
            pring_buffer_1 = this.v_index;
            for (k = 0; k < 64; k++) {
                output[out++] = (this.v[pring_buffer_1 + k + 0] * FilterbankTable.qmf_c[k + 0]) + (this.v[pring_buffer_1 + k + 192] * FilterbankTable.qmf_c[k + 64]) + (this.v[pring_buffer_1 + k + 256] * FilterbankTable.qmf_c[k + 128]) + (this.v[pring_buffer_1 + k + (256 + 192)] * FilterbankTable.qmf_c[k + 192]) + (this.v[pring_buffer_1 + k + 512] * FilterbankTable.qmf_c[k + 256]) + (this.v[pring_buffer_1 + k + (512 + 192)] * FilterbankTable.qmf_c[k + 320]) + (this.v[pring_buffer_1 + k + 768] * FilterbankTable.qmf_c[k + 384]) + (this.v[pring_buffer_1 + k + (768 + 192)] * FilterbankTable.qmf_c[k + 448]) + (this.v[pring_buffer_1 + k + 1024] * FilterbankTable.qmf_c[k + 512]) + (this.v[pring_buffer_1 + k + (1024 + 192)] * FilterbankTable.qmf_c[k + 576]);
            }
            this.v_index -= 128;
            if (this.v_index < 0) 
                this.v_index = (1280 - 128);
        }
    };
    prototype.DCT4_32 = function(y, x) {
        var f0, f1, f2, f3, f4, f5, f6, f7, f8, f9, f10;
        var f11, f12, f13, f14, f15, f16, f17, f18, f19, f20;
        var f21, f22, f23, f24, f25, f26, f27, f28, f29, f30;
        var f31, f32, f33, f34, f35, f36, f37, f38, f39, f40;
        var f41, f42, f43, f44, f45, f46, f47, f48, f49, f50;
        var f51, f52, f53, f54, f55, f56, f57, f58, f59, f60;
        var f61, f62, f63, f64, f65, f66, f67, f68, f69, f70;
        var f71, f72, f73, f74, f75, f76, f77, f78, f79, f80;
        var f81, f82, f83, f84, f85, f86, f87, f88, f89, f90;
        var f91, f92, f93, f94, f95, f96, f97, f98, f99, f100;
        var f101, f102, f103, f104, f105, f106, f107, f108, f109, f110;
        var f111, f112, f113, f114, f115, f116, f117, f118, f119, f120;
        var f121, f122, f123, f124, f125, f126, f127, f128, f129, f130;
        var f131, f132, f133, f134, f135, f136, f137, f138, f139, f140;
        var f141, f142, f143, f144, f145, f146, f147, f148, f149, f150;
        var f151, f152, f153, f154, f155, f156, f157, f158, f159, f160;
        var f161, f162, f163, f164, f165, f166, f167, f168, f169, f170;
        var f171, f172, f173, f174, f175, f176, f177, f178, f179, f180;
        var f181, f182, f183, f184, f185, f186, f187, f188, f189, f190;
        var f191, f192, f193, f194, f195, f196, f197, f198, f199, f200;
        var f201, f202, f203, f204, f205, f206, f207, f208, f209, f210;
        var f211, f212, f213, f214, f215, f216, f217, f218, f219, f220;
        var f221, f222, f223, f224, f225, f226, f227, f228, f229, f230;
        var f231, f232, f233, f234, f235, f236, f237, f238, f239, f240;
        var f241, f242, f243, f244, f245, f246, f247, f248, f249, f250;
        var f251, f252, f253, f254, f255, f256, f257, f258, f259, f260;
        var f261, f262, f263, f264, f265, f266, f267, f268, f269, f270;
        var f271, f272, f273, f274, f275, f276, f277, f278, f279, f280;
        var f281, f282, f283, f284, f285, f286, f287, f288, f289, f290;
        var f291, f292, f293, f294, f295, f296, f297, f298, f299, f300;
        var f301, f302, f303, f304, f305, f306, f307, f310, f311, f312;
        var f313, f316, f317, f318, f319, f322, f323, f324, f325, f328;
        var f329, f330, f331, f334, f335, f336, f337, f340, f341, f342;
        var f343, f346, f347, f348, f349, f352, f353, f354, f355, f358;
        var f359, f360, f361, f364, f365, f366, f367, f370, f371, f372;
        var f373, f376, f377, f378, f379, f382, f383, f384, f385, f388;
        var f389, f390, f391, f394, f395, f396, f397;
        f0 = x[15] - x[16];
        f1 = x[15] + x[16];
        f2 = (0.70710677 * f1);
        f3 = (0.70710677 * f0);
        f4 = x[8] - x[23];
        f5 = x[8] + x[23];
        f6 = (0.70710677 * f5);
        f7 = (0.70710677 * f4);
        f8 = x[12] - x[19];
        f9 = x[12] + x[19];
        f10 = (0.70710677 * f9);
        f11 = (0.70710677 * f8);
        f12 = x[11] - x[20];
        f13 = x[11] + x[20];
        f14 = (0.70710677 * f13);
        f15 = (0.70710677 * f12);
        f16 = x[14] - x[17];
        f17 = x[14] + x[17];
        f18 = (0.70710677 * f17);
        f19 = (0.70710677 * f16);
        f20 = x[9] - x[22];
        f21 = x[9] + x[22];
        f22 = (0.70710677 * f21);
        f23 = (0.70710677 * f20);
        f24 = x[13] - x[18];
        f25 = x[13] + x[18];
        f26 = (0.70710677 * f25);
        f27 = (0.70710677 * f24);
        f28 = x[10] - x[21];
        f29 = x[10] + x[21];
        f30 = (0.70710677 * f29);
        f31 = (0.70710677 * f28);
        f32 = x[0] - f2;
        f33 = x[0] + f2;
        f34 = x[31] - f3;
        f35 = x[31] + f3;
        f36 = x[7] - f6;
        f37 = x[7] + f6;
        f38 = x[24] - f7;
        f39 = x[24] + f7;
        f40 = x[3] - f10;
        f41 = x[3] + f10;
        f42 = x[28] - f11;
        f43 = x[28] + f11;
        f44 = x[4] - f14;
        f45 = x[4] + f14;
        f46 = x[27] - f15;
        f47 = x[27] + f15;
        f48 = x[1] - f18;
        f49 = x[1] + f18;
        f50 = x[30] - f19;
        f51 = x[30] + f19;
        f52 = x[6] - f22;
        f53 = x[6] + f22;
        f54 = x[25] - f23;
        f55 = x[25] + f23;
        f56 = x[2] - f26;
        f57 = x[2] + f26;
        f58 = x[29] - f27;
        f59 = x[29] + f27;
        f60 = x[5] - f30;
        f61 = x[5] + f30;
        f62 = x[26] - f31;
        f63 = x[26] + f31;
        f64 = f39 + f37;
        f65 = (-0.5411961 * f39);
        f66 = (0.9238795 * f64);
        f67 = (1.306563 * f37);
        f68 = f65 + f66;
        f69 = f67 - f66;
        f70 = f38 + f36;
        f71 = (1.306563 * f38);
        f72 = (-0.38268343 * f70);
        f73 = (0.5411961 * f36);
        f74 = f71 + f72;
        f75 = f73 - f72;
        f76 = f47 + f45;
        f77 = (-0.5411961 * f47);
        f78 = (0.9238795 * f76);
        f79 = (1.306563 * f45);
        f80 = f77 + f78;
        f81 = f79 - f78;
        f82 = f46 + f44;
        f83 = (1.306563 * f46);
        f84 = (-0.38268343 * f82);
        f85 = (0.5411961 * f44);
        f86 = f83 + f84;
        f87 = f85 - f84;
        f88 = f55 + f53;
        f89 = (-0.5411961 * f55);
        f90 = (0.9238795 * f88);
        f91 = (1.306563 * f53);
        f92 = f89 + f90;
        f93 = f91 - f90;
        f94 = f54 + f52;
        f95 = (1.306563 * f54);
        f96 = (-0.38268343 * f94);
        f97 = (0.5411961 * f52);
        f98 = f95 + f96;
        f99 = f97 - f96;
        f100 = f63 + f61;
        f101 = (-0.5411961 * f63);
        f102 = (0.9238795 * f100);
        f103 = (1.306563 * f61);
        f104 = f101 + f102;
        f105 = f103 - f102;
        f106 = f62 + f60;
        f107 = (1.306563 * f62);
        f108 = (-0.38268343 * f106);
        f109 = (0.5411961 * f60);
        f110 = f107 + f108;
        f111 = f109 - f108;
        f112 = f33 - f68;
        f113 = f33 + f68;
        f114 = f35 - f69;
        f115 = f35 + f69;
        f116 = f32 - f74;
        f117 = f32 + f74;
        f118 = f34 - f75;
        f119 = f34 + f75;
        f120 = f41 - f80;
        f121 = f41 + f80;
        f122 = f43 - f81;
        f123 = f43 + f81;
        f124 = f40 - f86;
        f125 = f40 + f86;
        f126 = f42 - f87;
        f127 = f42 + f87;
        f128 = f49 - f92;
        f129 = f49 + f92;
        f130 = f51 - f93;
        f131 = f51 + f93;
        f132 = f48 - f98;
        f133 = f48 + f98;
        f134 = f50 - f99;
        f135 = f50 + f99;
        f136 = f57 - f104;
        f137 = f57 + f104;
        f138 = f59 - f105;
        f139 = f59 + f105;
        f140 = f56 - f110;
        f141 = f56 + f110;
        f142 = f58 - f111;
        f143 = f58 + f111;
        f144 = f123 + f121;
        f145 = (-0.78569496 * f123);
        f146 = (0.98078525 * f144);
        f147 = (1.1758755 * f121);
        f148 = f145 + f146;
        f149 = f147 - f146;
        f150 = f127 + f125;
        f151 = (0.27589938 * f127);
        f152 = (0.55557024 * f150);
        f153 = (1.3870399 * f125);
        f154 = f151 + f152;
        f155 = f153 - f152;
        f156 = f122 + f120;
        f157 = (1.1758755 * f122);
        f158 = (-0.19509032 * f156);
        f159 = (0.78569496 * f120);
        f160 = f157 + f158;
        f161 = f159 - f158;
        f162 = f126 + f124;
        f163 = (1.3870399 * f126);
        f164 = (-0.8314696 * f162);
        f165 = (-0.27589938 * f124);
        f166 = f163 + f164;
        f167 = f165 - f164;
        f168 = f139 + f137;
        f169 = (-0.78569496 * f139);
        f170 = (0.98078525 * f168);
        f171 = (1.1758755 * f137);
        f172 = f169 + f170;
        f173 = f171 - f170;
        f174 = f143 + f141;
        f175 = (0.27589938 * f143);
        f176 = (0.55557024 * f174);
        f177 = (1.3870399 * f141);
        f178 = f175 + f176;
        f179 = f177 - f176;
        f180 = f138 + f136;
        f181 = (1.1758755 * f138);
        f182 = (-0.19509032 * f180);
        f183 = (0.78569496 * f136);
        f184 = f181 + f182;
        f185 = f183 - f182;
        f186 = f142 + f140;
        f187 = (1.3870399 * f142);
        f188 = (-0.8314696 * f186);
        f189 = (-0.27589938 * f140);
        f190 = f187 + f188;
        f191 = f189 - f188;
        f192 = f113 - f148;
        f193 = f113 + f148;
        f194 = f115 - f149;
        f195 = f115 + f149;
        f196 = f117 - f154;
        f197 = f117 + f154;
        f198 = f119 - f155;
        f199 = f119 + f155;
        f200 = f112 - f160;
        f201 = f112 + f160;
        f202 = f114 - f161;
        f203 = f114 + f161;
        f204 = f116 - f166;
        f205 = f116 + f166;
        f206 = f118 - f167;
        f207 = f118 + f167;
        f208 = f129 - f172;
        f209 = f129 + f172;
        f210 = f131 - f173;
        f211 = f131 + f173;
        f212 = f133 - f178;
        f213 = f133 + f178;
        f214 = f135 - f179;
        f215 = f135 + f179;
        f216 = f128 - f184;
        f217 = f128 + f184;
        f218 = f130 - f185;
        f219 = f130 + f185;
        f220 = f132 - f190;
        f221 = f132 + f190;
        f222 = f134 - f191;
        f223 = f134 + f191;
        f224 = f211 + f209;
        f225 = (-0.89716756 * f211);
        f226 = (0.9951847 * f224);
        f227 = (1.0932019 * f209);
        f228 = f225 + f226;
        f229 = f227 - f226;
        f230 = f215 + f213;
        f231 = (-0.41052452 * f215);
        f232 = (0.8819213 * f230);
        f233 = (1.353318 * f213);
        f234 = f231 + f232;
        f235 = f233 - f232;
        f236 = f219 + f217;
        f237 = (0.13861717 * f219);
        f238 = (0.6343933 * f236);
        f239 = (1.4074037 * f217);
        f240 = f237 + f238;
        f241 = f239 - f238;
        f242 = f223 + f221;
        f243 = (0.66665566 * f223);
        f244 = (0.29028466 * f242);
        f245 = (1.247225 * f221);
        f246 = f243 + f244;
        f247 = f245 - f244;
        f248 = f210 + f208;
        f249 = (1.0932019 * f210);
        f250 = (-0.09801714 * f248);
        f251 = (0.89716756 * f208);
        f252 = f249 + f250;
        f253 = f251 - f250;
        f254 = f214 + f212;
        f255 = (1.353318 * f214);
        f256 = (-0.47139674 * f254);
        f257 = (0.41052452 * f212);
        f258 = f255 + f256;
        f259 = f257 - f256;
        f260 = f218 + f216;
        f261 = (1.4074037 * f218);
        f262 = (-0.77301043 * f260);
        f263 = (-0.13861717 * f216);
        f264 = f261 + f262;
        f265 = f263 - f262;
        f266 = f222 + f220;
        f267 = (1.247225 * f222);
        f268 = (-0.95694035 * f266);
        f269 = (-0.66665566 * f220);
        f270 = f267 + f268;
        f271 = f269 - f268;
        f272 = f193 - f228;
        f273 = f193 + f228;
        f274 = f195 - f229;
        f275 = f195 + f229;
        f276 = f197 - f234;
        f277 = f197 + f234;
        f278 = f199 - f235;
        f279 = f199 + f235;
        f280 = f201 - f240;
        f281 = f201 + f240;
        f282 = f203 - f241;
        f283 = f203 + f241;
        f284 = f205 - f246;
        f285 = f205 + f246;
        f286 = f207 - f247;
        f287 = f207 + f247;
        f288 = f192 - f252;
        f289 = f192 + f252;
        f290 = f194 - f253;
        f291 = f194 + f253;
        f292 = f196 - f258;
        f293 = f196 + f258;
        f294 = f198 - f259;
        f295 = f198 + f259;
        f296 = f200 - f264;
        f297 = f200 + f264;
        f298 = f202 - f265;
        f299 = f202 + f265;
        f300 = f204 - f270;
        f301 = f204 + f270;
        f302 = f206 - f271;
        f303 = f206 + f271;
        f304 = f275 + f273;
        f305 = (-0.9751576 * f275);
        f306 = (0.9996988 * f304);
        f307 = (1.02424 * f273);
        y[0] = f305 + f306;
        y[31] = f307 - f306;
        f310 = f279 + f277;
        f311 = (-0.87006885 * f279);
        f312 = (0.99247956 * f310);
        f313 = (1.1148902 * f277);
        y[2] = f311 + f312;
        y[29] = f313 - f312;
        f316 = f283 + f281;
        f317 = (-0.7566009 * f283);
        f318 = (0.9757021 * f316);
        f319 = (1.1948034 * f281);
        y[4] = f317 + f318;
        y[27] = f319 - f318;
        f322 = f287 + f285;
        f323 = (-0.63584644 * f287);
        f324 = (0.94952816 * f322);
        f325 = (1.2632099 * f285);
        y[6] = f323 + f324;
        y[25] = f325 - f324;
        f328 = f291 + f289;
        f329 = (-0.5089684 * f291);
        f330 = (0.9142098 * f328);
        f331 = (1.3194511 * f289);
        y[8] = f329 + f330;
        y[23] = f331 - f330;
        f334 = f295 + f293;
        f335 = (-0.3771888 * f295);
        f336 = (0.87008697 * f334);
        f337 = (1.3629851 * f293);
        y[10] = f335 + f336;
        y[21] = f337 - f336;
        f340 = f299 + f297;
        f341 = (-0.24177662 * f299);
        f342 = (0.8175848 * f340);
        f343 = (1.393393 * f297);
        y[12] = f341 + f342;
        y[19] = f343 - f342;
        f346 = f303 + f301;
        f347 = (-0.104036 * f303);
        f348 = (0.7572088 * f346);
        f349 = (1.4103817 * f301);
        y[14] = f347 + f348;
        y[17] = f349 - f348;
        f352 = f274 + f272;
        f353 = (0.034706537 * f274);
        f354 = (0.68954057 * f352);
        f355 = (1.4137876 * f272);
        y[16] = f353 + f354;
        y[15] = f355 - f354;
        f358 = f278 + f276;
        f359 = (0.17311484 * f278);
        f360 = (0.6152316 * f358);
        f361 = (1.403578 * f276);
        y[18] = f359 + f360;
        y[13] = f361 - f360;
        f364 = f282 + f280;
        f365 = (0.30985594 * f282);
        f366 = (0.53499764 * f364);
        f367 = (1.3798512 * f280);
        y[20] = f365 + f366;
        y[11] = f367 - f366;
        f370 = f286 + f284;
        f371 = (0.44361296 * f286);
        f372 = (0.44961134 * f370);
        f373 = (1.3428357 * f284);
        y[22] = f371 + f372;
        y[9] = f373 - f372;
        f376 = f290 + f288;
        f377 = (0.57309777 * f290);
        f378 = (0.35989505 * f376);
        f379 = (1.2928878 * f288);
        y[24] = f377 + f378;
        y[7] = f379 - f378;
        f382 = f294 + f292;
        f383 = (0.6970633 * f294);
        f384 = (0.26671275 * f382);
        f385 = (1.2304888 * f292);
        y[26] = f383 + f384;
        y[5] = f385 - f384;
        f388 = f298 + f296;
        f389 = (0.81431574 * f298);
        f390 = (0.17096189 * f388);
        f391 = (1.1562395 * f296);
        y[28] = f389 + f390;
        y[3] = f391 - f390;
        f394 = f302 + f300;
        f395 = (0.9237259 * f302);
        f396 = (0.07356457 * f394);
        f397 = (1.070855 * f300);
        y[30] = f395 + f396;
        y[1] = f397 - f396;
    };
    prototype.DST4_32 = function(y, x) {
        var f0, f1, f2, f3, f4, f5, f6, f7, f8, f9;
        var f10, f11, f12, f13, f14, f15, f16, f17, f18, f19;
        var f20, f21, f22, f23, f24, f25, f26, f27, f28, f29;
        var f30, f31, f32, f33, f34, f35, f36, f37, f38, f39;
        var f40, f41, f42, f43, f44, f45, f46, f47, f48, f49;
        var f50, f51, f52, f53, f54, f55, f56, f57, f58, f59;
        var f60, f61, f62, f63, f64, f65, f66, f67, f68, f69;
        var f70, f71, f72, f73, f74, f75, f76, f77, f78, f79;
        var f80, f81, f82, f83, f84, f85, f86, f87, f88, f89;
        var f90, f91, f92, f93, f94, f95, f96, f97, f98, f99;
        var f100, f101, f102, f103, f104, f105, f106, f107, f108, f109;
        var f110, f111, f112, f113, f114, f115, f116, f117, f118, f119;
        var f120, f121, f122, f123, f124, f125, f126, f127, f128, f129;
        var f130, f131, f132, f133, f134, f135, f136, f137, f138, f139;
        var f140, f141, f142, f143, f144, f145, f146, f147, f148, f149;
        var f150, f151, f152, f153, f154, f155, f156, f157, f158, f159;
        var f160, f161, f162, f163, f164, f165, f166, f167, f168, f169;
        var f170, f171, f172, f173, f174, f175, f176, f177, f178, f179;
        var f180, f181, f182, f183, f184, f185, f186, f187, f188, f189;
        var f190, f191, f192, f193, f194, f195, f196, f197, f198, f199;
        var f200, f201, f202, f203, f204, f205, f206, f207, f208, f209;
        var f210, f211, f212, f213, f214, f215, f216, f217, f218, f219;
        var f220, f221, f222, f223, f224, f225, f226, f227, f228, f229;
        var f230, f231, f232, f233, f234, f235, f236, f237, f238, f239;
        var f240, f241, f242, f243, f244, f245, f246, f247, f248, f249;
        var f250, f251, f252, f253, f254, f255, f256, f257, f258, f259;
        var f260, f261, f262, f263, f264, f265, f266, f267, f268, f269;
        var f270, f271, f272, f273, f274, f275, f276, f277, f278, f279;
        var f280, f281, f282, f283, f284, f285, f286, f287, f288, f289;
        var f290, f291, f292, f293, f294, f295, f296, f297, f298, f299;
        var f300, f301, f302, f303, f304, f305, f306, f307, f308, f309;
        var f310, f311, f312, f313, f314, f315, f316, f317, f318, f319;
        var f320, f321, f322, f323, f324, f325, f326, f327, f328, f329;
        var f330, f331, f332, f333, f334, f335;
        f0 = x[0] - x[1];
        f1 = x[2] - x[1];
        f2 = x[2] - x[3];
        f3 = x[4] - x[3];
        f4 = x[4] - x[5];
        f5 = x[6] - x[5];
        f6 = x[6] - x[7];
        f7 = x[8] - x[7];
        f8 = x[8] - x[9];
        f9 = x[10] - x[9];
        f10 = x[10] - x[11];
        f11 = x[12] - x[11];
        f12 = x[12] - x[13];
        f13 = x[14] - x[13];
        f14 = x[14] - x[15];
        f15 = x[16] - x[15];
        f16 = x[16] - x[17];
        f17 = x[18] - x[17];
        f18 = x[18] - x[19];
        f19 = x[20] - x[19];
        f20 = x[20] - x[21];
        f21 = x[22] - x[21];
        f22 = x[22] - x[23];
        f23 = x[24] - x[23];
        f24 = x[24] - x[25];
        f25 = x[26] - x[25];
        f26 = x[26] - x[27];
        f27 = x[28] - x[27];
        f28 = x[28] - x[29];
        f29 = x[30] - x[29];
        f30 = x[30] - x[31];
        f31 = (0.70710677 * f15);
        f32 = x[0] - f31;
        f33 = x[0] + f31;
        f34 = f7 + f23;
        f35 = (1.306563 * f7);
        f36 = (-0.9238795 * f34);
        f37 = (-0.5411961 * f23);
        f38 = f35 + f36;
        f39 = f37 - f36;
        f40 = f33 - f39;
        f41 = f33 + f39;
        f42 = f32 - f38;
        f43 = f32 + f38;
        f44 = f11 - f19;
        f45 = f11 + f19;
        f46 = (0.70710677 * f45);
        f47 = f3 - f46;
        f48 = f3 + f46;
        f49 = (0.70710677 * f44);
        f50 = f49 - f27;
        f51 = f49 + f27;
        f52 = f51 + f48;
        f53 = (-0.78569496 * f51);
        f54 = (0.98078525 * f52);
        f55 = (1.1758755 * f48);
        f56 = f53 + f54;
        f57 = f55 - f54;
        f58 = f50 + f47;
        f59 = (-0.27589938 * f50);
        f60 = (0.8314696 * f58);
        f61 = (1.3870399 * f47);
        f62 = f59 + f60;
        f63 = f61 - f60;
        f64 = f41 - f56;
        f65 = f41 + f56;
        f66 = f43 - f62;
        f67 = f43 + f62;
        f68 = f42 - f63;
        f69 = f42 + f63;
        f70 = f40 - f57;
        f71 = f40 + f57;
        f72 = f5 - f9;
        f73 = f5 + f9;
        f74 = f13 - f17;
        f75 = f13 + f17;
        f76 = f21 - f25;
        f77 = f21 + f25;
        f78 = (0.70710677 * f75);
        f79 = f1 - f78;
        f80 = f1 + f78;
        f81 = f73 + f77;
        f82 = (1.306563 * f73);
        f83 = (-0.9238795 * f81);
        f84 = (-0.5411961 * f77);
        f85 = f82 + f83;
        f86 = f84 - f83;
        f87 = f80 - f86;
        f88 = f80 + f86;
        f89 = f79 - f85;
        f90 = f79 + f85;
        f91 = (0.70710677 * f74);
        f92 = f29 - f91;
        f93 = f29 + f91;
        f94 = f76 + f72;
        f95 = (1.306563 * f76);
        f96 = (-0.9238795 * f94);
        f97 = (-0.5411961 * f72);
        f98 = f95 + f96;
        f99 = f97 - f96;
        f100 = f93 - f99;
        f101 = f93 + f99;
        f102 = f92 - f98;
        f103 = f92 + f98;
        f104 = f101 + f88;
        f105 = (-0.89716756 * f101);
        f106 = (0.9951847 * f104);
        f107 = (1.0932019 * f88);
        f108 = f105 + f106;
        f109 = f107 - f106;
        f110 = f90 - f103;
        f111 = (-0.66665566 * f103);
        f112 = (0.95694035 * f110);
        f113 = (1.247225 * f90);
        f114 = f112 - f111;
        f115 = f113 - f112;
        f116 = f102 + f89;
        f117 = (-0.41052452 * f102);
        f118 = (0.8819213 * f116);
        f119 = (1.353318 * f89);
        f120 = f117 + f118;
        f121 = f119 - f118;
        f122 = f87 - f100;
        f123 = (-0.13861717 * f100);
        f124 = (0.77301043 * f122);
        f125 = (1.4074037 * f87);
        f126 = f124 - f123;
        f127 = f125 - f124;
        f128 = f65 - f108;
        f129 = f65 + f108;
        f130 = f67 - f114;
        f131 = f67 + f114;
        f132 = f69 - f120;
        f133 = f69 + f120;
        f134 = f71 - f126;
        f135 = f71 + f126;
        f136 = f70 - f127;
        f137 = f70 + f127;
        f138 = f68 - f121;
        f139 = f68 + f121;
        f140 = f66 - f115;
        f141 = f66 + f115;
        f142 = f64 - f109;
        f143 = f64 + f109;
        f144 = f0 + f30;
        f145 = (1.0478631 * f0);
        f146 = (-0.99879545 * f144);
        f147 = (-0.9497278 * f30);
        f148 = f145 + f146;
        f149 = f147 - f146;
        f150 = f4 + f26;
        f151 = (1.2130114 * f4);
        f152 = (-0.97003126 * f150);
        f153 = (-0.7270511 * f26);
        f154 = f151 + f152;
        f155 = f153 - f152;
        f156 = f8 + f22;
        f157 = (1.3315444 * f8);
        f158 = (-0.9039893 * f156);
        f159 = (-0.4764342 * f22);
        f160 = f157 + f158;
        f161 = f159 - f158;
        f162 = f12 + f18;
        f163 = (1.3989068 * f12);
        f164 = (-0.8032075 * f162);
        f165 = (-0.20750822 * f18);
        f166 = f163 + f164;
        f167 = f165 - f164;
        f168 = f16 + f14;
        f169 = (1.41251 * f16);
        f170 = (-0.671559 * f168);
        f171 = (0.06939217 * f14);
        f172 = f169 + f170;
        f173 = f171 - f170;
        f174 = f20 + f10;
        f175 = (1.3718313 * f20);
        f176 = (-0.51410276 * f174);
        f177 = (0.34362587 * f10);
        f178 = f175 + f176;
        f179 = f177 - f176;
        f180 = f24 + f6;
        f181 = (1.2784339 * f24);
        f182 = (-0.33688986 * f180);
        f183 = (0.6046542 * f6);
        f184 = f181 + f182;
        f185 = f183 - f182;
        f186 = f28 + f2;
        f187 = (1.1359069 * f28);
        f188 = (-0.14673047 * f186);
        f189 = (0.842446 * f2);
        f190 = f187 + f188;
        f191 = f189 - f188;
        f192 = f149 - f173;
        f193 = f149 + f173;
        f194 = f148 - f172;
        f195 = f148 + f172;
        f196 = f155 - f179;
        f197 = f155 + f179;
        f198 = f154 - f178;
        f199 = f154 + f178;
        f200 = f161 - f185;
        f201 = f161 + f185;
        f202 = f160 - f184;
        f203 = f160 + f184;
        f204 = f167 - f191;
        f205 = f167 + f191;
        f206 = f166 - f190;
        f207 = f166 + f190;
        f208 = f192 + f194;
        f209 = (1.1758755 * f192);
        f210 = (-0.98078525 * f208);
        f211 = (-0.78569496 * f194);
        f212 = f209 + f210;
        f213 = f211 - f210;
        f214 = f196 + f198;
        f215 = (1.3870399 * f196);
        f216 = (-0.55557024 * f214);
        f217 = (0.27589938 * f198);
        f218 = f215 + f216;
        f219 = f217 - f216;
        f220 = f200 + f202;
        f221 = (0.78569496 * f200);
        f222 = (0.19509032 * f220);
        f223 = (1.1758755 * f202);
        f224 = f221 + f222;
        f225 = f223 - f222;
        f226 = f204 + f206;
        f227 = (-0.27589938 * f204);
        f228 = (0.8314696 * f226);
        f229 = (1.3870399 * f206);
        f230 = f227 + f228;
        f231 = f229 - f228;
        f232 = f193 - f201;
        f233 = f193 + f201;
        f234 = f195 - f203;
        f235 = f195 + f203;
        f236 = f197 - f205;
        f237 = f197 + f205;
        f238 = f199 - f207;
        f239 = f199 + f207;
        f240 = f213 - f225;
        f241 = f213 + f225;
        f242 = f212 - f224;
        f243 = f212 + f224;
        f244 = f219 - f231;
        f245 = f219 + f231;
        f246 = f218 - f230;
        f247 = f218 + f230;
        f248 = f232 + f234;
        f249 = (1.306563 * f232);
        f250 = (-0.9238795 * f248);
        f251 = (-0.5411961 * f234);
        f252 = f249 + f250;
        f253 = f251 - f250;
        f254 = f236 + f238;
        f255 = (0.5411961 * f236);
        f256 = (0.38268343 * f254);
        f257 = (1.306563 * f238);
        f258 = f255 + f256;
        f259 = f257 - f256;
        f260 = f240 + f242;
        f261 = (1.306563 * f240);
        f262 = (-0.9238795 * f260);
        f263 = (-0.5411961 * f242);
        f264 = f261 + f262;
        f265 = f263 - f262;
        f266 = f244 + f246;
        f267 = (0.5411961 * f244);
        f268 = (0.38268343 * f266);
        f269 = (1.306563 * f246);
        f270 = f267 + f268;
        f271 = f269 - f268;
        f272 = f233 - f237;
        f273 = f233 + f237;
        f274 = f235 - f239;
        f275 = f235 + f239;
        f276 = f253 - f259;
        f277 = f253 + f259;
        f278 = f252 - f258;
        f279 = f252 + f258;
        f280 = f241 - f245;
        f281 = f241 + f245;
        f282 = f243 - f247;
        f283 = f243 + f247;
        f284 = f265 - f271;
        f285 = f265 + f271;
        f286 = f264 - f270;
        f287 = f264 + f270;
        f288 = f272 - f274;
        f289 = f272 + f274;
        f290 = (0.70710677 * f288);
        f291 = (0.70710677 * f289);
        f292 = f276 - f278;
        f293 = f276 + f278;
        f294 = (0.70710677 * f292);
        f295 = (0.70710677 * f293);
        f296 = f280 - f282;
        f297 = f280 + f282;
        f298 = (0.70710677 * f296);
        f299 = (0.70710677 * f297);
        f300 = f284 - f286;
        f301 = f284 + f286;
        f302 = (0.70710677 * f300);
        f303 = (0.70710677 * f301);
        f304 = f129 - f273;
        f305 = f129 + f273;
        f306 = f131 - f281;
        f307 = f131 + f281;
        f308 = f133 - f285;
        f309 = f133 + f285;
        f310 = f135 - f277;
        f311 = f135 + f277;
        f312 = f137 - f295;
        f313 = f137 + f295;
        f314 = f139 - f303;
        f315 = f139 + f303;
        f316 = f141 - f299;
        f317 = f141 + f299;
        f318 = f143 - f291;
        f319 = f143 + f291;
        f320 = f142 - f290;
        f321 = f142 + f290;
        f322 = f140 - f298;
        f323 = f140 + f298;
        f324 = f138 - f302;
        f325 = f138 + f302;
        f326 = f136 - f294;
        f327 = f136 + f294;
        f328 = f134 - f279;
        f329 = f134 + f279;
        f330 = f132 - f287;
        f331 = f132 + f287;
        f332 = f130 - f283;
        f333 = f130 + f283;
        f334 = f128 - f275;
        f335 = f128 + f275;
        y[31] = (0.5001506 * f305);
        y[30] = (0.50135845 * f307);
        y[29] = (0.5037887 * f309);
        y[28] = (0.50747114 * f311);
        y[27] = (0.51245147 * f313);
        y[26] = (0.5187927 * f315);
        y[25] = (0.5265773 * f317);
        y[24] = (0.53590983 * f319);
        y[23] = (0.5469204 * f321);
        y[22] = (0.5597698 * f323);
        y[21] = (0.5746552 * f325);
        y[20] = (0.5918185 * f327);
        y[19] = (0.61155736 * f329);
        y[18] = (0.63423896 * f331);
        y[17] = (0.6603198 * f333);
        y[16] = (0.6903721 * f335);
        y[15] = (0.72512054 * f334);
        y[14] = (0.76549417 * f332);
        y[13] = (0.8127021 * f330);
        y[12] = (0.8683447 * f328);
        y[11] = (0.9345836 * f326);
        y[10] = (1.0144082 * f324);
        y[9] = (1.1120716 * f322);
        y[8] = (1.2338327 * f320);
        y[7] = (1.3892939 * f318);
        y[6] = (1.5939723 * f316);
        y[5] = (1.874676 * f314);
        y[4] = (2.2820501 * f312);
        y[3] = (2.9246285 * f310);
        y[2] = (4.084611 * f308);
        y[1] = (6.7967505 * f306);
        y[0] = (20.373878 * f304);
    };
}, {qmf32_pre_twiddle: "Array", v: "Float32Array", qmf_c: "Float32Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 * 
 *  @author in-somnia
 */
var AnalysisFilterbank = function(channels) {
    this.channels = channels;
    this.x = new Float32Array(2 * channels * 10);
    this.x_index = 0;
};
AnalysisFilterbank = stjs.extend(AnalysisFilterbank, null, [FilterbankTable], function(constructor, prototype) {
    prototype.x = null;
    prototype.x_index = 0;
    prototype.channels = 0;
    prototype.reset = function() {
        Arrays.fill(this.x, 0);
    };
    prototype.sbr_qmf_analysis_32 = function(sbr, input, X, offset, kx) {
        var u = new Float32Array(64);
        var in_real = new Float32Array(32), in_imag = new Float32Array(32);
        var out_real = new Float32Array(32), out_imag = new Float32Array(32);
        var _in = 0;
        var l;
        for (l = 0; l < sbr.numTimeSlotsRate; l++) {
            var n;
            for (n = 32 - 1; n >= 0; n--) {
                this.x[this.x_index + n] = this.x[this.x_index + n + 320] = input[_in++];
            }
            for (n = 0; n < 64; n++) {
                u[n] = (this.x[this.x_index + n] * FilterbankTable.qmf_c[2 * n]) + (this.x[this.x_index + n + 64] * FilterbankTable.qmf_c[2 * (n + 64)]) + (this.x[this.x_index + n + 128] * FilterbankTable.qmf_c[2 * (n + 128)]) + (this.x[this.x_index + n + 192] * FilterbankTable.qmf_c[2 * (n + 192)]) + (this.x[this.x_index + n + 256] * FilterbankTable.qmf_c[2 * (n + 256)]);
            }
            this.x_index -= 32;
            if (this.x_index < 0) 
                this.x_index = (320 - 32);
            in_imag[31] = u[1];
            in_real[0] = u[0];
            for (n = 1; n < 31; n++) {
                in_imag[31 - n] = u[n + 1];
                in_real[n] = -u[64 - n];
            }
            in_imag[0] = u[32];
            in_real[31] = -u[33];
            DCT.dct4_kernel(in_real, in_imag, out_real, out_imag);
            for (n = 0; n < 16; n++) {
                if (2 * n + 1 < kx) {
                    X[l + offset][2 * n][0] = 2.0 * out_real[n];
                    X[l + offset][2 * n][1] = 2.0 * out_imag[n];
                    X[l + offset][2 * n + 1][0] = -2.0 * out_imag[31 - n];
                    X[l + offset][2 * n + 1][1] = -2.0 * out_real[31 - n];
                } else {
                    if (2 * n < kx) {
                        X[l + offset][2 * n][0] = 2.0 * out_real[n];
                        X[l + offset][2 * n][1] = 2.0 * out_imag[n];
                    } else {
                        X[l + offset][2 * n][0] = 0;
                        X[l + offset][2 * n][1] = 0;
                    }
                    X[l + offset][2 * n + 1][0] = 0;
                    X[l + offset][2 * n + 1][1] = 0;
                }
            }
        }
    };
}, {x: "Float32Array", qmf_c: "Float32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Just stores log messages to be extracted at later point
 *  
 *  @author The JCodec project
 */
var BufferLogSink = function() {
    this.messages = new LinkedList();
};
BufferLogSink = stjs.extend(BufferLogSink, null, [LogSink], function(constructor, prototype) {
    prototype.messages = null;
    prototype.postMessage = function(msg) {
        this.messages.add(msg);
    };
    prototype.getMessages = function() {
        return this.messages;
    };
}, {messages: {name: "List", arguments: ["Message"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  H264 CABAC M-encoder
 *  
 *  @author The JCodec project
 *  
 */
var MEncoder = function(out, models) {
    this.range = 510;
    this.models = models;
    this.out = out;
};
MEncoder = stjs.extend(MEncoder, null, [], function(constructor, prototype) {
    prototype.out = null;
    prototype.range = 0;
    prototype.offset = 0;
    prototype.onesOutstanding = 0;
    prototype.zeroBorrowed = false;
    prototype.outReg = 0;
    prototype.bitsInOutReg = 0;
    prototype.models = null;
    /**
     *  Encodes one bin in normal mode using supplied context model
     *  
     *  @param bin
     *  @param cm
     *  @throws IOException
     */
    prototype.encodeBin = function(model, bin) {
        var qs = (this.range >> 6) & 3;
        var rangeLPS = MConst.rangeLPS[qs][this.models[0][model]];
        this.range -= rangeLPS;
        if (bin != this.models[1][model]) {
            this.offset += this.range;
            this.range = rangeLPS;
            if (this.models[0][model] == 0) 
                this.models[1][model] = 1 - this.models[1][model];
            this.models[0][model] = MConst.transitLPS[this.models[0][model]];
        } else {
            if (this.models[0][model] < 62) 
                this.models[0][model]++;
        }
        this.renormalize();
    };
    /**
     *  Codes one bin in bypass mode for symbols with uniform probability
     *  distribution
     *  
     *  @param bin
     *  @throws IOException
     */
    prototype.encodeBinBypass = function(bin) {
        this.offset <<= 1;
        if (bin == 1) {
            this.offset += this.range;
        }
        if ((this.offset & 1024) != 0) {
            this.flushOutstanding(1);
            this.offset &= 1023;
        } else if ((this.offset & 512) != 0) {
            this.offset &= 511;
            ++this.onesOutstanding;
        } else {
            this.flushOutstanding(0);
        }
    };
    /**
     *  Codes termination flag. Range for LPS is preset to be 2
     *  
     *  @param bin
     *  @throws IOException
     */
    prototype.encodeBinFinal = function(bin) {
        this.range -= 2;
        if (bin == 0) {
            this.renormalize();
        } else {
            this.offset += this.range;
            this.range = 2;
            this.renormalize();
        }
    };
    prototype.finishEncoding = function() {
        this.flushOutstanding((this.offset >> 9) & 1);
        this.putBit((this.offset >> 8) & 1);
        this.stuffBits();
    };
    prototype.renormalize = function() {
         while (this.range < 256){
            if (this.offset < 256) {
                this.flushOutstanding(0);
            } else if (this.offset < 512) {
                this.offset &= 255;
                ++this.onesOutstanding;
            } else {
                this.offset &= 511;
                this.flushOutstanding(1);
            }
            this.range <<= 1;
            this.offset <<= 1;
        }
    };
    prototype.flushOutstanding = function(hasCarry) {
        if (this.zeroBorrowed) 
            this.putBit(hasCarry);
        var trailingBit = 1 - hasCarry;
        for (; this.onesOutstanding > 0; this.onesOutstanding--) 
            this.putBit(trailingBit);
        this.zeroBorrowed = true;
    };
    prototype.putBit = function(bit) {
        this.outReg = (this.outReg << 1) | bit;
        ++this.bitsInOutReg;
        if (this.bitsInOutReg == 8) {
            this.out.put((this.outReg << 24 >> 24));
            this.outReg = 0;
            this.bitsInOutReg = 0;
        }
    };
    prototype.stuffBits = function() {
        if (this.bitsInOutReg == 0) {
            this.out.put((128 << 24 >> 24));
        } else {
            this.outReg = (this.outReg << 1) | 1;
            this.outReg <<= (8 - (this.bitsInOutReg + 1));
            this.out.put((this.outReg << 24 >> 24));
            this.outReg = 0;
            this.bitsInOutReg = 0;
        }
    };
}, {out: "ByteBuffer", models: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  H264 CABAC M-Coder ( decoder module )
 *  
 *  @author The JCodec project
 *  
 */
var MDecoder = function(_in, cm) {
    this._in = _in;
    this.range = 510;
    this.cm = cm;
    this.initCodeRegister();
};
MDecoder = stjs.extend(MDecoder, null, [], function(constructor, prototype) {
    prototype._in = null;
    prototype.range = 0;
    prototype.code = 0;
    prototype.nBitsPending = 0;
    prototype.cm = null;
    /**
     *  Initializes code register. Loads 9 bits from the stream into working area
     *  of code register ( bits 8 - 16) leaving 7 bits in the pending area of
     *  code register (bits 0 - 7)
     *  
     *  @throws IOException
     */
    prototype.initCodeRegister = function() {
        this.readOneByte();
        if (this.nBitsPending != 8) 
             throw new RuntimeException("Empty stream");
        this.code <<= 8;
        this.readOneByte();
        this.code <<= 1;
        this.nBitsPending -= 9;
    };
    prototype.readOneByte = function() {
        if (!this._in.hasRemaining()) 
            return;
        var b = this._in.get() & 255;
        this.code |= b;
        this.nBitsPending += 8;
    };
    /**
     *  Decodes one bin from arithmetice code word
     *  
     *  @param cm
     *  @return
     *  @throws IOException
     */
    prototype.decodeBin = function(m) {
        var bin;
        var qIdx = (this.range >> 6) & 3;
        var rLPS = MConst.rangeLPS[qIdx][this.cm[0][m]];
        this.range -= rLPS;
        var rs8 = this.range << 8;
        if (this.code < rs8) {
            if (this.cm[0][m] < 62) 
                this.cm[0][m]++;
            this.renormalize();
            bin = this.cm[1][m];
        } else {
            this.range = rLPS;
            this.code -= rs8;
            this.renormalize();
            bin = 1 - this.cm[1][m];
            if (this.cm[0][m] == 0) 
                this.cm[1][m] = 1 - this.cm[1][m];
            this.cm[0][m] = MConst.transitLPS[this.cm[0][m]];
        }
        return bin;
    };
    /**
     *  Special decoding process for 'end of slice' flag. Uses probability state
     *  63.
     *  
     *  @param cm
     *  @return
     *  @throws IOException
     */
    prototype.decodeFinalBin = function() {
        this.range -= 2;
        if (this.code < (this.range << 8)) {
            this.renormalize();
            return 0;
        } else {
            return 1;
        }
    };
    /**
     *  Special decoding process for symbols with uniform distribution
     *  
     *  @return
     *  @throws IOException
     */
    prototype.decodeBinBypass = function() {
        this.code <<= 1;
        --this.nBitsPending;
        if (this.nBitsPending <= 0) 
            this.readOneByte();
        var tmp = this.code - (this.range << 8);
        if (tmp < 0) {
            return 0;
        } else {
            this.code = tmp;
            return 1;
        }
    };
    /**
     *  Shifts the current interval to either 1/2 or 0 (code = (code << 1) &
     *  0x1ffff) and scales it by 2 (range << 1).
     *  
     *  Reads new byte from the input stream into code value if there are no more
     *  bits pending
     *  
     *  @throws IOException
     */
    prototype.renormalize = function() {
         while (this.range < 256){
            this.range <<= 1;
            this.code <<= 1;
            this.code &= 131071;
            --this.nBitsPending;
            if (this.nBitsPending <= 0) 
                this.readOneByte();
        }
    };
}, {_in: "ByteBuffer", cm: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var S302MUtils = function() {};
S302MUtils = stjs.extend(S302MUtils, null, [], function(constructor, prototype) {
    constructor.name = function(channels) {
        switch (channels) {
            case 1:
                return "Mono";
            case 2:
                return "Stereo 2.0";
            case 4:
                return "Surround 4.0";
            case 8:
                return "Stereo 2.0 + Surround 5.1";
        }
        return null;
    };
    constructor.labels = function(channels) {
        switch (channels) {
            case 1:
                return [ChannelLabel.MONO];
            case 2:
                return [ChannelLabel.STEREO_LEFT, ChannelLabel.STEREO_RIGHT];
            case 4:
                return [ChannelLabel.FRONT_LEFT, ChannelLabel.FRONT_RIGHT, ChannelLabel.REAR_LEFT, ChannelLabel.REAR_RIGHT];
            case 8:
                return [ChannelLabel.STEREO_LEFT, ChannelLabel.STEREO_RIGHT, ChannelLabel.FRONT_LEFT, ChannelLabel.FRONT_RIGHT, ChannelLabel.REAR_LEFT, ChannelLabel.REAR_RIGHT, ChannelLabel.CENTER, ChannelLabel.LFE];
        }
        return null;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  @author The JCodec project
 */
var AutoPool = function() {
    this.resources = Collections.synchronizedList(new ArrayList());
    this.scheduler = Executors.newScheduledThreadPool(1, this.daemonThreadFactory());
    var res = this.resources;
    this.scheduler.scheduleAtFixedRate(new (stjs.extend(function AutoPool$1() {}, null, [Runnable], function(constructor, prototype) {
        prototype.run = function() {
            var curTime = System.currentTimeMillis();
            for (var iterator$autoResource = res.iterator(); iterator$autoResource.hasNext(); ) {
                var autoResource = iterator$autoResource.next();
                autoResource.setCurTime(curTime);
            }
        };
    }, {}, {}))(), 0, 100, TimeUnit.MILLISECONDS);
};
AutoPool = stjs.extend(AutoPool, null, [], function(constructor, prototype) {
    prototype.resources = null;
    prototype.scheduler = null;
    prototype.daemonThreadFactory = function() {
        return new (stjs.extend(function AutoPool$2() {}, null, [ThreadFactory], function(constructor, prototype) {
            prototype.newThread = function(r) {
                var t = new Thread(r);
                t.setDaemon(true);
                t.setName(AutoPool.getName());
                return t;
            };
        }, {}, {}))();
    };
    constructor.getInstance = function() {
        return AutoPool.instance;
    };
    prototype.add = function(res) {
        this.resources.add(res);
    };
    constructor.instance = new AutoPool();
}, {resources: {name: "List", arguments: ["AutoResource"]}, scheduler: "ScheduledExecutorService", instance: "AutoPool"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var PriorityCallable = function() {};
PriorityCallable = stjs.extend(PriorityCallable, null, [Callable], function(constructor, prototype) {
    prototype.getPriority = function() {};
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var SeekableByteChannel = function() {};
SeekableByteChannel = stjs.extend(SeekableByteChannel, null, [ByteChannel, Channel, Closeable, ReadableByteChannel, WritableByteChannel], function(constructor, prototype) {
    prototype.position = function() {};
    prototype.setPosition = function(newPosition) {};
    prototype.size = function() {};
    prototype.truncate = function(size) {};
}, {}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 * 
 *  @author in-somnia
 */
var HFAdjustment = function() {
    this.G_lim_boost = Array.apply(null, Array(SBRConstants.MAX_L_E)).map(function() {
        return new Float32Array(SBRConstants.MAX_M);
    });
    this.Q_M_lim_boost = Array.apply(null, Array(SBRConstants.MAX_L_E)).map(function() {
        return new Float32Array(SBRConstants.MAX_M);
    });
    this.S_M_boost = Array.apply(null, Array(SBRConstants.MAX_L_E)).map(function() {
        return new Float32Array(SBRConstants.MAX_M);
    });
};
HFAdjustment = stjs.extend(HFAdjustment, null, [SBRConstants, NoiseTable], function(constructor, prototype) {
    constructor.h_smooth = new Float32Array([0.0318305, 0.11516383, 0.2181695, 0.30150282, 0.33333334]);
    constructor.phi_re = new Int32Array([1, 0, -1, 0]);
    constructor.phi_im = new Int32Array([0, 1, 0, -1]);
    constructor.limGain = new Float32Array([0.5, 1.0, 2.0, 1.0E10]);
    constructor.EPS = 1.0E-12;
    prototype.G_lim_boost = null;
    prototype.Q_M_lim_boost = null;
    prototype.S_M_boost = null;
    constructor.hf_adjustment = function(sbr, Xsbr, ch) {
        var adj = new HFAdjustment();
        var ret = 0;
        if (sbr.bs_frame_class[ch] == SBRConstants.FIXFIX) {
            sbr.l_A[ch] = -1;
        } else if (sbr.bs_frame_class[ch] == SBRConstants.VARFIX) {
            if (sbr.bs_pointer[ch] > 1) 
                sbr.l_A[ch] = sbr.bs_pointer[ch] - 1;
             else 
                sbr.l_A[ch] = -1;
        } else {
            if (sbr.bs_pointer[ch] == 0) 
                sbr.l_A[ch] = -1;
             else 
                sbr.l_A[ch] = sbr.L_E[ch] + 1 - sbr.bs_pointer[ch];
        }
        ret = HFAdjustment.estimate_current_envelope(sbr, adj, Xsbr, ch);
        if (ret > 0) 
            return 1;
        HFAdjustment.calculate_gain(sbr, adj, ch);
        HFAdjustment.hf_assembly(sbr, adj, Xsbr, ch);
        return 0;
    };
    constructor.get_S_mapped = function(sbr, ch, l, current_band) {
        if (sbr.f[ch][l] == SBRConstants.HI_RES) {
            if ((l >= sbr.l_A[ch]) || (sbr.bs_add_harmonic_prev[ch][current_band] != 0 && sbr.bs_add_harmonic_flag_prev[ch])) {
                return sbr.bs_add_harmonic[ch][current_band];
            }
        } else {
            var b, lb, ub;
            lb = 2 * current_band - ((sbr.N_high & 1) != 0 ? 1 : 0);
            ub = 2 * (current_band + 1) - ((sbr.N_high & 1) != 0 ? 1 : 0);
            for (b = lb; b < ub; b++) {
                if ((l >= sbr.l_A[ch]) || (sbr.bs_add_harmonic_prev[ch][b] != 0 && sbr.bs_add_harmonic_flag_prev[ch])) {
                    if (sbr.bs_add_harmonic[ch][b] == 1) 
                        return 1;
                }
            }
        }
        return 0;
    };
    constructor.estimate_current_envelope = function(sbr, adj, Xsbr, ch) {
        var m, l, j, k, k_l, k_h, p;
        var nrg, div;
        if (sbr.bs_interpol_freq) {
            for (l = 0; l < sbr.L_E[ch]; l++) {
                var i, l_i, u_i;
                l_i = sbr.t_E[ch][l];
                u_i = sbr.t_E[ch][l + 1];
                div = (u_i - l_i);
                if (div == 0) 
                    div = 1;
                for (m = 0; m < sbr.M; m++) {
                    nrg = 0;
                    for (i = l_i + sbr.tHFAdj; i < u_i + sbr.tHFAdj; i++) {
                        nrg += (Xsbr[i][m + sbr.kx][0] * Xsbr[i][m + sbr.kx][0]) + (Xsbr[i][m + sbr.kx][1] * Xsbr[i][m + sbr.kx][1]);
                    }
                    sbr.E_curr[ch][m][l] = nrg / div;
                }
            }
        } else {
            for (l = 0; l < sbr.L_E[ch]; l++) {
                for (p = 0; p < sbr.n[sbr.f[ch][l]]; p++) {
                    k_l = sbr.f_table_res[sbr.f[ch][l]][p];
                    k_h = sbr.f_table_res[sbr.f[ch][l]][p + 1];
                    for (k = k_l; k < k_h; k++) {
                        var i, l_i, u_i;
                        nrg = 0;
                        l_i = sbr.t_E[ch][l];
                        u_i = sbr.t_E[ch][l + 1];
                        div = ((u_i - l_i) * (k_h - k_l));
                        if (div == 0) 
                            div = 1;
                        for (i = l_i + sbr.tHFAdj; i < u_i + sbr.tHFAdj; i++) {
                            for (j = k_l; j < k_h; j++) {
                                nrg += (Xsbr[i][j][0] * Xsbr[i][j][0]) + (Xsbr[i][j][1] * Xsbr[i][j][1]);
                            }
                        }
                        sbr.E_curr[ch][k - sbr.kx][l] = nrg / div;
                    }
                }
            }
        }
        return 0;
    };
    constructor.hf_assembly = function(sbr, adj, Xsbr, ch) {
        var m, l, i, n;
        var fIndexNoise = 0;
        var fIndexSine = 0;
        var assembly_reset = false;
        var G_filt, Q_filt;
        var h_SL;
        if (sbr.Reset) {
            assembly_reset = true;
            fIndexNoise = 0;
        } else {
            fIndexNoise = sbr.index_noise_prev[ch];
        }
        fIndexSine = sbr.psi_is_prev[ch];
        for (l = 0; l < sbr.L_E[ch]; l++) {
            var no_noise = (l == sbr.l_A[ch] || l == sbr.prevEnvIsShort[ch]);
            h_SL = (sbr.bs_smoothing_mode) ? 0 : 4;
            h_SL = (no_noise ? 0 : h_SL);
            if (assembly_reset) {
                for (n = 0; n < 4; n++) {
                    System.arraycopy(adj.G_lim_boost[l], 0, sbr.G_temp_prev[ch][n], 0, sbr.M);
                    System.arraycopy(adj.Q_M_lim_boost[l], 0, sbr.Q_temp_prev[ch][n], 0, sbr.M);
                }
                sbr.GQ_ringbuf_index[ch] = 4;
                assembly_reset = false;
            }
            for (i = sbr.t_E[ch][l]; i < sbr.t_E[ch][l + 1]; i++) {
                System.arraycopy(adj.G_lim_boost[l], 0, sbr.G_temp_prev[ch][sbr.GQ_ringbuf_index[ch]], 0, sbr.M);
                System.arraycopy(adj.Q_M_lim_boost[l], 0, sbr.Q_temp_prev[ch][sbr.GQ_ringbuf_index[ch]], 0, sbr.M);
                for (m = 0; m < sbr.M; m++) {
                    var psi = new Float32Array(2);
                    G_filt = 0;
                    Q_filt = 0;
                    if (h_SL != 0) {
                        var ri = sbr.GQ_ringbuf_index[ch];
                        for (n = 0; n <= 4; n++) {
                            var curr_h_smooth = HFAdjustment.h_smooth[n];
                            ri++;
                            if (ri >= 5) 
                                ri -= 5;
                            G_filt += (sbr.G_temp_prev[ch][ri][m] * curr_h_smooth);
                            Q_filt += (sbr.Q_temp_prev[ch][ri][m] * curr_h_smooth);
                        }
                    } else {
                        G_filt = sbr.G_temp_prev[ch][sbr.GQ_ringbuf_index[ch]][m];
                        Q_filt = sbr.Q_temp_prev[ch][sbr.GQ_ringbuf_index[ch]][m];
                    }
                    Q_filt = (adj.S_M_boost[l][m] != 0 || no_noise) ? 0 : Q_filt;
                    fIndexNoise = (fIndexNoise + 1) & 511;
                    Xsbr[i + sbr.tHFAdj][m + sbr.kx][0] = G_filt * Xsbr[i + sbr.tHFAdj][m + sbr.kx][0] + (Q_filt * NoiseTable.NOISE_TABLE[fIndexNoise][0]);
                    if (sbr.bs_extension_id == 3 && sbr.bs_extension_data == 42) 
                        Xsbr[i + sbr.tHFAdj][m + sbr.kx][0] = 16428320;
                    Xsbr[i + sbr.tHFAdj][m + sbr.kx][1] = G_filt * Xsbr[i + sbr.tHFAdj][m + sbr.kx][1] + (Q_filt * NoiseTable.NOISE_TABLE[fIndexNoise][1]);
                    {
                        var rev = (((m + sbr.kx) & 1) != 0 ? -1 : 1);
                        psi[0] = adj.S_M_boost[l][m] * HFAdjustment.phi_re[fIndexSine];
                        Xsbr[i + sbr.tHFAdj][m + sbr.kx][0] += psi[0];
                        psi[1] = rev * adj.S_M_boost[l][m] * HFAdjustment.phi_im[fIndexSine];
                        Xsbr[i + sbr.tHFAdj][m + sbr.kx][1] += psi[1];
                    }}
                fIndexSine = (fIndexSine + 1) & 3;
                sbr.GQ_ringbuf_index[ch]++;
                if (sbr.GQ_ringbuf_index[ch] >= 5) 
                    sbr.GQ_ringbuf_index[ch] = 0;
            }
        }
        sbr.index_noise_prev[ch] = fIndexNoise;
        sbr.psi_is_prev[ch] = fIndexSine;
    };
    constructor.calculate_gain = function(sbr, adj, ch) {
        var m, l, k;
        var current_t_noise_band = 0;
        var S_mapped;
        var Q_M_lim = new Float32Array(SBRConstants.MAX_M);
        var G_lim = new Float32Array(SBRConstants.MAX_M);
        var G_boost;
        var S_M = new Float32Array(SBRConstants.MAX_M);
        for (l = 0; l < sbr.L_E[ch]; l++) {
            var current_f_noise_band = 0;
            var current_res_band = 0;
            var current_res_band2 = 0;
            var current_hi_res_band = 0;
            var delta = (l == sbr.l_A[ch] || l == sbr.prevEnvIsShort[ch]) ? 0 : 1;
            S_mapped = HFAdjustment.get_S_mapped(sbr, ch, l, current_res_band2);
            if (sbr.t_E[ch][l + 1] > sbr.t_Q[ch][current_t_noise_band + 1]) {
                current_t_noise_band++;
            }
            for (k = 0; k < sbr.N_L[sbr.bs_limiter_bands]; k++) {
                var G_max;
                var den = 0;
                var acc1 = 0;
                var acc2 = 0;
                var current_res_band_size = 0;
                var ml1, ml2;
                ml1 = sbr.f_table_lim[sbr.bs_limiter_bands][k];
                ml2 = sbr.f_table_lim[sbr.bs_limiter_bands][k + 1];
                for (m = ml1; m < ml2; m++) {
                    if ((m + sbr.kx) == sbr.f_table_res[sbr.f[ch][l]][current_res_band + 1]) {
                        current_res_band++;
                    }
                    acc1 += sbr.E_orig[ch][current_res_band][l];
                    acc2 += sbr.E_curr[ch][m][l];
                }
                G_max = ((HFAdjustment.EPS + acc1) / (HFAdjustment.EPS + acc2)) * HFAdjustment.limGain[sbr.bs_limiter_gains];
                G_max = Math.min(G_max, 1.0E10);
                for (m = ml1; m < ml2; m++) {
                    var Q_M, G;
                    var Q_div, Q_div2;
                    var S_index_mapped;
                    if ((m + sbr.kx) == sbr.f_table_noise[current_f_noise_band + 1]) {
                        current_f_noise_band++;
                    }
                    if ((m + sbr.kx) == sbr.f_table_res[sbr.f[ch][l]][current_res_band2 + 1]) {
                        current_res_band2++;
                        S_mapped = HFAdjustment.get_S_mapped(sbr, ch, l, current_res_band2);
                    }
                    if ((m + sbr.kx) == sbr.f_table_res[SBRConstants.HI_RES][current_hi_res_band + 1]) {
                        current_hi_res_band++;
                    }
                    S_index_mapped = 0;
                    if ((l >= sbr.l_A[ch]) || (sbr.bs_add_harmonic_prev[ch][current_hi_res_band] != 0 && sbr.bs_add_harmonic_flag_prev[ch])) {
                        if ((m + sbr.kx) == (sbr.f_table_res[SBRConstants.HI_RES][current_hi_res_band + 1] + sbr.f_table_res[SBRConstants.HI_RES][current_hi_res_band]) >> 1) 
                            S_index_mapped = sbr.bs_add_harmonic[ch][current_hi_res_band];
                    }
                    Q_div = sbr.Q_div[ch][current_f_noise_band][current_t_noise_band];
                    Q_div2 = sbr.Q_div2[ch][current_f_noise_band][current_t_noise_band];
                    Q_M = sbr.E_orig[ch][current_res_band2][l] * Q_div2;
                    if (S_index_mapped == 0) {
                        S_M[m] = 0;
                    } else {
                        S_M[m] = sbr.E_orig[ch][current_res_band2][l] * Q_div;
                        den += S_M[m];
                    }
                    G = sbr.E_orig[ch][current_res_band2][l] / (1.0 + sbr.E_curr[ch][m][l]);
                    if ((S_mapped == 0) && (delta == 1)) 
                        G *= Q_div;
                     else if (S_mapped == 1) 
                        G *= Q_div2;
                    if (G_max > G) {
                        Q_M_lim[m] = Q_M;
                        G_lim[m] = G;
                    } else {
                        Q_M_lim[m] = Q_M * G_max / G;
                        G_lim[m] = G_max;
                    }
                    den += sbr.E_curr[ch][m][l] * G_lim[m];
                    if ((S_index_mapped == 0) && (l != sbr.l_A[ch])) 
                        den += Q_M_lim[m];
                }
                G_boost = (acc1 + HFAdjustment.EPS) / (den + HFAdjustment.EPS);
                G_boost = Math.min(G_boost, 2.5118864);
                for (m = ml1; m < ml2; m++) {
                    adj.G_lim_boost[l][m] = Math.sqrt(G_lim[m] * G_boost);
                    adj.Q_M_lim_boost[l][m] = Math.sqrt(Q_M_lim[m] * G_boost);
                    if (S_M[m] != 0) {
                        adj.S_M_boost[l][m] = Math.sqrt(S_M[m] * G_boost);
                    } else {
                        adj.S_M_boost[l][m] = 0;
                    }
                }
            }
        }
    };
}, {h_smooth: "Float32Array", phi_re: "Int32Array", phi_im: "Int32Array", limGain: "Float32Array", G_lim_boost: "Array", Q_M_lim_boost: "Array", S_M_boost: "Array", startMinTable: "Int32Array", offsetIndexTable: "Int32Array", OFFSET: "Array", NOISE_TABLE: "Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 * 
 *  @author in-somnia
 */
var IPQF = function() {
    this.buf = new Float32Array(GCConstants.BANDS);
    this.tmp1 = Array.apply(null, Array(stjs.trunc(GCConstants.BANDS / 2))).map(function() {
        return new Float32Array(stjs.trunc(GCConstants.NPQFTAPS / GCConstants.BANDS));
    });
    this.tmp2 = Array.apply(null, Array(stjs.trunc(GCConstants.BANDS / 2))).map(function() {
        return new Float32Array(stjs.trunc(GCConstants.NPQFTAPS / GCConstants.BANDS));
    });
};
IPQF = stjs.extend(IPQF, null, [GCConstants, PQFTables], function(constructor, prototype) {
    prototype.buf = null;
    prototype.tmp1 = null;
    prototype.tmp2 = null;
    prototype.process = function(_in, frameLen, maxBand, out) {
        var i, j;
        for (i = 0; i < frameLen; i++) {
            out[i] = 0.0;
        }
        for (i = 0; i < stjs.trunc(frameLen / GCConstants.BANDS); i++) {
            for (j = 0; j < GCConstants.BANDS; j++) {
                this.buf[j] = _in[j][i];
            }
            this.performSynthesis(this.buf, out, i * GCConstants.BANDS);
        }
    };
    prototype.performSynthesis = function(_in, out, outOff) {
        var kk = stjs.trunc(GCConstants.NPQFTAPS / (2 * GCConstants.BANDS));
        var i, n, k;
        var acc;
        for (n = 0; n < stjs.trunc(GCConstants.BANDS / 2); ++n) {
            for (k = 0; k < 2 * kk - 1; ++k) {
                this.tmp1[n][k] = this.tmp1[n][k + 1];
                this.tmp2[n][k] = this.tmp2[n][k + 1];
            }
        }
        for (n = 0; n < stjs.trunc(GCConstants.BANDS / 2); ++n) {
            acc = 0.0;
            for (i = 0; i < GCConstants.BANDS; ++i) {
                acc += PQFTables.COEFS_Q0[n][i] * _in[i];
            }
            this.tmp1[n][2 * kk - 1] = acc;
            acc = 0.0;
            for (i = 0; i < GCConstants.BANDS; ++i) {
                acc += PQFTables.COEFS_Q1[n][i] * _in[i];
            }
            this.tmp2[n][2 * kk - 1] = acc;
        }
        for (n = 0; n < stjs.trunc(GCConstants.BANDS / 2); ++n) {
            acc = 0.0;
            for (k = 0; k < kk; ++k) {
                acc += PQFTables.COEFS_T0[n][k] * this.tmp1[n][2 * kk - 1 - 2 * k];
            }
            for (k = 0; k < kk; ++k) {
                acc += PQFTables.COEFS_T1[n][k] * this.tmp2[n][2 * kk - 2 - 2 * k];
            }
            out[outOff + n] = acc;
            acc = 0.0;
            for (k = 0; k < kk; ++k) {
                acc += PQFTables.COEFS_T0[GCConstants.BANDS - 1 - n][k] * this.tmp1[n][2 * kk - 1 - 2 * k];
            }
            for (k = 0; k < kk; ++k) {
                acc -= PQFTables.COEFS_T1[GCConstants.BANDS - 1 - n][k] * this.tmp2[n][2 * kk - 2 - 2 * k];
            }
            out[outOff + GCConstants.BANDS - 1 - n] = acc;
        }
    };
}, {buf: "Float32Array", tmp1: "Array", tmp2: "Array", LN_GAIN: "Int32Array", PROTO_TABLE: "Float32Array", COEFS_Q0: "Array", COEFS_Q1: "Array", COEFS_T0: "Array", COEFS_T1: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var TimeUtil = function() {};
TimeUtil = stjs.extend(TimeUtil, null, [], function(constructor, prototype) {
    constructor.MOV_TIME_OFFSET = 0;
    constructor.macTimeToDate = function(movSec) {
        return new jsutil.Date(TimeUtil.fromMovTime(movSec));
    };
    constructor.fromMovTime = function(movSec) {
        return (stjs.trunc(movSec)) * 1000 + TimeUtil.MOV_TIME_OFFSET;
    };
    constructor.toMovTime = function(millis) {
        return (((stjs.trunc((millis - TimeUtil.MOV_TIME_OFFSET) / 1000))) | 0);
    };
}, {}, {});
(function() {
    var calendar = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
    calendar.set(1904, 0, 1, 0, 0, 0);
    calendar.set(Calendar.MILLISECOND, 0);
    TimeUtil.MOV_TIME_OFFSET = calendar.getTimeInMillis();
})();
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  @author The JCodec project
 */
var MD5 = function() {};
MD5 = stjs.extend(MD5, null, [], function(constructor, prototype) {
    constructor.md5sumBytes = function(bytes) {
        var md5 = MD5.getDigest();
        md5.update(bytes);
        return MD5.digestToString(md5.digest());
    };
    constructor.digestToString = function(digest) {
        var sb = new StringBuilder();
        for (var i = 0; i < digest.length; i++) {
            var item = digest[i];
            var b = item & 255;
            if (b < 16) 
                sb.append('0');
            sb.append(Integer.toHexString(b));
        }
        return sb.toString();
    };
    constructor.md5sum = function(bytes) {
        var md5 = MD5.getDigest();
        md5.update(bytes);
        var digest = md5.digest();
        return MD5.digestToString(digest);
    };
    constructor.getDigest = function() {
        var md5;
        try {
            md5 = MessageDigest.getInstance("MD5");
        }catch (e) {
             throw new RuntimeException(e);
        }
        return md5;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Decode program configuration element; reference: table 4.2.
 *  
 *  @author The JCodec project
 *  
 */
var BlockPCE = function() {
    Block.call(this);
};
BlockPCE = stjs.extend(BlockPCE, Block, [], function(constructor, prototype) {
    constructor.MAX_ELEM_ID = 16;
    constructor.ChannelMapping = function() {};
    constructor.ChannelMapping = stjs.extend(constructor.ChannelMapping, null, [], function(constructor, prototype) {
        prototype.syn_ele = null;
        prototype.someInt = 0;
        prototype.position = null;
    }, {syn_ele: {name: "Enum", arguments: ["RawDataBlockType"]}, position: {name: "Enum", arguments: ["ChannelPosition"]}}, {});
    prototype.parse = function(_in) {
        _in.readNBit(2);
        var samplingIndex = stjs.trunc(_in.readNBit(4));
        var num_front = stjs.trunc(_in.readNBit(4));
        var num_side = stjs.trunc(_in.readNBit(4));
        var num_back = stjs.trunc(_in.readNBit(4));
        var num_lfe = stjs.trunc(_in.readNBit(2));
        var num_assoc_data = stjs.trunc(_in.readNBit(3));
        var num_cc = stjs.trunc(_in.readNBit(4));
        if (_in.read1Bit() != 0) 
            _in.readNBit(4);
        if (_in.read1Bit() != 0) 
            _in.readNBit(4);
        if (_in.read1Bit() != 0) 
            _in.readNBit(3);
        var layout_map = Array(BlockPCE.MAX_ELEM_ID * 4);
        var tags = 0;
        this.decodeChannelMap(layout_map, tags, ChannelPosition.AAC_CHANNEL_FRONT, _in, num_front);
        tags = num_front;
        this.decodeChannelMap(layout_map, tags, ChannelPosition.AAC_CHANNEL_SIDE, _in, num_side);
        tags += num_side;
        this.decodeChannelMap(layout_map, tags, ChannelPosition.AAC_CHANNEL_BACK, _in, num_back);
        tags += num_back;
        this.decodeChannelMap(layout_map, tags, ChannelPosition.AAC_CHANNEL_LFE, _in, num_lfe);
        tags += num_lfe;
        _in.skip(4 * num_assoc_data);
        this.decodeChannelMap(layout_map, tags, ChannelPosition.AAC_CHANNEL_CC, _in, num_cc);
        tags += num_cc;
        _in.align();
        var comment_len = stjs.trunc(_in.readNBit(8)) * 8;
        _in.skip(comment_len);
    };
    /**
     *  Decode an array of 4 bit element IDs, optionally interleaved with a
     *  stereo/mono switching bit.
     *  
     *  @throws IOException
     */
    prototype.decodeChannelMap = function(layout_map, offset, type, _in, n) {
         while (n-- > 0){
            var syn_ele = null;
            switch (type) {
                case ChannelPosition.AAC_CHANNEL_FRONT:
                case ChannelPosition.AAC_CHANNEL_BACK:
                case ChannelPosition.AAC_CHANNEL_SIDE:
                    syn_ele = RawDataBlockType.values()[_in.read1Bit()];
                    break;
                case ChannelPosition.AAC_CHANNEL_CC:
                    _in.read1Bit();
                    syn_ele = RawDataBlockType.TYPE_CCE;
                    break;
                case ChannelPosition.AAC_CHANNEL_LFE:
                    syn_ele = RawDataBlockType.TYPE_LFE;
                    break;
            }
            layout_map[offset].syn_ele = syn_ele;
            layout_map[offset].someInt = stjs.trunc(_in.readNBit(4));
            layout_map[offset].position = type;
            offset++;
        }
    };
}, {type: {name: "Enum", arguments: ["BlockType"]}}, {});
var Platform = function() {};
Platform = stjs.extend(Platform, null, [], function(constructor, prototype) {
    constructor.neu = function(cls, params) {
        var instance = (Object).create((cls).prototype);
        var result = (cls).apply(instance, params);
        var object = (result != null && (typeof result) == "object") ? result : instance;
        return object;
    };
    constructor.newInstance = function(clazz, params) {
        console.log("newInstance", clazz);
        var created = Platform.neu(clazz, (params));
        return created;
    };
    constructor.invokeMethod = function(target, methodName, params) {
        var parameterTypes = Array(params.length);
        for (var i = 0; i < params.length; i++) {
            parameterTypes[i] = params[i].getClass();
        }
        try {
            target.getClass().getDeclaredMethod(methodName, parameterTypes).invoke(target, params);
        }catch (e) {
             throw new RuntimeException(e);
        }
    };
    constructor.getDeclaredMethods = function(claz) {
         throw new RuntimeException("TODO");
    };
    constructor.getMethods = function(class1) {
         throw new RuntimeException("TODO");
    };
    constructor.getDeclaredFields = function(class1) {
         throw new RuntimeException("TODO");
    };
    constructor.getFields = function(class1) {
         throw new RuntimeException("TODO");
    };
    constructor.stringFromCharset = function(data, charset) {
         throw new RuntimeException("TODO");
    };
    constructor.getBytesForCharset = function(url, utf8) {
         throw new RuntimeException("TODO");
    };
    constructor.getResourceAsStream = function(class1, string) {
         throw new RuntimeException("TODO");
    };
    constructor.stringFromCharset4 = function(data, offset, len, charset) {
         throw new RuntimeException("TODO");
    };
    constructor.getResource = function(class1, string) {
         throw new RuntimeException("TODO");
    };
    constructor.arrayEqualsInt = function(a, a2) {
         throw new RuntimeException("TODO");
    };
    constructor.arrayEqualsByte = function(a, a2) {
         throw new RuntimeException("TODO");
    };
    constructor.arrayEqualsObj = function(a, a2) {
        return JSArrays.equalsObjs(a, a2);
    };
    constructor.copyOfRangeO = function(original, from, to) {
         throw new RuntimeException("TODO");
    };
    constructor.copyOfRangeL = function(original, from, to) {
         throw new RuntimeException("TODO");
    };
    constructor.copyOfRangeI = function(original, from, to) {
         throw new RuntimeException("TODO");
    };
    constructor.copyOfRangeB = function(original, from, to) {
         throw new RuntimeException("TODO");
    };
    constructor.copyOfObj = function(original, newLength) {
        var copy = Array(newLength);
        System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength));
        return copy;
    };
    constructor.copyOfLong = function(original, newLength) {
         throw new RuntimeException("TODO");
    };
    constructor.copyOfInt = function(original, newLength) {
        var copy = new Int32Array(newLength);
        System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength));
        return copy;
    };
    constructor.copyOfBool = function(original, newLength) {
         throw new RuntimeException("TODO");
    };
    constructor.copyOfByte = function(original, newLength) {
         throw new RuntimeException("TODO");
    };
    constructor.arrayToString = function(a) {
         throw new RuntimeException("TODO");
    };
    constructor.deleteFile = function(file) {
         throw new RuntimeException("TODO");
    };
    constructor.getBytes = function(string) {
        var buf = new Int8Array(string.length);
        for (var i = 0; i < string.length; i++) {
            var charCodeAt = (string).charCodeAt(i);
            buf[i] = (charCodeAt << 24 >> 24);
        }
        return buf;
    };
    constructor.stringFromBytes = function(bytes) {
        var str = "";
        for (var i = 0; i < bytes.length; i++) {
            str += (String).fromCharCode(bytes[i]);
        }
        return str;
    };
    constructor.isAssignableFrom = function(parent, child) {
        return stjs.isInstanceOf(child, parent);
    };
    constructor.arraycopyByte = function(src, srcPos, dst, dstPos, len) {
        var _src = src;
        var _dst = dst;
        _dst.subarray(dstPos, dstPos + len).set(_src.subarray(srcPos, srcPos + len), 0);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Assert = function() {};
Assert = stjs.extend(Assert, null, [], function(constructor, prototype) {
    constructor.assertEquals = function(_arguments) {
        if (arguments.length == 2) {
            if (arguments[0] != arguments[1]) {
                 throw new AssertionError(arguments[0] + " != " + arguments[1]);
            }
        } else {
            console.log("arguments", arguments);
             throw new RuntimeException("TODO jcodec Assert.assertEquals");
        }
    };
    constructor.assertTrue = function(_arguments) {
        if (arguments.length == 1) {
            var expected = arguments[0];
            if (!expected) {
                 throw new AssertionError();
            }
        } else if (arguments.length == 2) {
            var msg = arguments[0];
            var expected = arguments[1];
            if (!expected) {
                 throw new AssertionError(msg);
            }
        } else {
            console.log("arguments", arguments);
             throw new RuntimeException("TODO Assert.assertTrue " + arguments.length);
        }
    };
    constructor.assertNotNull = function(obj) {
        if (obj == null) 
             throw new AssertionError();
    };
    constructor.assertArrayEquals = function(a, b) {
        if (a == b) 
            return;
        if (a == null || b == null) 
             throw new AssertionError();
        if (a.length != b.length) 
             throw new AssertionError();
        for (var i = 0; i < a.length; i++) 
            if (a[i] != b[i]) 
                 throw new AssertionError();
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Contains various deblocking filter routines for deblocking on MB bases
 *  
 *  @author Stan Vitvitskyy
 *  
 */
var MBDeblocker = function() {};
MBDeblocker = stjs.extend(MBDeblocker, null, [], function(constructor, prototype) {
    constructor.LOOKUP_IDX_P_V = [new Int32Array([3, 7, 11, 15]), new Int32Array([0, 4, 8, 12]), new Int32Array([1, 5, 9, 13]), new Int32Array([2, 6, 10, 14])];
    constructor.LOOKUP_IDX_Q_V = [new Int32Array([0, 4, 8, 12]), new Int32Array([1, 5, 9, 13]), new Int32Array([2, 6, 10, 14]), new Int32Array([3, 7, 11, 15])];
    constructor.LOOKUP_IDX_P_H = [new Int32Array([12, 13, 14, 15]), new Int32Array([0, 1, 2, 3]), new Int32Array([4, 5, 6, 7]), new Int32Array([8, 9, 10, 11])];
    constructor.LOOKUP_IDX_Q_H = [new Int32Array([0, 1, 2, 3]), new Int32Array([4, 5, 6, 7]), new Int32Array([8, 9, 10, 11]), new Int32Array([12, 13, 14, 15])];
    constructor.BS_I = [new Int32Array([4, 4, 4, 4]), new Int32Array([3, 3, 3, 3]), new Int32Array([3, 3, 3, 3]), new Int32Array([3, 3, 3, 3])];
    /**
     *  Deblocks bottom edge of topOutMB, right edge of leftOutMB and left/top
     *  and inner block edges of outMB
     *  
     *  @param curPix
     *             Pixels of the current MB
     *  @param leftPix
     *             Pixels of the leftMB
     *  @param topPix
     *             Pixels of the tipMB
     *  
     *  @param vertStrength
     *             Border strengths for vertical edges (filtered first)
     *  @param horizStrength
     *             Border strengths for the horizontal edges
     *  
     *  @param curQp
     *             Current MB's qp
     *  @param leftQp
     *             Left MB's qp
     *  @param topQp
     *             Top MB's qp
     */
    prototype.deblockMBGeneric = function(curMB, leftMB, topMB, vertStrength, horizStrength) {
        var curPix = curMB.getPixels();
        if (leftMB != null) {
            var leftPix = leftMB.getPixels();
            var avgQp = MathUtil.clip((leftMB.getQp() + curMB.getQp() + 1) >> 1, 0, 51);
            this.deblockBorder(vertStrength[0], avgQp, leftPix.getPlaneData(0), 3, curPix.getPlaneData(0), 0, MBDeblocker.P_POS_V, MBDeblocker.Q_POS_V, false);
            this.deblockBorderChroma(vertStrength[0], avgQp, leftPix.getPlaneData(1), 3, curPix.getPlaneData(1), 0, MBDeblocker.P_POS_V_CHR, MBDeblocker.Q_POS_V_CHR, false);
            this.deblockBorderChroma(vertStrength[0], avgQp, leftPix.getPlaneData(2), 3, curPix.getPlaneData(2), 0, MBDeblocker.P_POS_V_CHR, MBDeblocker.Q_POS_V_CHR, false);
        }
        for (var i = 0; i < 3; i++) {
            this.deblockBorder(vertStrength[i + 1], curMB.getQp(), curPix.getPlaneData(0), i, curPix.getPlaneData(0), i + 1, MBDeblocker.P_POS_V, MBDeblocker.Q_POS_V, false);
            this.deblockBorderChroma(vertStrength[i + 1], curMB.getQp(), curPix.getPlaneData(1), i, curPix.getPlaneData(1), i + 1, MBDeblocker.P_POS_V_CHR, MBDeblocker.Q_POS_V_CHR, false);
            this.deblockBorderChroma(vertStrength[i + 1], curMB.getQp(), curPix.getPlaneData(2), i, curPix.getPlaneData(2), i + 1, MBDeblocker.P_POS_V_CHR, MBDeblocker.Q_POS_V_CHR, false);
        }
        if (topMB != null) {
            var topPix = topMB.getPixels();
            var avgQp = MathUtil.clip((topMB.getQp() + curMB.getQp() + 1) >> 1, 0, 51);
            this.deblockBorder(horizStrength[0], avgQp, topPix.getPlaneData(0), 3, curPix.getPlaneData(0), 0, MBDeblocker.P_POS_H, MBDeblocker.Q_POS_H, true);
            this.deblockBorderChroma(horizStrength[0], avgQp, topPix.getPlaneData(1), 3, curPix.getPlaneData(1), 0, MBDeblocker.P_POS_H_CHR, MBDeblocker.Q_POS_H_CHR, true);
            this.deblockBorderChroma(horizStrength[0], avgQp, topPix.getPlaneData(2), 3, curPix.getPlaneData(2), 0, MBDeblocker.P_POS_H_CHR, MBDeblocker.Q_POS_H_CHR, true);
        }
        for (var i = 0; i < 3; i++) {
            this.deblockBorder(horizStrength[i + 1], curMB.getQp(), curPix.getPlaneData(0), i, curPix.getPlaneData(0), i + 1, MBDeblocker.P_POS_H, MBDeblocker.Q_POS_H, true);
            this.deblockBorderChroma(horizStrength[i + 1], curMB.getQp(), curPix.getPlaneData(1), i, curPix.getPlaneData(1), i + 1, MBDeblocker.P_POS_H_CHR, MBDeblocker.Q_POS_H_CHR, true);
            this.deblockBorderChroma(horizStrength[i + 1], curMB.getQp(), curPix.getPlaneData(2), i, curPix.getPlaneData(2), i + 1, MBDeblocker.P_POS_H_CHR, MBDeblocker.Q_POS_H_CHR, true);
        }
    };
    prototype.deblockMBI = function(outMB, leftOutMB, topOutMB) {
        this.deblockMBGeneric(outMB, leftOutMB, topOutMB, MBDeblocker.BS_I, MBDeblocker.BS_I);
    };
    /**
     *  Deblocks P-macroblock
     *  
     *  @param cur
     *             Pixels and parameters of encoded and reconstructed current
     *             macroblock
     *  @param left
     *             Pixels and parameters of encoded and reconstructed left
     *             macroblock
     *  @param top
     *             Pixels and parameters of encoded and reconstructed top
     *             macroblock
     */
    prototype.deblockMBP = function(cur, left, top) {
        var vertStrength = Array.apply(null, Array(4)).map(function() {
            return new Int32Array(4);
        });
        var horizStrength = Array.apply(null, Array(4)).map(function() {
            return new Int32Array(4);
        });
        MBDeblocker.calcStrengthForBlocks(cur, left, vertStrength, MBDeblocker.LOOKUP_IDX_P_V, MBDeblocker.LOOKUP_IDX_Q_V);
        MBDeblocker.calcStrengthForBlocks(cur, top, horizStrength, MBDeblocker.LOOKUP_IDX_P_H, MBDeblocker.LOOKUP_IDX_Q_H);
        this.deblockMBGeneric(cur, left, top, vertStrength, horizStrength);
    };
    prototype.deblockBorder = function(boundary, qp, p, pi, q, qi, pTab, qTab, horiz) {
        var inc1 = horiz ? 16 : 1, inc2 = inc1 * 2, inc3 = inc1 * 3;
        for (var b = 0; b < 4; b++) {
            if (boundary[b] == 4) {
                for (var i = 0, ii = b << 2; i < 4; ++i , ++ii) 
                    this.filterBs4(qp, qp, p, q, pTab[pi][ii] - inc3, pTab[pi][ii] - inc2, pTab[pi][ii] - inc1, pTab[pi][ii], qTab[qi][ii], qTab[qi][ii] + inc1, qTab[qi][ii] + inc2, qTab[qi][ii] + inc3);
            } else if (boundary[b] > 0) {
                for (var i = 0, ii = b << 2; i < 4; ++i , ++ii) 
                    this.filterBs(boundary[b], qp, qp, p, q, pTab[pi][ii] - inc2, pTab[pi][ii] - inc1, pTab[pi][ii], qTab[qi][ii], qTab[qi][ii] + inc1, qTab[qi][ii] + inc2);
            }
        }
    };
    prototype.filterBs4Chr = function(indexAlpha, indexBeta, pelsP, pelsQ, p1Idx, p0Idx, q0Idx, q1Idx) {
        this._filterBs4(indexAlpha, indexBeta, pelsP, pelsQ, -1, -1, p1Idx, p0Idx, q0Idx, q1Idx, -1, -1, true);
    };
    prototype.filterBsChr = function(bs, indexAlpha, indexBeta, pelsP, pelsQ, p1Idx, p0Idx, q0Idx, q1Idx) {
        this._filterBs(bs, indexAlpha, indexBeta, pelsP, pelsQ, -1, p1Idx, p0Idx, q0Idx, q1Idx, -1, true);
    };
    prototype.filterBs4 = function(indexAlpha, indexBeta, pelsP, pelsQ, p3Idx, p2Idx, p1Idx, p0Idx, q0Idx, q1Idx, q2Idx, q3Idx) {
        this._filterBs4(indexAlpha, indexBeta, pelsP, pelsQ, p3Idx, p2Idx, p1Idx, p0Idx, q0Idx, q1Idx, q2Idx, q3Idx, false);
    };
    prototype.filterBs = function(bs, indexAlpha, indexBeta, pelsP, pelsQ, p2Idx, p1Idx, p0Idx, q0Idx, q1Idx, q2Idx) {
        this._filterBs(bs, indexAlpha, indexBeta, pelsP, pelsQ, p2Idx, p1Idx, p0Idx, q0Idx, q1Idx, q2Idx, false);
    };
    prototype._filterBs4 = function(indexAlpha, indexBeta, pelsP, pelsQ, p3Idx, p2Idx, p1Idx, p0Idx, q0Idx, q1Idx, q2Idx, q3Idx, isChroma) {
        var p0 = pelsP[p0Idx];
        var q0 = pelsQ[q0Idx];
        var p1 = pelsP[p1Idx];
        var q1 = pelsQ[q1Idx];
        var alphaThresh = DeblockingFilter.alphaTab[indexAlpha];
        var betaThresh = DeblockingFilter.betaTab[indexBeta];
        var filterEnabled = Math.abs(p0 - q0) < alphaThresh && Math.abs(p1 - p0) < betaThresh && Math.abs(q1 - q0) < betaThresh;
        if (!filterEnabled) 
            return;
        var conditionP, conditionQ;
        if (isChroma) {
            conditionP = false;
            conditionQ = false;
        } else {
            var ap = Math.abs(pelsP[p2Idx] - p0);
            var aq = Math.abs(pelsQ[q2Idx] - q0);
            conditionP = ap < betaThresh && Math.abs(p0 - q0) < ((alphaThresh >> 2) + 2);
            conditionQ = aq < betaThresh && Math.abs(p0 - q0) < ((alphaThresh >> 2) + 2);
        }
        if (conditionP) {
            var p3 = pelsP[p3Idx];
            var p2 = pelsP[p2Idx];
            var p0n = (p2 + 2 * p1 + 2 * p0 + 2 * q0 + q1 + 4) >> 3;
            var p1n = (p2 + p1 + p0 + q0 + 2) >> 2;
            var p2n = (2 * p3 + 3 * p2 + p1 + p0 + q0 + 4) >> 3;
            pelsP[p0Idx] = (MathUtil.clip(p0n, -128, 127) << 24 >> 24);
            pelsP[p1Idx] = (MathUtil.clip(p1n, -128, 127) << 24 >> 24);
            pelsP[p2Idx] = (MathUtil.clip(p2n, -128, 127) << 24 >> 24);
        } else {
            var p0n = (2 * p1 + p0 + q1 + 2) >> 2;
            pelsP[p0Idx] = (MathUtil.clip(p0n, -128, 127) << 24 >> 24);
        }
        if (conditionQ && !isChroma) {
            var q2 = pelsQ[q2Idx];
            var q3 = pelsQ[q3Idx];
            var q0n = (p1 + 2 * p0 + 2 * q0 + 2 * q1 + q2 + 4) >> 3;
            var q1n = (p0 + q0 + q1 + q2 + 2) >> 2;
            var q2n = (2 * q3 + 3 * q2 + q1 + q0 + p0 + 4) >> 3;
            pelsQ[q0Idx] = (MathUtil.clip(q0n, -128, 127) << 24 >> 24);
            pelsQ[q1Idx] = (MathUtil.clip(q1n, -128, 127) << 24 >> 24);
            pelsQ[q2Idx] = (MathUtil.clip(q2n, -128, 127) << 24 >> 24);
        } else {
            var q0n = (2 * q1 + q0 + p1 + 2) >> 2;
            pelsQ[q0Idx] = (MathUtil.clip(q0n, -128, 127) << 24 >> 24);
        }
    };
    prototype._filterBs = function(bs, indexAlpha, indexBeta, pelsP, pelsQ, p2Idx, p1Idx, p0Idx, q0Idx, q1Idx, q2Idx, isChroma) {
        var p1 = pelsP[p1Idx];
        var p0 = pelsP[p0Idx];
        var q0 = pelsQ[q0Idx];
        var q1 = pelsQ[q1Idx];
        var alphaThresh = DeblockingFilter.alphaTab[indexAlpha];
        var betaThresh = DeblockingFilter.betaTab[indexBeta];
        var filterEnabled = Math.abs(p0 - q0) < alphaThresh && Math.abs(p1 - p0) < betaThresh && Math.abs(q1 - q0) < betaThresh;
        if (!filterEnabled) 
            return;
        var tC0 = DeblockingFilter.tcs[bs - 1][indexAlpha];
        var conditionP, conditionQ;
        var tC;
        if (!isChroma) {
            var ap = Math.abs(pelsP[p2Idx] - p0);
            var aq = Math.abs(pelsQ[q2Idx] - q0);
            tC = tC0 + ((ap < betaThresh) ? 1 : 0) + ((aq < betaThresh) ? 1 : 0);
            conditionP = ap < betaThresh;
            conditionQ = aq < betaThresh;
        } else {
            tC = tC0 + 1;
            conditionP = false;
            conditionQ = false;
        }
        var sigma = ((((q0 - p0) << 2) + (p1 - q1) + 4) >> 3);
        sigma = sigma < -tC ? -tC : (sigma > tC ? tC : sigma);
        var p0n = p0 + sigma;
        p0n = p0n < -128 ? -128 : p0n;
        var q0n = q0 - sigma;
        q0n = q0n < -128 ? -128 : q0n;
        if (conditionP) {
            var p2 = pelsP[p2Idx];
            var diff = (p2 + ((p0 + q0 + 1) >> 1) - (p1 << 1)) >> 1;
            diff = diff < -tC0 ? -tC0 : (diff > tC0 ? tC0 : diff);
            var p1n = p1 + diff;
            pelsP[p1Idx] = (MathUtil.clip(p1n, -128, 127) << 24 >> 24);
        }
        if (conditionQ) {
            var q2 = pelsQ[q2Idx];
            var diff = (q2 + ((p0 + q0 + 1) >> 1) - (q1 << 1)) >> 1;
            diff = diff < -tC0 ? -tC0 : (diff > tC0 ? tC0 : diff);
            var q1n = q1 + diff;
            pelsQ[q1Idx] = (MathUtil.clip(q1n, -128, 127) << 24 >> 24);
        }
        pelsQ[q0Idx] = (MathUtil.clip(q0n, -128, 127) << 24 >> 24);
        pelsP[p0Idx] = (MathUtil.clip(p0n, -128, 127) << 24 >> 24);
    };
    prototype.deblockBorderChroma = function(boundary, qp, p, pi, q, qi, pTab, qTab, horiz) {
        var inc1 = horiz ? 8 : 1;
        for (var b = 0; b < 4; b++) {
            if (boundary[b] == 4) {
                for (var i = 0, ii = b << 1; i < 2; ++i , ++ii) 
                    this.filterBs4Chr(qp, qp, p, q, pTab[pi][ii] - inc1, pTab[pi][ii], qTab[qi][ii], qTab[qi][ii] + inc1);
            } else if (boundary[b] > 0) {
                for (var i = 0, ii = b << 1; i < 2; ++i , ++ii) 
                    this.filterBsChr(boundary[b], qp, qp, p, q, pTab[pi][ii] - inc1, pTab[pi][ii], qTab[qi][ii], qTab[qi][ii] + inc1);
            }
        }
    };
    constructor.buildPPosH = function() {
        var qPos = Array.apply(null, Array(4)).map(function() {
            return new Int32Array(16);
        });
        for (var i = 0; i < 4; i++) {
            for (var j = 0; j < 16; j++) {
                qPos[i][j] = j + (i << 6) + 48;
            }
        }
        return qPos;
    };
    constructor.buildQPosH = function() {
        var pPos = Array.apply(null, Array(4)).map(function() {
            return new Int32Array(16);
        });
        for (var i = 0; i < 4; i++) {
            for (var j = 0; j < 16; j++) {
                pPos[i][j] = j + (i << 6);
            }
        }
        return pPos;
    };
    constructor.buildPPosV = function() {
        var qPos = Array.apply(null, Array(4)).map(function() {
            return new Int32Array(16);
        });
        for (var i = 0; i < 4; i++) {
            for (var j = 0; j < 16; j++) {
                qPos[i][j] = (j << 4) + (i << 2) + 3;
            }
        }
        return qPos;
    };
    constructor.buildQPosV = function() {
        var pPos = Array.apply(null, Array(4)).map(function() {
            return new Int32Array(16);
        });
        for (var i = 0; i < 4; i++) {
            for (var j = 0; j < 16; j++) {
                pPos[i][j] = (j << 4) + (i << 2);
            }
        }
        return pPos;
    };
    constructor.buildPPosHChr = function() {
        var qPos = Array.apply(null, Array(4)).map(function() {
            return new Int32Array(8);
        });
        for (var i = 0; i < 4; i++) {
            for (var j = 0; j < 8; j++) {
                qPos[i][j] = j + (i << 4) + 8;
            }
        }
        return qPos;
    };
    constructor.buildQPosHChr = function() {
        var pPos = Array.apply(null, Array(4)).map(function() {
            return new Int32Array(8);
        });
        for (var i = 0; i < 4; i++) {
            for (var j = 0; j < 8; j++) {
                pPos[i][j] = j + (i << 4);
            }
        }
        return pPos;
    };
    constructor.buildPPosVChr = function() {
        var qPos = Array.apply(null, Array(4)).map(function() {
            return new Int32Array(8);
        });
        for (var i = 0; i < 4; i++) {
            for (var j = 0; j < 8; j++) {
                qPos[i][j] = (j << 3) + (i << 1) + 1;
            }
        }
        return qPos;
    };
    constructor.buildQPosVChr = function() {
        var pPos = Array.apply(null, Array(4)).map(function() {
            return new Int32Array(8);
        });
        for (var i = 0; i < 4; i++) {
            for (var j = 0; j < 8; j++) {
                pPos[i][j] = (j << 3) + (i << 1);
            }
        }
        return pPos;
    };
    constructor.calcStrengthForBlocks = function(cur, other, outStrength, LOOKUP_IDX_P, LOOKUP_IDX_Q) {
        if (other != null) {
            for (var i = 0; i < 4; ++i) {
                outStrength[0][i] = other.getType().isIntra() ? 4 : MathUtil.max3(MBDeblocker.strengthMv(other.getMx()[LOOKUP_IDX_P[0][i]], cur.getMx()[LOOKUP_IDX_Q[0][i]]), MBDeblocker.strengthMv(other.getMy()[LOOKUP_IDX_P[0][i]], cur.getMy()[LOOKUP_IDX_Q[0][i]]), MBDeblocker.strengthNc(other.getNc()[LOOKUP_IDX_P[0][i]], cur.getNc()[LOOKUP_IDX_Q[0][i]]));
            }
        }
        for (var i = 1; i < 4; i++) {
            for (var j = 0; j < 4; ++j) {
                outStrength[i][j] = MathUtil.max3(MBDeblocker.strengthMv(cur.getMx()[LOOKUP_IDX_P[i][j]], cur.getMx()[LOOKUP_IDX_Q[i][j]]), MBDeblocker.strengthMv(cur.getMy()[LOOKUP_IDX_P[i][j]], cur.getMy()[LOOKUP_IDX_Q[i][j]]), MBDeblocker.strengthNc(cur.getNc()[LOOKUP_IDX_P[i][j]], cur.getNc()[LOOKUP_IDX_Q[i][j]]));
            }
        }
    };
    constructor.strengthNc = function(ncA, ncB) {
        return ncA > 0 || ncB > 0 ? 2 : 0;
    };
    constructor.strengthMv = function(v0, v1) {
        return Math.abs(v0 - v1) >= 4 ? 1 : 0;
    };
    constructor.P_POS_V = MBDeblocker.buildPPosV();
    constructor.Q_POS_V = MBDeblocker.buildQPosV();
    constructor.P_POS_H = MBDeblocker.buildPPosH();
    constructor.Q_POS_H = MBDeblocker.buildQPosH();
    constructor.P_POS_V_CHR = MBDeblocker.buildPPosVChr();
    constructor.Q_POS_V_CHR = MBDeblocker.buildQPosVChr();
    constructor.P_POS_H_CHR = MBDeblocker.buildPPosHChr();
    constructor.Q_POS_H_CHR = MBDeblocker.buildQPosHChr();
}, {LOOKUP_IDX_P_V: "Array", LOOKUP_IDX_Q_V: "Array", LOOKUP_IDX_P_H: "Array", LOOKUP_IDX_Q_H: "Array", BS_I: "Array", P_POS_V: "Array", Q_POS_V: "Array", P_POS_H: "Array", Q_POS_H: "Array", P_POS_V_CHR: "Array", Q_POS_V_CHR: "Array", P_POS_H_CHR: "Array", Q_POS_H_CHR: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Estimates motion using diagonal search
 *  
 *  @author Stanislav Vitvitskyy
 */
var MotionEstimator = function(maxSearchRange) {
    this.maxSearchRange = maxSearchRange;
};
MotionEstimator = stjs.extend(MotionEstimator, null, [], function(constructor, prototype) {
    prototype.maxSearchRange = 0;
    prototype.estimate = function(ref, patch, mbX, mbY, mvpx, mvpy) {
        var searchPatch = new Int8Array((this.maxSearchRange * 2 + 16) * (this.maxSearchRange * 2 + 16));
        var startX = (mbX << 4);
        var startY = (mbY << 4);
        var patchTlX = Math.max(startX - this.maxSearchRange, 0);
        var patchTlY = Math.max(startY - this.maxSearchRange, 0);
        var patchBrX = Math.min(startX + this.maxSearchRange + 16, ref.getPlaneWidth(0));
        var patchBrY = Math.min(startY + this.maxSearchRange + 16, ref.getPlaneHeight(0));
        var centerX = startX - patchTlX;
        var centerY = startY - patchTlY;
        var patchW = patchBrX - patchTlX;
        var patchH = patchBrY - patchTlY;
        MBEncoderHelper.takeSafe(ref.getPlaneData(0), ref.getPlaneWidth(0), ref.getPlaneHeight(0), patchTlX, patchTlY, searchPatch, patchW, patchH);
        var bestMvX = centerX, bestMvY = centerY;
        var bestScore = this.sad(searchPatch, patchW, patch, bestMvX, bestMvY);
        for (var i = 0; i < this.maxSearchRange; i++) {
            var score1 = bestMvX > 0 ? this.sad(searchPatch, patchW, patch, bestMvX - 1, bestMvY) : Integer.MAX_VALUE;
            var score2 = bestMvX < patchW - 1 ? this.sad(searchPatch, patchW, patch, bestMvX + 1, bestMvY) : Integer.MAX_VALUE;
            var score3 = bestMvY > 0 ? this.sad(searchPatch, patchW, patch, bestMvX, bestMvY - 1) : Integer.MAX_VALUE;
            var score4 = bestMvY < patchH - 1 ? this.sad(searchPatch, patchW, patch, bestMvX, bestMvY + 1) : Integer.MAX_VALUE;
            var min = Math.min(Math.min(Math.min(score1, score2), score3), score4);
            if (min > bestScore) 
                break;
            bestScore = min;
            if (score1 == min) {
                --bestMvX;
            } else if (score2 == min) {
                ++bestMvX;
            } else if (score3 == min) {
                --bestMvY;
            } else {
                ++bestMvY;
            }
        }
        return new Int32Array([((bestMvX - centerX) << 2), ((bestMvY - centerY) << 2)]);
    };
    prototype.sad = function(big, bigStride, small, offX, offY) {
        var score = 0, bigOff = offY * bigStride + offX, smallOff = 0;
        for (var i = 0; i < 16; i++) {
            for (var j = 0; j < 16; j++ , ++bigOff , ++smallOff) {
                score += MathUtil.abs(big[bigOff] - small[smallOff]);
            }
            bigOff += bigStride - 16;
        }
        return score;
    };
}, {}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  Mid/side stereo
 *  @author in-somnia
 */
var MS = function() {};
MS = stjs.extend(MS, null, [SyntaxConstants, HCB], function(constructor, prototype) {
    constructor.process = function(cpe, specL, specR) {
        var ics = cpe.getLeftChannel();
        var info = ics.getInfo();
        var offsets = info.getSWBOffsets();
        var windowGroups = info.getWindowGroupCount();
        var maxSFB = info.getMaxSFB();
        var sfbCBl = ics.getSfbCB();
        var sfbCBr = cpe.getRightChannel().getSfbCB();
        var groupOff = 0;
        var g, i, w, j, idx = 0;
        for (g = 0; g < windowGroups; g++) {
            for (i = 0; i < maxSFB; i++ , idx++) {
                if (cpe.isMSUsed(idx) && sfbCBl[idx] < HCB.NOISE_HCB && sfbCBr[idx] < HCB.NOISE_HCB) {
                    for (w = 0; w < info.getWindowGroupLength(g); w++) {
                        var off = groupOff + w * 128 + offsets[i];
                        for (j = 0; j < offsets[i + 1] - offsets[i]; j++) {
                            var t = specL[off + j] - specR[off + j];
                            specL[off + j] += specR[off + j];
                            specR[off + j] = t;
                        }
                    }
                }
            }
            groupOff += info.getWindowGroupLength(g) * 128;
        }
    };
}, {LOGGER: "Logger"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  Intensity stereo
 *  @author in-somnia
 */
var IS = function() {};
IS = stjs.extend(IS, null, [SyntaxConstants, ISScaleTable, HCB], function(constructor, prototype) {
    constructor.process = function(cpe, specL, specR) {
        var ics = cpe.getRightChannel();
        var info = ics.getInfo();
        var offsets = info.getSWBOffsets();
        var windowGroups = info.getWindowGroupCount();
        var maxSFB = info.getMaxSFB();
        var sfbCB = ics.getSfbCB();
        var sectEnd = ics.getSectEnd();
        var scaleFactors = ics.getScaleFactors();
        var w, i, j, c, end, off;
        var idx = 0, groupOff = 0;
        var scale;
        for (var g = 0; g < windowGroups; g++) {
            for (i = 0; i < maxSFB; ) {
                if (sfbCB[idx] == HCB.INTENSITY_HCB || sfbCB[idx] == HCB.INTENSITY_HCB2) {
                    end = sectEnd[idx];
                    for (; i < end; i++ , idx++) {
                        c = sfbCB[idx] == HCB.INTENSITY_HCB ? 1 : -1;
                        if (cpe.isMSMaskPresent()) 
                            c *= cpe.isMSUsed(idx) ? -1 : 1;
                        scale = c * scaleFactors[idx];
                        for (w = 0; w < info.getWindowGroupLength(g); w++) {
                            off = groupOff + w * 128 + offsets[i];
                            for (j = 0; j < offsets[i + 1] - offsets[i]; j++) {
                                specR[off + j] = specL[off + j] * scale;
                            }
                        }
                    }
                } else {
                    end = sectEnd[idx];
                    idx += end - i;
                    i = end;
                }
            }
            groupOff += info.getWindowGroupLength(g) * 128;
        }
    };
}, {LOGGER: "Logger", SCALE_TABLE: "Float32Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  Intra-channel prediction used in profile Main
 *  @author in-somnia
 */
var ICPrediction = function() {
    this.states = Array(ICPrediction.MAX_PREDICTORS);
    this.resetAllPredictors();
};
ICPrediction = stjs.extend(ICPrediction, null, [], function(constructor, prototype) {
    constructor.SF_SCALE = 1.0 / -1024.0;
    constructor.INV_SF_SCALE = 1.0 / ICPrediction.SF_SCALE;
    constructor.MAX_PREDICTORS = 672;
    constructor.A = 0.953125;
    constructor.ALPHA = 0.90625;
    prototype.predictorReset = false;
    prototype.predictorResetGroup = 0;
    prototype.predictionUsed = null;
    prototype.states = null;
    constructor.PredictorState = function() {};
    constructor.PredictorState = stjs.extend(constructor.PredictorState, null, [], function(constructor, prototype) {
        prototype.cor0 = 0.0;
        prototype.cor1 = 0.0;
        prototype.var0 = 0.0;
        prototype.var1 = 0.0;
        prototype.r0 = 1.0;
        prototype.r1 = 1.0;
    }, {}, {});
    prototype.decode = function(_in, maxSFB, sf) {
        var predictorCount = sf.getPredictorCount();
        if (this.predictorReset = _in.readBool()) 
            this.predictorResetGroup = _in.readBits(5);
        var maxPredSFB = sf.getMaximalPredictionSFB();
        var length = Math.min(maxSFB, maxPredSFB);
        this.predictionUsed = new Int8Array(length);
        for (var sfb = 0; sfb < length; sfb++) {
            this.predictionUsed[sfb] = _in.readBool();
        }
        SyntaxConstants.LOGGER.log(Level.WARNING, "ICPrediction: maxSFB={0}, maxPredSFB={1}", new Int32Array([maxSFB, maxPredSFB]));
    };
    prototype.setPredictionUnused = function(sfb) {
        this.predictionUsed[sfb] = false;
    };
    prototype.process = function(ics, data, sf) {
        var info = ics.getInfo();
        if (info.isEightShortFrame()) 
            this.resetAllPredictors();
         else {
            var len = Math.min(sf.getMaximalPredictionSFB(), info.getMaxSFB());
            var swbOffsets = info.getSWBOffsets();
            var k;
            for (var sfb = 0; sfb < len; sfb++) {
                for (k = swbOffsets[sfb]; k < swbOffsets[sfb + 1]; k++) {
                    this.predict(data, k, this.predictionUsed[sfb]);
                }
            }
            if (this.predictorReset) 
                this.resetPredictorGroup(this.predictorResetGroup);
        }
    };
    prototype.resetPredictState = function(index) {
        if (this.states[index] == null) 
            this.states[index] = new ICPrediction.PredictorState();
        this.states[index].r0 = 0;
        this.states[index].r1 = 0;
        this.states[index].cor0 = 0;
        this.states[index].cor1 = 0;
        this.states[index].var0 = 16256;
        this.states[index].var1 = 16256;
    };
    prototype.resetAllPredictors = function() {
        var i;
        for (i = 0; i < this.states.length; i++) {
            this.resetPredictState(i);
        }
    };
    prototype.resetPredictorGroup = function(group) {
        var i;
        for (i = group - 1; i < this.states.length; i += 30) {
            this.resetPredictState(i);
        }
    };
    prototype.predict = function(data, off, output) {
        if (this.states[off] == null) 
            this.states[off] = new ICPrediction.PredictorState();
        var state = this.states[off];
        var r0 = state.r0, r1 = state.r1;
        var cor0 = state.cor0, cor1 = state.cor1;
        var var0 = state.var0, var1 = state.var1;
        var k1 = var0 > 1 ? cor0 * this.even(ICPrediction.A / var0) : 0;
        var k2 = var1 > 1 ? cor1 * this.even(ICPrediction.A / var1) : 0;
        var pv = this.round(k1 * r0 + k2 * r1);
        if (output) 
            data[off] += pv * ICPrediction.SF_SCALE;
        var e0 = (data[off] * ICPrediction.INV_SF_SCALE);
        var e1 = e0 - k1 * r0;
        state.cor1 = this.trunc(ICPrediction.ALPHA * cor1 + r1 * e1);
        state.var1 = this.trunc(ICPrediction.ALPHA * var1 + 0.5 * (r1 * r1 + e1 * e1));
        state.cor0 = this.trunc(ICPrediction.ALPHA * cor0 + r0 * e0);
        state.var0 = this.trunc(ICPrediction.ALPHA * var0 + 0.5 * (r0 * r0 + e0 * e0));
        state.r1 = this.trunc(ICPrediction.A * (r0 - k1 * e0));
        state.r0 = this.trunc(ICPrediction.A * e0);
    };
    prototype.round = function(pf) {
        return Float.intBitsToFloat((Float.floatToIntBits(pf) + 32768) & -65536);
    };
    prototype.even = function(pf) {
        var i = Float.floatToIntBits(pf);
        i = (i + 32767 + (i & 65536 >> 16)) & -65536;
        return Float.intBitsToFloat(i);
    };
    prototype.trunc = function(pf) {
        return Float.intBitsToFloat(Float.floatToIntBits(pf) & -65536);
    };
}, {predictionUsed: "Int8Array", states: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Wraps virtual packet for easy proxy creation
 *  
 *  @author The JCodec project
 *  
 */
var VirtualPacketWrapper = function(src) {
    this.src = src;
};
VirtualPacketWrapper = stjs.extend(VirtualPacketWrapper, null, [VirtualPacket], function(constructor, prototype) {
    prototype.src = null;
    prototype.getData = function() {
        return this.src.getData();
    };
    prototype.getDataLen = function() {
        return this.src.getDataLen();
    };
    prototype.getPts = function() {
        return this.src.getPts();
    };
    prototype.getDuration = function() {
        return this.src.getDuration();
    };
    prototype.isKeyframe = function() {
        return this.src.isKeyframe();
    };
    prototype.getFrameNo = function() {
        return this.src.getFrameNo();
    };
}, {src: "VirtualPacket", byPts: {name: "Comparator", arguments: ["Object"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var ConcatPacket = function(packet, ptsOffset, fnOffset) {
    this.packet = packet;
    this.ptsOffset = ptsOffset;
    this.fnOffset = fnOffset;
};
ConcatPacket = stjs.extend(ConcatPacket, null, [VirtualPacket], function(constructor, prototype) {
    prototype.packet = null;
    prototype.ptsOffset = 0.0;
    prototype.fnOffset = 0;
    prototype.getData = function() {
        return this.packet.getData();
    };
    prototype.getDataLen = function() {
        return this.packet.getDataLen();
    };
    prototype.getPts = function() {
        return this.ptsOffset + this.packet.getPts();
    };
    prototype.getDuration = function() {
        return this.packet.getDuration();
    };
    prototype.isKeyframe = function() {
        return this.packet.isKeyframe();
    };
    prototype.getFrameNo = function() {
        return this.fnOffset + this.packet.getFrameNo();
    };
}, {packet: "VirtualPacket", byPts: {name: "Comparator", arguments: ["Object"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var RgbToYuv422p8Bit = function() {};
RgbToYuv422p8Bit = stjs.extend(RgbToYuv422p8Bit, null, [Transform8Bit], function(constructor, prototype) {
    prototype.transform = function(img, dst) {
        var y = img.getData()[0];
        var out1 = new Int8Array(3);
        var out2 = new Int8Array(3);
        var dstData = dst.getData();
        var off = 0, offSrc = 0;
        for (var i = 0; i < img.getHeight(); i++) {
            for (var j = 0; j < img.getWidth() >> 1; j++) {
                var offY = off << 1;
                RgbToYuv420p8Bit.rgb2yuv(y[offSrc++], y[offSrc++], y[offSrc++], out1);
                dstData[0][offY] = out1[0];
                RgbToYuv420p8Bit.rgb2yuv(y[offSrc++], y[offSrc++], y[offSrc++], out2);
                dstData[0][offY + 1] = out2[0];
                dstData[1][off] = (((out1[1] + out2[1] + 1) >> 1) << 24 >> 24);
                dstData[2][off] = (((out1[2] + out2[2] + 1) >> 1) << 24 >> 24);
                ++off;
            }
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  All the IO routines related to bits
 *  
 *  @author The JCodec project
 *  
 */
var BitIO = function() {};
BitIO = stjs.extend(BitIO, null, [], function(constructor, prototype) {
    constructor.InputBits = function() {};
    constructor.InputBits = stjs.extend(constructor.InputBits, null, [], function(constructor, prototype) {
        prototype.getBit = function() {};
    }, {}, {});
    constructor.OutputBits = function() {};
    constructor.OutputBits = stjs.extend(constructor.OutputBits, null, [], function(constructor, prototype) {
        prototype.putBit = function(symbol) {};
        prototype.flush = function() {};
    }, {}, {});
    constructor.inputFromStream = function(is) {
        return new BitIO.StreamInputBits(is);
    };
    constructor.outputFromStream = function(out) {
        return new BitIO.StreamOutputBits(out);
    };
    constructor.inputFromArray = function(bytes) {
        return new BitIO.StreamInputBits(new ByteArrayInputStream(bytes));
    };
    constructor.outputFromArray = function(bytes) {
        return new BitIO.StreamOutputBits(new (stjs.extend(function BitIO$1() {
            BaseOutputStream.call(this);
        }, BaseOutputStream, [], function(constructor, prototype) {
            prototype.ptr = 0;
            prototype.writeByte = function(b) {
                if (this.ptr >= bytes.length) 
                     throw new IOException("Buffer is full");
                bytes[this.ptr++] = (b << 24 >> 24);
            };
        }, {}, {}))());
    };
    constructor.compressBits = function(decompressed) {
        var compressed = new Int8Array((decompressed.length >> 3) + 1);
        var out = BitIO.outputFromArray(compressed);
        try {
            for (var i = 0; i < decompressed.length; i++) {
                var bit = decompressed[i];
                out.putBit(bit);
            }
        }catch (e) {}
        return compressed;
    };
    constructor.decompressBits = function(compressed) {
        var decompressed = new Int32Array(compressed.length << 3);
        var inputFromArray = BitIO.inputFromArray(compressed);
        var read;
        try {
            for (var i = 0; (read = inputFromArray.getBit()) != -1; i++) {
                decompressed[i] = read;
            }
        }catch (e) {}
        return decompressed;
    };
    constructor.StreamInputBits = function(_in) {
        this._in = _in;
        this.bit = 8;
    };
    constructor.StreamInputBits = stjs.extend(constructor.StreamInputBits, null, [BitIO.InputBits], function(constructor, prototype) {
        prototype._in = null;
        prototype.cur = 0;
        prototype.bit = 0;
        prototype.getBit = function() {
            if (this.bit > 7) {
                this.cur = this._in.read();
                if (this.cur == -1) 
                    return -1;
                this.bit = 0;
            }
            return (this.cur >> (7 - this.bit++)) & 1;
        };
    }, {_in: "InputStream"}, {});
    constructor.StreamOutputBits = function(out) {
        this.out = out;
    };
    constructor.StreamOutputBits = stjs.extend(constructor.StreamOutputBits, null, [BitIO.OutputBits], function(constructor, prototype) {
        prototype.out = null;
        prototype.cur = 0;
        prototype.bit = 0;
        prototype.putBit = function(symbol) {
            if (this.bit > 7) {
                this.out.write(this.cur);
                this.cur = 0;
                this.bit = 0;
            }
            this.cur |= (symbol & 1) << (7 - this.bit++);
        };
        prototype.flush = function() {
            if (this.bit > 0) 
                this.out.write(this.cur);
        };
    }, {out: "OutputStream"}, {});
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Class for convenient reading JPEG entropy coded bit stream
 *  
 *  @author The JCodec project
 *  
 */
var JPEGBitStream = function(b, huff, lumaLen) {
    this.dcPredictor = new Int32Array(3);
    this._in = BitReader.createBitReader(b);
    this.huff = huff;
    this.lumaLen = lumaLen;
};
JPEGBitStream = stjs.extend(JPEGBitStream, null, [], function(constructor, prototype) {
    prototype.huff = null;
    prototype._in = null;
    prototype.dcPredictor = null;
    prototype.lumaLen = 0;
    prototype.readMCU = function(buf) {
        var blk = 0;
        for (var i = 0; i < this.lumaLen; i++ , blk++) {
            this.dcPredictor[0] = buf[blk][0] = this.readDCValue(this.dcPredictor[0], this.huff[0]);
            this.readACValues(buf[blk], this.huff[2]);
        }
        this.dcPredictor[1] = buf[blk][0] = this.readDCValue(this.dcPredictor[1], this.huff[1]);
        this.readACValues(buf[blk], this.huff[3]);
        ++blk;
        this.dcPredictor[2] = buf[blk][0] = this.readDCValue(this.dcPredictor[2], this.huff[1]);
        this.readACValues(buf[blk], this.huff[3]);
        ++blk;
    };
    prototype.readDCValue = function(prevDC, table) {
        var code = table.readVLC(this._in);
        return code != 0 ? this.toValue(this._in.readNBit(code), code) + prevDC : prevDC;
    };
    prototype.readACValues = function(target, table) {
        var code;
        var curOff = 1;
        do {
            code = table.readVLC(this._in);
            if (code == 240) {
                curOff += 16;
            } else if (code > 0) {
                var rle = code >> 4;
                curOff += rle;
                var len = code & 15;
                target[curOff] = this.toValue(this._in.readNBit(len), len);
                curOff++;
            }
        } while (code != 0 && curOff < 64);
    };
    prototype.toValue = function(raw, length) {
        return (length >= 1 && raw < (1 << length - 1)) ? -(1 << length) + 1 + raw : raw;
    };
}, {huff: "Array", _in: "BitReader", dcPredictor: "Int32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  The data is -128 shifted, so 0 is represented by -128 and 255 is represented
 *  by +127
 *  
 *  @author The JCodec project
 *  
 */
var Picture8Bit = function(width, height, data, color, crop) {
    this.width = width;
    this.height = height;
    this.data = data;
    this.color = color;
    this.crop = crop;
    if (color != null) {
        for (var i = 0; i < color.nComp; i++) {
            var mask = 255 >> (8 - color.compWidth[i]);
            if ((width & mask) != 0) 
                 throw new IllegalArgumentException("Component " + i + " width should be a multiple of " + (1 << color.compWidth[i]) + " for colorspace: " + color);
            if (crop != null && (crop.getWidth() & mask) != 0) 
                 throw new IllegalArgumentException("Component " + i + " cropped width should be a multiple of " + (1 << color.compWidth[i]) + " for colorspace: " + color);
            mask = 255 >> (8 - color.compHeight[i]);
            if ((height & mask) != 0) 
                 throw new IllegalArgumentException("Component " + i + " height should be a multiple of " + (1 << color.compHeight[i]) + " for colorspace: " + color);
            if (crop != null && (crop.getHeight() & mask) != 0) 
                 throw new IllegalArgumentException("Component " + i + " cropped height should be a multiple of " + (1 << color.compHeight[i]) + " for colorspace: " + color);
        }
    }
};
Picture8Bit = stjs.extend(Picture8Bit, null, [], function(constructor, prototype) {
    prototype.color = null;
    prototype.width = 0;
    prototype.height = 0;
    prototype.data = null;
    prototype.crop = null;
    constructor.createPicture8Bit = function(width, height, data, color) {
        return new Picture8Bit(width, height, data, color, new Rect(0, 0, width, height));
    };
    constructor.copyPicture8Bit = function(other) {
        return new Picture8Bit(other.width, other.height, other.data, other.color, other.crop);
    };
    constructor.create = function(width, height, colorSpace) {
        return Picture8Bit.createCropped(width, height, colorSpace, null);
    };
    constructor.createCropped = function(width, height, colorSpace, crop) {
        var planeSizes = new Int32Array(ColorSpace.MAX_PLANES);
        for (var i = 0; i < colorSpace.nComp; i++) {
            planeSizes[colorSpace.compPlane[i]] += (width >> colorSpace.compWidth[i]) * (height >> colorSpace.compHeight[i]);
        }
        var nPlanes = 0;
        for (var i = 0; i < ColorSpace.MAX_PLANES; i++) 
            nPlanes += planeSizes[i] != 0 ? 1 : 0;
        var data = Array(nPlanes);
        for (var i = 0, plane = 0; i < ColorSpace.MAX_PLANES; i++) {
            if (planeSizes[i] != 0) {
                data[plane++] = new Int8Array(planeSizes[i]);
            }
        }
        return new Picture8Bit(width, height, data, colorSpace, crop);
    };
    prototype.getWidth = function() {
        return this.width;
    };
    prototype.getHeight = function() {
        return this.height;
    };
    prototype.getPlaneData = function(plane) {
        return this.data[plane];
    };
    prototype.getColor = function() {
        return this.color;
    };
    prototype.getData = function() {
        return this.data;
    };
    prototype.getCrop = function() {
        return this.crop;
    };
    prototype.getPlaneWidth = function(plane) {
        return this.width >> this.color.compWidth[plane];
    };
    prototype.getPlaneHeight = function(plane) {
        return this.height >> this.color.compHeight[plane];
    };
    prototype.compatible = function(src) {
        return src.color == this.color && src.width == this.width && src.height == this.height;
    };
    prototype.createCompatible = function() {
        return Picture8Bit.create(this.width, this.height, this.color);
    };
    prototype.copyFrom = function(src) {
        if (!this.compatible(src)) 
             throw new IllegalArgumentException("Can not copy to incompatible picture");
        for (var plane = 0; plane < this.color.nComp; plane++) {
            if (this.data[plane] == null) 
                continue;
            System.arraycopy(src.data[plane], 0, this.data[plane], 0, (this.width >> this.color.compWidth[plane]) * (this.height >> this.color.compHeight[plane]));
        }
    };
    /**
     *  Creates a cropped clone of this picture.
     *  
     *  @return
     */
    prototype.cloneCropped = function() {
        if (this.cropNeeded()) {
            return this.cropped();
        } else {
            var clone = this.createCompatible();
            clone.copyFrom(this);
            return clone;
        }
    };
    prototype.cropped = function() {
        if (!this.cropNeeded()) 
            return this;
        var result = Picture8Bit.create(this.crop.getWidth(), this.crop.getHeight(), this.color);
        for (var plane = 0; plane < this.color.nComp; plane++) {
            if (this.data[plane] == null) 
                continue;
            this.cropSub(this.data[plane], this.crop.getX() >> this.color.compWidth[plane], this.crop.getY() >> this.color.compHeight[plane], this.crop.getWidth() >> this.color.compWidth[plane], this.crop.getHeight() >> this.color.compHeight[plane], this.width >> this.color.compWidth[plane], result.data[plane]);
        }
        return result;
    };
    prototype.cropNeeded = function() {
        return this.crop != null && (this.crop.getX() != 0 || this.crop.getY() != 0 || this.crop.getWidth() != this.width || this.crop.getHeight() != this.height);
    };
    prototype.cropSub = function(src, x, y, w, h, srcStride, tgt) {
        var srcOff = y * srcStride + x, dstOff = 0;
        for (var i = 0; i < h; i++) {
            for (var j = 0; j < w; j++) 
                tgt[dstOff + j] = src[srcOff + j];
            srcOff += srcStride;
            dstOff += w;
        }
    };
    prototype.setCrop = function(crop) {
        this.crop = crop;
    };
    prototype.getCroppedWidth = function() {
        return this.crop == null ? this.width : this.crop.getWidth();
    };
    prototype.getCroppedHeight = function() {
        return this.crop == null ? this.height : this.crop.getHeight();
    };
    constructor.fromPicture = function(pic) {
        var create = Picture8Bit.createCropped(pic.getWidth(), pic.getHeight(), pic.getColor(), pic.getCrop());
        for (var i = 0; i < Math.min(pic.getData().length, create.getData().length); i++) {
            for (var j = 0; j < Math.min(pic.getData()[i].length, create.getData()[i].length); j++) {
                create.getData()[i][j] = ((((pic.getData()[i][j] << 8) >> pic.getBitDepth()) - 128) << 24 >> 24);
            }
        }
        return create;
    };
    prototype.toPicture = function(bitDepth) {
        var create = Picture.doCreate(this.width, this.height, this.color, bitDepth, this.crop);
        return this.toPictureInternal(bitDepth, create);
    };
    prototype.toPictureWithBuffer = function(bitDepth, buffer) {
        var create = new Picture(this.width, this.height, buffer, this.color, bitDepth, this.crop);
        return this.toPictureInternal(bitDepth, create);
    };
    prototype.toPictureInternal = function(bitDepth, create) {
        for (var i = 0; i < this.data.length; i++) {
            var planeSize = this.getPlaneWidth(i) * this.getPlaneHeight(i);
            for (var j = 0; j < planeSize; j++) {
                create.getData()[i][j] = ((this.data[i][j] + 128) << bitDepth) >> 8;
            }
        }
        return create;
    };
    prototype.fill = function(val) {
        for (var i = 0; i < this.data.length; i++) {
            Arrays.fill(this.data[i], (val << 24 >> 24));
        }
    };
    prototype.equals = function(obj) {
        if (obj == null || !(stjs.isInstanceOf(obj.constructor, Picture8Bit))) 
            return false;
        var other = obj;
        if (other.getCroppedWidth() != this.getCroppedWidth() || other.getCroppedHeight() != this.getCroppedHeight() || other.getColor() != this.color) 
            return false;
        for (var i = 0; i < this.getData().length; i++) 
            if (!this.planeEquals(other, i)) 
                return false;
        return true;
    };
    prototype.planeEquals = function(other, plane) {
        var cw = this.color.compWidth[plane];
        var ch = this.color.compHeight[plane];
        var offA = other.getCrop() == null ? 0 : ((other.getCrop().getX() >> cw) + (other.getCrop().getY() >> ch) * (other.getWidth() >> cw));
        var offB = this.crop == null ? 0 : ((this.crop.getX() >> cw) + (this.crop.getY() >> ch) * (this.width >> cw));
        var planeData = other.getPlaneData(plane);
        for (var i = 0; i < this.getCroppedHeight() >> ch; i++ , offA += (other.getWidth() >> cw) , offB += (this.width >> cw)) {
            for (var j = 0; j < this.getCroppedWidth() >> cw; j++) {
                if (planeData[offA + j] != this.data[plane][offB + j]) 
                    return false;
            }
        }
        return true;
    };
}, {color: "ColorSpace", data: "Array", crop: "Rect"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var GOPHeader = function(timeCode, closedGop, brokenLink) {
    this.timeCode = timeCode;
    this.closedGop = closedGop;
    this.brokenLink = brokenLink;
};
GOPHeader = stjs.extend(GOPHeader, null, [MPEGHeader], function(constructor, prototype) {
    prototype.timeCode = null;
    prototype.closedGop = false;
    prototype.brokenLink = false;
    constructor.read = function(bb) {
        var _in = BitReader.createBitReader(bb);
        var dropFrame = _in.read1Bit() == 1;
        var hours = ((_in.readNBit(5)) << 16 >> 16);
        var minutes = (_in.readNBit(6) << 24 >> 24);
        _in.skip(1);
        var seconds = (_in.readNBit(6) << 24 >> 24);
        var frames = (_in.readNBit(6) << 24 >> 24);
        var closedGop = _in.read1Bit() == 1;
        var brokenLink = _in.read1Bit() == 1;
        return new GOPHeader(new TapeTimecode(hours, minutes, seconds, frames, dropFrame), closedGop, brokenLink);
    };
    prototype.write = function(bb) {
        var bw = new BitWriter(bb);
        if (this.timeCode == null) 
            bw.writeNBit(0, 25);
         else {
            bw.write1Bit(this.timeCode.isDropFrame() ? 1 : 0);
            bw.writeNBit(this.timeCode.getHour(), 5);
            bw.writeNBit(this.timeCode.getMinute(), 6);
            bw.write1Bit(1);
            bw.writeNBit(this.timeCode.getSecond(), 6);
            bw.writeNBit(this.timeCode.getFrame(), 6);
        }
        bw.write1Bit(this.closedGop ? 1 : 0);
        bw.write1Bit(this.brokenLink ? 1 : 0);
        bw.flush();
    };
    prototype.getTimeCode = function() {
        return this.timeCode;
    };
    prototype.isClosedGop = function() {
        return this.closedGop;
    };
    prototype.isBrokenLink = function() {
        return this.brokenLink;
    };
}, {timeCode: "TapeTimecode"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var SequenceDisplayExtension = function() {};
SequenceDisplayExtension = stjs.extend(SequenceDisplayExtension, null, [MPEGHeader], function(constructor, prototype) {
    prototype.video_format = 0;
    prototype.display_horizontal_size = 0;
    prototype.display_vertical_size = 0;
    prototype.colorDescription = null;
    constructor.Sequence_Display_Extension = 2;
    constructor.ColorDescription = function() {};
    constructor.ColorDescription = stjs.extend(constructor.ColorDescription, null, [], function(constructor, prototype) {
        prototype.colour_primaries = 0;
        prototype.transfer_characteristics = 0;
        prototype.matrix_coefficients = 0;
        constructor.read = function(_in) {
            var cd = new SequenceDisplayExtension.ColorDescription();
            cd.colour_primaries = _in.readNBit(8);
            cd.transfer_characteristics = _in.readNBit(8);
            cd.matrix_coefficients = _in.readNBit(8);
            return cd;
        };
        prototype.write = function(out) {
            out.writeNBit(this.colour_primaries, 8);
            out.writeNBit(this.transfer_characteristics, 8);
            out.writeNBit(this.matrix_coefficients, 8);
        };
    }, {}, {});
    constructor.read = function(_in) {
        var sde = new SequenceDisplayExtension();
        sde.video_format = _in.readNBit(3);
        if (_in.read1Bit() == 1) {
            sde.colorDescription = SequenceDisplayExtension.ColorDescription.read(_in);
        }
        sde.display_horizontal_size = _in.readNBit(14);
        _in.read1Bit();
        sde.display_vertical_size = _in.readNBit(14);
        return sde;
    };
    prototype.write = function(bb) {
        var bw = new BitWriter(bb);
        bw.writeNBit(SequenceDisplayExtension.Sequence_Display_Extension, 4);
        bw.writeNBit(this.video_format, 3);
        bw.write1Bit(this.colorDescription != null ? 1 : 0);
        if (this.colorDescription != null) 
            this.colorDescription.write(bw);
        bw.writeNBit(this.display_horizontal_size, 14);
        bw.write1Bit(1);
        bw.writeNBit(this.display_vertical_size, 14);
        bw.flush();
    };
}, {colorDescription: "SequenceDisplayExtension.ColorDescription"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var PictureSpatialScalableExtension = function() {};
PictureSpatialScalableExtension = stjs.extend(PictureSpatialScalableExtension, null, [MPEGHeader], function(constructor, prototype) {
    prototype.lower_layer_temporal_reference = 0;
    prototype.lower_layer_horizontal_offset = 0;
    prototype.lower_layer_vertical_offset = 0;
    prototype.spatial_temporal_weight_code_table_index = 0;
    prototype.lower_layer_progressive_frame = 0;
    prototype.lower_layer_deinterlaced_field_select = 0;
    constructor.Picture_Spatial_Scalable_Extension = 9;
    constructor.read = function(_in) {
        var psse = new PictureSpatialScalableExtension();
        psse.lower_layer_temporal_reference = _in.readNBit(10);
        _in.read1Bit();
        psse.lower_layer_horizontal_offset = _in.readNBit(15);
        _in.read1Bit();
        psse.lower_layer_vertical_offset = _in.readNBit(15);
        psse.spatial_temporal_weight_code_table_index = _in.readNBit(2);
        psse.lower_layer_progressive_frame = _in.read1Bit();
        psse.lower_layer_deinterlaced_field_select = _in.read1Bit();
        return psse;
    };
    prototype.write = function(bb) {
        var bw = new BitWriter(bb);
        bw.writeNBit(PictureSpatialScalableExtension.Picture_Spatial_Scalable_Extension, 4);
        bw.writeNBit(this.lower_layer_temporal_reference, 10);
        bw.write1Bit(1);
        bw.writeNBit(this.lower_layer_horizontal_offset, 15);
        bw.write1Bit(1);
        bw.writeNBit(this.lower_layer_vertical_offset, 15);
        bw.writeNBit(this.spatial_temporal_weight_code_table_index, 2);
        bw.write1Bit(this.lower_layer_progressive_frame);
        bw.write1Bit(this.lower_layer_deinterlaced_field_select);
        bw.flush();
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var SequenceExtension = function() {};
SequenceExtension = stjs.extend(SequenceExtension, null, [MPEGHeader], function(constructor, prototype) {
    constructor.Chroma420 = 1;
    constructor.Chroma422 = 2;
    constructor.Chroma444 = 3;
    prototype.profile_and_level = 0;
    prototype.progressive_sequence = 0;
    prototype.chroma_format = 0;
    prototype.horizontal_size_extension = 0;
    prototype.vertical_size_extension = 0;
    prototype.bit_rate_extension = 0;
    prototype.vbv_buffer_size_extension = 0;
    prototype.low_delay = 0;
    prototype.frame_rate_extension_n = 0;
    prototype.frame_rate_extension_d = 0;
    constructor.Sequence_Extension = 1;
    constructor.createSequenceExtension = function(profile_and_level, progressive_sequence, chroma_format, horizontal_size_extension, vertical_size_extension, bit_rate_extension, vbv_buffer_size_extension, low_delay, frame_rate_extension_n, frame_rate_extension_d) {
        var se = new SequenceExtension();
        se.profile_and_level = profile_and_level;
        se.progressive_sequence = progressive_sequence;
        se.chroma_format = chroma_format;
        se.horizontal_size_extension = horizontal_size_extension;
        se.vertical_size_extension = vertical_size_extension;
        se.bit_rate_extension = bit_rate_extension;
        se.vbv_buffer_size_extension = vbv_buffer_size_extension;
        se.low_delay = low_delay;
        se.frame_rate_extension_n = frame_rate_extension_n;
        se.frame_rate_extension_d = frame_rate_extension_d;
        return se;
    };
    constructor.read = function(_in) {
        var se = new SequenceExtension();
        se.profile_and_level = _in.readNBit(8);
        se.progressive_sequence = _in.read1Bit();
        se.chroma_format = _in.readNBit(2);
        se.horizontal_size_extension = _in.readNBit(2);
        se.vertical_size_extension = _in.readNBit(2);
        se.bit_rate_extension = _in.readNBit(12);
        se.vbv_buffer_size_extension = _in.readNBit(8);
        se.low_delay = _in.read1Bit();
        se.frame_rate_extension_n = _in.readNBit(2);
        se.frame_rate_extension_d = _in.readNBit(5);
        return se;
    };
    prototype.write = function(bb) {
        var bw = new BitWriter(bb);
        bw.writeNBit(SequenceExtension.Sequence_Extension, 4);
        bw.writeNBit(this.profile_and_level, 8);
        bw.write1Bit(this.progressive_sequence);
        bw.writeNBit(this.chroma_format, 2);
        bw.writeNBit(this.horizontal_size_extension, 2);
        bw.writeNBit(this.vertical_size_extension, 2);
        bw.writeNBit(this.bit_rate_extension, 12);
        bw.write1Bit(1);
        bw.writeNBit(this.vbv_buffer_size_extension, 8);
        bw.write1Bit(this.low_delay);
        bw.writeNBit(this.frame_rate_extension_n, 2);
        bw.writeNBit(this.frame_rate_extension_d, 5);
        bw.flush();
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var ADTSParser = function() {};
ADTSParser = stjs.extend(ADTSParser, null, [], function(constructor, prototype) {
    constructor.Header = function(object_type, chanConfig, crcAbsent, numAACFrames, samplingIndex) {
        this.objectType = object_type;
        this.chanConfig = chanConfig;
        this.crcAbsent = crcAbsent;
        this.numAACFrames = numAACFrames;
        this.samplingIndex = samplingIndex;
    };
    constructor.Header = stjs.extend(constructor.Header, null, [], function(constructor, prototype) {
        prototype.objectType = 0;
        prototype.chanConfig = 0;
        prototype.crcAbsent = 0;
        prototype.numAACFrames = 0;
        prototype.samplingIndex = 0;
        prototype.samples = 0;
        prototype.getObjectType = function() {
            return this.objectType;
        };
        prototype.getChanConfig = function() {
            return this.chanConfig;
        };
        prototype.getCrcAbsent = function() {
            return this.crcAbsent;
        };
        prototype.getNumAACFrames = function() {
            return this.numAACFrames;
        };
        prototype.getSamplingIndex = function() {
            return this.samplingIndex;
        };
        prototype.getSamples = function() {
            return this.samples;
        };
    }, {}, {});
    constructor.read = function(data) {
        var dup = data.duplicate();
        var br = BitReader.createBitReader(dup);
        if (br.readNBit(12) != 4095) {
            return null;
        }
        var id = br.read1Bit();
        var layer = br.readNBit(2);
        var crc_abs = br.read1Bit();
        var aot = br.readNBit(2);
        var sr = br.readNBit(4);
        var pb = br.read1Bit();
        var ch = br.readNBit(3);
        var origCopy = br.read1Bit();
        var home = br.read1Bit();
        var copy = br.read1Bit();
        var copyStart = br.read1Bit();
        var size = br.readNBit(13);
        if (size < 7) 
            return null;
        var buffer = br.readNBit(11);
        var rdb = br.readNBit(2);
        br.stop();
        data.setPosition(dup.position());
        return new ADTSParser.Header(aot + 1, ch, crc_abs, rdb + 1, sr);
    };
    constructor.write = function(header, buf, frameSize) {
        var data = buf.duplicate();
        var br = new BitWriter(data);
        br.writeNBit(4095, 12);
        br.write1Bit(1);
        br.writeNBit(0, 2);
        br.write1Bit(header.getCrcAbsent());
        br.writeNBit(header.getObjectType(), 2);
        br.writeNBit(header.getSamplingIndex(), 4);
        br.write1Bit(0);
        br.writeNBit(header.getChanConfig(), 3);
        br.write1Bit(0);
        br.write1Bit(0);
        br.write1Bit(0);
        br.write1Bit(0);
        br.writeNBit(frameSize + 7, 13);
        br.writeNBit(0, 11);
        br.writeNBit(header.getNumAACFrames(), 2);
        br.flush();
        data.flip();
        return data;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var PictureCodingExtension = function() {
    this.f_code = Array.apply(null, Array(2)).map(function() {
        return new Int32Array(2);
    });
};
PictureCodingExtension = stjs.extend(PictureCodingExtension, null, [MPEGHeader], function(constructor, prototype) {
    constructor.Top_Field = 1;
    constructor.Bottom_Field = 2;
    constructor.Frame = 3;
    prototype.f_code = null;
    prototype.intra_dc_precision = 0;
    prototype.picture_structure = 0;
    prototype.top_field_first = 0;
    prototype.frame_pred_frame_dct = 0;
    prototype.concealment_motion_vectors = 0;
    prototype.q_scale_type = 0;
    prototype.intra_vlc_format = 0;
    prototype.alternate_scan = 0;
    prototype.repeat_first_field = 0;
    prototype.chroma_420_type = 0;
    prototype.progressive_frame = 0;
    prototype.compositeDisplay = null;
    constructor.Picture_Coding_Extension = 8;
    constructor.CompositeDisplay = function() {};
    constructor.CompositeDisplay = stjs.extend(constructor.CompositeDisplay, null, [], function(constructor, prototype) {
        prototype.v_axis = 0;
        prototype.field_sequence = 0;
        prototype.sub_carrier = 0;
        prototype.burst_amplitude = 0;
        prototype.sub_carrier_phase = 0;
        constructor.read = function(_in) {
            var cd = new PictureCodingExtension.CompositeDisplay();
            cd.v_axis = _in.read1Bit();
            cd.field_sequence = _in.readNBit(3);
            cd.sub_carrier = _in.read1Bit();
            cd.burst_amplitude = _in.readNBit(7);
            cd.sub_carrier_phase = _in.readNBit(8);
            return cd;
        };
        prototype.write = function(out) {
            out.write1Bit(this.v_axis);
            out.writeNBit(this.field_sequence, 3);
            out.write1Bit(this.sub_carrier);
            out.writeNBit(this.burst_amplitude, 7);
            out.writeNBit(this.sub_carrier_phase, 8);
        };
    }, {}, {});
    constructor.read = function(_in) {
        var pce = new PictureCodingExtension();
        pce.f_code[0][0] = _in.readNBit(4);
        pce.f_code[0][1] = _in.readNBit(4);
        pce.f_code[1][0] = _in.readNBit(4);
        pce.f_code[1][1] = _in.readNBit(4);
        pce.intra_dc_precision = _in.readNBit(2);
        pce.picture_structure = _in.readNBit(2);
        pce.top_field_first = _in.read1Bit();
        pce.frame_pred_frame_dct = _in.read1Bit();
        pce.concealment_motion_vectors = _in.read1Bit();
        pce.q_scale_type = _in.read1Bit();
        pce.intra_vlc_format = _in.read1Bit();
        pce.alternate_scan = _in.read1Bit();
        pce.repeat_first_field = _in.read1Bit();
        pce.chroma_420_type = _in.read1Bit();
        pce.progressive_frame = _in.read1Bit();
        if (_in.read1Bit() != 0) {
            pce.compositeDisplay = PictureCodingExtension.CompositeDisplay.read(_in);
        }
        return pce;
    };
    prototype.write = function(bb) {
        var bw = new BitWriter(bb);
        bw.writeNBit(PictureCodingExtension.Picture_Coding_Extension, 4);
        bw.writeNBit(this.f_code[0][0], 4);
        bw.writeNBit(this.f_code[0][1], 4);
        bw.writeNBit(this.f_code[1][0], 4);
        bw.writeNBit(this.f_code[1][1], 4);
        bw.writeNBit(this.intra_dc_precision, 2);
        bw.writeNBit(this.picture_structure, 2);
        bw.write1Bit(this.top_field_first);
        bw.write1Bit(this.frame_pred_frame_dct);
        bw.write1Bit(this.concealment_motion_vectors);
        bw.write1Bit(this.q_scale_type);
        bw.write1Bit(this.intra_vlc_format);
        bw.write1Bit(this.alternate_scan);
        bw.write1Bit(this.repeat_first_field);
        bw.write1Bit(this.chroma_420_type);
        bw.write1Bit(this.progressive_frame);
        bw.write1Bit(this.compositeDisplay != null ? 1 : 0);
        if (this.compositeDisplay != null) 
            this.compositeDisplay.write(bw);
        bw.flush();
    };
}, {f_code: "Array", compositeDisplay: "PictureCodingExtension.CompositeDisplay"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var QuantMatrixExtension = function() {};
QuantMatrixExtension = stjs.extend(QuantMatrixExtension, null, [MPEGHeader], function(constructor, prototype) {
    prototype.intra_quantiser_matrix = null;
    prototype.non_intra_quantiser_matrix = null;
    prototype.chroma_intra_quantiser_matrix = null;
    prototype.chroma_non_intra_quantiser_matrix = null;
    constructor.Quant_Matrix_Extension = 3;
    constructor.read = function(_in) {
        var qme = new QuantMatrixExtension();
        if (_in.read1Bit() != 0) 
            qme.intra_quantiser_matrix = QuantMatrixExtension.readQMat(_in);
        if (_in.read1Bit() != 0) 
            qme.non_intra_quantiser_matrix = QuantMatrixExtension.readQMat(_in);
        if (_in.read1Bit() != 0) 
            qme.chroma_intra_quantiser_matrix = QuantMatrixExtension.readQMat(_in);
        if (_in.read1Bit() != 0) 
            qme.chroma_non_intra_quantiser_matrix = QuantMatrixExtension.readQMat(_in);
        return qme;
    };
    constructor.readQMat = function(_in) {
        var qmat = new Int32Array(64);
        for (var i = 0; i < 64; i++) 
            qmat[i] = _in.readNBit(8);
        return qmat;
    };
    prototype.write = function(bb) {
        var bw = new BitWriter(bb);
        bw.writeNBit(QuantMatrixExtension.Quant_Matrix_Extension, 4);
        bw.write1Bit(this.intra_quantiser_matrix != null ? 1 : 0);
        if (this.intra_quantiser_matrix != null) 
            this.writeQMat(this.intra_quantiser_matrix, bw);
        bw.write1Bit(this.non_intra_quantiser_matrix != null ? 1 : 0);
        if (this.non_intra_quantiser_matrix != null) 
            this.writeQMat(this.non_intra_quantiser_matrix, bw);
        bw.write1Bit(this.chroma_intra_quantiser_matrix != null ? 1 : 0);
        if (this.chroma_intra_quantiser_matrix != null) 
            this.writeQMat(this.chroma_intra_quantiser_matrix, bw);
        bw.write1Bit(this.chroma_non_intra_quantiser_matrix != null ? 1 : 0);
        if (this.chroma_non_intra_quantiser_matrix != null) 
            this.writeQMat(this.chroma_non_intra_quantiser_matrix, bw);
        bw.flush();
    };
    prototype.writeQMat = function(matrix, ob) {
        for (var i = 0; i < 64; i++) 
            ob.writeNBit(matrix[i], 8);
    };
}, {intra_quantiser_matrix: "Int32Array", non_intra_quantiser_matrix: "Int32Array", chroma_intra_quantiser_matrix: "Int32Array", chroma_non_intra_quantiser_matrix: "Int32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var CopyrightExtension = function() {};
CopyrightExtension = stjs.extend(CopyrightExtension, null, [MPEGHeader], function(constructor, prototype) {
    prototype.copyright_flag = 0;
    prototype.copyright_identifier = 0;
    prototype.original_or_copy = 0;
    prototype.copyright_number_1 = 0;
    prototype.copyright_number_2 = 0;
    prototype.copyright_number_3 = 0;
    constructor.Copyright_Extension = 4;
    constructor.read = function(_in) {
        var ce = new CopyrightExtension();
        ce.copyright_flag = _in.read1Bit();
        ce.copyright_identifier = _in.readNBit(8);
        ce.original_or_copy = _in.read1Bit();
        _in.skip(7);
        _in.read1Bit();
        ce.copyright_number_1 = _in.readNBit(20);
        _in.read1Bit();
        ce.copyright_number_2 = _in.readNBit(22);
        _in.read1Bit();
        ce.copyright_number_3 = _in.readNBit(22);
        return ce;
    };
    prototype.write = function(bb) {
        var bw = new BitWriter(bb);
        bw.writeNBit(CopyrightExtension.Copyright_Extension, 4);
        bw.write1Bit(this.copyright_flag);
        bw.writeNBit(this.copyright_identifier, 8);
        bw.write1Bit(this.original_or_copy);
        bw.writeNBit(0, 7);
        bw.write1Bit(1);
        bw.writeNBit(this.copyright_number_1, 20);
        bw.write1Bit(1);
        bw.writeNBit(this.copyright_number_2, 22);
        bw.write1Bit(1);
        bw.writeNBit(this.copyright_number_3, 22);
        bw.flush();
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var PictureTemporalScalableExtension = function() {};
PictureTemporalScalableExtension = stjs.extend(PictureTemporalScalableExtension, null, [MPEGHeader], function(constructor, prototype) {
    prototype.reference_select_code = 0;
    prototype.forward_temporal_reference = 0;
    prototype.backward_temporal_reference = 0;
    constructor.Picture_Temporal_Scalable_Extension = 16;
    constructor.read = function(_in) {
        var ptse = new PictureTemporalScalableExtension();
        ptse.reference_select_code = _in.readNBit(2);
        ptse.forward_temporal_reference = _in.readNBit(10);
        _in.read1Bit();
        ptse.backward_temporal_reference = _in.readNBit(10);
        return ptse;
    };
    prototype.write = function(bb) {
        var bw = new BitWriter(bb);
        bw.writeNBit(PictureTemporalScalableExtension.Picture_Temporal_Scalable_Extension, 4);
        bw.writeNBit(this.reference_select_code, 2);
        bw.writeNBit(this.forward_temporal_reference, 10);
        bw.write1Bit(1);
        bw.writeNBit(this.backward_temporal_reference, 10);
        bw.flush();
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Table-based prefix VLC reader
 *  
 *  @author The JCodec project
 *  
 */
var VLC = function(codes, codeSizes) {
    this.codes = codes;
    this.codeSizes = codeSizes;
    this._invert();
};
VLC = stjs.extend(VLC, null, [], function(constructor, prototype) {
    /**
     *  @param arguments
     *             vlc codes
     *  @return
     */
    constructor.createVLC = function(_arguments) {
        var _codes = IntArrayList.createIntArrayList();
        var _codeSizes = IntArrayList.createIntArrayList();
        for (var i = 0; i < arguments.length; i++) {
            var string = arguments[i];
            _codes.add(Integer.parseInt(string, 2) << (32 - string.length));
            _codeSizes.add(string.length);
        }
        var vlc = new VLC(_codes.toArray(), _codeSizes.toArray());
        return vlc;
    };
    prototype.codes = null;
    prototype.codeSizes = null;
    prototype.values = null;
    prototype.valueSizes = null;
    prototype._invert = function() {
        var values = IntArrayList.createIntArrayList();
        var valueSizes = IntArrayList.createIntArrayList();
        this.invert(0, 0, 0, values, valueSizes);
        this.values = values.toArray();
        this.valueSizes = valueSizes.toArray();
    };
    prototype.invert = function(startOff, level, prefix, values, valueSizes) {
        var tableEnd = startOff + 256;
        values.fill(startOff, tableEnd, -1);
        valueSizes.fill(startOff, tableEnd, 0);
        var prefLen = level << 3;
        for (var i = 0; i < this.codeSizes.length; i++) {
            if ((this.codeSizes[i] <= prefLen) || (level > 0 && (this.codes[i] >>> (32 - prefLen)) != prefix)) 
                continue;
            var pref = this.codes[i] >>> (32 - prefLen - 8);
            var code = pref & 255;
            var len = this.codeSizes[i] - prefLen;
            if (len <= 8) {
                for (var k = 0; k < (1 << (8 - len)); k++) {
                    values.set(startOff + code + k, i);
                    valueSizes.set(startOff + code + k, len);
                }
            } else {
                if (values.get(startOff + code) == -1) {
                    values.set(startOff + code, tableEnd);
                    tableEnd = this.invert(tableEnd, level + 1, pref, values, valueSizes);
                }
            }
        }
        return tableEnd;
    };
    prototype.readVLC16 = function(_in) {
        var string = _in.check16Bits();
        var b = string >>> 8;
        var code = this.values[b];
        var len = this.valueSizes[b];
        if (len == 0) {
            b = (string & 255) + code;
            code = this.values[b];
            _in.skipFast(8 + this.valueSizes[b]);
        } else 
            _in.skipFast(len);
        return code;
    };
    prototype.readVLC = function(_in) {
        var code = 0, len = 0, overall = 0, total = 0;
        for (var i = 0; len == 0; i++) {
            var string = _in.checkNBit(8);
            var ind = string + code;
            code = this.values[ind];
            len = this.valueSizes[ind];
            var bits = len != 0 ? len : 8;
            total += bits;
            overall = (overall << bits) | (string >> (8 - bits));
            _in.skip(bits);
            if (code == -1) 
                 throw new RuntimeException("Invalid code prefix " + this.binary(overall, (i << 3) + bits));
        }
        return code;
    };
    prototype.binary = function(string, len) {
        var symb = new Uint16Array(len);
        for (var i = 0; i < len; i++) {
            symb[i] = (string & (1 << (len - i - 1))) != 0 ? '1' : '0';
        }
        return new String(symb);
    };
    prototype.writeVLC = function(out, code) {
        out.writeNBit(this.codes[code] >>> (32 - this.codeSizes[code]), this.codeSizes[code]);
    };
    prototype.printTable = function(ps) {
        for (var i = 0; i < this.values.length; i++) {
            ps.println(i + ": " + this.extracted(i) + " (" + this.valueSizes[i] + ") -> " + this.values[i]);
        }
    };
    prototype.extracted = function(num) {
        var str = Integer.toString(num & 255, 2);
        var builder = new StringBuilder();
        for (var i = 0; i < 8 - str.length; i++) 
            builder.append('0');
        builder.append(str);
        return builder.toString();
    };
    prototype.getCodes = function() {
        return this.codes;
    };
    prototype.getCodeSizes = function() {
        return this.codeSizes;
    };
}, {codes: "Int32Array", codeSizes: "Int32Array", values: "Int32Array", valueSizes: "Int32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Represents PAT ( Program Association Table ) PSI payload of MPEG Transport
 *  stream
 *  
 *  @author The JCodec project
 *  
 */
var PATSection = function(psi, networkPids, programs) {
    PSISection.call(this, psi.tableId, psi.specificId, psi.versionNumber, psi.currentNextIndicator, psi.sectionNumber, psi.lastSectionNumber);
    this.networkPids = networkPids;
    this.programs = programs;
};
PATSection = stjs.extend(PATSection, PSISection, [], function(constructor, prototype) {
    prototype.networkPids = null;
    prototype.programs = null;
    prototype.getNetworkPids = function() {
        return this.networkPids;
    };
    prototype.getPrograms = function() {
        return this.programs;
    };
    constructor.parsePAT = function(data) {
        var psi = PSISection.parsePSI(data);
        var networkPids = IntArrayList.createIntArrayList();
        var programs = new IntIntMap();
         while (data.remaining() > 4){
            var programNum = data.getShort() & 65535;
            var w = data.getShort();
            var pid = w & 8191;
            if (programNum == 0) 
                networkPids.add(pid);
             else 
                programs.put(programNum, pid);
        }
        return new PATSection(psi, networkPids.toArray(), programs);
    };
}, {networkPids: "Int32Array", programs: "IntIntMap"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license. 
 * 
 *  @author in-somnia
 */
var HFGeneration = function() {};
HFGeneration = stjs.extend(HFGeneration, null, [], function(constructor, prototype) {
    constructor.goalSbTab = new Int32Array([21, 23, 32, 43, 46, 64, 85, 93, 128, 0, 0, 0]);
    constructor.acorr_coef = function() {
        this.r01 = new Float32Array(2);
        this.r02 = new Float32Array(2);
        this.r11 = new Float32Array(2);
        this.r12 = new Float32Array(2);
        this.r22 = new Float32Array(2);
    };
    constructor.acorr_coef = stjs.extend(constructor.acorr_coef, null, [], function(constructor, prototype) {
        prototype.r01 = null;
        prototype.r02 = null;
        prototype.r11 = null;
        prototype.r12 = null;
        prototype.r22 = null;
        prototype.det = 0.0;
    }, {r01: "Float32Array", r02: "Float32Array", r11: "Float32Array", r12: "Float32Array", r22: "Float32Array"}, {});
    constructor.hf_generation = function(sbr, Xlow, Xhigh, ch) {
        var l, i, x;
        var alpha_0 = Array.apply(null, Array(64)).map(function() {
            return new Float32Array(2);
        }), alpha_1 = Array.apply(null, Array(64)).map(function() {
            return new Float32Array(2);
        });
        var offset = sbr.tHFAdj;
        var first = sbr.t_E[ch][0];
        var last = sbr.t_E[ch][sbr.L_E[ch]];
        HFGeneration.calc_chirp_factors(sbr, ch);
        if ((ch == 0) && (sbr.Reset)) 
            HFGeneration.patch_construction(sbr);
        for (i = 0; i < sbr.noPatches; i++) {
            for (x = 0; x < sbr.patchNoSubbands[i]; x++) {
                var a0_r, a0_i, a1_r, a1_i;
                var bw, bw2;
                var q, p, k, g;
                k = sbr.kx + x;
                for (q = 0; q < i; q++) {
                    k += sbr.patchNoSubbands[q];
                }
                p = sbr.patchStartSubband[i] + x;
                g = sbr.table_map_k_to_g[k];
                bw = sbr.bwArray[ch][g];
                bw2 = bw * bw;
                if (bw2 > 0) {
                    var temp1_r, temp2_r, temp3_r;
                    var temp1_i, temp2_i, temp3_i;
                    HFGeneration.calc_prediction_coef(sbr, Xlow, alpha_0, alpha_1, p);
                    a0_r = (alpha_0[p][0] * bw);
                    a1_r = (alpha_1[p][0] * bw2);
                    a0_i = (alpha_0[p][1] * bw);
                    a1_i = (alpha_1[p][1] * bw2);
                    temp2_r = (Xlow[first - 2 + offset][p][0]);
                    temp3_r = (Xlow[first - 1 + offset][p][0]);
                    temp2_i = (Xlow[first - 2 + offset][p][1]);
                    temp3_i = (Xlow[first - 1 + offset][p][1]);
                    for (l = first; l < last; l++) {
                        temp1_r = temp2_r;
                        temp2_r = temp3_r;
                        temp3_r = (Xlow[l + offset][p][0]);
                        temp1_i = temp2_i;
                        temp2_i = temp3_i;
                        temp3_i = (Xlow[l + offset][p][1]);
                        Xhigh[l + offset][k][0] = temp3_r + ((a0_r * temp2_r) - (a0_i * temp2_i) + (a1_r * temp1_r) - (a1_i * temp1_i));
                        Xhigh[l + offset][k][1] = temp3_i + ((a0_i * temp2_r) + (a0_r * temp2_i) + (a1_i * temp1_r) + (a1_r * temp1_i));
                    }
                } else {
                    for (l = first; l < last; l++) {
                        Xhigh[l + offset][k][0] = Xlow[l + offset][p][0];
                        Xhigh[l + offset][k][1] = Xlow[l + offset][p][1];
                    }
                }
            }
        }
        if (sbr.Reset) {
            FBT.limiter_frequency_table(sbr);
        }
    };
    constructor.auto_correlation = function(sbr, ac, buffer, bd, len) {
        var r01r = 0, r01i = 0, r02r = 0, r02i = 0, r11r = 0;
        var temp1_r, temp1_i, temp2_r, temp2_i, temp3_r, temp3_i, temp4_r, temp4_i, temp5_r, temp5_i;
        var rel = 1.0 / (1 + 1.0E-6);
        var j;
        var offset = sbr.tHFAdj;
        temp2_r = buffer[offset - 2][bd][0];
        temp2_i = buffer[offset - 2][bd][1];
        temp3_r = buffer[offset - 1][bd][0];
        temp3_i = buffer[offset - 1][bd][1];
        temp4_r = temp2_r;
        temp4_i = temp2_i;
        temp5_r = temp3_r;
        temp5_i = temp3_i;
        for (j = offset; j < len + offset; j++) {
            temp1_r = temp2_r;
            temp1_i = temp2_i;
            temp2_r = temp3_r;
            temp2_i = temp3_i;
            temp3_r = buffer[j][bd][0];
            temp3_i = buffer[j][bd][1];
            r01r += temp3_r * temp2_r + temp3_i * temp2_i;
            r01i += temp3_i * temp2_r - temp3_r * temp2_i;
            r02r += temp3_r * temp1_r + temp3_i * temp1_i;
            r02i += temp3_i * temp1_r - temp3_r * temp1_i;
            r11r += temp2_r * temp2_r + temp2_i * temp2_i;
        }
        ac.r12[0] = r01r - (temp3_r * temp2_r + temp3_i * temp2_i) + (temp5_r * temp4_r + temp5_i * temp4_i);
        ac.r12[1] = r01i - (temp3_i * temp2_r - temp3_r * temp2_i) + (temp5_i * temp4_r - temp5_r * temp4_i);
        ac.r22[0] = r11r - (temp2_r * temp2_r + temp2_i * temp2_i) + (temp4_r * temp4_r + temp4_i * temp4_i);
        ac.r01[0] = r01r;
        ac.r01[1] = r01i;
        ac.r02[0] = r02r;
        ac.r02[1] = r02i;
        ac.r11[0] = r11r;
        ac.det = (ac.r11[0] * ac.r22[0]) - (rel * ((ac.r12[0] * ac.r12[0]) + (ac.r12[1] * ac.r12[1])));
    };
    constructor.calc_prediction_coef = function(sbr, Xlow, alpha_0, alpha_1, k) {
        var tmp;
        var ac = new HFGeneration.acorr_coef();
        HFGeneration.auto_correlation(sbr, ac, Xlow, k, sbr.numTimeSlotsRate + 6);
        if (ac.det == 0) {
            alpha_1[k][0] = 0;
            alpha_1[k][1] = 0;
        } else {
            tmp = 1.0 / ac.det;
            alpha_1[k][0] = ((ac.r01[0] * ac.r12[0]) - (ac.r01[1] * ac.r12[1]) - (ac.r02[0] * ac.r11[0])) * tmp;
            alpha_1[k][1] = ((ac.r01[1] * ac.r12[0]) + (ac.r01[0] * ac.r12[1]) - (ac.r02[1] * ac.r11[0])) * tmp;
        }
        if (ac.r11[0] == 0) {
            alpha_0[k][0] = 0;
            alpha_0[k][1] = 0;
        } else {
            tmp = 1.0 / ac.r11[0];
            alpha_0[k][0] = -(ac.r01[0] + (alpha_1[k][0] * ac.r12[0]) + (alpha_1[k][1] * ac.r12[1])) * tmp;
            alpha_0[k][1] = -(ac.r01[1] + (alpha_1[k][1] * ac.r12[0]) - (alpha_1[k][0] * ac.r12[1])) * tmp;
        }
        if (((alpha_0[k][0] * alpha_0[k][0]) + (alpha_0[k][1] * alpha_0[k][1]) >= 16.0) || ((alpha_1[k][0] * alpha_1[k][0]) + (alpha_1[k][1] * alpha_1[k][1]) >= 16.0)) {
            alpha_0[k][0] = 0;
            alpha_0[k][1] = 0;
            alpha_1[k][0] = 0;
            alpha_1[k][1] = 0;
        }
    };
    constructor.mapNewBw = function(invf_mode, invf_mode_prev) {
        switch (invf_mode) {
            case 1:
                if (invf_mode_prev == 0) 
                    return 0.6;
                 else 
                    return 0.75;
            case 2:
                return 0.9;
            case 3:
                return 0.98;
            default:
                if (invf_mode_prev == 1) 
                    return 0.6;
                 else 
                    return 0.0;
        }
    };
    constructor.calc_chirp_factors = function(sbr, ch) {
        var i;
        for (i = 0; i < sbr.N_Q; i++) {
            sbr.bwArray[ch][i] = HFGeneration.mapNewBw(sbr.bs_invf_mode[ch][i], sbr.bs_invf_mode_prev[ch][i]);
            if (sbr.bwArray[ch][i] < sbr.bwArray_prev[ch][i]) 
                sbr.bwArray[ch][i] = (sbr.bwArray[ch][i] * 0.75) + (sbr.bwArray_prev[ch][i] * 0.25);
             else 
                sbr.bwArray[ch][i] = (sbr.bwArray[ch][i] * 0.90625) + (sbr.bwArray_prev[ch][i] * 0.09375);
            if (sbr.bwArray[ch][i] < 0.015625) 
                sbr.bwArray[ch][i] = 0.0;
            if (sbr.bwArray[ch][i] >= 0.99609375) 
                sbr.bwArray[ch][i] = 0.99609375;
            sbr.bwArray_prev[ch][i] = sbr.bwArray[ch][i];
            sbr.bs_invf_mode_prev[ch][i] = sbr.bs_invf_mode[ch][i];
        }
    };
    constructor.patch_construction = function(sbr) {
        var i, k;
        var odd, sb;
        var msb = sbr.k0;
        var usb = sbr.kx;
        var goalSb = HFGeneration.goalSbTab[sbr.sample_rate.getIndex()];
        sbr.noPatches = 0;
        if (goalSb < (sbr.kx + sbr.M)) {
            for (i = 0 , k = 0; sbr.f_master[i] < goalSb; i++) {
                k = i + 1;
            }
        } else {
            k = sbr.N_master;
        }
        if (sbr.N_master == 0) {
            sbr.noPatches = 0;
            sbr.patchNoSubbands[0] = 0;
            sbr.patchStartSubband[0] = 0;
            return;
        }
        do {
            var j = k + 1;
            do {
                j--;
                sb = sbr.f_master[j];
                odd = (sb - 2 + sbr.k0) % 2;
            } while (sb > (sbr.k0 - 1 + msb - odd));
            sbr.patchNoSubbands[sbr.noPatches] = Math.max(sb - usb, 0);
            sbr.patchStartSubband[sbr.noPatches] = sbr.k0 - odd - sbr.patchNoSubbands[sbr.noPatches];
            if (sbr.patchNoSubbands[sbr.noPatches] > 0) {
                usb = sb;
                msb = sb;
                sbr.noPatches++;
            } else {
                msb = sbr.kx;
            }
            if (sbr.f_master[k] - sb < 3) 
                k = sbr.N_master;
        } while (sb != (sbr.kx + sbr.M));
        if ((sbr.patchNoSubbands[sbr.noPatches - 1] < 3) && (sbr.noPatches > 1)) {
            sbr.noPatches--;
        }
        sbr.noPatches = Math.min(sbr.noPatches, 5);
    };
}, {goalSbTab: "Int32Array"}, {});
var TimecodeBoxes = function() {
    Boxes.call(this);
};
TimecodeBoxes = stjs.extend(TimecodeBoxes, Boxes, [], null, {mappings: {name: "Map", arguments: [null, {name: "Class", arguments: ["Object"]}]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Yuv422jToRgb = function() {};
Yuv422jToRgb = stjs.extend(Yuv422jToRgb, null, [Transform], function(constructor, prototype) {
    prototype.transform = function(src, dst) {
        var y = src.getPlaneData(0);
        var u = src.getPlaneData(1);
        var v = src.getPlaneData(2);
        var data = dst.getPlaneData(0);
        var offLuma = 0, offChroma = 0;
        for (var i = 0; i < dst.getHeight(); i++) {
            for (var j = 0; j < dst.getWidth(); j += 2) {
                Yuv420jToRgb.YUVJtoRGB(y[offLuma], u[offChroma], v[offChroma], data, offLuma * 3);
                Yuv420jToRgb.YUVJtoRGB(y[offLuma + 1], u[offChroma], v[offChroma], data, (offLuma + 1) * 3);
                offLuma += 2;
                ++offChroma;
            }
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Yuv444jToRgb = function() {};
Yuv444jToRgb = stjs.extend(Yuv444jToRgb, null, [Transform], function(constructor, prototype) {
    prototype.transform = function(src, dst) {
        var y = src.getPlaneData(0);
        var u = src.getPlaneData(1);
        var v = src.getPlaneData(2);
        var data = dst.getPlaneData(0);
        for (var i = 0, srcOff = 0, dstOff = 0; i < dst.getHeight(); i++) {
            for (var j = 0; j < dst.getWidth(); j++ , srcOff++ , dstOff += 3) {
                Yuv420jToRgb.YUVJtoRGB(y[srcOff], u[srcOff], v[srcOff], data, dstOff);
            }
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var RgbToYuv422p = function(upShift, downShift) {
    this.upShift = upShift;
    this.downShift = downShift;
    this.downShiftChr = downShift + 1;
};
RgbToYuv422p = stjs.extend(RgbToYuv422p, null, [Transform], function(constructor, prototype) {
    prototype.upShift = 0;
    prototype.downShift = 0;
    prototype.downShiftChr = 0;
    prototype.transform = function(img, dst) {
        var y = img.getData()[0];
        var dstData = dst.getData();
        var off = 0, offSrc = 0;
        for (var i = 0; i < img.getHeight(); i++) {
            for (var j = 0; j < img.getWidth() >> 1; j++) {
                dstData[1][off] = 0;
                dstData[2][off] = 0;
                var offY = off << 1;
                RgbToYuv420p.rgb2yuv(y[offSrc++], y[offSrc++], y[offSrc++], dstData[0], offY, dstData[1], off, dstData[2], off);
                dstData[0][offY] = (dstData[0][offY] << this.upShift) >> this.downShift;
                RgbToYuv420p.rgb2yuv(y[offSrc++], y[offSrc++], y[offSrc++], dstData[0], offY + 1, dstData[1], off, dstData[2], off);
                dstData[0][offY + 1] = (dstData[0][offY + 1] << this.upShift) >> this.downShift;
                dstData[1][off] = (dstData[1][off] << this.upShift) >> this.downShiftChr;
                dstData[2][off] = (dstData[2][off] << this.upShift) >> this.downShiftChr;
                ++off;
            }
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Yuv420pToRgb = function(upShift, downShift) {
    this.upShift = upShift;
    this.downShift = downShift;
};
Yuv420pToRgb = stjs.extend(Yuv420pToRgb, null, [Transform], function(constructor, prototype) {
    prototype.downShift = 0;
    prototype.upShift = 0;
    prototype.transform = function(src, dst) {
        var y = src.getPlaneData(0);
        var u = src.getPlaneData(1);
        var v = src.getPlaneData(2);
        var data = dst.getPlaneData(0);
        var offLuma = 0, offChroma = 0;
        var stride = dst.getWidth();
        for (var i = 0; i < (dst.getHeight() >> 1); i++) {
            for (var k = 0; k < (dst.getWidth() >> 1); k++) {
                var j = k << 1;
                Yuv422pToRgb.YUV444toRGB888((y[offLuma + j] << this.upShift) >> this.downShift, (u[offChroma] << this.upShift) >> this.downShift, (v[offChroma] << this.upShift) >> this.downShift, data, (offLuma + j) * 3);
                Yuv422pToRgb.YUV444toRGB888((y[offLuma + j + 1] << this.upShift) >> this.downShift, (u[offChroma] << this.upShift) >> this.downShift, (v[offChroma] << this.upShift) >> this.downShift, data, (offLuma + j + 1) * 3);
                Yuv422pToRgb.YUV444toRGB888((y[offLuma + j + stride] << this.upShift) >> this.downShift, (u[offChroma] << this.upShift) >> this.downShift, (v[offChroma] << this.upShift) >> this.downShift, data, (offLuma + j + stride) * 3);
                Yuv422pToRgb.YUV444toRGB888((y[offLuma + j + stride + 1] << this.upShift) >> this.downShift, (u[offChroma] << this.upShift) >> this.downShift, (v[offChroma] << this.upShift) >> this.downShift, data, (offLuma + j + stride + 1) * 3);
                ++offChroma;
            }
            if ((dst.getWidth() & 1) != 0) {
                var j = dst.getWidth() - 1;
                Yuv422pToRgb.YUV444toRGB888((y[offLuma + j] << this.upShift) >> this.downShift, (u[offChroma] << this.upShift) >> this.downShift, (v[offChroma] << this.upShift) >> this.downShift, data, (offLuma + j) * 3);
                Yuv422pToRgb.YUV444toRGB888((y[offLuma + j + stride] << this.upShift) >> this.downShift, (u[offChroma] << this.upShift) >> this.downShift, (v[offChroma] << this.upShift) >> this.downShift, data, (offLuma + j + stride) * 3);
                ++offChroma;
            }
            offLuma += 2 * stride;
        }
        if ((dst.getHeight() & 1) != 0) {
            for (var k = 0; k < (dst.getWidth() >> 1); k++) {
                var j = k << 1;
                Yuv422pToRgb.YUV444toRGB888((y[offLuma + j] << this.upShift) >> this.downShift, (u[offChroma] << this.upShift) >> this.downShift, (v[offChroma] << this.upShift) >> this.downShift, data, (offLuma + j) * 3);
                Yuv422pToRgb.YUV444toRGB888((y[offLuma + j + 1] << this.upShift) >> this.downShift, (u[offChroma] << this.upShift) >> this.downShift, (v[offChroma] << this.upShift) >> this.downShift, data, (offLuma + j + 1) * 3);
                ++offChroma;
            }
            if ((dst.getWidth() & 1) != 0) {
                var j = dst.getWidth() - 1;
                Yuv422pToRgb.YUV444toRGB888((y[offLuma + j] << this.upShift) >> this.downShift, (u[offChroma] << this.upShift) >> this.downShift, (v[offChroma] << this.upShift) >> this.downShift, data, (offLuma + j) * 3);
                ++offChroma;
            }
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  @author Alex Zhukov
 */
var IntDCT = function() {
    DCT.call(this);
};
IntDCT = stjs.extend(IntDCT, DCT, [], function(constructor, prototype) {
    constructor.INSTANCE = new IntDCT();
    constructor.DCTSIZE = 8;
    constructor.PASS1_BITS = 2;
    constructor.MAXJSAMPLE = 255;
    constructor.CENTERJSAMPLE = 128;
    /**
     * 2 bits wider than legal samples 
     */
    constructor.RANGE_MASK = (IntDCT.MAXJSAMPLE * 4 + 3);
    prototype.decode = function(orig) {
        var inptr = IntBuffer.wrap(orig);
        var workspace = IntBuffer.allocate(64);
        var outptr = IntBuffer.allocate(64);
        this.doDecode(inptr, workspace, outptr);
        return outptr.array();
    };
    prototype.doDecode = function(inptr, workspace, outptr) {
        IntDCT.pass1(inptr, workspace.duplicate());
        IntDCT.pass2(outptr, workspace.duplicate());
        return outptr;
    };
    /**
     *  Pass 2: process rows from work array, store into output array.
     *  
     *  Note that we must descale the results by a factor of 8 == 23, and also
     *  undo the PASS1_BITS scaling.
     */
    constructor.pass2 = function(outptr, wsptr) {
        for (var ctr = 0; ctr < IntDCT.DCTSIZE; ctr++) {
            var z2 = wsptr.get(2);
            var z3 = wsptr.get(6);
            var z1 = IntDCT.MULTIPLY(z2 + z3, IntDCT.FIX_0_541196100);
            var tmp2 = z1 + IntDCT.MULTIPLY(z3, -IntDCT.FIX_1_847759065);
            var tmp3 = z1 + IntDCT.MULTIPLY(z2, IntDCT.FIX_0_765366865);
            var tmp0 = (stjs.trunc(wsptr.get(0)) + stjs.trunc(wsptr.get(4))) << IntDCT.CONST_BITS;
            var tmp1 = (stjs.trunc(wsptr.get(0)) - stjs.trunc(wsptr.get(4))) << IntDCT.CONST_BITS;
            var tmp10 = tmp0 + tmp3;
            var tmp13 = tmp0 - tmp3;
            var tmp11 = tmp1 + tmp2;
            var tmp12 = tmp1 - tmp2;
            tmp0 = stjs.trunc(wsptr.get(7));
            tmp1 = stjs.trunc(wsptr.get(5));
            tmp2 = stjs.trunc(wsptr.get(3));
            tmp3 = stjs.trunc(wsptr.get(1));
            z1 = tmp0 + tmp3;
            z2 = tmp1 + tmp2;
            z3 = tmp0 + tmp2;
            var z4 = tmp1 + tmp3;
            var z5 = IntDCT.MULTIPLY(z3 + z4, IntDCT.FIX_1_175875602);
            tmp0 = IntDCT.MULTIPLY(tmp0, IntDCT.FIX_0_298631336);
            tmp1 = IntDCT.MULTIPLY(tmp1, IntDCT.FIX_2_053119869);
            tmp2 = IntDCT.MULTIPLY(tmp2, IntDCT.FIX_3_072711026);
            tmp3 = IntDCT.MULTIPLY(tmp3, IntDCT.FIX_1_501321110);
            z1 = IntDCT.MULTIPLY(z1, -IntDCT.FIX_0_899976223);
            z2 = IntDCT.MULTIPLY(z2, -IntDCT.FIX_2_562915447);
            z3 = IntDCT.MULTIPLY(z3, -IntDCT.FIX_1_961570560);
            z4 = IntDCT.MULTIPLY(z4, -IntDCT.FIX_0_390180644);
            z3 += z5;
            z4 += z5;
            tmp0 += z1 + z3;
            tmp1 += z2 + z4;
            tmp2 += z2 + z3;
            tmp3 += z1 + z4;
            var D = IntDCT.CONST_BITS + IntDCT.PASS1_BITS + 3;
            outptr.put(IntDCT.range_limit(IntDCT.DESCALE(tmp10 + tmp3, D) & IntDCT.RANGE_MASK));
            outptr.put(IntDCT.range_limit(IntDCT.DESCALE(tmp11 + tmp2, D) & IntDCT.RANGE_MASK));
            outptr.put(IntDCT.range_limit(IntDCT.DESCALE(tmp12 + tmp1, D) & IntDCT.RANGE_MASK));
            outptr.put(IntDCT.range_limit(IntDCT.DESCALE(tmp13 + tmp0, D) & IntDCT.RANGE_MASK));
            outptr.put(IntDCT.range_limit(IntDCT.DESCALE(tmp13 - tmp0, D) & IntDCT.RANGE_MASK));
            outptr.put(IntDCT.range_limit(IntDCT.DESCALE(tmp12 - tmp1, D) & IntDCT.RANGE_MASK));
            outptr.put(IntDCT.range_limit(IntDCT.DESCALE(tmp11 - tmp2, D) & IntDCT.RANGE_MASK));
            outptr.put(IntDCT.range_limit(IntDCT.DESCALE(tmp10 - tmp3, D) & IntDCT.RANGE_MASK));
            wsptr = IntDCT.doAdvance(wsptr, IntDCT.DCTSIZE);
        }
    };
    constructor.range_limit = function(i) {
        return IntDCT.idct_sample_range_limit.get(i + 256);
    };
    constructor.sample_range_limit = IntBuffer.allocate((5 * (IntDCT.MAXJSAMPLE + 1) + IntDCT.CENTERJSAMPLE));
    constructor.idct_sample_range_limit = IntBuffer.allocate(IntDCT.sample_range_limit.capacity() - 128);
    constructor.prepare_range_limit_table = function() {
        IntDCT.sample_range_limit.position(256);
        for (var i = 0; i < 128; i++) {
            IntDCT.sample_range_limit.put(i);
        }
        for (var i = -128; i < 0; i++) {
            IntDCT.sample_range_limit.put(i);
        }
        for (var i = 0; i < 256 + 128; i++) {
            IntDCT.sample_range_limit.put(-1);
        }
        for (var i = 0; i < 256 + 128; i++) {
            IntDCT.sample_range_limit.put(0);
        }
        for (var i = 0; i < 128; i++) {
            IntDCT.sample_range_limit.put(i);
        }
        for (var i = 0; i < IntDCT.idct_sample_range_limit.capacity(); i++) {
            IntDCT.idct_sample_range_limit.put(IntDCT.sample_range_limit.get(i + 128) & 255);
        }
    };
    constructor.shortcut = function(inptr, wsptr) {
        if (inptr.get(IntDCT.DCTSIZE * 1) == 0 && inptr.get(IntDCT.DCTSIZE * 2) == 0 && inptr.get(IntDCT.DCTSIZE * 3) == 0 && inptr.get(IntDCT.DCTSIZE * 4) == 0 && inptr.get(IntDCT.DCTSIZE * 5) == 0 && inptr.get(IntDCT.DCTSIZE * 6) == 0 && inptr.get(IntDCT.DCTSIZE * 7) == 0) {
            var dcval = inptr.get(IntDCT.DCTSIZE * 0) << IntDCT.PASS1_BITS;
            wsptr.put(IntDCT.DCTSIZE * 0, dcval);
            wsptr.put(IntDCT.DCTSIZE * 1, dcval);
            wsptr.put(IntDCT.DCTSIZE * 2, dcval);
            wsptr.put(IntDCT.DCTSIZE * 3, dcval);
            wsptr.put(IntDCT.DCTSIZE * 4, dcval);
            wsptr.put(IntDCT.DCTSIZE * 5, dcval);
            wsptr.put(IntDCT.DCTSIZE * 6, dcval);
            wsptr.put(IntDCT.DCTSIZE * 7, dcval);
            inptr = IntDCT.advance(inptr);
            wsptr = IntDCT.advance(wsptr);
            return true;
        }
        return false;
    };
    /**
     *  Pass 1: process columns from input, store into work array.
     *  
     *  Note results are scaled up by sqrt(8) compared to a true IDCT;
     *  furthermore, we scale the results by 2xPASS1_BITS.
     */
    constructor.pass1 = function(inptr, wsptr) {
        for (var ctr = IntDCT.DCTSIZE; ctr > 0; ctr--) {
            var z2 = inptr.get(IntDCT.DCTSIZE * 2);
            var z3 = inptr.get(IntDCT.DCTSIZE * 6);
            var z1 = IntDCT.MULTIPLY(z2 + z3, IntDCT.FIX_0_541196100);
            var tmp2 = z1 + IntDCT.MULTIPLY(z3, -IntDCT.FIX_1_847759065);
            var tmp3 = z1 + IntDCT.MULTIPLY(z2, IntDCT.FIX_0_765366865);
            z2 = inptr.get(IntDCT.DCTSIZE * 0);
            z3 = inptr.get(IntDCT.DCTSIZE * 4);
            var tmp0 = (z2 + z3) << IntDCT.CONST_BITS;
            var tmp1 = (z2 - z3) << IntDCT.CONST_BITS;
            var tmp10 = tmp0 + tmp3;
            var tmp13 = tmp0 - tmp3;
            var tmp11 = tmp1 + tmp2;
            var tmp12 = tmp1 - tmp2;
            tmp0 = inptr.get(IntDCT.DCTSIZE * 7);
            tmp1 = inptr.get(IntDCT.DCTSIZE * 5);
            tmp2 = inptr.get(IntDCT.DCTSIZE * 3);
            tmp3 = inptr.get(IntDCT.DCTSIZE * 1);
            z1 = tmp0 + tmp3;
            z2 = tmp1 + tmp2;
            z3 = tmp0 + tmp2;
            var z4 = tmp1 + tmp3;
            var z5 = IntDCT.MULTIPLY(z3 + z4, IntDCT.FIX_1_175875602);
            tmp0 = IntDCT.MULTIPLY(tmp0, IntDCT.FIX_0_298631336);
            tmp1 = IntDCT.MULTIPLY(tmp1, IntDCT.FIX_2_053119869);
            tmp2 = IntDCT.MULTIPLY(tmp2, IntDCT.FIX_3_072711026);
            tmp3 = IntDCT.MULTIPLY(tmp3, IntDCT.FIX_1_501321110);
            z1 = IntDCT.MULTIPLY(z1, -IntDCT.FIX_0_899976223);
            z2 = IntDCT.MULTIPLY(z2, -IntDCT.FIX_2_562915447);
            z3 = IntDCT.MULTIPLY(z3, -IntDCT.FIX_1_961570560);
            z4 = IntDCT.MULTIPLY(z4, -IntDCT.FIX_0_390180644);
            z3 += z5;
            z4 += z5;
            tmp0 += z1 + z3;
            tmp1 += z2 + z4;
            tmp2 += z2 + z3;
            tmp3 += z1 + z4;
            var D = IntDCT.CONST_BITS - IntDCT.PASS1_BITS;
            wsptr.put(IntDCT.DCTSIZE * 0, IntDCT.DESCALE(tmp10 + tmp3, D));
            wsptr.put(IntDCT.DCTSIZE * 7, IntDCT.DESCALE(tmp10 - tmp3, D));
            wsptr.put(IntDCT.DCTSIZE * 1, IntDCT.DESCALE(tmp11 + tmp2, D));
            wsptr.put(IntDCT.DCTSIZE * 6, IntDCT.DESCALE(tmp11 - tmp2, D));
            wsptr.put(IntDCT.DCTSIZE * 2, IntDCT.DESCALE(tmp12 + tmp1, D));
            wsptr.put(IntDCT.DCTSIZE * 5, IntDCT.DESCALE(tmp12 - tmp1, D));
            wsptr.put(IntDCT.DCTSIZE * 3, IntDCT.DESCALE(tmp13 + tmp0, D));
            wsptr.put(IntDCT.DCTSIZE * 4, IntDCT.DESCALE(tmp13 - tmp0, D));
            inptr = IntDCT.advance(inptr);
            wsptr = IntDCT.advance(wsptr);
        }
    };
    /**
     *  advance pointers to next column
     */
    constructor.advance = function(ptr) {
        return IntDCT.doAdvance(ptr, 1);
    };
    constructor.doAdvance = function(ptr, size) {
        ptr.position(ptr.position() + size);
        return ptr.slice();
    };
    constructor.DESCALE = function(x, n) {
        return IntDCT.RIGHT_SHIFT((x) + (1 << ((n) - 1)), n);
    };
    constructor.RIGHT_SHIFT = function(x, shft) {
        return x >> shft;
    };
    constructor.MULTIPLY = function(i, j) {
        return i * j;
    };
    constructor.FIX = function(x) {
        return (stjs.trunc(((x) * (1 << IntDCT.CONST_BITS) + 0.5)));
    };
    constructor.FIX_0_298631336 = IntDCT.FIX(0.298631336);
    constructor.FIX_0_390180644 = IntDCT.FIX(0.390180644);
    constructor.FIX_0_541196100 = IntDCT.FIX(0.5411961);
    constructor.FIX_0_765366865 = IntDCT.FIX(0.765366865);
    constructor.FIX_0_899976223 = IntDCT.FIX(0.899976223);
    constructor.FIX_1_175875602 = IntDCT.FIX(1.175875602);
    constructor.FIX_1_501321110 = IntDCT.FIX(1.50132111);
    constructor.FIX_1_847759065 = IntDCT.FIX(1.847759065);
    constructor.FIX_1_961570560 = IntDCT.FIX(1.96157056);
    constructor.FIX_2_053119869 = IntDCT.FIX(2.053119869);
    constructor.FIX_2_562915447 = IntDCT.FIX(2.562915447);
    constructor.FIX_3_072711026 = IntDCT.FIX(3.072711026);
    constructor.CONST_BITS = 13;
    constructor.ONE_HALF = (1 << (IntDCT.CONST_BITS - 1));
}, {INSTANCE: "IntDCT", sample_range_limit: "IntBuffer", idct_sample_range_limit: "IntBuffer"}, {});
(function() {
    IntDCT.prepare_range_limit_table();
})();
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  @author The JCodec project
 */
var SlowDCT = function() {
    DCT.call(this);
};
SlowDCT = stjs.extend(SlowDCT, DCT, [], function(constructor, prototype) {
    constructor.INSTANCE = new SlowDCT();
    /**
     * r - Reciprocal 
     */
    constructor.rSqrt2 = 1 / Math.sqrt(2);
    prototype.encode = function(orig) {
        var result = new Int16Array(64);
        for (var u = 0; u < 8; u++) {
            for (var v = 0; v < 8; v++) {
                var sum = 0;
                for (var i = 0; i < 8; i++) {
                    for (var j = 0; j < 8; j++) {
                        sum += orig[i * 8 + j] * Math.cos((Math.PI / 8) * (i + 0.5) * u) * Math.cos((Math.PI / 8) * (j + 0.5) * v);
                    }
                }
                result[u * 8 + v] = stjs.trunc(sum);
            }
        }
        result[0] = stjs.trunc((result[0] / 8));
        var sqrt2 = Math.sqrt(2);
        for (var i = 1; i < 8; i++) {
            result[i] = stjs.trunc((result[0] * sqrt2 / 8));
            result[i * 8] = stjs.trunc((result[0] * sqrt2 / 8));
            for (var j = 1; j < 8; j++) {
                result[i * 8 + j] = stjs.trunc((result[0] / 4));
            }
        }
        return result;
    };
    prototype.decode = function(orig) {
        var res = new Int32Array(64);
        var i = 0;
        for (var y = 0; y < 8; y++) {
            for (var x = 0; x < 8; x++) {
                var sum = 0;
                var pixOffset = 0;
                for (var u = 0; u < 8; u++) {
                    var cu = (u == 0) ? SlowDCT.rSqrt2 : 1;
                    for (var v = 0; v < 8; v++) {
                        var cv = (v == 0) ? SlowDCT.rSqrt2 : 1;
                        var svu = orig[pixOffset];
                        var c1 = ((2 * x + 1) * v * Math.PI) / 16.0;
                        var c2 = ((2 * y + 1) * u * Math.PI) / 16.0;
                        sum += cu * cv * svu * Math.cos(c1) * Math.cos(c2);
                        pixOffset++;
                    }
                }
                sum *= 0.25;
                sum = Math.round(sum + 128);
                var isum = (stjs.trunc(sum));
                res[i++] = ImageConvert.icrop(isum);
            }
        }
        return res;
    };
}, {INSTANCE: "SlowDCT"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  @author in-somnia
 */
var NIOBitStream = function(br) {
    this.br = br;
};
NIOBitStream = stjs.extend(NIOBitStream, null, [IBitStream], function(constructor, prototype) {
    prototype.br = null;
    prototype.destroy = function() {
        this.reset();
        this.br = null;
    };
    prototype.setData = function(data) {
        this.br = BitReader.createBitReader(ByteBuffer.wrap(data));
    };
    prototype.byteAlign = function() {
        this.br.align();
    };
    prototype.reset = function() {
         throw new RuntimeException("todo");
    };
    prototype.getPosition = function() {
        return this.br.position();
    };
    prototype.getBitsLeft = function() {
        return this.br.remaining();
    };
    prototype.readBits = function(n) {
        if (this.br.remaining() >= n) {
            return this.br.readNBit(n);
        }
         throw AACException.endOfStream();
    };
    prototype.readBit = function() {
        if (this.br.remaining() >= 1) {
            return this.br.read1Bit();
        }
         throw AACException.endOfStream();
    };
    prototype.readBool = function() {
        var read1Bit = this.readBit();
        return read1Bit != 0;
    };
    prototype.peekBits = function(n) {
        var checkNBit = this.br.checkNBit(n);
        return checkNBit;
    };
    prototype.peekBit = function() {
        var curBit = this.br.curBit();
        return curBit;
    };
    prototype.skipBits = function(n) {
        this.br.skip(n);
    };
    prototype.skipBit = function() {
        this.skipBits(1);
    };
    prototype.maskBits = function(n) {
        var i;
        if (n == 32) 
            i = -1;
         else 
            i = (1 << n) - 1;
        return i;
    };
}, {br: "BitReader"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 * 
 *  @author in-somnia
 */
var Huffman = function() {};
Huffman = stjs.extend(Huffman, null, [Codebooks], function(constructor, prototype) {
    constructor.UNSIGNED = new Int8Array([false, false, true, true, false, false, true, true, true, true, true]);
    constructor.QUAD_LEN = 4;
    constructor.PAIR_LEN = 2;
    constructor.findOffset = function(_in, table) {
        var off = 0;
        var len = table[off][0];
        var cw = _in.readBits(len);
        var j;
         while (cw != table[off][1]){
            off++;
            j = table[off][0] - len;
            len = table[off][0];
            cw <<= j;
            cw |= _in.readBits(j);
        }
        return off;
    };
    constructor.signValues = function(_in, data, off, len) {
        for (var i = off; i < off + len; i++) {
            if (data[i] != 0) {
                if (_in.readBool()) 
                    data[i] = -data[i];
            }
        }
    };
    constructor.getEscape = function(_in, s) {
        var neg = s < 0;
        var i = 4;
         while (_in.readBool()){
            i++;
        }
        var j = _in.readBits(i) | (1 << i);
        return (neg ? -j : j);
    };
    constructor.decodeScaleFactor = function(_in) {
        var offset = Huffman.findOffset(_in, Codebooks.HCB_SF);
        return Codebooks.HCB_SF[offset][2];
    };
    constructor.decodeSpectralData = function(_in, cb, data, off) {
        var HCB = Codebooks.CODEBOOKS[cb - 1];
        var offset = Huffman.findOffset(_in, HCB);
        data[off] = HCB[offset][2];
        data[off + 1] = HCB[offset][3];
        if (cb < 5) {
            data[off + 2] = HCB[offset][4];
            data[off + 3] = HCB[offset][5];
        }
        if (cb < 11) {
            if (Huffman.UNSIGNED[cb - 1]) 
                Huffman.signValues(_in, data, off, cb < 5 ? Huffman.QUAD_LEN : Huffman.PAIR_LEN);
        } else if (cb == 11 || cb > 15) {
            Huffman.signValues(_in, data, off, cb < 5 ? Huffman.QUAD_LEN : Huffman.PAIR_LEN);
            if (Math.abs(data[off]) == 16) 
                data[off] = Huffman.getEscape(_in, data[off]);
            if (Math.abs(data[off + 1]) == 16) 
                data[off + 1] = Huffman.getEscape(_in, data[off + 1]);
        } else 
             throw new AACException("Huffman: unknown spectral codebook: " + cb);
    };
}, {UNSIGNED: "Int8Array", HCB1: "Array", HCB2: "Array", HCB3: "Array", HCB4: "Array", HCB5: "Array", HCB6: "Array", HCB7: "Array", HCB8: "Array", HCB9: "Array", HCB10: "Array", HCB11: "Array", HCB_SF: "Array", CODEBOOKS: "Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license. 
 * 
 *  @author in-somnia
 */
var BitStream = function() {};
BitStream = stjs.extend(BitStream, null, [IBitStream], function(constructor, prototype) {
    constructor.WORD_BITS = 32;
    constructor.WORD_BYTES = 4;
    constructor.BYTE_MASK = 255;
    constructor.createBitStream = function(data) {
        var bs = new BitStream();
        bs.setData(data);
        return bs;
    };
    prototype.buffer = null;
    prototype.pos = 0;
    prototype.cache = 0;
    prototype.bitsCached = 0;
    prototype.position = 0;
    prototype.destroy = function() {
        this.reset();
        this.buffer = null;
    };
    prototype.setData = function(data) {
        var size = BitStream.WORD_BYTES * (stjs.trunc((data.length + BitStream.WORD_BYTES - 1) / BitStream.WORD_BYTES));
        if (this.buffer == null || this.buffer.length != size) 
            this.buffer = new Int8Array(size);
        System.arraycopy(data, 0, this.buffer, 0, data.length);
        this.reset();
    };
    prototype.byteAlign = function() {
        var toFlush = this.bitsCached & 7;
        if (toFlush > 0) 
            this.skipBits(toFlush);
    };
    prototype.reset = function() {
        this.pos = 0;
        this.bitsCached = 0;
        this.cache = 0;
        this.position = 0;
    };
    prototype.getPosition = function() {
        return this.position;
    };
    prototype.getBitsLeft = function() {
        return this.buffer != null ? 8 * (this.buffer.length - this.pos) + this.bitsCached : 0;
    };
    /**
     *  Reads the next four bytes.
     *  @param peek if true, the stream pointer will not be increased
     */
    prototype.readCache = function(peek) {
        var i;
        if (this.pos > this.buffer.length - BitStream.WORD_BYTES) 
             throw AACException.endOfStream();
         else 
            i = ((this.buffer[this.pos] & BitStream.BYTE_MASK) << 24) | ((this.buffer[this.pos + 1] & BitStream.BYTE_MASK) << 16) | ((this.buffer[this.pos + 2] & BitStream.BYTE_MASK) << 8) | (this.buffer[this.pos + 3] & BitStream.BYTE_MASK);
        if (!peek) 
            this.pos += BitStream.WORD_BYTES;
        return i;
    };
    prototype.readBits = function(n) {
        var result;
        if (this.bitsCached >= n) {
            this.bitsCached -= n;
            result = (this.cache >> this.bitsCached) & this.maskBits(n);
            this.position += n;
        } else {
            this.position += n;
            var c = this.cache & this.maskBits(this.bitsCached);
            var left = n - this.bitsCached;
            this.cache = this.readCache(false);
            this.bitsCached = BitStream.WORD_BITS - left;
            result = ((this.cache >> this.bitsCached) & this.maskBits(left)) | (c << left);
        }
        return result;
    };
    prototype.readBit = function() {
        var i;
        if (this.bitsCached > 0) {
            this.bitsCached--;
            i = (this.cache >> (this.bitsCached)) & 1;
            this.position++;
        } else {
            this.cache = this.readCache(false);
            this.bitsCached = BitStream.WORD_BITS - 1;
            this.position++;
            i = (this.cache >> this.bitsCached) & 1;
        }
        return i;
    };
    prototype.readBool = function() {
        return (this.readBit() & 1) != 0;
    };
    prototype.peekBits = function(n) {
        var ret;
        if (this.bitsCached >= n) {
            ret = (this.cache >> (this.bitsCached - n)) & this.maskBits(n);
        } else {
            var c = this.cache & this.maskBits(this.bitsCached);
            n -= this.bitsCached;
            ret = ((this.readCache(true) >> BitStream.WORD_BITS - n) & this.maskBits(n)) | (c << n);
        }
        return ret;
    };
    prototype.peekBit = function() {
        var ret;
        if (this.bitsCached > 0) {
            ret = (this.cache >> (this.bitsCached - 1)) & 1;
        } else {
            var word = this.readCache(true);
            ret = (word >> BitStream.WORD_BITS - 1) & 1;
        }
        return ret;
    };
    prototype.skipBits = function(n) {
        this.position += n;
        if (n <= this.bitsCached) {
            this.bitsCached -= n;
        } else {
            n -= this.bitsCached;
             while (n >= BitStream.WORD_BITS){
                n -= BitStream.WORD_BITS;
                this.readCache(false);
            }
            if (n > 0) {
                this.cache = this.readCache(false);
                this.bitsCached = BitStream.WORD_BITS - n;
            } else {
                this.cache = 0;
                this.bitsCached = 0;
            }
        }
    };
    prototype.skipBit = function() {
        this.position++;
        if (this.bitsCached > 0) {
            this.bitsCached--;
        } else {
            this.cache = this.readCache(false);
            this.bitsCached = BitStream.WORD_BITS - 1;
        }
    };
    prototype.maskBits = function(n) {
        var i;
        if (n == 32) 
            i = -1;
         else 
            i = (1 << n) - 1;
        return i;
    };
}, {buffer: "Int8Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  Huffman Codeword Reordering
 *  Decodes spectral data for ICStreams if error resilience is used for
 *  section data.
 *  
 *  @author in-somnia
 */
var HCR = function() {};
HCR = stjs.extend(HCR, null, [SyntaxConstants], function(constructor, prototype) {
    constructor.Codeword = function() {};
    constructor.Codeword = stjs.extend(constructor.Codeword, null, [], function(constructor, prototype) {
        prototype.cb = 0;
        prototype.decoded = 0;
        prototype.sp_offset = 0;
        prototype.bits = null;
        prototype.fill = function(sp, cb) {
            this.sp_offset = sp;
            this.cb = cb;
            this.decoded = 0;
            this.bits = new BitsBuffer();
        };
    }, {bits: "BitsBuffer"}, {});
    constructor.NUM_CB = 6;
    constructor.NUM_CB_ER = 22;
    constructor.MAX_CB = 32;
    constructor.VCB11_FIRST = 16;
    constructor.VCB11_LAST = 31;
    constructor.PRE_SORT_CB_STD = new Int32Array([11, 9, 7, 5, 3, 1]);
    constructor.PRE_SORT_CB_ER = new Int32Array([11, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 9, 7, 5, 3, 1]);
    constructor.MAX_CW_LEN = new Int32Array([0, 11, 9, 20, 16, 13, 11, 14, 12, 17, 14, 49, 0, 0, 0, 0, 14, 17, 21, 21, 25, 25, 29, 29, 29, 29, 33, 33, 33, 37, 37, 41]);
    constructor.isGoodCB = function(cb, sectCB) {
        var b = false;
        if ((sectCB > HCB.ZERO_HCB && sectCB <= HCB.ESCAPE_HCB) || (sectCB >= HCR.VCB11_FIRST && sectCB <= HCR.VCB11_LAST)) {
            if (cb < HCB.ESCAPE_HCB) 
                b = ((sectCB == cb) || (sectCB == cb + 1));
             else 
                b = (sectCB == cb);
        }
        return b;
    };
    constructor.decodeReorderedSpectralData = function(ics, _in, spectralData, sectionDataResilience) {
        var info = ics.getInfo();
        var windowGroupCount = info.getWindowGroupCount();
        var maxSFB = info.getMaxSFB();
        var swbOffsets = info.getSWBOffsets();
        var swbOffsetMax = info.getSWBOffsetMax();
        var sectStart = Array.apply(null, Array(0)).map(function() {
            return new Int32Array(0);
        });
        var sectEnd = Array.apply(null, Array(0)).map(function() {
            return new Int32Array(0);
        });
        var numSec = new Int32Array(0);
        var sectCB = Array.apply(null, Array(0)).map(function() {
            return new Int32Array(0);
        });
        var sectSFBOffsets = Array.apply(null, Array(0)).map(function() {
            return new Int32Array(0);
        });
        var spDataLen = ics.getReorderedSpectralDataLength();
        if (spDataLen == 0) 
            return;
        var longestLen = ics.getLongestCodewordLength();
        if (longestLen == 0 || longestLen >= spDataLen) 
             throw new AACException("length of longest HCR codeword out of range");
        var spOffsets = new Int32Array(8);
        var shortFrameLen = stjs.trunc(spectralData.length / 8);
        spOffsets[0] = 0;
        var g;
        for (g = 1; g < windowGroupCount; g++) {
            spOffsets[g] = spOffsets[g - 1] + shortFrameLen * info.getWindowGroupLength(g - 1);
        }
        var codeword = Array(512);
        var segment = Array(512);
        var lastCB;
        var preSortCB;
        if (sectionDataResilience) {
            preSortCB = HCR.PRE_SORT_CB_ER;
            lastCB = HCR.NUM_CB_ER;
        } else {
            preSortCB = HCR.PRE_SORT_CB_STD;
            lastCB = HCR.NUM_CB;
        }
        var PCWs_done = 0;
        var segmentsCount = 0;
        var numberOfCodewords = 0;
        var bitsread = 0;
        var sfb, w_idx, i, thisCB, thisSectCB, cws;
        for (var sortloop = 0; sortloop < lastCB; sortloop++) {
            thisCB = preSortCB[sortloop];
            for (sfb = 0; sfb < maxSFB; sfb++) {
                for (w_idx = 0; 4 * w_idx < (Math.min(swbOffsets[sfb + 1], swbOffsetMax) - swbOffsets[sfb]); w_idx++) {
                    for (g = 0; g < windowGroupCount; g++) {
                        for (i = 0; i < numSec[g]; i++) {
                            if ((sectStart[g][i] <= sfb) && (sectEnd[g][i] > sfb)) {
                                thisSectCB = sectCB[g][i];
                                if (HCR.isGoodCB(thisCB, thisSectCB)) {
                                    var sect_sfb_size = sectSFBOffsets[g][sfb + 1] - sectSFBOffsets[g][sfb];
                                    var inc = (thisSectCB < HCB.FIRST_PAIR_HCB) ? 4 : 2;
                                    var group_cws_count = stjs.trunc((4 * info.getWindowGroupLength(g)) / inc);
                                    var segwidth = Math.min(HCR.MAX_CW_LEN[thisSectCB], longestLen);
                                    for (cws = 0; (cws < group_cws_count) && ((cws + w_idx * group_cws_count) < sect_sfb_size); cws++) {
                                        var sp = spOffsets[g] + sectSFBOffsets[g][sfb] + inc * (cws + w_idx * group_cws_count);
                                        if (PCWs_done == 0) {
                                            if (bitsread + segwidth <= spDataLen) {
                                                segment[segmentsCount].readSegment(segwidth, _in);
                                                bitsread += segwidth;
                                                segment[segmentsCount].rewindReverse();
                                                segmentsCount++;
                                            } else {
                                                if (bitsread < spDataLen) {
                                                    var additional_bits = spDataLen - bitsread;
                                                    segment[segmentsCount].readSegment(additional_bits, _in);
                                                    segment[segmentsCount].len += segment[segmentsCount - 1].len;
                                                    segment[segmentsCount].rewindReverse();
                                                    if (segment[segmentsCount - 1].len > 32) {
                                                        segment[segmentsCount - 1].bufb = segment[segmentsCount].bufb + segment[segmentsCount - 1].showBits(segment[segmentsCount - 1].len - 32);
                                                        segment[segmentsCount - 1].bufa = segment[segmentsCount].bufa + segment[segmentsCount - 1].showBits(32);
                                                    } else {
                                                        segment[segmentsCount - 1].bufa = segment[segmentsCount].bufa + segment[segmentsCount - 1].showBits(segment[segmentsCount - 1].len);
                                                        segment[segmentsCount - 1].bufb = segment[segmentsCount].bufb;
                                                    }
                                                    segment[segmentsCount - 1].len += additional_bits;
                                                }
                                                bitsread = spDataLen;
                                                PCWs_done = 1;
                                                codeword[0].fill(sp, thisSectCB);
                                            }
                                        } else {
                                            codeword[numberOfCodewords - segmentsCount].fill(sp, thisSectCB);
                                        }
                                        numberOfCodewords++;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        if (segmentsCount == 0) 
             throw new AACException("no segments _in HCR");
        var numberOfSets = stjs.trunc(numberOfCodewords / segmentsCount);
        var trial, codewordBase, segmentID, codewordID;
        for (var set = 1; set <= numberOfSets; set++) {
            for (trial = 0; trial < segmentsCount; trial++) {
                for (codewordBase = 0; codewordBase < segmentsCount; codewordBase++) {
                    segmentID = (trial + codewordBase) % segmentsCount;
                    codewordID = codewordBase + set * segmentsCount - segmentsCount;
                    if (codewordID >= numberOfCodewords - segmentsCount) 
                        break;
                    if ((codeword[codewordID].decoded == 0) && (segment[segmentID].len > 0)) {
                        if (codeword[codewordID].bits.len != 0) 
                            segment[segmentID].concatBits(codeword[codewordID].bits);
                        var tmplen = segment[segmentID].len;
                    }
                }
            }
            for (i = 0; i < segmentsCount; i++) {
                segment[i].rewindReverse();
            }
        }
    };
}, {PRE_SORT_CB_STD: "Int32Array", PRE_SORT_CB_ER: "Int32Array", MAX_CW_LEN: "Int32Array", LOGGER: "Logger"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  @author in-somnia
 */
var FFT = function(length) {
    this.length = length;
    switch (length) {
        case 64:
            this.roots = FFTTables.FFT_TABLE_64;
            break;
        case 512:
            this.roots = FFTTables.FFT_TABLE_512;
            break;
        case 60:
            this.roots = FFTTables.FFT_TABLE_60;
            break;
        case 480:
            this.roots = FFTTables.FFT_TABLE_480;
            break;
        default:
             throw new AACException("unexpected FFT length: " + length);
    }
    this.rev = Array.apply(null, Array(length)).map(function() {
        return new Float32Array(2);
    });
    this.a = new Float32Array(2);
    this.b = new Float32Array(2);
    this.c = new Float32Array(2);
    this.d = new Float32Array(2);
    this.e1 = new Float32Array(2);
    this.e2 = new Float32Array(2);
};
FFT = stjs.extend(FFT, null, [FFTTables], function(constructor, prototype) {
    prototype.length = 0;
    prototype.roots = null;
    prototype.rev = null;
    prototype.a = null;
    prototype.b = null;
    prototype.c = null;
    prototype.d = null;
    prototype.e1 = null;
    prototype.e2 = null;
    prototype.process = function(_in, forward) {
        var imOff = (forward ? 2 : 1);
        var scale = (forward ? this.length : 1);
        var ii = 0;
        for (var i = 0; i < this.length; i++) {
            this.rev[i][0] = _in[ii][0];
            this.rev[i][1] = _in[ii][1];
            var k = this.length >> 1;
             while (ii >= k && k > 0){
                ii -= k;
                k >>= 1;
            }
            ii += k;
        }
        for (var i = 0; i < this.length; i++) {
            _in[i][0] = this.rev[i][0];
            _in[i][1] = this.rev[i][1];
        }
        for (var i = 0; i < this.length; i += 4) {
            this.a[0] = _in[i][0] + _in[i + 1][0];
            this.a[1] = _in[i][1] + _in[i + 1][1];
            this.b[0] = _in[i + 2][0] + _in[i + 3][0];
            this.b[1] = _in[i + 2][1] + _in[i + 3][1];
            this.c[0] = _in[i][0] - _in[i + 1][0];
            this.c[1] = _in[i][1] - _in[i + 1][1];
            this.d[0] = _in[i + 2][0] - _in[i + 3][0];
            this.d[1] = _in[i + 2][1] - _in[i + 3][1];
            _in[i][0] = this.a[0] + this.b[0];
            _in[i][1] = this.a[1] + this.b[1];
            _in[i + 2][0] = this.a[0] - this.b[0];
            _in[i + 2][1] = this.a[1] - this.b[1];
            this.e1[0] = this.c[0] - this.d[1];
            this.e1[1] = this.c[1] + this.d[0];
            this.e2[0] = this.c[0] + this.d[1];
            this.e2[1] = this.c[1] - this.d[0];
            if (forward) {
                _in[i + 1][0] = this.e2[0];
                _in[i + 1][1] = this.e2[1];
                _in[i + 3][0] = this.e1[0];
                _in[i + 3][1] = this.e1[1];
            } else {
                _in[i + 1][0] = this.e1[0];
                _in[i + 1][1] = this.e1[1];
                _in[i + 3][0] = this.e2[0];
                _in[i + 3][1] = this.e2[1];
            }
        }
        var shift, m, km;
        var rootRe, rootIm, zRe, zIm;
        for (var i = 4; i < this.length; i <<= 1) {
            shift = i << 1;
            m = stjs.trunc(this.length / shift);
            for (var j = 0; j < this.length; j += shift) {
                for (var k = 0; k < i; k++) {
                    km = k * m;
                    rootRe = this.roots[km][0];
                    rootIm = this.roots[km][imOff];
                    zRe = _in[i + j + k][0] * rootRe - _in[i + j + k][1] * rootIm;
                    zIm = _in[i + j + k][0] * rootIm + _in[i + j + k][1] * rootRe;
                    _in[i + j + k][0] = (_in[j + k][0] - zRe) * scale;
                    _in[i + j + k][1] = (_in[j + k][1] - zIm) * scale;
                    _in[j + k][0] = (_in[j + k][0] + zRe) * scale;
                    _in[j + k][1] = (_in[j + k][1] + zIm) * scale;
                }
            }
        }
    };
}, {roots: "Array", rev: "Array", a: "Float32Array", b: "Float32Array", c: "Float32Array", d: "Float32Array", e1: "Float32Array", e2: "Float32Array", FFT_TABLE_512: "Array", FFT_TABLE_64: "Array", FFT_TABLE_480: "Array", FFT_TABLE_60: "Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  Temporal Noise Shaping
 *  @author in-somnia
 */
var TNS = function() {
    this.nFilt = new Int32Array(8);
    this.length = Array.apply(null, Array(8)).map(function() {
        return new Int32Array(4);
    });
    this.direction = Array.apply(null, Array(8)).map(function() {
        return new Int8Array(4);
    });
    this.order = Array.apply(null, Array(8)).map(function() {
        return new Int32Array(4);
    });
    this.coef = Array.apply(null, Array(8)).map(function() {
        return Array.apply(null, Array(4)).map(function() {
            return new Float32Array(TNS.TNS_MAX_ORDER);
        });
    });
};
TNS = stjs.extend(TNS, null, [SyntaxConstants, TNSTables], function(constructor, prototype) {
    constructor.TNS_MAX_ORDER = 20;
    constructor.SHORT_BITS = new Int32Array([1, 4, 3]);
    constructor.LONG_BITS = new Int32Array([2, 6, 5]);
    prototype.nFilt = null;
    prototype.length = null;
    prototype.order = null;
    prototype.direction = null;
    prototype.coef = null;
    prototype.decode = function(_in, info) {
        var windowCount = info.getWindowCount();
        var bits = info.isEightShortFrame() ? TNS.SHORT_BITS : TNS.LONG_BITS;
        var w, i, filt, coefLen, coefRes, coefCompress, tmp;
        for (w = 0; w < windowCount; w++) {
            if ((this.nFilt[w] = _in.readBits(bits[0])) != 0) {
                coefRes = _in.readBit();
                for (filt = 0; filt < this.nFilt[w]; filt++) {
                    this.length[w][filt] = _in.readBits(bits[1]);
                    if ((this.order[w][filt] = _in.readBits(bits[2])) > 20) 
                         throw new AACException("TNS filter out of range: " + this.order[w][filt]);
                     else if (this.order[w][filt] != 0) {
                        this.direction[w][filt] = _in.readBool();
                        coefCompress = _in.readBit();
                        coefLen = coefRes + 3 - coefCompress;
                        tmp = 2 * coefCompress + coefRes;
                        for (i = 0; i < this.order[w][filt]; i++) {
                            this.coef[w][filt][i] = TNSTables.TNS_TABLES[tmp][_in.readBits(coefLen)];
                        }
                    }
                }
            }
        }
    };
    prototype.process = function(ics, spec, sf, decode) {};
}, {SHORT_BITS: "Int32Array", LONG_BITS: "Int32Array", nFilt: "Int32Array", length: "Array", order: "Array", direction: "Array", coef: "Array", LOGGER: "Logger", TNS_COEF_1_3: "Float32Array", TNS_COEF_0_3: "Float32Array", TNS_COEF_1_4: "Float32Array", TNS_COEF_0_4: "Float32Array", TNS_TABLES: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var RationalLarge = function(num, den) {
    this.num = num;
    this.den = den;
};
RationalLarge = stjs.extend(RationalLarge, null, [], function(constructor, prototype) {
    constructor.ONE = new RationalLarge(1, 1);
    constructor.HALF = new RationalLarge(1, 2);
    constructor.ZERO = new RationalLarge(0, 1);
    prototype.num = 0;
    prototype.den = 0;
    prototype.getNum = function() {
        return this.num;
    };
    prototype.getDen = function() {
        return this.den;
    };
    constructor.parse = function(string) {
        var split = StringUtils.splitS(string, ":");
        return new RationalLarge(Long.parseLong(split[0]), Long.parseLong(split[1]));
    };
    prototype.hashCode = function() {
        var prime = 31;
        var result = 1;
        result = prime * result + (((this.den ^ (this.den >>> 32))) | 0);
        result = prime * result + (((this.num ^ (this.num >>> 32))) | 0);
        return result;
    };
    prototype.equals = function(obj) {
        if (this == obj) 
            return true;
        if (obj == null) 
            return false;
        if (this.getClass() != obj.getClass()) 
            return false;
        var other = obj;
        if (this.den != other.den) 
            return false;
        if (this.num != other.num) 
            return false;
        return true;
    };
    prototype.multiplyS = function(scalar) {
        return stjs.trunc((this.num * scalar) / this.den);
    };
    prototype.divideS = function(scalar) {
        return stjs.trunc((this.den * scalar) / this.num);
    };
    prototype.divideByS = function(scalar) {
        return stjs.trunc(this.num / (this.den * scalar));
    };
    prototype.flip = function() {
        return new RationalLarge(this.den, this.num);
    };
    constructor.R = function(num, den) {
        return new RationalLarge(num, den);
    };
    constructor.R1 = function(num) {
        return RationalLarge.R(num, 1);
    };
    prototype.lessThen = function(sec) {
        return this.num * sec.den < sec.num * this.den;
    };
    prototype.greaterThen = function(sec) {
        return this.num * sec.den > sec.num * this.den;
    };
    prototype.smallerOrEqualTo = function(sec) {
        return this.num * sec.den <= sec.num * this.den;
    };
    prototype.greaterOrEqualTo = function(sec) {
        return this.num * sec.den >= sec.num * this.den;
    };
    prototype.equalsLarge = function(other) {
        return this.num * other.den == other.num * this.den;
    };
    prototype.plus = function(other) {
        return RationalLarge.reduceLong(this.num * other.den + other.num * this.den, this.den * other.den);
    };
    prototype.plusR = function(other) {
        return RationalLarge.reduceLong(this.num * other.den + other.num * this.den, this.den * other.den);
    };
    prototype.minus = function(other) {
        return RationalLarge.reduceLong(this.num * other.den - other.num * this.den, this.den * other.den);
    };
    prototype.minusR = function(other) {
        return RationalLarge.reduceLong(this.num * other.den - other.num * this.den, this.den * other.den);
    };
    prototype.plusLong = function(scalar) {
        return new RationalLarge(this.num + scalar * this.den, this.den);
    };
    prototype.minusLong = function(scalar) {
        return new RationalLarge(this.num - scalar * this.den, this.den);
    };
    prototype.multiplyLong = function(scalar) {
        return new RationalLarge(this.num * scalar, this.den);
    };
    prototype.divideLong = function(scalar) {
        return new RationalLarge(this.den * scalar, this.num);
    };
    prototype.divideByLong = function(scalar) {
        return new RationalLarge(this.num, this.den * scalar);
    };
    prototype.multiply = function(other) {
        return RationalLarge.reduceLong(this.num * other.num, this.den * other.den);
    };
    prototype.multiplyR = function(other) {
        return RationalLarge.reduceLong(this.num * other.num, this.den * other.den);
    };
    prototype.divideRL = function(other) {
        return RationalLarge.reduceLong(other.num * this.den, other.den * this.num);
    };
    prototype.divideR = function(other) {
        return RationalLarge.reduceLong(other.num * this.den, other.den * this.num);
    };
    prototype.divideBy = function(other) {
        return RationalLarge.reduceLong(this.num * other.den, this.den * other.num);
    };
    prototype.divideByR = function(other) {
        return RationalLarge.reduceLong(this.num * other.den, this.den * other.num);
    };
    prototype.scalar = function() {
        return (this.num) / this.den;
    };
    prototype.scalarClip = function() {
        return stjs.trunc(this.num / this.den);
    };
    prototype.toString = function() {
        return this.num + ":" + this.den;
    };
    constructor.reduceLong = function(num, den) {
        var gcd = MathUtil.gcdLong(num, den);
        return new RationalLarge(stjs.trunc(num / gcd), stjs.trunc(den / gcd));
    };
}, {ONE: "RationalLarge", HALF: "RationalLarge", ZERO: "RationalLarge"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Low pass filter based on windowed sinc function
 *  
 *  Simplest possible low pass filter
 *  
 *  BW = 4 / kernelSize
 *  
 *  BW - width of transition band measured in fraction of sampling rate
 *  
 *  So for kernelSize = 20, and sampling rate 48000, BW = 9600 Hz ( pretty huge )
 *  
 *  @author The JCodec project
 *  
 */
var SincLowPassFilter = function(kernelSize, cutoffFreq) {
    ConvolutionFilter.call(this);
    this.kernelSize = kernelSize;
    this.cutoffFreq = cutoffFreq;
};
SincLowPassFilter = stjs.extend(SincLowPassFilter, ConvolutionFilter, [], function(constructor, prototype) {
    prototype.kernelSize = 0;
    prototype.cutoffFreq = 0.0;
    constructor.createSincLowPassFilter = function(cutoffFreq) {
        return new SincLowPassFilter(40, cutoffFreq);
    };
    constructor.createSincLowPassFilter2 = function(cutoffFreq, samplingRate) {
        return new SincLowPassFilter(40, cutoffFreq / samplingRate);
    };
    prototype.buildKernel = function() {
        var kernel = new Float64Array(this.kernelSize);
        var sum = 0;
        for (var i = 0; i < this.kernelSize; i++) {
            var a = i - stjs.trunc(this.kernelSize / 2);
            if (a != 0) 
                kernel[i] = Math.sin(2 * Math.PI * this.cutoffFreq * (i - stjs.trunc(this.kernelSize / 2))) / (i - stjs.trunc(this.kernelSize / 2)) * (0.54 - 0.46 * Math.cos(2 * Math.PI * i / this.kernelSize));
             else 
                kernel[i] = 2 * Math.PI * this.cutoffFreq;
            sum += kernel[i];
        }
        for (var i = 0; i < this.kernelSize; i++) 
            kernel[i] /= sum;
        return kernel;
    };
}, {kernel: "Float64Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 * 
 *  @author in-somnia
 */
var PSFilterbank = function(numTimeSlotsRate) {
    this.resolution20 = new Int32Array(3);
    this.resolution34 = new Int32Array(5);
    var i;
    this.resolution34[0] = 12;
    this.resolution34[1] = 8;
    this.resolution34[2] = 4;
    this.resolution34[3] = 4;
    this.resolution34[4] = 4;
    this.resolution20[0] = 8;
    this.resolution20[1] = 2;
    this.resolution20[2] = 2;
    this.frame_len = numTimeSlotsRate;
    this.work = Array.apply(null, Array((this.frame_len + 12))).map(function() {
        return new Float32Array(2);
    });
    this.buffer = Array.apply(null, Array(5)).map(function() {
        return Array.apply(null, Array(2)).map(function() {
            return new Float32Array(2);
        });
    });
    this.temp = Array.apply(null, Array(this.frame_len)).map(function() {
        return Array.apply(null, Array(12)).map(function() {
            return new Float32Array(2);
        });
    });
};
PSFilterbank = stjs.extend(PSFilterbank, null, [PSTables], function(constructor, prototype) {
    prototype.frame_len = 0;
    prototype.resolution20 = null;
    prototype.resolution34 = null;
    prototype.work = null;
    prototype.buffer = null;
    prototype.temp = null;
    prototype.hybrid_analysis = function(X, X_hybrid, use34, numTimeSlotsRate) {
        var k, n, band;
        var offset = 0;
        var qmf_bands = (use34) ? 5 : 3;
        var resolution = (use34) ? this.resolution34 : this.resolution20;
        for (band = 0; band < qmf_bands; band++) {
            for (var i = 0; i < 12; i++) {
                this.work[i][0] = this.buffer[band][i][0];
                this.work[i][1] = this.buffer[band][i][1];
            }
            for (n = 0; n < this.frame_len; n++) {
                this.work[12 + n][0] = X[n + 6][band][0];
                this.work[12 + n][0] = X[n + 6][band][0];
            }
            for (var i = 0; i < 12; i++) {
                this.buffer[band][i][0] = this.work[this.frame_len + i][0];
                this.buffer[band][i][1] = this.work[this.frame_len + i][1];
            }
            switch (resolution[band]) {
                case 2:
                    PSFilterbank.channel_filter2(this.frame_len, PSTables.p2_13_20, this.work, this.temp);
                    break;
                case 4:
                    PSFilterbank.channel_filter4(this.frame_len, PSTables.p4_13_34, this.work, this.temp);
                    break;
                case 8:
                    this.channel_filter8(this.frame_len, (use34) ? PSTables.p8_13_34 : PSTables.p8_13_20, this.work, this.temp);
                    break;
                case 12:
                    this.channel_filter12(this.frame_len, PSTables.p12_13_34, this.work, this.temp);
                    break;
            }
            for (n = 0; n < this.frame_len; n++) {
                for (k = 0; k < resolution[band]; k++) {
                    X_hybrid[n][offset + k][0] = this.temp[n][k][0];
                    X_hybrid[n][offset + k][1] = this.temp[n][k][1];
                }
            }
            offset += resolution[band];
        }
        if (!use34) {
            for (n = 0; n < numTimeSlotsRate; n++) {
                X_hybrid[n][3][0] += X_hybrid[n][4][0];
                X_hybrid[n][3][1] += X_hybrid[n][4][1];
                X_hybrid[n][4][0] = 0;
                X_hybrid[n][4][1] = 0;
                X_hybrid[n][2][0] += X_hybrid[n][5][0];
                X_hybrid[n][2][1] += X_hybrid[n][5][1];
                X_hybrid[n][5][0] = 0;
                X_hybrid[n][5][1] = 0;
            }
        }
    };
    constructor.channel_filter2 = function(frame_len, filter, buffer, X_hybrid) {
        var i;
        for (i = 0; i < frame_len; i++) {
            var r0 = (filter[0] * (buffer[0 + i][0] + buffer[12 + i][0]));
            var r1 = (filter[1] * (buffer[1 + i][0] + buffer[11 + i][0]));
            var r2 = (filter[2] * (buffer[2 + i][0] + buffer[10 + i][0]));
            var r3 = (filter[3] * (buffer[3 + i][0] + buffer[9 + i][0]));
            var r4 = (filter[4] * (buffer[4 + i][0] + buffer[8 + i][0]));
            var r5 = (filter[5] * (buffer[5 + i][0] + buffer[7 + i][0]));
            var r6 = (filter[6] * buffer[6 + i][0]);
            var i0 = (filter[0] * (buffer[0 + i][1] + buffer[12 + i][1]));
            var i1 = (filter[1] * (buffer[1 + i][1] + buffer[11 + i][1]));
            var i2 = (filter[2] * (buffer[2 + i][1] + buffer[10 + i][1]));
            var i3 = (filter[3] * (buffer[3 + i][1] + buffer[9 + i][1]));
            var i4 = (filter[4] * (buffer[4 + i][1] + buffer[8 + i][1]));
            var i5 = (filter[5] * (buffer[5 + i][1] + buffer[7 + i][1]));
            var i6 = (filter[6] * buffer[6 + i][1]);
            X_hybrid[i][0][0] = r0 + r1 + r2 + r3 + r4 + r5 + r6;
            X_hybrid[i][0][1] = i0 + i1 + i2 + i3 + i4 + i5 + i6;
            X_hybrid[i][1][0] = r0 - r1 + r2 - r3 + r4 - r5 + r6;
            X_hybrid[i][1][1] = i0 - i1 + i2 - i3 + i4 - i5 + i6;
        }
    };
    constructor.channel_filter4 = function(frame_len, filter, buffer, X_hybrid) {
        var i;
        var input_re1 = new Float32Array(2), input_re2 = new Float32Array(2);
        var input_im1 = new Float32Array(2), input_im2 = new Float32Array(2);
        for (i = 0; i < frame_len; i++) {
            input_re1[0] = -(filter[2] * (buffer[i + 2][0] + buffer[i + 10][0])) + (filter[6] * buffer[i + 6][0]);
            input_re1[1] = (-0.70710677 * ((filter[1] * (buffer[i + 1][0] + buffer[i + 11][0])) + (filter[3] * (buffer[i + 3][0] + buffer[i + 9][0])) - (filter[5] * (buffer[i + 5][0] + buffer[i + 7][0]))));
            input_im1[0] = (filter[0] * (buffer[i + 0][1] - buffer[i + 12][1])) - (filter[4] * (buffer[i + 4][1] - buffer[i + 8][1]));
            input_im1[1] = (0.70710677 * ((filter[1] * (buffer[i + 1][1] - buffer[i + 11][1])) - (filter[3] * (buffer[i + 3][1] - buffer[i + 9][1])) - (filter[5] * (buffer[i + 5][1] - buffer[i + 7][1]))));
            input_re2[0] = (filter[0] * (buffer[i + 0][0] - buffer[i + 12][0])) - (filter[4] * (buffer[i + 4][0] - buffer[i + 8][0]));
            input_re2[1] = (0.70710677 * ((filter[1] * (buffer[i + 1][0] - buffer[i + 11][0])) - (filter[3] * (buffer[i + 3][0] - buffer[i + 9][0])) - (filter[5] * (buffer[i + 5][0] - buffer[i + 7][0]))));
            input_im2[0] = -(filter[2] * (buffer[i + 2][1] + buffer[i + 10][1])) + (filter[6] * buffer[i + 6][1]);
            input_im2[1] = (-0.70710677 * ((filter[1] * (buffer[i + 1][1] + buffer[i + 11][1])) + (filter[3] * (buffer[i + 3][1] + buffer[i + 9][1])) - (filter[5] * (buffer[i + 5][1] + buffer[i + 7][1]))));
            X_hybrid[i][0][0] = input_re1[0] + input_re1[1] + input_im1[0] + input_im1[1];
            X_hybrid[i][0][1] = -input_re2[0] - input_re2[1] + input_im2[0] + input_im2[1];
            X_hybrid[i][1][0] = input_re1[0] - input_re1[1] - input_im1[0] + input_im1[1];
            X_hybrid[i][1][1] = input_re2[0] - input_re2[1] + input_im2[0] - input_im2[1];
            X_hybrid[i][2][0] = input_re1[0] - input_re1[1] + input_im1[0] - input_im1[1];
            X_hybrid[i][2][1] = -input_re2[0] + input_re2[1] + input_im2[0] - input_im2[1];
            X_hybrid[i][3][0] = input_re1[0] + input_re1[1] - input_im1[0] - input_im1[1];
            X_hybrid[i][3][1] = input_re2[0] + input_re2[1] + input_im2[0] + input_im2[1];
        }
    };
    constructor.DCT3_4_unscaled = function(y, x) {
        var f0, f1, f2, f3, f4, f5, f6, f7, f8;
        f0 = (x[2] * 0.70710677);
        f1 = x[0] - f0;
        f2 = x[0] + f0;
        f3 = x[1] + x[3];
        f4 = (x[1] * 1.306563);
        f5 = (f3 * (-0.9238795));
        f6 = (x[3] * (-0.5411961));
        f7 = f4 + f5;
        f8 = f6 - f5;
        y[3] = f2 - f8;
        y[0] = f2 + f8;
        y[2] = f1 - f7;
        y[1] = f1 + f7;
    };
    prototype.channel_filter8 = function(frame_len, filter, buffer, X_hybrid) {
        var i, n;
        var input_re1 = new Float32Array(4), input_re2 = new Float32Array(4);
        var input_im1 = new Float32Array(4), input_im2 = new Float32Array(4);
        var x = new Float32Array(4);
        for (i = 0; i < frame_len; i++) {
            input_re1[0] = (filter[6] * buffer[6 + i][0]);
            input_re1[1] = (filter[5] * (buffer[5 + i][0] + buffer[7 + i][0]));
            input_re1[2] = -(filter[0] * (buffer[0 + i][0] + buffer[12 + i][0])) + (filter[4] * (buffer[4 + i][0] + buffer[8 + i][0]));
            input_re1[3] = -(filter[1] * (buffer[1 + i][0] + buffer[11 + i][0])) + (filter[3] * (buffer[3 + i][0] + buffer[9 + i][0]));
            input_im1[0] = (filter[5] * (buffer[7 + i][1] - buffer[5 + i][1]));
            input_im1[1] = (filter[0] * (buffer[12 + i][1] - buffer[0 + i][1])) + (filter[4] * (buffer[8 + i][1] - buffer[4 + i][1]));
            input_im1[2] = (filter[1] * (buffer[11 + i][1] - buffer[1 + i][1])) + (filter[3] * (buffer[9 + i][1] - buffer[3 + i][1]));
            input_im1[3] = (filter[2] * (buffer[10 + i][1] - buffer[2 + i][1]));
            for (n = 0; n < 4; n++) {
                x[n] = input_re1[n] - input_im1[3 - n];
            }
            PSFilterbank.DCT3_4_unscaled(x, x);
            X_hybrid[i][7][0] = x[0];
            X_hybrid[i][5][0] = x[2];
            X_hybrid[i][3][0] = x[3];
            X_hybrid[i][1][0] = x[1];
            for (n = 0; n < 4; n++) {
                x[n] = input_re1[n] + input_im1[3 - n];
            }
            PSFilterbank.DCT3_4_unscaled(x, x);
            X_hybrid[i][6][0] = x[1];
            X_hybrid[i][4][0] = x[3];
            X_hybrid[i][2][0] = x[2];
            X_hybrid[i][0][0] = x[0];
            input_im2[0] = (filter[6] * buffer[6 + i][1]);
            input_im2[1] = (filter[5] * (buffer[5 + i][1] + buffer[7 + i][1]));
            input_im2[2] = -(filter[0] * (buffer[0 + i][1] + buffer[12 + i][1])) + (filter[4] * (buffer[4 + i][1] + buffer[8 + i][1]));
            input_im2[3] = -(filter[1] * (buffer[1 + i][1] + buffer[11 + i][1])) + (filter[3] * (buffer[3 + i][1] + buffer[9 + i][1]));
            input_re2[0] = (filter[5] * (buffer[7 + i][0] - buffer[5 + i][0]));
            input_re2[1] = (filter[0] * (buffer[12 + i][0] - buffer[0 + i][0])) + (filter[4] * (buffer[8 + i][0] - buffer[4 + i][0]));
            input_re2[2] = (filter[1] * (buffer[11 + i][0] - buffer[1 + i][0])) + (filter[3] * (buffer[9 + i][0] - buffer[3 + i][0]));
            input_re2[3] = (filter[2] * (buffer[10 + i][0] - buffer[2 + i][0]));
            for (n = 0; n < 4; n++) {
                x[n] = input_im2[n] + input_re2[3 - n];
            }
            PSFilterbank.DCT3_4_unscaled(x, x);
            X_hybrid[i][7][1] = x[0];
            X_hybrid[i][5][1] = x[2];
            X_hybrid[i][3][1] = x[3];
            X_hybrid[i][1][1] = x[1];
            for (n = 0; n < 4; n++) {
                x[n] = input_im2[n] - input_re2[3 - n];
            }
            PSFilterbank.DCT3_4_unscaled(x, x);
            X_hybrid[i][6][1] = x[1];
            X_hybrid[i][4][1] = x[3];
            X_hybrid[i][2][1] = x[2];
            X_hybrid[i][0][1] = x[0];
        }
    };
    prototype.DCT3_6_unscaled = function(y, x) {
        var f0, f1, f2, f3, f4, f5, f6, f7;
        f0 = (x[3] * 0.70710677);
        f1 = x[0] + f0;
        f2 = x[0] - f0;
        f3 = ((x[1] - x[5]) * 0.70710677);
        f4 = (x[2] * 0.8660254) + (x[4] * 0.5);
        f5 = f4 - x[4];
        f6 = (x[1] * 0.9659258) + (x[5] * 0.25881904);
        f7 = f6 - f3;
        y[0] = f1 + f6 + f4;
        y[1] = f2 + f3 - x[4];
        y[2] = f7 + f2 - f5;
        y[3] = f1 - f7 - f5;
        y[4] = f1 - f3 - x[4];
        y[5] = f2 - f6 + f4;
    };
    prototype.channel_filter12 = function(frame_len, filter, buffer, X_hybrid) {
        var i, n;
        var input_re1 = new Float32Array(6), input_re2 = new Float32Array(6);
        var input_im1 = new Float32Array(6), input_im2 = new Float32Array(6);
        var out_re1 = new Float32Array(6), out_re2 = new Float32Array(6);
        var out_im1 = new Float32Array(6), out_im2 = new Float32Array(6);
        for (i = 0; i < frame_len; i++) {
            for (n = 0; n < 6; n++) {
                if (n == 0) {
                    input_re1[0] = (buffer[6 + i][0] * filter[6]);
                    input_re2[0] = (buffer[6 + i][1] * filter[6]);
                } else {
                    input_re1[6 - n] = ((buffer[n + i][0] + buffer[12 - n + i][0]) * filter[n]);
                    input_re2[6 - n] = ((buffer[n + i][1] + buffer[12 - n + i][1]) * filter[n]);
                }
                input_im2[n] = ((buffer[n + i][0] - buffer[12 - n + i][0]) * filter[n]);
                input_im1[n] = ((buffer[n + i][1] - buffer[12 - n + i][1]) * filter[n]);
            }
            this.DCT3_6_unscaled(out_re1, input_re1);
            this.DCT3_6_unscaled(out_re2, input_re2);
            this.DCT3_6_unscaled(out_im1, input_im1);
            this.DCT3_6_unscaled(out_im2, input_im2);
            for (n = 0; n < 6; n += 2) {
                X_hybrid[i][n][0] = out_re1[n] - out_im1[n];
                X_hybrid[i][n][1] = out_re2[n] + out_im2[n];
                X_hybrid[i][n + 1][0] = out_re1[n + 1] + out_im1[n + 1];
                X_hybrid[i][n + 1][1] = out_re2[n + 1] - out_im2[n + 1];
                X_hybrid[i][10 - n][0] = out_re1[n + 1] - out_im1[n + 1];
                X_hybrid[i][10 - n][1] = out_re2[n + 1] + out_im2[n + 1];
                X_hybrid[i][11 - n][0] = out_re1[n] + out_im1[n];
                X_hybrid[i][11 - n][1] = out_re2[n] - out_im2[n];
            }
        }
    };
    prototype.hybrid_synthesis = function(X, X_hybrid, use34, numTimeSlotsRate) {
        var k, n, band;
        var offset = 0;
        var qmf_bands = (use34) ? 5 : 3;
        var resolution = (use34) ? this.resolution34 : this.resolution20;
        for (band = 0; band < qmf_bands; band++) {
            for (n = 0; n < this.frame_len; n++) {
                X[n][band][0] = 0;
                X[n][band][1] = 0;
                for (k = 0; k < resolution[band]; k++) {
                    X[n][band][0] += X_hybrid[n][offset + k][0];
                    X[n][band][1] += X_hybrid[n][offset + k][1];
                }
            }
            offset += resolution[band];
        }
    };
}, {resolution20: "Int32Array", resolution34: "Int32Array", work: "Array", buffer: "Array", temp: "Array", nr_iid_par_tab: "Int32Array", nr_icc_par_tab: "Int32Array", nr_ipdopd_par_tab: "Int32Array", num_env_tab: "Array", filter_a: "Float32Array", group_border20: "Int32Array", group_border34: "Int32Array", map_group2bk20: "Int32Array", map_group2bk34: "Int32Array", delay_length_d: "Int32Array", p8_13_20: "Float32Array", p2_13_20: "Float32Array", p12_13_34: "Float32Array", p8_13_34: "Float32Array", p4_13_34: "Float32Array", Phi_Fract_Qmf: "Array", Phi_Fract_SubQmf20: "Array", Phi_Fract_SubQmf34: "Array", Q_Fract_allpass_Qmf: "Array", Q_Fract_allpass_SubQmf20: "Array", Q_Fract_allpass_SubQmf34: "Array", cos_alphas: "Float32Array", sin_alphas: "Float32Array", cos_betas_normal: "Array", sin_betas_normal: "Array", cos_betas_fine: "Array", sin_betas_fine: "Array", sincos_alphas_B_normal: "Array", sincos_alphas_B_fine: "Array", cos_gammas_normal: "Array", cos_gammas_fine: "Array", sin_gammas_normal: "Array", sin_gammas_fine: "Array", sf_iid_normal: "Float32Array", sf_iid_fine: "Float32Array", ipdopd_cos_tab: "Float32Array", ipdopd_sin_tab: "Float32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var VideoDecoder = function() {};
VideoDecoder = stjs.extend(VideoDecoder, null, [], function(constructor, prototype) {
    prototype.byteBuffer = null;
    /**
     *  Decodes a video frame to an uncompressed picture in codec native
     *  colorspace
     *  
     *  @param data
     *             Compressed frame data
     *  @throws IOException
     */
    prototype.decodeFrame = function(data, buffer) {
        var frame = this.decodeFrame8Bit(data, this.getSameSizeBuffer(buffer));
        return frame == null ? null : frame.toPictureWithBuffer(8, buffer);
    };
    /**
     *  Decodes a video frame to an uncompressed picture in codec native
     *  colorspace
     *  
     *  @param data
     *             Compressed frame data
     *  @throws IOException
     */
    prototype.decodeFrame8Bit = function(data, buffer) {};
    /**
     *  Tests if compressed frame can be decoded with this decoder
     *  
     *  @param data
     *             Compressed frame data
     *  @return
     */
    prototype.probe = function(data) {};
    prototype.getSameSizeBuffer = function(buffer) {
        if (this.byteBuffer == null || this.byteBuffer.length != buffer.length || this.byteBuffer[0].length != buffer[0].length) 
            this.byteBuffer = ArrayUtil.create2D(buffer[0].length, buffer.length);
        return this.byteBuffer;
    };
    /**
     *  Returns a downscaled version of this decoder
     *  @param ratio
     *  @return
     */
    prototype.downscaled = function(ratio) {
        if (ratio == 1) 
            return this;
        return null;
    };
}, {byteBuffer: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Debug = function() {};
Debug = stjs.extend(Debug, null, [], function(constructor, prototype) {
    constructor.print8x8i = function(output) {
        var i = 0;
        for (var x = 0; x < 8; x++) {
            for (var y = 0; y < 8; y++) {
                System.out.printf("%3d, ", output[i]);
                i++;
            }
            System.out.println();
        }
    };
    constructor.print8x8s = function(output) {
        var i = 0;
        for (var x = 0; x < 8; x++) {
            for (var y = 0; y < 8; y++) {
                System.out.printf("%3d, ", output[i]);
                i++;
            }
            System.out.println();
        }
    };
    constructor.print8x8sb = function(output) {
        for (var x = 0; x < 8; x++) {
            for (var y = 0; y < 8; y++) {
                System.out.printf("%3d, ", output.get());
            }
            System.out.println();
        }
    };
    constructor.prints = function(table) {
        var i = 0;
        for (var x = 0; x < 8; x++) {
            for (var y = 0; y < 8; y++) {
                System.out.printf("%3d, ", table[i]);
                i++;
            }
            System.out.println();
        }
    };
    constructor.trace = function(_arguments) {
        if (Debug.debug && arguments.length > 0) {
            var format = arguments[0];
            ArrayUtil.shiftLeft1(arguments);
            System.out.printf(format + ": %d\n", arguments);
        }
    };
    constructor.debug = false;
    constructor.printInt = function(i) {
        if (Debug.debug) 
            System.out.print(i);
    };
    constructor.print = function(string) {
        if (Debug.debug) 
            System.out.print(string);
    };
    constructor.println = function(string) {
        if (Debug.debug) 
            System.out.println(string);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Integer DCT 4x4 base implementation
 *  
 *  @author The JCodec project
 *  
 */
var CoeffTransformer = function(scalingListMatrix) {};
CoeffTransformer = stjs.extend(CoeffTransformer, null, [], function(constructor, prototype) {
    constructor.fieldScan4x4 = new Int32Array([0, 4, 1, 8, 12, 5, 9, 13, 2, 6, 10, 14, 3, 7, 11, 15]);
    constructor.fieldScan8x8 = new Int32Array([0, 8, 16, 1, 9, 24, 32, 17, 2, 25, 40, 48, 56, 33, 10, 3, 18, 41, 49, 57, 26, 11, 4, 19, 34, 42, 50, 58, 27, 12, 5, 20, 35, 43, 51, 58, 28, 13, 6, 21, 36, 44, 52, 60, 29, 14, 22, 37, 45, 53, 61, 30, 7, 15, 38, 46, 54, 62, 23, 31, 39, 47, 55, 63]);
    constructor.zigzag4x4 = new Int32Array([0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15]);
    constructor.dequantCoef = [new Int32Array([10, 13, 10, 13, 13, 16, 13, 16, 10, 13, 10, 13, 13, 16, 13, 16]), new Int32Array([11, 14, 11, 14, 14, 18, 14, 18, 11, 14, 11, 14, 14, 18, 14, 18]), new Int32Array([13, 16, 13, 16, 16, 20, 16, 20, 13, 16, 13, 16, 16, 20, 16, 20]), new Int32Array([14, 18, 14, 18, 18, 23, 18, 23, 14, 18, 14, 18, 18, 23, 18, 23]), new Int32Array([16, 20, 16, 20, 20, 25, 20, 25, 16, 20, 16, 20, 20, 25, 20, 25]), new Int32Array([18, 23, 18, 23, 23, 29, 23, 29, 18, 23, 18, 23, 23, 29, 23, 29])];
    constructor.dequantCoef8x8 = Array.apply(null, Array(6)).map(function() {
        return new Int32Array(64);
    });
    constructor.initDequantCoeff8x8 = [new Int32Array([20, 18, 32, 19, 25, 24]), new Int32Array([22, 19, 35, 21, 28, 26]), new Int32Array([26, 23, 42, 24, 33, 31]), new Int32Array([28, 25, 45, 26, 35, 33]), new Int32Array([32, 28, 51, 30, 40, 38]), new Int32Array([36, 32, 58, 34, 46, 43])];
    constructor.zigzag8x8 = new Int32Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]);
    constructor.quantCoeff = [new Int32Array([13107, 8066, 13107, 8066, 8066, 5243, 8066, 5243, 13107, 8066, 13107, 8066, 8066, 5243, 8066, 5243]), new Int32Array([11916, 7490, 11916, 7490, 7490, 4660, 7490, 4660, 11916, 7490, 11916, 7490, 7490, 4660, 7490, 4660]), new Int32Array([10082, 6554, 10082, 6554, 6554, 4194, 6554, 4194, 10082, 6554, 10082, 6554, 6554, 4194, 6554, 4194]), new Int32Array([9362, 5825, 9362, 5825, 5825, 3647, 5825, 3647, 9362, 5825, 9362, 5825, 5825, 3647, 5825, 3647]), new Int32Array([8192, 5243, 8192, 5243, 5243, 3355, 5243, 3355, 8192, 5243, 8192, 5243, 5243, 3355, 5243, 3355]), new Int32Array([7282, 4559, 7282, 4559, 4559, 2893, 4559, 2893, 7282, 4559, 7282, 4559, 4559, 2893, 4559, 2893])];
    /**
     *  Inverce integer DCT transform for 4x4 block
     *  
     *  @param block
     *  @return
     */
    constructor.idct4x4 = function(block) {
        CoeffTransformer._idct4x4(block, block);
    };
    constructor._idct4x4 = function(block, out) {
        for (var i = 0; i < 16; i += 4) {
            var e0 = block[i] + block[i + 2];
            var e1 = block[i] - block[i + 2];
            var e2 = (block[i + 1] >> 1) - block[i + 3];
            var e3 = block[i + 1] + (block[i + 3] >> 1);
            out[i] = e0 + e3;
            out[i + 1] = e1 + e2;
            out[i + 2] = e1 - e2;
            out[i + 3] = e0 - e3;
        }
        for (var i = 0; i < 4; i++) {
            var g0 = out[i] + out[i + 8];
            var g1 = out[i] - out[i + 8];
            var g2 = (out[i + 4] >> 1) - out[i + 12];
            var g3 = out[i + 4] + (out[i + 12] >> 1);
            out[i] = g0 + g3;
            out[i + 4] = g1 + g2;
            out[i + 8] = g1 - g2;
            out[i + 12] = g0 - g3;
        }
        for (var i = 0; i < 16; i++) {
            out[i] = (out[i] + 32) >> 6;
        }
    };
    constructor.fdct4x4 = function(block) {
        for (var i = 0; i < 16; i += 4) {
            var t0 = block[i] + block[i + 3];
            var t1 = block[i + 1] + block[i + 2];
            var t2 = block[i + 1] - block[i + 2];
            var t3 = block[i] - block[i + 3];
            block[i] = t0 + t1;
            block[i + 1] = (t3 << 1) + t2;
            block[i + 2] = t0 - t1;
            block[i + 3] = t3 - (t2 << 1);
        }
        for (var i = 0; i < 4; i++) {
            var t0 = block[i] + block[i + 12];
            var t1 = block[i + 4] + block[i + 8];
            var t2 = block[i + 4] - block[i + 8];
            var t3 = block[i] - block[i + 12];
            block[i] = t0 + t1;
            block[i + 4] = t2 + (t3 << 1);
            block[i + 8] = t0 - t1;
            block[i + 12] = t3 - (t2 << 1);
        }
    };
    /**
     *  Inverse Hadamard transform
     *  
     *  @param scaled
     */
    constructor.invDC4x4 = function(scaled) {
        for (var i = 0; i < 16; i += 4) {
            var e0 = scaled[i] + scaled[i + 2];
            var e1 = scaled[i] - scaled[i + 2];
            var e2 = scaled[i + 1] - scaled[i + 3];
            var e3 = scaled[i + 1] + scaled[i + 3];
            scaled[i] = e0 + e3;
            scaled[i + 1] = e1 + e2;
            scaled[i + 2] = e1 - e2;
            scaled[i + 3] = e0 - e3;
        }
        for (var i = 0; i < 4; i++) {
            var g0 = scaled[i] + scaled[i + 8];
            var g1 = scaled[i] - scaled[i + 8];
            var g2 = scaled[i + 4] - scaled[i + 12];
            var g3 = scaled[i + 4] + scaled[i + 12];
            scaled[i] = g0 + g3;
            scaled[i + 4] = g1 + g2;
            scaled[i + 8] = g1 - g2;
            scaled[i + 12] = g0 - g3;
        }
    };
    /**
     *  Forward Hadamard transform
     *  
     *  @param scaled
     */
    constructor.fvdDC4x4 = function(scaled) {
        for (var i = 0; i < 16; i += 4) {
            var t0 = scaled[i] + scaled[i + 3];
            var t1 = scaled[i + 1] + scaled[i + 2];
            var t2 = scaled[i + 1] - scaled[i + 2];
            var t3 = scaled[i] - scaled[i + 3];
            scaled[i] = t0 + t1;
            scaled[i + 1] = t3 + t2;
            scaled[i + 2] = t0 - t1;
            scaled[i + 3] = t3 - t2;
        }
        for (var i = 0; i < 4; i++) {
            var t0 = scaled[i] + scaled[i + 12];
            var t1 = scaled[i + 4] + scaled[i + 8];
            var t2 = scaled[i + 4] - scaled[i + 8];
            var t3 = scaled[i] - scaled[i + 12];
            scaled[i] = (t0 + t1) >> 1;
            scaled[i + 4] = (t2 + t3) >> 1;
            scaled[i + 8] = (t0 - t1) >> 1;
            scaled[i + 12] = (t3 - t2) >> 1;
        }
    };
    constructor.dequantizeAC = function(coeffs, qp) {
        var group = qp % 6;
        if (qp >= 24) {
            var qbits = stjs.trunc(qp / 6);
            for (var i = 0; i < 16; i++) 
                coeffs[i] = (coeffs[i] * CoeffTransformer.dequantCoef[group][i]) << qbits;
        } else {
            var qbits = 4 - stjs.trunc(qp / 6);
            var addition = 1 << (3 - stjs.trunc(qp / 6));
            for (var i = 0; i < 16; i++) 
                coeffs[i] = (coeffs[i] * (CoeffTransformer.dequantCoef[group][i] << 4) + addition) >> qbits;
        }
    };
    constructor.quantizeAC = function(coeffs, qp) {
        var level = stjs.trunc(qp / 6);
        var offset = qp % 6;
        var addition = 682 << (stjs.trunc(qp / 6) + 4);
        var qbits = 15 + level;
        if (qp < 10) {
            for (var i = 0; i < 16; i++) {
                var sign = (coeffs[i] >> 31);
                coeffs[i] = (Math.min((((coeffs[i] ^ sign) - sign) * CoeffTransformer.quantCoeff[offset][i] + addition) >> qbits, 2063) ^ sign) - sign;
            }
        } else {
            for (var i = 0; i < 16; i++) {
                var sign = (coeffs[i] >> 31);
                coeffs[i] = (((((coeffs[i] ^ sign) - sign) * CoeffTransformer.quantCoeff[offset][i] + addition) >> qbits) ^ sign) - sign;
            }
        }
    };
    constructor.unzigzagAC = function(coeffs) {
        var tab;
        if (coeffs.length == 16) {
            tab = CoeffTransformer.zigzag4x4;
        } else if (coeffs.length == 64) {
            tab = CoeffTransformer.zigzag8x8;
        } else 
             throw new IllegalArgumentException("Coefficients array should be of either 16 or 64 length.");
        var result = new Int32Array(coeffs.length);
        for (var i = 0; i < coeffs.length; i++) {
            result[tab[i]] = coeffs[i];
        }
        return result;
    };
    constructor.dequantizeDC4x4 = function(coeffs, qp) {
        var group = qp % 6;
        if (qp >= 36) {
            var qbits = stjs.trunc(qp / 6) - 2;
            for (var i = 0; i < 16; i++) 
                coeffs[i] = (coeffs[i] * CoeffTransformer.dequantCoef[group][0]) << qbits;
        } else {
            var qbits = 6 - stjs.trunc(qp / 6);
            var addition = 1 << (5 - stjs.trunc(qp / 6));
            for (var i = 0; i < 16; i++) 
                coeffs[i] = (coeffs[i] * (CoeffTransformer.dequantCoef[group][0] << 4) + addition) >> qbits;
        }
    };
    constructor.quantizeDC4x4 = function(coeffs, qp) {
        var level = stjs.trunc(qp / 6);
        var offset = qp % 6;
        var addition = 682 << (stjs.trunc(qp / 6) + 5);
        var qbits = 16 + level;
        if (qp < 10) {
            for (var i = 0; i < 16; i++) {
                var sign = (coeffs[i] >> 31);
                coeffs[i] = (Math.min((((coeffs[i] ^ sign) - sign) * CoeffTransformer.quantCoeff[offset][0] + addition) >> qbits, 2063) ^ sign) - sign;
            }
        } else {
            for (var i = 0; i < 16; i++) {
                var sign = (coeffs[i] >> 31);
                coeffs[i] = (((((coeffs[i] ^ sign) - sign) * CoeffTransformer.quantCoeff[offset][0] + addition) >> qbits) ^ sign) - sign;
            }
        }
    };
    /**
     *  Inverse Hadamard 2x2
     *  
     *  @param block
     */
    constructor.invDC2x2 = function(block) {
        var t0, t1, t2, t3;
        t0 = block[0] + block[1];
        t1 = block[0] - block[1];
        t2 = block[2] + block[3];
        t3 = block[2] - block[3];
        block[0] = (t0 + t2);
        block[1] = (t1 + t3);
        block[2] = (t0 - t2);
        block[3] = (t1 - t3);
    };
    /**
     *  Forward Hadamard 2x2
     *  
     *  @param dc2
     */
    constructor.fvdDC2x2 = function(block) {
        CoeffTransformer.invDC2x2(block);
    };
    constructor.dequantizeDC2x2 = function(transformed, qp) {
        var group = qp % 6;
        var shift = stjs.trunc(qp / 6);
        for (var i = 0; i < 4; i++) {
            transformed[i] = ((transformed[i] * CoeffTransformer.dequantCoef[group][0]) << shift) >> 1;
        }
    };
    constructor.quantizeDC2x2 = function(coeffs, qp) {
        var level = stjs.trunc(qp / 6);
        var offset = qp % 6;
        var addition = 682 << (stjs.trunc(qp / 6) + 5);
        var qbits = 16 + level;
        if (qp < 4) {
            for (var i = 0; i < 4; i++) {
                var sign = (coeffs[i] >> 31);
                coeffs[i] = (Math.min((((coeffs[i] ^ sign) - sign) * CoeffTransformer.quantCoeff[offset][0] + addition) >> qbits, 2063) ^ sign) - sign;
            }
        } else {
            for (var i = 0; i < 4; i++) {
                var sign = (coeffs[i] >> 31);
                coeffs[i] = (((((coeffs[i] ^ sign) - sign) * CoeffTransformer.quantCoeff[offset][0] + addition) >> qbits) ^ sign) - sign;
            }
        }
    };
    constructor.reorderDC4x4 = function(dc) {
        ArrayUtil.swap(dc, 2, 4);
        ArrayUtil.swap(dc, 3, 5);
        ArrayUtil.swap(dc, 10, 12);
        ArrayUtil.swap(dc, 11, 13);
    };
    constructor.fvdDC4x2 = function(dc) {};
    constructor.quantizeDC4x2 = function(dc, qp) {};
    constructor.invDC4x2 = function(dc) {};
    constructor.dequantizeDC4x2 = function(dc, qp) {};
    /**
     *  Coefficients are <<4 on exit
     *  
     *  @param coeffs
     *  @param qp
     */
    constructor.dequantizeAC8x8 = function(coeffs, qp) {
        var group = qp % 6;
        if (qp >= 36) {
            var qbits = stjs.trunc(qp / 6) - 2;
            for (var i = 0; i < 64; i++) 
                coeffs[i] = (coeffs[i] * CoeffTransformer.dequantCoef8x8[group][i]) << qbits;
        } else {
            var qbits = 6 - stjs.trunc(qp / 6);
            var addition = 1 << (5 - stjs.trunc(qp / 6));
            for (var i = 0; i < 64; i++) 
                coeffs[i] = (coeffs[i] * (CoeffTransformer.dequantCoef8x8[group][i] << 4) + addition) >> qbits;
        }
    };
    constructor.idct8x8 = function(ac) {
        var off = 0;
        for (var row = 0; row < 8; row++) {
            var e0 = ac[off] + ac[off + 4];
            var e1 = -ac[off + 3] + ac[off + 5] - ac[off + 7] - (ac[off + 7] >> 1);
            var e2 = ac[off] - ac[off + 4];
            var e3 = ac[off + 1] + ac[off + 7] - ac[off + 3] - (ac[off + 3] >> 1);
            var e4 = (ac[off + 2] >> 1) - ac[off + 6];
            var e5 = -ac[off + 1] + ac[off + 7] + ac[off + 5] + (ac[off + 5] >> 1);
            var e6 = ac[off + 2] + (ac[off + 6] >> 1);
            var e7 = ac[off + 3] + ac[off + 5] + ac[off + 1] + (ac[off + 1] >> 1);
            var f0 = e0 + e6;
            var f1 = e1 + (e7 >> 2);
            var f2 = e2 + e4;
            var f3 = e3 + (e5 >> 2);
            var f4 = e2 - e4;
            var f5 = (e3 >> 2) - e5;
            var f6 = e0 - e6;
            var f7 = e7 - (e1 >> 2);
            ac[off] = f0 + f7;
            ac[off + 1] = f2 + f5;
            ac[off + 2] = f4 + f3;
            ac[off + 3] = f6 + f1;
            ac[off + 4] = f6 - f1;
            ac[off + 5] = f4 - f3;
            ac[off + 6] = f2 - f5;
            ac[off + 7] = f0 - f7;
            off += 8;
        }
        for (var col = 0; col < 8; col++) {
            var e0 = ac[col] + ac[col + 32];
            var e1 = -ac[col + 24] + ac[col + 40] - ac[col + 56] - (ac[col + 56] >> 1);
            var e2 = ac[col] - ac[col + 32];
            var e3 = ac[col + 8] + ac[col + 56] - ac[col + 24] - (ac[col + 24] >> 1);
            var e4 = (ac[col + 16] >> 1) - ac[col + 48];
            var e5 = -ac[col + 8] + ac[col + 56] + ac[col + 40] + (ac[col + 40] >> 1);
            var e6 = ac[col + 16] + (ac[col + 48] >> 1);
            var e7 = ac[col + 24] + ac[col + 40] + ac[col + 8] + (ac[col + 8] >> 1);
            var f0 = e0 + e6;
            var f1 = e1 + (e7 >> 2);
            var f2 = e2 + e4;
            var f3 = e3 + (e5 >> 2);
            var f4 = e2 - e4;
            var f5 = (e3 >> 2) - e5;
            var f6 = e0 - e6;
            var f7 = e7 - (e1 >> 2);
            ac[col] = f0 + f7;
            ac[col + 8] = f2 + f5;
            ac[col + 16] = f4 + f3;
            ac[col + 24] = f6 + f1;
            ac[col + 32] = f6 - f1;
            ac[col + 40] = f4 - f3;
            ac[col + 48] = f2 - f5;
            ac[col + 56] = f0 - f7;
        }
        for (var i = 0; i < 64; i++) {
            ac[i] = (ac[i] + 32) >> 6;
        }
    };
}, {fieldScan4x4: "Int32Array", fieldScan8x8: "Int32Array", zigzag4x4: "Int32Array", dequantCoef: "Array", dequantCoef8x8: "Array", initDequantCoeff8x8: "Array", zigzag8x8: "Int32Array", quantCoeff: "Array"}, {});
(function() {
    for (var g = 0; g < 6; g++) {
        Arrays.fill(CoeffTransformer.dequantCoef8x8[g], CoeffTransformer.initDequantCoeff8x8[g][5]);
        for (var i = 0; i < 8; i += 4) 
            for (var j = 0; j < 8; j += 4) 
                CoeffTransformer.dequantCoef8x8[g][(i << 3) + j] = CoeffTransformer.initDequantCoeff8x8[g][0];
        for (var i = 1; i < 8; i += 2) 
            for (var j = 1; j < 8; j += 2) 
                CoeffTransformer.dequantCoef8x8[g][(i << 3) + j] = CoeffTransformer.initDequantCoeff8x8[g][1];
        for (var i = 2; i < 8; i += 4) 
            for (var j = 2; j < 8; j += 4) 
                CoeffTransformer.dequantCoef8x8[g][(i << 3) + j] = CoeffTransformer.initDequantCoeff8x8[g][2];
        for (var i = 0; i < 8; i += 4) 
            for (var j = 1; j < 8; j += 2) 
                CoeffTransformer.dequantCoef8x8[g][(i << 3) + j] = CoeffTransformer.initDequantCoeff8x8[g][3];
        for (var i = 1; i < 8; i += 2) 
            for (var j = 0; j < 8; j += 4) 
                CoeffTransformer.dequantCoef8x8[g][(i << 3) + j] = CoeffTransformer.initDequantCoeff8x8[g][3];
        for (var i = 0; i < 8; i += 4) 
            for (var j = 2; j < 8; j += 4) 
                CoeffTransformer.dequantCoef8x8[g][(i << 3) + j] = CoeffTransformer.initDequantCoeff8x8[g][4];
        for (var i = 2; i < 8; i += 4) 
            for (var j = 0; j < 8; j += 4) 
                CoeffTransformer.dequantCoef8x8[g][(i << 3) + j] = CoeffTransformer.initDequantCoeff8x8[g][4];
    }
})();
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var ChannelLayout = function(code, labels) {
    this.code = code;
    this.labels = labels;
    ChannelLayout._values.add(this);
};
ChannelLayout = stjs.extend(ChannelLayout, null, [], function(constructor, prototype) {
    constructor._values = new ArrayList();
    constructor.kCAFChannelLayoutTag_UseChannelDescriptions = new ChannelLayout((0 << 16) | 0, []);
    constructor.kCAFChannelLayoutTag_UseChannelBitmap = new ChannelLayout((1 << 16) | 0, []);
    constructor.kCAFChannelLayoutTag_Mono = new ChannelLayout((100 << 16) | 1, [Label.Mono]);
    constructor.kCAFChannelLayoutTag_Stereo = new ChannelLayout((101 << 16) | 2, [Label.Left, Label.Right]);
    constructor.kCAFChannelLayoutTag_StereoHeadphones = new ChannelLayout((102 << 16) | 2, [Label.HeadphonesLeft, Label.HeadphonesRight]);
    constructor.kCAFChannelLayoutTag_MatrixStereo = new ChannelLayout((103 << 16) | 2, [Label.LeftTotal, Label.RightTotal]);
    constructor.kCAFChannelLayoutTag_MidSide = new ChannelLayout((104 << 16) | 2, [Label.MS_Mid, Label.MS_Side]);
    constructor.kCAFChannelLayoutTag_XY = new ChannelLayout((105 << 16) | 2, [Label.XY_X, Label.XY_Y]);
    constructor.kCAFChannelLayoutTag_Binaural = new ChannelLayout((106 << 16) | 2, [Label.HeadphonesLeft, Label.HeadphonesRight]);
    constructor.kCAFChannelLayoutTag_Ambisonic_B_Format = new ChannelLayout((107 << 16) | 4, [Label.Ambisonic_W, Label.Ambisonic_X, Label.Ambisonic_Y, Label.Ambisonic_Z]);
    constructor.kCAFChannelLayoutTag_Quadraphonic = new ChannelLayout((108 << 16) | 4, [Label.Left, Label.Right, Label.LeftSurround, Label.RightSurround]);
    constructor.kCAFChannelLayoutTag_Pentagonal = new ChannelLayout((109 << 16) | 5, [Label.Left, Label.Right, Label.LeftSurround, Label.RightSurround, Label.Center]);
    constructor.kCAFChannelLayoutTag_Hexagonal = new ChannelLayout((110 << 16) | 6, [Label.Left, Label.Right, Label.LeftSurround, Label.RightSurround, Label.Center, Label.CenterSurround]);
    constructor.kCAFChannelLayoutTag_Octagonal = new ChannelLayout((111 << 16) | 8, [Label.Left, Label.Right, Label.LeftSurround, Label.RightSurround, Label.Center, Label.CenterSurround, Label.LeftCenter, Label.RightCenter]);
    constructor.kCAFChannelLayoutTag_Cube = new ChannelLayout((112 << 16) | 8, [Label.Left, Label.Right, Label.LeftSurround, Label.RightSurround, Label.TopBackLeft, Label.TopBackRight, Label.TopBackCenter, Label.TopCenterSurround]);
    constructor.kCAFChannelLayoutTag_MPEG_3_0_A = new ChannelLayout((113 << 16) | 3, [Label.Left, Label.Right, Label.Center]);
    constructor.kCAFChannelLayoutTag_MPEG_3_0_B = new ChannelLayout((114 << 16) | 3, [Label.Center, Label.Left, Label.Right]);
    constructor.kCAFChannelLayoutTag_MPEG_4_0_A = new ChannelLayout((115 << 16) | 4, [Label.Left, Label.Right, Label.Center, Label.CenterSurround]);
    constructor.kCAFChannelLayoutTag_MPEG_4_0_B = new ChannelLayout((116 << 16) | 4, [Label.Center, Label.Left, Label.Right, Label.CenterSurround]);
    constructor.kCAFChannelLayoutTag_MPEG_5_0_A = new ChannelLayout((117 << 16) | 5, [Label.Left, Label.Right, Label.Center, Label.LeftSurround, Label.RightSurround]);
    constructor.kCAFChannelLayoutTag_MPEG_5_0_B = new ChannelLayout((118 << 16) | 5, [Label.Left, Label.Right, Label.LeftSurround, Label.RightSurround, Label.Center]);
    constructor.kCAFChannelLayoutTag_MPEG_5_0_C = new ChannelLayout((119 << 16) | 5, [Label.Left, Label.Center, Label.Right, Label.LeftSurround, Label.RightSurround]);
    constructor.kCAFChannelLayoutTag_MPEG_5_0_D = new ChannelLayout((120 << 16) | 5, [Label.Center, Label.Left, Label.Right, Label.LeftSurround, Label.RightSurround]);
    constructor.kCAFChannelLayoutTag_MPEG_5_1_A = new ChannelLayout((121 << 16) | 6, [Label.Left, Label.Right, Label.Center, Label.LFEScreen, Label.LeftSurround, Label.RightSurround]);
    constructor.kCAFChannelLayoutTag_MPEG_5_1_B = new ChannelLayout((122 << 16) | 6, [Label.Left, Label.Right, Label.LeftSurround, Label.RightSurround, Label.Center, Label.LFEScreen]);
    constructor.kCAFChannelLayoutTag_MPEG_5_1_C = new ChannelLayout((123 << 16) | 6, [Label.Left, Label.Center, Label.Right, Label.LeftSurround, Label.RightSurround, Label.LFEScreen]);
    constructor.kCAFChannelLayoutTag_MPEG_5_1_D = new ChannelLayout((124 << 16) | 6, [Label.Center, Label.Left, Label.Right, Label.LeftSurround, Label.RightSurround, Label.LFEScreen]);
    constructor.kCAFChannelLayoutTag_MPEG_6_1_A = new ChannelLayout((125 << 16) | 7, [Label.Left, Label.Right, Label.Center, Label.LFEScreen, Label.LeftSurround, Label.RightSurround, Label.Right]);
    constructor.kCAFChannelLayoutTag_MPEG_7_1_A = new ChannelLayout((126 << 16) | 8, [Label.Left, Label.Right, Label.Center, Label.LFEScreen, Label.LeftSurround, Label.RightSurround, Label.LeftCenter, Label.RightCenter]);
    constructor.kCAFChannelLayoutTag_MPEG_7_1_B = new ChannelLayout((127 << 16) | 8, [Label.Center, Label.LeftCenter, Label.RightCenter, Label.Left, Label.Right, Label.LeftSurround, Label.RightSurround, Label.LFEScreen]);
    constructor.kCAFChannelLayoutTag_MPEG_7_1_C = new ChannelLayout((128 << 16) | 8, [Label.Left, Label.Right, Label.Center, Label.LFEScreen, Label.LeftSurround, Label.RightSurround, Label.RearSurroundLeft, Label.RearSurroundRight]);
    constructor.kCAFChannelLayoutTag_Emagic_Default_7_1 = new ChannelLayout((129 << 16) | 8, [Label.Left, Label.Right, Label.LeftSurround, Label.RightSurround, Label.Center, Label.LFEScreen, Label.LeftCenter, Label.RightCenter]);
    constructor.kCAFChannelLayoutTag_SMPTE_DTV = new ChannelLayout((130 << 16) | 8, [Label.Left, Label.Right, Label.Center, Label.LFEScreen, Label.LeftSurround, Label.RightSurround, Label.LeftTotal, Label.RightTotal]);
    constructor.kCAFChannelLayoutTag_ITU_2_1 = new ChannelLayout((131 << 16) | 3, [Label.Left, Label.Right, Label.CenterSurround]);
    constructor.kCAFChannelLayoutTag_ITU_2_2 = new ChannelLayout((132 << 16) | 4, [Label.Left, Label.Right, Label.LeftSurround, Label.RightSurround]);
    constructor.kCAFChannelLayoutTag_DVD_4 = new ChannelLayout((133 << 16) | 3, [Label.Left, Label.Right, Label.LFEScreen]);
    constructor.kCAFChannelLayoutTag_DVD_5 = new ChannelLayout((134 << 16) | 4, [Label.Left, Label.Right, Label.LFEScreen, Label.CenterSurround]);
    constructor.kCAFChannelLayoutTag_DVD_6 = new ChannelLayout((135 << 16) | 5, [Label.Left, Label.Right, Label.LFEScreen, Label.LeftSurround, Label.RightSurround]);
    constructor.kCAFChannelLayoutTag_DVD_10 = new ChannelLayout((136 << 16) | 4, [Label.Left, Label.Right, Label.Center, Label.LFEScreen]);
    constructor.kCAFChannelLayoutTag_DVD_11 = new ChannelLayout((137 << 16) | 5, [Label.Left, Label.Right, Label.Center, Label.LFEScreen, Label.CenterSurround]);
    constructor.kCAFChannelLayoutTag_DVD_18 = new ChannelLayout((138 << 16) | 5, [Label.Left, Label.Right, Label.LeftSurround, Label.RightSurround, Label.LFEScreen]);
    constructor.kCAFChannelLayoutTag_AudioUnit_6_0 = new ChannelLayout((139 << 16) | 6, [Label.Left, Label.Right, Label.LeftSurround, Label.RightSurround, Label.Center, Label.CenterSurround]);
    constructor.kCAFChannelLayoutTag_AudioUnit_7_0 = new ChannelLayout((140 << 16) | 7, [Label.Left, Label.Right, Label.LeftSurround, Label.RightSurround, Label.Center, Label.RearSurroundLeft, Label.RearSurroundRight]);
    constructor.kCAFChannelLayoutTag_AAC_6_0 = new ChannelLayout((141 << 16) | 6, [Label.Center, Label.Left, Label.Right, Label.LeftSurround, Label.RightSurround, Label.CenterSurround]);
    constructor.kCAFChannelLayoutTag_AAC_6_1 = new ChannelLayout((142 << 16) | 7, [Label.Center, Label.Left, Label.Right, Label.LeftSurround, Label.RightSurround, Label.CenterSurround, Label.LFEScreen]);
    constructor.kCAFChannelLayoutTag_AAC_7_0 = new ChannelLayout((143 << 16) | 7, [Label.Center, Label.Left, Label.Right, Label.LeftSurround, Label.RightSurround, Label.RearSurroundLeft, Label.RearSurroundRight]);
    constructor.kCAFChannelLayoutTag_AAC_Octagonal = new ChannelLayout((144 << 16) | 8, [Label.Center, Label.Left, Label.Right, Label.LeftSurround, Label.RightSurround, Label.RearSurroundLeft, Label.RearSurroundRight, Label.CenterSurround]);
    constructor.kCAFChannelLayoutTag_TMH_10_2_std = new ChannelLayout((145 << 16) | 16, [Label.Left, Label.Right, Label.Center, Label.Mono, Label.Mono, Label.Mono, Label.LeftSurround, Label.RightSurround, Label.Mono, Label.Mono, Label.Mono, Label.Mono, Label.Mono, Label.CenterSurround, Label.LFEScreen, Label.LFE2]);
    constructor.kCAFChannelLayoutTag_TMH_10_2_full = new ChannelLayout((146 << 16) | 21, [Label.LeftCenter, Label.RightCenter, Label.Mono, Label.Mono, Label.Mono]);
    constructor.kCAFChannelLayoutTag_RESERVED_DO_NOT_USE = new ChannelLayout((147 << 16), Array(0));
    prototype.code = 0;
    prototype.labels = null;
    prototype.getCode = function() {
        return this.code;
    };
    prototype.getLabels = function() {
        return this.labels;
    };
    constructor.values = function() {
        return ChannelLayout._values.toArray(Array(0));
    };
}, {_values: {name: "List", arguments: ["ChannelLayout"]}, kCAFChannelLayoutTag_UseChannelDescriptions: "ChannelLayout", kCAFChannelLayoutTag_UseChannelBitmap: "ChannelLayout", kCAFChannelLayoutTag_Mono: "ChannelLayout", kCAFChannelLayoutTag_Stereo: "ChannelLayout", kCAFChannelLayoutTag_StereoHeadphones: "ChannelLayout", kCAFChannelLayoutTag_MatrixStereo: "ChannelLayout", kCAFChannelLayoutTag_MidSide: "ChannelLayout", kCAFChannelLayoutTag_XY: "ChannelLayout", kCAFChannelLayoutTag_Binaural: "ChannelLayout", kCAFChannelLayoutTag_Ambisonic_B_Format: "ChannelLayout", kCAFChannelLayoutTag_Quadraphonic: "ChannelLayout", kCAFChannelLayoutTag_Pentagonal: "ChannelLayout", kCAFChannelLayoutTag_Hexagonal: "ChannelLayout", kCAFChannelLayoutTag_Octagonal: "ChannelLayout", kCAFChannelLayoutTag_Cube: "ChannelLayout", kCAFChannelLayoutTag_MPEG_3_0_A: "ChannelLayout", kCAFChannelLayoutTag_MPEG_3_0_B: "ChannelLayout", kCAFChannelLayoutTag_MPEG_4_0_A: "ChannelLayout", kCAFChannelLayoutTag_MPEG_4_0_B: "ChannelLayout", kCAFChannelLayoutTag_MPEG_5_0_A: "ChannelLayout", kCAFChannelLayoutTag_MPEG_5_0_B: "ChannelLayout", kCAFChannelLayoutTag_MPEG_5_0_C: "ChannelLayout", kCAFChannelLayoutTag_MPEG_5_0_D: "ChannelLayout", kCAFChannelLayoutTag_MPEG_5_1_A: "ChannelLayout", kCAFChannelLayoutTag_MPEG_5_1_B: "ChannelLayout", kCAFChannelLayoutTag_MPEG_5_1_C: "ChannelLayout", kCAFChannelLayoutTag_MPEG_5_1_D: "ChannelLayout", kCAFChannelLayoutTag_MPEG_6_1_A: "ChannelLayout", kCAFChannelLayoutTag_MPEG_7_1_A: "ChannelLayout", kCAFChannelLayoutTag_MPEG_7_1_B: "ChannelLayout", kCAFChannelLayoutTag_MPEG_7_1_C: "ChannelLayout", kCAFChannelLayoutTag_Emagic_Default_7_1: "ChannelLayout", kCAFChannelLayoutTag_SMPTE_DTV: "ChannelLayout", kCAFChannelLayoutTag_ITU_2_1: "ChannelLayout", kCAFChannelLayoutTag_ITU_2_2: "ChannelLayout", kCAFChannelLayoutTag_DVD_4: "ChannelLayout", kCAFChannelLayoutTag_DVD_5: "ChannelLayout", kCAFChannelLayoutTag_DVD_6: "ChannelLayout", kCAFChannelLayoutTag_DVD_10: "ChannelLayout", kCAFChannelLayoutTag_DVD_11: "ChannelLayout", kCAFChannelLayoutTag_DVD_18: "ChannelLayout", kCAFChannelLayoutTag_AudioUnit_6_0: "ChannelLayout", kCAFChannelLayoutTag_AudioUnit_7_0: "ChannelLayout", kCAFChannelLayoutTag_AAC_6_0: "ChannelLayout", kCAFChannelLayoutTag_AAC_6_1: "ChannelLayout", kCAFChannelLayoutTag_AAC_7_0: "ChannelLayout", kCAFChannelLayoutTag_AAC_Octagonal: "ChannelLayout", kCAFChannelLayoutTag_TMH_10_2_std: "ChannelLayout", kCAFChannelLayoutTag_TMH_10_2_full: "ChannelLayout", kCAFChannelLayoutTag_RESERVED_DO_NOT_USE: "ChannelLayout", labels: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var AutoFileChannelWrapper = function(file) {
    this.file = file;
    this.curTime = System.currentTimeMillis();
    AutoPool.getInstance().add(this);
    this.ensureOpen();
};
AutoFileChannelWrapper = stjs.extend(AutoFileChannelWrapper, null, [SeekableByteChannel, AutoResource], function(constructor, prototype) {
    constructor.THRESHOLD = 5000;
    prototype.ch = null;
    prototype.file = null;
    prototype.savedPos = 0;
    prototype.curTime = 0;
    prototype.accessTime = 0;
    prototype.ensureOpen = function() {
        this.accessTime = this.curTime;
        if (this.ch == null || !this.ch.isOpen()) {
            this.ch = new FileInputStream(this.file).getChannel();
            this.ch.position(this.savedPos);
        }
    };
    prototype.read = function(arg0) {
        this.ensureOpen();
        var r = this.ch.read(arg0);
        this.savedPos = this.ch.position();
        return r;
    };
    prototype.close = function() {
        if (this.ch != null && this.ch.isOpen()) {
            this.savedPos = this.ch.position();
            this.ch.close();
            this.ch = null;
        }
    };
    prototype.isOpen = function() {
        return this.ch != null && this.ch.isOpen();
    };
    prototype.write = function(arg0) {
        this.ensureOpen();
        var w = this.ch.write(arg0);
        this.savedPos = this.ch.position();
        return w;
    };
    prototype.position = function() {
        this.ensureOpen();
        return this.ch.position();
    };
    prototype.setPosition = function(newPosition) {
        this.ensureOpen();
        this.ch.position(newPosition);
        this.savedPos = newPosition;
        return this;
    };
    prototype.size = function() {
        this.ensureOpen();
        return this.ch.size();
    };
    prototype.truncate = function(size) {
        this.ensureOpen();
        this.ch.truncate(size);
        this.savedPos = this.ch.position();
        return this;
    };
    prototype.setCurTime = function(curTime) {
        this.curTime = curTime;
        if (this.ch != null && this.ch.isOpen() && curTime - this.accessTime > AutoFileChannelWrapper.THRESHOLD) {
            try {
                this.close();
            }catch (e) {
                 throw new RuntimeException(e);
            }
        }
    };
}, {ch: "FileChannel", file: "File"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A seekable byte channel wrappter
 *  
 *  @author The JCodec project
 *  
 */
var SeekableByteChannelWrapper = function(src) {
    this.src = src;
};
SeekableByteChannelWrapper = stjs.extend(SeekableByteChannelWrapper, null, [SeekableByteChannel], function(constructor, prototype) {
    prototype.src = null;
    prototype.read = function(dst) {
        return this.src.read(dst);
    };
    prototype.isOpen = function() {
        return this.src.isOpen();
    };
    prototype.close = function() {
        this.src.close();
    };
    prototype.write = function(buf) {
        return this.src.write(buf);
    };
    prototype.position = function() {
        return this.src.position();
    };
    prototype.setPosition = function(newPosition) {
        this.src.setPosition(newPosition);
        return this;
    };
    prototype.size = function() {
        return this.src.size();
    };
    prototype.truncate = function(size) {
        this.src.truncate(size);
        return this;
    };
}, {src: "SeekableByteChannel"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var FileChannelWrapper = function(ch) {
    this.ch = ch;
};
FileChannelWrapper = stjs.extend(FileChannelWrapper, null, [SeekableByteChannel], function(constructor, prototype) {
    prototype.ch = null;
    prototype.read = function(arg0) {
        return this.ch.read(arg0);
    };
    prototype.close = function() {
        this.ch.close();
    };
    prototype.isOpen = function() {
        return this.ch.isOpen();
    };
    prototype.write = function(arg0) {
        return this.ch.write(arg0);
    };
    prototype.position = function() {
        return this.ch.position();
    };
    prototype.setPosition = function(newPosition) {
        this.ch.position(newPosition);
        return this;
    };
    prototype.size = function() {
        return this.ch.size();
    };
    prototype.truncate = function(size) {
        this.ch.truncate(size);
        return this;
    };
}, {ch: "FileChannel"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed under FreeBSD License
 *  
 *  EBML IO implementation
 *  
 *  @author The JCodec project
 *  
 */
var EbmlBase = function(id) {
    this.id = id;
};
EbmlBase = stjs.extend(EbmlBase, null, [], function(constructor, prototype) {
    prototype.parent = null;
    prototype.type = null;
    prototype.id = null;
    prototype.dataLen = 0;
    prototype.offset = 0;
    prototype.dataOffset = 0;
    prototype.typeSizeLength = 0;
    prototype.equalId = function(typeId) {
        return Platform.arrayEqualsByte(this.id, typeId);
    };
    prototype.getData = function() {};
    prototype.size = function() {
        return this.dataLen + EbmlUtil.ebmlLength(this.dataLen) + this.id.length;
    };
    prototype.mux = function(os) {
        var bb = this.getData();
        return os.write(bb);
    };
}, {parent: "EbmlMaster", type: "MKVType", id: "Int8Array"}, {});
var JCodecUtil2 = function() {};
JCodecUtil2 = stjs.extend(JCodecUtil2, null, [], function(constructor, prototype) {
    constructor.writeBER32 = function(buffer, value) {
        buffer.put((((value >> 21) | 128) << 24 >> 24));
        buffer.put((((value >> 14) | 128) << 24 >> 24));
        buffer.put((((value >> 7) | 128) << 24 >> 24));
        buffer.put(((value & 127) << 24 >> 24));
    };
    constructor.readBER32 = function(input) {
        var size = 0;
        for (var i = 0; i < 4; i++) {
            var b = input.get();
            size = (size << 7) | (b & 127);
            if (((b & 255) >> 7) == 0) 
                break;
        }
        return size;
    };
    constructor.writeBER32Var = function(bb, value) {
        for (var i = 0, bits = MathUtil.log2(value); i < 4 && bits > 0; i++) {
            bits -= 7;
            var out = value >> bits;
            if (bits > 0) 
                out |= 128;
            bb.put((out << 24 >> 24));
        }
    };
    constructor.asciiString = function(fourcc) {
        return Platform.getBytes(fourcc);
    };
    constructor.getAsIntArray = function(yuv, size) {
        var b = new Int8Array(size);
        var result = new Int32Array(size);
        yuv.getBuf(b);
        for (var i = 0; i < b.length; i++) {
            result[i] = b[i] & 255;
        }
        return result;
    };
    constructor.removeExtension = function(name) {
        if (name == null) 
            return null;
        return name.replaceAll("\\.[^\\.]+$", "");
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var StringReader = function() {};
StringReader = stjs.extend(StringReader, null, [], function(constructor, prototype) {
    constructor.readString = function(input, len) {
        var bs = StringReader._sureRead(input, len);
        return bs == null ? null : Platform.stringFromBytes(bs);
    };
    constructor._sureRead = function(input, len) {
        var res = new Int8Array(len);
        if (StringReader.sureRead(input, res, res.length) == len) 
            return res;
        return null;
    };
    constructor.sureRead = function(input, buf, len) {
        var read = 0;
         while (read < len){
            var tmp = input.read(buf, read, len - read);
            if (tmp == -1) 
                break;
            read += tmp;
        }
        return read;
    };
    constructor.sureSkip = function(is, l) {
         while (l > 0)
            l -= is.skip(l);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  FLV metadata
 *  
 *  @author Stan Vitvitskyy
 *  
 */
var FLVMetadata = function(md) {
    var declaredFields = Platform.getDeclaredFields(this.getClass());
    for (var i = 0; i < declaredFields.length; i++) {
        var field = declaredFields[i];
        var object = md.get(field.getName());
        try {
            if (stjs.isInstanceOf(object.constructor, Double)) {
                field.setDouble(this, object);
            } else if (stjs.isInstanceOf(object.constructor, Boolean)) {
                field.setBoolean(this, object);
            } else {
                field.set(this, object);
            }
        }catch (e) {}
    }
};
FLVMetadata = stjs.extend(FLVMetadata, null, [], function(constructor, prototype) {
    prototype.duration = 0.0;
    prototype.width = 0.0;
    prototype.height = 0.0;
    prototype.framerate = 0.0;
    prototype.audiocodecid = null;
    prototype.videokeyframe_frequency = 0.0;
    prototype.videodevice = null;
    prototype.avclevel = 0.0;
    prototype.audiosamplerate = 0.0;
    prototype.audiochannels = 0.0;
    prototype.presetname = null;
    prototype.videodatarate = 0.0;
    prototype.audioinputvolume = 0.0;
    prototype.creationdate = null;
    prototype.videocodecid = null;
    prototype.avcprofile = 0.0;
    prototype.audiodevice = null;
    prototype.audiodatarate = 0.0;
    prototype.getDuration = function() {
        return this.duration;
    };
    prototype.getWidth = function() {
        return this.width;
    };
    prototype.getHeight = function() {
        return this.height;
    };
    prototype.getFramerate = function() {
        return this.framerate;
    };
    prototype.getAudiocodecid = function() {
        return this.audiocodecid;
    };
    prototype.getVideokeyframe_frequency = function() {
        return this.videokeyframe_frequency;
    };
    prototype.getVideodevice = function() {
        return this.videodevice;
    };
    prototype.getAvclevel = function() {
        return this.avclevel;
    };
    prototype.getAudiosamplerate = function() {
        return this.audiosamplerate;
    };
    prototype.getAudiochannels = function() {
        return this.audiochannels;
    };
    prototype.getPresetname = function() {
        return this.presetname;
    };
    prototype.getVideodatarate = function() {
        return this.videodatarate;
    };
    prototype.getAudioinputvolume = function() {
        return this.audioinputvolume;
    };
    prototype.getCreationdate = function() {
        return this.creationdate;
    };
    prototype.getVideocodecid = function() {
        return this.videocodecid;
    };
    prototype.getAvcprofile = function() {
        return this.avcprofile;
    };
    prototype.getAudiodevice = function() {
        return this.audiodevice;
    };
    prototype.getAudiodatarate = function() {
        return this.audiodatarate;
    };
}, {creationdate: "jsutil.Date"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var FilterSocket = function() {};
FilterSocket = stjs.extend(FilterSocket, null, [], function(constructor, prototype) {
    prototype.buffers = null;
    prototype.positions = null;
    prototype.delays = null;
    prototype.filters = null;
    prototype.totalInputs = 0;
    prototype.totalOutputs = 0;
    constructor.createFilterSocket = function(_arguments) {
        var fs = new FilterSocket();
        fs.totalInputs = 0;
        fs.totalOutputs = 0;
        for (var i = 0; i < arguments.length; i++) {
            fs.totalInputs += arguments[i].getNInputs();
            fs.totalOutputs += arguments[i].getNOutputs();
        }
        fs.buffers = Array(fs.totalInputs);
        fs.positions = Array(fs.totalInputs);
        fs.delays = new Int32Array(fs.totalInputs);
        for (var i = 0, b = 0; i < arguments.length; i++) {
            for (var j = 0; j < arguments[i].getNInputs(); j++ , b++) {
                fs.delays[b] = arguments[i].getDelay();
            }
        }
        fs.filters = arguments;
        return fs;
    };
    prototype.allocateBuffers = function(bufferSize) {
        for (var i = 0; i < this.totalInputs; i++) {
            this.buffers[i] = FloatBuffer.allocate(bufferSize + this.delays[i] * 2);
            this.buffers[i].position(this.delays[i]);
        }
    };
    constructor.createFilterSocket2 = function(filter, buffers, positions) {
        var fs = new FilterSocket();
        fs.filters = [filter];
        fs.buffers = buffers;
        fs.positions = positions;
        fs.delays = new Int32Array([filter.getDelay()]);
        fs.totalInputs = filter.getNInputs();
        fs.totalOutputs = filter.getNOutputs();
        return fs;
    };
    prototype.filter = function(outputs) {
        if (outputs.length != this.totalOutputs) 
             throw new IllegalArgumentException("Can not output to provided filter socket inputs != outputs (" + outputs.length + "!=" + this.totalOutputs + ")");
        for (var i = 0, ii = 0, oi = 0; i < this.filters.length; ii += this.filters[i].getNInputs() , oi += this.filters[i].getNOutputs() , i++) {
            this.filters[i].filter(Platform.copyOfRangeO(this.buffers, ii, this.filters[i].getNInputs() + ii), Platform.copyOfRangeL(this.positions, ii, this.filters[i].getNInputs() + ii), Platform.copyOfRangeO(outputs, oi, this.filters[i].getNOutputs() + oi));
        }
    };
    prototype.getBuffers = function() {
        return this.buffers;
    };
    prototype.rotate = function() {
        for (var i = 0; i < this.buffers.length; i++) {
            this.positions[i] += this.buffers[i].position();
            Audio.rotate(this.buffers[i]);
        }
    };
    prototype.setBuffers = function(ins, pos) {
        if (ins.length != this.totalInputs) 
             throw new IllegalArgumentException("Number of input buffers provided is less then the number of filter inputs.");
        if (pos.length != this.totalInputs) 
             throw new IllegalArgumentException("Number of input buffer positions provided is less then the number of filter inputs.");
        this.buffers = ins;
        this.positions = pos;
    };
    prototype.getTotalInputs = function() {
        return this.totalInputs;
    };
    prototype.getTotalOutputs = function() {
        return this.totalOutputs;
    };
    prototype.getFilters = function() {
        return this.filters;
    };
    prototype.getPositions = function() {
        return this.positions;
    };
}, {buffers: "Array", positions: "Array", delays: "Int32Array", filters: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MainUtils = function() {};
MainUtils = stjs.extend(MainUtils, null, [], function(constructor, prototype) {
    constructor.JCODEC_LOG_SINK_COLOR = "jcodec.colorPrint";
    constructor.isColorSupported = System.console() != null || Boolean.parseBoolean(System.getProperty(MainUtils.JCODEC_LOG_SINK_COLOR));
    constructor.Cmd = function(flags, args, argFlags) {
        this.flags = flags;
        this.args = args;
        this.argFlags = argFlags;
    };
    constructor.Cmd = stjs.extend(constructor.Cmd, null, [], function(constructor, prototype) {
        prototype.flags = null;
        prototype.args = null;
        prototype.argFlags = null;
        prototype.getLongFlagInternal = function(flags, flagName, defaultValue) {
            return flags.containsKey(flagName) ? new Long(flags.get(flagName)) : defaultValue;
        };
        prototype.getIntegerFlagInternal = function(flags, flagName, defaultValue) {
            return flags.containsKey(flagName) ? new Integer(flags.get(flagName)) : defaultValue;
        };
        prototype.getBooleanFlagInternal = function(flags, flagName, defaultValue) {
            return flags.containsKey(flagName) ? !"false".equalsIgnoreCase(flags.get(flagName)) : defaultValue;
        };
        prototype.getDoubleFlagInternal = function(flags, flagName, defaultValue) {
            return flags.containsKey(flagName) ? new Double(flags.get(flagName)) : defaultValue;
        };
        prototype.getStringFlagInternal = function(flags, flagName, defaultValue) {
            return flags.containsKey(flagName) ? flags.get(flagName) : defaultValue;
        };
        prototype.getMultiIntegerFlagInternal = function(flags, flagName, defaultValue) {
            if (!flags.containsKey(flagName)) 
                return defaultValue;
            var split = StringUtils.splitS(flags.get(flagName), ",");
            var result = new Int32Array(split.length);
            for (var i = 0; i < split.length; i++) 
                result[i] = Integer.parseInt(split[i]);
            return result;
        };
        prototype.getEnumFlagInternal = function(flags, flagName, defaultValue, class1) {
            if (!flags.containsKey(flagName)) 
                return defaultValue;
            var strVal = flags.get(flagName).toLowerCase();
            var allOf = EnumSet.allOf(class1);
            for (var iterator$val = allOf.iterator(); iterator$val.hasNext(); ) {
                var val = iterator$val.next();
                if (val.name().toLowerCase().equals(strVal)) 
                    return val;
            }
            return null;
        };
        prototype.getLongFlagD = function(flagName, defaultValue) {
            return this.getLongFlagInternal(this.flags, flagName, defaultValue);
        };
        prototype.getLongFlag = function(flagName) {
            return this.getLongFlagInternal(this.flags, flagName, null);
        };
        prototype.getLongFlagID = function(arg, flagName, defaultValue) {
            return this.getLongFlagInternal(this.argFlags[arg], flagName, defaultValue);
        };
        prototype.getLongFlagI = function(arg, flagName) {
            return this.getLongFlagInternal(this.argFlags[arg], flagName, null);
        };
        prototype.getIntegerFlagD = function(flagName, defaultValue) {
            return this.getIntegerFlagInternal(this.flags, flagName, defaultValue);
        };
        prototype.getIntegerFlag = function(flagName) {
            return this.getIntegerFlagInternal(this.flags, flagName, null);
        };
        prototype.getIntegerFlagID = function(arg, flagName, defaultValue) {
            return this.getIntegerFlagInternal(this.argFlags[arg], flagName, defaultValue);
        };
        prototype.getIntegerFlagI = function(arg, flagName) {
            return this.getIntegerFlagInternal(this.argFlags[arg], flagName, null);
        };
        prototype.getBooleanFlagD = function(flagName, defaultValue) {
            return this.getBooleanFlagInternal(this.flags, flagName, defaultValue);
        };
        prototype.getBooleanFlag = function(flagName) {
            return this.getBooleanFlagInternal(this.flags, flagName, null);
        };
        prototype.getBooleanFlagID = function(arg, flagName, defaultValue) {
            return this.getBooleanFlagInternal(this.argFlags[arg], flagName, defaultValue);
        };
        prototype.getBooleanFlagI = function(arg, flagName) {
            return this.getBooleanFlagInternal(this.argFlags[arg], flagName, null);
        };
        prototype.getDoubleFlagD = function(flagName, defaultValue) {
            return this.getDoubleFlagInternal(this.flags, flagName, defaultValue);
        };
        prototype.getDoubleFlag = function(flagName) {
            return this.getDoubleFlagInternal(this.flags, flagName, null);
        };
        prototype.getDoubleFlagID = function(arg, flagName, defaultValue) {
            return this.getDoubleFlagInternal(this.argFlags[arg], flagName, defaultValue);
        };
        prototype.getDoubleFlagI = function(arg, flagName) {
            return this.getDoubleFlagInternal(this.argFlags[arg], flagName, null);
        };
        prototype.getStringFlagD = function(flagName, defaultValue) {
            return this.getStringFlagInternal(this.flags, flagName, defaultValue);
        };
        prototype.getStringFlag = function(flagName) {
            return this.getStringFlagInternal(this.flags, flagName, null);
        };
        prototype.getStringFlagID = function(arg, flagName, defaultValue) {
            return this.getStringFlagInternal(this.argFlags[arg], flagName, defaultValue);
        };
        prototype.getStringFlagI = function(arg, flagName) {
            return this.getStringFlagInternal(this.argFlags[arg], flagName, null);
        };
        prototype.getMultiIntegerFlagD = function(flagName, defaultValue) {
            return this.getMultiIntegerFlagInternal(this.flags, flagName, defaultValue);
        };
        prototype.getMultiIntegerFlag = function(flagName) {
            return this.getMultiIntegerFlagInternal(this.flags, flagName, new Int32Array(0));
        };
        prototype.getMultiIntegerFlagID = function(arg, flagName, defaultValue) {
            return this.getMultiIntegerFlagInternal(this.argFlags[arg], flagName, defaultValue);
        };
        prototype.getMultiIntegerFlagI = function(arg, flagName) {
            return this.getMultiIntegerFlagInternal(this.argFlags[arg], flagName, new Int32Array(0));
        };
        prototype.getEnumFlagD = function(flagName, defaultValue, class1) {
            return this.getEnumFlagInternal(this.flags, flagName, defaultValue, class1);
        };
        prototype.getEnumFlag = function(flagName, class1) {
            return this.getEnumFlagInternal(this.flags, flagName, null, class1);
        };
        prototype.getEnumFlagID = function(arg, flagName, defaultValue, class1) {
            return this.getEnumFlagInternal(this.argFlags[arg], flagName, defaultValue, class1);
        };
        prototype.getEnumFlagI = function(arg, flagName, class1) {
            return this.getEnumFlagInternal(this.argFlags[arg], flagName, null, class1);
        };
        prototype.getArg = function(i) {
            return i < this.args.length ? this.args[i] : null;
        };
        prototype.argsLength = function() {
            return this.args.length;
        };
        prototype.popArg = function() {
            this.args = Platform.copyOfRangeO(this.args, 1, this.args.length);
        };
    }, {flags: {name: "Map", arguments: [null, null]}, args: "Array", argFlags: "Array"}, {});
    constructor.flagPattern = Pattern.compile("^--([^=]+)=(.*)$");
    constructor.parseArguments = function(args) {
        var flags = new HashMap();
        var allFlags = new HashMap();
        var outArgs = new ArrayList();
        var argFlags = new ArrayList();
        var arg = 0;
        for (; arg < args.length; arg++) {
            if (args[arg].startsWith("--")) {
                var matcher = MainUtils.flagPattern.matcher(args[arg]);
                if (matcher.matches()) {
                    flags.put(matcher.group(1), matcher.group(2));
                } else {
                    flags.put(args[arg].substring(2), "true");
                }
            } else if (args[arg].startsWith("-")) {
                flags.put(args[arg].substring(1), args[++arg]);
            } else {
                allFlags.putAll(flags);
                outArgs.add(args[arg]);
                argFlags.add(flags);
            }
        }
        return new MainUtils.Cmd(allFlags, outArgs.toArray(Array(0)), argFlags.toArray(jslang.reflect.Array.newInstance(flags.getClass(), 0)));
    };
    constructor.printHelpVarArgs = function(flags, _arguments) {
        MainUtils.printHelpOut(System.out, "", flags, Arrays.asList(arguments));
    };
    constructor.printHelp = function(flags, params) {
        MainUtils.printHelpOut(System.out, "", flags, params);
    };
    constructor.printHelpNoFlags = function(_arguments) {
        MainUtils.printHelpOut(System.out, "", new HashMap(), Arrays.asList(arguments));
    };
    constructor.printHelpCmd = function(command, flags, params) {
        MainUtils.printHelpOut(System.out, command, flags, params);
    };
    constructor.printHelpOut = function(out, command, flags, params) {
        out.print(MainUtils.bold("Syntax: " + command));
        var sample = new StringBuilder();
        var detail = new StringBuilder();
        for (var iterator$entry = flags.entrySet().iterator(); iterator$entry.hasNext(); ) {
            var entry = iterator$entry.next();
            sample.append(" [" + MainUtils.bold(MainUtils.color("--" + entry.getKey() + "=<value>", MainUtils.ANSIColor.MAGENTA)) + "]");
            detail.append("\t" + MainUtils.bold(MainUtils.color("--" + entry.getKey(), MainUtils.ANSIColor.MAGENTA)) + "\t\t" + entry.getValue() + "\n");
        }
        for (var iterator$param = params.iterator(); iterator$param.hasNext(); ) {
            var param = iterator$param.next();
            if (param.charAt(0) != '?') 
                sample.append(MainUtils.bold(" <" + param + ">"));
             else 
                sample.append(MainUtils.bold(" [" + param.substring(1) + "]"));
        }
        out.println(sample);
        out.println(MainUtils.bold("Where:"));
        out.println(detail);
    };
    constructor.ANSIColor = stjs.enumeration("BLACK", "RED", "GREEN", "BROWN", "BLUE", "MAGENTA", "CYAN", "GREY");
    constructor.bold = function(str) {
        return MainUtils.isColorSupported ? "\x1b[1m" + str + "\x1b[0m" : str;
    };
    constructor.colorString = function(str, placeholder) {
        return MainUtils.isColorSupported ? "\x1b[" + placeholder + "m" + str + "\x1b[0m" : str;
    };
    constructor.color = function(str, fg) {
        return MainUtils.isColorSupported ? "\x1b[" + (30 + (fg.ordinal() & 7)) + "m" + str + "\x1b[0m" : str;
    };
    constructor.colorBright = function(str, fg, bright) {
        return MainUtils.isColorSupported ? "\x1b[" + (30 + (fg.ordinal() & 7)) + ";" + (bright ? 1 : 2) + "m" + str + "\x1b[0m" : str;
    };
    constructor.color3 = function(str, fg, bg) {
        return MainUtils.isColorSupported ? "\x1b[" + (30 + (fg.ordinal() & 7)) + ";" + (40 + (bg.ordinal() & 7)) + ";1m" + str + "\x1b[0m" : str;
    };
    constructor.color4 = function(str, fg, bg, bright) {
        return MainUtils.isColorSupported ? "\x1b[" + (30 + (fg.ordinal() & 7)) + ";" + (40 + (bg.ordinal() & 7)) + ";" + (bright ? 1 : 2) + "m" + str + "\x1b[0m" : str;
    };
    constructor.tildeExpand = function(path) {
        if (path.startsWith("~")) {
            path = path.replaceFirst("~", System.getProperty("user.home"));
        }
        return new File(path);
    };
}, {flagPattern: "Pattern"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Builds intra prediction for intra 8x8 coded macroblocks
 *  
 *  @author The JCodec project
 *  
 */
var Intra8x8PredictionBuilder = function() {
    this.topBuf = new Int8Array(16);
    this.leftBuf = new Int8Array(8);
    this.genBuf = new Int8Array(24);
};
Intra8x8PredictionBuilder = stjs.extend(Intra8x8PredictionBuilder, null, [], function(constructor, prototype) {
    prototype.topBuf = null;
    prototype.leftBuf = null;
    prototype.genBuf = null;
    prototype.predictWithMode = function(mode, residual, leftAvailable, topAvailable, topLeftAvailable, topRightAvailable, leftRow, topLine, topLeft, mbOffX, blkX, blkY, pixOut) {
        switch (mode) {
            case 0:
                Assert.assertTrue(topAvailable);
                this.predictVertical(residual, topLeftAvailable, topRightAvailable, topLeft, topLine, mbOffX, blkX, blkY, pixOut);
                break;
            case 1:
                Assert.assertTrue(leftAvailable);
                this.predictHorizontal(residual, topLeftAvailable, topLeft, leftRow, mbOffX, blkX, blkY, pixOut);
                break;
            case 2:
                this.predictDC(residual, topLeftAvailable, topRightAvailable, leftAvailable, topAvailable, topLeft, leftRow, topLine, mbOffX, blkX, blkY, pixOut);
                break;
            case 3:
                Assert.assertTrue(topAvailable);
                this.predictDiagonalDownLeft(residual, topLeftAvailable, topAvailable, topRightAvailable, topLeft, topLine, mbOffX, blkX, blkY, pixOut);
                break;
            case 4:
                Assert.assertTrue(topAvailable && leftAvailable && topLeftAvailable);
                this.predictDiagonalDownRight(residual, topRightAvailable, topLeft, leftRow, topLine, mbOffX, blkX, blkY, pixOut);
                break;
            case 5:
                Assert.assertTrue(topAvailable && leftAvailable && topLeftAvailable);
                this.predictVerticalRight(residual, topRightAvailable, topLeft, leftRow, topLine, mbOffX, blkX, blkY, pixOut);
                break;
            case 6:
                Assert.assertTrue(topAvailable && leftAvailable && topLeftAvailable);
                this.predictHorizontalDown(residual, topRightAvailable, topLeft, leftRow, topLine, mbOffX, blkX, blkY, pixOut);
                break;
            case 7:
                Assert.assertTrue(topAvailable);
                this.predictVerticalLeft(residual, topLeftAvailable, topRightAvailable, topLeft, topLine, mbOffX, blkX, blkY, pixOut);
                break;
            case 8:
                Assert.assertTrue(leftAvailable);
                this.predictHorizontalUp(residual, topLeftAvailable, topLeft, leftRow, mbOffX, blkX, blkY, pixOut);
                break;
        }
        var oo1 = mbOffX + blkX;
        var off1 = (blkY << 4) + blkX + 7;
        topLeft[blkY >> 2] = topLine[oo1 + 7];
        for (var i = 0; i < 8; i++) 
            leftRow[blkY + i] = pixOut[off1 + (i << 4)];
        var off2 = (blkY << 4) + blkX + 112;
        for (var i = 0; i < 8; i++) 
            topLine[oo1 + i] = pixOut[off2 + i];
        topLeft[(blkY >> 2) + 1] = leftRow[blkY + 3];
    };
    prototype.interpolateTop = function(topLeftAvailable, topRightAvailable, topLeft, topLine, blkX, blkY, out) {
        var a = topLeftAvailable ? topLeft[blkY >> 2] : topLine[blkX];
        out[0] = (((a + (topLine[blkX] << 1) + topLine[blkX + 1] + 2) >> 2) << 24 >> 24);
        var i;
        for (i = 1; i < 7; i++) 
            out[i] = (((topLine[blkX + i - 1] + (topLine[blkX + i] << 1) + topLine[blkX + i + 1] + 2) >> 2) << 24 >> 24);
        if (topRightAvailable) {
            for (; i < 15; i++) 
                out[i] = (((topLine[blkX + i - 1] + (topLine[blkX + i] << 1) + topLine[blkX + i + 1] + 2) >> 2) << 24 >> 24);
            out[15] = (((topLine[blkX + 14] + (topLine[blkX + 15] << 1) + topLine[blkX + 15] + 2) >> 2) << 24 >> 24);
        } else {
            out[7] = (((topLine[blkX + 6] + (topLine[blkX + 7] << 1) + topLine[blkX + 7] + 2) >> 2) << 24 >> 24);
            for (i = 8; i < 16; i++) 
                out[i] = topLine[blkX + 7];
        }
    };
    prototype.interpolateLeft = function(topLeftAvailable, topLeft, leftRow, blkY, out) {
        var a = topLeftAvailable ? topLeft[blkY >> 2] : leftRow[0];
        out[0] = (((a + (leftRow[blkY] << 1) + leftRow[blkY + 1] + 2) >> 2) << 24 >> 24);
        for (var i = 1; i < 7; i++) 
            out[i] = (((leftRow[blkY + i - 1] + (leftRow[blkY + i] << 1) + leftRow[blkY + i + 1] + 2) >> 2) << 24 >> 24);
        out[7] = (((leftRow[blkY + 6] + (leftRow[blkY + 7] << 1) + leftRow[blkY + 7] + 2) >> 2) << 24 >> 24);
    };
    prototype.interpolateTopLeft = function(topAvailable, leftAvailable, topLeft, topLine, leftRow, mbOffX, blkX, blkY) {
        var a = topLeft[blkY >> 2];
        var b = topAvailable ? topLine[mbOffX + blkX] : a;
        var c = leftAvailable ? leftRow[blkY] : a;
        var aa = a << 1;
        return (aa + b + c + 2) >> 2;
    };
    prototype.copyAdd = function(pred, srcOff, residual, pixOff, rOff, out) {
        out[pixOff] = (MathUtil.clip(residual[rOff] + pred[srcOff], -128, 127) << 24 >> 24);
        out[pixOff + 1] = (MathUtil.clip(residual[rOff + 1] + pred[srcOff + 1], -128, 127) << 24 >> 24);
        out[pixOff + 2] = (MathUtil.clip(residual[rOff + 2] + pred[srcOff + 2], -128, 127) << 24 >> 24);
        out[pixOff + 3] = (MathUtil.clip(residual[rOff + 3] + pred[srcOff + 3], -128, 127) << 24 >> 24);
        out[pixOff + 4] = (MathUtil.clip(residual[rOff + 4] + pred[srcOff + 4], -128, 127) << 24 >> 24);
        out[pixOff + 5] = (MathUtil.clip(residual[rOff + 5] + pred[srcOff + 5], -128, 127) << 24 >> 24);
        out[pixOff + 6] = (MathUtil.clip(residual[rOff + 6] + pred[srcOff + 6], -128, 127) << 24 >> 24);
        out[pixOff + 7] = (MathUtil.clip(residual[rOff + 7] + pred[srcOff + 7], -128, 127) << 24 >> 24);
    };
    prototype.fillAdd = function(residual, pixOff, val, pixOut) {
        var rOff = 0;
        for (var i = 0; i < 8; i++) {
            pixOut[pixOff] = (MathUtil.clip(residual[rOff] + val, -128, 127) << 24 >> 24);
            pixOut[pixOff + 1] = (MathUtil.clip(residual[rOff + 1] + val, -128, 127) << 24 >> 24);
            pixOut[pixOff + 2] = (MathUtil.clip(residual[rOff + 2] + val, -128, 127) << 24 >> 24);
            pixOut[pixOff + 3] = (MathUtil.clip(residual[rOff + 3] + val, -128, 127) << 24 >> 24);
            pixOut[pixOff + 4] = (MathUtil.clip(residual[rOff + 4] + val, -128, 127) << 24 >> 24);
            pixOut[pixOff + 5] = (MathUtil.clip(residual[rOff + 5] + val, -128, 127) << 24 >> 24);
            pixOut[pixOff + 6] = (MathUtil.clip(residual[rOff + 6] + val, -128, 127) << 24 >> 24);
            pixOut[pixOff + 7] = (MathUtil.clip(residual[rOff + 7] + val, -128, 127) << 24 >> 24);
            pixOff += 16;
            rOff += 8;
        }
    };
    prototype.predictVertical = function(residual, topLeftAvailable, topRightAvailable, topLeft, topLine, mbOffX, blkX, blkY, pixOut) {
        this.interpolateTop(topLeftAvailable, topRightAvailable, topLeft, topLine, mbOffX + blkX, blkY, this.topBuf);
        var pixOff = (blkY << 4) + blkX;
        var rOff = 0;
        for (var i = 0; i < 8; i++) {
            pixOut[pixOff] = (MathUtil.clip(residual[rOff] + this.topBuf[0], -128, 127) << 24 >> 24);
            pixOut[pixOff + 1] = (MathUtil.clip(residual[rOff + 1] + this.topBuf[1], -128, 127) << 24 >> 24);
            pixOut[pixOff + 2] = (MathUtil.clip(residual[rOff + 2] + this.topBuf[2], -128, 127) << 24 >> 24);
            pixOut[pixOff + 3] = (MathUtil.clip(residual[rOff + 3] + this.topBuf[3], -128, 127) << 24 >> 24);
            pixOut[pixOff + 4] = (MathUtil.clip(residual[rOff + 4] + this.topBuf[4], -128, 127) << 24 >> 24);
            pixOut[pixOff + 5] = (MathUtil.clip(residual[rOff + 5] + this.topBuf[5], -128, 127) << 24 >> 24);
            pixOut[pixOff + 6] = (MathUtil.clip(residual[rOff + 6] + this.topBuf[6], -128, 127) << 24 >> 24);
            pixOut[pixOff + 7] = (MathUtil.clip(residual[rOff + 7] + this.topBuf[7], -128, 127) << 24 >> 24);
            pixOff += 16;
            rOff += 8;
        }
    };
    prototype.predictHorizontal = function(residual, topLeftAvailable, topLeft, leftRow, mbOffX, blkX, blkY, pixOut) {
        this.interpolateLeft(topLeftAvailable, topLeft, leftRow, blkY, this.leftBuf);
        var pixOff = (blkY << 4) + blkX;
        var rOff = 0;
        for (var i = 0; i < 8; i++) {
            pixOut[pixOff] = (MathUtil.clip(residual[rOff] + this.leftBuf[i], -128, 127) << 24 >> 24);
            pixOut[pixOff + 1] = (MathUtil.clip(residual[rOff + 1] + this.leftBuf[i], -128, 127) << 24 >> 24);
            pixOut[pixOff + 2] = (MathUtil.clip(residual[rOff + 2] + this.leftBuf[i], -128, 127) << 24 >> 24);
            pixOut[pixOff + 3] = (MathUtil.clip(residual[rOff + 3] + this.leftBuf[i], -128, 127) << 24 >> 24);
            pixOut[pixOff + 4] = (MathUtil.clip(residual[rOff + 4] + this.leftBuf[i], -128, 127) << 24 >> 24);
            pixOut[pixOff + 5] = (MathUtil.clip(residual[rOff + 5] + this.leftBuf[i], -128, 127) << 24 >> 24);
            pixOut[pixOff + 6] = (MathUtil.clip(residual[rOff + 6] + this.leftBuf[i], -128, 127) << 24 >> 24);
            pixOut[pixOff + 7] = (MathUtil.clip(residual[rOff + 7] + this.leftBuf[i], -128, 127) << 24 >> 24);
            pixOff += 16;
            rOff += 8;
        }
    };
    prototype.predictDC = function(residual, topLeftAvailable, topRightAvailable, leftAvailable, topAvailable, topLeft, leftRow, topLine, mbOffX, blkX, blkY, pixOut) {
        if (topAvailable && leftAvailable) {
            this.interpolateTop(topLeftAvailable, topRightAvailable, topLeft, topLine, mbOffX + blkX, blkY, this.topBuf);
            this.interpolateLeft(topLeftAvailable, topLeft, leftRow, blkY, this.leftBuf);
            var sum1 = this.topBuf[0] + this.topBuf[1] + this.topBuf[2] + this.topBuf[3];
            var sum2 = this.topBuf[4] + this.topBuf[5] + this.topBuf[6] + this.topBuf[7];
            var sum3 = this.leftBuf[0] + this.leftBuf[1] + this.leftBuf[2] + this.leftBuf[3];
            var sum4 = this.leftBuf[4] + this.leftBuf[5] + this.leftBuf[6] + this.leftBuf[7];
            this.fillAdd(residual, (blkY << 4) + blkX, (sum1 + sum2 + sum3 + sum4 + 8) >> 4, pixOut);
        } else if (leftAvailable) {
            this.interpolateLeft(topLeftAvailable, topLeft, leftRow, blkY, this.leftBuf);
            var sum3 = this.leftBuf[0] + this.leftBuf[1] + this.leftBuf[2] + this.leftBuf[3];
            var sum4 = this.leftBuf[4] + this.leftBuf[5] + this.leftBuf[6] + this.leftBuf[7];
            this.fillAdd(residual, (blkY << 4) + blkX, (sum3 + sum4 + 4) >> 3, pixOut);
        } else if (topAvailable) {
            this.interpolateTop(topLeftAvailable, topRightAvailable, topLeft, topLine, mbOffX + blkX, blkY, this.topBuf);
            var sum1 = this.topBuf[0] + this.topBuf[1] + this.topBuf[2] + this.topBuf[3];
            var sum2 = this.topBuf[4] + this.topBuf[5] + this.topBuf[6] + this.topBuf[7];
            this.fillAdd(residual, (blkY << 4) + blkX, (sum1 + sum2 + 4) >> 3, pixOut);
        } else {
            this.fillAdd(residual, (blkY << 4) + blkX, 0, pixOut);
        }
    };
    prototype.predictDiagonalDownLeft = function(residual, topLeftAvailable, topAvailable, topRightAvailable, topLeft, topLine, mbOffX, blkX, blkY, pixOut) {
        this.interpolateTop(topLeftAvailable, topRightAvailable, topLeft, topLine, mbOffX + blkX, blkY, this.topBuf);
        this.genBuf[0] = (((this.topBuf[0] + this.topBuf[2] + ((this.topBuf[1]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[1] = (((this.topBuf[1] + this.topBuf[3] + ((this.topBuf[2]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[2] = (((this.topBuf[2] + this.topBuf[4] + ((this.topBuf[3]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[3] = (((this.topBuf[3] + this.topBuf[5] + ((this.topBuf[4]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[4] = (((this.topBuf[4] + this.topBuf[6] + ((this.topBuf[5]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[5] = (((this.topBuf[5] + this.topBuf[7] + ((this.topBuf[6]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[6] = (((this.topBuf[6] + this.topBuf[8] + ((this.topBuf[7]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[7] = (((this.topBuf[7] + this.topBuf[9] + ((this.topBuf[8]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[8] = (((this.topBuf[8] + this.topBuf[10] + ((this.topBuf[9]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[9] = (((this.topBuf[9] + this.topBuf[11] + ((this.topBuf[10]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[10] = (((this.topBuf[10] + this.topBuf[12] + ((this.topBuf[11]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[11] = (((this.topBuf[11] + this.topBuf[13] + ((this.topBuf[12]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[12] = (((this.topBuf[12] + this.topBuf[14] + ((this.topBuf[13]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[13] = (((this.topBuf[13] + this.topBuf[15] + ((this.topBuf[14]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[14] = (((this.topBuf[14] + this.topBuf[15] + ((this.topBuf[15]) << 1) + 2) >> 2) << 24 >> 24);
        var off = (blkY << 4) + blkX;
        this.copyAdd(this.genBuf, 0, residual, off, 0, pixOut);
        this.copyAdd(this.genBuf, 1, residual, off + 16, 8, pixOut);
        this.copyAdd(this.genBuf, 2, residual, off + 32, 16, pixOut);
        this.copyAdd(this.genBuf, 3, residual, off + 48, 24, pixOut);
        this.copyAdd(this.genBuf, 4, residual, off + 64, 32, pixOut);
        this.copyAdd(this.genBuf, 5, residual, off + 80, 40, pixOut);
        this.copyAdd(this.genBuf, 6, residual, off + 96, 48, pixOut);
        this.copyAdd(this.genBuf, 7, residual, off + 112, 56, pixOut);
    };
    prototype.predictDiagonalDownRight = function(residual, topRightAvailable, topLeft, leftRow, topLine, mbOffX, blkX, blkY, pixOut) {
        this.interpolateTop(true, topRightAvailable, topLeft, topLine, mbOffX + blkX, blkY, this.topBuf);
        this.interpolateLeft(true, topLeft, leftRow, blkY, this.leftBuf);
        var tl = this.interpolateTopLeft(true, true, topLeft, topLine, leftRow, mbOffX, blkX, blkY);
        this.genBuf[0] = (((this.leftBuf[7] + this.leftBuf[5] + ((this.leftBuf[6]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[1] = (((this.leftBuf[6] + this.leftBuf[4] + ((this.leftBuf[5]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[2] = (((this.leftBuf[5] + this.leftBuf[3] + ((this.leftBuf[4]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[3] = (((this.leftBuf[4] + this.leftBuf[2] + ((this.leftBuf[3]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[4] = (((this.leftBuf[3] + this.leftBuf[1] + ((this.leftBuf[2]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[5] = (((this.leftBuf[2] + this.leftBuf[0] + ((this.leftBuf[1]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[6] = (((this.leftBuf[1] + tl + ((this.leftBuf[0]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[7] = (((this.leftBuf[0] + this.topBuf[0] + ((tl) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[8] = (((tl + this.topBuf[1] + ((this.topBuf[0]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[9] = (((this.topBuf[0] + this.topBuf[2] + ((this.topBuf[1]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[10] = (((this.topBuf[1] + this.topBuf[3] + ((this.topBuf[2]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[11] = (((this.topBuf[2] + this.topBuf[4] + ((this.topBuf[3]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[12] = (((this.topBuf[3] + this.topBuf[5] + ((this.topBuf[4]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[13] = (((this.topBuf[4] + this.topBuf[6] + ((this.topBuf[5]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[14] = (((this.topBuf[5] + this.topBuf[7] + ((this.topBuf[6]) << 1) + 2) >> 2) << 24 >> 24);
        var off = (blkY << 4) + blkX;
        this.copyAdd(this.genBuf, 7, residual, off, 0, pixOut);
        this.copyAdd(this.genBuf, 6, residual, off + 16, 8, pixOut);
        this.copyAdd(this.genBuf, 5, residual, off + 32, 16, pixOut);
        this.copyAdd(this.genBuf, 4, residual, off + 48, 24, pixOut);
        this.copyAdd(this.genBuf, 3, residual, off + 64, 32, pixOut);
        this.copyAdd(this.genBuf, 2, residual, off + 80, 40, pixOut);
        this.copyAdd(this.genBuf, 1, residual, off + 96, 48, pixOut);
        this.copyAdd(this.genBuf, 0, residual, off + 112, 56, pixOut);
    };
    prototype.predictVerticalRight = function(residual, topRightAvailable, topLeft, leftRow, topLine, mbOffX, blkX, blkY, pixOut) {
        this.interpolateTop(true, topRightAvailable, topLeft, topLine, mbOffX + blkX, blkY, this.topBuf);
        this.interpolateLeft(true, topLeft, leftRow, blkY, this.leftBuf);
        var tl = this.interpolateTopLeft(true, true, topLeft, topLine, leftRow, mbOffX, blkX, blkY);
        this.genBuf[0] = (((this.leftBuf[5] + this.leftBuf[3] + ((this.leftBuf[4]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[1] = (((this.leftBuf[3] + this.leftBuf[1] + ((this.leftBuf[2]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[2] = (((this.leftBuf[1] + tl + ((this.leftBuf[0]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[3] = (((tl + this.topBuf[0] + 1) >> 1) << 24 >> 24);
        this.genBuf[4] = (((this.topBuf[0] + this.topBuf[1] + 1) >> 1) << 24 >> 24);
        this.genBuf[5] = (((this.topBuf[1] + this.topBuf[2] + 1) >> 1) << 24 >> 24);
        this.genBuf[6] = (((this.topBuf[2] + this.topBuf[3] + 1) >> 1) << 24 >> 24);
        this.genBuf[7] = (((this.topBuf[3] + this.topBuf[4] + 1) >> 1) << 24 >> 24);
        this.genBuf[8] = (((this.topBuf[4] + this.topBuf[5] + 1) >> 1) << 24 >> 24);
        this.genBuf[9] = (((this.topBuf[5] + this.topBuf[6] + 1) >> 1) << 24 >> 24);
        this.genBuf[10] = (((this.topBuf[6] + this.topBuf[7] + 1) >> 1) << 24 >> 24);
        this.genBuf[11] = (((this.leftBuf[6] + this.leftBuf[4] + ((this.leftBuf[5]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[12] = (((this.leftBuf[4] + this.leftBuf[2] + ((this.leftBuf[3]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[13] = (((this.leftBuf[2] + this.leftBuf[0] + ((this.leftBuf[1]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[14] = (((this.leftBuf[0] + this.topBuf[0] + ((tl) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[15] = (((tl + this.topBuf[1] + ((this.topBuf[0]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[16] = (((this.topBuf[0] + this.topBuf[2] + ((this.topBuf[1]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[17] = (((this.topBuf[1] + this.topBuf[3] + ((this.topBuf[2]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[18] = (((this.topBuf[2] + this.topBuf[4] + ((this.topBuf[3]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[19] = (((this.topBuf[3] + this.topBuf[5] + ((this.topBuf[4]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[20] = (((this.topBuf[4] + this.topBuf[6] + ((this.topBuf[5]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[21] = (((this.topBuf[5] + this.topBuf[7] + ((this.topBuf[6]) << 1) + 2) >> 2) << 24 >> 24);
        var off = (blkY << 4) + blkX;
        this.copyAdd(this.genBuf, 3, residual, off, 0, pixOut);
        this.copyAdd(this.genBuf, 14, residual, off + 16, 8, pixOut);
        this.copyAdd(this.genBuf, 2, residual, off + 32, 16, pixOut);
        this.copyAdd(this.genBuf, 13, residual, off + 48, 24, pixOut);
        this.copyAdd(this.genBuf, 1, residual, off + 64, 32, pixOut);
        this.copyAdd(this.genBuf, 12, residual, off + 80, 40, pixOut);
        this.copyAdd(this.genBuf, 0, residual, off + 96, 48, pixOut);
        this.copyAdd(this.genBuf, 11, residual, off + 112, 56, pixOut);
    };
    prototype.predictHorizontalDown = function(residual, topRightAvailable, topLeft, leftRow, topLine, mbOffX, blkX, blkY, pixOut) {
        this.interpolateTop(true, topRightAvailable, topLeft, topLine, mbOffX + blkX, blkY, this.topBuf);
        this.interpolateLeft(true, topLeft, leftRow, blkY, this.leftBuf);
        var tl = this.interpolateTopLeft(true, true, topLeft, topLine, leftRow, mbOffX, blkX, blkY);
        this.genBuf[0] = (((this.leftBuf[7] + this.leftBuf[6] + 1) >> 1) << 24 >> 24);
        this.genBuf[1] = (((this.leftBuf[5] + this.leftBuf[7] + (this.leftBuf[6] << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[2] = (((this.leftBuf[6] + this.leftBuf[5] + 1) >> 1) << 24 >> 24);
        this.genBuf[3] = (((this.leftBuf[4] + this.leftBuf[6] + ((this.leftBuf[5]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[4] = (((this.leftBuf[5] + this.leftBuf[4] + 1) >> 1) << 24 >> 24);
        this.genBuf[5] = (((this.leftBuf[3] + this.leftBuf[5] + ((this.leftBuf[4]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[6] = (((this.leftBuf[4] + this.leftBuf[3] + 1) >> 1) << 24 >> 24);
        this.genBuf[7] = (((this.leftBuf[2] + this.leftBuf[4] + ((this.leftBuf[3]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[8] = (((this.leftBuf[3] + this.leftBuf[2] + 1) >> 1) << 24 >> 24);
        this.genBuf[9] = (((this.leftBuf[1] + this.leftBuf[3] + ((this.leftBuf[2]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[10] = (((this.leftBuf[2] + this.leftBuf[1] + 1) >> 1) << 24 >> 24);
        this.genBuf[11] = (((this.leftBuf[0] + this.leftBuf[2] + ((this.leftBuf[1]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[12] = (((this.leftBuf[1] + this.leftBuf[0] + 1) >> 1) << 24 >> 24);
        this.genBuf[13] = (((tl + this.leftBuf[1] + ((this.leftBuf[0]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[14] = (((this.leftBuf[0] + tl + 1) >> 1) << 24 >> 24);
        this.genBuf[15] = (((this.leftBuf[0] + this.topBuf[0] + ((tl) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[16] = (((tl + this.topBuf[1] + ((this.topBuf[0]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[17] = (((this.topBuf[0] + this.topBuf[2] + ((this.topBuf[1]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[18] = (((this.topBuf[1] + this.topBuf[3] + ((this.topBuf[2]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[19] = (((this.topBuf[2] + this.topBuf[4] + ((this.topBuf[3]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[20] = (((this.topBuf[3] + this.topBuf[5] + ((this.topBuf[4]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[21] = (((this.topBuf[4] + this.topBuf[6] + ((this.topBuf[5]) << 1) + 2) >> 2) << 24 >> 24);
        var off = (blkY << 4) + blkX;
        this.copyAdd(this.genBuf, 14, residual, off, 0, pixOut);
        this.copyAdd(this.genBuf, 12, residual, off + 16, 8, pixOut);
        this.copyAdd(this.genBuf, 10, residual, off + 32, 16, pixOut);
        this.copyAdd(this.genBuf, 8, residual, off + 48, 24, pixOut);
        this.copyAdd(this.genBuf, 6, residual, off + 64, 32, pixOut);
        this.copyAdd(this.genBuf, 4, residual, off + 80, 40, pixOut);
        this.copyAdd(this.genBuf, 2, residual, off + 96, 48, pixOut);
        this.copyAdd(this.genBuf, 0, residual, off + 112, 56, pixOut);
    };
    prototype.predictVerticalLeft = function(residual, topLeftAvailable, topRightAvailable, topLeft, topLine, mbOffX, blkX, blkY, pixOut) {
        this.interpolateTop(topLeftAvailable, topRightAvailable, topLeft, topLine, mbOffX + blkX, blkY, this.topBuf);
        this.genBuf[0] = (((this.topBuf[0] + this.topBuf[1] + 1) >> 1) << 24 >> 24);
        this.genBuf[1] = (((this.topBuf[1] + this.topBuf[2] + 1) >> 1) << 24 >> 24);
        this.genBuf[2] = (((this.topBuf[2] + this.topBuf[3] + 1) >> 1) << 24 >> 24);
        this.genBuf[3] = (((this.topBuf[3] + this.topBuf[4] + 1) >> 1) << 24 >> 24);
        this.genBuf[4] = (((this.topBuf[4] + this.topBuf[5] + 1) >> 1) << 24 >> 24);
        this.genBuf[5] = (((this.topBuf[5] + this.topBuf[6] + 1) >> 1) << 24 >> 24);
        this.genBuf[6] = (((this.topBuf[6] + this.topBuf[7] + 1) >> 1) << 24 >> 24);
        this.genBuf[7] = (((this.topBuf[7] + this.topBuf[8] + 1) >> 1) << 24 >> 24);
        this.genBuf[8] = (((this.topBuf[8] + this.topBuf[9] + 1) >> 1) << 24 >> 24);
        this.genBuf[9] = (((this.topBuf[9] + this.topBuf[10] + 1) >> 1) << 24 >> 24);
        this.genBuf[10] = (((this.topBuf[10] + this.topBuf[11] + 1) >> 1) << 24 >> 24);
        this.genBuf[11] = (((this.topBuf[0] + this.topBuf[2] + ((this.topBuf[1]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[12] = (((this.topBuf[1] + this.topBuf[3] + ((this.topBuf[2]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[13] = (((this.topBuf[2] + this.topBuf[4] + ((this.topBuf[3]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[14] = (((this.topBuf[3] + this.topBuf[5] + ((this.topBuf[4]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[15] = (((this.topBuf[4] + this.topBuf[6] + ((this.topBuf[5]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[16] = (((this.topBuf[5] + this.topBuf[7] + ((this.topBuf[6]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[17] = (((this.topBuf[6] + this.topBuf[8] + ((this.topBuf[7]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[18] = (((this.topBuf[7] + this.topBuf[9] + ((this.topBuf[8]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[19] = (((this.topBuf[8] + this.topBuf[10] + ((this.topBuf[9]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[20] = (((this.topBuf[9] + this.topBuf[11] + ((this.topBuf[10]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[21] = (((this.topBuf[10] + this.topBuf[12] + ((this.topBuf[11]) << 1) + 2) >> 2) << 24 >> 24);
        var off = (blkY << 4) + blkX;
        this.copyAdd(this.genBuf, 0, residual, off, 0, pixOut);
        this.copyAdd(this.genBuf, 11, residual, off + 16, 8, pixOut);
        this.copyAdd(this.genBuf, 1, residual, off + 32, 16, pixOut);
        this.copyAdd(this.genBuf, 12, residual, off + 48, 24, pixOut);
        this.copyAdd(this.genBuf, 2, residual, off + 64, 32, pixOut);
        this.copyAdd(this.genBuf, 13, residual, off + 80, 40, pixOut);
        this.copyAdd(this.genBuf, 3, residual, off + 96, 48, pixOut);
        this.copyAdd(this.genBuf, 14, residual, off + 112, 56, pixOut);
    };
    prototype.predictHorizontalUp = function(residual, topLeftAvailable, topLeft, leftRow, mbOffX, blkX, blkY, pixOut) {
        this.interpolateLeft(topLeftAvailable, topLeft, leftRow, blkY, this.leftBuf);
        this.genBuf[0] = (((this.leftBuf[0] + this.leftBuf[1] + 1) >> 1) << 24 >> 24);
        this.genBuf[1] = (((this.leftBuf[2] + this.leftBuf[0] + ((this.leftBuf[1]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[2] = (((this.leftBuf[1] + this.leftBuf[2] + 1) >> 1) << 24 >> 24);
        this.genBuf[3] = (((this.leftBuf[3] + this.leftBuf[1] + ((this.leftBuf[2]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[4] = (((this.leftBuf[2] + this.leftBuf[3] + 1) >> 1) << 24 >> 24);
        this.genBuf[5] = (((this.leftBuf[4] + this.leftBuf[2] + ((this.leftBuf[3]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[6] = (((this.leftBuf[3] + this.leftBuf[4] + 1) >> 1) << 24 >> 24);
        this.genBuf[7] = (((this.leftBuf[5] + this.leftBuf[3] + ((this.leftBuf[4]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[8] = (((this.leftBuf[4] + this.leftBuf[5] + 1) >> 1) << 24 >> 24);
        this.genBuf[9] = (((this.leftBuf[6] + this.leftBuf[4] + ((this.leftBuf[5]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[10] = (((this.leftBuf[5] + this.leftBuf[6] + 1) >> 1) << 24 >> 24);
        this.genBuf[11] = (((this.leftBuf[7] + this.leftBuf[5] + ((this.leftBuf[6]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[12] = (((this.leftBuf[6] + this.leftBuf[7] + 1) >> 1) << 24 >> 24);
        this.genBuf[13] = (((this.leftBuf[6] + this.leftBuf[7] + ((this.leftBuf[7]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[14] = this.genBuf[15] = this.genBuf[16] = this.genBuf[17] = this.genBuf[18] = this.genBuf[19] = this.genBuf[20] = this.genBuf[21] = this.leftBuf[7];
        var off = (blkY << 4) + blkX;
        this.copyAdd(this.genBuf, 0, residual, off, 0, pixOut);
        this.copyAdd(this.genBuf, 2, residual, off + 16, 8, pixOut);
        this.copyAdd(this.genBuf, 4, residual, off + 32, 16, pixOut);
        this.copyAdd(this.genBuf, 6, residual, off + 48, 24, pixOut);
        this.copyAdd(this.genBuf, 8, residual, off + 64, 32, pixOut);
        this.copyAdd(this.genBuf, 10, residual, off + 80, 40, pixOut);
        this.copyAdd(this.genBuf, 12, residual, off + 96, 48, pixOut);
        this.copyAdd(this.genBuf, 14, residual, off + 112, 56, pixOut);
    };
}, {topBuf: "Int8Array", leftBuf: "Int8Array", genBuf: "Int8Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A funnel that merges channels into multi-channel stream
 *  
 *  @author The JCodec project
 *  
 */
var ChannelMerge = function(format) {
    this.format = format;
};
ChannelMerge = stjs.extend(ChannelMerge, null, [AudioFilter], function(constructor, prototype) {
    prototype.format = null;
    prototype.filter = function(_in, inPos, out) {
        if (_in.length != this.format.getChannels()) {
             throw new IllegalArgumentException("Channel merge must be supplied with " + this.format.getChannels() + " input buffers to hold the channels.");
        }
        if (out.length != 1) {
             throw new IllegalArgumentException("Channel merget invoked on more then one output");
        }
        var out0 = out[0];
        var min = Integer.MAX_VALUE;
        for (var i = 0; i < _in.length; i++) {
            if (_in[i].remaining() < min) 
                min = _in[i].remaining();
        }
        for (var i = 0; i < _in.length; i++) {
            Assert.assertEquals(_in[i].remaining(), min);
        }
        if (out0.remaining() < min * _in.length) 
             throw new IllegalArgumentException("Supplied output buffer is not big enough to hold " + min + " * " + _in.length + " = " + (min * _in.length) + " output samples.");
        for (var i = 0; i < min; i++) {
            for (var j = 0; j < _in.length; j++) 
                out0.put(_in[j].get());
        }
    };
    prototype.getDelay = function() {
        return 0;
    };
    prototype.getNInputs = function() {
        return this.format.getChannels();
    };
    prototype.getNOutputs = function() {
        return 1;
    };
}, {format: "AudioFormat"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license. 
 * 
 *  @author in-somnia
 */
var ICSInfo = function(frameLength) {
    this.frameLength = frameLength;
    this.windowShape = new Int32Array(2);
    this.windowSequence = ICSInfo.WindowSequence.ONLY_LONG_SEQUENCE;
    this.windowGroupLength = new Int32Array(SyntaxConstants.MAX_WINDOW_GROUP_COUNT);
    this.ltpData1Present = false;
    this.ltpData2Present = false;
};
ICSInfo = stjs.extend(ICSInfo, null, [SyntaxConstants, ScaleFactorBands], function(constructor, prototype) {
    constructor.LTPrediction = function(frameLength) {
        this.frameLength = frameLength;
        this.states = new Int32Array(4 * frameLength);
    };
    constructor.LTPrediction = stjs.extend(constructor.LTPrediction, null, [SyntaxConstants], function(constructor, prototype) {
        constructor.CODEBOOK = new Float32Array([0.570829, 0.696616, 0.813004, 0.911304, 0.9849, 1.067894, 1.194601, 1.369533]);
        prototype.frameLength = 0;
        prototype.states = null;
        prototype.coef = 0;
        prototype.lag = 0;
        prototype.lastBand = 0;
        prototype.lagUpdate = false;
        prototype.shortUsed = null;
        prototype.shortLagPresent = null;
        prototype.longUsed = null;
        prototype.shortLag = null;
        prototype.decode = function(_in, info, profile) {
            this.lag = 0;
            if (profile.equals(Profile.AAC_LD)) {
                this.lagUpdate = _in.readBool();
                if (this.lagUpdate) 
                    this.lag = _in.readBits(10);
            } else 
                this.lag = _in.readBits(11);
            if (this.lag > (this.frameLength << 1)) 
                 throw new AACException("LTP lag too large: " + this.lag);
            this.coef = _in.readBits(3);
            var windowCount = info.getWindowCount();
            if (info.isEightShortFrame()) {
                this.shortUsed = new Int8Array(windowCount);
                this.shortLagPresent = new Int8Array(windowCount);
                this.shortLag = new Int32Array(windowCount);
                for (var w = 0; w < windowCount; w++) {
                    if (this.shortUsed[w] = _in.readBool()) {
                        this.shortLagPresent[w] = _in.readBool();
                        if (this.shortLagPresent[w]) 
                            this.shortLag[w] = _in.readBits(4);
                    }
                }
            } else {
                this.lastBand = Math.min(info.getMaxSFB(), SyntaxConstants.MAX_LTP_SFB);
                this.longUsed = new Int8Array(this.lastBand);
                for (var i = 0; i < this.lastBand; i++) {
                    this.longUsed[i] = _in.readBool();
                }
            }
        };
        prototype.setPredictionUnused = function(sfb) {
            if (this.longUsed != null) 
                this.longUsed[sfb] = false;
        };
        prototype.process = function(ics, data, filterBank, sf) {
            var info = ics.getInfo();
            if (!info.isEightShortFrame()) {
                var samples = this.frameLength << 1;
                var _in = new Float32Array(2048);
                var out = new Float32Array(2048);
                for (var i = 0; i < samples; i++) {
                    _in[i] = this.states[samples + i - this.lag] * ICSInfo.LTPrediction.CODEBOOK[this.coef];
                }
                filterBank.processLTP(info.getWindowSequence(), info.getWindowShape(ICSInfo.CURRENT), info.getWindowShape(ICSInfo.PREVIOUS), _in, out);
                if (ics.isTNSDataPresent()) 
                    ics.getTNS().process(ics, out, sf, true);
                var swbOffsets = info.getSWBOffsets();
                var swbOffsetMax = info.getSWBOffsetMax();
                var low, high, bin;
                for (var sfb = 0; sfb < this.lastBand; sfb++) {
                    if (this.longUsed[sfb]) {
                        low = swbOffsets[sfb];
                        high = Math.min(swbOffsets[sfb + 1], swbOffsetMax);
                        for (bin = low; bin < high; bin++) {
                            data[bin] += out[bin];
                        }
                    }
                }
            }
        };
        prototype.updateState = function(time, overlap, profile) {
            var i;
            if (profile.equals(Profile.AAC_LD)) {
                for (i = 0; i < this.frameLength; i++) {
                    this.states[i] = this.states[i + this.frameLength];
                    this.states[this.frameLength + i] = this.states[i + (this.frameLength * 2)];
                    this.states[(this.frameLength * 2) + i] = Math.round(time[i]);
                    this.states[(this.frameLength * 3) + i] = Math.round(overlap[i]);
                }
            } else {
                for (i = 0; i < this.frameLength; i++) {
                    this.states[i] = this.states[i + this.frameLength];
                    this.states[this.frameLength + i] = Math.round(time[i]);
                    this.states[(this.frameLength * 2) + i] = Math.round(overlap[i]);
                }
            }
        };
        constructor.isLTPProfile = function(profile) {
            return profile.equals(Profile.AAC_LTP) || profile.equals(Profile.ER_AAC_LTP) || profile.equals(Profile.AAC_LD);
        };
        prototype.copy = function(ltp) {
            System.arraycopy(ltp.states, 0, this.states, 0, this.states.length);
            this.coef = ltp.coef;
            this.lag = ltp.lag;
            this.lastBand = ltp.lastBand;
            this.lagUpdate = ltp.lagUpdate;
            this.shortUsed = Platform.copyOfBool(ltp.shortUsed, ltp.shortUsed.length);
            this.shortLagPresent = Platform.copyOfBool(ltp.shortLagPresent, ltp.shortLagPresent.length);
            this.shortLag = Platform.copyOfInt(ltp.shortLag, ltp.shortLag.length);
            this.longUsed = Platform.copyOfBool(ltp.longUsed, ltp.longUsed.length);
        };
    }, {CODEBOOK: "Float32Array", states: "Int32Array", shortUsed: "Int8Array", shortLagPresent: "Int8Array", longUsed: "Int8Array", shortLag: "Int32Array", LOGGER: "Logger"}, {});
    constructor.WINDOW_SHAPE_SINE = 0;
    constructor.WINDOW_SHAPE_KAISER = 1;
    constructor.PREVIOUS = 0;
    constructor.CURRENT = 1;
    constructor.WindowSequence = stjs.enumeration("ONLY_LONG_SEQUENCE", "LONG_START_SEQUENCE", "EIGHT_SHORT_SEQUENCE", "LONG_STOP_SEQUENCE");
    constructor.windowSequenceFromInt = function(i) {
        var values = ICSInfo.WindowSequence.values();
        if (values.length >= i) {
             throw new AACException("unknown window sequence type");
        }
        return values[i];
    };
    prototype.frameLength = 0;
    prototype.windowSequence = null;
    prototype.windowShape = null;
    prototype.maxSFB = 0;
    prototype.predictionDataPresent = false;
    prototype.icPredict = null;
    prototype.ltpData1Present = false;
    prototype.ltpData2Present = false;
    prototype.ltPredict1 = null;
    prototype.ltPredict2 = null;
    prototype.windowCount = 0;
    prototype.windowGroupCount = 0;
    prototype.windowGroupLength = null;
    prototype.swbCount = 0;
    prototype.swbOffsets = null;
    prototype.decode = function(_in, conf, commonWindow) {
        var sf = conf.getSampleFrequency();
        if (sf.equals(SampleFrequency.SAMPLE_FREQUENCY_NONE)) 
             throw new AACException("invalid sample frequency");
        _in.skipBit();
        this.windowSequence = ICSInfo.windowSequenceFromInt(_in.readBits(2));
        this.windowShape[ICSInfo.PREVIOUS] = this.windowShape[ICSInfo.CURRENT];
        this.windowShape[ICSInfo.CURRENT] = _in.readBit();
        this.windowGroupCount = 1;
        this.windowGroupLength[0] = 1;
        if (this.windowSequence.equals(ICSInfo.WindowSequence.EIGHT_SHORT_SEQUENCE)) {
            this.maxSFB = _in.readBits(4);
            var i;
            for (i = 0; i < 7; i++) {
                if (_in.readBool()) 
                    this.windowGroupLength[this.windowGroupCount - 1]++;
                 else {
                    this.windowGroupCount++;
                    this.windowGroupLength[this.windowGroupCount - 1] = 1;
                }
            }
            this.windowCount = 8;
            this.swbOffsets = ScaleFactorBands.SWB_OFFSET_SHORT_WINDOW[sf.getIndex()];
            this.swbCount = ScaleFactorBands.SWB_SHORT_WINDOW_COUNT[sf.getIndex()];
            this.predictionDataPresent = false;
        } else {
            this.maxSFB = _in.readBits(6);
            this.windowCount = 1;
            this.swbOffsets = ScaleFactorBands.SWB_OFFSET_LONG_WINDOW[sf.getIndex()];
            this.swbCount = ScaleFactorBands.SWB_LONG_WINDOW_COUNT[sf.getIndex()];
            this.predictionDataPresent = _in.readBool();
            if (this.predictionDataPresent) 
                this.readPredictionData(_in, conf.getProfile(), sf, commonWindow);
        }
    };
    prototype.readPredictionData = function(_in, profile, sf, commonWindow) {
        if (Profile.AAC_MAIN == profile) {
            if (this.icPredict == null) 
                this.icPredict = new ICPrediction();
            this.icPredict.decode(_in, this.maxSFB, sf);
        } else if (Profile.AAC_LTP == profile) {
            if (this.ltpData1Present = _in.readBool()) {
                if (this.ltPredict1 == null) 
                    this.ltPredict1 = new ICSInfo.LTPrediction(this.frameLength);
                this.ltPredict1.decode(_in, this, profile);
            }
            if (commonWindow) {
                if (this.ltpData2Present = _in.readBool()) {
                    if (this.ltPredict2 == null) 
                        this.ltPredict2 = new ICSInfo.LTPrediction(this.frameLength);
                    this.ltPredict2.decode(_in, this, profile);
                }
            }
        } else if (Profile.ER_AAC_LTP == profile) {
            if (!commonWindow) {
                if (this.ltpData1Present = _in.readBool()) {
                    if (this.ltPredict1 == null) 
                        this.ltPredict1 = new ICSInfo.LTPrediction(this.frameLength);
                    this.ltPredict1.decode(_in, this, profile);
                }
            }
        } else {
             throw new AACException("unexpected profile for LTP: " + profile);
        }
    };
    prototype.getMaxSFB = function() {
        return this.maxSFB;
    };
    prototype.getSWBCount = function() {
        return this.swbCount;
    };
    prototype.getSWBOffsets = function() {
        return this.swbOffsets;
    };
    prototype.getSWBOffsetMax = function() {
        return this.swbOffsets[this.swbCount];
    };
    prototype.getWindowCount = function() {
        return this.windowCount;
    };
    prototype.getWindowGroupCount = function() {
        return this.windowGroupCount;
    };
    prototype.getWindowGroupLength = function(g) {
        return this.windowGroupLength[g];
    };
    prototype.getWindowSequence = function() {
        return this.windowSequence;
    };
    prototype.isEightShortFrame = function() {
        return this.windowSequence.equals(ICSInfo.WindowSequence.EIGHT_SHORT_SEQUENCE);
    };
    prototype.getWindowShape = function(index) {
        return this.windowShape[index];
    };
    prototype.isICPredictionPresent = function() {
        return this.predictionDataPresent;
    };
    prototype.getICPrediction = function() {
        return this.icPredict;
    };
    prototype.isLTPrediction1Present = function() {
        return this.ltpData1Present;
    };
    prototype.getLTPrediction1 = function() {
        return this.ltPredict1;
    };
    prototype.isLTPrediction2Present = function() {
        return this.ltpData2Present;
    };
    prototype.getLTPrediction2 = function() {
        return this.ltPredict2;
    };
    prototype.unsetPredictionSFB = function(sfb) {
        if (this.predictionDataPresent) 
            this.icPredict.setPredictionUnused(sfb);
        if (this.ltpData1Present) 
            this.ltPredict1.setPredictionUnused(sfb);
        if (this.ltpData2Present) 
            this.ltPredict2.setPredictionUnused(sfb);
    };
    prototype.setData = function(info) {
        this.windowSequence = ICSInfo.WindowSequence.valueOf(info.windowSequence.name());
        this.windowShape[ICSInfo.PREVIOUS] = this.windowShape[ICSInfo.CURRENT];
        this.windowShape[ICSInfo.CURRENT] = info.windowShape[ICSInfo.CURRENT];
        this.maxSFB = info.maxSFB;
        this.predictionDataPresent = info.predictionDataPresent;
        if (this.predictionDataPresent) 
            this.icPredict = info.icPredict;
        this.ltpData1Present = info.ltpData1Present;
        if (this.ltpData1Present) {
            this.ltPredict1.copy(info.ltPredict1);
            this.ltPredict2.copy(info.ltPredict2);
        }
        this.windowCount = info.windowCount;
        this.windowGroupCount = info.windowGroupCount;
        this.windowGroupLength = Platform.copyOfInt(info.windowGroupLength, info.windowGroupLength.length);
        this.swbCount = info.swbCount;
        this.swbOffsets = Platform.copyOfInt(info.swbOffsets, info.swbOffsets.length);
    };
}, {windowSequence: {name: "Enum", arguments: ["ICSInfo.WindowSequence"]}, windowShape: "Int32Array", icPredict: "ICPrediction", ltPredict1: "ICSInfo.LTPrediction", ltPredict2: "ICSInfo.LTPrediction", windowGroupLength: "Int32Array", swbOffsets: "Int32Array", LOGGER: "Logger", SWB_LONG_WINDOW_COUNT: "Int32Array", SWB_OFFSET_1024_96: "Int32Array", SWB_OFFSET_1024_64: "Int32Array", SWB_OFFSET_1024_48: "Int32Array", SWB_OFFSET_1024_32: "Int32Array", SWB_OFFSET_1024_24: "Int32Array", SWB_OFFSET_1024_16: "Int32Array", SWB_OFFSET_1024_8: "Int32Array", SWB_OFFSET_LONG_WINDOW: "Array", SWB_SHORT_WINDOW_COUNT: "Int32Array", SWB_OFFSET_128_96: "Int32Array", SWB_OFFSET_128_64: "Int32Array", SWB_OFFSET_128_48: "Int32Array", SWB_OFFSET_128_24: "Int32Array", SWB_OFFSET_128_16: "Int32Array", SWB_OFFSET_128_8: "Int32Array", SWB_OFFSET_SHORT_WINDOW: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Returns clips track to a certain frame range
 *  
 *  @author The JCodec project
 *  
 */
var ClipTrack = function(src, frameFrom, frameTo) {
    if (frameTo <= frameFrom) 
         throw new IllegalArgumentException("Clipping negative or zero frames.");
    this.src = src;
    this.from = frameFrom;
    this.to = frameTo;
};
ClipTrack = stjs.extend(ClipTrack, null, [VirtualTrack], function(constructor, prototype) {
    prototype.src = null;
    prototype.from = 0;
    prototype.to = 0;
    prototype.startFrame = 0;
    prototype.startPts = 0.0;
    prototype.gop = null;
    prototype.eof = false;
    prototype.nextPacket = function() {
        if (this.eof) 
            return null;
        var nextPacket;
        if (this.gop == null) {
            this.gop = this.getGop(this.src, this.from);
            this.startPts = this.gop.get(0).getPts();
            this.startFrame = this.gop.get(0).getFrameNo();
        }
        nextPacket = this.gop.size() > 0 ? this.gop.remove(0) : this.src.nextPacket();
        if (nextPacket == null || nextPacket.getFrameNo() >= this.to) {
            this.eof = true;
            return null;
        }
        return new ClipTrack.ClipPacket(this, nextPacket);
    };
    prototype.getGop = function(src, from) {
        var result = new ArrayList();
        var nextPacket;
        do {
            nextPacket = src.nextPacket();
            if (nextPacket != null) {
                if (nextPacket.isKeyframe()) 
                    result.clear();
                result.add(nextPacket);
            }
        } while (nextPacket != null && nextPacket.getFrameNo() < from);
        return result;
    };
    prototype.getCodecMeta = function() {
        return this.src.getCodecMeta();
    };
    prototype.getEdits = function() {
        return null;
    };
    prototype.getPreferredTimescale = function() {
        return this.src.getPreferredTimescale();
    };
    prototype.close = function() {
        this.src.close();
    };
    constructor.ClipPacket = function(track, src) {
        VirtualPacketWrapper.call(this, src);
        this.track = track;
    };
    constructor.ClipPacket = stjs.extend(constructor.ClipPacket, VirtualPacketWrapper, [], function(constructor, prototype) {
        prototype.track = null;
        prototype.getPts = function() {
            return VirtualPacketWrapper.prototype.getPts.call(this) - this.track.startPts;
        };
        prototype.getFrameNo = function() {
            return VirtualPacketWrapper.prototype.getFrameNo.call(this) - this.track.startFrame;
        };
    }, {track: "ClipTrack", src: "VirtualPacket", byPts: {name: "Comparator", arguments: ["Object"]}}, {});
}, {src: "VirtualTrack", gop: {name: "List", arguments: ["VirtualPacket"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Edits frames track the way the resulting track is completely edit-less
 *  
 *  @author The JCodec project
 *  
 */
var EditedFramesTrack = function(src) {
    this.src = src;
    this.edits = src.getEdits();
    this.buckets = Array(this.edits.length);
    for (var i = 0; i < this.edits.length; i++) 
        this.buckets[i] = new ArrayList();
    var pkt;
     while ((pkt = src.nextPacket()) != null){
        if (!pkt.isKeyframe()) 
             throw new IllegalArgumentException("Can not apply edits to a track that has inter frames, this will result in decoding errors.");
        for (var e = 0; e < this.edits.length; e++) {
            var ed = this.edits[e];
            if (pkt.getPts() < ed.getIn() + ed.getDuration() && pkt.getPts() + pkt.getDuration() > ed.getIn()) {
                this.buckets[e].add(pkt);
            }
        }
    }
};
EditedFramesTrack = stjs.extend(EditedFramesTrack, null, [VirtualTrack], function(constructor, prototype) {
    prototype.src = null;
    prototype.buckets = null;
    prototype.edits = null;
    prototype.curEdit = 0;
    prototype.curPkt = 0;
    prototype.frameNo = 0;
    prototype.pts = 0.0;
    prototype.nextPacket = function() {
        if (this.curEdit >= this.edits.length) 
            return null;
        var pkt = this.buckets[this.curEdit].get(this.curPkt);
        var edt = this.edits[this.curEdit];
        var duration = pkt.getDuration();
        var sticksFront = edt.getIn() - pkt.getPts();
        var sticksBack = pkt.getPts() + pkt.getDuration() - (edt.getIn() + edt.getDuration());
        duration -= Math.max(sticksFront, 0) + Math.max(sticksBack, 0);
        var ret = new EditedFramesTrack.EditedFramesPacket(pkt, this.pts, duration, this.frameNo);
        ++this.curPkt;
        if (this.curPkt >= this.buckets[this.curEdit].size()) {
            this.curEdit++;
            this.curPkt = 0;
        }
        this.frameNo++;
        this.pts += duration;
        return ret;
    };
    constructor.EditedFramesPacket = function(src, pts, duration, frameNo) {
        VirtualPacketWrapper.call(this, src);
        this.pts = pts;
        this.duration = duration;
        this.frameNo = frameNo;
    };
    constructor.EditedFramesPacket = stjs.extend(constructor.EditedFramesPacket, VirtualPacketWrapper, [], function(constructor, prototype) {
        prototype.pts = 0.0;
        prototype.duration = 0.0;
        prototype.frameNo = 0;
        prototype.getPts = function() {
            return this.pts;
        };
        prototype.getDuration = function() {
            return this.duration;
        };
        prototype.isKeyframe = function() {
            return true;
        };
        prototype.getFrameNo = function() {
            return this.frameNo;
        };
    }, {src: "VirtualPacket", byPts: {name: "Comparator", arguments: ["Object"]}}, {});
    prototype.getCodecMeta = function() {
        return this.src.getCodecMeta();
    };
    prototype.getEdits = function() {
        return null;
    };
    prototype.close = function() {
        this.src.close();
    };
    prototype.getPreferredTimescale = function() {
        return this.src.getPreferredTimescale();
    };
}, {src: "VirtualTrack", buckets: "Array", edits: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A proxy track that maintains in-memory cache of recently read packets
 *  
 *  @author The JCodec project
 *  
 */
var CachingTrack = function(src, policy, policyExecutor) {
    this.cachedPackets = Collections.synchronizedList(new ArrayList());
    if (policy < 1) 
         throw new IllegalArgumentException("Caching track with less then 1 entry.");
    this.src = src;
    var self = this;
    this.policyFuture = policyExecutor.scheduleAtFixedRate(new (stjs.extend(function CachingTrack$1() {}, null, [Runnable], function(constructor, prototype) {
        prototype.run = function() {
             while (self.cachedPackets.size() > policy){
                self.cachedPackets.get(0).wipe();
            }
        };
    }, {}, {}))(), 200, 200, TimeUnit.MILLISECONDS);
};
CachingTrack = stjs.extend(CachingTrack, null, [VirtualTrack], function(constructor, prototype) {
    prototype.src = null;
    prototype.cachedPackets = null;
    prototype.policyFuture = null;
    prototype.getCodecMeta = function() {
        return this.src.getCodecMeta();
    };
    prototype.nextPacket = function() {
        var pkt = this.src.nextPacket();
        if (pkt == null) 
            return null;
        return new CachingTrack.CachingPacket(this, pkt);
    };
    constructor.CachingPacket = function(track, src) {
        VirtualPacketWrapper.call(this, src);
        this.track = track;
    };
    constructor.CachingPacket = stjs.extend(constructor.CachingPacket, VirtualPacketWrapper, [], function(constructor, prototype) {
        prototype.cache = null;
        prototype.track = null;
        prototype.wipe = function() {
            if (this.track.cachedPackets.indexOf(this) == 0) {
                this.track.cachedPackets.remove(0);
                this.cache = null;
            }
        };
        prototype.getData = function() {
            this.track.cachedPackets.remove(this);
            if (this.cache == null) {
                this.cache = this.src.getData();
            }
            this.track.cachedPackets.add(this);
            return this.cache == null ? null : this.cache.duplicate();
        };
    }, {cache: "ByteBuffer", track: "CachingTrack", src: "VirtualPacket", byPts: {name: "Comparator", arguments: ["Object"]}}, {});
    prototype.close = function() {
        if (this.policyFuture != null) 
            this.policyFuture.cancel(false);
        this.cachedPackets.clear();
        this.src.close();
    };
    prototype.getEdits = function() {
        return this.src.getEdits();
    };
    prototype.getPreferredTimescale = function() {
        return this.src.getPreferredTimescale();
    };
}, {src: "VirtualTrack", cachedPackets: {name: "List", arguments: ["CachingTrack.CachingPacket"]}, policyFuture: {name: "ScheduledFuture", arguments: ["Object"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var ConcatTrack = function(tracks) {
    this.tracks = tracks;
};
ConcatTrack = stjs.extend(ConcatTrack, null, [VirtualTrack], function(constructor, prototype) {
    prototype.tracks = null;
    prototype.idx = 0;
    prototype.lastPacket = null;
    prototype.offsetPts = 0;
    prototype.offsetFn = 0;
    prototype.nextPacket = function() {
         while (this.idx < this.tracks.length){
            var track = this.tracks[this.idx];
            var nextPacket = track.nextPacket();
            if (nextPacket == null) {
                this.idx++;
                this.offsetPts += this.lastPacket.getPts() + this.lastPacket.getDuration();
                this.offsetFn += this.lastPacket.getFrameNo() + 1;
            } else {
                this.lastPacket = nextPacket;
                return new ConcatPacket(nextPacket, this.offsetPts, this.offsetFn);
            }
        }
        return null;
    };
    prototype.getCodecMeta = function() {
        return this.tracks[0].getCodecMeta();
    };
    prototype.getEdits = function() {
        return null;
    };
    prototype.getPreferredTimescale = function() {
        return this.tracks[0].getPreferredTimescale();
    };
    prototype.close = function() {
        for (var i = 0; i < this.tracks.length; i++) {
            this.tracks[i].close();
        }
    };
}, {tracks: "Array", lastPacket: "VirtualPacket"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Picture extension with frame number, makes it easier to debug reordering
 *  
 *  @author The JCodec project
 *  
 */
var Frame = function(width, height, data, color, crop, frameNo, frameType, mvs, refsUsed, poc) {
    Picture8Bit.call(this, width, height, data, color, crop);
    this.frameNo = frameNo;
    this.mvs = mvs;
    this.refsUsed = refsUsed;
    this.poc = poc;
    this.shortTerm = true;
};
Frame = stjs.extend(Frame, Picture8Bit, [], function(constructor, prototype) {
    prototype.frameNo = 0;
    prototype.frameType = null;
    prototype.mvs = null;
    prototype.refsUsed = null;
    prototype.shortTerm = false;
    prototype.poc = 0;
    constructor.createFrame = function(pic) {
        var comp = pic.createCompatible();
        return new Frame(comp.getWidth(), comp.getHeight(), comp.getData(), comp.getColor(), pic.getCrop(), pic.frameNo, pic.frameType, pic.mvs, pic.refsUsed, pic.poc);
    };
    prototype.cropped = function() {
        var cropped = Picture8Bit.prototype.cropped.call(this);
        return new Frame(cropped.getWidth(), cropped.getHeight(), cropped.getData(), cropped.getColor(), null, this.frameNo, this.frameType, this.mvs, this.refsUsed, this.poc);
    };
    prototype.copyFromFrame = function(src) {
        Picture8Bit.prototype.copyFrom.call(this, src);
        this.frameNo = src.frameNo;
        this.mvs = src.mvs;
        this.shortTerm = src.shortTerm;
        this.refsUsed = src.refsUsed;
        this.poc = src.poc;
    };
    /**
     *  Creates a cropped clone of this picture.
     *  
     *  @return
     */
    prototype.cloneCropped = function() {
        if (this.cropNeeded()) {
            return this.cropped();
        } else {
            var clone = Frame.createFrame(this);
            clone.copyFrom(this);
            return clone;
        }
    };
    prototype.getFrameNo = function() {
        return this.frameNo;
    };
    prototype.getMvs = function() {
        return this.mvs;
    };
    prototype.isShortTerm = function() {
        return this.shortTerm;
    };
    prototype.setShortTerm = function(shortTerm) {
        this.shortTerm = shortTerm;
    };
    prototype.getPOC = function() {
        return this.poc;
    };
    constructor.POCAsc = new (stjs.extend(function Frame$1() {}, null, [Comparator], function(constructor, prototype) {
        prototype.compare = function(o1, o2) {
            if (o1 == null && o2 == null) 
                return 0;
             else if (o1 == null) 
                return 1;
             else if (o2 == null) 
                return -1;
             else 
                return o1.poc > o2.poc ? 1 : (o1.poc == o2.poc ? 0 : -1);
        };
    }, {}, {}))();
    constructor.POCDesc = new (stjs.extend(function Frame$2() {}, null, [Comparator], function(constructor, prototype) {
        prototype.compare = function(o1, o2) {
            if (o1 == null && o2 == null) 
                return 0;
             else if (o1 == null) 
                return 1;
             else if (o2 == null) 
                return -1;
             else 
                return o1.poc < o2.poc ? 1 : (o1.poc == o2.poc ? 0 : -1);
        };
    }, {}, {}))();
    prototype.getRefsUsed = function() {
        return this.refsUsed;
    };
    prototype.getFrameType = function() {
        return this.frameType;
    };
}, {frameType: "SliceType", mvs: "Array", refsUsed: "Array", POCAsc: {name: "Comparator", arguments: ["Frame"]}, POCDesc: {name: "Comparator", arguments: ["Frame"]}, color: "ColorSpace", data: "Array", crop: "Rect"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var EncodedMB = function() {
    this.pixels = Picture8Bit.create(16, 16, ColorSpace.YUV420J);
    this.nc = new Int32Array(16);
    this.mx = new Int32Array(16);
    this.my = new Int32Array(16);
};
EncodedMB = stjs.extend(EncodedMB, null, [], function(constructor, prototype) {
    prototype.pixels = null;
    prototype.type = null;
    prototype.qp = 0;
    prototype.nc = null;
    prototype.mx = null;
    prototype.my = null;
    prototype.getPixels = function() {
        return this.pixels;
    };
    prototype.getType = function() {
        return this.type;
    };
    prototype.setType = function(type) {
        this.type = type;
    };
    prototype.getQp = function() {
        return this.qp;
    };
    prototype.setQp = function(qp) {
        this.qp = qp;
    };
    prototype.getNc = function() {
        return this.nc;
    };
    prototype.getMx = function() {
        return this.mx;
    };
    prototype.getMy = function() {
        return this.my;
    };
}, {pixels: "Picture8Bit", type: "MBType", nc: "Int32Array", mx: "Int32Array", my: "Int32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var VP8Decoder = function() {};
VP8Decoder = stjs.extend(VP8Decoder, null, [], function(constructor, prototype) {
    prototype.mbs = null;
    prototype.width = 0;
    prototype.height = 0;
    prototype.decode = function(frame) {
        var firstThree = new Int8Array(3);
        frame.getBuf(firstThree);
        var keyFrame = VP8Util.getBitInBytes(firstThree, 0) == 0;
        var version = VP8Util.getBitsInBytes(firstThree, 1, 3);
        var showFrame = VP8Util.getBitInBytes(firstThree, 4) > 0;
        var partitionSize = VP8Util.getBitsInBytes(firstThree, 5, 19);
        var threeByteToken = VP8Decoder.printHexByte(frame.get()) + " " + VP8Decoder.printHexByte(frame.get()) + " " + VP8Decoder.printHexByte(frame.get());
        var twoBytesWidth = (frame.get() & 255) | (frame.get() & 255) << 8;
        var twoBytesHeight = (frame.get() & 255) | (frame.get() & 255) << 8;
        this.width = (twoBytesWidth & 16383);
        this.height = (twoBytesHeight & 16383);
        var numberOfMBRows = VP8Util.getMacroblockCount(this.height);
        var numberOfMBCols = VP8Util.getMacroblockCount(this.width);
        this.mbs = Array.apply(null, Array(numberOfMBRows + 2)).map(function() {
            return Array(numberOfMBCols + 2);
        });
        for (var row = 0; row < numberOfMBRows + 2; row++) 
            for (var col = 0; col < numberOfMBCols + 2; col++) 
                this.mbs[row][col] = new Macroblock(row, col);
        var headerOffset = frame.position();
        var headerDecoder = new BooleanArithmeticDecoder(frame, 0);
        var isYUVColorSpace = (headerDecoder.decodeBit() == 0);
        var clampingRequired = headerDecoder.decodeBit() == 0;
        var segmentation = headerDecoder.decodeBit();
        Assert.assertEquals("Frame has segmentation, segment decoding is not ", 0, segmentation);
        var simpleFilter = headerDecoder.decodeBit();
        var filterLevel = headerDecoder.decodeInt(6);
        var filterType = (filterLevel == 0) ? 0 : (simpleFilter > 0) ? 1 : 2;
        var sharpnessLevel = headerDecoder.decodeInt(3);
        var loopFilterDeltaFlag = headerDecoder.decodeBit();
        Assert.assertEquals(1, loopFilterDeltaFlag);
        var loopFilterDeltaUpdate = headerDecoder.decodeBit();
        Assert.assertEquals(1, loopFilterDeltaUpdate);
        var refLoopFilterDeltas = new Int32Array(VP8Util.MAX_REF_LF_DELTAS);
        var modeLoopFilterDeltas = new Int32Array(VP8Util.MAX_MODE_LF_DELTAS);
        for (var i = 0; i < VP8Util.MAX_REF_LF_DELTAS; i++) {
            if (headerDecoder.decodeBit() > 0) {
                refLoopFilterDeltas[i] = headerDecoder.decodeInt(6);
                ;
                if (headerDecoder.decodeBit() > 0) 
                    refLoopFilterDeltas[i] = refLoopFilterDeltas[i] * -1;
            }
        }
        for (var i = 0; i < VP8Util.MAX_MODE_LF_DELTAS; i++) {
            if (headerDecoder.decodeBit() > 0) {
                modeLoopFilterDeltas[i] = headerDecoder.decodeInt(6);
                if (headerDecoder.decodeBit() > 0) 
                    modeLoopFilterDeltas[i] = modeLoopFilterDeltas[i] * -1;
            }
        }
        var log2OfPartCnt = headerDecoder.decodeInt(2);
        Assert.assertEquals(0, log2OfPartCnt);
        var partitionsCount = 1;
        var runningSize = 0;
        var zSize = frame.limit() - (partitionSize + headerOffset);
        var tokenBuffer = frame.duplicate();
        tokenBuffer.setPosition(partitionSize + headerOffset);
        var decoder = new BooleanArithmeticDecoder(tokenBuffer, 0);
        var yacIndex = headerDecoder.decodeInt(7);
        var ydcDelta = ((headerDecoder.decodeBit() > 0) ? VP8Util.delta(headerDecoder) : 0);
        var y2dcDelta = ((headerDecoder.decodeBit() > 0) ? VP8Util.delta(headerDecoder) : 0);
        var y2acDelta = ((headerDecoder.decodeBit() > 0) ? VP8Util.delta(headerDecoder) : 0);
        var chromaDCDelta = ((headerDecoder.decodeBit() > 0) ? VP8Util.delta(headerDecoder) : 0);
        var chromaACDelta = ((headerDecoder.decodeBit() > 0) ? VP8Util.delta(headerDecoder) : 0);
        var refreshProbs = headerDecoder.decodeBit() == 0;
        var quants = new VP8Util.QuantizationParams(yacIndex, ydcDelta, y2dcDelta, y2acDelta, chromaDCDelta, chromaACDelta);
        var coefProbs = VP8Util.getDefaultCoefProbs();
        for (var i = 0; i < VP8Util.BLOCK_TYPES; i++) 
            for (var j = 0; j < VP8Util.COEF_BANDS; j++) 
                for (var k = 0; k < VP8Util.PREV_COEF_CONTEXTS; k++) 
                    for (var l = 0; l < VP8Util.MAX_ENTROPY_TOKENS - 1; l++) {
                        if (headerDecoder.decodeBool(VP8Util.vp8CoefUpdateProbs[i][j][k][l]) > 0) {
                            var newp = headerDecoder.decodeInt(8);
                            coefProbs[i][j][k][l] = newp;
                        }
                    }
        var macroBlockNoCoeffSkip = stjs.trunc(headerDecoder.decodeBit());
        Assert.assertEquals(1, macroBlockNoCoeffSkip);
        var probSkipFalse = headerDecoder.decodeInt(8);
        for (var mbRow = 0; mbRow < numberOfMBRows; mbRow++) {
            for (var mbCol = 0; mbCol < numberOfMBCols; mbCol++) {
                var mb = this.mbs[mbRow + 1][mbCol + 1];
                if (segmentation > 0) 
                     throw new NotSupportedException("TODO: frames with multiple segments are not supported yet");
                if (loopFilterDeltaFlag > 0) {
                    var level = filterLevel;
                    level = level + refLoopFilterDeltas[0];
                    level = (level < 0) ? 0 : (level > 63) ? 63 : level;
                    mb.filterLevel = level;
                } else 
                     throw new NotSupportedException("TODO: frames with loopFilterDeltaFlag <= 0 are not supported yet");
                if (macroBlockNoCoeffSkip > 0) 
                    mb.skipCoeff = headerDecoder.decodeBool(probSkipFalse);
                mb.lumaMode = headerDecoder.readTree(VP8Util.keyFrameYModeTree, VP8Util.keyFrameYModeProb);
                if (mb.lumaMode == VP8Util.SubblockConstants.B_PRED) {
                    for (var sbRow = 0; sbRow < 4; sbRow++) {
                        for (var sbCol = 0; sbCol < 4; sbCol++) {
                            var sb = mb.ySubblocks[sbRow][sbCol];
                            var A = sb.getAbove(VP8Util.PLANE.Y1, this.mbs);
                            var L = sb.getLeft(VP8Util.PLANE.Y1, this.mbs);
                            sb.mode = headerDecoder.readTree(VP8Util.SubblockConstants.subblockModeTree, VP8Util.SubblockConstants.keyFrameSubblockModeProb[A.mode][L.mode]);
                        }
                    }
                } else {
                    var fixedMode;
                    switch (mb.lumaMode) {
                        case VP8Util.SubblockConstants.DC_PRED:
                            fixedMode = VP8Util.SubblockConstants.B_DC_PRED;
                            break;
                        case VP8Util.SubblockConstants.V_PRED:
                            fixedMode = VP8Util.SubblockConstants.B_VE_PRED;
                            break;
                        case VP8Util.SubblockConstants.H_PRED:
                            fixedMode = VP8Util.SubblockConstants.B_HE_PRED;
                            break;
                        case VP8Util.SubblockConstants.TM_PRED:
                            fixedMode = VP8Util.SubblockConstants.B_TM_PRED;
                            break;
                        default:
                            fixedMode = VP8Util.SubblockConstants.B_DC_PRED;
                            break;
                    }
                    for (var x = 0; x < 4; x++) 
                        for (var y = 0; y < 4; y++) 
                            mb.ySubblocks[y][x].mode = fixedMode;
                }
                mb.chromaMode = headerDecoder.readTree(VP8Util.vp8UVModeTree, VP8Util.vp8KeyFrameUVModeProb);
            }
        }
        for (var mbRow = 0; mbRow < numberOfMBRows; mbRow++) {
            for (var mbCol = 0; mbCol < numberOfMBCols; mbCol++) {
                var mb = this.mbs[mbRow + 1][mbCol + 1];
                mb.decodeMacroBlock(this.mbs, decoder, coefProbs);
                mb.dequantMacroBlock(this.mbs, quants);
            }
        }
        if (filterType > 0 && filterLevel != 0) {
            if (filterType == 2) {
                FilterUtil.loopFilterUV(this.mbs, sharpnessLevel, keyFrame);
                FilterUtil.loopFilterY(this.mbs, sharpnessLevel, keyFrame);
            } else if (filterType == 1) {}
        }
    };
    prototype.getPicture8Bit = function() {
        var p = Picture8Bit.create(this.width, this.height, ColorSpace.YUV420);
        var luma = p.getPlaneData(0);
        var cb = p.getPlaneData(1);
        var cr = p.getPlaneData(2);
        var mbWidth = VP8Util.getMacroblockCount(this.width);
        var mbHeight = VP8Util.getMacroblockCount(this.height);
        var strideLuma = mbWidth * 16;
        var strideChroma = mbWidth * 8;
        for (var mbRow = 0; mbRow < mbHeight; mbRow++) {
            for (var mbCol = 0; mbCol < mbWidth; mbCol++) {
                var mb = this.mbs[mbRow + 1][mbCol + 1];
                for (var lumaRow = 0; lumaRow < 4; lumaRow++) 
                    for (var lumaCol = 0; lumaCol < 4; lumaCol++) 
                        for (var lumaPRow = 0; lumaPRow < 4; lumaPRow++) 
                            for (var lumaPCol = 0; lumaPCol < 4; lumaPCol++) {
                                var y = (mbRow << 4) + (lumaRow << 2) + lumaPRow;
                                var x = (mbCol << 4) + (lumaCol << 2) + lumaPCol;
                                if (x >= strideLuma || y >= stjs.trunc(luma.length / strideLuma)) 
                                    continue;
                                var yy = mb.ySubblocks[lumaRow][lumaCol].val[lumaPRow * 4 + lumaPCol];
                                luma[strideLuma * y + x] = ((yy - 128) << 24 >> 24);
                            }
                for (var chromaRow = 0; chromaRow < 2; chromaRow++) 
                    for (var chromaCol = 0; chromaCol < 2; chromaCol++) 
                        for (var chromaPRow = 0; chromaPRow < 4; chromaPRow++) 
                            for (var chromaPCol = 0; chromaPCol < 4; chromaPCol++) {
                                var y = (mbRow << 3) + (chromaRow << 2) + chromaPRow;
                                var x = (mbCol << 3) + (chromaCol << 2) + chromaPCol;
                                if (x >= strideChroma || y >= stjs.trunc(cb.length / strideChroma)) 
                                    continue;
                                var u = mb.uSubblocks[chromaRow][chromaCol].val[chromaPRow * 4 + chromaPCol];
                                var v = mb.vSubblocks[chromaRow][chromaCol].val[chromaPRow * 4 + chromaPCol];
                                cb[strideChroma * y + x] = ((u - 128) << 24 >> 24);
                                cr[strideChroma * y + x] = ((v - 128) << 24 >> 24);
                            }
            }
        }
        return p;
    };
    constructor.printHexByte = function(b) {
        return "0x" + Integer.toHexString(b & 255);
    };
}, {mbs: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var VideoEncoder = function() {};
VideoEncoder = stjs.extend(VideoEncoder, null, [], function(constructor, prototype) {
    prototype.encodeFrame = function(pic, _out) {
        return this.encodeFrame8Bit(Picture8Bit.fromPicture(pic), _out);
    };
    prototype.encodeFrame8Bit = function(pic, _out) {};
    prototype.getSupportedColorSpaces = function() {};
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  High level frame grabber helper.
 *  
 *  @author The JCodec project
 *  
 */
var GenericAdaptor = function(detect) {
    this.decoder = detect;
};
GenericAdaptor = stjs.extend(GenericAdaptor, null, [ContainerAdaptor], function(constructor, prototype) {
    prototype.decoder = null;
    prototype.decodeFrame = function(packet, data) {
        return this.decoder.decodeFrame(packet.getData(), data);
    };
    prototype.decodeFrame8Bit = function(packet, data) {
        return this.decoder.decodeFrame8Bit(packet.getData(), data);
    };
    prototype.canSeek = function(data) {
        return true;
    };
    prototype.allocatePicture = function() {
        return Picture.create(1920, 1088, ColorSpace.YUV444).getData();
    };
    prototype.getMediaInfo = function() {
        return new MediaInfo(new Size(0, 0));
    };
    prototype.allocatePicture8Bit = function() {
        return Picture8Bit.create(1920, 1088, ColorSpace.YUV444).getData();
    };
}, {decoder: "VideoDecoder"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  The decoder for yuv 10 bit 422
 *  
 *  x|x|9876543210(cr0)|9876543210(y0) |9876543210(cb0)
 *  x|x|9876543210(y2) |9876543210(cb1)|9876543210(y1)
 *  x|x|9876543210(cb2)|9876543210(y3) |9876543210(cr1)
 *  x|x|9876543210(y5) |9876543210(cr2)|9876543210(y4) 
 *  
 *  @author The JCodec project
 *  
 */
var V210Decoder = function(width, height) {
    this.width = width;
    this.height = height;
};
V210Decoder = stjs.extend(V210Decoder, null, [], function(constructor, prototype) {
    prototype.width = 0;
    prototype.height = 0;
    prototype.decode = function(data) {
        var littleEndian = ByteBuffer.wrap(data).order(ByteOrder.LITTLE_ENDIAN);
        var dat = littleEndian.asIntBuffer();
        var y = ByteBuffer.wrap(new Int8Array(this.width * this.height));
        var cb = ByteBuffer.wrap(new Int8Array(stjs.trunc(this.width * this.height / 2)));
        var cr = ByteBuffer.wrap(new Int8Array(stjs.trunc(this.width * this.height / 2)));
         while (dat.hasRemaining()){
            var i = dat.get();
            cr.put(this.to8Bit(i >> 20));
            y.put(this.to8Bit((i >> 10) & 1023));
            cb.put(this.to8Bit(i & 1023));
            i = dat.get();
            y.put(this.to8Bit(i & 1023));
            y.put(this.to8Bit(i >> 20));
            cb.put(this.to8Bit((i >> 10) & 1023));
            i = dat.get();
            cb.put(this.to8Bit(i >> 20));
            y.put(this.to8Bit((i >> 10) & 1023));
            cr.put(this.to8Bit(i & 1023));
            i = dat.get();
            y.put(this.to8Bit(i & 1023));
            y.put(this.to8Bit(i >> 20));
            cr.put(this.to8Bit((i >> 10) & 1023));
        }
        return Picture8Bit.createPicture8Bit(this.width, this.height, [y.array(), cb.array(), cr.array()], ColorSpace.YUV422);
    };
    prototype.to8Bit = function(i) {
        return ((((i + 2) >> 2) - 128) << 24 >> 24);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var PictureDisplayExtension = function() {};
PictureDisplayExtension = stjs.extend(PictureDisplayExtension, null, [MPEGHeader], function(constructor, prototype) {
    prototype.frame_centre_offsets = null;
    constructor.Picture_Display_Extension = 7;
    constructor.read = function(bits, se, pce) {
        var pde = new PictureDisplayExtension();
        pde.frame_centre_offsets = Array(PictureDisplayExtension.numberOfFrameCentreOffsets(se, pce));
        for (var i = 0; i < pde.frame_centre_offsets.length; i++) {
            var frame_centre_horizontal_offset = bits.readNBit(16);
            bits.read1Bit();
            var frame_centre_vertical_offset = bits.readNBit(16);
            bits.read1Bit();
            pde.frame_centre_offsets[i] = new Point(frame_centre_horizontal_offset, frame_centre_vertical_offset);
        }
        return pde;
    };
    constructor.numberOfFrameCentreOffsets = function(se, pce) {
        if (se == null || pce == null) 
             throw new IllegalArgumentException("PictureDisplayExtension requires SequenceExtension and PictureCodingExtension to be present");
        if (se.progressive_sequence == 1) {
            if (pce.repeat_first_field == 1) {
                if (pce.top_field_first == 1) 
                    return 3;
                 else 
                    return 2;
            } else {
                return 1;
            }
        } else {
            if (pce.picture_structure != PictureCodingExtension.Frame) {
                return 1;
            } else {
                if (pce.repeat_first_field == 1) 
                    return 3;
                 else 
                    return 2;
            }
        }
    };
    prototype.write = function(bb) {
        var bw = new BitWriter(bb);
        bw.writeNBit(PictureDisplayExtension.Picture_Display_Extension, 4);
        for (var i = 0; i < this.frame_centre_offsets.length; i++) {
            var point = this.frame_centre_offsets[i];
            bw.writeNBit(point.getX(), 16);
            bw.writeNBit(point.getY(), 16);
        }
        bw.flush();
    };
}, {frame_centre_offsets: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  prefix VLC reader builder
 *  
 *  @author The JCodec project
 *  
 */
var VLCBuilder = function() {
    this.forward = new IntIntMap();
    this.inverse = new IntIntMap();
    this.codes = IntArrayList.createIntArrayList();
    this.codesSizes = IntArrayList.createIntArrayList();
};
VLCBuilder = stjs.extend(VLCBuilder, null, [], function(constructor, prototype) {
    constructor.createVLCBuilder = function(codes, lens, vals) {
        var b = new VLCBuilder();
        for (var i = 0; i < codes.length; i++) {
            b.setInt(codes[i], lens[i], vals[i]);
        }
        return b;
    };
    prototype.forward = null;
    prototype.inverse = null;
    prototype.codes = null;
    prototype.codesSizes = null;
    prototype.set = function(val, code) {
        this.setInt(Integer.parseInt(code, 2), code.length, val);
        return this;
    };
    prototype.setInt = function(code, len, val) {
        this.codes.add(code << (32 - len));
        this.codesSizes.add(len);
        this.forward.put(val, this.codes.size() - 1);
        this.inverse.put(this.codes.size() - 1, val);
        return this;
    };
    prototype.getVLC = function() {
        var self = this;
        return new (stjs.extend(function VLCBuilder$1(x0, x1) {
            VLC.call(this, x0, x1);
        }, VLC, [], function(constructor, prototype) {
            prototype.readVLC = function(_in) {
                return self.inverse.get(VLC.prototype.readVLC.call(this, _in));
            };
            prototype.readVLC16 = function(_in) {
                return self.inverse.get(VLC.prototype.readVLC16.call(this, _in));
            };
            prototype.writeVLC = function(out, code) {
                VLC.prototype.writeVLC.call(this, out, self.forward.get(code));
            };
        }, {codes: "Int32Array", codeSizes: "Int32Array", values: "Int32Array", valueSizes: "Int32Array"}, {}))(this.codes.toArray(), this.codesSizes.toArray());
    };
}, {forward: "IntIntMap", inverse: "IntIntMap", codes: "IntArrayList", codesSizes: "IntArrayList"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var ColorUtil = function() {};
ColorUtil = stjs.extend(ColorUtil, null, [], function(constructor, prototype) {
    constructor.map = new HashMap();
    constructor.map8Bit = new HashMap();
    constructor.getTransform = function(from, to) {
        var map2 = ColorUtil.map.get(from);
        return map2 == null ? null : map2.get(to);
    };
    constructor.getTransform8Bit = function(from, to) {
        var map2 = ColorUtil.map8Bit.get(from);
        return map2 == null ? null : map2.get(to);
    };
    constructor.Idential = function() {};
    constructor.Idential = stjs.extend(constructor.Idential, null, [Transform], function(constructor, prototype) {
        prototype.transform = function(src, dst) {
            for (var i = 0; i < 3; i++) 
                System.arraycopy(src.getPlaneData(i), 0, dst.getPlaneData(i), 0, Math.min(src.getPlaneWidth(i) * src.getPlaneHeight(i), dst.getPlaneWidth(i) * dst.getPlaneHeight(i)));
        };
    }, {}, {});
    constructor.Idential8Bit = function() {};
    constructor.Idential8Bit = stjs.extend(constructor.Idential8Bit, null, [Transform8Bit], function(constructor, prototype) {
        prototype.transform = function(src, dst) {
            for (var i = 0; i < 3; i++) 
                System.arraycopy(src.getPlaneData(i), 0, dst.getPlaneData(i), 0, Math.min(src.getPlaneWidth(i) * src.getPlaneHeight(i), dst.getPlaneWidth(i) * dst.getPlaneHeight(i)));
        };
    }, {}, {});
}, {map: {name: "Map", arguments: ["ColorSpace", {name: "Map", arguments: ["ColorSpace", "Transform"]}]}, map8Bit: {name: "Map", arguments: ["ColorSpace", {name: "Map", arguments: ["ColorSpace", "Transform8Bit"]}]}}, {});
(function() {
    var rgb = new HashMap();
    rgb.put(ColorSpace.RGB, new ColorUtil.Idential());
    rgb.put(ColorSpace.YUV420, new RgbToYuv420p(0, 0));
    rgb.put(ColorSpace.YUV420J, new RgbToYuv420j());
    rgb.put(ColorSpace.YUV422, new RgbToYuv422p(0, 0));
    rgb.put(ColorSpace.YUV422_10, new RgbToYuv422p(2, 0));
    ColorUtil.map.put(ColorSpace.RGB, rgb);
    var yuv420 = new HashMap();
    yuv420.put(ColorSpace.YUV420, new ColorUtil.Idential());
    yuv420.put(ColorSpace.RGB, new Yuv420pToRgb(0, 0));
    yuv420.put(ColorSpace.YUV422, new Yuv420pToYuv422p(0, 0));
    yuv420.put(ColorSpace.YUV422_10, new Yuv420pToYuv422p(0, 2));
    ColorUtil.map.put(ColorSpace.YUV420, yuv420);
    var yuv422 = new HashMap();
    yuv422.put(ColorSpace.YUV422, new ColorUtil.Idential());
    yuv422.put(ColorSpace.RGB, new Yuv422pToRgb(0, 0));
    yuv422.put(ColorSpace.YUV420, new Yuv422pToYuv420p(0, 0));
    yuv422.put(ColorSpace.YUV420J, new Yuv422pToYuv420j(0, 0));
    ColorUtil.map.put(ColorSpace.YUV422, yuv422);
    var yuv422_10 = new HashMap();
    yuv422_10.put(ColorSpace.YUV422_10, new ColorUtil.Idential());
    yuv422_10.put(ColorSpace.RGB, new Yuv422pToRgb(2, 0));
    yuv422_10.put(ColorSpace.YUV420, new Yuv422pToYuv420p(0, 2));
    yuv422_10.put(ColorSpace.YUV420J, new Yuv422pToYuv420j(0, 2));
    ColorUtil.map.put(ColorSpace.YUV422_10, yuv422_10);
    var yuv444 = new HashMap();
    yuv444.put(ColorSpace.YUV444, new ColorUtil.Idential());
    yuv444.put(ColorSpace.RGB, new Yuv444pToRgb(0, 0));
    yuv444.put(ColorSpace.YUV420, new Yuv444pToYuv420p(0, 0));
    ColorUtil.map.put(ColorSpace.YUV444, yuv444);
    var yuv444_10 = new HashMap();
    yuv444_10.put(ColorSpace.YUV444_10, new ColorUtil.Idential());
    yuv444_10.put(ColorSpace.RGB, new Yuv444pToRgb(2, 0));
    yuv444_10.put(ColorSpace.YUV420, new Yuv444pToYuv420p(0, 2));
    ColorUtil.map.put(ColorSpace.YUV444_10, yuv444_10);
    var yuv420j = new HashMap();
    yuv420j.put(ColorSpace.YUV420J, new ColorUtil.Idential());
    yuv420j.put(ColorSpace.RGB, new Yuv420jToRgb());
    yuv420j.put(ColorSpace.YUV420, new Yuv420jToYuv420());
    ColorUtil.map.put(ColorSpace.YUV420J, yuv420j);
    var yuv422j = new HashMap();
    yuv422j.put(ColorSpace.YUV422J, new ColorUtil.Idential());
    yuv422j.put(ColorSpace.RGB, new Yuv422jToRgb());
    yuv422j.put(ColorSpace.YUV420, new Yuv422jToYuv420p());
    yuv422j.put(ColorSpace.YUV420J, new Yuv422pToYuv420p(0, 0));
    ColorUtil.map.put(ColorSpace.YUV422J, yuv422j);
    var yuv444j = new HashMap();
    yuv444j.put(ColorSpace.YUV444J, new ColorUtil.Idential());
    yuv444j.put(ColorSpace.RGB, new Yuv444jToRgb());
    yuv444j.put(ColorSpace.YUV420, new Yuv444jToYuv420p());
    yuv444j.put(ColorSpace.YUV420J, new Yuv444pToYuv420p(0, 0));
    ColorUtil.map.put(ColorSpace.YUV444J, yuv444j);
    var rgb8Bit = new HashMap();
    rgb8Bit.put(ColorSpace.RGB, new ColorUtil.Idential8Bit());
    rgb8Bit.put(ColorSpace.YUV420J, new RgbToYuv420j8Bit());
    rgb8Bit.put(ColorSpace.YUV420, new RgbToYuv420p8Bit());
    rgb8Bit.put(ColorSpace.YUV422, new RgbToYuv422p8Bit());
    ColorUtil.map8Bit.put(ColorSpace.RGB, rgb8Bit);
    var yuv4208Bit = new HashMap();
    yuv4208Bit.put(ColorSpace.YUV420, new ColorUtil.Idential8Bit());
    yuv4208Bit.put(ColorSpace.YUV422, new Yuv420pToYuv422p8Bit());
    yuv4208Bit.put(ColorSpace.RGB, new Yuv420pToRgb8Bit());
    ColorUtil.map8Bit.put(ColorSpace.YUV420, yuv4208Bit);
    var yuv4228Bit = new HashMap();
    yuv4228Bit.put(ColorSpace.YUV422, new ColorUtil.Idential8Bit());
    yuv4228Bit.put(ColorSpace.YUV420, new Yuv422pToYuv420p8Bit());
    yuv4228Bit.put(ColorSpace.RGB, new Yuv422pToRgb8Bit());
    ColorUtil.map8Bit.put(ColorSpace.YUV422, yuv4228Bit);
    var yuv4448Bit = new HashMap();
    yuv4448Bit.put(ColorSpace.YUV444, new ColorUtil.Idential8Bit());
    ColorUtil.map8Bit.put(ColorSpace.YUV444, yuv4448Bit);
    var yuv420j8Bit = new HashMap();
    yuv420j8Bit.put(ColorSpace.YUV420J, new ColorUtil.Idential8Bit());
    yuv420j8Bit.put(ColorSpace.RGB, new Yuv420jToRgb8Bit());
    ColorUtil.map8Bit.put(ColorSpace.YUV420J, yuv420j8Bit);
})();
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 * 
 *  @author in-somnia
 */
var MDCT = function(length) {
    this.N = length;
    this.N2 = length >> 1;
    this.N4 = length >> 2;
    this.N8 = length >> 3;
    switch (length) {
        case 2048:
            this.sincos = MDCTTables.MDCT_TABLE_2048;
            break;
        case 256:
            this.sincos = MDCTTables.MDCT_TABLE_128;
            break;
        case 1920:
            this.sincos = MDCTTables.MDCT_TABLE_1920;
            break;
        case 240:
            this.sincos = MDCTTables.MDCT_TABLE_240;
        default:
             throw new AACException("unsupported MDCT length: " + length);
    }
    this.fft = new FFT(this.N4);
    this.buf = Array.apply(null, Array(this.N4)).map(function() {
        return new Float32Array(2);
    });
    this.tmp = new Float32Array(2);
};
MDCT = stjs.extend(MDCT, null, [MDCTTables], function(constructor, prototype) {
    prototype.N = 0;
    prototype.N2 = 0;
    prototype.N4 = 0;
    prototype.N8 = 0;
    prototype.sincos = null;
    prototype.fft = null;
    prototype.buf = null;
    prototype.tmp = null;
    prototype.process = function(_in, inOff, out, outOff) {
        var k;
        for (k = 0; k < this.N4; k++) {
            this.buf[k][1] = (_in[inOff + 2 * k] * this.sincos[k][0]) + (_in[inOff + this.N2 - 1 - 2 * k] * this.sincos[k][1]);
            this.buf[k][0] = (_in[inOff + this.N2 - 1 - 2 * k] * this.sincos[k][0]) - (_in[inOff + 2 * k] * this.sincos[k][1]);
        }
        this.fft.process(this.buf, false);
        for (k = 0; k < this.N4; k++) {
            this.tmp[0] = this.buf[k][0];
            this.tmp[1] = this.buf[k][1];
            this.buf[k][1] = (this.tmp[1] * this.sincos[k][0]) + (this.tmp[0] * this.sincos[k][1]);
            this.buf[k][0] = (this.tmp[0] * this.sincos[k][0]) - (this.tmp[1] * this.sincos[k][1]);
        }
        for (k = 0; k < this.N8; k += 2) {
            out[outOff + 2 * k] = this.buf[this.N8 + k][1];
            out[outOff + 2 + 2 * k] = this.buf[this.N8 + 1 + k][1];
            out[outOff + 1 + 2 * k] = -this.buf[this.N8 - 1 - k][0];
            out[outOff + 3 + 2 * k] = -this.buf[this.N8 - 2 - k][0];
            out[outOff + this.N4 + 2 * k] = this.buf[k][0];
            out[outOff + this.N4 + 2 + 2 * k] = this.buf[1 + k][0];
            out[outOff + this.N4 + 1 + 2 * k] = -this.buf[this.N4 - 1 - k][1];
            out[outOff + this.N4 + 3 + 2 * k] = -this.buf[this.N4 - 2 - k][1];
            out[outOff + this.N2 + 2 * k] = this.buf[this.N8 + k][0];
            out[outOff + this.N2 + 2 + 2 * k] = this.buf[this.N8 + 1 + k][0];
            out[outOff + this.N2 + 1 + 2 * k] = -this.buf[this.N8 - 1 - k][1];
            out[outOff + this.N2 + 3 + 2 * k] = -this.buf[this.N8 - 2 - k][1];
            out[outOff + this.N2 + this.N4 + 2 * k] = -this.buf[k][1];
            out[outOff + this.N2 + this.N4 + 2 + 2 * k] = -this.buf[1 + k][1];
            out[outOff + this.N2 + this.N4 + 1 + 2 * k] = this.buf[this.N4 - 1 - k][0];
            out[outOff + this.N2 + this.N4 + 3 + 2 * k] = this.buf[this.N4 - 2 - k][0];
        }
    };
    prototype.processForward = function(_in, out) {
        var n, k;
        for (k = 0; k < this.N8; k++) {
            n = k << 1;
            this.tmp[0] = _in[this.N - this.N4 - 1 - n] + _in[this.N - this.N4 + n];
            this.tmp[1] = _in[this.N4 + n] - _in[this.N4 - 1 - n];
            this.buf[k][0] = (this.tmp[0] * this.sincos[k][0]) + (this.tmp[1] * this.sincos[k][1]);
            this.buf[k][1] = (this.tmp[1] * this.sincos[k][0]) - (this.tmp[0] * this.sincos[k][1]);
            this.buf[k][0] *= this.N;
            this.buf[k][1] *= this.N;
            this.tmp[0] = _in[this.N2 - 1 - n] - _in[n];
            this.tmp[1] = _in[this.N2 + n] + _in[this.N - 1 - n];
            this.buf[k + this.N8][0] = (this.tmp[0] * this.sincos[k + this.N8][0]) + (this.tmp[1] * this.sincos[k + this.N8][1]);
            this.buf[k + this.N8][1] = (this.tmp[1] * this.sincos[k + this.N8][0]) - (this.tmp[0] * this.sincos[k + this.N8][1]);
            this.buf[k + this.N8][0] *= this.N;
            this.buf[k + this.N8][1] *= this.N;
        }
        this.fft.process(this.buf, true);
        for (k = 0; k < this.N4; k++) {
            n = k << 1;
            this.tmp[0] = (this.buf[k][0] * this.sincos[k][0]) + (this.buf[k][1] * this.sincos[k][1]);
            this.tmp[1] = (this.buf[k][1] * this.sincos[k][0]) - (this.buf[k][0] * this.sincos[k][1]);
            out[n] = -this.tmp[0];
            out[this.N2 - 1 - n] = this.tmp[1];
            out[this.N2 + n] = -this.tmp[1];
            out[this.N - 1 - n] = this.tmp[0];
        }
    };
}, {sincos: "Array", fft: "FFT", buf: "Array", tmp: "Float32Array", MDCT_TABLE_2048: "Array", MDCT_TABLE_128: "Array", MDCT_TABLE_1920: "Array", MDCT_TABLE_240: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Rational = function(num, den) {
    this.num = num;
    this.den = den;
};
Rational = stjs.extend(Rational, null, [], function(constructor, prototype) {
    constructor.ONE = new Rational(1, 1);
    constructor.HALF = new Rational(1, 2);
    constructor.ZERO = new Rational(0, 1);
    prototype.num = 0;
    prototype.den = 0;
    constructor.R = function(num, den) {
        return new Rational(num, den);
    };
    constructor.R1 = function(num) {
        return Rational.R(num, 1);
    };
    prototype.getNum = function() {
        return this.num;
    };
    prototype.getDen = function() {
        return this.den;
    };
    constructor.parse = function(string) {
        var split = StringUtils.splitS(string, ":");
        return new Rational(Integer.parseInt(split[0]), Integer.parseInt(split[1]));
    };
    prototype.hashCode = function() {
        var prime = 31;
        var result = 1;
        result = prime * result + this.den;
        result = prime * result + this.num;
        return result;
    };
    prototype.equals = function(obj) {
        if (this == obj) 
            return true;
        if (obj == null) 
            return false;
        if (this.getClass() != obj.getClass()) 
            return false;
        var other = obj;
        if (this.den != other.den) 
            return false;
        if (this.num != other.num) 
            return false;
        return true;
    };
    prototype.multiplyS = function(val) {
        return (((stjs.trunc((stjs.trunc(this.num) * val) / this.den))) | 0);
    };
    prototype.divideS = function(val) {
        return (((stjs.trunc((stjs.trunc(this.den) * val) / this.num))) | 0);
    };
    prototype.divideByS = function(val) {
        return stjs.trunc(this.num / (this.den * val));
    };
    prototype.multiplyLong = function(val) {
        return stjs.trunc((this.num * val) / this.den);
    };
    prototype.divideLong = function(val) {
        return stjs.trunc((this.den * val) / this.num);
    };
    prototype.flip = function() {
        return new Rational(this.den, this.num);
    };
    prototype.smallerThen = function(sec) {
        return this.num * sec.den < sec.num * this.den;
    };
    prototype.greaterThen = function(sec) {
        return this.num * sec.den > sec.num * this.den;
    };
    prototype.smallerOrEqualTo = function(sec) {
        return this.num * sec.den <= sec.num * this.den;
    };
    prototype.greaterOrEqualTo = function(sec) {
        return this.num * sec.den >= sec.num * this.den;
    };
    prototype.equalsRational = function(other) {
        return this.num * other.den == other.num * this.den;
    };
    prototype.plus = function(other) {
        return Rational.reduce(this.num * other.den + other.num * this.den, this.den * other.den);
    };
    prototype.plusLarge = function(other) {
        return RationalLarge.reduceLong(this.num * other.den + other.num * this.den, this.den * other.den);
    };
    prototype.minus = function(other) {
        return Rational.reduce(this.num * other.den - other.num * this.den, this.den * other.den);
    };
    prototype.minusLarge = function(other) {
        return RationalLarge.reduceLong(this.num * other.den - other.num * this.den, this.den * other.den);
    };
    prototype.plusInt = function(scalar) {
        return new Rational(this.num + scalar * this.den, this.den);
    };
    prototype.minusInt = function(scalar) {
        return new Rational(this.num - scalar * this.den, this.den);
    };
    prototype.multiplyInt = function(scalar) {
        return new Rational(this.num * scalar, this.den);
    };
    prototype.divideInt = function(scalar) {
        return new Rational(this.den * scalar, this.num);
    };
    prototype.divideByInt = function(scalar) {
        return new Rational(this.num, this.den * scalar);
    };
    prototype.multiply = function(other) {
        return Rational.reduce(this.num * other.num, this.den * other.den);
    };
    prototype.multiplyLarge = function(other) {
        return RationalLarge.reduceLong(this.num * other.num, this.den * other.den);
    };
    prototype.divide = function(other) {
        return Rational.reduce(other.num * this.den, other.den * this.num);
    };
    prototype.divideLarge = function(other) {
        return RationalLarge.reduceLong(other.num * this.den, other.den * this.num);
    };
    prototype.divideBy = function(other) {
        return Rational.reduce(this.num * other.den, this.den * other.num);
    };
    prototype.divideByLarge = function(other) {
        return RationalLarge.reduceLong(this.num * other.den, this.den * other.num);
    };
    prototype.scalar = function() {
        return this.num / this.den;
    };
    prototype.scalarClip = function() {
        return stjs.trunc(this.num / this.den);
    };
    constructor.reduce = function(num, den) {
        var gcd = MathUtil.gcd(num, den);
        return new Rational(stjs.trunc(num / gcd), stjs.trunc(den / gcd));
    };
    constructor.reduceRational = function(r) {
        return Rational.reduce(r.getNum(), r.getDen());
    };
}, {ONE: "Rational", HALF: "Rational", ZERO: "Rational"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Encoded stream packet
 *  
 *  @author The JCodec project
 *  
 */
var Packet = function(data, pts, timescale, duration, frameNo, keyFrame, tapeTimecode, displayOrder) {
    this.data = data;
    this.pts = pts;
    this.timescale = timescale;
    this.duration = duration;
    this.frameNo = frameNo;
    this.keyFrame = keyFrame;
    this.tapeTimecode = tapeTimecode;
    this.displayOrder = displayOrder;
};
Packet = stjs.extend(Packet, null, [], function(constructor, prototype) {
    prototype.data = null;
    prototype.pts = 0;
    prototype.timescale = 0;
    prototype.duration = 0;
    prototype.frameNo = 0;
    prototype.keyFrame = false;
    prototype.tapeTimecode = null;
    prototype.displayOrder = 0;
    constructor.createPacket = function(data, pts, timescale, duration, frameNo, keyFrame, tapeTimecode) {
        return new Packet(data, pts, timescale, duration, frameNo, keyFrame, tapeTimecode, 0);
    };
    constructor.createPacketWithData = function(other, data) {
        return new Packet(data, other.pts, other.timescale, other.duration, other.frameNo, other.keyFrame, other.tapeTimecode, other.displayOrder);
    };
    prototype.getData = function() {
        return this.data.duplicate();
    };
    prototype.getPts = function() {
        return this.pts;
    };
    prototype.getTimescale = function() {
        return this.timescale;
    };
    prototype.getDuration = function() {
        return this.duration;
    };
    prototype.getFrameNo = function() {
        return this.frameNo;
    };
    prototype.setTimescale = function(timescale) {
        this.timescale = timescale;
    };
    prototype.getTapeTimecode = function() {
        return this.tapeTimecode;
    };
    prototype.setTapeTimecode = function(tapeTimecode) {
        this.tapeTimecode = tapeTimecode;
    };
    prototype.getDisplayOrder = function() {
        return this.displayOrder;
    };
    prototype.setDisplayOrder = function(displayOrder) {
        this.displayOrder = displayOrder;
    };
    prototype.isKeyFrame = function() {
        return this.keyFrame;
    };
    prototype.setKeyFrame = function(keyFrame) {
        this.keyFrame = keyFrame;
    };
    prototype.getPtsR = function() {
        return RationalLarge.R(this.pts, this.timescale);
    };
    prototype.getPtsD = function() {
        return (this.pts) / this.timescale;
    };
    prototype.getDurationD = function() {
        return (this.duration) / this.timescale;
    };
    prototype.setData = function(data) {
        this.data = data;
    };
    constructor.FRAME_ASC = new (stjs.extend(function Packet$1() {}, null, [Comparator], function(constructor, prototype) {
        prototype.compare = function(o1, o2) {
            if (o1 == null && o2 == null) 
                return 0;
            if (o1 == null) 
                return -1;
            if (o2 == null) 
                return 1;
            return o1.frameNo < o2.frameNo ? -1 : (o1.frameNo == o2.frameNo ? 0 : 1);
        };
    }, {}, {}))();
    prototype.setDuration = function(duration) {
        this.duration = duration;
    };
}, {data: "ByteBuffer", tapeTimecode: "TapeTimecode", FRAME_ASC: {name: "Comparator", arguments: ["Packet"]}}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 * 
 *  @author in-somnia
 */
var PS = function(sr, numTimeSlotsRate) {
    this.border_position = new Int32Array(PSConstants.MAX_PS_ENVELOPES + 1);
    this.iid_dt = new Int8Array(PSConstants.MAX_PS_ENVELOPES);
    this.icc_dt = new Int8Array(PSConstants.MAX_PS_ENVELOPES);
    this.ipd_dt = new Int8Array(PSConstants.MAX_PS_ENVELOPES);
    this.opd_dt = new Int8Array(PSConstants.MAX_PS_ENVELOPES);
    this.iid_index_prev = new Int32Array(34);
    this.icc_index_prev = new Int32Array(34);
    this.ipd_index_prev = new Int32Array(17);
    this.opd_index_prev = new Int32Array(17);
    this.iid_index = Array.apply(null, Array(PSConstants.MAX_PS_ENVELOPES)).map(function() {
        return new Int32Array(34);
    });
    this.icc_index = Array.apply(null, Array(PSConstants.MAX_PS_ENVELOPES)).map(function() {
        return new Int32Array(34);
    });
    this.ipd_index = Array.apply(null, Array(PSConstants.MAX_PS_ENVELOPES)).map(function() {
        return new Int32Array(17);
    });
    this.opd_index = Array.apply(null, Array(PSConstants.MAX_PS_ENVELOPES)).map(function() {
        return new Int32Array(17);
    });
    this.ipd_index_1 = new Int32Array(17);
    this.opd_index_1 = new Int32Array(17);
    this.ipd_index_2 = new Int32Array(17);
    this.opd_index_2 = new Int32Array(17);
    this.delay_buf_index_ser = new Int32Array(PSConstants.NO_ALLPASS_LINKS);
    this.num_sample_delay_ser = new Int32Array(PSConstants.NO_ALLPASS_LINKS);
    this.delay_D = new Int32Array(64);
    this.delay_buf_index_delay = new Int32Array(64);
    this.delay_Qmf = Array.apply(null, Array(14)).map(function() {
        return Array.apply(null, Array(64)).map(function() {
            return new Float32Array(2);
        });
    });
    this.delay_SubQmf = Array.apply(null, Array(2)).map(function() {
        return Array.apply(null, Array(32)).map(function() {
            return new Float32Array(2);
        });
    });
    this.delay_Qmf_ser = Array.apply(null, Array(PSConstants.NO_ALLPASS_LINKS)).map(function() {
        return Array.apply(null, Array(5)).map(function() {
            return Array.apply(null, Array(64)).map(function() {
                return new Float32Array(2);
            });
        });
    });
    this.delay_SubQmf_ser = Array.apply(null, Array(PSConstants.NO_ALLPASS_LINKS)).map(function() {
        return Array.apply(null, Array(5)).map(function() {
            return Array.apply(null, Array(32)).map(function() {
                return new Float32Array(2);
            });
        });
    });
    this.P_PeakDecayNrg = new Float32Array(34);
    this.P_prev = new Float32Array(34);
    this.P_SmoothPeakDecayDiffNrg_prev = new Float32Array(34);
    this.h11_prev = Array.apply(null, Array(50)).map(function() {
        return new Float32Array(2);
    });
    this.h12_prev = Array.apply(null, Array(50)).map(function() {
        return new Float32Array(2);
    });
    this.h21_prev = Array.apply(null, Array(50)).map(function() {
        return new Float32Array(2);
    });
    this.h22_prev = Array.apply(null, Array(50)).map(function() {
        return new Float32Array(2);
    });
    this.ipd_prev = Array.apply(null, Array(20)).map(function() {
        return Array.apply(null, Array(2)).map(function() {
            return new Float32Array(2);
        });
    });
    this.opd_prev = Array.apply(null, Array(20)).map(function() {
        return Array.apply(null, Array(2)).map(function() {
            return new Float32Array(2);
        });
    });
    var i;
    var short_delay_band;
    this.hyb = new PSFilterbank(numTimeSlotsRate);
    this.numTimeSlotsRate = numTimeSlotsRate;
    this.ps_data_available = 0;
    this.saved_delay = 0;
    for (i = 0; i < 64; i++) {
        this.delay_buf_index_delay[i] = 0;
    }
    for (i = 0; i < PSConstants.NO_ALLPASS_LINKS; i++) {
        this.delay_buf_index_ser[i] = 0;
        this.num_sample_delay_ser[i] = PSTables.delay_length_d[i];
    }
    short_delay_band = 35;
    this.nr_allpass_bands = 22;
    this.alpha_decay = 0.7659283;
    this.alpha_smooth = 0.25;
    for (i = 0; i < short_delay_band; i++) {
        this.delay_D[i] = 14;
    }
    for (i = short_delay_band; i < 64; i++) {
        this.delay_D[i] = 1;
    }
    for (i = 0; i < 50; i++) {
        this.h11_prev[i][0] = 1;
        this.h12_prev[i][1] = 1;
        this.h11_prev[i][0] = 1;
        this.h12_prev[i][1] = 1;
    }
    this.phase_hist = 0;
    for (i = 0; i < 20; i++) {
        this.ipd_prev[i][0][0] = 0;
        this.ipd_prev[i][0][1] = 0;
        this.ipd_prev[i][1][0] = 0;
        this.ipd_prev[i][1][1] = 0;
        this.opd_prev[i][0][0] = 0;
        this.opd_prev[i][0][1] = 0;
        this.opd_prev[i][1][0] = 0;
        this.opd_prev[i][1][1] = 0;
    }
};
PS = stjs.extend(PS, null, [PSConstants, PSTables, PSHuffmanTables], function(constructor, prototype) {
    prototype.enable_iid = false;
    prototype.enable_icc = false;
    prototype.enable_ext = false;
    prototype.iid_mode = 0;
    prototype.icc_mode = 0;
    prototype.nr_iid_par = 0;
    prototype.nr_ipdopd_par = 0;
    prototype.nr_icc_par = 0;
    prototype.frame_class = 0;
    prototype.num_env = 0;
    prototype.border_position = null;
    prototype.iid_dt = null;
    prototype.icc_dt = null;
    prototype.enable_ipdopd = false;
    prototype.ipd_mode = 0;
    prototype.ipd_dt = null;
    prototype.opd_dt = null;
    prototype.iid_index_prev = null;
    prototype.icc_index_prev = null;
    prototype.ipd_index_prev = null;
    prototype.opd_index_prev = null;
    prototype.iid_index = null;
    prototype.icc_index = null;
    prototype.ipd_index = null;
    prototype.opd_index = null;
    prototype.ipd_index_1 = null;
    prototype.opd_index_1 = null;
    prototype.ipd_index_2 = null;
    prototype.opd_index_2 = null;
    prototype.ps_data_available = 0;
    prototype.header_read = false;
    prototype.hyb = null;
    prototype.use34hybrid_bands = false;
    prototype.numTimeSlotsRate = 0;
    prototype.num_groups = 0;
    prototype.num_hybrid_groups = 0;
    prototype.nr_par_bands = 0;
    prototype.nr_allpass_bands = 0;
    prototype.decay_cutoff = 0;
    prototype.group_border = null;
    prototype.map_group2bk = null;
    prototype.saved_delay = 0;
    prototype.delay_buf_index_ser = null;
    prototype.num_sample_delay_ser = null;
    prototype.delay_D = null;
    prototype.delay_buf_index_delay = null;
    prototype.delay_Qmf = null;
    prototype.delay_SubQmf = null;
    prototype.delay_Qmf_ser = null;
    prototype.delay_SubQmf_ser = null;
    prototype.alpha_decay = 0.0;
    prototype.alpha_smooth = 0.0;
    prototype.P_PeakDecayNrg = null;
    prototype.P_prev = null;
    prototype.P_SmoothPeakDecayDiffNrg_prev = null;
    prototype.h11_prev = null;
    prototype.h12_prev = null;
    prototype.h21_prev = null;
    prototype.h22_prev = null;
    prototype.phase_hist = 0;
    prototype.ipd_prev = null;
    prototype.opd_prev = null;
    prototype.decode = function(ld) {
        var tmp, n;
        var bits = ld.getPosition();
        if (ld.readBool()) {
            this.header_read = true;
            this.use34hybrid_bands = false;
            this.enable_iid = ld.readBool();
            if (this.enable_iid) {
                this.iid_mode = ld.readBits(3);
                this.nr_iid_par = PSTables.nr_iid_par_tab[this.iid_mode];
                this.nr_ipdopd_par = PSTables.nr_ipdopd_par_tab[this.iid_mode];
                if (this.iid_mode == 2 || this.iid_mode == 5) 
                    this.use34hybrid_bands = true;
                this.ipd_mode = this.iid_mode;
            }
            this.enable_icc = ld.readBool();
            if (this.enable_icc) {
                this.icc_mode = ld.readBits(3);
                this.nr_icc_par = PSTables.nr_icc_par_tab[this.icc_mode];
                if (this.icc_mode == 2 || this.icc_mode == 5) 
                    this.use34hybrid_bands = true;
            }
            this.enable_ext = ld.readBool();
        }
        if (this.header_read == false) {
            this.ps_data_available = 0;
            return 1;
        }
        this.frame_class = ld.readBit();
        tmp = ld.readBits(2);
        this.num_env = PSTables.num_env_tab[this.frame_class][tmp];
        if (this.frame_class != 0) {
            for (n = 1; n < this.num_env + 1; n++) {
                this.border_position[n] = ld.readBits(5) + 1;
            }
        }
        if (this.enable_iid) {
            for (n = 0; n < this.num_env; n++) {
                this.iid_dt[n] = ld.readBool();
                if (this.iid_mode < 3) {
                    this.huff_data(ld, this.iid_dt[n], this.nr_iid_par, PSHuffmanTables.t_huff_iid_def, PSHuffmanTables.f_huff_iid_def, this.iid_index[n]);
                } else {
                    this.huff_data(ld, this.iid_dt[n], this.nr_iid_par, PSHuffmanTables.t_huff_iid_fine, PSHuffmanTables.f_huff_iid_fine, this.iid_index[n]);
                }
            }
        }
        if (this.enable_icc) {
            for (n = 0; n < this.num_env; n++) {
                this.icc_dt[n] = ld.readBool();
                this.huff_data(ld, this.icc_dt[n], this.nr_icc_par, PSHuffmanTables.t_huff_icc, PSHuffmanTables.f_huff_icc, this.icc_index[n]);
            }
        }
        if (this.enable_ext) {
            var num_bits_left;
            var cnt = ld.readBits(4);
            if (cnt == 15) {
                cnt += ld.readBits(8);
            }
            num_bits_left = 8 * cnt;
             while (num_bits_left > 7){
                var ps_extension_id = ld.readBits(2);
                num_bits_left -= 2;
                num_bits_left -= this.ps_extension(ld, ps_extension_id, num_bits_left);
            }
            ld.skipBits(num_bits_left);
        }
        var bits2 = (((ld.getPosition() - bits)) | 0);
        this.ps_data_available = 1;
        return bits2;
    };
    prototype.ps_extension = function(ld, ps_extension_id, num_bits_left) {
        var n;
        var bits = ld.getPosition();
        if (ps_extension_id == 0) {
            this.enable_ipdopd = ld.readBool();
            if (this.enable_ipdopd) {
                for (n = 0; n < this.num_env; n++) {
                    this.ipd_dt[n] = ld.readBool();
                    this.huff_data(ld, this.ipd_dt[n], this.nr_ipdopd_par, PSHuffmanTables.t_huff_ipd, PSHuffmanTables.f_huff_ipd, this.ipd_index[n]);
                    this.opd_dt[n] = ld.readBool();
                    this.huff_data(ld, this.opd_dt[n], this.nr_ipdopd_par, PSHuffmanTables.t_huff_opd, PSHuffmanTables.f_huff_opd, this.opd_index[n]);
                }
            }
            ld.readBit();
        }
        var bits2 = (((ld.getPosition() - bits)) | 0);
        return bits2;
    };
    prototype.huff_data = function(ld, dt, nr_par, t_huff, f_huff, par) {
        var n;
        if (dt) {
            for (n = 0; n < nr_par; n++) {
                par[n] = this.ps_huff_dec(ld, t_huff);
            }
        } else {
            par[0] = this.ps_huff_dec(ld, f_huff);
            for (n = 1; n < nr_par; n++) {
                par[n] = this.ps_huff_dec(ld, f_huff);
            }
        }
    };
    prototype.ps_huff_dec = function(ld, t_huff) {
        var bit;
        var index = 0;
         while (index >= 0){
            bit = ld.readBit();
            index = t_huff[index][bit];
        }
        return index + 31;
    };
    prototype.delta_clip = function(i, min, max) {
        if (i < min) 
            return min;
         else if (i > max) 
            return max;
         else 
            return i;
    };
    prototype.delta_decode = function(enable, index, index_prev, dt_flag, nr_par, stride, min_index, max_index) {
        var i;
        if (enable) {
            if (!dt_flag) {
                index[0] = 0 + index[0];
                index[0] = this.delta_clip(index[0], min_index, max_index);
                for (i = 1; i < nr_par; i++) {
                    index[i] = index[i - 1] + index[i];
                    index[i] = this.delta_clip(index[i], min_index, max_index);
                }
            } else {
                for (i = 0; i < nr_par; i++) {
                    index[i] = index_prev[i * stride] + index[i];
                    index[i] = this.delta_clip(index[i], min_index, max_index);
                }
            }
        } else {
            for (i = 0; i < nr_par; i++) {
                index[i] = 0;
            }
        }
        if (stride == 2) {
            for (i = (nr_par << 1) - 1; i > 0; i--) {
                index[i] = index[i >> 1];
            }
        }
    };
    prototype.delta_modulo_decode = function(enable, index, index_prev, dt_flag, nr_par, stride, and_modulo) {
        var i;
        if (enable) {
            if (!dt_flag) {
                index[0] = 0 + index[0];
                index[0] &= and_modulo;
                for (i = 1; i < nr_par; i++) {
                    index[i] = index[i - 1] + index[i];
                    index[i] &= and_modulo;
                }
            } else {
                for (i = 0; i < nr_par; i++) {
                    index[i] = index_prev[i * stride] + index[i];
                    index[i] &= and_modulo;
                }
            }
        } else {
            for (i = 0; i < nr_par; i++) {
                index[i] = 0;
            }
        }
        if (stride == 2) {
            index[0] = 0;
            for (i = (nr_par << 1) - 1; i > 0; i--) {
                index[i] = index[i >> 1];
            }
        }
    };
    prototype.map20indexto34 = function(index, bins) {
        index[1] = stjs.trunc((index[0] + index[1]) / 2);
        index[2] = index[1];
        index[3] = index[2];
        index[4] = stjs.trunc((index[2] + index[3]) / 2);
        index[5] = index[3];
        index[6] = index[4];
        index[7] = index[4];
        index[8] = index[5];
        index[9] = index[5];
        index[10] = index[6];
        index[11] = index[7];
        index[12] = index[8];
        index[13] = index[8];
        index[14] = index[9];
        index[15] = index[9];
        index[16] = index[10];
        if (bins == 34) {
            index[17] = index[11];
            index[18] = index[12];
            index[19] = index[13];
            index[20] = index[14];
            index[21] = index[14];
            index[22] = index[15];
            index[23] = index[15];
            index[24] = index[16];
            index[25] = index[16];
            index[26] = index[17];
            index[27] = index[17];
            index[28] = index[18];
            index[29] = index[18];
            index[30] = index[18];
            index[31] = index[18];
            index[32] = index[19];
            index[33] = index[19];
        }
    };
    prototype.ps_data_decode = function() {
        var env, bin;
        if (this.ps_data_available == 0) {
            this.num_env = 0;
        }
        for (env = 0; env < this.num_env; env++) {
            var iid_index_prev;
            var icc_index_prev;
            var ipd_index_prev;
            var opd_index_prev;
            var num_iid_steps = (this.iid_mode < 3) ? 7 : 15;
            if (env == 0) {
                iid_index_prev = this.iid_index_prev;
                icc_index_prev = this.icc_index_prev;
                ipd_index_prev = this.ipd_index_prev;
                opd_index_prev = this.opd_index_prev;
            } else {
                iid_index_prev = this.iid_index[env - 1];
                icc_index_prev = this.icc_index[env - 1];
                ipd_index_prev = this.ipd_index[env - 1];
                opd_index_prev = this.opd_index[env - 1];
            }
            this.delta_decode(this.enable_iid, this.iid_index[env], iid_index_prev, this.iid_dt[env], this.nr_iid_par, (this.iid_mode == 0 || this.iid_mode == 3) ? 2 : 1, -num_iid_steps, num_iid_steps);
            this.delta_decode(this.enable_icc, this.icc_index[env], icc_index_prev, this.icc_dt[env], this.nr_icc_par, (this.icc_mode == 0 || this.icc_mode == 3) ? 2 : 1, 0, 7);
            this.delta_modulo_decode(this.enable_ipdopd, this.ipd_index[env], ipd_index_prev, this.ipd_dt[env], this.nr_ipdopd_par, 1, 7);
            this.delta_modulo_decode(this.enable_ipdopd, this.opd_index[env], opd_index_prev, this.opd_dt[env], this.nr_ipdopd_par, 1, 7);
        }
        if (this.num_env == 0) {
            this.num_env = 1;
            if (this.enable_iid) {
                for (bin = 0; bin < 34; bin++) {
                    this.iid_index[0][bin] = this.iid_index_prev[bin];
                }
            } else {
                for (bin = 0; bin < 34; bin++) {
                    this.iid_index[0][bin] = 0;
                }
            }
            if (this.enable_icc) {
                for (bin = 0; bin < 34; bin++) {
                    this.icc_index[0][bin] = this.icc_index_prev[bin];
                }
            } else {
                for (bin = 0; bin < 34; bin++) {
                    this.icc_index[0][bin] = 0;
                }
            }
            if (this.enable_ipdopd) {
                for (bin = 0; bin < 17; bin++) {
                    this.ipd_index[0][bin] = this.ipd_index_prev[bin];
                    this.opd_index[0][bin] = this.opd_index_prev[bin];
                }
            } else {
                for (bin = 0; bin < 17; bin++) {
                    this.ipd_index[0][bin] = 0;
                    this.opd_index[0][bin] = 0;
                }
            }
        }
        for (bin = 0; bin < 34; bin++) {
            this.iid_index_prev[bin] = this.iid_index[this.num_env - 1][bin];
        }
        for (bin = 0; bin < 34; bin++) {
            this.icc_index_prev[bin] = this.icc_index[this.num_env - 1][bin];
        }
        for (bin = 0; bin < 17; bin++) {
            this.ipd_index_prev[bin] = this.ipd_index[this.num_env - 1][bin];
            this.opd_index_prev[bin] = this.opd_index[this.num_env - 1][bin];
        }
        this.ps_data_available = 0;
        if (this.frame_class == 0) {
            this.border_position[0] = 0;
            for (env = 1; env < this.num_env; env++) {
                this.border_position[env] = stjs.trunc((env * this.numTimeSlotsRate) / this.num_env);
            }
            this.border_position[this.num_env] = this.numTimeSlotsRate;
        } else {
            this.border_position[0] = 0;
            if (this.border_position[this.num_env] < this.numTimeSlotsRate) {
                for (bin = 0; bin < 34; bin++) {
                    this.iid_index[this.num_env][bin] = this.iid_index[this.num_env - 1][bin];
                    this.icc_index[this.num_env][bin] = this.icc_index[this.num_env - 1][bin];
                }
                for (bin = 0; bin < 17; bin++) {
                    this.ipd_index[this.num_env][bin] = this.ipd_index[this.num_env - 1][bin];
                    this.opd_index[this.num_env][bin] = this.opd_index[this.num_env - 1][bin];
                }
                this.num_env++;
                this.border_position[this.num_env] = this.numTimeSlotsRate;
            }
            for (env = 1; env < this.num_env; env++) {
                var thr = this.numTimeSlotsRate - (this.num_env - env);
                if (this.border_position[env] > thr) {
                    this.border_position[env] = thr;
                } else {
                    thr = this.border_position[env - 1] + 1;
                    if (this.border_position[env] < thr) {
                        this.border_position[env] = thr;
                    }
                }
            }
        }
        if (this.use34hybrid_bands) {
            for (env = 0; env < this.num_env; env++) {
                if (this.iid_mode != 2 && this.iid_mode != 5) 
                    this.map20indexto34(this.iid_index[env], 34);
                if (this.icc_mode != 2 && this.icc_mode != 5) 
                    this.map20indexto34(this.icc_index[env], 34);
                if (this.ipd_mode != 2 && this.ipd_mode != 5) {
                    this.map20indexto34(this.ipd_index[env], 17);
                    this.map20indexto34(this.opd_index[env], 17);
                }
            }
        }
    };
    prototype.ps_decorrelate = function(X_left, X_right, X_hybrid_left, X_hybrid_right) {
        var gr, n, m, bk;
        var temp_delay = 0;
        var sb, maxsb;
        var temp_delay_ser = new Int32Array(PSConstants.NO_ALLPASS_LINKS);
        var P_SmoothPeakDecayDiffNrg, nrg;
        var P = Array.apply(null, Array(32)).map(function() {
            return new Float32Array(34);
        });
        var G_TransientRatio = Array.apply(null, Array(32)).map(function() {
            return new Float32Array(34);
        });
        var inputLeft = new Float32Array(2);
        var Phi_Fract_SubQmf;
        if (this.use34hybrid_bands) {
            Phi_Fract_SubQmf = PSTables.Phi_Fract_SubQmf34;
        } else {
            Phi_Fract_SubQmf = PSTables.Phi_Fract_SubQmf20;
        }
        for (n = 0; n < 32; n++) {
            for (bk = 0; bk < 34; bk++) {
                P[n][bk] = 0;
            }
        }
        for (gr = 0; gr < this.num_groups; gr++) {
            bk = (~PSConstants.NEGATE_IPD_MASK) & this.map_group2bk[gr];
            maxsb = (gr < this.num_hybrid_groups) ? this.group_border[gr] + 1 : this.group_border[gr + 1];
            for (sb = this.group_border[gr]; sb < maxsb; sb++) {
                for (n = this.border_position[0]; n < this.border_position[this.num_env]; n++) {
                    if (gr < this.num_hybrid_groups) {
                        inputLeft[0] = X_hybrid_left[n][sb][0];
                        inputLeft[1] = X_hybrid_left[n][sb][1];
                    } else {
                        inputLeft[0] = X_left[n][sb][0];
                        inputLeft[1] = X_left[n][sb][1];
                    }
                    P[n][bk] += (inputLeft[0] * inputLeft[0]) + (inputLeft[1] * inputLeft[1]);
                }
            }
        }
        for (bk = 0; bk < this.nr_par_bands; bk++) {
            for (n = this.border_position[0]; n < this.border_position[this.num_env]; n++) {
                var gamma = 1.5;
                this.P_PeakDecayNrg[bk] = (this.P_PeakDecayNrg[bk] * this.alpha_decay);
                if (this.P_PeakDecayNrg[bk] < P[n][bk]) 
                    this.P_PeakDecayNrg[bk] = P[n][bk];
                P_SmoothPeakDecayDiffNrg = this.P_SmoothPeakDecayDiffNrg_prev[bk];
                P_SmoothPeakDecayDiffNrg += ((this.P_PeakDecayNrg[bk] - P[n][bk] - this.P_SmoothPeakDecayDiffNrg_prev[bk]) * this.alpha_smooth);
                this.P_SmoothPeakDecayDiffNrg_prev[bk] = P_SmoothPeakDecayDiffNrg;
                nrg = this.P_prev[bk];
                nrg += ((P[n][bk] - this.P_prev[bk]) * this.alpha_smooth);
                this.P_prev[bk] = nrg;
                if ((P_SmoothPeakDecayDiffNrg * gamma) <= nrg) {
                    G_TransientRatio[n][bk] = 1.0;
                } else {
                    G_TransientRatio[n][bk] = (nrg / (P_SmoothPeakDecayDiffNrg * gamma));
                }
            }
        }
        for (gr = 0; gr < this.num_groups; gr++) {
            if (gr < this.num_hybrid_groups) 
                maxsb = this.group_border[gr] + 1;
             else 
                maxsb = this.group_border[gr + 1];
            for (sb = this.group_border[gr]; sb < maxsb; sb++) {
                var g_DecaySlope;
                var g_DecaySlope_filt = new Float32Array(PSConstants.NO_ALLPASS_LINKS);
                if (gr < this.num_hybrid_groups || sb <= this.decay_cutoff) {
                    g_DecaySlope = 1.0;
                } else {
                    var decay = this.decay_cutoff - sb;
                    if (decay <= -20) {
                        g_DecaySlope = 0;
                    } else {
                        g_DecaySlope = 1.0 + PSConstants.DECAY_SLOPE * decay;
                    }
                }
                for (m = 0; m < PSConstants.NO_ALLPASS_LINKS; m++) {
                    g_DecaySlope_filt[m] = g_DecaySlope * PSTables.filter_a[m];
                }
                temp_delay = this.saved_delay;
                for (n = 0; n < PSConstants.NO_ALLPASS_LINKS; n++) {
                    temp_delay_ser[n] = this.delay_buf_index_ser[n];
                }
                for (n = this.border_position[0]; n < this.border_position[this.num_env]; n++) {
                    var tmp = new Float32Array(2), tmp0 = new Float32Array(2), R0 = new Float32Array(2);
                    if (gr < this.num_hybrid_groups) {
                        inputLeft[0] = X_hybrid_left[n][sb][0];
                        inputLeft[1] = X_hybrid_left[n][sb][1];
                    } else {
                        inputLeft[0] = X_left[n][sb][0];
                        inputLeft[1] = X_left[n][sb][1];
                    }
                    if (sb > this.nr_allpass_bands && gr >= this.num_hybrid_groups) {
                        tmp[0] = this.delay_Qmf[this.delay_buf_index_delay[sb]][sb][0];
                        tmp[1] = this.delay_Qmf[this.delay_buf_index_delay[sb]][sb][1];
                        R0[0] = tmp[0];
                        R0[1] = tmp[1];
                        this.delay_Qmf[this.delay_buf_index_delay[sb]][sb][0] = inputLeft[0];
                        this.delay_Qmf[this.delay_buf_index_delay[sb]][sb][1] = inputLeft[1];
                    } else {
                        var Phi_Fract = new Float32Array(2);
                        if (gr < this.num_hybrid_groups) {
                            tmp0[0] = this.delay_SubQmf[temp_delay][sb][0];
                            tmp0[1] = this.delay_SubQmf[temp_delay][sb][1];
                            this.delay_SubQmf[temp_delay][sb][0] = inputLeft[0];
                            this.delay_SubQmf[temp_delay][sb][1] = inputLeft[1];
                            Phi_Fract[0] = Phi_Fract_SubQmf[sb][0];
                            Phi_Fract[1] = Phi_Fract_SubQmf[sb][1];
                        } else {
                            tmp0[0] = this.delay_Qmf[temp_delay][sb][0];
                            tmp0[1] = this.delay_Qmf[temp_delay][sb][1];
                            this.delay_Qmf[temp_delay][sb][0] = inputLeft[0];
                            this.delay_Qmf[temp_delay][sb][1] = inputLeft[1];
                            Phi_Fract[0] = PSTables.Phi_Fract_Qmf[sb][0];
                            Phi_Fract[1] = PSTables.Phi_Fract_Qmf[sb][1];
                        }
                        tmp[0] = (tmp[0] * Phi_Fract[0]) + (tmp0[1] * Phi_Fract[1]);
                        tmp[1] = (tmp0[1] * Phi_Fract[0]) - (tmp0[0] * Phi_Fract[1]);
                        R0[0] = tmp[0];
                        R0[1] = tmp[1];
                        for (m = 0; m < PSConstants.NO_ALLPASS_LINKS; m++) {
                            var Q_Fract_allpass = new Float32Array(2), tmp2 = new Float32Array(2);
                            if (gr < this.num_hybrid_groups) {
                                tmp0[0] = this.delay_SubQmf_ser[m][temp_delay_ser[m]][sb][0];
                                tmp0[1] = this.delay_SubQmf_ser[m][temp_delay_ser[m]][sb][1];
                                if (this.use34hybrid_bands) {
                                    Q_Fract_allpass[0] = PSTables.Q_Fract_allpass_SubQmf34[sb][m][0];
                                    Q_Fract_allpass[1] = PSTables.Q_Fract_allpass_SubQmf34[sb][m][1];
                                } else {
                                    Q_Fract_allpass[0] = PSTables.Q_Fract_allpass_SubQmf20[sb][m][0];
                                    Q_Fract_allpass[1] = PSTables.Q_Fract_allpass_SubQmf20[sb][m][1];
                                }
                            } else {
                                tmp0[0] = this.delay_Qmf_ser[m][temp_delay_ser[m]][sb][0];
                                tmp0[1] = this.delay_Qmf_ser[m][temp_delay_ser[m]][sb][1];
                                Q_Fract_allpass[0] = PSTables.Q_Fract_allpass_Qmf[sb][m][0];
                                Q_Fract_allpass[1] = PSTables.Q_Fract_allpass_Qmf[sb][m][1];
                            }
                            tmp[0] = (tmp0[0] * Q_Fract_allpass[0]) + (tmp0[1] * Q_Fract_allpass[1]);
                            tmp[1] = (tmp0[1] * Q_Fract_allpass[0]) - (tmp0[0] * Q_Fract_allpass[1]);
                            tmp[0] += -(g_DecaySlope_filt[m] * R0[0]);
                            tmp[1] += -(g_DecaySlope_filt[m] * R0[1]);
                            tmp2[0] = R0[0] + (g_DecaySlope_filt[m] * tmp[0]);
                            tmp2[1] = R0[1] + (g_DecaySlope_filt[m] * tmp[1]);
                            if (gr < this.num_hybrid_groups) {
                                this.delay_SubQmf_ser[m][temp_delay_ser[m]][sb][0] = tmp2[0];
                                this.delay_SubQmf_ser[m][temp_delay_ser[m]][sb][1] = tmp2[1];
                            } else {
                                this.delay_Qmf_ser[m][temp_delay_ser[m]][sb][0] = tmp2[0];
                                this.delay_Qmf_ser[m][temp_delay_ser[m]][sb][1] = tmp2[1];
                            }
                            R0[0] = tmp[0];
                            R0[1] = tmp[1];
                        }
                    }
                    bk = (~PSConstants.NEGATE_IPD_MASK) & this.map_group2bk[gr];
                    R0[0] = (G_TransientRatio[n][bk] * R0[0]);
                    R0[1] = (G_TransientRatio[n][bk] * R0[1]);
                    if (gr < this.num_hybrid_groups) {
                        X_hybrid_right[n][sb][0] = R0[0];
                        X_hybrid_right[n][sb][1] = R0[1];
                    } else {
                        X_right[n][sb][0] = R0[0];
                        X_right[n][sb][1] = R0[1];
                    }
                    if (++temp_delay >= 2) {
                        temp_delay = 0;
                    }
                    if (sb > this.nr_allpass_bands && gr >= this.num_hybrid_groups) {
                        if (++this.delay_buf_index_delay[sb] >= this.delay_D[sb]) {
                            this.delay_buf_index_delay[sb] = 0;
                        }
                    }
                    for (m = 0; m < PSConstants.NO_ALLPASS_LINKS; m++) {
                        if (++temp_delay_ser[m] >= this.num_sample_delay_ser[m]) {
                            temp_delay_ser[m] = 0;
                        }
                    }
                }
            }
        }
        this.saved_delay = temp_delay;
        for (m = 0; m < PSConstants.NO_ALLPASS_LINKS; m++) {
            this.delay_buf_index_ser[m] = temp_delay_ser[m];
        }
    };
    prototype.magnitude_c = function(c) {
        return Math.sqrt(c[0] * c[0] + c[1] * c[1]);
    };
    prototype.ps_mix_phase = function(X_left, X_right, X_hybrid_left, X_hybrid_right) {
        var n;
        var gr;
        var bk = 0;
        var sb, maxsb;
        var env;
        var nr_ipdopd_par;
        var h11 = new Float32Array(2), h12 = new Float32Array(2), h21 = new Float32Array(2), h22 = new Float32Array(2);
        var H11 = new Float32Array(2), H12 = new Float32Array(2), H21 = new Float32Array(2), H22 = new Float32Array(2);
        var deltaH11 = new Float32Array(2), deltaH12 = new Float32Array(2), deltaH21 = new Float32Array(2), deltaH22 = new Float32Array(2);
        var tempLeft = new Float32Array(2);
        var tempRight = new Float32Array(2);
        var phaseLeft = new Float32Array(2);
        var phaseRight = new Float32Array(2);
        var L;
        var sf_iid;
        var no_iid_steps;
        if (this.iid_mode >= 3) {
            no_iid_steps = 15;
            sf_iid = PSTables.sf_iid_fine;
        } else {
            no_iid_steps = 7;
            sf_iid = PSTables.sf_iid_normal;
        }
        if (this.ipd_mode == 0 || this.ipd_mode == 3) {
            nr_ipdopd_par = 11;
        } else {
            nr_ipdopd_par = this.nr_ipdopd_par;
        }
        for (gr = 0; gr < this.num_groups; gr++) {
            bk = (~PSConstants.NEGATE_IPD_MASK) & this.map_group2bk[gr];
            maxsb = (gr < this.num_hybrid_groups) ? this.group_border[gr] + 1 : this.group_border[gr + 1];
            for (env = 0; env < this.num_env; env++) {
                if (this.icc_mode < 3) {
                    var c_1, c_2;
                    var cosa, sina;
                    var cosb, sinb;
                    var ab1, ab2;
                    var ab3, ab4;
                    c_1 = sf_iid[no_iid_steps + this.iid_index[env][bk]];
                    c_2 = sf_iid[no_iid_steps - this.iid_index[env][bk]];
                    cosa = PSTables.cos_alphas[this.icc_index[env][bk]];
                    sina = PSTables.sin_alphas[this.icc_index[env][bk]];
                    if (this.iid_mode >= 3) {
                        if (this.iid_index[env][bk] < 0) {
                            cosb = PSTables.cos_betas_fine[-this.iid_index[env][bk]][this.icc_index[env][bk]];
                            sinb = -PSTables.sin_betas_fine[-this.iid_index[env][bk]][this.icc_index[env][bk]];
                        } else {
                            cosb = PSTables.cos_betas_fine[this.iid_index[env][bk]][this.icc_index[env][bk]];
                            sinb = PSTables.sin_betas_fine[this.iid_index[env][bk]][this.icc_index[env][bk]];
                        }
                    } else {
                        if (this.iid_index[env][bk] < 0) {
                            cosb = PSTables.cos_betas_normal[-this.iid_index[env][bk]][this.icc_index[env][bk]];
                            sinb = -PSTables.sin_betas_normal[-this.iid_index[env][bk]][this.icc_index[env][bk]];
                        } else {
                            cosb = PSTables.cos_betas_normal[this.iid_index[env][bk]][this.icc_index[env][bk]];
                            sinb = PSTables.sin_betas_normal[this.iid_index[env][bk]][this.icc_index[env][bk]];
                        }
                    }
                    ab1 = (cosb * cosa);
                    ab2 = (sinb * sina);
                    ab3 = (sinb * cosa);
                    ab4 = (cosb * sina);
                    h11[0] = (c_2 * (ab1 - ab2));
                    h12[0] = (c_1 * (ab1 + ab2));
                    h21[0] = (c_2 * (ab3 + ab4));
                    h22[0] = (c_1 * (ab3 - ab4));
                } else {
                    var sina, cosa;
                    var cosg, sing;
                    if (this.iid_mode >= 3) {
                        var abs_iid = Math.abs(this.iid_index[env][bk]);
                        cosa = PSTables.sincos_alphas_B_fine[no_iid_steps + this.iid_index[env][bk]][this.icc_index[env][bk]];
                        sina = PSTables.sincos_alphas_B_fine[30 - (no_iid_steps + this.iid_index[env][bk])][this.icc_index[env][bk]];
                        cosg = PSTables.cos_gammas_fine[abs_iid][this.icc_index[env][bk]];
                        sing = PSTables.sin_gammas_fine[abs_iid][this.icc_index[env][bk]];
                    } else {
                        var abs_iid = Math.abs(this.iid_index[env][bk]);
                        cosa = PSTables.sincos_alphas_B_normal[no_iid_steps + this.iid_index[env][bk]][this.icc_index[env][bk]];
                        sina = PSTables.sincos_alphas_B_normal[14 - (no_iid_steps + this.iid_index[env][bk])][this.icc_index[env][bk]];
                        cosg = PSTables.cos_gammas_normal[abs_iid][this.icc_index[env][bk]];
                        sing = PSTables.sin_gammas_normal[abs_iid][this.icc_index[env][bk]];
                    }
                    h11[0] = (PSConstants.COEF_SQRT2 * (cosa * cosg));
                    h12[0] = (PSConstants.COEF_SQRT2 * (sina * cosg));
                    h21[0] = (PSConstants.COEF_SQRT2 * (-cosa * sing));
                    h22[0] = (PSConstants.COEF_SQRT2 * (sina * sing));
                }
                if ((this.enable_ipdopd) && (bk < nr_ipdopd_par)) {
                    var xy, pq, xypq;
                    var i = this.phase_hist;
                    tempLeft[0] = (this.ipd_prev[bk][i][0] * 0.25);
                    tempLeft[1] = (this.ipd_prev[bk][i][1] * 0.25);
                    tempRight[0] = (this.opd_prev[bk][i][0] * 0.25);
                    tempRight[1] = (this.opd_prev[bk][i][1] * 0.25);
                    this.ipd_prev[bk][i][0] = PSTables.ipdopd_cos_tab[Math.abs(this.ipd_index[env][bk])];
                    this.ipd_prev[bk][i][1] = PSTables.ipdopd_sin_tab[Math.abs(this.ipd_index[env][bk])];
                    this.opd_prev[bk][i][0] = PSTables.ipdopd_cos_tab[Math.abs(this.opd_index[env][bk])];
                    this.opd_prev[bk][i][1] = PSTables.ipdopd_sin_tab[Math.abs(this.opd_index[env][bk])];
                    tempLeft[0] += this.ipd_prev[bk][i][0];
                    tempLeft[1] += this.ipd_prev[bk][i][1];
                    tempRight[0] += this.opd_prev[bk][i][0];
                    tempRight[1] += this.opd_prev[bk][i][1];
                    if (i == 0) {
                        i = 2;
                    }
                    i--;
                    tempLeft[0] += (this.ipd_prev[bk][i][0] * 0.5);
                    tempLeft[1] += (this.ipd_prev[bk][i][1] * 0.5);
                    tempRight[0] += (this.opd_prev[bk][i][0] * 0.5);
                    tempRight[1] += (this.opd_prev[bk][i][1] * 0.5);
                    xy = this.magnitude_c(tempRight);
                    pq = this.magnitude_c(tempLeft);
                    if (xy != 0) {
                        phaseLeft[0] = (tempRight[0] / xy);
                        phaseLeft[1] = (tempRight[1] / xy);
                    } else {
                        phaseLeft[0] = 0;
                        phaseLeft[1] = 0;
                    }
                    xypq = (xy * pq);
                    if (xypq != 0) {
                        var tmp1 = (tempRight[0] * tempLeft[0]) + (tempRight[1] * tempLeft[1]);
                        var tmp2 = (tempRight[1] * tempLeft[0]) - (tempRight[0] * tempLeft[1]);
                        phaseRight[0] = (tmp1 / xypq);
                        phaseRight[1] = (tmp2 / xypq);
                    } else {
                        phaseRight[0] = 0;
                        phaseRight[1] = 0;
                    }
                    h11[1] = (h11[0] * phaseLeft[1]);
                    h12[1] = (h12[0] * phaseRight[1]);
                    h21[1] = (h21[0] * phaseLeft[1]);
                    h22[1] = (h22[0] * phaseRight[1]);
                    h11[0] = (h11[0] * phaseLeft[0]);
                    h12[0] = (h12[0] * phaseRight[0]);
                    h21[0] = (h21[0] * phaseLeft[0]);
                    h22[0] = (h22[0] * phaseRight[0]);
                }
                L = (this.border_position[env + 1] - this.border_position[env]);
                deltaH11[0] = (h11[0] - this.h11_prev[gr][0]) / L;
                deltaH12[0] = (h12[0] - this.h12_prev[gr][0]) / L;
                deltaH21[0] = (h21[0] - this.h21_prev[gr][0]) / L;
                deltaH22[0] = (h22[0] - this.h22_prev[gr][0]) / L;
                H11[0] = this.h11_prev[gr][0];
                H12[0] = this.h12_prev[gr][0];
                H21[0] = this.h21_prev[gr][0];
                H22[0] = this.h22_prev[gr][0];
                this.h11_prev[gr][0] = h11[0];
                this.h12_prev[gr][0] = h12[0];
                this.h21_prev[gr][0] = h21[0];
                this.h22_prev[gr][0] = h22[0];
                if ((this.enable_ipdopd) && (bk < nr_ipdopd_par)) {
                    deltaH11[1] = (h11[1] - this.h11_prev[gr][1]) / L;
                    deltaH12[1] = (h12[1] - this.h12_prev[gr][1]) / L;
                    deltaH21[1] = (h21[1] - this.h21_prev[gr][1]) / L;
                    deltaH22[1] = (h22[1] - this.h22_prev[gr][1]) / L;
                    H11[1] = this.h11_prev[gr][1];
                    H12[1] = this.h12_prev[gr][1];
                    H21[1] = this.h21_prev[gr][1];
                    H22[1] = this.h22_prev[gr][1];
                    if ((PSConstants.NEGATE_IPD_MASK & this.map_group2bk[gr]) != 0) {
                        deltaH11[1] = -deltaH11[1];
                        deltaH12[1] = -deltaH12[1];
                        deltaH21[1] = -deltaH21[1];
                        deltaH22[1] = -deltaH22[1];
                        H11[1] = -H11[1];
                        H12[1] = -H12[1];
                        H21[1] = -H21[1];
                        H22[1] = -H22[1];
                    }
                    this.h11_prev[gr][1] = h11[1];
                    this.h12_prev[gr][1] = h12[1];
                    this.h21_prev[gr][1] = h21[1];
                    this.h22_prev[gr][1] = h22[1];
                }
                for (n = this.border_position[env]; n < this.border_position[env + 1]; n++) {
                    H11[0] += deltaH11[0];
                    H12[0] += deltaH12[0];
                    H21[0] += deltaH21[0];
                    H22[0] += deltaH22[0];
                    if ((this.enable_ipdopd) && (bk < nr_ipdopd_par)) {
                        H11[1] += deltaH11[1];
                        H12[1] += deltaH12[1];
                        H21[1] += deltaH21[1];
                        H22[1] += deltaH22[1];
                    }
                    for (sb = this.group_border[gr]; sb < maxsb; sb++) {
                        var inLeft = new Float32Array(2), inRight = new Float32Array(2);
                        if (gr < this.num_hybrid_groups) {
                            inLeft[0] = X_hybrid_left[n][sb][0];
                            inLeft[1] = X_hybrid_left[n][sb][1];
                            inRight[0] = X_hybrid_right[n][sb][0];
                            inRight[1] = X_hybrid_right[n][sb][1];
                        } else {
                            inLeft[0] = X_left[n][sb][0];
                            inLeft[1] = X_left[n][sb][1];
                            inRight[0] = X_right[n][sb][0];
                            inRight[1] = X_right[n][sb][1];
                        }
                        tempLeft[0] = (H11[0] * inLeft[0]) + (H21[0] * inRight[0]);
                        tempLeft[1] = (H11[0] * inLeft[1]) + (H21[0] * inRight[1]);
                        tempRight[0] = (H12[0] * inLeft[0]) + (H22[0] * inRight[0]);
                        tempRight[1] = (H12[0] * inLeft[1]) + (H22[0] * inRight[1]);
                        if ((this.enable_ipdopd) && (bk < nr_ipdopd_par)) {
                            tempLeft[0] -= (H11[1] * inLeft[1]) + (H21[1] * inRight[1]);
                            tempLeft[1] += (H11[1] * inLeft[0]) + (H21[1] * inRight[0]);
                            tempRight[0] -= (H12[1] * inLeft[1]) + (H22[1] * inRight[1]);
                            tempRight[1] += (H12[1] * inLeft[0]) + (H22[1] * inRight[0]);
                        }
                        if (gr < this.num_hybrid_groups) {
                            X_hybrid_left[n][sb][0] = tempLeft[0];
                            X_hybrid_left[n][sb][1] = tempLeft[1];
                            X_hybrid_right[n][sb][0] = tempRight[0];
                            X_hybrid_right[n][sb][1] = tempRight[1];
                        } else {
                            X_left[n][sb][0] = tempLeft[0];
                            X_left[n][sb][1] = tempLeft[1];
                            X_right[n][sb][0] = tempRight[0];
                            X_right[n][sb][1] = tempRight[1];
                        }
                    }
                }
                this.phase_hist++;
                if (this.phase_hist == 2) {
                    this.phase_hist = 0;
                }
            }
        }
    };
    prototype.process = function(X_left, X_right) {
        var X_hybrid_left = Array.apply(null, Array(32)).map(function() {
            return Array.apply(null, Array(32)).map(function() {
                return new Float32Array(2);
            });
        });
        var X_hybrid_right = Array.apply(null, Array(32)).map(function() {
            return Array.apply(null, Array(32)).map(function() {
                return new Float32Array(2);
            });
        });
        this.ps_data_decode();
        if (this.use34hybrid_bands) {
            this.group_border = PSTables.group_border34;
            this.map_group2bk = PSTables.map_group2bk34;
            this.num_groups = 32 + 18;
            this.num_hybrid_groups = 32;
            this.nr_par_bands = 34;
            this.decay_cutoff = 5;
        } else {
            this.group_border = PSTables.group_border20;
            this.map_group2bk = PSTables.map_group2bk20;
            this.num_groups = 10 + 12;
            this.num_hybrid_groups = 10;
            this.nr_par_bands = 20;
            this.decay_cutoff = 3;
        }
        this.hyb.hybrid_analysis(X_left, X_hybrid_left, this.use34hybrid_bands, this.numTimeSlotsRate);
        this.ps_decorrelate(X_left, X_right, X_hybrid_left, X_hybrid_right);
        this.ps_mix_phase(X_left, X_right, X_hybrid_left, X_hybrid_right);
        this.hyb.hybrid_synthesis(X_left, X_hybrid_left, this.use34hybrid_bands, this.numTimeSlotsRate);
        this.hyb.hybrid_synthesis(X_right, X_hybrid_right, this.use34hybrid_bands, this.numTimeSlotsRate);
        return 0;
    };
}, {border_position: "Int32Array", iid_dt: "Int8Array", icc_dt: "Int8Array", ipd_dt: "Int8Array", opd_dt: "Int8Array", iid_index_prev: "Int32Array", icc_index_prev: "Int32Array", ipd_index_prev: "Int32Array", opd_index_prev: "Int32Array", iid_index: "Array", icc_index: "Array", ipd_index: "Array", opd_index: "Array", ipd_index_1: "Int32Array", opd_index_1: "Int32Array", ipd_index_2: "Int32Array", opd_index_2: "Int32Array", hyb: "PSFilterbank", group_border: "Int32Array", map_group2bk: "Int32Array", delay_buf_index_ser: "Int32Array", num_sample_delay_ser: "Int32Array", delay_D: "Int32Array", delay_buf_index_delay: "Int32Array", delay_Qmf: "Array", delay_SubQmf: "Array", delay_Qmf_ser: "Array", delay_SubQmf_ser: "Array", P_PeakDecayNrg: "Float32Array", P_prev: "Float32Array", P_SmoothPeakDecayDiffNrg_prev: "Float32Array", h11_prev: "Array", h12_prev: "Array", h21_prev: "Array", h22_prev: "Array", ipd_prev: "Array", opd_prev: "Array", nr_iid_par_tab: "Int32Array", nr_icc_par_tab: "Int32Array", nr_ipdopd_par_tab: "Int32Array", num_env_tab: "Array", filter_a: "Float32Array", group_border20: "Int32Array", group_border34: "Int32Array", map_group2bk20: "Int32Array", map_group2bk34: "Int32Array", delay_length_d: "Int32Array", p8_13_20: "Float32Array", p2_13_20: "Float32Array", p12_13_34: "Float32Array", p8_13_34: "Float32Array", p4_13_34: "Float32Array", Phi_Fract_Qmf: "Array", Phi_Fract_SubQmf20: "Array", Phi_Fract_SubQmf34: "Array", Q_Fract_allpass_Qmf: "Array", Q_Fract_allpass_SubQmf20: "Array", Q_Fract_allpass_SubQmf34: "Array", cos_alphas: "Float32Array", sin_alphas: "Float32Array", cos_betas_normal: "Array", sin_betas_normal: "Array", cos_betas_fine: "Array", sin_betas_fine: "Array", sincos_alphas_B_normal: "Array", sincos_alphas_B_fine: "Array", cos_gammas_normal: "Array", cos_gammas_fine: "Array", sin_gammas_normal: "Array", sin_gammas_fine: "Array", sf_iid_normal: "Float32Array", sf_iid_fine: "Float32Array", ipdopd_cos_tab: "Float32Array", ipdopd_sin_tab: "Float32Array", f_huff_iid_def: "Array", t_huff_iid_def: "Array", f_huff_iid_fine: "Array", t_huff_iid_fine: "Array", f_huff_icc: "Array", t_huff_icc: "Array", f_huff_ipd: "Array", t_huff_ipd: "Array", f_huff_opd: "Array", t_huff_opd: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A class responsible for outputting exp-Golomb values into binary stream
 *  
 *  @author The JCodec project
 *  
 */
var CAVLCWriter = function() {};
CAVLCWriter = stjs.extend(CAVLCWriter, null, [], function(constructor, prototype) {
    constructor.writeUtrace = function(out, value, n, message) {
        out.writeNBit(value, n);
        Debug.trace(message, value);
    };
    constructor.writeUE = function(out, value) {
        var bits = 0;
        var cumul = 0;
        for (var i = 0; i < 15; i++) {
            if (value < cumul + (1 << i)) {
                bits = i;
                break;
            }
            cumul += (1 << i);
        }
        out.writeNBit(0, bits);
        out.write1Bit(1);
        out.writeNBit(value - cumul, bits);
    };
    constructor.writeSE = function(out, value) {
        CAVLCWriter.writeUE(out, MathUtil.golomb(value));
    };
    constructor.writeUEtrace = function(out, value, message) {
        CAVLCWriter.writeUE(out, value);
        Debug.trace(message, value);
    };
    constructor.writeSEtrace = function(out, value, message) {
        CAVLCWriter.writeUE(out, MathUtil.golomb(value));
        Debug.trace(message, value);
    };
    constructor.writeTE = function(out, value, max) {
        if (max > 1) 
            CAVLCWriter.writeUE(out, value);
         else 
            out.write1Bit(~value & 1);
    };
    constructor.writeBool = function(out, value, message) {
        out.write1Bit(value ? 1 : 0);
        Debug.trace(message, value ? 1 : 0);
    };
    constructor.writeU = function(out, i, n) {
        out.writeNBit(i, n);
    };
    constructor.writeNBit = function(out, value, n, message) {
        for (var i = 0; i < n; i++) {
            out.write1Bit((((value >> (n - i - 1))) | 0) & 1);
        }
        Debug.trace(message, value);
    };
    constructor.writeTrailingBits = function(out) {
        out.write1Bit(1);
        out.flush();
    };
    constructor.writeSliceTrailingBits = function() {
         throw new NotImplementedException("todo");
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var CAVLCReader = function() {};
CAVLCReader = stjs.extend(CAVLCReader, null, [], function(constructor, prototype) {
    constructor.readNBit = function(bits, n, message) {
        var val = bits.readNBit(n);
        Debug.trace(message, val);
        return val;
    };
    constructor.readUE = function(bits) {
        var cnt = 0;
         while (bits.read1Bit() == 0 && cnt < 32)
            cnt++;
        var res = 0;
        if (cnt > 0) {
            var val = bits.readNBit(cnt);
            res = ((((1 << cnt) - 1 + val)) | 0);
        }
        return res;
    };
    constructor.readUEtrace = function(bits, message) {
        var res = CAVLCReader.readUE(bits);
        Debug.trace(message, res);
        return res;
    };
    constructor.readSE = function(bits, message) {
        var val = CAVLCReader.readUE(bits);
        val = H264Utils2.golomb2Signed(val);
        Debug.trace(message, val);
        return val;
    };
    constructor.readBool = function(bits, message) {
        var res = bits.read1Bit() == 0 ? false : true;
        Debug.trace(message, res ? 1 : 0);
        return res;
    };
    constructor.readU = function(bits, i, string) {
        return stjs.trunc(CAVLCReader.readNBit(bits, i, string));
    };
    constructor.readTE = function(bits, max) {
        if (max > 1) 
            return CAVLCReader.readUE(bits);
        return ~bits.read1Bit() & 1;
    };
    constructor.readME = function(bits, string) {
        return CAVLCReader.readUEtrace(bits, string);
    };
    constructor.readZeroBitCount = function(bits, message) {
        var count = 0;
         while (bits.read1Bit() == 0 && count < 32)
            count++;
        if (Debug.debug) 
            Debug.trace(message, String.valueOf(count));
        return count;
    };
    constructor.moreRBSPData = function(bits) {
        return !(bits.remaining() < 32 && bits.checkNBit(1) == 1 && (bits.checkNBit(24) << 9) == 0);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var NIOUtils = function() {};
NIOUtils = stjs.extend(NIOUtils, null, [], function(constructor, prototype) {
    constructor.search = function(buffer, n, param) {
        var result = buffer.duplicate();
        var step = 0, rem = buffer.position();
         while (buffer.hasRemaining()){
            var b = buffer.get();
            if (b == param[step]) {
                ++step;
                if (step == param.length) {
                    if (n == 0) {
                        buffer.setPosition(rem);
                        result.setLimit(buffer.position());
                        break;
                    }
                    n--;
                    step = 0;
                }
            } else {
                if (step != 0) {
                    step = 0;
                    ++rem;
                    buffer.setPosition(rem);
                } else 
                    rem = buffer.position();
            }
        }
        return result;
    };
    constructor.read = function(buffer, count) {
        var slice = buffer.duplicate();
        var limit = buffer.position() + count;
        slice.setLimit(limit);
        buffer.setPosition(limit);
        return slice;
    };
    constructor.fetchFromFile = function(file) {
        return NIOUtils.fetchFromFileL(file, ((file.length()) | 0));
    };
    constructor.fetchFromChannel = function(ch, size) {
        var buf = ByteBuffer.allocate(size);
        NIOUtils.readFromChannel(ch, buf);
        buf.flip();
        return buf;
    };
    /**
     *  Reads size amount of bytes from ch into a new ByteBuffer allocated from a
     *  buffer buf
     *  
     *  @param buf
     *  @param ch
     *  @param size
     *  @return
     *  @throws IOException
     */
    constructor.fetchFrom = function(buf, ch, size) {
        var result = buf.duplicate();
        result.setLimit(size);
        NIOUtils.readFromChannel(ch, result);
        result.flip();
        return result;
    };
    constructor.fetchFromFileL = function(file, length) {
        var is = null;
        try {
            is = new FileInputStream(file).getChannel();
            return NIOUtils.fetchFromChannel(is, length);
        } finally {
            NIOUtils.closeQuietly(is);
        }
    };
    constructor.writeTo = function(buffer, file) {
        var out = null;
        try {
            out = new FileOutputStream(file).getChannel();
            out.write(buffer);
        } finally {
            NIOUtils.closeQuietly(out);
        }
    };
    constructor.toArray = function(buffer) {
        var result = new Int8Array(buffer.remaining());
        buffer.duplicate().getBuf(result);
        return result;
    };
    constructor.toArrayL = function(buffer, count) {
        var result = new Int8Array(Math.min(buffer.remaining(), count));
        buffer.duplicate().getBuf(result);
        return result;
    };
    constructor.readL = function(channel, buffer, length) {
        var fork = buffer.duplicate();
        fork.setLimit(Math.min(fork.position() + length, fork.limit()));
        var read;
         while ((read = channel.read(fork)) != -1 && fork.hasRemaining())
            ;
        if (read == -1) 
            return -1;
        buffer.setPosition(fork.position());
        return read;
    };
    constructor.readFromChannel = function(channel, buffer) {
        var rem = buffer.position();
         while (channel.read(buffer) != -1 && buffer.hasRemaining())
            ;
        return buffer.position() - rem;
    };
    constructor.write = function(to, from) {
        if (from.hasArray()) {
            to.put3(from.array(), from.arrayOffset() + from.position(), Math.min(to.remaining(), from.remaining()));
        } else {
            to.putArr(NIOUtils.toArrayL(from, to.remaining()));
        }
    };
    constructor.writeL = function(to, from, count) {
        if (from.hasArray()) {
            to.put3(from.array(), from.arrayOffset() + from.position(), Math.min(from.remaining(), count));
        } else {
            to.putArr(NIOUtils.toArrayL(from, count));
        }
    };
    constructor.fill = function(buffer, val) {
         while (buffer.hasRemaining())
            buffer.put(val);
    };
    constructor.map = function(fileName) {
        return NIOUtils.mapFile(new File(fileName));
    };
    constructor.mapFile = function(file) {
        var is = new FileInputStream(file);
        var map = is.getChannel().map(FileChannel.MapMode.READ_ONLY, 0, file.length());
        is.close();
        return map;
    };
    constructor.skip = function(buffer, count) {
        var toSkip = Math.min(buffer.remaining(), count);
        buffer.setPosition(buffer.position() + toSkip);
        return toSkip;
    };
    constructor.from = function(buffer, offset) {
        var dup = buffer.duplicate();
        dup.setPosition(dup.position() + offset);
        return dup;
    };
    constructor.combineBuffers = function(picture) {
        var size = 0;
        for (var iterator$byteBuffer = picture.iterator(); iterator$byteBuffer.hasNext(); ) {
            var byteBuffer = iterator$byteBuffer.next();
            size += byteBuffer.remaining();
        }
        var result = ByteBuffer.allocate(size);
        for (var iterator$byteBuffer = picture.iterator(); iterator$byteBuffer.hasNext(); ) {
            var byteBuffer = iterator$byteBuffer.next();
            NIOUtils.write(result, byteBuffer);
        }
        result.flip();
        return result;
    };
    constructor.combine = function(_arguments) {
        return NIOUtils.combineBuffers(Arrays.asList(arguments));
    };
    constructor.readString = function(buffer, len) {
        return Platform.stringFromBytes(NIOUtils.toArray(NIOUtils.read(buffer, len)));
    };
    constructor.readPascalStringL = function(buffer, maxLen) {
        var sub = NIOUtils.read(buffer, maxLen + 1);
        return Platform.stringFromBytes(NIOUtils.toArray(NIOUtils.read(sub, Math.min(sub.get() & 255, maxLen))));
    };
    constructor.writePascalStringL = function(buffer, string, maxLen) {
        buffer.put((string.length << 24 >> 24));
        buffer.putArr(NIOUtils.asciiString(string));
        NIOUtils.skip(buffer, maxLen - string.length);
    };
    constructor.asciiString = function(fourcc) {
        return Platform.getBytes(fourcc);
    };
    constructor.writePascalString = function(buffer, name) {
        buffer.put((name.length << 24 >> 24));
        buffer.putArr(NIOUtils.asciiString(name));
    };
    constructor.readPascalString = function(buffer) {
        return NIOUtils.readString(buffer, buffer.get() & 255);
    };
    constructor.readNullTermString = function(buffer) {
        return NIOUtils.readNullTermStringCharset(buffer, Charset.defaultCharset());
    };
    constructor.readNullTermStringCharset = function(buffer, charset) {
        var fork = buffer.duplicate();
         while (buffer.hasRemaining() && buffer.get() != 0)
            ;
        if (buffer.hasRemaining()) 
            fork.setLimit(buffer.position() - 1);
        return Platform.stringFromCharset(NIOUtils.toArray(fork), charset);
    };
    constructor.readBuf = function(buffer) {
        var result = buffer.duplicate();
        buffer.setPosition(buffer.limit());
        return result;
    };
    constructor.copy = function(_in, out, amount) {
        var buf = ByteBuffer.allocate(65536);
        var read;
        do {
            buf.setPosition(0);
            buf.setLimit(((Math.min(amount, buf.capacity())) | 0));
            read = _in.read(buf);
            if (read != -1) {
                buf.flip();
                out.write(buf);
                amount -= read;
            }
        } while (read != -1 && amount > 0);
    };
    constructor.closeQuietly = function(channel) {
        if (channel == null) 
            return;
        try {
            channel.close();
        }catch (e) {}
    };
    constructor.readByte = function(channel) {
        var buf = ByteBuffer.allocate(1);
        channel.read(buf);
        buf.flip();
        return buf.get();
    };
    constructor.readNByte = function(channel, n) {
        var result = new Int8Array(n);
        channel.read(ByteBuffer.wrap(result));
        return result;
    };
    constructor.readInt = function(channel) {
        var buf = ByteBuffer.allocate(4);
        channel.read(buf);
        buf.flip();
        return buf.getInt();
    };
    constructor.readIntOrder = function(channel, order) {
        var buf = ByteBuffer.allocate(4).order(order);
        channel.read(buf);
        buf.flip();
        return buf.getInt();
    };
    constructor.writeByte = function(channel, value) {
        channel.write(ByteBuffer.allocate(1).put(value).flip());
    };
    constructor.writeIntOrder = function(channel, value, order) {
        var order2 = ByteBuffer.allocate(4).order(order);
        channel.write(order2.putInt(value).flip());
    };
    constructor.writeIntLE = function(channel, value) {
        var allocate = ByteBuffer.allocate(4);
        allocate.order(ByteOrder.LITTLE_ENDIAN);
        channel.write(allocate.putInt(value).flip());
    };
    constructor.writeInt = function(channel, value) {
        channel.write(ByteBuffer.allocate(4).putInt(value).flip());
    };
    constructor.writeLong = function(channel, value) {
        channel.write(ByteBuffer.allocate(8).putLong(value).flip());
    };
    constructor.readableChannel = function(file) {
        return new FileChannelWrapper(new FileInputStream(file).getChannel());
    };
    constructor.writableChannel = function(file) {
        return new FileChannelWrapper(new FileOutputStream(file).getChannel());
    };
    constructor.rwChannel = function(file) {
        return new FileChannelWrapper(new RandomAccessFile(file, "rw").getChannel());
    };
    constructor.readableFileChannel = function(file) {
        return new FileChannelWrapper(new FileInputStream(file).getChannel());
    };
    constructor.writableFileChannel = function(file) {
        return new FileChannelWrapper(new FileOutputStream(file).getChannel());
    };
    constructor.rwFileChannel = function(file) {
        return new FileChannelWrapper(new RandomAccessFile(file, "rw").getChannel());
    };
    constructor.autoChannel = function(file) {
        return new AutoFileChannelWrapper(file);
    };
    constructor.duplicate = function(bb) {
        var out = ByteBuffer.allocate(bb.remaining());
        out.putBuf(bb.duplicate());
        out.flip();
        return out;
    };
    constructor.find = function(catalog, key) {
        var keyA = NIOUtils.toArray(key);
        for (var i = 0; i < catalog.size(); i++) {
            if (Platform.arrayEqualsByte(NIOUtils.toArray(catalog.get(i)), keyA)) 
                return i;
        }
        return -1;
    };
    constructor.FileReaderListener = function() {};
    constructor.FileReaderListener = stjs.extend(constructor.FileReaderListener, null, [], function(constructor, prototype) {
        prototype.progress = function(percentDone) {};
    }, {}, {});
    constructor.FileReader = function() {};
    constructor.FileReader = stjs.extend(constructor.FileReader, null, [], function(constructor, prototype) {
        prototype.oldPd = 0;
        prototype.data = function(data, filePos) {};
        prototype.done = function() {};
        prototype.readChannel = function(ch, bufferSize, listener) {
            var buf = ByteBuffer.allocate(bufferSize);
            var size = ch.size();
            for (var pos = ch.position(); ch.read(buf) != -1; pos = ch.position()) {
                buf.flip();
                this.data(buf, pos);
                buf.flip();
                if (listener != null) {
                    var newPd = (((stjs.trunc(100 * pos / size))) | 0);
                    if (newPd != this.oldPd) 
                        listener.progress(newPd);
                    this.oldPd = newPd;
                }
            }
            this.done();
        };
        prototype.readFile = function(source, bufferSize, listener) {
            var ch = null;
            try {
                ch = NIOUtils.readableChannel(source);
                this.readChannel(ch, bufferSize, listener);
            } finally {
                NIOUtils.closeQuietly(ch);
            }
        };
    }, {}, {});
    constructor.getRel = function(bb, rel) {
        return bb.getAt(bb.position() + rel);
    };
    constructor.cloneBuffer = function(pesBuffer) {
        var res = ByteBuffer.allocate(pesBuffer.remaining());
        res.putBuf(pesBuffer.duplicate());
        res.clear();
        return res;
    };
    constructor.clone = function(byteBuffer) {
        var result = ByteBuffer.allocate(byteBuffer.remaining());
        result.putBuf(byteBuffer.duplicate());
        result.flip();
        return result;
    };
    constructor.asByteBuffer = function(_arguments) {
        return ByteBuffer.wrap(arguments);
    };
    constructor.asByteBufferInt = function(_arguments) {
        return NIOUtils.asByteBuffer(ArrayUtil.toByteArray(arguments));
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var EbmlVoid = function(id) {
    EbmlBase.call(this, id);
};
EbmlVoid = stjs.extend(EbmlVoid, EbmlBase, [], function(constructor, prototype) {
    prototype.getData = function() {
        return null;
    };
    prototype.skip = function(is) {
        is.setPosition(this.dataOffset + this.dataLen);
    };
}, {parent: "EbmlMaster", type: "MKVType", id: "Int8Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed under FreeBSD License
 *  
 *  EBML IO implementation
 *  
 *  @author The JCodec project
 *  
 */
var EbmlBin = function(id) {
    EbmlBase.call(this, id);
};
EbmlBin = stjs.extend(EbmlBin, EbmlBase, [], function(constructor, prototype) {
    prototype.data = null;
    prototype.dataRead = false;
    prototype.readChannel = function(is) {
        var bb = ByteBuffer.allocate(stjs.trunc(this.dataLen));
        is.read(bb);
        bb.flip();
        this.read(bb);
    };
    prototype.read = function(source) {
        this.data = source.slice();
        this.data.setLimit(stjs.trunc(this.dataLen));
        this.dataRead = true;
    };
    prototype.skip = function(source) {
        if (!this.dataRead) {
            source.setPosition((((this.dataOffset + this.dataLen)) | 0));
            this.dataRead = true;
        }
    };
    prototype.size = function() {
        if (this.data == null || this.data.limit() == 0) 
            return EbmlBase.prototype.size.call(this);
        var totalSize = this.data.limit();
        totalSize += EbmlUtil.ebmlLength(this.data.limit());
        totalSize += this.id.length;
        return totalSize;
    };
    prototype.setBuf = function(data) {
        this.data = data.slice();
        this.dataLen = this.data.limit();
    };
    prototype.getData = function() {
        var sizeSize = EbmlUtil.ebmlLength(this.data.limit());
        var size = EbmlUtil.ebmlEncodeLen(this.data.limit(), sizeSize);
        var bb = ByteBuffer.allocate(this.id.length + sizeSize + this.data.limit());
        bb.putArr(this.id);
        bb.putArr(size);
        bb.putBuf(this.data);
        bb.flip();
        this.data.flip();
        return bb;
    };
}, {data: "ByteBuffer", parent: "EbmlMaster", type: "MKVType", id: "Int8Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  EBML IO implementation
 *  
 *  @author The JCodec project
 *  
 */
var EbmlMaster = function(id) {
    EbmlBase.call(this, id);
    this.children = new ArrayList();
    this.id = id;
};
EbmlMaster = stjs.extend(EbmlMaster, EbmlBase, [], function(constructor, prototype) {
    prototype.usedSize = 0;
    prototype.children = null;
    constructor.CLUSTER_ID = new Int8Array([31, (67 << 24 >> 24), (182 << 24 >> 24), (117 << 24 >> 24)]);
    prototype.add = function(elem) {
        if (elem == null) 
            return;
        elem.parent = this;
        this.children.add(elem);
    };
    prototype.getData = function() {
        var size = this.getDataLen();
        if (size > Integer.MAX_VALUE) 
            System.out.println("EbmlMaster.getData: id.length " + this.id.length + "  EbmlUtil.ebmlLength(" + size + "): " + EbmlUtil.ebmlLength(size) + " size: " + size);
        var bb = ByteBuffer.allocate((((this.id.length + EbmlUtil.ebmlLength(size) + size)) | 0));
        bb.putArr(this.id);
        bb.putArr(EbmlUtil.ebmlEncode(size));
        for (var i = 0; i < this.children.size(); i++) 
            bb.putBuf(this.children.get(i).getData());
        bb.flip();
        return bb;
    };
    prototype.getDataLen = function() {
        if (this.children == null || this.children.isEmpty()) 
            return this.dataLen;
        var dataLength = 0;
        for (var iterator$e = this.children.iterator(); iterator$e.hasNext(); ) {
            var e = iterator$e.next();
            dataLength += e.size();
        }
        return dataLength;
    };
    prototype.size = function() {
        var size = this.getDataLen();
        size += EbmlUtil.ebmlLength(size);
        size += this.id.length;
        return size;
    };
}, {children: {name: "ArrayList", arguments: ["EbmlBase"]}, CLUSTER_ID: "Int8Array", parent: "EbmlMaster", type: "MKVType", id: "Int8Array"}, {});
/**
 *  
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var PPMEncoder = function() {};
PPMEncoder = stjs.extend(PPMEncoder, null, [], function(constructor, prototype) {
    prototype.encodeFrame8Bit = function(picture) {
        if (picture.getColor() != ColorSpace.RGB) 
             throw new IllegalArgumentException("Only RGB image can be stored in PPM");
        var buffer = ByteBuffer.allocate(picture.getWidth() * picture.getHeight() * 3 + 200);
        buffer.putArr(JCodecUtil2.asciiString("P6 " + picture.getWidth() + " " + picture.getHeight() + " 255\n"));
        var data = picture.getData();
        for (var i = 0; i < picture.getWidth() * picture.getHeight() * 3; i += 3) {
            buffer.put(((data[0][i + 2] + 128) << 24 >> 24));
            buffer.put(((data[0][i + 1] + 128) << 24 >> 24));
            buffer.put(((data[0][i] + 128) << 24 >> 24));
        }
        buffer.flip();
        return buffer;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Audio filter graph
 *  
 *  Represents a combination of filters as on 'uber' filter
 *  
 *  @author The JCodec project
 *  
 */
var FilterGraph = function(sockets) {
    this.sockets = sockets;
};
FilterGraph = stjs.extend(FilterGraph, null, [AudioFilter], function(constructor, prototype) {
    constructor.addLevel = function(first) {
        return new FilterGraph.Factory(first);
    };
    constructor.Factory = function(firstFilter) {
        this.sockets = new ArrayList();
        if (firstFilter.getDelay() != 0) {
            this.sockets.add(FilterSocket.createFilterSocket(new Audio.DummyFilter(firstFilter.getNInputs())));
            this.addLevel(firstFilter);
        } else 
            this.sockets.add(FilterSocket.createFilterSocket(firstFilter));
    };
    constructor.Factory = stjs.extend(constructor.Factory, null, [], function(constructor, prototype) {
        prototype.sockets = null;
        /**
         *  Adds filters to the next level in the graph
         *  
         *  The filters are added to from the left to the right, i.e.
         *  <pre>
         *            L0
         *      L1 L1 L1 L1 L1 L1
         *      L2 L2 -->
         *  </pre>     
         *  As a consequence if the filters in this level contain less inputs then
         *  there are outputs in a previous level the graph will throw exception
         *  because the configuration it's misconfigured.
         *  
         *  @param filters
         *  @return
         */
        prototype.addLevel = function(_arguments) {
            var socket = FilterSocket.createFilterSocket(arguments);
            socket.allocateBuffers(4096);
            this.sockets.add(socket);
            return this;
        };
        /**
         *  Adds n of this filter as the next level in a graph
         *  
         *  @param filter
         *  @param n
         *  @return
         */
        prototype.addLevels = function(filter, n) {
            var filters = Array(n);
            Arrays.fill(filters, filter);
            return this.addLevel(filters);
        };
        /**
         *  Adds a level to the graph and tries to fill it with as many of the
         *  current filter as will be needed to take all the outputs of the
         *  previous level
         *  
         *  @param filter
         *  @return
         */
        prototype.addLevelSpan = function(filter) {
            var prevLevelOuts = this.sockets.get(this.sockets.size() - 1).getTotalOutputs();
            if ((prevLevelOuts % filter.getNInputs()) != 0) 
                 throw new IllegalArgumentException("Can't fill " + prevLevelOuts + " with multiple of " + filter.getNInputs());
            return this.addLevels(filter, stjs.trunc(prevLevelOuts / filter.getNInputs()));
        };
        prototype.create = function() {
            return new FilterGraph(this.sockets.toArray(Array(0)));
        };
    }, {sockets: {name: "List", arguments: ["FilterSocket"]}}, {});
    prototype.sockets = null;
    prototype.filter = function(ins, pos, outs) {
        this.sockets[0].setBuffers(ins, pos);
        for (var i = 0; i < this.sockets.length; i++) {
            var curOut = i < this.sockets.length - 1 ? this.sockets[i + 1].getBuffers() : outs;
            this.sockets[i].filter(curOut);
            if (i > 0) {
                this.sockets[i].rotate();
            }
            if (i < this.sockets.length - 1) {
                for (var b in curOut) 
                    b.flip();
            }
        }
    };
    prototype.getDelay = function() {
        return this.sockets[0].getFilters()[0].getDelay();
    };
    prototype.getNInputs = function() {
        return this.sockets[0].getTotalInputs();
    };
    prototype.getNOutputs = function() {
        return this.sockets[this.sockets.length - 1].getTotalOutputs();
    };
}, {sockets: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Outputs messages to standard output
 *  
 *  @author The JCodec project
 */
var OutLogSink = function(out, fmt) {
    this.out = out;
    this.fmt = fmt;
};
OutLogSink = stjs.extend(OutLogSink, null, [LogSink], function(constructor, prototype) {
    constructor.SimpleFormat = function(fmt) {
        this.fmt = fmt;
    };
    constructor.SimpleFormat = stjs.extend(constructor.SimpleFormat, null, [OutLogSink.MessageFormat], function(constructor, prototype) {
        prototype.fmt = null;
        constructor.colorMap = new HashMap();
        prototype.formatMessage = function(msg) {
            return this.fmt.replace("#level", String.valueOf(msg.getLevel())).replace("#color_code", String.valueOf(30 + OutLogSink.SimpleFormat.colorMap.get(msg.getLevel()).ordinal())).replace("#class", msg.getClassName()).replace("#method", msg.getMethodName()).replace("#file", msg.getFileName()).replace("#line", String.valueOf(msg.getLineNumber())).replace("#message", msg.getMessage());
        };
    }, {colorMap: {name: "Map", arguments: [{name: "Enum", arguments: ["LogLevel"]}, {name: "Enum", arguments: ["MainUtils.ANSIColor"]}]}}, {});
    (function() {
        OutLogSink.SimpleFormat.colorMap.put(LogLevel.DEBUG, MainUtils.ANSIColor.BROWN);
        OutLogSink.SimpleFormat.colorMap.put(LogLevel.INFO, MainUtils.ANSIColor.GREEN);
        OutLogSink.SimpleFormat.colorMap.put(LogLevel.WARN, MainUtils.ANSIColor.MAGENTA);
        OutLogSink.SimpleFormat.colorMap.put(LogLevel.ERROR, MainUtils.ANSIColor.RED);
    })();
    constructor.DEFAULT_FORMAT = new OutLogSink.SimpleFormat(MainUtils.colorString("[#level]", "#color_code") + MainUtils.bold("\t#class.#method (#file:#line):") + "\t#message");
    constructor.createOutLogSink = function() {
        return new OutLogSink(System.out, OutLogSink.DEFAULT_FORMAT);
    };
    prototype.out = null;
    prototype.fmt = null;
    prototype.postMessage = function(msg) {
        this.out.println(this.fmt.formatMessage(msg));
    };
    constructor.MessageFormat = function() {};
    constructor.MessageFormat = stjs.extend(constructor.MessageFormat, null, [], function(constructor, prototype) {
        prototype.formatMessage = function(msg) {};
    }, {}, {});
}, {DEFAULT_FORMAT: "OutLogSink.SimpleFormat", out: "PrintStream", fmt: "OutLogSink.MessageFormat"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  @author in-somnia
 */
var IMDCT = function(frameLen) {
    this.frameLen = frameLen;
    this.lbLong = stjs.trunc(frameLen / GCConstants.BANDS);
    this.shortFrameLen = stjs.trunc(frameLen / 8);
    this.lbShort = stjs.trunc(this.shortFrameLen / GCConstants.BANDS);
    this.lbMid = stjs.trunc((this.lbLong - this.lbShort) / 2);
};
IMDCT = stjs.extend(IMDCT, null, [GCConstants, IMDCTTables, Windows], function(constructor, prototype) {
    constructor.LONG_WINDOWS = [Windows.SINE_256, Windows.KBD_256];
    constructor.SHORT_WINDOWS = [Windows.SINE_32, Windows.KBD_32];
    prototype.frameLen = 0;
    prototype.shortFrameLen = 0;
    prototype.lbLong = 0;
    prototype.lbShort = 0;
    prototype.lbMid = 0;
    prototype.process = function(_in, out, winShape, winShapePrev, winSeq) {
        var buf = new Float32Array(this.frameLen);
        var b, j, i;
        if (winSeq.equals(ICSInfo.WindowSequence.EIGHT_SHORT_SEQUENCE)) {
            for (b = 0; b < GCConstants.BANDS; b++) {
                for (j = 0; j < 8; j++) {
                    for (i = 0; i < this.lbShort; i++) {
                        if (b % 2 == 0) 
                            buf[this.lbLong * b + this.lbShort * j + i] = _in[this.shortFrameLen * j + this.lbShort * b + i];
                         else 
                            buf[this.lbLong * b + this.lbShort * j + i] = _in[this.shortFrameLen * j + this.lbShort * b + this.lbShort - 1 - i];
                    }
                }
            }
        } else {
            for (b = 0; b < GCConstants.BANDS; b++) {
                for (i = 0; i < this.lbLong; i++) {
                    if (b % 2 == 0) 
                        buf[this.lbLong * b + i] = _in[this.lbLong * b + i];
                     else 
                        buf[this.lbLong * b + i] = _in[this.lbLong * b + this.lbLong - 1 - i];
                }
            }
        }
        for (b = 0; b < GCConstants.BANDS; b++) {
            this.process2(buf, out, winSeq, winShape, winShapePrev, b);
        }
    };
    prototype.process2 = function(_in, out, winSeq, winShape, winShapePrev, band) {
        var bufIn = new Float32Array(this.lbLong);
        var bufOut = new Float32Array(this.lbLong * 2);
        var window = new Float32Array(this.lbLong * 2);
        var window1 = new Float32Array(this.lbShort * 2);
        var window2 = new Float32Array(this.lbShort * 2);
        var i;
        switch (winSeq) {
            case ICSInfo.WindowSequence.ONLY_LONG_SEQUENCE:
                for (i = 0; i < this.lbLong; i++) {
                    window[i] = IMDCT.LONG_WINDOWS[winShapePrev][i];
                    window[this.lbLong * 2 - 1 - i] = IMDCT.LONG_WINDOWS[winShape][i];
                }
                break;
            case ICSInfo.WindowSequence.EIGHT_SHORT_SEQUENCE:
                for (i = 0; i < this.lbShort; i++) {
                    window1[i] = IMDCT.SHORT_WINDOWS[winShapePrev][i];
                    window1[this.lbShort * 2 - 1 - i] = IMDCT.SHORT_WINDOWS[winShape][i];
                    window2[i] = IMDCT.SHORT_WINDOWS[winShape][i];
                    window2[this.lbShort * 2 - 1 - i] = IMDCT.SHORT_WINDOWS[winShape][i];
                }
                break;
            case ICSInfo.WindowSequence.LONG_START_SEQUENCE:
                for (i = 0; i < this.lbLong; i++) {
                    window[i] = IMDCT.LONG_WINDOWS[winShapePrev][i];
                }
                for (i = 0; i < this.lbMid; i++) {
                    window[i + this.lbLong] = 1.0;
                }
                for (i = 0; i < this.lbShort; i++) {
                    window[i + this.lbMid + this.lbLong] = IMDCT.SHORT_WINDOWS[winShape][this.lbShort - 1 - i];
                }
                for (i = 0; i < this.lbMid; i++) {
                    window[i + this.lbMid + this.lbLong + this.lbShort] = 0.0;
                }
                break;
            case ICSInfo.WindowSequence.LONG_STOP_SEQUENCE:
                for (i = 0; i < this.lbMid; i++) {
                    window[i] = 0.0;
                }
                for (i = 0; i < this.lbShort; i++) {
                    window[i + this.lbMid] = IMDCT.SHORT_WINDOWS[winShapePrev][i];
                }
                for (i = 0; i < this.lbMid; i++) {
                    window[i + this.lbMid + this.lbShort] = 1.0;
                }
                for (i = 0; i < this.lbLong; i++) {
                    window[i + this.lbMid + this.lbShort + this.lbMid] = IMDCT.LONG_WINDOWS[winShape][this.lbLong - 1 - i];
                }
                break;
        }
        var j;
        if (winSeq.equals(ICSInfo.WindowSequence.EIGHT_SHORT_SEQUENCE)) {
            var k;
            for (j = 0; j < 8; j++) {
                for (k = 0; k < this.lbShort; k++) {
                    bufIn[k] = _in[band * this.lbLong + j * this.lbShort + k];
                }
                if (j == 0) 
                    System.arraycopy(window1, 0, window, 0, this.lbShort * 2);
                 else 
                    System.arraycopy(window2, 0, window, 0, this.lbShort * 2);
                this.imdct(bufIn, bufOut, window, this.lbShort);
                for (k = 0; k < this.lbShort * 2; k++) {
                    out[band * this.lbLong * 2 + j * this.lbShort * 2 + k] = bufOut[k] / 32.0;
                }
            }
        } else {
            for (j = 0; j < this.lbLong; j++) {
                bufIn[j] = _in[band * this.lbLong + j];
            }
            this.imdct(bufIn, bufOut, window, this.lbLong);
            for (j = 0; j < this.lbLong * 2; j++) {
                out[band * this.lbLong * 2 + j] = bufOut[j] / 256.0;
            }
        }
    };
    prototype.imdct = function(_in, out, window, n) {
        var n2 = stjs.trunc(n / 2);
        var table, table2;
        if (n == 256) {
            table = IMDCTTables.IMDCT_TABLE_256;
            table2 = IMDCTTables.IMDCT_POST_TABLE_256;
        } else if (n == 32) {
            table = IMDCTTables.IMDCT_TABLE_32;
            table2 = IMDCTTables.IMDCT_POST_TABLE_32;
        } else 
             throw new AACException("gain control: unexpected IMDCT length");
        var tmp = new Float32Array(n);
        var i;
        for (i = 0; i < n2; ++i) {
            tmp[i] = _in[2 * i];
        }
        for (i = n2; i < n; ++i) {
            tmp[i] = -_in[2 * n - 1 - 2 * i];
        }
        var buf = Array.apply(null, Array(n2)).map(function() {
            return new Float32Array(2);
        });
        for (i = 0; i < n2; i++) {
            buf[i][0] = (table[i][0] * tmp[2 * i]) - (table[i][1] * tmp[2 * i + 1]);
            buf[i][1] = (table[i][0] * tmp[2 * i + 1]) + (table[i][1] * tmp[2 * i]);
        }
        FFT.process(buf, n2);
        for (i = 0; i < n2; i++) {
            tmp[i] = table2[i][0] * buf[i][0] + table2[i][1] * buf[n2 - 1 - i][0] + table2[i][2] * buf[i][1] + table2[i][3] * buf[n2 - 1 - i][1];
            tmp[n - 1 - i] = table2[i][2] * buf[i][0] - table2[i][3] * buf[n2 - 1 - i][0] - table2[i][0] * buf[i][1] + table2[i][1] * buf[n2 - 1 - i][1];
        }
        System.arraycopy(tmp, n2, out, 0, n2);
        for (i = n2; i < stjs.trunc(n * 3 / 2); ++i) {
            out[i] = -tmp[stjs.trunc(n * 3 / 2) - 1 - i];
        }
        for (i = stjs.trunc(n * 3 / 2); i < n * 2; ++i) {
            out[i] = -tmp[i - stjs.trunc(n * 3 / 2)];
        }
        for (i = 0; i < n; i++) {
            out[i] *= window[i];
        }
    };
}, {LONG_WINDOWS: "Array", SHORT_WINDOWS: "Array", LN_GAIN: "Int32Array", IMDCT_TABLE_256: "Array", IMDCT_TABLE_32: "Array", IMDCT_POST_TABLE_256: "Array", IMDCT_POST_TABLE_32: "Array", SINE_256: "Float32Array", SINE_32: "Float32Array", KBD_256: "Float32Array", KBD_32: "Float32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var VP8Encoder = function(rc) {
    VideoEncoder.call(this);
    this.rc = rc;
    this.tmp = new Int32Array(16);
};
VP8Encoder = stjs.extend(VP8Encoder, VideoEncoder, [], function(constructor, prototype) {
    prototype.bitstream = null;
    prototype.leftRow = null;
    prototype.topLine = null;
    prototype.quantizer = null;
    prototype.tmp = null;
    prototype.rc = null;
    prototype.headerBuffer = null;
    prototype.dataBuffer = null;
    constructor.createVP8Encoder = function(qp) {
        return new VP8Encoder(new NopRateControl(qp));
    };
    prototype.encodeFrame8Bit = function(pic, _buf) {
        var out = _buf.duplicate();
        var mbWidth = ((pic.getWidth() + 15) >> 4);
        var mbHeight = ((pic.getHeight() + 15) >> 4);
        this.prepareBuffers(mbWidth, mbHeight);
        this.bitstream = new VPXBitstream(VPXConst.tokenDefaultBinProbs, mbWidth);
        this.leftRow = [new Int8Array(16), new Int8Array(8), new Int8Array(8)];
        this.topLine = [new Int8Array(mbWidth << 4), new Int8Array(mbWidth << 3), new Int8Array(mbWidth << 3)];
        this.initValue(this.leftRow, (1 << 24 >> 24));
        this.initValue(this.topLine, (-1 << 24 >> 24));
        this.quantizer = new VPXQuantizer();
        var outMB = Picture8Bit.create(16, 16, ColorSpace.YUV420);
        var segmentQps = this.rc.getSegmentQps();
        var boolEnc = new VPxBooleanEncoder(this.dataBuffer);
        var segmentMap = new Int32Array(mbWidth * mbHeight);
        for (var mbY = 0, mbAddr = 0; mbY < mbHeight; mbY++) {
            this.initValue(this.leftRow, (1 << 24 >> 24));
            for (var mbX = 0; mbX < mbWidth; mbX++ , mbAddr++) {
                var before = boolEnc.position();
                var segment = this.rc.getSegment();
                segmentMap[mbAddr] = segment;
                this.luma(pic, mbX, mbY, boolEnc, segmentQps[segment], outMB);
                this.chroma(pic, mbX, mbY, boolEnc, segmentQps[segment], outMB);
                this.rc.report(boolEnc.position() - before);
                this.collectPredictors(outMB, mbX);
            }
        }
        boolEnc.stop();
        this.dataBuffer.flip();
        boolEnc = new VPxBooleanEncoder(this.headerBuffer);
        var probs = this.calcSegmentProbs(segmentMap);
        this.writeHeader2(boolEnc, segmentQps, probs);
        for (var mbY = 0, mbAddr = 0; mbY < mbHeight; mbY++) {
            for (var mbX = 0; mbX < mbWidth; mbX++ , mbAddr++) {
                this.writeSegmetId(boolEnc, segmentMap[mbAddr], probs);
                boolEnc.writeBit(145, 1);
                boolEnc.writeBit(156, 0);
                boolEnc.writeBit(163, 0);
                boolEnc.writeBit(142, 0);
            }
        }
        boolEnc.stop();
        this.headerBuffer.flip();
        out.order(ByteOrder.LITTLE_ENDIAN);
        this.writeHeader(out, pic.getWidth(), pic.getHeight(), this.headerBuffer.remaining());
        out.putBuf(this.headerBuffer);
        out.putBuf(this.dataBuffer);
        out.flip();
        return out;
    };
    prototype.prepareBuffers = function(mbWidth, mbHeight) {
        var dataBufSize = (mbHeight * mbHeight) << 10;
        var headerBufSize = 256 + mbWidth * mbHeight;
        if (this.headerBuffer == null || this.headerBuffer.capacity() < headerBufSize) 
            this.headerBuffer = ByteBuffer.allocate(headerBufSize);
         else 
            this.headerBuffer.clear();
        if (this.dataBuffer == null || this.dataBuffer.capacity() < dataBufSize) 
            this.dataBuffer = ByteBuffer.allocate(dataBufSize);
         else 
            this.dataBuffer.clear();
    };
    prototype.writeSegmetId = function(boolEnc, id, probs) {
        var bit1 = (id >> 1) & 1;
        boolEnc.writeBit(probs[0], bit1);
        boolEnc.writeBit(probs[1 + bit1], id & 1);
    };
    prototype.calcSegmentProbs = function(segmentMap) {
        var result = new Int32Array(3);
        for (var i = 0; i < segmentMap.length; i++) {
            switch (segmentMap[i]) {
                case 0:
                    result[0]++;
                    result[1]++;
                    break;
                case 1:
                    result[0]++;
                    break;
                case 2:
                    result[2]++;
            }
        }
        for (var i = 0; i < 3; i++) 
            result[i] = MathUtil.clip(stjs.trunc((result[i] << 8) / segmentMap.length), 1, 255);
        return result;
    };
    prototype.initValue = function(leftRow2, val) {
        Arrays.fill(leftRow2[0], val);
        Arrays.fill(leftRow2[1], val);
        Arrays.fill(leftRow2[2], val);
    };
    prototype.writeHeader2 = function(boolEnc, segmentQps, probs) {
        boolEnc.writeBit(128, 0);
        boolEnc.writeBit(128, 0);
        boolEnc.writeBit(128, 1);
        boolEnc.writeBit(128, 1);
        boolEnc.writeBit(128, 1);
        boolEnc.writeBit(128, 1);
        for (var i = 0; i < segmentQps.length; i++) {
            boolEnc.writeBit(128, 1);
            this.writeInt(boolEnc, segmentQps[i], 7);
            boolEnc.writeBit(128, 0);
        }
        for (var i = segmentQps.length; i < 4; i++) 
            boolEnc.writeBit(128, 0);
        boolEnc.writeBit(128, 0);
        boolEnc.writeBit(128, 0);
        boolEnc.writeBit(128, 0);
        boolEnc.writeBit(128, 0);
        for (var i = 0; i < 3; i++) {
            boolEnc.writeBit(128, 1);
            this.writeInt(boolEnc, probs[i], 8);
        }
        boolEnc.writeBit(128, 0);
        this.writeInt(boolEnc, 1, 6);
        this.writeInt(boolEnc, 0, 3);
        boolEnc.writeBit(128, 0);
        this.writeInt(boolEnc, 0, 2);
        this.writeInt(boolEnc, segmentQps[0], 7);
        boolEnc.writeBit(128, 0);
        boolEnc.writeBit(128, 0);
        boolEnc.writeBit(128, 0);
        boolEnc.writeBit(128, 0);
        boolEnc.writeBit(128, 0);
        boolEnc.writeBit(128, 0);
        var probFlags = VPXConst.tokenProbUpdateFlagProbs;
        for (var i = 0; i < probFlags.length; i++) {
            for (var j = 0; j < probFlags[i].length; j++) {
                for (var k = 0; k < probFlags[i][j].length; k++) {
                    for (var l = 0; l < probFlags[i][j][k].length; l++) 
                        boolEnc.writeBit(probFlags[i][j][k][l], 0);
                }
            }
        }
        boolEnc.writeBit(128, 0);
    };
    prototype.writeInt = function(boolEnc, data, bits) {
        var bit;
        for (bit = bits - 1; bit >= 0; bit--) 
            boolEnc.writeBit(128, (1 & (data >> bit)));
    };
    prototype.writeHeader = function(out, width, height, firstPart) {
        var version = 0, type = 0, showFrame = 1;
        var header = (firstPart << 5) | (showFrame << 4) | (version << 1) | type;
        out.put(((header & 255) << 24 >> 24));
        out.put((((header >> 8) & 255) << 24 >> 24));
        out.put((((header >> 16) & 255) << 24 >> 24));
        out.put((157 << 24 >> 24));
        out.put((1 << 24 >> 24));
        out.put((42 << 24 >> 24));
        out.putShort(((width) << 16 >> 16));
        out.putShort(((height) << 16 >> 16));
    };
    prototype.collectPredictors = function(outMB, mbX) {
        System.arraycopy(outMB.getPlaneData(0), 240, this.topLine[0], mbX << 4, 16);
        System.arraycopy(outMB.getPlaneData(1), 56, this.topLine[1], mbX << 3, 8);
        System.arraycopy(outMB.getPlaneData(2), 56, this.topLine[2], mbX << 3, 8);
        this.copyCol(outMB.getPlaneData(0), 15, 16, this.leftRow[0]);
        this.copyCol(outMB.getPlaneData(1), 7, 8, this.leftRow[1]);
        this.copyCol(outMB.getPlaneData(2), 7, 8, this.leftRow[2]);
    };
    prototype.copyCol = function(planeData, off, stride, out) {
        for (var i = 0; i < out.length; i++) {
            out[i] = planeData[off];
            off += stride;
        }
    };
    prototype.luma = function(pic, mbX, mbY, out, qp, outMB) {
        var x = mbX << 4;
        var y = mbY << 4;
        var ac = this.transform(pic, 0, qp, x, y);
        var dc = this.extractDC(ac);
        this.writeLumaDC(mbX, mbY, out, qp, dc);
        this.writeLumaAC(mbX, mbY, out, ac, qp);
        this.restorePlaneLuma(dc, ac, qp);
        this.putLuma(outMB.getPlaneData(0), this.lumaDCPred(x, y), ac, 4);
    };
    prototype.writeLumaAC = function(mbX, mbY, out, ac, qp) {
        for (var i = 0; i < 16; i++) {
            this.quantizer.quantizeY(ac[i], qp);
            this.bitstream.encodeCoeffsDCT15(out, this.zigzag(ac[i], this.tmp), mbX, i & 3, i >> 2);
        }
    };
    prototype.writeLumaDC = function(mbX, mbY, out, qp, dc) {
        VPXDCT.walsh4x4(dc);
        this.quantizer.quantizeY2(dc, qp);
        this.bitstream.encodeCoeffsWHT(out, this.zigzag(dc, this.tmp), mbX);
    };
    prototype.writeChroma = function(comp, mbX, mbY, boolEnc, ac, qp) {
        for (var i = 0; i < 4; i++) {
            this.quantizer.quantizeUV(ac[i], qp);
            this.bitstream.encodeCoeffsDCTUV(boolEnc, this.zigzag(ac[i], this.tmp), comp, mbX, i & 1, i >> 1);
        }
    };
    prototype.zigzag = function(zz, tmp2) {
        for (var i = 0; i < 16; i++) 
            tmp2[i] = zz[VPXConst.zigzag[i]];
        return tmp2;
    };
    prototype.chroma = function(pic, mbX, mbY, boolEnc, qp, outMB) {
        var x = mbX << 3;
        var y = mbY << 3;
        var chromaPred1 = this.chromaPredBlk(1, x, y);
        var chromaPred2 = this.chromaPredBlk(2, x, y);
        var ac1 = this.transformChroma(pic, 1, qp, x, y, outMB, chromaPred1);
        var ac2 = this.transformChroma(pic, 2, qp, x, y, outMB, chromaPred2);
        this.writeChroma(1, mbX, mbY, boolEnc, ac1, qp);
        this.writeChroma(2, mbX, mbY, boolEnc, ac2, qp);
        this.restorePlaneChroma(ac1, qp);
        this.putChroma(outMB.getData()[1], 1, x, y, ac1, chromaPred1);
        this.restorePlaneChroma(ac2, qp);
        this.putChroma(outMB.getData()[2], 2, x, y, ac2, chromaPred2);
    };
    prototype.transformChroma = function(pic, comp, qp, x, y, outMB, chromaPred) {
        var ac = Array.apply(null, Array(4)).map(function() {
            return new Int32Array(16);
        });
        for (var blk = 0; blk < ac.length; blk++) {
            var blkOffX = (blk & 1) << 2;
            var blkOffY = (blk >> 1) << 2;
            this.takeSubtract(pic.getPlaneData(comp), pic.getPlaneWidth(comp), pic.getPlaneHeight(comp), x + blkOffX, y + blkOffY, ac[blk], chromaPred);
            VPXDCT.fdct4x4(ac[blk]);
        }
        return ac;
    };
    prototype.putChroma = function(mb, comp, x, y, ac, chromaPred) {
        for (var blk = 0; blk < 4; blk++) 
            this.putBlk(mb, chromaPred, ac[blk], 3, (blk & 1) << 2, (blk >> 1) << 2);
    };
    prototype.chromaPredOne = function(pix, x) {
        return (((pix[x] + pix[x + 1] + pix[x + 2] + pix[x + 3] + pix[x + 4] + pix[x + 5] + pix[x + 6] + pix[x + 7] + 4) >> 3) << 24 >> 24);
    };
    prototype.chromaPredTwo = function(pix1, pix2, x, y) {
        return (((pix1[x] + pix1[x + 1] + pix1[x + 2] + pix1[x + 3] + pix1[x + 4] + pix1[x + 5] + pix1[x + 6] + pix1[x + 7] + pix2[y] + pix2[y + 1] + pix2[y + 2] + pix2[y + 3] + pix2[y + 4] + pix2[y + 5] + pix2[y + 6] + pix2[y + 7] + 8) >> 4) << 24 >> 24);
    };
    prototype.chromaPredBlk = function(comp, x, y) {
        var predY = y & 7;
        if (x != 0 && y != 0) 
            return this.chromaPredTwo(this.leftRow[comp], this.topLine[comp], predY, x);
         else if (x != 0) 
            return this.chromaPredOne(this.leftRow[comp], predY);
         else if (y != 0) 
            return this.chromaPredOne(this.topLine[comp], x);
         else 
            return 0;
    };
    prototype.putLuma = function(planeData, pred, ac, log2stride) {
        for (var blk = 0; blk < ac.length; blk++) {
            var blkOffX = (blk & 3) << 2;
            var blkOffY = blk & ~3;
            this.putBlk(planeData, pred, ac[blk], log2stride, blkOffX, blkOffY);
        }
    };
    prototype.putBlk = function(planeData, pred, block, log2stride, blkX, blkY) {
        var stride = 1 << log2stride;
        for (var line = 0, srcOff = 0, dstOff = (blkY << log2stride) + blkX; line < 4; line++) {
            planeData[dstOff] = ((MathUtil.clip(block[srcOff] + pred, -128, 127)) << 24 >> 24);
            planeData[dstOff + 1] = ((MathUtil.clip(block[srcOff + 1] + pred, -128, 127)) << 24 >> 24);
            planeData[dstOff + 2] = ((MathUtil.clip(block[srcOff + 2] + pred, -128, 127)) << 24 >> 24);
            planeData[dstOff + 3] = ((MathUtil.clip(block[srcOff + 3] + pred, -128, 127)) << 24 >> 24);
            srcOff += 4;
            dstOff += stride;
        }
    };
    prototype.restorePlaneChroma = function(ac, qp) {
        for (var i = 0; i < 4; i++) {
            this.quantizer.dequantizeUV(ac[i], qp);
            VPXDCT.idct4x4(ac[i]);
        }
    };
    prototype.restorePlaneLuma = function(dc, ac, qp) {
        this.quantizer.dequantizeY2(dc, qp);
        VPXDCT.iwalsh4x4(dc);
        for (var i = 0; i < 16; i++) {
            this.quantizer.dequantizeY(ac[i], qp);
            ac[i][0] = dc[i];
            VPXDCT.idct4x4(ac[i]);
        }
    };
    prototype.extractDC = function(ac) {
        var dc = new Int32Array(ac.length);
        for (var i = 0; i < ac.length; i++) {
            dc[i] = ac[i][0];
        }
        return dc;
    };
    prototype.lumaDCPred = function(x, y) {
        if (x == 0 && y == 0) 
            return 0;
        if (y == 0) 
            return (((ArrayUtil.sumByte(this.leftRow[0]) + 8) >> 4) << 24 >> 24);
        if (x == 0) 
            return (((ArrayUtil.sumByte3(this.topLine[0], x, 16) + 8) >> 4) << 24 >> 24);
        return (((ArrayUtil.sumByte(this.leftRow[0]) + ArrayUtil.sumByte3(this.topLine[0], x, 16) + 16) >> 5) << 24 >> 24);
    };
    prototype.transform = function(pic, comp, qp, x, y) {
        var dcc = this.lumaDCPred(x, y);
        var ac = Array.apply(null, Array(16)).map(function() {
            return new Int32Array(16);
        });
        for (var i = 0; i < ac.length; i++) {
            var coeff = ac[i];
            var blkOffX = (i & 3) << 2;
            var blkOffY = i & ~3;
            this.takeSubtract(pic.getPlaneData(comp), pic.getPlaneWidth(comp), pic.getPlaneHeight(comp), x + blkOffX, y + blkOffY, coeff, dcc);
            VPXDCT.fdct4x4(coeff);
        }
        return ac;
    };
    prototype.takeSubtract = function(planeData, planeWidth, planeHeight, x, y, coeff, dc) {
        if (x + 4 < planeWidth && y + 4 < planeHeight) 
            this.takeSubtractSafe(planeData, planeWidth, planeHeight, x, y, coeff, dc);
         else 
            this.takeSubtractUnsafe(planeData, planeWidth, planeHeight, x, y, coeff, dc);
    };
    prototype.takeSubtractSafe = function(planeData, planeWidth, planeHeight, x, y, coeff, dc) {
        for (var i = 0, srcOff = y * planeWidth + x, dstOff = 0; i < 4; i++ , srcOff += planeWidth , dstOff += 4) {
            coeff[dstOff] = planeData[srcOff] - dc;
            coeff[dstOff + 1] = planeData[srcOff + 1] - dc;
            coeff[dstOff + 2] = planeData[srcOff + 2] - dc;
            coeff[dstOff + 3] = planeData[srcOff + 3] - dc;
        }
    };
    prototype.takeSubtractUnsafe = function(planeData, planeWidth, planeHeight, x, y, coeff, dc) {
        var outOff = 0;
        var i;
        for (i = y; i < Math.min(y + 4, planeHeight); i++) {
            var off = i * planeWidth + Math.min(x, planeWidth);
            var j;
            for (j = x; j < Math.min(x + 4, planeWidth); j++) 
                coeff[outOff++] = planeData[off++] - dc;
            --off;
            for (; j < x + 4; j++) 
                coeff[outOff++] = planeData[off] - dc;
        }
        for (; i < y + 4; i++) {
            var off = planeHeight * planeWidth - planeWidth + Math.min(x, planeWidth);
            var j;
            for (j = x; j < Math.min(x + 4, planeWidth); j++) 
                coeff[outOff++] = planeData[off++] - dc;
            --off;
            for (; j < x + 4; j++) 
                coeff[outOff++] = planeData[off] - dc;
        }
    };
    prototype.getSupportedColorSpaces = function() {
        return [ColorSpace.YUV420J];
    };
}, {bitstream: "VPXBitstream", leftRow: "Array", topLine: "Array", quantizer: "VPXQuantizer", tmp: "Int32Array", rc: "RateControl", headerBuffer: "ByteBuffer", dataBuffer: "ByteBuffer"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  @author The JCodec project
 */
var JpegConst = function() {};
JpegConst = stjs.extend(JpegConst, null, [], function(constructor, prototype) {
    constructor.naturalOrder = new Int32Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]);
    constructor.YDC_DEFAULT = null;
    constructor.YAC_DEFAULT = null;
    constructor.CDC_DEFAULT = null;
    constructor.CAC_DEFAULT = null;
    constructor.names = Array(256);
    constructor.markerToString = function(marker) {
        return JpegConst.names[marker];
    };
    /**
     * Start Of Frame - Baseline DCT 
     */
    constructor.SOF0 = 192;
    /**
     * Start Of Frame - Extended sequential DCT 
     */
    constructor.SOF1 = 193;
    /**
     * Start Of Frame - Progressive DCT 
     */
    constructor.SOF2 = 194;
    /**
     * Start Of Frame - Lossless (sequential) 
     */
    constructor.SOF3 = 195;
    /**
     * Huffman table specification - Define Huffman table(s) 
     */
    constructor.DHT = 196;
    /**
     * Define quantization table(s) 
     */
    constructor.DQT = 219;
    /**
     * Start of scan 
     */
    constructor.SOS = 218;
    /**
     * End of image - standalone marker 
     */
    constructor.EOI = 217;
    /**
     * Start of image - standalone marker 
     */
    constructor.SOI = 216;
    /**
     * Reserved for application segments 
     */
    constructor.APP0 = 224;
    /**
     * Reserved for application segments 
     */
    constructor.APP1 = 225;
    /**
     * Reserved for application segments 
     */
    constructor.APP2 = 226;
    /**
     * Reserved for application segments 
     */
    constructor.APP3 = 227;
    /**
     * Reserved for application segments 
     */
    constructor.APP4 = 228;
    /**
     * Reserved for application segments 
     */
    constructor.APP5 = 229;
    /**
     * Reserved for application segments 
     */
    constructor.APP6 = 230;
    /**
     * Reserved for application segments 
     */
    constructor.APP7 = 231;
    /**
     * Reserved for application segments 
     */
    constructor.APP8 = 232;
    /**
     * Reserved for application segments 
     */
    constructor.APP9 = 233;
    /**
     * Reserved for application segments 
     */
    constructor.APPA = 234;
    /**
     * Reserved for application segments 
     */
    constructor.APPB = 235;
    /**
     * Reserved for application segments 
     */
    constructor.APPC = 236;
    /**
     * Reserved for application segments 
     */
    constructor.APPD = 237;
    /**
     * Reserved for application segments 
     */
    constructor.APPE = 238;
    /**
     * Reserved for application segments 
     */
    constructor.APPF = 239;
    /**
     * Restart with modulo 8 count 0 
     */
    constructor.RST0 = 208;
    /**
     * Restart with modulo 8 count 1 
     */
    constructor.RST1 = 209;
    /**
     * Restart with modulo 8 count 2 
     */
    constructor.RST2 = 210;
    /**
     * Restart with modulo 8 count 3 
     */
    constructor.RST3 = 211;
    /**
     * Restart with modulo 8 count 4 
     */
    constructor.RST4 = 212;
    /**
     * Restart with modulo 8 count 5 
     */
    constructor.RST5 = 213;
    /**
     * Restart with modulo 8 count 6 
     */
    constructor.RST6 = 214;
    /**
     * Restart with modulo 8 count 7 
     */
    constructor.RST7 = 215;
    constructor.COM = 254;
    /**
     * Define restart interval marker 
     */
    constructor.DRI = 221;
    constructor.DEFAULT_QUANT_LUMA = new Int32Array([16, 11, 12, 14, 12, 10, 16, 14, 13, 14, 18, 17, 16, 19, 24, 40, 26, 24, 22, 22, 24, 49, 36, 37, 29, 40, 58, 51, 61, 60, 57, 51, 56, 55, 64, 72, 92, 78, 64, 68, 87, 69, 55, 56, 80, 109, 81, 87, 95, 62, 103, 104, 103, 98, 77, 113, 121, 112, 100, 120, 92, 101, 103, 99]);
    constructor.DEFAULT_QUANT_CHROMA = new Int32Array([17, 18, 18, 24, 21, 24, 47, 26, 26, 47, 99, 66, 56, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99]);
}, {naturalOrder: "Int32Array", YDC_DEFAULT: "VLC", YAC_DEFAULT: "VLC", CDC_DEFAULT: "VLC", CAC_DEFAULT: "VLC", names: "Array", DEFAULT_QUANT_LUMA: "Int32Array", DEFAULT_QUANT_CHROMA: "Int32Array"}, {});
(function() {
    var bldr1 = new VLCBuilder();
    bldr1.set(0, "00");
    bldr1.set(1, "010");
    bldr1.set(2, "011");
    bldr1.set(3, "100");
    bldr1.set(4, "101");
    bldr1.set(5, "110");
    bldr1.set(6, "1110");
    bldr1.set(7, "11110");
    bldr1.set(8, "111110");
    bldr1.set(9, "1111110");
    bldr1.set(10, "11111110");
    bldr1.set(11, "111111110");
    JpegConst.YDC_DEFAULT = bldr1.getVLC();
    var bldr2 = new VLCBuilder();
    bldr2.set(0, "00");
    bldr2.set(1, "01");
    bldr2.set(2, "10");
    bldr2.set(3, "110");
    bldr2.set(4, "1110");
    bldr2.set(5, "11110");
    bldr2.set(6, "111110");
    bldr2.set(7, "1111110");
    bldr2.set(8, "11111110");
    bldr2.set(9, "111111110");
    bldr2.set(10, "1111111110");
    bldr2.set(11, "11111111110");
    JpegConst.CDC_DEFAULT = bldr2.getVLC();
    var bldr3 = new VLCBuilder();
    bldr3.set(0, "1010");
    bldr3.set(1, "00");
    bldr3.set(2, "01");
    bldr3.set(3, "100");
    bldr3.set(4, "1011");
    bldr3.set(5, "11010");
    bldr3.set(6, "1111000");
    bldr3.set(7, "11111000");
    bldr3.set(8, "1111110110");
    bldr3.set(9, "1111111110000010");
    bldr3.set(10, "1111111110000011");
    bldr3.set(17, "1100");
    bldr3.set(18, "11011");
    bldr3.set(19, "1111001");
    bldr3.set(20, "111110110");
    bldr3.set(21, "11111110110");
    bldr3.set(22, "1111111110000100");
    bldr3.set(23, "1111111110000101");
    bldr3.set(24, "1111111110000110");
    bldr3.set(25, "1111111110000111");
    bldr3.set(26, "1111111110001000");
    bldr3.set(33, "11100");
    bldr3.set(34, "11111001");
    bldr3.set(35, "1111110111");
    bldr3.set(36, "111111110100");
    bldr3.set(37, "1111111110001001");
    bldr3.set(38, "1111111110001010");
    bldr3.set(39, "1111111110001011");
    bldr3.set(40, "1111111110001100");
    bldr3.set(41, "1111111110001101");
    bldr3.set(42, "1111111110001110");
    bldr3.set(49, "111010");
    bldr3.set(50, "111110111");
    bldr3.set(51, "111111110101");
    bldr3.set(52, "1111111110001111");
    bldr3.set(53, "1111111110010000");
    bldr3.set(54, "1111111110010001");
    bldr3.set(55, "1111111110010010");
    bldr3.set(56, "1111111110010011");
    bldr3.set(57, "1111111110010100");
    bldr3.set(58, "1111111110010101");
    bldr3.set(65, "111011");
    bldr3.set(66, "1111111000");
    bldr3.set(67, "1111111110010110");
    bldr3.set(68, "1111111110010111");
    bldr3.set(69, "1111111110011000");
    bldr3.set(70, "1111111110011001");
    bldr3.set(71, "1111111110011010");
    bldr3.set(72, "1111111110011011");
    bldr3.set(73, "1111111110011100");
    bldr3.set(74, "1111111110011101");
    bldr3.set(81, "1111010");
    bldr3.set(82, "11111110111");
    bldr3.set(83, "1111111110011110");
    bldr3.set(84, "1111111110011111");
    bldr3.set(85, "1111111110100000");
    bldr3.set(86, "1111111110100001");
    bldr3.set(87, "1111111110100010");
    bldr3.set(88, "1111111110100011");
    bldr3.set(89, "1111111110100100");
    bldr3.set(90, "1111111110100101");
    bldr3.set(97, "1111011");
    bldr3.set(98, "111111110110");
    bldr3.set(99, "1111111110100110");
    bldr3.set(100, "1111111110100111");
    bldr3.set(101, "1111111110101000");
    bldr3.set(102, "1111111110101001");
    bldr3.set(103, "1111111110101010");
    bldr3.set(104, "1111111110101011");
    bldr3.set(105, "1111111110101100");
    bldr3.set(106, "1111111110101101");
    bldr3.set(113, "11111010");
    bldr3.set(114, "111111110111");
    bldr3.set(115, "1111111110101110");
    bldr3.set(116, "1111111110101111");
    bldr3.set(117, "1111111110110000");
    bldr3.set(118, "1111111110110001");
    bldr3.set(119, "1111111110110010");
    bldr3.set(120, "1111111110110011");
    bldr3.set(121, "1111111110110100");
    bldr3.set(122, "1111111110110101");
    bldr3.set(129, "111111000");
    bldr3.set(130, "111111111000000");
    bldr3.set(131, "1111111110110110");
    bldr3.set(132, "1111111110110111");
    bldr3.set(133, "1111111110111000");
    bldr3.set(134, "1111111110111001");
    bldr3.set(135, "1111111110111010");
    bldr3.set(136, "1111111110111011");
    bldr3.set(137, "1111111110111100");
    bldr3.set(138, "1111111110111101");
    bldr3.set(145, "111111001");
    bldr3.set(146, "1111111110111110");
    bldr3.set(147, "1111111110111111");
    bldr3.set(148, "1111111111000000");
    bldr3.set(149, "1111111111000001");
    bldr3.set(150, "1111111111000010");
    bldr3.set(151, "1111111111000011");
    bldr3.set(152, "1111111111000100");
    bldr3.set(153, "1111111111000101");
    bldr3.set(154, "1111111111000110");
    bldr3.set(161, "111111010");
    bldr3.set(162, "1111111111000111");
    bldr3.set(163, "1111111111001000");
    bldr3.set(164, "1111111111001001");
    bldr3.set(165, "1111111111001010");
    bldr3.set(166, "1111111111001011");
    bldr3.set(167, "1111111111001100");
    bldr3.set(168, "1111111111001101");
    bldr3.set(169, "1111111111001110");
    bldr3.set(170, "1111111111001111");
    bldr3.set(177, "1111111001");
    bldr3.set(178, "1111111111010000");
    bldr3.set(179, "1111111111010001");
    bldr3.set(180, "1111111111010010");
    bldr3.set(181, "1111111111010011");
    bldr3.set(182, "1111111111010100");
    bldr3.set(183, "1111111111010101");
    bldr3.set(184, "1111111111010110");
    bldr3.set(185, "1111111111010111");
    bldr3.set(186, "1111111111011000");
    bldr3.set(193, "1111111010");
    bldr3.set(194, "1111111111011001");
    bldr3.set(195, "1111111111011010");
    bldr3.set(196, "1111111111011011");
    bldr3.set(197, "1111111111011100");
    bldr3.set(198, "1111111111011101");
    bldr3.set(199, "1111111111011110");
    bldr3.set(200, "1111111111011111");
    bldr3.set(201, "1111111111100000");
    bldr3.set(202, "1111111111100001");
    bldr3.set(209, "11111111000");
    bldr3.set(210, "1111111111100010");
    bldr3.set(211, "1111111111100011");
    bldr3.set(212, "1111111111100100");
    bldr3.set(213, "1111111111100101");
    bldr3.set(214, "1111111111100110");
    bldr3.set(215, "1111111111100111");
    bldr3.set(216, "1111111111101000");
    bldr3.set(217, "1111111111101001");
    bldr3.set(218, "1111111111101010");
    bldr3.set(225, "1111111111101011");
    bldr3.set(226, "1111111111101100");
    bldr3.set(227, "1111111111101101");
    bldr3.set(228, "1111111111101110");
    bldr3.set(229, "1111111111101111");
    bldr3.set(230, "1111111111110000");
    bldr3.set(231, "1111111111110001");
    bldr3.set(232, "1111111111110010");
    bldr3.set(233, "1111111111110011");
    bldr3.set(234, "1111111111110100");
    bldr3.set(240, "11111111001");
    bldr3.set(241, "1111111111110101");
    bldr3.set(242, "1111111111110110");
    bldr3.set(243, "1111111111110111");
    bldr3.set(244, "1111111111111000");
    bldr3.set(245, "1111111111111001");
    bldr3.set(246, "1111111111111010");
    bldr3.set(247, "1111111111111011");
    bldr3.set(248, "1111111111111100");
    bldr3.set(249, "1111111111111101");
    bldr3.set(250, "1111111111111110");
    JpegConst.YAC_DEFAULT = bldr3.getVLC();
    var bldr4 = new VLCBuilder();
    bldr4.set(0, "00");
    bldr4.set(1, "01");
    bldr4.set(2, "100");
    bldr4.set(3, "1010");
    bldr4.set(4, "11000");
    bldr4.set(5, "11001");
    bldr4.set(6, "111000");
    bldr4.set(7, "1111000");
    bldr4.set(8, "111110100");
    bldr4.set(9, "1111110110");
    bldr4.set(10, "111111110100");
    bldr4.set(17, "1011");
    bldr4.set(18, "111001");
    bldr4.set(19, "11110110");
    bldr4.set(20, "111110101");
    bldr4.set(21, "11111110110");
    bldr4.set(22, "111111110101");
    bldr4.set(23, "1111111110001000");
    bldr4.set(24, "1111111110001001");
    bldr4.set(25, "1111111110001010");
    bldr4.set(26, "1111111110001011");
    bldr4.set(33, "11010");
    bldr4.set(34, "11110111");
    bldr4.set(35, "1111110111");
    bldr4.set(36, "111111110110");
    bldr4.set(37, "111111111000010");
    bldr4.set(38, "1111111110001100");
    bldr4.set(39, "1111111110001101");
    bldr4.set(40, "1111111110001110");
    bldr4.set(41, "1111111110001111");
    bldr4.set(42, "1111111110010000");
    bldr4.set(49, "11011");
    bldr4.set(50, "11111000");
    bldr4.set(51, "1111111000");
    bldr4.set(52, "111111110111");
    bldr4.set(53, "1111111110010001");
    bldr4.set(54, "1111111110010010");
    bldr4.set(55, "1111111110010011");
    bldr4.set(56, "1111111110010100");
    bldr4.set(57, "1111111110010101");
    bldr4.set(58, "1111111110010110");
    bldr4.set(65, "111010");
    bldr4.set(66, "111110110");
    bldr4.set(67, "1111111110010111");
    bldr4.set(68, "1111111110011000");
    bldr4.set(69, "1111111110011001");
    bldr4.set(70, "1111111110011010");
    bldr4.set(71, "1111111110011011");
    bldr4.set(72, "1111111110011100");
    bldr4.set(73, "1111111110011101");
    bldr4.set(74, "1111111110011110");
    bldr4.set(81, "111011");
    bldr4.set(82, "1111111001");
    bldr4.set(83, "1111111110011111");
    bldr4.set(84, "1111111110100000");
    bldr4.set(85, "1111111110100001");
    bldr4.set(86, "1111111110100010");
    bldr4.set(87, "1111111110100011");
    bldr4.set(88, "1111111110100100");
    bldr4.set(89, "1111111110100101");
    bldr4.set(90, "1111111110100110");
    bldr4.set(97, "1111001");
    bldr4.set(98, "11111110111");
    bldr4.set(99, "1111111110100111");
    bldr4.set(100, "1111111110101000");
    bldr4.set(101, "1111111110101001");
    bldr4.set(102, "1111111110101010");
    bldr4.set(103, "1111111110101011");
    bldr4.set(104, "1111111110101100");
    bldr4.set(105, "1111111110101101");
    bldr4.set(106, "1111111110101110");
    bldr4.set(113, "1111010");
    bldr4.set(114, "11111111000");
    bldr4.set(115, "1111111110101111");
    bldr4.set(116, "1111111110110000");
    bldr4.set(117, "1111111110110001");
    bldr4.set(118, "1111111110110010");
    bldr4.set(119, "1111111110110011");
    bldr4.set(120, "1111111110110100");
    bldr4.set(121, "1111111110110101");
    bldr4.set(122, "1111111110110110");
    bldr4.set(129, "11111001");
    bldr4.set(130, "1111111110110111");
    bldr4.set(131, "1111111110111000");
    bldr4.set(132, "1111111110111001");
    bldr4.set(133, "1111111110111010");
    bldr4.set(134, "1111111110111011");
    bldr4.set(135, "1111111110111100");
    bldr4.set(136, "1111111110111101");
    bldr4.set(137, "1111111110111110");
    bldr4.set(138, "1111111110111111");
    bldr4.set(145, "111110111");
    bldr4.set(146, "1111111111000000");
    bldr4.set(147, "1111111111000001");
    bldr4.set(148, "1111111111000010");
    bldr4.set(149, "1111111111000011");
    bldr4.set(150, "1111111111000100");
    bldr4.set(151, "1111111111000101");
    bldr4.set(152, "1111111111000110");
    bldr4.set(153, "1111111111000111");
    bldr4.set(154, "1111111111001000");
    bldr4.set(161, "111111000");
    bldr4.set(162, "1111111111001001");
    bldr4.set(163, "1111111111001010");
    bldr4.set(164, "1111111111001011");
    bldr4.set(165, "1111111111001100");
    bldr4.set(166, "1111111111001101");
    bldr4.set(167, "1111111111001110");
    bldr4.set(168, "1111111111001111");
    bldr4.set(169, "1111111111010000");
    bldr4.set(170, "1111111111010001");
    bldr4.set(177, "111111001");
    bldr4.set(178, "1111111111010010");
    bldr4.set(179, "1111111111010011");
    bldr4.set(180, "1111111111010100");
    bldr4.set(181, "1111111111010101");
    bldr4.set(182, "1111111111010110");
    bldr4.set(183, "1111111111010111");
    bldr4.set(184, "1111111111011000");
    bldr4.set(185, "1111111111011001");
    bldr4.set(186, "1111111111011010");
    bldr4.set(193, "111111010");
    bldr4.set(194, "1111111111011011");
    bldr4.set(195, "1111111111011100");
    bldr4.set(196, "1111111111011101");
    bldr4.set(197, "1111111111011110");
    bldr4.set(198, "1111111111011111");
    bldr4.set(199, "1111111111100000");
    bldr4.set(200, "1111111111100001");
    bldr4.set(201, "1111111111100010");
    bldr4.set(202, "1111111111100011");
    bldr4.set(209, "11111111001");
    bldr4.set(210, "1111111111100100");
    bldr4.set(211, "1111111111100101");
    bldr4.set(212, "1111111111100110");
    bldr4.set(213, "1111111111100111");
    bldr4.set(214, "1111111111101000");
    bldr4.set(215, "1111111111101001");
    bldr4.set(216, "1111111111101010");
    bldr4.set(217, "1111111111101011");
    bldr4.set(218, "1111111111101100");
    bldr4.set(225, "11111111100000");
    bldr4.set(226, "1111111111101101");
    bldr4.set(227, "1111111111101110");
    bldr4.set(228, "1111111111101111");
    bldr4.set(229, "1111111111110000");
    bldr4.set(230, "1111111111110001");
    bldr4.set(231, "1111111111110010");
    bldr4.set(232, "1111111111110011");
    bldr4.set(233, "1111111111110100");
    bldr4.set(234, "1111111111110101");
    bldr4.set(240, "1111111010");
    bldr4.set(241, "111111111000011");
    bldr4.set(242, "1111111111110110");
    bldr4.set(243, "1111111111110111");
    bldr4.set(244, "1111111111111000");
    bldr4.set(245, "1111111111111001");
    bldr4.set(246, "1111111111111010");
    bldr4.set(247, "1111111111111011");
    bldr4.set(248, "1111111111111100");
    bldr4.set(249, "1111111111111101");
    bldr4.set(250, "1111111111111110");
    JpegConst.CAC_DEFAULT = bldr4.getVLC();
})();
(function() {
    for (var i = 0; i < JpegConst.names.length; i++) {
        JpegConst.names[i] = "(0x" + Integer.toHexString(i) + ")";
    }
    JpegConst.names[192] = "SOF0";
    JpegConst.names[193] = "SOF1";
    JpegConst.names[194] = "SOF2";
    JpegConst.names[195] = "SOF3";
    JpegConst.names[196] = "DHT";
    JpegConst.names[219] = "DQT";
    JpegConst.names[218] = "SOS";
    JpegConst.names[217] = "EOI";
    JpegConst.names[216] = "SOI";
    JpegConst.names[224] = "APP0";
    JpegConst.names[225] = "APP1";
    JpegConst.names[226] = "APP2";
    JpegConst.names[227] = "APP3";
    JpegConst.names[228] = "APP4";
    JpegConst.names[229] = "APP5";
    JpegConst.names[230] = "APP6";
    JpegConst.names[231] = "APP7";
    JpegConst.names[232] = "APP8";
    JpegConst.names[233] = "APP9";
    JpegConst.names[234] = "APPA";
    JpegConst.names[235] = "APPB";
    JpegConst.names[236] = "APPC";
    JpegConst.names[237] = "APPD";
    JpegConst.names[238] = "APPE";
    JpegConst.names[239] = "APPF";
    JpegConst.names[208] = "RST0";
    JpegConst.names[209] = "RST1";
    JpegConst.names[210] = "RST2";
    JpegConst.names[211] = "RST3";
    JpegConst.names[212] = "RST4";
    JpegConst.names[213] = "RST5";
    JpegConst.names[214] = "RST6";
    JpegConst.names[215] = "RST7";
    JpegConst.names[221] = "DRI";
})();
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MPEGConst = function() {};
MPEGConst = stjs.extend(MPEGConst, null, [], function(constructor, prototype) {
    constructor.PICTURE_START_CODE = 0;
    constructor.SLICE_START_CODE_FIRST = 1;
    constructor.SLICE_START_CODE_LAST = 175;
    constructor.USER_DATA_START_CODE = 178;
    constructor.SEQUENCE_HEADER_CODE = 179;
    constructor.SEQUENCE_ERROR_CODE = 180;
    constructor.EXTENSION_START_CODE = 181;
    constructor.SEQUENCE_END_CODE = 183;
    constructor.GROUP_START_CODE = 184;
    constructor.vlcAddressIncrement = null;
    constructor.vlcMBTypeI = null;
    constructor.mbTypeValI = null;
    constructor.vlcMBTypeP = null;
    constructor.mbTypeValP = null;
    constructor.vlcMBTypeB = null;
    constructor.mbTypeValB = null;
    constructor.vlcMBTypeISpat = null;
    constructor.mbTypeValISpat = null;
    constructor.vlcMBTypePSpat = null;
    constructor.mbTypeValPSpat = null;
    constructor.vlcMBTypeBSpat = null;
    constructor.mbTypeValBSpat = null;
    constructor.vlcMBTypeSNR = null;
    constructor.mbTypeValSNR = null;
    constructor.vlcCBP = null;
    constructor.vlcMotionCode = null;
    constructor.vlcDualPrime = null;
    constructor.vlcDCSizeLuma = null;
    constructor.vlcDCSizeChroma = null;
    constructor.vlcCoeff0 = null;
    constructor.vlcCoeff1 = null;
    constructor.MBType = function(macroblock_quant, macroblock_motion_forward, macroblock_motion_backward, macroblock_pattern, macroblock_intra, spatial_temporal_weight_code_flag, permitted_spatial_temporal_weight_classes) {
        this.macroblock_quant = macroblock_quant;
        this.macroblock_motion_forward = macroblock_motion_forward;
        this.macroblock_motion_backward = macroblock_motion_backward;
        this.macroblock_pattern = macroblock_pattern;
        this.macroblock_intra = macroblock_intra;
        this.spatial_temporal_weight_code_flag = spatial_temporal_weight_code_flag;
        this.permitted_spatial_temporal_weight_classes = permitted_spatial_temporal_weight_classes;
    };
    constructor.MBType = stjs.extend(constructor.MBType, null, [], function(constructor, prototype) {
        prototype.macroblock_quant = 0;
        prototype.macroblock_motion_forward = 0;
        prototype.macroblock_motion_backward = 0;
        prototype.macroblock_pattern = 0;
        prototype.macroblock_intra = 0;
        prototype.spatial_temporal_weight_code_flag = 0;
        prototype.permitted_spatial_temporal_weight_classes = 0;
    }, {}, {});
    constructor.CODE_ESCAPE = 2049;
    constructor.CODE_END = 2048;
    constructor.qScaleTab1 = new Int32Array([0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62]);
    constructor.qScaleTab2 = new Int32Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 18, 20, 22, 24, 28, 32, 36, 40, 44, 48, 52, 56, 64, 72, 80, 88, 96, 104, 112]);
    constructor.defaultQMatIntra = new Int32Array([8, 16, 19, 22, 26, 27, 29, 34, 16, 16, 22, 24, 27, 29, 34, 37, 19, 22, 26, 27, 29, 34, 34, 38, 22, 22, 26, 27, 29, 34, 37, 40, 22, 26, 27, 29, 32, 35, 40, 48, 26, 27, 29, 32, 35, 40, 48, 58, 26, 27, 29, 34, 38, 46, 56, 69, 27, 29, 35, 38, 46, 56, 69, 83]);
    constructor.defaultQMatInter = new Int32Array([16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16]);
    constructor.scan = [new Int32Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]), new Int32Array([0, 8, 16, 24, 1, 9, 2, 10, 17, 25, 32, 40, 48, 56, 57, 49, 41, 33, 26, 18, 3, 11, 4, 12, 19, 27, 34, 42, 50, 58, 35, 43, 51, 59, 20, 28, 5, 13, 6, 14, 21, 29, 36, 44, 52, 60, 37, 45, 53, 61, 22, 30, 7, 15, 23, 31, 38, 46, 54, 62, 39, 47, 55, 63])];
    constructor.BLOCK_TO_CC = new Int32Array([0, 0, 0, 0, 1, 2, 1, 2, 1, 2, 1, 2]);
    constructor.BLOCK_POS_X = new Int32Array([0, 8, 0, 8, 0, 0, 0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 0, 8, 0, 8, 0, 0, 0, 0, 8, 8, 8, 8]);
    constructor.BLOCK_POS_Y = new Int32Array([0, 0, 8, 8, 0, 0, 8, 8, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1]);
    constructor.STEP_Y = new Int32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]);
    constructor.SQUEEZE_X = new Int32Array([0, 1, 1, 0]);
    constructor.SQUEEZE_Y = new Int32Array([0, 1, 0, 0]);
    constructor.IntraCoded = 1;
    constructor.PredictiveCoded = 2;
    constructor.BiPredictiveCoded = 3;
}, {vlcAddressIncrement: "VLC", vlcMBTypeI: "VLC", mbTypeValI: "Array", vlcMBTypeP: "VLC", mbTypeValP: "Array", vlcMBTypeB: "VLC", mbTypeValB: "Array", vlcMBTypeISpat: "VLC", mbTypeValISpat: "Array", vlcMBTypePSpat: "VLC", mbTypeValPSpat: "Array", vlcMBTypeBSpat: "VLC", mbTypeValBSpat: "Array", vlcMBTypeSNR: "VLC", mbTypeValSNR: "Array", vlcCBP: "VLC", vlcMotionCode: "VLC", vlcDualPrime: "VLC", vlcDCSizeLuma: "VLC", vlcDCSizeChroma: "VLC", vlcCoeff0: "VLC", vlcCoeff1: "VLC", qScaleTab1: "Int32Array", qScaleTab2: "Int32Array", defaultQMatIntra: "Int32Array", defaultQMatInter: "Int32Array", scan: "Array", BLOCK_TO_CC: "Int32Array", BLOCK_POS_X: "Int32Array", BLOCK_POS_Y: "Int32Array", STEP_Y: "Int32Array", SQUEEZE_X: "Int32Array", SQUEEZE_Y: "Int32Array"}, {});
(function() {
    MPEGConst.vlcAddressIncrement = VLC.createVLC("1", "011", "010", "0011", "0010", "00011", "00010", "0000111", "0000110", "00001011", "00001010", "00001001", "00001000", "00000111", "00000110", "0000010111", "0000010110", "0000010101", "0000010100", "0000010011", "0000010010", "00000100011", "00000100010", "00000100001", "00000100000", "00000011111", "00000011110", "00000011101", "00000011100", "00000011011", "00000011010", "00000011001", "00000011000");
    MPEGConst.vlcMBTypeI = VLC.createVLC("1", "01");
    MPEGConst.mbTypeValI = [new MPEGConst.MBType(0, 0, 0, 0, 1, 0, 0), new MPEGConst.MBType(1, 0, 0, 0, 1, 0, 0)];
    MPEGConst.vlcMBTypeP = VLC.createVLC("1", "01", "001", "00011", "00010", "00001", "000001");
    MPEGConst.mbTypeValP = [new MPEGConst.MBType(0, 1, 0, 1, 0, 0, 0), new MPEGConst.MBType(0, 0, 0, 1, 0, 0, 0), new MPEGConst.MBType(0, 1, 0, 0, 0, 0, 0), new MPEGConst.MBType(0, 0, 0, 0, 1, 0, 0), new MPEGConst.MBType(1, 1, 0, 1, 0, 0, 0), new MPEGConst.MBType(1, 0, 0, 1, 0, 0, 0), new MPEGConst.MBType(1, 0, 0, 0, 1, 0, 0)];
    MPEGConst.vlcMBTypeB = VLC.createVLC("10", "11", "010", "011", "0010", "0011", "00011", "00010", "000011", "000010", "000001");
    MPEGConst.mbTypeValB = [new MPEGConst.MBType(0, 1, 1, 0, 0, 0, 0), new MPEGConst.MBType(0, 1, 1, 1, 0, 0, 0), new MPEGConst.MBType(0, 0, 1, 0, 0, 0, 0), new MPEGConst.MBType(0, 0, 1, 1, 0, 0, 0), new MPEGConst.MBType(0, 1, 0, 0, 0, 0, 0), new MPEGConst.MBType(0, 1, 0, 1, 0, 0, 0), new MPEGConst.MBType(0, 0, 0, 0, 1, 0, 0), new MPEGConst.MBType(1, 1, 1, 1, 0, 0, 0), new MPEGConst.MBType(1, 1, 0, 1, 0, 0, 0), new MPEGConst.MBType(1, 0, 1, 1, 0, 0, 0), new MPEGConst.MBType(1, 0, 0, 0, 1, 0, 0)];
    MPEGConst.vlcMBTypeISpat = VLC.createVLC("1", "01", "0011", "0010", "0001");
    MPEGConst.mbTypeValISpat = [new MPEGConst.MBType(0, 0, 0, 0, 1, 0, 0), new MPEGConst.MBType(1, 0, 0, 0, 1, 0, 0), new MPEGConst.MBType(0, 0, 0, 0, 1, 0, 0), new MPEGConst.MBType(1, 0, 0, 0, 1, 0, 0), new MPEGConst.MBType(0, 0, 0, 0, 0, 0, 0)];
    MPEGConst.vlcMBTypePSpat = VLC.createVLC("10", "011", "0000100", "000111", "0010", "0000111", "0011", "010", "000100", "0000110", "11", "000101", "000110", "0000101", "0000010", "0000011");
    MPEGConst.mbTypeValPSpat = [new MPEGConst.MBType(0, 1, 0, 1, 0, 0, 0), new MPEGConst.MBType(0, 1, 0, 1, 0, 1, 0), new MPEGConst.MBType(0, 0, 0, 1, 0, 0, 0), new MPEGConst.MBType(0, 0, 0, 1, 0, 1, 0), new MPEGConst.MBType(0, 1, 0, 0, 0, 0, 0), new MPEGConst.MBType(0, 0, 0, 0, 1, 0, 0), new MPEGConst.MBType(0, 1, 0, 0, 0, 1, 0), new MPEGConst.MBType(1, 1, 0, 1, 0, 0, 0), new MPEGConst.MBType(1, 0, 0, 1, 0, 0, 0), new MPEGConst.MBType(1, 0, 0, 0, 1, 0, 0), new MPEGConst.MBType(1, 1, 0, 1, 0, 1, 0), new MPEGConst.MBType(1, 0, 0, 1, 0, 1, 0), new MPEGConst.MBType(0, 0, 0, 0, 0, 1, 0), new MPEGConst.MBType(0, 0, 0, 1, 0, 0, 0), new MPEGConst.MBType(1, 0, 0, 1, 0, 0, 0), new MPEGConst.MBType(0, 0, 0, 0, 0, 0, 0)];
    MPEGConst.vlcMBTypeBSpat = VLC.createVLC("10", "11", "010", "011", "0010", "0011", "000110", "000111", "000100", "000101", "0000110", "0000111", "0000100", "0000101", "00000100", "00000101", "000001100", "000001110", "000001101", "000001111");
    MPEGConst.mbTypeValBSpat = [new MPEGConst.MBType(0, 1, 1, 0, 0, 0, 0), new MPEGConst.MBType(0, 1, 1, 1, 0, 0, 0), new MPEGConst.MBType(0, 0, 1, 0, 0, 0, 0), new MPEGConst.MBType(0, 0, 1, 1, 0, 0, 0), new MPEGConst.MBType(0, 1, 0, 0, 0, 0, 0), new MPEGConst.MBType(0, 1, 0, 1, 0, 0, 0), new MPEGConst.MBType(0, 0, 1, 0, 0, 1, 0), new MPEGConst.MBType(0, 0, 1, 1, 0, 1, 0), new MPEGConst.MBType(0, 1, 0, 0, 0, 1, 0), new MPEGConst.MBType(0, 1, 0, 1, 0, 1, 0), new MPEGConst.MBType(0, 0, 0, 0, 1, 0, 0), new MPEGConst.MBType(1, 1, 1, 1, 0, 0, 0), new MPEGConst.MBType(1, 1, 0, 1, 0, 0, 0), new MPEGConst.MBType(1, 0, 1, 1, 0, 0, 0), new MPEGConst.MBType(1, 0, 0, 0, 1, 0, 0), new MPEGConst.MBType(1, 1, 0, 1, 0, 1, 0), new MPEGConst.MBType(1, 0, 1, 1, 0, 1, 0), new MPEGConst.MBType(0, 0, 0, 0, 0, 0, 0), new MPEGConst.MBType(1, 0, 0, 1, 0, 0, 0), new MPEGConst.MBType(0, 0, 0, 1, 0, 0, 0)];
    MPEGConst.vlcMBTypeSNR = VLC.createVLC("1", "01", "001");
    MPEGConst.mbTypeValSNR = [new MPEGConst.MBType(0, 0, 0, 1, 0, 0, 0), new MPEGConst.MBType(1, 0, 0, 1, 0, 0, 0), new MPEGConst.MBType(0, 0, 0, 0, 0, 0, 0)];
    MPEGConst.vlcCBP = VLC.createVLC("000000001", "01011", "01001", "001101", "1101", "0010111", "0010011", "00011111", "1100", "0010110", "0010010", "00011110", "10011", "00011011", "00010111", "00010011", "1011", "0010101", "0010001", "00011101", "10001", "00011001", "00010101", "00010001", "001111", "00001111", "00001101", "000000011", "01111", "00001011", "00000111", "000000111", "1010", "0010100", "0010000", "00011100", "001110", "00001110", "00001100", "000000010", "10000", "00011000", "00010100", "00010000", "01110", "00001010", "00000110", "000000110", "10010", "00011010", "00010110", "00010010", "01101", "00001001", "00000101", "000000101", "01100", "00001000", "00000100", "000000100", "111", "01010", "01000", "001100");
    MPEGConst.vlcMotionCode = VLC.createVLC("1", "01", "001", "0001", "000011", "0000101", "0000100", "0000011", "000001011", "000001010", "000001001", "0000010001", "0000010000", "0000001111", "0000001110", "0000001101", "0000001100");
    MPEGConst.vlcDualPrime = VLC.createVLC("11", "0", "10");
    MPEGConst.vlcDCSizeLuma = VLC.createVLC("100", "00", "01", "101", "110", "1110", "11110", "111110", "1111110", "11111110", "111111110", "111111111");
    MPEGConst.vlcDCSizeChroma = VLC.createVLC("00", "01", "10", "110", "1110", "11110", "111110", "1111110", "11111110", "111111110", "1111111110", "1111111111");
    var vlcCoeffBldr = new VLCBuilder();
    vlcCoeffBldr.set(MPEGConst.CODE_ESCAPE, "000001");
    vlcCoeffBldr.set(MPEGConst.CODE_END, "10");
    vlcCoeffBldr.set((0 << 6) | 1, "11");
    vlcCoeffBldr.set((1 << 6) | 1, "011");
    vlcCoeffBldr.set((0 << 6) | 2, "0100");
    vlcCoeffBldr.set((2 << 6) | 1, "0101");
    vlcCoeffBldr.set((0 << 6) | 3, "00101");
    vlcCoeffBldr.set((3 << 6) | 1, "00111");
    vlcCoeffBldr.set((4 << 6) | 1, "00110");
    vlcCoeffBldr.set((1 << 6) | 2, "000110");
    vlcCoeffBldr.set((5 << 6) | 1, "000111");
    vlcCoeffBldr.set((6 << 6) | 1, "000101");
    vlcCoeffBldr.set((7 << 6) | 1, "000100");
    vlcCoeffBldr.set((0 << 6) | 4, "0000110");
    vlcCoeffBldr.set((2 << 6) | 2, "0000100");
    vlcCoeffBldr.set((8 << 6) | 1, "0000111");
    vlcCoeffBldr.set((9 << 6) | 1, "0000101");
    vlcCoeffBldr.set((0 << 6) | 5, "00100110");
    vlcCoeffBldr.set((0 << 6) | 6, "00100001");
    vlcCoeffBldr.set((1 << 6) | 3, "00100101");
    vlcCoeffBldr.set((3 << 6) | 2, "00100100");
    vlcCoeffBldr.set((10 << 6) | 1, "00100111");
    vlcCoeffBldr.set((11 << 6) | 1, "00100011");
    vlcCoeffBldr.set((12 << 6) | 1, "00100010");
    vlcCoeffBldr.set((13 << 6) | 1, "00100000");
    vlcCoeffBldr.set((0 << 6) | 7, "0000001010");
    vlcCoeffBldr.set((1 << 6) | 4, "0000001100");
    vlcCoeffBldr.set((2 << 6) | 3, "0000001011");
    vlcCoeffBldr.set((4 << 6) | 2, "0000001111");
    vlcCoeffBldr.set((5 << 6) | 2, "0000001001");
    vlcCoeffBldr.set((14 << 6) | 1, "0000001110");
    vlcCoeffBldr.set((15 << 6) | 1, "0000001101");
    vlcCoeffBldr.set((16 << 6) | 1, "0000001000");
    vlcCoeffBldr.set((0 << 6) | 8, "000000011101");
    vlcCoeffBldr.set((0 << 6) | 9, "000000011000");
    vlcCoeffBldr.set((0 << 6) | 10, "000000010011");
    vlcCoeffBldr.set((0 << 6) | 11, "000000010000");
    vlcCoeffBldr.set((1 << 6) | 5, "000000011011");
    vlcCoeffBldr.set((2 << 6) | 4, "000000010100");
    vlcCoeffBldr.set((3 << 6) | 3, "000000011100");
    vlcCoeffBldr.set((4 << 6) | 3, "000000010010");
    vlcCoeffBldr.set((6 << 6) | 2, "000000011110");
    vlcCoeffBldr.set((7 << 6) | 2, "000000010101");
    vlcCoeffBldr.set((8 << 6) | 2, "000000010001");
    vlcCoeffBldr.set((17 << 6) | 1, "000000011111");
    vlcCoeffBldr.set((18 << 6) | 1, "000000011010");
    vlcCoeffBldr.set((19 << 6) | 1, "000000011001");
    vlcCoeffBldr.set((20 << 6) | 1, "000000010111");
    vlcCoeffBldr.set((21 << 6) | 1, "000000010110");
    vlcCoeffBldr.set((0 << 6) | 12, "0000000011010");
    vlcCoeffBldr.set((0 << 6) | 13, "0000000011001");
    vlcCoeffBldr.set((0 << 6) | 14, "0000000011000");
    vlcCoeffBldr.set((0 << 6) | 15, "0000000010111");
    vlcCoeffBldr.set((1 << 6) | 6, "0000000010110");
    vlcCoeffBldr.set((1 << 6) | 7, "0000000010101");
    vlcCoeffBldr.set((2 << 6) | 5, "0000000010100");
    vlcCoeffBldr.set((3 << 6) | 4, "0000000010011");
    vlcCoeffBldr.set((5 << 6) | 3, "0000000010010");
    vlcCoeffBldr.set((9 << 6) | 2, "0000000010001");
    vlcCoeffBldr.set((10 << 6) | 2, "0000000010000");
    vlcCoeffBldr.set((22 << 6) | 1, "0000000011111");
    vlcCoeffBldr.set((23 << 6) | 1, "0000000011110");
    vlcCoeffBldr.set((24 << 6) | 1, "0000000011101");
    vlcCoeffBldr.set((25 << 6) | 1, "0000000011100");
    vlcCoeffBldr.set((26 << 6) | 1, "0000000011011");
    vlcCoeffBldr.set((0 << 6) | 16, "00000000011111");
    vlcCoeffBldr.set((0 << 6) | 17, "00000000011110");
    vlcCoeffBldr.set((0 << 6) | 18, "00000000011101");
    vlcCoeffBldr.set((0 << 6) | 19, "00000000011100");
    vlcCoeffBldr.set((0 << 6) | 20, "00000000011011");
    vlcCoeffBldr.set((0 << 6) | 21, "00000000011010");
    vlcCoeffBldr.set((0 << 6) | 22, "00000000011001");
    vlcCoeffBldr.set((0 << 6) | 23, "00000000011000");
    vlcCoeffBldr.set((0 << 6) | 24, "00000000010111");
    vlcCoeffBldr.set((0 << 6) | 25, "00000000010110");
    vlcCoeffBldr.set((0 << 6) | 26, "00000000010101");
    vlcCoeffBldr.set((0 << 6) | 27, "00000000010100");
    vlcCoeffBldr.set((0 << 6) | 28, "00000000010011");
    vlcCoeffBldr.set((0 << 6) | 29, "00000000010010");
    vlcCoeffBldr.set((0 << 6) | 30, "00000000010001");
    vlcCoeffBldr.set((0 << 6) | 31, "00000000010000");
    vlcCoeffBldr.set((0 << 6) | 32, "000000000011000");
    vlcCoeffBldr.set((0 << 6) | 33, "000000000010111");
    vlcCoeffBldr.set((0 << 6) | 34, "000000000010110");
    vlcCoeffBldr.set((0 << 6) | 35, "000000000010101");
    vlcCoeffBldr.set((0 << 6) | 36, "000000000010100");
    vlcCoeffBldr.set((0 << 6) | 37, "000000000010011");
    vlcCoeffBldr.set((0 << 6) | 38, "000000000010010");
    vlcCoeffBldr.set((0 << 6) | 39, "000000000010001");
    vlcCoeffBldr.set((0 << 6) | 40, "000000000010000");
    vlcCoeffBldr.set((1 << 6) | 8, "000000000011111");
    vlcCoeffBldr.set((1 << 6) | 9, "000000000011110");
    vlcCoeffBldr.set((1 << 6) | 10, "000000000011101");
    vlcCoeffBldr.set((1 << 6) | 11, "000000000011100");
    vlcCoeffBldr.set((1 << 6) | 12, "000000000011011");
    vlcCoeffBldr.set((1 << 6) | 13, "000000000011010");
    vlcCoeffBldr.set((1 << 6) | 14, "000000000011001");
    vlcCoeffBldr.set((1 << 6) | 15, "0000000000010011");
    vlcCoeffBldr.set((1 << 6) | 16, "0000000000010010");
    vlcCoeffBldr.set((1 << 6) | 17, "0000000000010001");
    vlcCoeffBldr.set((1 << 6) | 18, "0000000000010000");
    vlcCoeffBldr.set((6 << 6) | 3, "0000000000010100");
    vlcCoeffBldr.set((11 << 6) | 2, "0000000000011010");
    vlcCoeffBldr.set((12 << 6) | 2, "0000000000011001");
    vlcCoeffBldr.set((13 << 6) | 2, "0000000000011000");
    vlcCoeffBldr.set((14 << 6) | 2, "0000000000010111");
    vlcCoeffBldr.set((15 << 6) | 2, "0000000000010110");
    vlcCoeffBldr.set((16 << 6) | 2, "0000000000010101");
    vlcCoeffBldr.set((27 << 6) | 1, "0000000000011111");
    vlcCoeffBldr.set((28 << 6) | 1, "0000000000011110");
    vlcCoeffBldr.set((29 << 6) | 1, "0000000000011101");
    vlcCoeffBldr.set((30 << 6) | 1, "0000000000011100");
    vlcCoeffBldr.set((31 << 6) | 1, "0000000000011011");
    MPEGConst.vlcCoeff0 = vlcCoeffBldr.getVLC();
    vlcCoeffBldr = new VLCBuilder();
    vlcCoeffBldr.set(MPEGConst.CODE_ESCAPE, "000001");
    vlcCoeffBldr.set(MPEGConst.CODE_END, "0110");
    vlcCoeffBldr.set((0 << 6) | 1, "10");
    vlcCoeffBldr.set((1 << 6) | 1, "010");
    vlcCoeffBldr.set((0 << 6) | 2, "110");
    vlcCoeffBldr.set((2 << 6) | 1, "00101");
    vlcCoeffBldr.set((0 << 6) | 3, "0111");
    vlcCoeffBldr.set((3 << 6) | 1, "00111");
    vlcCoeffBldr.set((4 << 6) | 1, "000110");
    vlcCoeffBldr.set((1 << 6) | 2, "00110");
    vlcCoeffBldr.set((5 << 6) | 1, "000111");
    vlcCoeffBldr.set((6 << 6) | 1, "0000110");
    vlcCoeffBldr.set((7 << 6) | 1, "0000100");
    vlcCoeffBldr.set((0 << 6) | 4, "11100");
    vlcCoeffBldr.set((2 << 6) | 2, "0000111");
    vlcCoeffBldr.set((8 << 6) | 1, "0000101");
    vlcCoeffBldr.set((9 << 6) | 1, "1111000");
    vlcCoeffBldr.set((0 << 6) | 5, "11101");
    vlcCoeffBldr.set((0 << 6) | 6, "000101");
    vlcCoeffBldr.set((1 << 6) | 3, "1111001");
    vlcCoeffBldr.set((3 << 6) | 2, "00100110");
    vlcCoeffBldr.set((10 << 6) | 1, "1111010");
    vlcCoeffBldr.set((11 << 6) | 1, "00100001");
    vlcCoeffBldr.set((12 << 6) | 1, "00100101");
    vlcCoeffBldr.set((13 << 6) | 1, "00100100");
    vlcCoeffBldr.set((0 << 6) | 7, "000100");
    vlcCoeffBldr.set((1 << 6) | 4, "00100111");
    vlcCoeffBldr.set((2 << 6) | 3, "11111100");
    vlcCoeffBldr.set((4 << 6) | 2, "11111101");
    vlcCoeffBldr.set((5 << 6) | 2, "000000100");
    vlcCoeffBldr.set((14 << 6) | 1, "000000101");
    vlcCoeffBldr.set((15 << 6) | 1, "000000111");
    vlcCoeffBldr.set((16 << 6) | 1, "0000001101");
    vlcCoeffBldr.set((0 << 6) | 8, "1111011");
    vlcCoeffBldr.set((0 << 6) | 9, "1111100");
    vlcCoeffBldr.set((0 << 6) | 10, "00100011");
    vlcCoeffBldr.set((0 << 6) | 11, "00100010");
    vlcCoeffBldr.set((1 << 6) | 5, "00100000");
    vlcCoeffBldr.set((2 << 6) | 4, "0000001100");
    vlcCoeffBldr.set((3 << 6) | 3, "000000011100");
    vlcCoeffBldr.set((4 << 6) | 3, "000000010010");
    vlcCoeffBldr.set((6 << 6) | 2, "000000011110");
    vlcCoeffBldr.set((7 << 6) | 2, "000000010101");
    vlcCoeffBldr.set((8 << 6) | 2, "000000010001");
    vlcCoeffBldr.set((17 << 6) | 1, "000000011111");
    vlcCoeffBldr.set((18 << 6) | 1, "000000011010");
    vlcCoeffBldr.set((19 << 6) | 1, "000000011001");
    vlcCoeffBldr.set((20 << 6) | 1, "000000010111");
    vlcCoeffBldr.set((21 << 6) | 1, "000000010110");
    vlcCoeffBldr.set((0 << 6) | 12, "11111010");
    vlcCoeffBldr.set((0 << 6) | 13, "11111011");
    vlcCoeffBldr.set((0 << 6) | 14, "11111110");
    vlcCoeffBldr.set((0 << 6) | 15, "11111111");
    vlcCoeffBldr.set((1 << 6) | 6, "0000000010110");
    vlcCoeffBldr.set((1 << 6) | 7, "0000000010101");
    vlcCoeffBldr.set((2 << 6) | 5, "0000000010100");
    vlcCoeffBldr.set((3 << 6) | 4, "0000000010011");
    vlcCoeffBldr.set((5 << 6) | 3, "0000000010010");
    vlcCoeffBldr.set((9 << 6) | 2, "0000000010001");
    vlcCoeffBldr.set((10 << 6) | 2, "0000000010000");
    vlcCoeffBldr.set((22 << 6) | 1, "0000000011111");
    vlcCoeffBldr.set((23 << 6) | 1, "0000000011110");
    vlcCoeffBldr.set((24 << 6) | 1, "0000000011101");
    vlcCoeffBldr.set((25 << 6) | 1, "0000000011100");
    vlcCoeffBldr.set((26 << 6) | 1, "0000000011011");
    vlcCoeffBldr.set((0 << 6) | 16, "00000000011111");
    vlcCoeffBldr.set((0 << 6) | 17, "00000000011110");
    vlcCoeffBldr.set((0 << 6) | 18, "00000000011101");
    vlcCoeffBldr.set((0 << 6) | 19, "00000000011100");
    vlcCoeffBldr.set((0 << 6) | 20, "00000000011011");
    vlcCoeffBldr.set((0 << 6) | 21, "00000000011010");
    vlcCoeffBldr.set((0 << 6) | 22, "00000000011001");
    vlcCoeffBldr.set((0 << 6) | 23, "00000000011000");
    vlcCoeffBldr.set((0 << 6) | 24, "00000000010111");
    vlcCoeffBldr.set((0 << 6) | 25, "00000000010110");
    vlcCoeffBldr.set((0 << 6) | 26, "00000000010101");
    vlcCoeffBldr.set((0 << 6) | 27, "00000000010100");
    vlcCoeffBldr.set((0 << 6) | 28, "00000000010011");
    vlcCoeffBldr.set((0 << 6) | 29, "00000000010010");
    vlcCoeffBldr.set((0 << 6) | 30, "00000000010001");
    vlcCoeffBldr.set((0 << 6) | 31, "00000000010000");
    vlcCoeffBldr.set((0 << 6) | 32, "000000000011000");
    vlcCoeffBldr.set((0 << 6) | 33, "000000000010111");
    vlcCoeffBldr.set((0 << 6) | 34, "000000000010110");
    vlcCoeffBldr.set((0 << 6) | 35, "000000000010101");
    vlcCoeffBldr.set((0 << 6) | 36, "000000000010100");
    vlcCoeffBldr.set((0 << 6) | 37, "000000000010011");
    vlcCoeffBldr.set((0 << 6) | 38, "000000000010010");
    vlcCoeffBldr.set((0 << 6) | 39, "000000000010001");
    vlcCoeffBldr.set((0 << 6) | 40, "000000000010000");
    vlcCoeffBldr.set((1 << 6) | 8, "000000000011111");
    vlcCoeffBldr.set((1 << 6) | 9, "000000000011110");
    vlcCoeffBldr.set((1 << 6) | 10, "000000000011101");
    vlcCoeffBldr.set((1 << 6) | 11, "000000000011100");
    vlcCoeffBldr.set((1 << 6) | 12, "000000000011011");
    vlcCoeffBldr.set((1 << 6) | 13, "000000000011010");
    vlcCoeffBldr.set((1 << 6) | 14, "000000000011001");
    vlcCoeffBldr.set((1 << 6) | 15, "0000000000010011");
    vlcCoeffBldr.set((1 << 6) | 16, "0000000000010010");
    vlcCoeffBldr.set((1 << 6) | 17, "0000000000010001");
    vlcCoeffBldr.set((1 << 6) | 18, "0000000000010000");
    vlcCoeffBldr.set((6 << 6) | 3, "0000000000010100");
    vlcCoeffBldr.set((11 << 6) | 2, "0000000000011010");
    vlcCoeffBldr.set((12 << 6) | 2, "0000000000011001");
    vlcCoeffBldr.set((13 << 6) | 2, "0000000000011000");
    vlcCoeffBldr.set((14 << 6) | 2, "0000000000010111");
    vlcCoeffBldr.set((15 << 6) | 2, "0000000000010110");
    vlcCoeffBldr.set((16 << 6) | 2, "0000000000010101");
    vlcCoeffBldr.set((27 << 6) | 1, "0000000000011111");
    vlcCoeffBldr.set((28 << 6) | 1, "0000000000011110");
    vlcCoeffBldr.set((29 << 6) | 1, "0000000000011101");
    vlcCoeffBldr.set((30 << 6) | 1, "0000000000011100");
    vlcCoeffBldr.set((31 << 6) | 1, "0000000000011011");
    MPEGConst.vlcCoeff1 = vlcCoeffBldr.getVLC();
})();
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var H264Const = function() {};
H264Const = stjs.extend(H264Const, null, [], function(constructor, prototype) {
    constructor.CoeffToken = Array(10);
    constructor.coeffTokenChromaDCY420 = null;
    constructor.coeffTokenChromaDCY422 = null;
    constructor.run = null;
    constructor.totalZeros16 = [new VLCBuilder().set(0, "1").set(1, "011").set(2, "010").set(3, "0011").set(4, "0010").set(5, "00011").set(6, "00010").set(7, "000011").set(8, "000010").set(9, "0000011").set(10, "0000010").set(11, "00000011").set(12, "00000010").set(13, "000000011").set(14, "000000010").set(15, "000000001").getVLC(), new VLCBuilder().set(0, "111").set(1, "110").set(2, "101").set(3, "100").set(4, "011").set(5, "0101").set(6, "0100").set(7, "0011").set(8, "0010").set(9, "00011").set(10, "00010").set(11, "000011").set(12, "000010").set(13, "000001").set(14, "000000").getVLC(), new VLCBuilder().set(0, "0101").set(1, "111").set(2, "110").set(3, "101").set(4, "0100").set(5, "0011").set(6, "100").set(7, "011").set(8, "0010").set(9, "00011").set(10, "00010").set(11, "000001").set(12, "00001").set(13, "000000").getVLC(), new VLCBuilder().set(0, "00011").set(1, "111").set(2, "0101").set(3, "0100").set(4, "110").set(5, "101").set(6, "100").set(7, "0011").set(8, "011").set(9, "0010").set(10, "00010").set(11, "00001").set(12, "00000").getVLC(), new VLCBuilder().set(0, "0101").set(1, "0100").set(2, "0011").set(3, "111").set(4, "110").set(5, "101").set(6, "100").set(7, "011").set(8, "0010").set(9, "00001").set(10, "0001").set(11, "00000").getVLC(), new VLCBuilder().set(0, "000001").set(1, "00001").set(2, "111").set(3, "110").set(4, "101").set(5, "100").set(6, "011").set(7, "010").set(8, "0001").set(9, "001").set(10, "000000").getVLC(), new VLCBuilder().set(0, "000001").set(1, "00001").set(2, "101").set(3, "100").set(4, "011").set(5, "11").set(6, "010").set(7, "0001").set(8, "001").set(9, "000000").getVLC(), new VLCBuilder().set(0, "000001").set(1, "0001").set(2, "00001").set(3, "011").set(4, "11").set(5, "10").set(6, "010").set(7, "001").set(8, "000000").getVLC(), new VLCBuilder().set(0, "000001").set(1, "000000").set(2, "0001").set(3, "11").set(4, "10").set(5, "001").set(6, "01").set(7, "00001").getVLC(), new VLCBuilder().set(0, "00001").set(1, "00000").set(2, "001").set(3, "11").set(4, "10").set(5, "01").set(6, "0001").getVLC(), new VLCBuilder().set(0, "0000").set(1, "0001").set(2, "001").set(3, "010").set(4, "1").set(5, "011").getVLC(), new VLCBuilder().set(0, "0000").set(1, "0001").set(2, "01").set(3, "1").set(4, "001").getVLC(), new VLCBuilder().set(0, "000").set(1, "001").set(2, "1").set(3, "01").getVLC(), new VLCBuilder().set(0, "00").set(1, "01").set(2, "1").getVLC(), new VLCBuilder().set(0, "0").set(1, "1").getVLC()];
    constructor.totalZeros4 = [new VLCBuilder().set(0, "1").set(1, "01").set(2, "001").set(3, "000").getVLC(), new VLCBuilder().set(0, "1").set(1, "01").set(2, "00").getVLC(), new VLCBuilder().set(0, "1").set(1, "0").getVLC()];
    constructor.totalZeros8 = [new VLCBuilder().set(0, "1").set(1, "010").set(2, "011").set(3, "0010").set(4, "0011").set(5, "0001").set(6, "00001").set(7, "00000").getVLC(), new VLCBuilder().set(0, "000").set(1, "01").set(2, "001").set(3, "100").set(4, "101").set(5, "110").set(6, "111").getVLC(), new VLCBuilder().set(0, "000").set(1, "001").set(2, "01").set(3, "10").set(4, "110").set(5, "111").getVLC(), new VLCBuilder().set(0, "110").set(1, "00").set(2, "01").set(3, "10").set(4, "111").getVLC(), new VLCBuilder().set(0, "00").set(1, "01").set(2, "10").set(3, "11").getVLC(), new VLCBuilder().set(0, "00").set(1, "01").set(2, "1").getVLC(), new VLCBuilder().set(0, "0").set(1, "1").getVLC()];
    constructor.PartPred = stjs.enumeration("L0", "L1", "Bi", "Direct");
    constructor.bPredModes = [null, [H264Const.PartPred.L0], [H264Const.PartPred.L1], [H264Const.PartPred.Bi], [H264Const.PartPred.L0, H264Const.PartPred.L0], [H264Const.PartPred.L0, H264Const.PartPred.L0], [H264Const.PartPred.L1, H264Const.PartPred.L1], [H264Const.PartPred.L1, H264Const.PartPred.L1], [H264Const.PartPred.L0, H264Const.PartPred.L1], [H264Const.PartPred.L0, H264Const.PartPred.L1], [H264Const.PartPred.L1, H264Const.PartPred.L0], [H264Const.PartPred.L1, H264Const.PartPred.L0], [H264Const.PartPred.L0, H264Const.PartPred.Bi], [H264Const.PartPred.L0, H264Const.PartPred.Bi], [H264Const.PartPred.L1, H264Const.PartPred.Bi], [H264Const.PartPred.L1, H264Const.PartPred.Bi], [H264Const.PartPred.Bi, H264Const.PartPred.L0], [H264Const.PartPred.Bi, H264Const.PartPred.L0], [H264Const.PartPred.Bi, H264Const.PartPred.L1], [H264Const.PartPred.Bi, H264Const.PartPred.L1], [H264Const.PartPred.Bi, H264Const.PartPred.Bi], [H264Const.PartPred.Bi, H264Const.PartPred.Bi]];
    constructor.bMbTypes = [MBType.B_Direct_16x16, MBType.B_L0_16x16, MBType.B_L1_16x16, MBType.B_Bi_16x16, MBType.B_L0_L0_16x8, MBType.B_L0_L0_8x16, MBType.B_L1_L1_16x8, MBType.B_L1_L1_8x16, MBType.B_L0_L1_16x8, MBType.B_L0_L1_8x16, MBType.B_L1_L0_16x8, MBType.B_L1_L0_8x16, MBType.B_L0_Bi_16x8, MBType.B_L0_Bi_8x16, MBType.B_L1_Bi_16x8, MBType.B_L1_Bi_8x16, MBType.B_Bi_L0_16x8, MBType.B_Bi_L0_8x16, MBType.B_Bi_L1_16x8, MBType.B_Bi_L1_8x16, MBType.B_Bi_Bi_16x8, MBType.B_Bi_Bi_8x16, MBType.B_8x8];
    constructor.bPartW = new Int32Array([0, 16, 16, 16, 16, 8, 16, 8, 16, 8, 16, 8, 16, 8, 16, 8, 16, 8, 16, 8, 16, 8]);
    constructor.bPartH = new Int32Array([0, 16, 16, 16, 8, 16, 8, 16, 8, 16, 8, 16, 8, 16, 8, 16, 8, 16, 8, 16, 8, 16]);
    constructor.BLK_X = new Int32Array([0, 4, 0, 4, 8, 12, 8, 12, 0, 4, 0, 4, 8, 12, 8, 12]);
    constructor.BLK_Y = new Int32Array([0, 0, 4, 4, 0, 0, 4, 4, 8, 8, 12, 12, 8, 8, 12, 12]);
    constructor.BLK_8x8_X = new Int32Array([0, 8, 0, 8]);
    constructor.BLK_8x8_Y = new Int32Array([0, 0, 8, 8]);
    constructor.BLK_INV_MAP = new Int32Array([0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15]);
    constructor.MB_BLK_OFF_LEFT = new Int32Array([0, 1, 0, 1, 2, 3, 2, 3, 0, 1, 0, 1, 2, 3, 2, 3]);
    constructor.MB_BLK_OFF_TOP = new Int32Array([0, 0, 1, 1, 0, 0, 1, 1, 2, 2, 3, 3, 2, 2, 3, 3]);
    constructor.QP_SCALE_CR = new Int32Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 29, 30, 31, 32, 32, 33, 34, 34, 35, 35, 36, 36, 37, 37, 37, 38, 38, 38, 39, 39, 39, 39]);
    constructor.NO_PIC = Picture8Bit.createPicture8Bit(0, 0, null, null);
    constructor.BLK_8x8_MB_OFF_LUMA = new Int32Array([0, 8, 128, 136]);
    constructor.BLK_8x8_MB_OFF_CHROMA = new Int32Array([0, 4, 32, 36]);
    constructor.BLK_4x4_MB_OFF_LUMA = new Int32Array([0, 4, 8, 12, 64, 68, 72, 76, 128, 132, 136, 140, 192, 196, 200, 204]);
    constructor.BLK_8x8_IND = new Int32Array([0, 0, 1, 1, 0, 0, 1, 1, 2, 2, 3, 3, 2, 2, 3, 3]);
    constructor.BLK8x8_BLOCKS = [new Int32Array([0, 1, 4, 5]), new Int32Array([2, 3, 6, 7]), new Int32Array([8, 9, 12, 13]), new Int32Array([10, 11, 14, 15])];
    constructor.ARRAY = [new Int32Array([0]), new Int32Array([1]), new Int32Array([2]), new Int32Array([3])];
    constructor.CODED_BLOCK_PATTERN_INTRA_COLOR = new Int32Array([47, 31, 15, 0, 23, 27, 29, 30, 7, 11, 13, 14, 39, 43, 45, 46, 16, 3, 5, 10, 12, 19, 21, 26, 28, 35, 37, 42, 44, 1, 2, 4, 8, 17, 18, 20, 24, 6, 9, 22, 25, 32, 33, 34, 36, 40, 38, 41]);
    constructor.coded_block_pattern_intra_monochrome = new Int32Array([15, 0, 7, 11, 13, 14, 3, 5, 10, 12, 1, 2, 4, 8, 6, 9]);
    constructor.CODED_BLOCK_PATTERN_INTER_COLOR = new Int32Array([0, 16, 1, 2, 4, 8, 32, 3, 5, 10, 12, 15, 47, 7, 11, 13, 14, 6, 9, 31, 35, 37, 42, 44, 33, 34, 36, 40, 39, 43, 45, 46, 17, 18, 20, 24, 19, 21, 26, 28, 23, 27, 29, 30, 22, 25, 38, 41]);
    constructor.inverse = function(arr) {
        var inv = new Int32Array(arr.length);
        for (var i = 0; i < inv.length; i++) {
            inv[arr[i]] = i;
        }
        return inv;
    };
    constructor.CODED_BLOCK_PATTERN_INTER_COLOR_INV = H264Const.inverse(H264Const.CODED_BLOCK_PATTERN_INTER_COLOR);
    constructor.coded_block_pattern_inter_monochrome = new Int32Array([0, 1, 2, 4, 8, 3, 5, 10, 12, 15, 7, 11, 13, 14, 6, 9]);
    constructor.sig_coeff_map_8x8 = new Int32Array([0, 1, 2, 3, 4, 5, 5, 4, 4, 3, 3, 4, 4, 4, 5, 5, 4, 4, 4, 4, 3, 3, 6, 7, 7, 7, 8, 9, 10, 9, 8, 7, 7, 6, 11, 12, 13, 11, 6, 7, 8, 9, 14, 10, 9, 8, 6, 11, 12, 13, 11, 6, 9, 14, 10, 9, 11, 12, 13, 11, 14, 10, 12]);
    constructor.sig_coeff_map_8x8_mbaff = new Int32Array([0, 1, 1, 2, 2, 3, 3, 4, 5, 6, 7, 7, 7, 8, 4, 5, 6, 9, 10, 10, 8, 11, 12, 11, 9, 9, 10, 10, 8, 11, 12, 11, 9, 9, 10, 10, 8, 11, 12, 11, 9, 9, 10, 10, 8, 13, 13, 9, 9, 10, 10, 8, 13, 13, 9, 9, 10, 10, 14, 14, 14, 14, 14]);
    constructor.last_sig_coeff_map_8x8 = new Int32Array([0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8]);
    constructor.identityMapping16 = new Int32Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);
    constructor.identityMapping4 = new Int32Array([0, 1, 2, 3]);
    constructor.bPartPredModes = [H264Const.PartPred.Direct, H264Const.PartPred.L0, H264Const.PartPred.L1, H264Const.PartPred.Bi, H264Const.PartPred.L0, H264Const.PartPred.L0, H264Const.PartPred.L1, H264Const.PartPred.L1, H264Const.PartPred.Bi, H264Const.PartPred.Bi, H264Const.PartPred.L0, H264Const.PartPred.L1, H264Const.PartPred.Bi];
    constructor.bSubMbTypes = new Int32Array([0, 0, 0, 0, 1, 2, 1, 2, 1, 2, 3, 3, 3]);
    constructor.LUMA_4x4_BLOCK_LUT = new Int32Array(256);
    constructor.LUMA_4x4_POS_LUT = new Int32Array(256);
    constructor.LUMA_8x8_BLOCK_LUT = new Int32Array(256);
    constructor.LUMA_8x8_POS_LUT = new Int32Array(256);
    constructor.CHROMA_BLOCK_LUT = new Int32Array(64);
    constructor.CHROMA_POS_LUT = new Int32Array(64);
    constructor.COMP_BLOCK_4x4_LUT = [H264Const.LUMA_4x4_BLOCK_LUT, H264Const.CHROMA_BLOCK_LUT, H264Const.CHROMA_BLOCK_LUT];
    constructor.COMP_POS_4x4_LUT = [H264Const.LUMA_4x4_POS_LUT, H264Const.CHROMA_POS_LUT, H264Const.CHROMA_POS_LUT];
    constructor.COMP_BLOCK_8x8_LUT = [H264Const.LUMA_8x8_BLOCK_LUT, H264Const.CHROMA_BLOCK_LUT, H264Const.CHROMA_BLOCK_LUT];
    constructor.COMP_POS_8x8_LUT = [H264Const.LUMA_8x8_POS_LUT, H264Const.CHROMA_POS_LUT, H264Const.CHROMA_POS_LUT];
    constructor.putBlk = function(_in, blkX, blkY, blkW, blkH, stride, out) {
        for (var line = 0, srcOff = 0, dstOff = blkY * stride + blkX; line < blkH; line++) {
            for (var i = 0; i < blkW; i++) 
                out[dstOff + i] = _in[srcOff + i];
            srcOff += blkW;
            dstOff += stride;
        }
    };
    constructor.buildPixSplitMap4x4 = function() {
        var result = [new Int32Array([0, 1, 2, 3, 16, 17, 18, 19, 32, 33, 34, 35, 48, 49, 50, 51]), new Int32Array(16), new Int32Array(16), new Int32Array(16), new Int32Array(16), new Int32Array(16), new Int32Array(16), new Int32Array(16), new Int32Array(16), new Int32Array(16), new Int32Array(16), new Int32Array(16), new Int32Array(16), new Int32Array(16), new Int32Array(16), new Int32Array(16)];
        for (var blkY = 0, blk = 0, off = 0; blkY < 4; ++blkY) {
            for (var blkX = 0; blkX < 4; ++blkX , ++blk , off += 4) {
                for (var i = 0; i < 16; i++) 
                    result[blk][i] = result[0][i] + off;
            }
            off += 48;
        }
        return result;
    };
    constructor.buildPixSplitMap2x2 = function() {
        var result = [new Int32Array([0, 1, 2, 3, 8, 9, 10, 11, 16, 17, 18, 19, 24, 25, 26, 27]), new Int32Array(16), new Int32Array(16), new Int32Array(16)];
        for (var blkY = 0, blk = 0, off = 0; blkY < 2; ++blkY) {
            for (var blkX = 0; blkX < 2; ++blkX , ++blk , off += 4) {
                for (var i = 0; i < 16; i++) 
                    result[blk][i] = result[0][i] + off;
            }
            off += 24;
        }
        return result;
    };
    constructor.usesList = function(pred, l) {
        return pred == H264Const.PartPred.Bi ? true : (pred == H264Const.PartPred.L0 && l == 0 || pred == H264Const.PartPred.L1 && l == 1);
    };
    constructor.coeffToken = function(totalCoeff, trailingOnes) {
        return (totalCoeff << 4) | trailingOnes;
    };
    constructor.PIX_MAP_SPLIT_4x4 = H264Const.buildPixSplitMap4x4();
    constructor.PIX_MAP_SPLIT_2x2 = H264Const.buildPixSplitMap2x2();
}, {CoeffToken: "Array", coeffTokenChromaDCY420: "VLC", coeffTokenChromaDCY422: "VLC", run: "Array", totalZeros16: "Array", totalZeros4: "Array", totalZeros8: "Array", bPredModes: "Array", bMbTypes: "Array", bPartW: "Int32Array", bPartH: "Int32Array", BLK_X: "Int32Array", BLK_Y: "Int32Array", BLK_8x8_X: "Int32Array", BLK_8x8_Y: "Int32Array", BLK_INV_MAP: "Int32Array", MB_BLK_OFF_LEFT: "Int32Array", MB_BLK_OFF_TOP: "Int32Array", QP_SCALE_CR: "Int32Array", NO_PIC: "Picture8Bit", BLK_8x8_MB_OFF_LUMA: "Int32Array", BLK_8x8_MB_OFF_CHROMA: "Int32Array", BLK_4x4_MB_OFF_LUMA: "Int32Array", BLK_8x8_IND: "Int32Array", BLK8x8_BLOCKS: "Array", ARRAY: "Array", CODED_BLOCK_PATTERN_INTRA_COLOR: "Int32Array", coded_block_pattern_intra_monochrome: "Int32Array", CODED_BLOCK_PATTERN_INTER_COLOR: "Int32Array", CODED_BLOCK_PATTERN_INTER_COLOR_INV: "Int32Array", coded_block_pattern_inter_monochrome: "Int32Array", sig_coeff_map_8x8: "Int32Array", sig_coeff_map_8x8_mbaff: "Int32Array", last_sig_coeff_map_8x8: "Int32Array", identityMapping16: "Int32Array", identityMapping4: "Int32Array", bPartPredModes: "Array", bSubMbTypes: "Int32Array", LUMA_4x4_BLOCK_LUT: "Int32Array", LUMA_4x4_POS_LUT: "Int32Array", LUMA_8x8_BLOCK_LUT: "Int32Array", LUMA_8x8_POS_LUT: "Int32Array", CHROMA_BLOCK_LUT: "Int32Array", CHROMA_POS_LUT: "Int32Array", COMP_BLOCK_4x4_LUT: "Array", COMP_POS_4x4_LUT: "Array", COMP_BLOCK_8x8_LUT: "Array", COMP_POS_8x8_LUT: "Array", PIX_MAP_SPLIT_4x4: "Array", PIX_MAP_SPLIT_2x2: "Array"}, {});
(function() {
    var vbl = new VLCBuilder();
    vbl.set((0 << 4) | 0, "1");
    vbl.set(H264Const.coeffToken(1, 0), "000101");
    vbl.set(H264Const.coeffToken(1, 1), "01");
    vbl.set(H264Const.coeffToken(2, 0), "00000111");
    vbl.set(H264Const.coeffToken(2, 1), "000100");
    vbl.set(H264Const.coeffToken(2, 2), "001");
    vbl.set(H264Const.coeffToken(3, 0), "000000111");
    vbl.set(H264Const.coeffToken(3, 1), "00000110");
    vbl.set(H264Const.coeffToken(3, 2), "0000101");
    vbl.set(H264Const.coeffToken(3, 3), "00011");
    vbl.set(H264Const.coeffToken(4, 0), "0000000111");
    vbl.set(H264Const.coeffToken(4, 1), "000000110");
    vbl.set(H264Const.coeffToken(4, 2), "00000101");
    vbl.set(H264Const.coeffToken(4, 3), "000011");
    vbl.set(H264Const.coeffToken(5, 0), "00000000111");
    vbl.set(H264Const.coeffToken(5, 1), "0000000110");
    vbl.set(H264Const.coeffToken(5, 2), "000000101");
    vbl.set(H264Const.coeffToken(5, 3), "0000100");
    vbl.set(H264Const.coeffToken(6, 0), "0000000001111");
    vbl.set(H264Const.coeffToken(6, 1), "00000000110");
    vbl.set(H264Const.coeffToken(6, 2), "0000000101");
    vbl.set(H264Const.coeffToken(6, 3), "00000100");
    vbl.set(H264Const.coeffToken(7, 0), "0000000001011");
    vbl.set(H264Const.coeffToken(7, 1), "0000000001110");
    vbl.set(H264Const.coeffToken(7, 2), "00000000101");
    vbl.set(H264Const.coeffToken(7, 3), "000000100");
    vbl.set(H264Const.coeffToken(8, 0), "0000000001000");
    vbl.set(H264Const.coeffToken(8, 1), "0000000001010");
    vbl.set(H264Const.coeffToken(8, 2), "0000000001101");
    vbl.set(H264Const.coeffToken(8, 3), "0000000100");
    vbl.set(H264Const.coeffToken(9, 0), "00000000001111");
    vbl.set(H264Const.coeffToken(9, 1), "00000000001110");
    vbl.set(H264Const.coeffToken(9, 2), "0000000001001");
    vbl.set(H264Const.coeffToken(9, 3), "00000000100");
    vbl.set(H264Const.coeffToken(10, 0), "00000000001011");
    vbl.set(H264Const.coeffToken(10, 1), "00000000001010");
    vbl.set(H264Const.coeffToken(10, 2), "00000000001101");
    vbl.set(H264Const.coeffToken(10, 3), "0000000001100");
    vbl.set(H264Const.coeffToken(11, 0), "000000000001111");
    vbl.set(H264Const.coeffToken(11, 1), "000000000001110");
    vbl.set(H264Const.coeffToken(11, 2), "00000000001001");
    vbl.set(H264Const.coeffToken(11, 3), "00000000001100");
    vbl.set(H264Const.coeffToken(12, 0), "000000000001011");
    vbl.set(H264Const.coeffToken(12, 1), "000000000001010");
    vbl.set(H264Const.coeffToken(12, 2), "000000000001101");
    vbl.set(H264Const.coeffToken(12, 3), "00000000001000");
    vbl.set(H264Const.coeffToken(13, 0), "0000000000001111");
    vbl.set(H264Const.coeffToken(13, 1), "000000000000001");
    vbl.set(H264Const.coeffToken(13, 2), "000000000001001");
    vbl.set(H264Const.coeffToken(13, 3), "000000000001100");
    vbl.set(H264Const.coeffToken(14, 0), "0000000000001011");
    vbl.set(H264Const.coeffToken(14, 1), "0000000000001110");
    vbl.set(H264Const.coeffToken(14, 2), "0000000000001101");
    vbl.set(H264Const.coeffToken(14, 3), "000000000001000");
    vbl.set(H264Const.coeffToken(15, 0), "0000000000000111");
    vbl.set(H264Const.coeffToken(15, 1), "0000000000001010");
    vbl.set(H264Const.coeffToken(15, 2), "0000000000001001");
    vbl.set(H264Const.coeffToken(15, 3), "0000000000001100");
    vbl.set(H264Const.coeffToken(16, 0), "0000000000000100");
    vbl.set(H264Const.coeffToken(16, 1), "0000000000000110");
    vbl.set(H264Const.coeffToken(16, 2), "0000000000000101");
    vbl.set(H264Const.coeffToken(16, 3), "0000000000001000");
    H264Const.CoeffToken[0] = H264Const.CoeffToken[1] = vbl.getVLC();
})();
(function() {
    var vbl = new VLCBuilder();
    vbl.set(H264Const.coeffToken(0, 0), "11");
    vbl.set(H264Const.coeffToken(1, 0), "001011");
    vbl.set(H264Const.coeffToken(1, 1), "10");
    vbl.set(H264Const.coeffToken(2, 0), "000111");
    vbl.set(H264Const.coeffToken(2, 1), "00111");
    vbl.set(H264Const.coeffToken(2, 2), "011");
    vbl.set(H264Const.coeffToken(3, 0), "0000111");
    vbl.set(H264Const.coeffToken(3, 1), "001010");
    vbl.set(H264Const.coeffToken(3, 2), "001001");
    vbl.set(H264Const.coeffToken(3, 3), "0101");
    vbl.set(H264Const.coeffToken(4, 0), "00000111");
    vbl.set(H264Const.coeffToken(4, 1), "000110");
    vbl.set(H264Const.coeffToken(4, 2), "000101");
    vbl.set(H264Const.coeffToken(4, 3), "0100");
    vbl.set(H264Const.coeffToken(5, 0), "00000100");
    vbl.set(H264Const.coeffToken(5, 1), "0000110");
    vbl.set(H264Const.coeffToken(5, 2), "0000101");
    vbl.set(H264Const.coeffToken(5, 3), "00110");
    vbl.set(H264Const.coeffToken(6, 0), "000000111");
    vbl.set(H264Const.coeffToken(6, 1), "00000110");
    vbl.set(H264Const.coeffToken(6, 2), "00000101");
    vbl.set(H264Const.coeffToken(6, 3), "001000");
    vbl.set(H264Const.coeffToken(7, 0), "00000001111");
    vbl.set(H264Const.coeffToken(7, 1), "000000110");
    vbl.set(H264Const.coeffToken(7, 2), "000000101");
    vbl.set(H264Const.coeffToken(7, 3), "000100");
    vbl.set(H264Const.coeffToken(8, 0), "00000001011");
    vbl.set(H264Const.coeffToken(8, 1), "00000001110");
    vbl.set(H264Const.coeffToken(8, 2), "00000001101");
    vbl.set(H264Const.coeffToken(8, 3), "0000100");
    vbl.set(H264Const.coeffToken(9, 0), "000000001111");
    vbl.set(H264Const.coeffToken(9, 1), "00000001010");
    vbl.set(H264Const.coeffToken(9, 2), "00000001001");
    vbl.set(H264Const.coeffToken(9, 3), "000000100");
    vbl.set(H264Const.coeffToken(10, 0), "000000001011");
    vbl.set(H264Const.coeffToken(10, 1), "000000001110");
    vbl.set(H264Const.coeffToken(10, 2), "000000001101");
    vbl.set(H264Const.coeffToken(10, 3), "00000001100");
    vbl.set(H264Const.coeffToken(11, 0), "000000001000");
    vbl.set(H264Const.coeffToken(11, 1), "000000001010");
    vbl.set(H264Const.coeffToken(11, 2), "000000001001");
    vbl.set(H264Const.coeffToken(11, 3), "00000001000");
    vbl.set(H264Const.coeffToken(12, 0), "0000000001111");
    vbl.set(H264Const.coeffToken(12, 1), "0000000001110");
    vbl.set(H264Const.coeffToken(12, 2), "0000000001101");
    vbl.set(H264Const.coeffToken(12, 3), "000000001100");
    vbl.set(H264Const.coeffToken(13, 0), "0000000001011");
    vbl.set(H264Const.coeffToken(13, 1), "0000000001010");
    vbl.set(H264Const.coeffToken(13, 2), "0000000001001");
    vbl.set(H264Const.coeffToken(13, 3), "0000000001100");
    vbl.set(H264Const.coeffToken(14, 0), "0000000000111");
    vbl.set(H264Const.coeffToken(14, 1), "00000000001011");
    vbl.set(H264Const.coeffToken(14, 2), "0000000000110");
    vbl.set(H264Const.coeffToken(14, 3), "0000000001000");
    vbl.set(H264Const.coeffToken(15, 0), "00000000001001");
    vbl.set(H264Const.coeffToken(15, 1), "00000000001000");
    vbl.set(H264Const.coeffToken(15, 2), "00000000001010");
    vbl.set(H264Const.coeffToken(15, 3), "0000000000001");
    vbl.set(H264Const.coeffToken(16, 0), "00000000000111");
    vbl.set(H264Const.coeffToken(16, 1), "00000000000110");
    vbl.set(H264Const.coeffToken(16, 2), "00000000000101");
    vbl.set(H264Const.coeffToken(16, 3), "00000000000100");
    H264Const.CoeffToken[2] = H264Const.CoeffToken[3] = vbl.getVLC();
})();
(function() {
    var vbl = new VLCBuilder();
    vbl.set(H264Const.coeffToken(0, 0), "1111");
    vbl.set(H264Const.coeffToken(1, 0), "001111");
    vbl.set(H264Const.coeffToken(1, 1), "1110");
    vbl.set(H264Const.coeffToken(2, 0), "001011");
    vbl.set(H264Const.coeffToken(2, 1), "01111");
    vbl.set(H264Const.coeffToken(2, 2), "1101");
    vbl.set(H264Const.coeffToken(3, 0), "001000");
    vbl.set(H264Const.coeffToken(3, 1), "01100");
    vbl.set(H264Const.coeffToken(3, 2), "01110");
    vbl.set(H264Const.coeffToken(3, 3), "1100");
    vbl.set(H264Const.coeffToken(4, 0), "0001111");
    vbl.set(H264Const.coeffToken(4, 1), "01010");
    vbl.set(H264Const.coeffToken(4, 2), "01011");
    vbl.set(H264Const.coeffToken(4, 3), "1011");
    vbl.set(H264Const.coeffToken(5, 0), "0001011");
    vbl.set(H264Const.coeffToken(5, 1), "01000");
    vbl.set(H264Const.coeffToken(5, 2), "01001");
    vbl.set(H264Const.coeffToken(5, 3), "1010");
    vbl.set(H264Const.coeffToken(6, 0), "0001001");
    vbl.set(H264Const.coeffToken(6, 1), "001110");
    vbl.set(H264Const.coeffToken(6, 2), "001101");
    vbl.set(H264Const.coeffToken(6, 3), "1001");
    vbl.set(H264Const.coeffToken(7, 0), "0001000");
    vbl.set(H264Const.coeffToken(7, 1), "001010");
    vbl.set(H264Const.coeffToken(7, 2), "001001");
    vbl.set(H264Const.coeffToken(7, 3), "1000");
    vbl.set(H264Const.coeffToken(8, 0), "00001111");
    vbl.set(H264Const.coeffToken(8, 1), "0001110");
    vbl.set(H264Const.coeffToken(8, 2), "0001101");
    vbl.set(H264Const.coeffToken(8, 3), "01101");
    vbl.set(H264Const.coeffToken(9, 0), "00001011");
    vbl.set(H264Const.coeffToken(9, 1), "00001110");
    vbl.set(H264Const.coeffToken(9, 2), "0001010");
    vbl.set(H264Const.coeffToken(9, 3), "001100");
    vbl.set(H264Const.coeffToken(10, 0), "000001111");
    vbl.set(H264Const.coeffToken(10, 1), "00001010");
    vbl.set(H264Const.coeffToken(10, 2), "00001101");
    vbl.set(H264Const.coeffToken(10, 3), "0001100");
    vbl.set(H264Const.coeffToken(11, 0), "000001011");
    vbl.set(H264Const.coeffToken(11, 1), "000001110");
    vbl.set(H264Const.coeffToken(11, 2), "00001001");
    vbl.set(H264Const.coeffToken(11, 3), "00001100");
    vbl.set(H264Const.coeffToken(12, 0), "000001000");
    vbl.set(H264Const.coeffToken(12, 1), "000001010");
    vbl.set(H264Const.coeffToken(12, 2), "000001101");
    vbl.set(H264Const.coeffToken(12, 3), "00001000");
    vbl.set(H264Const.coeffToken(13, 0), "0000001101");
    vbl.set(H264Const.coeffToken(13, 1), "000000111");
    vbl.set(H264Const.coeffToken(13, 2), "000001001");
    vbl.set(H264Const.coeffToken(13, 3), "000001100");
    vbl.set(H264Const.coeffToken(14, 0), "0000001001");
    vbl.set(H264Const.coeffToken(14, 1), "0000001100");
    vbl.set(H264Const.coeffToken(14, 2), "0000001011");
    vbl.set(H264Const.coeffToken(14, 3), "0000001010");
    vbl.set(H264Const.coeffToken(15, 0), "0000000101");
    vbl.set(H264Const.coeffToken(15, 1), "0000001000");
    vbl.set(H264Const.coeffToken(15, 2), "0000000111");
    vbl.set(H264Const.coeffToken(15, 3), "0000000110");
    vbl.set(H264Const.coeffToken(16, 0), "0000000001");
    vbl.set(H264Const.coeffToken(16, 1), "0000000100");
    vbl.set(H264Const.coeffToken(16, 2), "0000000011");
    vbl.set(H264Const.coeffToken(16, 3), "0000000010");
    H264Const.CoeffToken[4] = H264Const.CoeffToken[5] = H264Const.CoeffToken[6] = H264Const.CoeffToken[7] = vbl.getVLC();
})();
(function() {
    var vbl = new VLCBuilder();
    vbl.set(H264Const.coeffToken(0, 0), "000011");
    vbl.set(H264Const.coeffToken(1, 0), "000000");
    vbl.set(H264Const.coeffToken(1, 1), "000001");
    vbl.set(H264Const.coeffToken(2, 0), "000100");
    vbl.set(H264Const.coeffToken(2, 1), "000101");
    vbl.set(H264Const.coeffToken(2, 2), "000110");
    vbl.set(H264Const.coeffToken(3, 0), "001000");
    vbl.set(H264Const.coeffToken(3, 1), "001001");
    vbl.set(H264Const.coeffToken(3, 2), "001010");
    vbl.set(H264Const.coeffToken(3, 3), "001011");
    vbl.set(H264Const.coeffToken(4, 0), "001100");
    vbl.set(H264Const.coeffToken(4, 1), "001101");
    vbl.set(H264Const.coeffToken(4, 2), "001110");
    vbl.set(H264Const.coeffToken(4, 3), "001111");
    vbl.set(H264Const.coeffToken(5, 0), "010000");
    vbl.set(H264Const.coeffToken(5, 1), "010001");
    vbl.set(H264Const.coeffToken(5, 2), "010010");
    vbl.set(H264Const.coeffToken(5, 3), "010011");
    vbl.set(H264Const.coeffToken(6, 0), "010100");
    vbl.set(H264Const.coeffToken(6, 1), "010101");
    vbl.set(H264Const.coeffToken(6, 2), "010110");
    vbl.set(H264Const.coeffToken(6, 3), "010111");
    vbl.set(H264Const.coeffToken(7, 0), "011000");
    vbl.set(H264Const.coeffToken(7, 1), "011001");
    vbl.set(H264Const.coeffToken(7, 2), "011010");
    vbl.set(H264Const.coeffToken(7, 3), "011011");
    vbl.set(H264Const.coeffToken(8, 0), "011100");
    vbl.set(H264Const.coeffToken(8, 1), "011101");
    vbl.set(H264Const.coeffToken(8, 2), "011110");
    vbl.set(H264Const.coeffToken(8, 3), "011111");
    vbl.set(H264Const.coeffToken(9, 0), "100000");
    vbl.set(H264Const.coeffToken(9, 1), "100001");
    vbl.set(H264Const.coeffToken(9, 2), "100010");
    vbl.set(H264Const.coeffToken(9, 3), "100011");
    vbl.set(H264Const.coeffToken(10, 0), "100100");
    vbl.set(H264Const.coeffToken(10, 1), "100101");
    vbl.set(H264Const.coeffToken(10, 2), "100110");
    vbl.set(H264Const.coeffToken(10, 3), "100111");
    vbl.set(H264Const.coeffToken(11, 0), "101000");
    vbl.set(H264Const.coeffToken(11, 1), "101001");
    vbl.set(H264Const.coeffToken(11, 2), "101010");
    vbl.set(H264Const.coeffToken(11, 3), "101011");
    vbl.set(H264Const.coeffToken(12, 0), "101100");
    vbl.set(H264Const.coeffToken(12, 1), "101101");
    vbl.set(H264Const.coeffToken(12, 2), "101110");
    vbl.set(H264Const.coeffToken(12, 3), "101111");
    vbl.set(H264Const.coeffToken(13, 0), "110000");
    vbl.set(H264Const.coeffToken(13, 1), "110001");
    vbl.set(H264Const.coeffToken(13, 2), "110010");
    vbl.set(H264Const.coeffToken(13, 3), "110011");
    vbl.set(H264Const.coeffToken(14, 0), "110100");
    vbl.set(H264Const.coeffToken(14, 1), "110101");
    vbl.set(H264Const.coeffToken(14, 2), "110110");
    vbl.set(H264Const.coeffToken(14, 3), "110111");
    vbl.set(H264Const.coeffToken(15, 0), "111000");
    vbl.set(H264Const.coeffToken(15, 1), "111001");
    vbl.set(H264Const.coeffToken(15, 2), "111010");
    vbl.set(H264Const.coeffToken(15, 3), "111011");
    vbl.set(H264Const.coeffToken(16, 0), "111100");
    vbl.set(H264Const.coeffToken(16, 1), "111101");
    vbl.set(H264Const.coeffToken(16, 2), "111110");
    vbl.set(H264Const.coeffToken(16, 3), "111111");
    H264Const.CoeffToken[8] = vbl.getVLC();
})();
(function() {
    var vbl = new VLCBuilder();
    vbl.set(H264Const.coeffToken(0, 0), "01");
    vbl.set(H264Const.coeffToken(1, 0), "000111");
    vbl.set(H264Const.coeffToken(1, 1), "1");
    vbl.set(H264Const.coeffToken(2, 0), "000100");
    vbl.set(H264Const.coeffToken(2, 1), "000110");
    vbl.set(H264Const.coeffToken(2, 2), "001");
    vbl.set(H264Const.coeffToken(3, 0), "000011");
    vbl.set(H264Const.coeffToken(3, 1), "0000011");
    vbl.set(H264Const.coeffToken(3, 2), "0000010");
    vbl.set(H264Const.coeffToken(3, 3), "000101");
    vbl.set(H264Const.coeffToken(4, 0), "000010");
    vbl.set(H264Const.coeffToken(4, 1), "00000011");
    vbl.set(H264Const.coeffToken(4, 2), "00000010");
    vbl.set(H264Const.coeffToken(4, 3), "0000000");
    H264Const.coeffTokenChromaDCY420 = vbl.getVLC();
})();
(function() {
    var vbl = new VLCBuilder();
    vbl.set(H264Const.coeffToken(0, 0), "1");
    vbl.set(H264Const.coeffToken(1, 0), "0001111");
    vbl.set(H264Const.coeffToken(1, 1), "01");
    vbl.set(H264Const.coeffToken(2, 0), "0001110");
    vbl.set(H264Const.coeffToken(2, 1), "0001101");
    vbl.set(H264Const.coeffToken(2, 2), "001");
    vbl.set(H264Const.coeffToken(3, 0), "000000111");
    vbl.set(H264Const.coeffToken(3, 1), "0001100");
    vbl.set(H264Const.coeffToken(3, 2), "0001011");
    vbl.set(H264Const.coeffToken(3, 3), "00001");
    vbl.set(H264Const.coeffToken(4, 0), "000000110");
    vbl.set(H264Const.coeffToken(4, 1), "000000101");
    vbl.set(H264Const.coeffToken(4, 2), "0001010");
    vbl.set(H264Const.coeffToken(4, 3), "000001");
    vbl.set(H264Const.coeffToken(5, 0), "0000000111");
    vbl.set(H264Const.coeffToken(5, 1), "0000000110");
    vbl.set(H264Const.coeffToken(5, 2), "000000100");
    vbl.set(H264Const.coeffToken(5, 3), "0001001");
    vbl.set(H264Const.coeffToken(6, 0), "00000000111");
    vbl.set(H264Const.coeffToken(6, 1), "00000000110");
    vbl.set(H264Const.coeffToken(6, 2), "0000000101");
    vbl.set(H264Const.coeffToken(6, 3), "0001000");
    vbl.set(H264Const.coeffToken(7, 0), "000000000111");
    vbl.set(H264Const.coeffToken(7, 1), "000000000110");
    vbl.set(H264Const.coeffToken(7, 2), "00000000101");
    vbl.set(H264Const.coeffToken(7, 3), "0000000100");
    vbl.set(H264Const.coeffToken(8, 0), "0000000000111");
    vbl.set(H264Const.coeffToken(8, 1), "000000000101");
    vbl.set(H264Const.coeffToken(8, 2), "000000000100");
    vbl.set(H264Const.coeffToken(8, 3), "00000000100");
    H264Const.coeffTokenChromaDCY422 = vbl.getVLC();
})();
(function() {
    H264Const.run = [new VLCBuilder().set(0, "1").set(1, "0").getVLC(), new VLCBuilder().set(0, "1").set(1, "01").set(2, "00").getVLC(), new VLCBuilder().set(0, "11").set(1, "10").set(2, "01").set(3, "00").getVLC(), new VLCBuilder().set(0, "11").set(1, "10").set(2, "01").set(3, "001").set(4, "000").getVLC(), new VLCBuilder().set(0, "11").set(1, "10").set(2, "011").set(3, "010").set(4, "001").set(5, "000").getVLC(), new VLCBuilder().set(0, "11").set(1, "000").set(2, "001").set(3, "011").set(4, "010").set(5, "101").set(6, "100").getVLC(), new VLCBuilder().set(0, "111").set(1, "110").set(2, "101").set(3, "100").set(4, "011").set(5, "010").set(6, "001").set(7, "0001").set(8, "00001").set(9, "000001").set(10, "0000001").set(11, "00000001").set(12, "000000001").set(13, "0000000001").set(14, "00000000001").getVLC()];
})();
(function() {
    var tmp = new Int32Array(16);
    for (var blk = 0; blk < 16; blk++) {
        for (var i = 0; i < 16; i++) {
            tmp[i] = i;
        }
        H264Const.putBlk(tmp, H264Const.BLK_X[blk], H264Const.BLK_Y[blk], 4, 4, 16, H264Const.LUMA_4x4_POS_LUT);
        Arrays.fill(tmp, blk);
        H264Const.putBlk(tmp, H264Const.BLK_X[blk], H264Const.BLK_Y[blk], 4, 4, 16, H264Const.LUMA_4x4_BLOCK_LUT);
    }
    for (var blk = 0; blk < 4; blk++) {
        for (var i = 0; i < 16; i++) {
            tmp[i] = i;
        }
        H264Const.putBlk(tmp, H264Const.BLK_X[blk], H264Const.BLK_Y[blk], 4, 4, 8, H264Const.CHROMA_POS_LUT);
        Arrays.fill(tmp, blk);
        H264Const.putBlk(tmp, H264Const.BLK_X[blk], H264Const.BLK_Y[blk], 4, 4, 8, H264Const.CHROMA_BLOCK_LUT);
    }
    tmp = new Int32Array(64);
    for (var blk = 0; blk < 4; blk++) {
        for (var i = 0; i < 64; i++) {
            tmp[i] = i;
        }
        H264Const.putBlk(tmp, H264Const.BLK_8x8_X[blk], H264Const.BLK_8x8_Y[blk], 8, 8, 16, H264Const.LUMA_8x8_POS_LUT);
        Arrays.fill(tmp, blk);
        H264Const.putBlk(tmp, H264Const.BLK_8x8_X[blk], H264Const.BLK_8x8_Y[blk], 8, 8, 16, H264Const.LUMA_8x8_BLOCK_LUT);
    }
})();
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Generic transcode track
 *  
 *  @author The JCodec project
 *  
 */
var TranscodeTrack = function(proresTrack, frameDim) {
    this.transcoders = new ThreadLocal();
    this.src = proresTrack;
    this.scaleFactor = frameDim.getWidth() >= 960 ? 2 : 1;
    this.thumbWidth = frameDim.getWidth() >> this.scaleFactor;
    this.thumbHeight = (frameDim.getHeight() >> this.scaleFactor) & ~1;
    this.mbW = (this.thumbWidth + 15) >> 4;
    this.mbH = (this.thumbHeight + 15) >> 4;
    var size = new Size(this.thumbWidth, this.thumbHeight);
    var pasp = (proresTrack.getCodecMeta()).getPasp();
    var codecPrivate = ByteBuffer.allocate(1024);
    this.getCodecPrivate(codecPrivate, size);
    this.se = VideoCodecMeta.createVideoCodecMeta("avc1", codecPrivate, size, pasp);
    this.frameSize = this.getFrameSize(this.mbW * this.mbH, TranscodeTrack.TARGET_RATE);
    this.frameSize += this.frameSize >> 4;
};
TranscodeTrack = stjs.extend(TranscodeTrack, null, [VirtualTrack], function(constructor, prototype) {
    constructor.TARGET_RATE = 1024;
    prototype.frameSize = 0;
    prototype.src = null;
    prototype.se = null;
    prototype.transcoders = null;
    prototype.mbW = 0;
    prototype.mbH = 0;
    prototype.scaleFactor = 0;
    prototype.thumbWidth = 0;
    prototype.thumbHeight = 0;
    prototype.getFrameSize = function(mbCount, rate) {};
    prototype.getDecoder = function(scaleFactor) {};
    prototype.getEncoder = function(rate) {};
    prototype.getCodecPrivate = function(buf, size) {};
    prototype.getCodecMeta = function() {
        return this.se;
    };
    prototype.nextPacket = function() {
        var nextPacket = this.src.nextPacket();
        if (nextPacket == null) 
            return null;
        return new TranscodeTrack.TranscodePacket(this, nextPacket);
    };
    constructor.TranscodePacket = function(track, nextPacket) {
        VirtualPacketWrapper.call(this, nextPacket);
        this.track = track;
    };
    constructor.TranscodePacket = stjs.extend(constructor.TranscodePacket, VirtualPacketWrapper, [], function(constructor, prototype) {
        prototype.track = null;
        prototype.getDataLen = function() {
            return this.track.frameSize;
        };
        prototype.getData = function() {
            var t = this.track.transcoders.get();
            if (t == null) {
                t = new TranscodeTrack.Transcoder(this.track);
                this.track.transcoders.set(t);
            }
            var buf = ByteBuffer.allocate(this.track.frameSize);
            var data = this.src.getData();
            return t.transcodeFrame(data, buf);
        };
    }, {track: "TranscodeTrack", src: "VirtualPacket", byPts: {name: "Comparator", arguments: ["Object"]}}, {});
    constructor.Transcoder = function(track) {
        this.encoder = Array(3);
        this.track = track;
        this.decoder = track.getDecoder(track.scaleFactor);
        this.encoder[0] = track.getEncoder(TranscodeTrack.TARGET_RATE);
        this.encoder[1] = track.getEncoder(stjs.trunc((TranscodeTrack.TARGET_RATE * 0.9)));
        this.encoder[2] = track.getEncoder(stjs.trunc((TranscodeTrack.TARGET_RATE * 0.8)));
        this.pic0 = Picture8Bit.create(track.mbW << 4, track.mbH << 4, ColorSpace.YUV444);
    };
    constructor.Transcoder = stjs.extend(constructor.Transcoder, null, [], function(constructor, prototype) {
        prototype.decoder = null;
        prototype.encoder = null;
        prototype.pic0 = null;
        prototype.pic1 = null;
        prototype.transform = null;
        prototype.track = null;
        prototype.transcodeFrame = function(src, dst) {
            var decoded = this.decoder.decodeFrame8Bit(src, this.pic0.getData());
            if (this.pic1 == null) {
                this.pic1 = Picture8Bit.create(decoded.getWidth(), decoded.getHeight(), ColorSpace.YUV420);
                this.transform = ColorUtil.getTransform8Bit(decoded.getColor(), ColorSpace.YUV420);
            }
            this.transform.transform(decoded, this.pic1);
            this.pic1.setCrop(new Rect(0, 0, this.track.thumbWidth, this.track.thumbHeight));
            for (var i = 0; i < this.encoder.length; i++) {
                try {
                    dst.clear();
                    var out = this.encoder[i].encodeFrame8Bit(this.pic1, dst);
                    break;
                }catch (ex) {
                    System.out.println("Abandon frame!!!");
                }
            }
            return dst;
        };
    }, {decoder: "VideoDecoder", encoder: "Array", pic0: "Picture8Bit", pic1: "Picture8Bit", transform: "Transform8Bit", track: "TranscodeTrack"}, {});
    prototype.close = function() {
        this.src.close();
    };
    prototype.getEdits = function() {
        return this.src.getEdits();
    };
    prototype.getPreferredTimescale = function() {
        return this.src.getPreferredTimescale();
    };
}, {src: "VirtualTrack", se: "CodecMeta", transcoders: {name: "ThreadLocal", arguments: ["TranscodeTrack.Transcoder"]}}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  @author in-somnia
 */
var FilterBank = function(smallFrames, channels) {
    if (smallFrames) {
        this.length = SyntaxConstants.WINDOW_SMALL_LEN_LONG;
        this.shortLen = SyntaxConstants.WINDOW_SMALL_LEN_SHORT;
        this.LONG_WINDOWS = [SineWindows.SINE_960, KBDWindows.KBD_960];
        this.SHORT_WINDOWS = [SineWindows.SINE_120, KBDWindows.KBD_120];
    } else {
        this.length = SyntaxConstants.WINDOW_LEN_LONG;
        this.shortLen = SyntaxConstants.WINDOW_LEN_SHORT;
        this.LONG_WINDOWS = [SineWindows.SINE_1024, KBDWindows.KBD_1024];
        this.SHORT_WINDOWS = [SineWindows.SINE_128, KBDWindows.KBD_128];
    }
    this.mid = stjs.trunc((this.length - this.shortLen) / 2);
    this.trans = stjs.trunc(this.shortLen / 2);
    this.mdctShort = new MDCT(this.shortLen * 2);
    this.mdctLong = new MDCT(this.length * 2);
    this.overlaps = Array.apply(null, Array(channels)).map(function() {
        return new Float32Array(this.length);
    });
    this.buf = new Float32Array(2 * this.length);
};
FilterBank = stjs.extend(FilterBank, null, [SyntaxConstants, SineWindows, KBDWindows], function(constructor, prototype) {
    prototype.LONG_WINDOWS = null;
    prototype.SHORT_WINDOWS = null;
    prototype.length = 0;
    prototype.shortLen = 0;
    prototype.mid = 0;
    prototype.trans = 0;
    prototype.mdctShort = null;
    prototype.mdctLong = null;
    prototype.buf = null;
    prototype.overlaps = null;
    prototype.process = function(windowSequence, windowShape, windowShapePrev, _in, out, channel) {
        var i;
        var overlap = this.overlaps[channel];
        switch (windowSequence) {
            case ICSInfo.WindowSequence.ONLY_LONG_SEQUENCE:
                this.mdctLong.process(_in, 0, this.buf, 0);
                for (i = 0; i < this.length; i++) {
                    out[i] = overlap[i] + (this.buf[i] * this.LONG_WINDOWS[windowShapePrev][i]);
                }
                for (i = 0; i < this.length; i++) {
                    overlap[i] = this.buf[this.length + i] * this.LONG_WINDOWS[windowShape][this.length - 1 - i];
                }
                break;
            case ICSInfo.WindowSequence.LONG_START_SEQUENCE:
                this.mdctLong.process(_in, 0, this.buf, 0);
                for (i = 0; i < this.length; i++) {
                    out[i] = overlap[i] + (this.buf[i] * this.LONG_WINDOWS[windowShapePrev][i]);
                }
                for (i = 0; i < this.mid; i++) {
                    overlap[i] = this.buf[this.length + i];
                }
                for (i = 0; i < this.shortLen; i++) {
                    overlap[this.mid + i] = this.buf[this.length + this.mid + i] * this.SHORT_WINDOWS[windowShape][this.shortLen - i - 1];
                }
                for (i = 0; i < this.mid; i++) {
                    overlap[this.mid + this.shortLen + i] = 0;
                }
                break;
            case ICSInfo.WindowSequence.EIGHT_SHORT_SEQUENCE:
                for (i = 0; i < 8; i++) {
                    this.mdctShort.process(_in, i * this.shortLen, this.buf, 2 * i * this.shortLen);
                }
                for (i = 0; i < this.mid; i++) {
                    out[i] = overlap[i];
                }
                for (i = 0; i < this.shortLen; i++) {
                    out[this.mid + i] = overlap[this.mid + i] + (this.buf[i] * this.SHORT_WINDOWS[windowShapePrev][i]);
                    out[this.mid + 1 * this.shortLen + i] = overlap[this.mid + this.shortLen * 1 + i] + (this.buf[this.shortLen * 1 + i] * this.SHORT_WINDOWS[windowShape][this.shortLen - 1 - i]) + (this.buf[this.shortLen * 2 + i] * this.SHORT_WINDOWS[windowShape][i]);
                    out[this.mid + 2 * this.shortLen + i] = overlap[this.mid + this.shortLen * 2 + i] + (this.buf[this.shortLen * 3 + i] * this.SHORT_WINDOWS[windowShape][this.shortLen - 1 - i]) + (this.buf[this.shortLen * 4 + i] * this.SHORT_WINDOWS[windowShape][i]);
                    out[this.mid + 3 * this.shortLen + i] = overlap[this.mid + this.shortLen * 3 + i] + (this.buf[this.shortLen * 5 + i] * this.SHORT_WINDOWS[windowShape][this.shortLen - 1 - i]) + (this.buf[this.shortLen * 6 + i] * this.SHORT_WINDOWS[windowShape][i]);
                    if (i < this.trans) 
                        out[this.mid + 4 * this.shortLen + i] = overlap[this.mid + this.shortLen * 4 + i] + (this.buf[this.shortLen * 7 + i] * this.SHORT_WINDOWS[windowShape][this.shortLen - 1 - i]) + (this.buf[this.shortLen * 8 + i] * this.SHORT_WINDOWS[windowShape][i]);
                }
                for (i = 0; i < this.shortLen; i++) {
                    if (i >= this.trans) 
                        overlap[this.mid + 4 * this.shortLen + i - this.length] = (this.buf[this.shortLen * 7 + i] * this.SHORT_WINDOWS[windowShape][this.shortLen - 1 - i]) + (this.buf[this.shortLen * 8 + i] * this.SHORT_WINDOWS[windowShape][i]);
                    overlap[this.mid + 5 * this.shortLen + i - this.length] = (this.buf[this.shortLen * 9 + i] * this.SHORT_WINDOWS[windowShape][this.shortLen - 1 - i]) + (this.buf[this.shortLen * 10 + i] * this.SHORT_WINDOWS[windowShape][i]);
                    overlap[this.mid + 6 * this.shortLen + i - this.length] = (this.buf[this.shortLen * 11 + i] * this.SHORT_WINDOWS[windowShape][this.shortLen - 1 - i]) + (this.buf[this.shortLen * 12 + i] * this.SHORT_WINDOWS[windowShape][i]);
                    overlap[this.mid + 7 * this.shortLen + i - this.length] = (this.buf[this.shortLen * 13 + i] * this.SHORT_WINDOWS[windowShape][this.shortLen - 1 - i]) + (this.buf[this.shortLen * 14 + i] * this.SHORT_WINDOWS[windowShape][i]);
                    overlap[this.mid + 8 * this.shortLen + i - this.length] = (this.buf[this.shortLen * 15 + i] * this.SHORT_WINDOWS[windowShape][this.shortLen - 1 - i]);
                }
                for (i = 0; i < this.mid; i++) {
                    overlap[this.mid + this.shortLen + i] = 0;
                }
                break;
            case ICSInfo.WindowSequence.LONG_STOP_SEQUENCE:
                this.mdctLong.process(_in, 0, this.buf, 0);
                for (i = 0; i < this.mid; i++) {
                    out[i] = overlap[i];
                }
                for (i = 0; i < this.shortLen; i++) {
                    out[this.mid + i] = overlap[this.mid + i] + (this.buf[this.mid + i] * this.SHORT_WINDOWS[windowShapePrev][i]);
                }
                for (i = 0; i < this.mid; i++) {
                    out[this.mid + this.shortLen + i] = overlap[this.mid + this.shortLen + i] + this.buf[this.mid + this.shortLen + i];
                }
                for (i = 0; i < this.length; i++) {
                    overlap[i] = this.buf[this.length + i] * this.LONG_WINDOWS[windowShape][this.length - 1 - i];
                }
                break;
        }
    };
    prototype.processLTP = function(windowSequence, windowShape, windowShapePrev, _in, out) {
        var i;
        switch (windowSequence) {
            case ICSInfo.WindowSequence.ONLY_LONG_SEQUENCE:
                for (i = this.length - 1; i >= 0; i--) {
                    this.buf[i] = _in[i] * this.LONG_WINDOWS[windowShapePrev][i];
                    this.buf[i + this.length] = _in[i + this.length] * this.LONG_WINDOWS[windowShape][this.length - 1 - i];
                }
                break;
            case ICSInfo.WindowSequence.LONG_START_SEQUENCE:
                for (i = 0; i < this.length; i++) {
                    this.buf[i] = _in[i] * this.LONG_WINDOWS[windowShapePrev][i];
                }
                for (i = 0; i < this.mid; i++) {
                    this.buf[i + this.length] = _in[i + this.length];
                }
                for (i = 0; i < this.shortLen; i++) {
                    this.buf[i + this.length + this.mid] = _in[i + this.length + this.mid] * this.SHORT_WINDOWS[windowShape][this.shortLen - 1 - i];
                }
                for (i = 0; i < this.mid; i++) {
                    this.buf[i + this.length + this.mid + this.shortLen] = 0;
                }
                break;
            case ICSInfo.WindowSequence.LONG_STOP_SEQUENCE:
                for (i = 0; i < this.mid; i++) {
                    this.buf[i] = 0;
                }
                for (i = 0; i < this.shortLen; i++) {
                    this.buf[i + this.mid] = _in[i + this.mid] * this.SHORT_WINDOWS[windowShapePrev][i];
                }
                for (i = 0; i < this.mid; i++) {
                    this.buf[i + this.mid + this.shortLen] = _in[i + this.mid + this.shortLen];
                }
                for (i = 0; i < this.length; i++) {
                    this.buf[i + this.length] = _in[i + this.length] * this.LONG_WINDOWS[windowShape][this.length - 1 - i];
                }
                break;
        }
        this.mdctLong.processForward(this.buf, out);
    };
    prototype.getOverlap = function(channel) {
        return this.overlaps[channel];
    };
}, {LONG_WINDOWS: "Array", SHORT_WINDOWS: "Array", mdctShort: "MDCT", mdctLong: "MDCT", buf: "Float32Array", overlaps: "Array", LOGGER: "Logger", SINE_1024: "Float32Array", SINE_128: "Float32Array", SINE_960: "Float32Array", SINE_120: "Float32Array", KBD_1024: "Float32Array", KBD_128: "Float32Array", KBD_960: "Float32Array", KBD_120: "Float32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Aspect ratio
 *  
 *  dynamic enum
 *  
 *  @author The JCodec project
 *  
 */
var AspectRatio = function(value) {
    this.value = value;
};
AspectRatio = stjs.extend(AspectRatio, null, [], function(constructor, prototype) {
    constructor.Extended_SAR = new AspectRatio(255);
    prototype.value = 0;
    constructor.values = [null, Rational.ONE, Rational.R(12, 11), Rational.R(10, 11), Rational.R(16, 11), Rational.R(40, 33), Rational.R(24, 11), Rational.R(20, 11), Rational.R(32, 11), Rational.R(80, 33), Rational.R(18, 11), Rational.R(15, 11), Rational.R(64, 33), Rational.R(160, 99), Rational.R(4, 3), Rational.R(3, 2), Rational.R(2, 1)];
    prototype.toRational = function() {
        if (AspectRatio.values.length > this.value) {
            return AspectRatio.values[this.value];
        }
        return null;
    };
    constructor.fromValue = function(value) {
        if (value == AspectRatio.Extended_SAR.value) {
            return AspectRatio.Extended_SAR;
        }
        return new AspectRatio(value);
    };
    prototype.getValue = function() {
        return this.value;
    };
}, {Extended_SAR: "AspectRatio", values: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var MP4Packet = function(data, pts, timescale, duration, frameNo, iframe, tapeTimecode, displayOrder, mediaPts, entryNo, fileOff, size, psync) {
    Packet.call(this, data, pts, timescale, duration, frameNo, iframe, tapeTimecode, displayOrder);
    this.mediaPts = mediaPts;
    this.entryNo = entryNo;
    this.fileOff = fileOff;
    this.size = size;
    this.psync = psync;
};
MP4Packet = stjs.extend(MP4Packet, Packet, [], function(constructor, prototype) {
    constructor.createMP4PacketWithTimecode = function(other, timecode) {
        return MP4Packet.createMP4Packet(other.data, other.pts, other.timescale, other.duration, other.frameNo, other.keyFrame, timecode, other.displayOrder, other.mediaPts, other.entryNo);
    };
    constructor.createMP4PacketWithData = function(other, frm) {
        return MP4Packet.createMP4Packet(frm, other.pts, other.timescale, other.duration, other.frameNo, other.keyFrame, other.tapeTimecode, other.displayOrder, other.mediaPts, other.entryNo);
    };
    constructor.createMP4Packet = function(data, pts, timescale, duration, frameNo, iframe, tapeTimecode, displayOrder, mediaPts, entryNo) {
        return new MP4Packet(data, pts, timescale, duration, frameNo, iframe, tapeTimecode, displayOrder, mediaPts, entryNo, 0, 0, false);
    };
    prototype.mediaPts = 0;
    prototype.entryNo = 0;
    prototype.fileOff = 0;
    prototype.size = 0;
    prototype.psync = false;
    /**
     *  Zero-offset sample entry index
     *  
     *  @return
     */
    prototype.getEntryNo = function() {
        return this.entryNo;
    };
    prototype.getMediaPts = function() {
        return this.mediaPts;
    };
    prototype.getFileOff = function() {
        return this.fileOff;
    };
    prototype.getSize = function() {
        return this.size;
    };
    prototype.isPsync = function() {
        return this.psync;
    };
}, {data: "ByteBuffer", tapeTimecode: "TapeTimecode", FRAME_ASC: {name: "Comparator", arguments: ["Packet"]}}, {});
var MPEGPacket = function(data, pts, timescale, duration, frameNo, keyFrame, tapeTimecode) {
    Packet.call(this, data, pts, timescale, duration, frameNo, keyFrame, tapeTimecode, 0);
};
MPEGPacket = stjs.extend(MPEGPacket, Packet, [], function(constructor, prototype) {
    prototype.offset = 0;
    prototype.seq = null;
    prototype.gop = 0;
    prototype.timecode = 0;
    prototype.getOffset = function() {
        return this.offset;
    };
    prototype.getSeq = function() {
        return this.seq;
    };
    prototype.getGOP = function() {
        return this.gop;
    };
    prototype.getTimecode = function() {
        return this.timecode;
    };
}, {seq: "ByteBuffer", data: "ByteBuffer", tapeTimecode: "TapeTimecode", FRAME_ASC: {name: "Comparator", arguments: ["Packet"]}}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 * 
 *  @author in-somnia
 */
var SBR = function(smallFrames, stereo, sample_rate, downSampledSBR) {
    this.amp_res = new Int8Array(2);
    this.N_L = new Int32Array(4);
    this.n = new Int32Array(2);
    this.f_master = new Int32Array(64);
    this.f_table_res = Array.apply(null, Array(2)).map(function() {
        return new Int32Array(64);
    });
    this.f_table_noise = new Int32Array(64);
    this.f_table_lim = Array.apply(null, Array(4)).map(function() {
        return new Int32Array(64);
    });
    this.table_map_k_to_g = new Int32Array(64);
    this.abs_bord_lead = new Int32Array(2);
    this.abs_bord_trail = new Int32Array(2);
    this.n_rel_lead = new Int32Array(2);
    this.n_rel_trail = new Int32Array(2);
    this.L_E = new Int32Array(2);
    this.L_E_prev = new Int32Array(2);
    this.L_Q = new Int32Array(2);
    this.t_E = Array.apply(null, Array(2)).map(function() {
        return new Int32Array(SBRConstants.MAX_L_E + 1);
    });
    this.t_Q = Array.apply(null, Array(2)).map(function() {
        return new Int32Array(3);
    });
    this.f = Array.apply(null, Array(2)).map(function() {
        return new Int32Array(SBRConstants.MAX_L_E + 1);
    });
    this.f_prev = new Int32Array(2);
    this.G_temp_prev = Array.apply(null, Array(2)).map(function() {
        return Array.apply(null, Array(5)).map(function() {
            return new Float32Array(64);
        });
    });
    this.Q_temp_prev = Array.apply(null, Array(2)).map(function() {
        return Array.apply(null, Array(5)).map(function() {
            return new Float32Array(64);
        });
    });
    this.GQ_ringbuf_index = new Int32Array(2);
    this.E = Array.apply(null, Array(2)).map(function() {
        return Array.apply(null, Array(64)).map(function() {
            return new Int32Array(SBRConstants.MAX_L_E);
        });
    });
    this.E_prev = Array.apply(null, Array(2)).map(function() {
        return new Int32Array(64);
    });
    this.E_orig = Array.apply(null, Array(2)).map(function() {
        return Array.apply(null, Array(64)).map(function() {
            return new Float32Array(SBRConstants.MAX_L_E);
        });
    });
    this.E_curr = Array.apply(null, Array(2)).map(function() {
        return Array.apply(null, Array(64)).map(function() {
            return new Float32Array(SBRConstants.MAX_L_E);
        });
    });
    this.Q = Array.apply(null, Array(2)).map(function() {
        return Array.apply(null, Array(64)).map(function() {
            return new Int32Array(2);
        });
    });
    this.Q_div = Array.apply(null, Array(2)).map(function() {
        return Array.apply(null, Array(64)).map(function() {
            return new Float32Array(2);
        });
    });
    this.Q_div2 = Array.apply(null, Array(2)).map(function() {
        return Array.apply(null, Array(64)).map(function() {
            return new Float32Array(2);
        });
    });
    this.Q_prev = Array.apply(null, Array(2)).map(function() {
        return new Int32Array(64);
    });
    this.l_A = new Int32Array(2);
    this.l_A_prev = new Int32Array(2);
    this.bs_invf_mode = Array.apply(null, Array(2)).map(function() {
        return new Int32Array(SBRConstants.MAX_L_E);
    });
    this.bs_invf_mode_prev = Array.apply(null, Array(2)).map(function() {
        return new Int32Array(SBRConstants.MAX_L_E);
    });
    this.bwArray = Array.apply(null, Array(2)).map(function() {
        return new Float32Array(64);
    });
    this.bwArray_prev = Array.apply(null, Array(2)).map(function() {
        return new Float32Array(64);
    });
    this.patchNoSubbands = new Int32Array(64);
    this.patchStartSubband = new Int32Array(64);
    this.bs_add_harmonic = Array.apply(null, Array(2)).map(function() {
        return new Int32Array(64);
    });
    this.bs_add_harmonic_prev = Array.apply(null, Array(2)).map(function() {
        return new Int32Array(64);
    });
    this.index_noise_prev = new Int32Array(2);
    this.psi_is_prev = new Int32Array(2);
    this.prevEnvIsShort = new Int32Array(2);
    this.qmfa = Array(2);
    this.qmfs = Array(2);
    this.Xsbr = Array.apply(null, Array(2)).map(function() {
        return Array.apply(null, Array(SBRConstants.MAX_NTSRHFG)).map(function() {
            return Array.apply(null, Array(64)).map(function() {
                return new Float32Array(2);
            });
        });
    });
    this.bs_add_harmonic_flag = new Int8Array(2);
    this.bs_add_harmonic_flag_prev = new Int8Array(2);
    this.bs_frame_class = new Int32Array(2);
    this.bs_rel_bord = Array.apply(null, Array(2)).map(function() {
        return new Int32Array(9);
    });
    this.bs_rel_bord_0 = Array.apply(null, Array(2)).map(function() {
        return new Int32Array(9);
    });
    this.bs_rel_bord_1 = Array.apply(null, Array(2)).map(function() {
        return new Int32Array(9);
    });
    this.bs_pointer = new Int32Array(2);
    this.bs_abs_bord_0 = new Int32Array(2);
    this.bs_abs_bord_1 = new Int32Array(2);
    this.bs_num_rel_0 = new Int32Array(2);
    this.bs_num_rel_1 = new Int32Array(2);
    this.bs_df_env = Array.apply(null, Array(2)).map(function() {
        return new Int32Array(9);
    });
    this.bs_df_noise = Array.apply(null, Array(2)).map(function() {
        return new Int32Array(3);
    });
    this.downSampledSBR = downSampledSBR;
    this.stereo = stereo;
    this.sample_rate = sample_rate;
    this.bs_freq_scale = 2;
    this.bs_alter_scale = true;
    this.bs_noise_bands = 2;
    this.bs_limiter_bands = 2;
    this.bs_limiter_gains = 2;
    this.bs_interpol_freq = true;
    this.bs_smoothing_mode = true;
    this.bs_start_freq = 5;
    this.bs_amp_res = true;
    this.bs_samplerate_mode = 1;
    this.prevEnvIsShort[0] = -1;
    this.prevEnvIsShort[1] = -1;
    this.header_count = 0;
    this.Reset = true;
    this.tHFGen = SBRConstants.T_HFGEN;
    this.tHFAdj = SBRConstants.T_HFADJ;
    this.bsco = 0;
    this.bsco_prev = 0;
    this.M_prev = 0;
    this.bs_start_freq_prev = -1;
    if (smallFrames) {
        this.numTimeSlotsRate = SBRConstants.RATE * SBRConstants.NO_TIME_SLOTS_960;
        this.numTimeSlots = SBRConstants.NO_TIME_SLOTS_960;
    } else {
        this.numTimeSlotsRate = SBRConstants.RATE * SBRConstants.NO_TIME_SLOTS;
        this.numTimeSlots = SBRConstants.NO_TIME_SLOTS;
    }
    this.GQ_ringbuf_index[0] = 0;
    this.GQ_ringbuf_index[1] = 0;
    if (stereo) {
        var j;
        this.qmfa[0] = new AnalysisFilterbank(32);
        this.qmfa[1] = new AnalysisFilterbank(32);
        this.qmfs[0] = new SynthesisFilterbank((downSampledSBR) ? 32 : 64);
        this.qmfs[1] = new SynthesisFilterbank((downSampledSBR) ? 32 : 64);
    } else {
        this.qmfa[0] = new AnalysisFilterbank(32);
        this.qmfs[0] = new SynthesisFilterbank((downSampledSBR) ? 32 : 64);
        this.qmfs[1] = null;
    }
};
SBR = stjs.extend(SBR, null, [SBRConstants, SyntaxConstants, HuffmanTables], function(constructor, prototype) {
    prototype.downSampledSBR = false;
    prototype.sample_rate = null;
    prototype.maxAACLine = 0;
    prototype.rate = 0;
    prototype.just_seeked = false;
    prototype.ret = 0;
    prototype.amp_res = null;
    prototype.k0 = 0;
    prototype.kx = 0;
    prototype.M = 0;
    prototype.N_master = 0;
    prototype.N_high = 0;
    prototype.N_low = 0;
    prototype.N_Q = 0;
    prototype.N_L = null;
    prototype.n = null;
    prototype.f_master = null;
    prototype.f_table_res = null;
    prototype.f_table_noise = null;
    prototype.f_table_lim = null;
    prototype.table_map_k_to_g = null;
    prototype.abs_bord_lead = null;
    prototype.abs_bord_trail = null;
    prototype.n_rel_lead = null;
    prototype.n_rel_trail = null;
    prototype.L_E = null;
    prototype.L_E_prev = null;
    prototype.L_Q = null;
    prototype.t_E = null;
    prototype.t_Q = null;
    prototype.f = null;
    prototype.f_prev = null;
    prototype.G_temp_prev = null;
    prototype.Q_temp_prev = null;
    prototype.GQ_ringbuf_index = null;
    prototype.E = null;
    prototype.E_prev = null;
    prototype.E_orig = null;
    prototype.E_curr = null;
    prototype.Q = null;
    prototype.Q_div = null;
    prototype.Q_div2 = null;
    prototype.Q_prev = null;
    prototype.l_A = null;
    prototype.l_A_prev = null;
    prototype.bs_invf_mode = null;
    prototype.bs_invf_mode_prev = null;
    prototype.bwArray = null;
    prototype.bwArray_prev = null;
    prototype.noPatches = 0;
    prototype.patchNoSubbands = null;
    prototype.patchStartSubband = null;
    prototype.bs_add_harmonic = null;
    prototype.bs_add_harmonic_prev = null;
    prototype.index_noise_prev = null;
    prototype.psi_is_prev = null;
    prototype.bs_start_freq_prev = 0;
    prototype.bs_stop_freq_prev = 0;
    prototype.bs_xover_band_prev = 0;
    prototype.bs_freq_scale_prev = 0;
    prototype.bs_alter_scale_prev = false;
    prototype.bs_noise_bands_prev = 0;
    prototype.prevEnvIsShort = null;
    prototype.kx_prev = 0;
    prototype.bsco = 0;
    prototype.bsco_prev = 0;
    prototype.M_prev = 0;
    prototype.Reset = false;
    prototype.frame = 0;
    prototype.header_count = 0;
    prototype.stereo = false;
    prototype.qmfa = null;
    prototype.qmfs = null;
    prototype.Xsbr = null;
    prototype.numTimeSlotsRate = 0;
    prototype.numTimeSlots = 0;
    prototype.tHFGen = 0;
    prototype.tHFAdj = 0;
    prototype.ps = null;
    prototype.ps_used = false;
    prototype.psResetFlag = false;
    prototype.bs_header_flag = false;
    prototype.bs_crc_flag = 0;
    prototype.bs_sbr_crc_bits = 0;
    prototype.bs_protocol_version = 0;
    prototype.bs_amp_res = false;
    prototype.bs_start_freq = 0;
    prototype.bs_stop_freq = 0;
    prototype.bs_xover_band = 0;
    prototype.bs_freq_scale = 0;
    prototype.bs_alter_scale = false;
    prototype.bs_noise_bands = 0;
    prototype.bs_limiter_bands = 0;
    prototype.bs_limiter_gains = 0;
    prototype.bs_interpol_freq = false;
    prototype.bs_smoothing_mode = false;
    prototype.bs_samplerate_mode = 0;
    prototype.bs_add_harmonic_flag = null;
    prototype.bs_add_harmonic_flag_prev = null;
    prototype.bs_extended_data = false;
    prototype.bs_extension_id = 0;
    prototype.bs_extension_data = 0;
    prototype.bs_coupling = false;
    prototype.bs_frame_class = null;
    prototype.bs_rel_bord = null;
    prototype.bs_rel_bord_0 = null;
    prototype.bs_rel_bord_1 = null;
    prototype.bs_pointer = null;
    prototype.bs_abs_bord_0 = null;
    prototype.bs_abs_bord_1 = null;
    prototype.bs_num_rel_0 = null;
    prototype.bs_num_rel_1 = null;
    prototype.bs_df_env = null;
    prototype.bs_df_noise = null;
    prototype.sbrReset = function() {
        var j;
        if (this.qmfa[0] != null) 
            this.qmfa[0].reset();
        if (this.qmfa[1] != null) 
            this.qmfa[1].reset();
        if (this.qmfs[0] != null) 
            this.qmfs[0].reset();
        if (this.qmfs[1] != null) 
            this.qmfs[1].reset();
        for (j = 0; j < 5; j++) {
            if (this.G_temp_prev[0][j] != null) 
                Arrays.fill(this.G_temp_prev[0][j], 0);
            if (this.G_temp_prev[1][j] != null) 
                Arrays.fill(this.G_temp_prev[1][j], 0);
            if (this.Q_temp_prev[0][j] != null) 
                Arrays.fill(this.Q_temp_prev[0][j], 0);
            if (this.Q_temp_prev[1][j] != null) 
                Arrays.fill(this.Q_temp_prev[1][j], 0);
        }
        for (var i = 0; i < 40; i++) {
            for (var k = 0; k < 64; k++) {
                this.Xsbr[0][i][j][0] = 0;
                this.Xsbr[0][i][j][1] = 0;
                this.Xsbr[1][i][j][0] = 0;
                this.Xsbr[1][i][j][1] = 0;
            }
        }
        this.GQ_ringbuf_index[0] = 0;
        this.GQ_ringbuf_index[1] = 0;
        this.header_count = 0;
        this.Reset = true;
        this.L_E_prev[0] = 0;
        this.L_E_prev[1] = 0;
        this.bs_freq_scale = 2;
        this.bs_alter_scale = true;
        this.bs_noise_bands = 2;
        this.bs_limiter_bands = 2;
        this.bs_limiter_gains = 2;
        this.bs_interpol_freq = true;
        this.bs_smoothing_mode = true;
        this.bs_start_freq = 5;
        this.bs_amp_res = true;
        this.bs_samplerate_mode = 1;
        this.prevEnvIsShort[0] = -1;
        this.prevEnvIsShort[1] = -1;
        this.bsco = 0;
        this.bsco_prev = 0;
        this.M_prev = 0;
        this.bs_start_freq_prev = -1;
        this.f_prev[0] = 0;
        this.f_prev[1] = 0;
        for (j = 0; j < SBRConstants.MAX_M; j++) {
            this.E_prev[0][j] = 0;
            this.Q_prev[0][j] = 0;
            this.E_prev[1][j] = 0;
            this.Q_prev[1][j] = 0;
            this.bs_add_harmonic_prev[0][j] = 0;
            this.bs_add_harmonic_prev[1][j] = 0;
        }
        this.bs_add_harmonic_flag_prev[0] = false;
        this.bs_add_harmonic_flag_prev[1] = false;
    };
    prototype.sbr_reset = function() {
        if ((this.bs_start_freq != this.bs_start_freq_prev) || (this.bs_stop_freq != this.bs_stop_freq_prev) || (this.bs_freq_scale != this.bs_freq_scale_prev) || (this.bs_alter_scale != this.bs_alter_scale_prev) || (this.bs_xover_band != this.bs_xover_band_prev) || (this.bs_noise_bands != this.bs_noise_bands_prev)) {
            this.Reset = true;
        } else {
            this.Reset = false;
        }
        this.bs_start_freq_prev = this.bs_start_freq;
        this.bs_stop_freq_prev = this.bs_stop_freq;
        this.bs_freq_scale_prev = this.bs_freq_scale;
        this.bs_alter_scale_prev = this.bs_alter_scale;
        this.bs_xover_band_prev = this.bs_xover_band;
        this.bs_noise_bands_prev = this.bs_noise_bands;
    };
    prototype.calc_sbr_tables = function(start_freq, stop_freq, samplerate_mode, freq_scale, alter_scale, xover_band) {
        var result = 0;
        var k2;
        this.k0 = FBT.qmf_start_channel(start_freq, samplerate_mode, this.sample_rate);
        k2 = FBT.qmf_stop_channel(stop_freq, this.sample_rate, this.k0);
        if (this.sample_rate.getFrequency() >= 48000) {
            if ((k2 - this.k0) > 32) 
                result += 1;
        } else if (this.sample_rate.getFrequency() <= 32000) {
            if ((k2 - this.k0) > 48) 
                result += 1;
        } else {
            if ((k2 - this.k0) > 45) 
                result += 1;
        }
        if (freq_scale == 0) {
            result += FBT.master_frequency_table_fs0(this, this.k0, k2, alter_scale);
        } else {
            result += FBT.master_frequency_table(this, this.k0, k2, freq_scale, alter_scale);
        }
        result += FBT.derived_frequency_table(this, xover_band, k2);
        result = (result > 0) ? 1 : 0;
        return result;
    };
    prototype.decode = function(ld, cnt) {
        var result = 0;
        var num_align_bits = 0;
        var num_sbr_bits1 = ld.getPosition();
        var num_sbr_bits2;
        var saved_start_freq, saved_samplerate_mode;
        var saved_stop_freq, saved_freq_scale;
        var saved_xover_band;
        var saved_alter_scale;
        var bs_extension_type = ld.readBits(4);
        if (bs_extension_type == SBRConstants.EXT_SBR_DATA_CRC) {
            this.bs_sbr_crc_bits = ld.readBits(10);
        }
        saved_start_freq = this.bs_start_freq;
        saved_samplerate_mode = this.bs_samplerate_mode;
        saved_stop_freq = this.bs_stop_freq;
        saved_freq_scale = this.bs_freq_scale;
        saved_alter_scale = this.bs_alter_scale;
        saved_xover_band = this.bs_xover_band;
        this.bs_header_flag = ld.readBool();
        if (this.bs_header_flag) 
            this.sbr_header(ld);
        this.sbr_reset();
        if (this.header_count != 0) {
            if (this.Reset || (this.bs_header_flag && this.just_seeked)) {
                var rt = this.calc_sbr_tables(this.bs_start_freq, this.bs_stop_freq, this.bs_samplerate_mode, this.bs_freq_scale, this.bs_alter_scale, this.bs_xover_band);
                if (rt > 0) {
                    this.calc_sbr_tables(saved_start_freq, saved_stop_freq, saved_samplerate_mode, saved_freq_scale, saved_alter_scale, saved_xover_band);
                }
            }
            if (result == 0) {
                result = this.sbr_data(ld);
                if ((result > 0) && (this.Reset || (this.bs_header_flag && this.just_seeked))) {
                    this.calc_sbr_tables(saved_start_freq, saved_stop_freq, saved_samplerate_mode, saved_freq_scale, saved_alter_scale, saved_xover_band);
                }
            }
        } else {
            result = 1;
        }
        num_sbr_bits2 = (((ld.getPosition() - num_sbr_bits1)) | 0);
        if (8 * cnt < num_sbr_bits2) {
             throw new AACException("frame overread");
        }
        {
            num_align_bits = 8 * cnt - num_sbr_bits2;
             while (num_align_bits > 7){
                ld.readBits(8);
                num_align_bits -= 8;
            }
            ld.readBits(num_align_bits);
        }return result;
    };
    prototype.sbr_header = function(ld) {
        var bs_header_extra_1, bs_header_extra_2;
        this.header_count++;
        this.bs_amp_res = ld.readBool();
        this.bs_start_freq = ld.readBits(4);
        this.bs_stop_freq = ld.readBits(4);
        this.bs_xover_band = ld.readBits(3);
        ld.readBits(2);
        bs_header_extra_1 = ld.readBool();
        bs_header_extra_2 = ld.readBool();
        if (bs_header_extra_1) {
            this.bs_freq_scale = ld.readBits(2);
            this.bs_alter_scale = ld.readBool();
            this.bs_noise_bands = ld.readBits(2);
        } else {
            this.bs_freq_scale = 2;
            this.bs_alter_scale = true;
            this.bs_noise_bands = 2;
        }
        if (bs_header_extra_2) {
            this.bs_limiter_bands = ld.readBits(2);
            this.bs_limiter_gains = ld.readBits(2);
            this.bs_interpol_freq = ld.readBool();
            this.bs_smoothing_mode = ld.readBool();
        } else {
            this.bs_limiter_bands = 2;
            this.bs_limiter_gains = 2;
            this.bs_interpol_freq = true;
            this.bs_smoothing_mode = true;
        }
    };
    prototype.sbr_data = function(ld) {
        var result;
        this.rate = (this.bs_samplerate_mode != 0) ? 2 : 1;
        if (this.stereo) {
            if ((result = this.sbr_channel_pair_element(ld)) > 0) 
                return result;
        } else {
            if ((result = this.sbr_single_channel_element(ld)) > 0) 
                return result;
        }
        return 0;
    };
    prototype.sbr_single_channel_element = function(ld) {
        var result;
        if (ld.readBool()) {
            ld.readBits(4);
        }
        if ((result = this.sbr_grid(ld, 0)) > 0) 
            return result;
        this.sbr_dtdf(ld, 0);
        this.invf_mode(ld, 0);
        this.sbr_envelope(ld, 0);
        this.sbr_noise(ld, 0);
        NoiseEnvelope.dequantChannel(this, 0);
        Arrays.fill(this.bs_add_harmonic[0], 0, 64, 0);
        Arrays.fill(this.bs_add_harmonic[1], 0, 64, 0);
        this.bs_add_harmonic_flag[0] = ld.readBool();
        if (this.bs_add_harmonic_flag[0]) 
            this.sinusoidal_coding(ld, 0);
        this.bs_extended_data = ld.readBool();
        if (this.bs_extended_data) {
            var nr_bits_left;
            var ps_ext_read = 0;
            var cnt = ld.readBits(4);
            if (cnt == 15) {
                cnt += ld.readBits(8);
            }
            nr_bits_left = 8 * cnt;
             while (nr_bits_left > 7){
                var tmp_nr_bits = 0;
                this.bs_extension_id = ld.readBits(2);
                tmp_nr_bits += 2;
                if (this.bs_extension_id == SBRConstants.EXTENSION_ID_PS) {
                    if (ps_ext_read == 0) {
                        ps_ext_read = 1;
                    } else {
                        this.bs_extension_id = 3;
                    }
                }
                tmp_nr_bits += this.sbr_extension(ld, this.bs_extension_id, nr_bits_left);
                if (tmp_nr_bits > nr_bits_left) 
                    return 1;
                nr_bits_left -= tmp_nr_bits;
            }
            if (nr_bits_left > 0) {
                ld.readBits(nr_bits_left);
            }
        }
        return 0;
    };
    prototype.sbr_channel_pair_element = function(ld) {
        var n, result;
        if (ld.readBool()) {
            ld.readBits(4);
            ld.readBits(4);
        }
        this.bs_coupling = ld.readBool();
        if (this.bs_coupling) {
            if ((result = this.sbr_grid(ld, 0)) > 0) 
                return result;
            this.bs_frame_class[1] = this.bs_frame_class[0];
            this.L_E[1] = this.L_E[0];
            this.L_Q[1] = this.L_Q[0];
            this.bs_pointer[1] = this.bs_pointer[0];
            for (n = 0; n <= this.L_E[0]; n++) {
                this.t_E[1][n] = this.t_E[0][n];
                this.f[1][n] = this.f[0][n];
            }
            for (n = 0; n <= this.L_Q[0]; n++) {
                this.t_Q[1][n] = this.t_Q[0][n];
            }
            this.sbr_dtdf(ld, 0);
            this.sbr_dtdf(ld, 1);
            this.invf_mode(ld, 0);
            for (n = 0; n < this.N_Q; n++) {
                this.bs_invf_mode[1][n] = this.bs_invf_mode[0][n];
            }
            this.sbr_envelope(ld, 0);
            this.sbr_noise(ld, 0);
            this.sbr_envelope(ld, 1);
            this.sbr_noise(ld, 1);
            Arrays.fill(this.bs_add_harmonic[0], 0, 64, 0);
            Arrays.fill(this.bs_add_harmonic[1], 0, 64, 0);
            this.bs_add_harmonic_flag[0] = ld.readBool();
            if (this.bs_add_harmonic_flag[0]) 
                this.sinusoidal_coding(ld, 0);
            this.bs_add_harmonic_flag[1] = ld.readBool();
            if (this.bs_add_harmonic_flag[1]) 
                this.sinusoidal_coding(ld, 1);
        } else {
            var saved_t_E = new Int32Array(6), saved_t_Q = new Int32Array(3);
            var saved_L_E = this.L_E[0];
            var saved_L_Q = this.L_Q[0];
            var saved_frame_class = this.bs_frame_class[0];
            for (n = 0; n < saved_L_E; n++) {
                saved_t_E[n] = this.t_E[0][n];
            }
            for (n = 0; n < saved_L_Q; n++) {
                saved_t_Q[n] = this.t_Q[0][n];
            }
            if ((result = this.sbr_grid(ld, 0)) > 0) 
                return result;
            if ((result = this.sbr_grid(ld, 1)) > 0) {
                this.bs_frame_class[0] = saved_frame_class;
                this.L_E[0] = saved_L_E;
                this.L_Q[0] = saved_L_Q;
                for (n = 0; n < 6; n++) {
                    this.t_E[0][n] = saved_t_E[n];
                }
                for (n = 0; n < 3; n++) {
                    this.t_Q[0][n] = saved_t_Q[n];
                }
                return result;
            }
            this.sbr_dtdf(ld, 0);
            this.sbr_dtdf(ld, 1);
            this.invf_mode(ld, 0);
            this.invf_mode(ld, 1);
            this.sbr_envelope(ld, 0);
            this.sbr_envelope(ld, 1);
            this.sbr_noise(ld, 0);
            this.sbr_noise(ld, 1);
            Arrays.fill(this.bs_add_harmonic[0], 0, 64, 0);
            Arrays.fill(this.bs_add_harmonic[1], 0, 64, 0);
            this.bs_add_harmonic_flag[0] = ld.readBool();
            if (this.bs_add_harmonic_flag[0]) 
                this.sinusoidal_coding(ld, 0);
            this.bs_add_harmonic_flag[1] = ld.readBool();
            if (this.bs_add_harmonic_flag[1]) 
                this.sinusoidal_coding(ld, 1);
        }
        NoiseEnvelope.dequantChannel(this, 0);
        NoiseEnvelope.dequantChannel(this, 1);
        if (this.bs_coupling) 
            NoiseEnvelope.unmap(this);
        this.bs_extended_data = ld.readBool();
        if (this.bs_extended_data) {
            var nr_bits_left;
            var cnt = ld.readBits(4);
            if (cnt == 15) {
                cnt += ld.readBits(8);
            }
            nr_bits_left = 8 * cnt;
             while (nr_bits_left > 7){
                var tmp_nr_bits = 0;
                this.bs_extension_id = ld.readBits(2);
                tmp_nr_bits += 2;
                tmp_nr_bits += this.sbr_extension(ld, this.bs_extension_id, nr_bits_left);
                if (tmp_nr_bits > nr_bits_left) 
                    return 1;
                nr_bits_left -= tmp_nr_bits;
            }
            if (nr_bits_left > 0) {
                ld.readBits(nr_bits_left);
            }
        }
        return 0;
    };
    prototype.sbr_log2 = function(val) {
        var log2tab = new Int32Array([0, 0, 1, 2, 2, 3, 3, 3, 3, 4]);
        if (val < 10 && val >= 0) 
            return log2tab[val];
         else 
            return 0;
    };
    prototype.sbr_grid = function(ld, ch) {
        var i, env, rel, result;
        var bs_abs_bord, bs_abs_bord_1;
        var bs_num_env = 0;
        var saved_L_E = this.L_E[ch];
        var saved_L_Q = this.L_Q[ch];
        var saved_frame_class = this.bs_frame_class[ch];
        this.bs_frame_class[ch] = ld.readBits(2);
        switch (this.bs_frame_class[ch]) {
            case SBRConstants.FIXFIX:
                i = ld.readBits(2);
                bs_num_env = Math.min(1 << i, 5);
                i = ld.readBit();
                for (env = 0; env < bs_num_env; env++) {
                    this.f[ch][env] = i;
                }
                this.abs_bord_lead[ch] = 0;
                this.abs_bord_trail[ch] = this.numTimeSlots;
                this.n_rel_lead[ch] = bs_num_env - 1;
                this.n_rel_trail[ch] = 0;
                break;
            case SBRConstants.FIXVAR:
                bs_abs_bord = ld.readBits(2) + this.numTimeSlots;
                bs_num_env = ld.readBits(2) + 1;
                for (rel = 0; rel < bs_num_env - 1; rel++) {
                    this.bs_rel_bord[ch][rel] = 2 * ld.readBits(2) + 2;
                }
                i = this.sbr_log2(bs_num_env + 1);
                this.bs_pointer[ch] = ld.readBits(i);
                for (env = 0; env < bs_num_env; env++) {
                    this.f[ch][bs_num_env - env - 1] = ld.readBit();
                }
                this.abs_bord_lead[ch] = 0;
                this.abs_bord_trail[ch] = bs_abs_bord;
                this.n_rel_lead[ch] = 0;
                this.n_rel_trail[ch] = bs_num_env - 1;
                break;
            case SBRConstants.VARFIX:
                bs_abs_bord = ld.readBits(2);
                bs_num_env = ld.readBits(2) + 1;
                for (rel = 0; rel < bs_num_env - 1; rel++) {
                    this.bs_rel_bord[ch][rel] = 2 * ld.readBits(2) + 2;
                }
                i = this.sbr_log2(bs_num_env + 1);
                this.bs_pointer[ch] = ld.readBits(i);
                for (env = 0; env < bs_num_env; env++) {
                    this.f[ch][env] = ld.readBit();
                }
                this.abs_bord_lead[ch] = bs_abs_bord;
                this.abs_bord_trail[ch] = this.numTimeSlots;
                this.n_rel_lead[ch] = bs_num_env - 1;
                this.n_rel_trail[ch] = 0;
                break;
            case SBRConstants.VARVAR:
                bs_abs_bord = ld.readBits(2);
                bs_abs_bord_1 = ld.readBits(2) + this.numTimeSlots;
                this.bs_num_rel_0[ch] = ld.readBits(2);
                this.bs_num_rel_1[ch] = ld.readBits(2);
                bs_num_env = Math.min(5, this.bs_num_rel_0[ch] + this.bs_num_rel_1[ch] + 1);
                for (rel = 0; rel < this.bs_num_rel_0[ch]; rel++) {
                    this.bs_rel_bord_0[ch][rel] = 2 * ld.readBits(2) + 2;
                }
                for (rel = 0; rel < this.bs_num_rel_1[ch]; rel++) {
                    this.bs_rel_bord_1[ch][rel] = 2 * ld.readBits(2) + 2;
                }
                i = this.sbr_log2(this.bs_num_rel_0[ch] + this.bs_num_rel_1[ch] + 2);
                this.bs_pointer[ch] = ld.readBits(i);
                for (env = 0; env < bs_num_env; env++) {
                    this.f[ch][env] = ld.readBit();
                }
                this.abs_bord_lead[ch] = bs_abs_bord;
                this.abs_bord_trail[ch] = bs_abs_bord_1;
                this.n_rel_lead[ch] = this.bs_num_rel_0[ch];
                this.n_rel_trail[ch] = this.bs_num_rel_1[ch];
                break;
        }
        if (this.bs_frame_class[ch] == SBRConstants.VARVAR) 
            this.L_E[ch] = Math.min(bs_num_env, 5);
         else 
            this.L_E[ch] = Math.min(bs_num_env, 4);
        if (this.L_E[ch] <= 0) 
            return 1;
        if (this.L_E[ch] > 1) 
            this.L_Q[ch] = 2;
         else 
            this.L_Q[ch] = 1;
        if ((result = TFGrid.envelope_time_border_vector(this, ch)) > 0) {
            this.bs_frame_class[ch] = saved_frame_class;
            this.L_E[ch] = saved_L_E;
            this.L_Q[ch] = saved_L_Q;
            return result;
        }
        TFGrid.noise_floor_time_border_vector(this, ch);
        return 0;
    };
    prototype.sbr_dtdf = function(ld, ch) {
        var i;
        for (i = 0; i < this.L_E[ch]; i++) {
            this.bs_df_env[ch][i] = ld.readBit();
        }
        for (i = 0; i < this.L_Q[ch]; i++) {
            this.bs_df_noise[ch][i] = ld.readBit();
        }
    };
    prototype.invf_mode = function(ld, ch) {
        var n;
        for (n = 0; n < this.N_Q; n++) {
            this.bs_invf_mode[ch][n] = ld.readBits(2);
        }
    };
    prototype.sbr_extension = function(ld, bs_extension_id, num_bits_left) {
        var ret;
        switch (bs_extension_id) {
            case SBRConstants.EXTENSION_ID_PS:
                if (this.ps == null) {
                    this.ps = new PS(this.sample_rate, this.numTimeSlotsRate);
                }
                if (this.psResetFlag) {
                    this.ps.header_read = false;
                }
                ret = this.ps.decode(ld);
                if (!this.ps_used && this.ps.header_read) {
                    this.ps_used = true;
                }
                if (this.ps.header_read) {
                    this.psResetFlag = false;
                }
                return ret;
            default:
                this.bs_extension_data = ld.readBits(6);
                return 6;
        }
    };
    prototype.sinusoidal_coding = function(ld, ch) {
        var n;
        for (n = 0; n < this.N_high; n++) {
            this.bs_add_harmonic[ch][n] = ld.readBit();
        }
    };
    prototype.sbr_envelope = function(ld, ch) {
        var env, band;
        var delta = 0;
        var t_huff, f_huff;
        if ((this.L_E[ch] == 1) && (this.bs_frame_class[ch] == SBRConstants.FIXFIX)) 
            this.amp_res[ch] = false;
         else 
            this.amp_res[ch] = this.bs_amp_res;
        if ((this.bs_coupling) && (ch == 1)) {
            delta = 1;
            if (this.amp_res[ch]) {
                t_huff = HuffmanTables.T_HUFFMAN_ENV_BAL_3_0DB;
                f_huff = HuffmanTables.F_HUFFMAN_ENV_BAL_3_0DB;
            } else {
                t_huff = HuffmanTables.T_HUFFMAN_ENV_BAL_1_5DB;
                f_huff = HuffmanTables.F_HUFFMAN_ENV_BAL_1_5DB;
            }
        } else {
            delta = 0;
            if (this.amp_res[ch]) {
                t_huff = HuffmanTables.T_HUFFMAN_ENV_3_0DB;
                f_huff = HuffmanTables.F_HUFFMAN_ENV_3_0DB;
            } else {
                t_huff = HuffmanTables.T_HUFFMAN_ENV_1_5DB;
                f_huff = HuffmanTables.F_HUFFMAN_ENV_1_5DB;
            }
        }
        for (env = 0; env < this.L_E[ch]; env++) {
            if (this.bs_df_env[ch][env] == 0) {
                if (this.bs_coupling && (ch == 1)) {
                    if (this.amp_res[ch]) {
                        this.E[ch][0][env] = ld.readBits(5) << delta;
                    } else {
                        this.E[ch][0][env] = ld.readBits(6) << delta;
                    }
                } else {
                    if (this.amp_res[ch]) {
                        this.E[ch][0][env] = ld.readBits(6) << delta;
                    } else {
                        this.E[ch][0][env] = ld.readBits(7) << delta;
                    }
                }
                for (band = 1; band < this.n[this.f[ch][env]]; band++) {
                    this.E[ch][band][env] = (this.decodeHuffman(ld, f_huff) << delta);
                }
            } else {
                for (band = 0; band < this.n[this.f[ch][env]]; band++) {
                    this.E[ch][band][env] = (this.decodeHuffman(ld, t_huff) << delta);
                }
            }
        }
        NoiseEnvelope.extract_envelope_data(this, ch);
    };
    prototype.sbr_noise = function(ld, ch) {
        var noise, band;
        var delta = 0;
        var t_huff, f_huff;
        if (this.bs_coupling && (ch == 1)) {
            delta = 1;
            t_huff = HuffmanTables.T_HUFFMAN_NOISE_BAL_3_0DB;
            f_huff = HuffmanTables.F_HUFFMAN_ENV_BAL_3_0DB;
        } else {
            delta = 0;
            t_huff = HuffmanTables.T_HUFFMAN_NOISE_3_0DB;
            f_huff = HuffmanTables.F_HUFFMAN_ENV_3_0DB;
        }
        for (noise = 0; noise < this.L_Q[ch]; noise++) {
            if (this.bs_df_noise[ch][noise] == 0) {
                if (this.bs_coupling && (ch == 1)) {
                    this.Q[ch][0][noise] = ld.readBits(5) << delta;
                } else {
                    this.Q[ch][0][noise] = ld.readBits(5) << delta;
                }
                for (band = 1; band < this.N_Q; band++) {
                    this.Q[ch][band][noise] = (this.decodeHuffman(ld, f_huff) << delta);
                }
            } else {
                for (band = 0; band < this.N_Q; band++) {
                    this.Q[ch][band][noise] = (this.decodeHuffman(ld, t_huff) << delta);
                }
            }
        }
        NoiseEnvelope.extract_noise_floor_data(this, ch);
    };
    prototype.decodeHuffman = function(ld, t_huff) {
        var bit;
        var index = 0;
         while (index >= 0){
            bit = ld.readBit();
            index = t_huff[index][bit];
        }
        return index + 64;
    };
    prototype.sbr_save_prev_data = function(ch) {
        var i;
        this.kx_prev = this.kx;
        this.M_prev = this.M;
        this.bsco_prev = this.bsco;
        this.L_E_prev[ch] = this.L_E[ch];
        if (this.L_E[ch] <= 0) 
            return 19;
        this.f_prev[ch] = this.f[ch][this.L_E[ch] - 1];
        for (i = 0; i < SBRConstants.MAX_M; i++) {
            this.E_prev[ch][i] = this.E[ch][i][this.L_E[ch] - 1];
            this.Q_prev[ch][i] = this.Q[ch][i][this.L_Q[ch] - 1];
        }
        for (i = 0; i < SBRConstants.MAX_M; i++) {
            this.bs_add_harmonic_prev[ch][i] = this.bs_add_harmonic[ch][i];
        }
        this.bs_add_harmonic_flag_prev[ch] = this.bs_add_harmonic_flag[ch];
        if (this.l_A[ch] == this.L_E[ch]) 
            this.prevEnvIsShort[ch] = 0;
         else 
            this.prevEnvIsShort[ch] = -1;
        return 0;
    };
    prototype.sbr_save_matrix = function(ch) {
        var i;
        for (i = 0; i < this.tHFGen; i++) {
            for (var j = 0; j < 64; j++) {
                this.Xsbr[ch][i][j][0] = this.Xsbr[ch][i + this.numTimeSlotsRate][j][0];
                this.Xsbr[ch][i][j][1] = this.Xsbr[ch][i + this.numTimeSlotsRate][j][1];
            }
        }
        for (i = this.tHFGen; i < SBRConstants.MAX_NTSRHFG; i++) {
            for (var j = 0; j < 64; j++) {
                this.Xsbr[ch][i][j][0] = 0;
                this.Xsbr[ch][i][j][1] = 0;
            }
        }
    };
    prototype.sbr_process_channel = function(channel_buf, X, ch, dont_process) {
        var k, l;
        var ret = 0;
        this.bsco = 0;
        if (dont_process) 
            this.qmfa[ch].sbr_qmf_analysis_32(this, channel_buf, this.Xsbr[ch], this.tHFGen, 32);
         else 
            this.qmfa[ch].sbr_qmf_analysis_32(this, channel_buf, this.Xsbr[ch], this.tHFGen, this.kx);
        if (!dont_process) {
            HFGeneration.hf_generation(this, this.Xsbr[ch], this.Xsbr[ch], ch);
            ret = HFAdjustment.hf_adjustment(this, this.Xsbr[ch], ch);
            if (ret > 0) {
                dont_process = true;
            }
        }
        if (this.just_seeked || dont_process) {
            for (l = 0; l < this.numTimeSlotsRate; l++) {
                for (k = 0; k < 32; k++) {
                    X[l][k][0] = this.Xsbr[ch][l + this.tHFAdj][k][0];
                    X[l][k][1] = this.Xsbr[ch][l + this.tHFAdj][k][1];
                }
                for (k = 32; k < 64; k++) {
                    X[l][k][0] = 0;
                    X[l][k][1] = 0;
                }
            }
        } else {
            for (l = 0; l < this.numTimeSlotsRate; l++) {
                var kx_band, M_band, bsco_band;
                if (l < this.t_E[ch][0]) {
                    kx_band = this.kx_prev;
                    M_band = this.M_prev;
                    bsco_band = this.bsco_prev;
                } else {
                    kx_band = this.kx;
                    M_band = this.M;
                    bsco_band = this.bsco;
                }
                for (k = 0; k < kx_band + bsco_band; k++) {
                    X[l][k][0] = this.Xsbr[ch][l + this.tHFAdj][k][0];
                    X[l][k][1] = this.Xsbr[ch][l + this.tHFAdj][k][1];
                }
                for (k = kx_band + bsco_band; k < kx_band + M_band; k++) {
                    X[l][k][0] = this.Xsbr[ch][l + this.tHFAdj][k][0];
                    X[l][k][1] = this.Xsbr[ch][l + this.tHFAdj][k][1];
                }
                for (k = Math.max(kx_band + bsco_band, kx_band + M_band); k < 64; k++) {
                    X[l][k][0] = 0;
                    X[l][k][1] = 0;
                }
            }
        }
        return ret;
    };
    prototype._process = function(left_chan, right_chan, just_seeked) {
        var dont_process = false;
        var ret = 0;
        var X = Array.apply(null, Array(SBRConstants.MAX_NTSR)).map(function() {
            return Array.apply(null, Array(64)).map(function() {
                return new Float32Array(2);
            });
        });
        if (!this.stereo) 
            return 21;
        if (this.ret != 0 || (this.header_count == 0)) {
            dont_process = true;
            if (this.ret != 0 && this.Reset) 
                this.bs_start_freq_prev = -1;
        }
        if (just_seeked) {
            this.just_seeked = true;
        } else {
            this.just_seeked = false;
        }
        this.ret += this.sbr_process_channel(left_chan, X, 0, dont_process);
        if (this.downSampledSBR) {
            this.qmfs[0].sbr_qmf_synthesis_32(this, X, left_chan);
        } else {
            this.qmfs[0].sbr_qmf_synthesis_64(this, X, left_chan);
        }
        this.ret += this.sbr_process_channel(right_chan, X, 1, dont_process);
        if (this.downSampledSBR) {
            this.qmfs[1].sbr_qmf_synthesis_32(this, X, right_chan);
        } else {
            this.qmfs[1].sbr_qmf_synthesis_64(this, X, right_chan);
        }
        if (this.bs_header_flag) 
            this.just_seeked = false;
        if (this.header_count != 0 && this.ret == 0) {
            ret = this.sbr_save_prev_data(0);
            if (ret != 0) 
                return ret;
            ret = this.sbr_save_prev_data(1);
            if (ret != 0) 
                return ret;
        }
        this.sbr_save_matrix(0);
        this.sbr_save_matrix(1);
        this.frame++;
        return 0;
    };
    prototype.process = function(channel, just_seeked) {
        var dont_process = false;
        var ret = 0;
        var X = Array.apply(null, Array(SBRConstants.MAX_NTSR)).map(function() {
            return Array.apply(null, Array(64)).map(function() {
                return new Float32Array(2);
            });
        });
        if (this.stereo) 
            return 21;
        if (this.ret != 0 || (this.header_count == 0)) {
            dont_process = true;
            if (this.ret != 0 && this.Reset) 
                this.bs_start_freq_prev = -1;
        }
        if (just_seeked) {
            this.just_seeked = true;
        } else {
            this.just_seeked = false;
        }
        this.ret += this.sbr_process_channel(channel, X, 0, dont_process);
        if (this.downSampledSBR) {
            this.qmfs[0].sbr_qmf_synthesis_32(this, X, channel);
        } else {
            this.qmfs[0].sbr_qmf_synthesis_64(this, X, channel);
        }
        if (this.bs_header_flag) 
            this.just_seeked = false;
        if (this.header_count != 0 && this.ret == 0) {
            ret = this.sbr_save_prev_data(0);
            if (ret != 0) 
                return ret;
        }
        this.sbr_save_matrix(0);
        this.frame++;
        return 0;
    };
    prototype.processPS = function(left_channel, right_channel, just_seeked) {
        var l, k;
        var dont_process = false;
        var ret = 0;
        var X_left = Array.apply(null, Array(38)).map(function() {
            return Array.apply(null, Array(64)).map(function() {
                return new Float32Array(2);
            });
        });
        var X_right = Array.apply(null, Array(38)).map(function() {
            return Array.apply(null, Array(64)).map(function() {
                return new Float32Array(2);
            });
        });
        if (this.stereo) 
            return 21;
        if (this.ret != 0 || (this.header_count == 0)) {
            dont_process = true;
            if (this.ret != 0 && this.Reset) 
                this.bs_start_freq_prev = -1;
        }
        if (just_seeked) {
            this.just_seeked = true;
        } else {
            this.just_seeked = false;
        }
        if (this.qmfs[1] == null) {
            this.qmfs[1] = new SynthesisFilterbank((this.downSampledSBR) ? 32 : 64);
        }
        this.ret += this.sbr_process_channel(left_channel, X_left, 0, dont_process);
        for (l = this.numTimeSlotsRate; l < this.numTimeSlotsRate + 6; l++) {
            for (k = 0; k < 5; k++) {
                X_left[l][k][0] = this.Xsbr[0][this.tHFAdj + l][k][0];
                X_left[l][k][1] = this.Xsbr[0][this.tHFAdj + l][k][1];
            }
        }
        this.ps.process(X_left, X_right);
        if (this.downSampledSBR) {
            this.qmfs[0].sbr_qmf_synthesis_32(this, X_left, left_channel);
            this.qmfs[1].sbr_qmf_synthesis_32(this, X_right, right_channel);
        } else {
            this.qmfs[0].sbr_qmf_synthesis_64(this, X_left, left_channel);
            this.qmfs[1].sbr_qmf_synthesis_64(this, X_right, right_channel);
        }
        if (this.bs_header_flag) 
            this.just_seeked = false;
        if (this.header_count != 0 && this.ret == 0) {
            ret = this.sbr_save_prev_data(0);
            if (ret != 0) 
                return ret;
        }
        this.sbr_save_matrix(0);
        this.frame++;
        return 0;
    };
    prototype.isPSUsed = function() {
        return this.ps_used;
    };
}, {sample_rate: "SampleFrequency", amp_res: "Int8Array", N_L: "Int32Array", n: "Int32Array", f_master: "Int32Array", f_table_res: "Array", f_table_noise: "Int32Array", f_table_lim: "Array", table_map_k_to_g: "Int32Array", abs_bord_lead: "Int32Array", abs_bord_trail: "Int32Array", n_rel_lead: "Int32Array", n_rel_trail: "Int32Array", L_E: "Int32Array", L_E_prev: "Int32Array", L_Q: "Int32Array", t_E: "Array", t_Q: "Array", f: "Array", f_prev: "Int32Array", G_temp_prev: "Array", Q_temp_prev: "Array", GQ_ringbuf_index: "Int32Array", E: "Array", E_prev: "Array", E_orig: "Array", E_curr: "Array", Q: "Array", Q_div: "Array", Q_div2: "Array", Q_prev: "Array", l_A: "Int32Array", l_A_prev: "Int32Array", bs_invf_mode: "Array", bs_invf_mode_prev: "Array", bwArray: "Array", bwArray_prev: "Array", patchNoSubbands: "Int32Array", patchStartSubband: "Int32Array", bs_add_harmonic: "Array", bs_add_harmonic_prev: "Array", index_noise_prev: "Int32Array", psi_is_prev: "Int32Array", prevEnvIsShort: "Int32Array", qmfa: "Array", qmfs: "Array", Xsbr: "Array", ps: "PS", bs_add_harmonic_flag: "Int8Array", bs_add_harmonic_flag_prev: "Int8Array", bs_frame_class: "Int32Array", bs_rel_bord: "Array", bs_rel_bord_0: "Array", bs_rel_bord_1: "Array", bs_pointer: "Int32Array", bs_abs_bord_0: "Int32Array", bs_abs_bord_1: "Int32Array", bs_num_rel_0: "Int32Array", bs_num_rel_1: "Int32Array", bs_df_env: "Array", bs_df_noise: "Array", startMinTable: "Int32Array", offsetIndexTable: "Int32Array", OFFSET: "Array", LOGGER: "Logger", T_HUFFMAN_ENV_1_5DB: "Array", F_HUFFMAN_ENV_1_5DB: "Array", T_HUFFMAN_ENV_BAL_1_5DB: "Array", F_HUFFMAN_ENV_BAL_1_5DB: "Array", T_HUFFMAN_ENV_3_0DB: "Array", F_HUFFMAN_ENV_3_0DB: "Array", T_HUFFMAN_ENV_BAL_3_0DB: "Array", F_HUFFMAN_ENV_BAL_3_0DB: "Array", T_HUFFMAN_NOISE_3_0DB: "Array", T_HUFFMAN_NOISE_BAL_3_0DB: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Supplementary Enhanced Information entity of H264 bitstream
 *  
 *  capable to serialize and deserialize with CAVLC bitstream
 *  
 *  @author The JCodec project
 *  
 */
var SEI = function(messages) {
    this.messages = messages;
};
SEI = stjs.extend(SEI, null, [], function(constructor, prototype) {
    constructor.SEIMessage = function(payloadType2, payloadSize2, payload2) {
        this.payload = payload2;
        this.payloadType = payloadType2;
        this.payloadSize = payloadSize2;
    };
    constructor.SEIMessage = stjs.extend(constructor.SEIMessage, null, [], function(constructor, prototype) {
        prototype.payloadType = 0;
        prototype.payloadSize = 0;
        prototype.payload = null;
    }, {payload: "Int8Array"}, {});
    prototype.messages = null;
    constructor.read = function(is) {
        var messages = new ArrayList();
        var msg;
        do {
            msg = SEI.sei_message(is);
            if (msg != null) 
                messages.add(msg);
        } while (msg != null);
        return new SEI(messages.toArray([]));
    };
    constructor.sei_message = function(is) {
        var payloadType = 0;
        var b = 0;
         while (is.hasRemaining() && (b = (is.get() & 255)) == 255){
            payloadType += 255;
        }
        if (!is.hasRemaining()) 
            return null;
        payloadType += b;
        var payloadSize = 0;
         while (is.hasRemaining() && (b = (is.get() & 255)) == 255){
            payloadSize += 255;
        }
        if (!is.hasRemaining()) 
            return null;
        payloadSize += b;
        var payload = SEI.sei_payload(payloadType, payloadSize, is);
        if (payload.length != payloadSize) 
            return null;
        return new SEI.SEIMessage(payloadType, payloadSize, payload);
    };
    constructor.sei_payload = function(payloadType, payloadSize, is) {
        var res = new Int8Array(payloadSize);
        is.getBuf(res);
        return res;
    };
    prototype.write = function(out) {
        var writer = new BitWriter(out);
        CAVLCWriter.writeTrailingBits(writer);
    };
}, {messages: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Sequence Parameter Set Extension entity of H264 bitstream
 *  
 *  Capable to serialize / deserialize itself with CAVLC bit stream
 *  
 *  @author The JCodec project
 *  
 */
var SeqParameterSetExt = function() {};
SeqParameterSetExt = stjs.extend(SeqParameterSetExt, null, [], function(constructor, prototype) {
    prototype.seq_parameter_set_id = 0;
    prototype.aux_format_idc = 0;
    prototype.bit_depth_aux_minus8 = 0;
    prototype.alpha_incr_flag = false;
    prototype.additional_extension_flag = false;
    prototype.alpha_opaque_value = 0;
    prototype.alpha_transparent_value = 0;
    constructor.read = function(is) {
        var _in = BitReader.createBitReader(is);
        var spse = new SeqParameterSetExt();
        spse.seq_parameter_set_id = CAVLCReader.readUEtrace(_in, "SPSE: seq_parameter_set_id");
        spse.aux_format_idc = CAVLCReader.readUEtrace(_in, "SPSE: aux_format_idc");
        if (spse.aux_format_idc != 0) {
            spse.bit_depth_aux_minus8 = CAVLCReader.readUEtrace(_in, "SPSE: bit_depth_aux_minus8");
            spse.alpha_incr_flag = CAVLCReader.readBool(_in, "SPSE: alpha_incr_flag");
            spse.alpha_opaque_value = CAVLCReader.readU(_in, spse.bit_depth_aux_minus8 + 9, "SPSE: alpha_opaque_value");
            spse.alpha_transparent_value = CAVLCReader.readU(_in, spse.bit_depth_aux_minus8 + 9, "SPSE: alpha_transparent_value");
        }
        spse.additional_extension_flag = CAVLCReader.readBool(_in, "SPSE: additional_extension_flag");
        return spse;
    };
    prototype.write = function(out) {
        var writer = new BitWriter(out);
        CAVLCWriter.writeTrailingBits(writer);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Scaling list entity
 *  
 *  capable to serialize / deserialize with CAVLC bitstream
 *  
 *  
 *  @author The JCodec project
 *  
 */
var ScalingList = function() {};
ScalingList = stjs.extend(ScalingList, null, [], function(constructor, prototype) {
    prototype.scalingList = null;
    prototype.useDefaultScalingMatrixFlag = false;
    prototype.write = function(out) {
        if (this.useDefaultScalingMatrixFlag) {
            CAVLCWriter.writeSEtrace(out, 0, "SPS: ");
            return;
        }
        var lastScale = 8;
        var nextScale = 8;
        for (var j = 0; j < this.scalingList.length; j++) {
            if (nextScale != 0) {
                var deltaScale = this.scalingList[j] - lastScale - 256;
                CAVLCWriter.writeSEtrace(out, deltaScale, "SPS: ");
            }
            lastScale = this.scalingList[j];
        }
    };
    constructor.read = function(_in, sizeOfScalingList) {
        var sl = new ScalingList();
        sl.scalingList = new Int32Array(sizeOfScalingList);
        var lastScale = 8;
        var nextScale = 8;
        for (var j = 0; j < sizeOfScalingList; j++) {
            if (nextScale != 0) {
                var deltaScale = CAVLCReader.readSE(_in, "deltaScale");
                nextScale = (lastScale + deltaScale + 256) % 256;
                sl.useDefaultScalingMatrixFlag = (j == 0 && nextScale == 0);
            }
            sl.scalingList[j] = nextScale == 0 ? lastScale : nextScale;
            lastScale = sl.scalingList[j];
        }
        return sl;
    };
}, {scalingList: "Int32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Pulls frames from MPEG elementary stream
 *  
 *  @author The JCodec project
 *  
 */
var SegmentReader = function(channel, fetchSize) {
    this.channel = channel;
    this.fetchSize = fetchSize;
    this.buf = NIOUtils.fetchFromChannel(channel, 4);
    this.pos = this.buf.remaining();
    this.curMarker = this.buf.getInt();
};
SegmentReader = stjs.extend(SegmentReader, null, [], function(constructor, prototype) {
    prototype.channel = null;
    prototype.buf = null;
    prototype.curMarker = 0;
    prototype.fetchSize = 0;
    prototype.done = false;
    prototype.pos = 0;
    prototype.readToNextMarker = function(out) {
        if (this.done) 
            return false;
        var n = 1;
        do {
             while (this.buf.hasRemaining()){
                if (this.curMarker >= 256 && this.curMarker <= 511) {
                    if (n == 0) {
                        return true;
                    }
                    --n;
                }
                out.put(((this.curMarker >>> 24) << 24 >> 24));
                this.curMarker = (this.curMarker << 8) | (this.buf.get() & 255);
            }
            this.buf = NIOUtils.fetchFromChannel(this.channel, this.fetchSize);
            this.pos += this.buf.remaining();
        } while (this.buf.hasRemaining());
        out.putInt(this.curMarker);
        this.done = true;
        return false;
    };
    prototype.skipToMarker = function() {
        if (this.done) 
            return false;
        do {
             while (this.buf.hasRemaining()){
                this.curMarker = (this.curMarker << 8) | (this.buf.get() & 255);
                if (this.curMarker >= 256 && this.curMarker <= 511) {
                    return true;
                }
            }
            this.buf = NIOUtils.fetchFromChannel(this.channel, this.fetchSize);
            this.pos += this.buf.remaining();
        } while (this.buf.hasRemaining());
        this.done = true;
        return false;
    };
    prototype.read = function(out, length) {
        if (this.done) 
            return false;
        do {
             while (this.buf.hasRemaining()){
                if (length-- == 0) 
                    return true;
                out.put(((this.curMarker >>> 24) << 24 >> 24));
                this.curMarker = (this.curMarker << 8) | (this.buf.get() & 255);
            }
            this.buf = NIOUtils.fetchFromChannel(this.channel, this.fetchSize);
            this.pos += this.buf.remaining();
        } while (this.buf.hasRemaining());
        out.putInt(this.curMarker);
        this.done = true;
        return false;
    };
    prototype.curPos = function() {
        return this.pos - this.buf.remaining() - 4;
    };
}, {channel: "ReadableByteChannel", buf: "ByteBuffer"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Retrieves a movie range
 *  
 *  @author The JCodec project
 *  
 */
var MovieRange = function(movie, from, to) {
    BaseInputStream.call(this);
    if (to < from) 
         throw new IllegalArgumentException("from < to");
    this.movie = movie;
    var chunk = movie.getPacketAt(from);
    this.remaining = to - from + 1;
    if (chunk != null) {
        this.chunkData = MovieRange.checkDataLen(chunk.getData(), chunk.getDataLen());
        this.chunkNo = chunk.getNo();
        NIOUtils.skip(this.chunkData, (((from - chunk.getPos())) | 0));
    }
};
MovieRange = stjs.extend(MovieRange, BaseInputStream, [], function(constructor, prototype) {
    prototype.movie = null;
    prototype.remaining = 0;
    prototype.chunkNo = 0;
    prototype.chunkData = null;
    constructor.checkDataLen = function(chunkData, chunkDataLen) {
        if (chunkData == null) {
            System.err.println("WARN: packet expected data len != actual data len " + chunkDataLen + " != 0");
            return ByteBuffer.allocate(chunkDataLen);
        }
        if (chunkData.remaining() != chunkDataLen) {
            System.err.println("WARN: packet expected data len != actual data len " + chunkDataLen + " != " + chunkData.remaining());
            chunkDataLen = Math.max(0, chunkDataLen);
            if (chunkDataLen < chunkData.remaining() || chunkData.capacity() - chunkData.position() >= chunkDataLen) {
                chunkData.setLimit(chunkData.position() + chunkDataLen);
            } else {
                var correct = ByteBuffer.allocate(chunkDataLen);
                correct.putBuf(chunkData);
                correct.clear();
                return correct;
            }
        }
        return chunkData;
    };
    prototype.readBuffer = function(b, from, len) {
        this.tryFetch();
        if (this.chunkData == null || this.remaining == 0) 
            return -1;
        len = ((Math.min(this.remaining, len)) | 0);
        var totalRead = 0;
         while (len > 0){
            var toRead = Math.min(this.chunkData.remaining(), len);
            this.chunkData.getBuf3(b, from, toRead);
            totalRead += toRead;
            len -= toRead;
            from += toRead;
            this.tryFetch();
            if (this.chunkData == null) 
                break;
        }
        this.remaining -= totalRead;
        return totalRead;
    };
    prototype.tryFetch = function() {
        if (this.chunkData == null || !this.chunkData.hasRemaining()) {
            var chunk = this.movie.getPacketByNo(this.chunkNo + 1);
            if (chunk != null) {
                this.chunkData = MovieRange.checkDataLen(chunk.getData(), chunk.getDataLen());
                this.chunkNo = chunk.getNo();
            } else 
                this.chunkData = null;
        }
    };
    prototype.readByte = function() {
        this.tryFetch();
        if (this.chunkData == null || this.remaining == 0) 
            return -1;
        --this.remaining;
        return this.chunkData.get() & 255;
    };
}, {movie: "VirtualMovie", chunkData: "ByteBuffer"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Descriptor = function(tag, size) {
    this._tag = tag;
    this.size = size;
};
Descriptor = stjs.extend(Descriptor, null, [], function(constructor, prototype) {
    prototype._tag = 0;
    prototype.size = 0;
    prototype.factory = null;
    prototype.write = function(out) {
        var fork = out.duplicate();
        NIOUtils.skip(out, 5);
        this.doWrite(out);
        var length = out.position() - fork.position() - 5;
        fork.put((this._tag << 24 >> 24));
        JCodecUtil2.writeBER32(fork, length);
    };
    prototype.doWrite = function(out) {};
    prototype.parse = function(input) {};
    prototype.getTag = function() {
        return this._tag;
    };
    constructor.read = function(input, factory) {
        if (input.remaining() < 2) 
            return null;
        var tag = input.get() & 255;
        var size = JCodecUtil2.readBER32(input);
        var cls = factory.byTag(tag);
        var descriptor;
        try {
            descriptor = cls.getConstructor(Integer.TYPE, Integer.TYPE).newInstance(tag, stjs.trunc(size));
            descriptor.setFactory(factory);
        }catch (e) {
             throw new RuntimeException(e);
        }
        descriptor.parse(NIOUtils.read(input, size));
        return descriptor;
    };
    prototype.setFactory = function(factory) {
        this.factory = factory;
    };
}, {factory: "IDescriptorFactory"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Implements a seekable byte channel that wraps a byte buffer
 *  
 *  @author The JCodec project
 *  
 */
var ByteBufferSeekableByteChannel = function(backing) {
    this.backing = backing;
    this.contentLength = backing.remaining();
    this.open = true;
};
ByteBufferSeekableByteChannel = stjs.extend(ByteBufferSeekableByteChannel, null, [SeekableByteChannel], function(constructor, prototype) {
    prototype.backing = null;
    prototype.open = false;
    prototype.contentLength = 0;
    prototype.isOpen = function() {
        return this.open;
    };
    prototype.close = function() {
        this.open = false;
    };
    prototype.read = function(dst) {
        if (!this.backing.hasRemaining()) {
            return -1;
        }
        var toRead = Math.min(this.backing.remaining(), dst.remaining());
        dst.putBuf(NIOUtils.read(this.backing, toRead));
        this.contentLength = Math.max(this.contentLength, this.backing.position());
        return toRead;
    };
    prototype.write = function(src) {
        var toWrite = Math.min(this.backing.remaining(), src.remaining());
        this.backing.putBuf(NIOUtils.read(src, toWrite));
        this.contentLength = Math.max(this.contentLength, this.backing.position());
        return toWrite;
    };
    prototype.position = function() {
        return this.backing.position();
    };
    prototype.setPosition = function(newPosition) {
        this.backing.setPosition(((newPosition) | 0));
        this.contentLength = Math.max(this.contentLength, this.backing.position());
        return this;
    };
    prototype.size = function() {
        return this.contentLength;
    };
    prototype.truncate = function(size) {
        this.contentLength = ((size) | 0);
        return this;
    };
    prototype.getContents = function() {
        var contents = this.backing.duplicate();
        contents.setPosition(0);
        contents.setLimit(this.contentLength);
        return contents;
    };
}, {backing: "ByteBuffer"}, {});
/**
 *  
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Apple ProRes encoder
 *  
 *  @author The JCodec project
 *  
 */
var ProresEncoder = function(profile, interlaced) {
    VideoEncoder.call(this);
    this.profile = profile;
    this.scaledLuma = this.scaleQMat(profile.qmatLuma, 1, 16);
    this.scaledChroma = this.scaleQMat(profile.qmatChroma, 1, 16);
    this.interlaced = interlaced;
};
ProresEncoder = stjs.extend(ProresEncoder, VideoEncoder, [], function(constructor, prototype) {
    constructor.LOG_DEFAULT_SLICE_MB_WIDTH = 3;
    constructor.DEFAULT_SLICE_MB_WIDTH = 1 << ProresEncoder.LOG_DEFAULT_SLICE_MB_WIDTH;
    constructor.Profile = function(qmatLuma, qmatChroma, fourcc, bitrate, firstQp, lastQp) {
        this.qmatLuma = qmatLuma;
        this.qmatChroma = qmatChroma;
        this.fourcc = fourcc;
        this.bitrate = bitrate;
        this.firstQp = firstQp;
        this.lastQp = lastQp;
    };
    constructor.Profile = stjs.extend(constructor.Profile, null, [], function(constructor, prototype) {
        constructor.PROXY = new ProresEncoder.Profile(ProresConsts.QMAT_LUMA_APCO, ProresConsts.QMAT_CHROMA_APCO, "apco", 1000, 4, 8);
        constructor.LT = new ProresEncoder.Profile(ProresConsts.QMAT_LUMA_APCS, ProresConsts.QMAT_CHROMA_APCS, "apcs", 2100, 1, 9);
        constructor.STANDARD = new ProresEncoder.Profile(ProresConsts.QMAT_LUMA_APCN, ProresConsts.QMAT_CHROMA_APCN, "apcn", 3500, 1, 6);
        constructor.HQ = new ProresEncoder.Profile(ProresConsts.QMAT_LUMA_APCH, ProresConsts.QMAT_CHROMA_APCH, "apch", 5400, 1, 6);
        constructor._values = [ProresEncoder.Profile.PROXY, ProresEncoder.Profile.LT, ProresEncoder.Profile.STANDARD, ProresEncoder.Profile.HQ];
        constructor.values = function() {
            return ProresEncoder.Profile._values;
        };
        prototype.qmatLuma = null;
        prototype.qmatChroma = null;
        prototype.fourcc = null;
        prototype.bitrate = 0;
        prototype.firstQp = 0;
        prototype.lastQp = 0;
    }, {PROXY: "ProresEncoder.Profile", LT: "ProresEncoder.Profile", STANDARD: "ProresEncoder.Profile", HQ: "ProresEncoder.Profile", _values: "Array", qmatLuma: "Int32Array", qmatChroma: "Int32Array"}, {});
    prototype.profile = null;
    prototype.scaledLuma = null;
    prototype.scaledChroma = null;
    prototype.interlaced = false;
    prototype.scaleQMat = function(qmatLuma, start, count) {
        var result = Array(count);
        for (var i = 0; i < count; i++) {
            result[i] = new Int32Array(qmatLuma.length);
            for (var j = 0; j < qmatLuma.length; j++) 
                result[i][j] = qmatLuma[j] * (i + start);
        }
        return result;
    };
    constructor.writeCodeword = function(writer, codebook, val) {
        var firstExp = ((codebook.switchBits + 1) << codebook.riceOrder);
        if (val >= firstExp) {
            val -= firstExp;
            val += (1 << codebook.expOrder);
            var exp = MathUtil.log2(val);
            var zeros = exp - codebook.expOrder + codebook.switchBits + 1;
            for (var i = 0; i < zeros; i++) 
                writer.write1Bit(0);
            writer.write1Bit(1);
            writer.writeNBit(val, exp);
        } else if (codebook.riceOrder > 0) {
            for (var i = 0; i < (val >> codebook.riceOrder); i++) 
                writer.write1Bit(0);
            writer.write1Bit(1);
            writer.writeNBit(val & ((1 << codebook.riceOrder) - 1), codebook.riceOrder);
        } else {
            for (var i = 0; i < val; i++) 
                writer.write1Bit(0);
            writer.write1Bit(1);
        }
    };
    constructor.qScale = function(qMat, ind, val) {
        return stjs.trunc(val / qMat[ind]);
    };
    constructor.toGolumb = function(val) {
        return (val << 1) ^ (val >> 31);
    };
    constructor.toGolumbSign = function(val, sign) {
        if (val == 0) 
            return 0;
        return (val << 1) + sign;
    };
    constructor.diffSign = function(val, sign) {
        return (val >> 31) ^ sign;
    };
    constructor.getLevel = function(val) {
        var sign = (val >> 31);
        return (val ^ sign) - sign;
    };
    constructor.writeDCCoeffs = function(bits, qMat, _in, blocksPerSlice) {
        var prevDc = ProresEncoder.qScale(qMat, 0, _in[0] - 16384);
        ProresEncoder.writeCodeword(bits, ProresConsts.firstDCCodebook, ProresEncoder.toGolumb(prevDc));
        var code = 5, sign = 0, idx = 64;
        for (var i = 1; i < blocksPerSlice; i++ , idx += 64) {
            var newDc = ProresEncoder.qScale(qMat, 0, _in[idx] - 16384);
            var delta = newDc - prevDc;
            var newCode = ProresEncoder.toGolumbSign(ProresEncoder.getLevel(delta), ProresEncoder.diffSign(delta, sign));
            ProresEncoder.writeCodeword(bits, ProresConsts.dcCodebooks[Math.min(code, 6)], newCode);
            code = newCode;
            sign = delta >> 31;
            prevDc = newDc;
        }
    };
    constructor.writeACCoeffs = function(bits, qMat, _in, blocksPerSlice, scan, maxCoeff) {
        var prevRun = 4;
        var prevLevel = 2;
        var run = 0;
        for (var i = 1; i < maxCoeff; i++) {
            var indp = scan[i];
            for (var j = 0; j < blocksPerSlice; j++) {
                var val = ProresEncoder.qScale(qMat, indp, _in[(j << 6) + indp]);
                if (val == 0) 
                    run++;
                 else {
                    ProresEncoder.writeCodeword(bits, ProresConsts.runCodebooks[Math.min(prevRun, 15)], run);
                    prevRun = run;
                    run = 0;
                    var level = ProresEncoder.getLevel(val);
                    ProresEncoder.writeCodeword(bits, ProresConsts.levCodebooks[Math.min(prevLevel, 9)], level - 1);
                    prevLevel = level;
                    bits.write1Bit(MathUtil.sign(val));
                }
            }
        }
    };
    constructor.encodeOnePlane = function(bits, blocksPerSlice, qMat, scan, _in) {
        ProresEncoder.writeDCCoeffs(bits, qMat, _in, blocksPerSlice);
        ProresEncoder.writeACCoeffs(bits, qMat, _in, blocksPerSlice, scan, 64);
    };
    prototype.dctOnePlane = function(blocksPerSlice, _in, out) {
        for (var i = 0; i < blocksPerSlice; i++) {
            SimpleIDCT10Bit.fdct10(_in, i << 6, out);
        }
    };
    prototype.encodeSlice = function(out, scaledLuma, scaledChroma, scan, sliceMbCount, mbX, mbY, result, prevQp, mbWidth, mbHeight, unsafe, vStep, vOffset) {
        var striped = this.splitSlice(result, mbX, mbY, sliceMbCount, unsafe, vStep, vOffset);
        var ac = [new Int32Array(sliceMbCount << 8), new Int32Array(sliceMbCount << 7), new Int32Array(sliceMbCount << 7)];
        this.dctOnePlane(sliceMbCount << 2, striped.getPlaneData(0), ac[0]);
        this.dctOnePlane(sliceMbCount << 1, striped.getPlaneData(1), ac[1]);
        this.dctOnePlane(sliceMbCount << 1, striped.getPlaneData(2), ac[2]);
        var est = (sliceMbCount >> 2) * this.profile.bitrate;
        var low = est - (est >> 3);
        var high = est + (est >> 3);
        var qp = prevQp;
        out.put(((6 << 3) << 24 >> 24));
        var fork = out.duplicate();
        NIOUtils.skip(out, 5);
        var rem = out.position();
        var sizes = new Int32Array(3);
        ProresEncoder.encodeSliceData(out, scaledLuma[qp - 1], scaledChroma[qp - 1], scan, sliceMbCount, ac, qp, sizes);
        if (ProresEncoder.bits(sizes) > high && qp < this.profile.lastQp) {
            do {
                ++qp;
                out.setPosition(rem);
                ProresEncoder.encodeSliceData(out, scaledLuma[qp - 1], scaledChroma[qp - 1], scan, sliceMbCount, ac, qp, sizes);
            } while (ProresEncoder.bits(sizes) > high && qp < this.profile.lastQp);
        } else if (ProresEncoder.bits(sizes) < low && qp > this.profile.firstQp) {
            do {
                --qp;
                out.setPosition(rem);
                ProresEncoder.encodeSliceData(out, scaledLuma[qp - 1], scaledChroma[qp - 1], scan, sliceMbCount, ac, qp, sizes);
            } while (ProresEncoder.bits(sizes) < low && qp > this.profile.firstQp);
        }
        fork.put((qp << 24 >> 24));
        fork.putShort(((sizes[0]) << 16 >> 16));
        fork.putShort(((sizes[1]) << 16 >> 16));
        return qp;
    };
    constructor.bits = function(sizes) {
        return sizes[0] + sizes[1] + sizes[2] << 3;
    };
    constructor.encodeSliceData = function(out, qmatLuma, qmatChroma, scan, sliceMbCount, ac, qp, sizes) {
        sizes[0] = ProresEncoder.onePlane(out, sliceMbCount << 2, qmatLuma, scan, ac[0]);
        sizes[1] = ProresEncoder.onePlane(out, sliceMbCount << 1, qmatChroma, scan, ac[1]);
        sizes[2] = ProresEncoder.onePlane(out, sliceMbCount << 1, qmatChroma, scan, ac[2]);
    };
    constructor.onePlane = function(out, blocksPerSlice, qmatLuma, scan, data) {
        var rem = out.position();
        var bits = new BitWriter(out);
        ProresEncoder.encodeOnePlane(bits, blocksPerSlice, qmatLuma, scan, data);
        bits.flush();
        return out.position() - rem;
    };
    prototype.encodePicture = function(out, scaledLuma, scaledChroma, scan, picture, vStep, vOffset) {
        var mbWidth = (picture.getWidth() + 15) >> 4;
        var shift = 4 + vStep;
        var round = (1 << shift) - 1;
        var mbHeight = (picture.getHeight() + round) >> shift;
        var qp = this.profile.firstQp;
        var nSlices = this.calcNSlices(mbWidth, mbHeight);
        ProresEncoder.writePictureHeader(ProresEncoder.LOG_DEFAULT_SLICE_MB_WIDTH, nSlices, out);
        var fork = out.duplicate();
        NIOUtils.skip(out, nSlices << 1);
        var i = 0;
        var total = new Int32Array(nSlices);
        for (var mbY = 0; mbY < mbHeight; mbY++) {
            var mbX = 0;
            var sliceMbCount = ProresEncoder.DEFAULT_SLICE_MB_WIDTH;
             while (mbX < mbWidth){
                 while (mbWidth - mbX < sliceMbCount)
                    sliceMbCount >>= 1;
                var sliceStart = out.position();
                var unsafeBottom = (picture.getHeight() % 16) != 0 && mbY == mbHeight - 1;
                var unsafeRight = (picture.getWidth() % 16) != 0 && mbX + sliceMbCount == mbWidth;
                qp = this.encodeSlice(out, scaledLuma, scaledChroma, scan, sliceMbCount, mbX, mbY, picture, qp, mbWidth, mbHeight, unsafeBottom || unsafeRight, vStep, vOffset);
                fork.putShort((((out.position() - sliceStart)) << 16 >> 16));
                total[i++] = (((out.position() - sliceStart)) << 16 >> 16);
                mbX += sliceMbCount;
            }
        }
    };
    constructor.writePictureHeader = function(logDefaultSliceMbWidth, nSlices, out) {
        var headerLen = 8;
        out.put(((headerLen << 3) << 24 >> 24));
        out.putInt(0);
        out.putShort(((nSlices) << 16 >> 16));
        out.put(((logDefaultSliceMbWidth << 4) << 24 >> 24));
    };
    prototype.calcNSlices = function(mbWidth, mbHeight) {
        var nSlices = mbWidth >> ProresEncoder.LOG_DEFAULT_SLICE_MB_WIDTH;
        for (var i = 0; i < ProresEncoder.LOG_DEFAULT_SLICE_MB_WIDTH; i++) {
            nSlices += (mbWidth >> i) & 1;
        }
        return nSlices * mbHeight;
    };
    prototype.splitSlice = function(result, mbX, mbY, sliceMbCount, unsafe, vStep, vOffset) {
        var out = Picture8Bit.create(sliceMbCount << 4, 16, ColorSpace.YUV422);
        if (unsafe) {
            var mbHeightPix = 16 << vStep;
            var filled = Picture8Bit.create(sliceMbCount << 4, mbHeightPix, ColorSpace.YUV422);
            ImageOP.subImageWithFillPic8(result, filled, new Rect(mbX << 4, mbY << (4 + vStep), sliceMbCount << 4, mbHeightPix));
            this.split(filled, out, 0, 0, sliceMbCount, vStep, vOffset);
        } else {
            this.split(result, out, mbX, mbY, sliceMbCount, vStep, vOffset);
        }
        return out;
    };
    prototype.split = function(_in, out, mbX, mbY, sliceMbCount, vStep, vOffset) {
        this.doSplit(_in.getPlaneData(0), out.getPlaneData(0), _in.getPlaneWidth(0), mbX, mbY, sliceMbCount, 0, vStep, vOffset);
        this.doSplit(_in.getPlaneData(1), out.getPlaneData(1), _in.getPlaneWidth(1), mbX, mbY, sliceMbCount, 1, vStep, vOffset);
        this.doSplit(_in.getPlaneData(2), out.getPlaneData(2), _in.getPlaneWidth(2), mbX, mbY, sliceMbCount, 1, vStep, vOffset);
    };
    prototype.doSplit = function(_in, out, stride, mbX, mbY, sliceMbCount, chroma, vStep, vOffset) {
        var outOff = 0;
        var off = (mbY << 4) * (stride << vStep) + (mbX << (4 - chroma)) + stride * vOffset;
        stride <<= vStep;
        for (var i = 0; i < sliceMbCount; i++) {
            this.splitBlock(_in, stride, off, out, outOff);
            this.splitBlock(_in, stride, off + (stride << 3), out, outOff + (128 >> chroma));
            if (chroma == 0) {
                this.splitBlock(_in, stride, off + 8, out, outOff + 64);
                this.splitBlock(_in, stride, off + (stride << 3) + 8, out, outOff + 192);
            }
            outOff += (256 >> chroma);
            off += (16 >> chroma);
        }
    };
    prototype.splitBlock = function(y, stride, off, out, outOff) {
        for (var i = 0; i < 8; i++) {
            for (var j = 0; j < 8; j++) 
                out[outOff++] = y[off++];
            off += stride - 8;
        }
    };
    prototype.encodeFrame8Bit = function(pic, buffer) {
        var out = buffer.duplicate();
        var fork = out.duplicate();
        var scan = this.interlaced ? ProresConsts.interlaced_scan : ProresConsts.progressive_scan;
        ProresEncoder.writeFrameHeader(out, new ProresConsts.FrameHeader(0, pic.getCroppedWidth(), pic.getCroppedHeight(), this.interlaced ? 1 : 0, true, scan, this.profile.qmatLuma, this.profile.qmatChroma, 2));
        this.encodePicture(out, this.scaledLuma, this.scaledChroma, scan, pic, this.interlaced ? 1 : 0, 0);
        if (this.interlaced) 
            this.encodePicture(out, this.scaledLuma, this.scaledChroma, scan, pic, this.interlaced ? 1 : 0, 1);
        out.flip();
        fork.putInt(out.remaining());
        return out;
    };
    constructor.writeFrameHeader = function(outp, header) {
        var headerSize = 148;
        outp.putInt(headerSize + 8 + header.payloadSize);
        outp.putArr(new Int8Array(['i', 'c', 'p', 'f']));
        outp.putShort(headerSize);
        outp.putShort(((0) << 16 >> 16));
        outp.putArr(new Int8Array(['a', 'p', 'l', '0']));
        outp.putShort(((header.width) << 16 >> 16));
        outp.putShort(((header.height) << 16 >> 16));
        outp.put(((header.frameType == 0 ? 131 : 135) << 24 >> 24));
        outp.putArr(new Int8Array([0, 2, 2, 6, 32, 0]));
        outp.put((3 << 24 >> 24));
        ProresEncoder.writeQMat(outp, header.qMatLuma);
        ProresEncoder.writeQMat(outp, header.qMatChroma);
    };
    constructor.writeQMat = function(out, qmat) {
        for (var i = 0; i < 64; i++) 
            out.put((qmat[i] << 24 >> 24));
    };
    prototype.getSupportedColorSpaces = function() {
        return [ColorSpace.YUV422];
    };
}, {profile: "ProresEncoder.Profile", scaledLuma: "Array", scaledChroma: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var DeltaEntries = function(posTabIdx, slice, elementDelta) {
    this.posTabIdx = posTabIdx;
    this.slice = slice;
    this.elementData = elementDelta;
};
DeltaEntries = stjs.extend(DeltaEntries, null, [], function(constructor, prototype) {
    prototype.posTabIdx = null;
    prototype.slice = null;
    prototype.elementData = null;
    constructor.read = function(bb) {
        bb.order(ByteOrder.BIG_ENDIAN);
        var n = bb.getInt();
        var len = bb.getInt();
        var posTabIdx = new Int8Array(n);
        var slice = new Int8Array(n);
        var elementDelta = new Int32Array(n);
        for (var i = 0; i < n; i++) {
            posTabIdx[i] = bb.get();
            slice[i] = bb.get();
            elementDelta[i] = bb.getInt();
            NIOUtils.skip(bb, len - 6);
        }
        return new DeltaEntries(posTabIdx, slice, elementDelta);
    };
}, {posTabIdx: "Int8Array", slice: "Int8Array", elementData: "Int32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Demuxer for MPEG Program Stream format
 *  
 *  @author The JCodec project
 *  
 */
var MPSUtils = function() {};
MPSUtils = stjs.extend(MPSUtils, null, [], function(constructor, prototype) {
    constructor.VIDEO_MIN = 480;
    constructor.VIDEO_MAX = 495;
    constructor.AUDIO_MIN = 448;
    constructor.AUDIO_MAX = 479;
    constructor.PACK = 442;
    constructor.SYSTEM = 443;
    constructor.PSM = 444;
    constructor.PRIVATE_1 = 445;
    constructor.PRIVATE_2 = 447;
    constructor.mediaStream = function(streamId) {
        return (streamId >= MPSUtils.$(MPSUtils.AUDIO_MIN) && streamId <= MPSUtils.$(MPSUtils.VIDEO_MAX) || streamId == MPSUtils.$(MPSUtils.PRIVATE_1) || streamId == MPSUtils.$(MPSUtils.PRIVATE_2));
    };
    constructor.mediaMarker = function(marker) {
        return (marker >= MPSUtils.AUDIO_MIN && marker <= MPSUtils.VIDEO_MAX || marker == MPSUtils.PRIVATE_1 || marker == MPSUtils.PRIVATE_2);
    };
    constructor.psMarker = function(marker) {
        return marker >= MPSUtils.PRIVATE_1 && marker <= MPSUtils.VIDEO_MAX;
    };
    constructor.videoMarker = function(marker) {
        return marker >= MPSUtils.VIDEO_MIN && marker <= MPSUtils.VIDEO_MAX;
    };
    constructor.videoStream = function(streamId) {
        return streamId >= MPSUtils.$(MPSUtils.VIDEO_MIN) && streamId <= MPSUtils.$(MPSUtils.VIDEO_MAX);
    };
    constructor.audioStream = function(streamId) {
        return streamId >= MPSUtils.$(MPSUtils.AUDIO_MIN) && streamId <= MPSUtils.$(MPSUtils.AUDIO_MAX) || streamId == MPSUtils.$(MPSUtils.PRIVATE_1) || streamId == MPSUtils.$(MPSUtils.PRIVATE_2);
    };
    constructor.$ = function(marker) {
        return marker & 255;
    };
    constructor.PESReader = function() {
        this.pesBuffer = ByteBuffer.allocate(1 << 21);
    };
    constructor.PESReader = stjs.extend(constructor.PESReader, null, [], function(constructor, prototype) {
        prototype.marker = -1;
        prototype.lenFieldLeft = 0;
        prototype.pesLen = 0;
        prototype.pesFileStart = -1;
        prototype.stream = 0;
        prototype._pes = false;
        prototype.pesLeft = 0;
        prototype.pesBuffer = null;
        prototype.pes = function(pesBuffer, start, pesLen, stream) {};
        prototype.analyseBuffer = function(buf, pos) {
            var init = buf.position();
             while (buf.hasRemaining()){
                if (this.pesLeft > 0) {
                    var toRead = Math.min(buf.remaining(), this.pesLeft);
                    this.pesBuffer.putBuf(NIOUtils.read(buf, toRead));
                    this.pesLeft -= toRead;
                    if (this.pesLeft == 0) {
                        var filePos = pos + buf.position() - init;
                        this.pes1(this.pesBuffer, this.pesFileStart, (((filePos - this.pesFileStart)) | 0), this.stream);
                        this.pesFileStart = -1;
                        this._pes = false;
                        this.stream = -1;
                    }
                    continue;
                }
                var bt = buf.get() & 255;
                if (this._pes) 
                    this.pesBuffer.put(((this.marker >>> 24) << 24 >> 24));
                this.marker = (this.marker << 8) | bt;
                if (this.marker >= MPSUtils.SYSTEM && this.marker <= MPSUtils.VIDEO_MAX) {
                    var filePos = pos + buf.position() - init - 4;
                    if (this._pes) 
                        this.pes1(this.pesBuffer, this.pesFileStart, (((filePos - this.pesFileStart)) | 0), this.stream);
                    this.pesFileStart = filePos;
                    this._pes = true;
                    this.stream = this.marker & 255;
                    this.lenFieldLeft = 2;
                    this.pesLen = 0;
                } else if (this.marker >= 441 && this.marker <= 511) {
                    if (this._pes) {
                        var filePos = pos + buf.position() - init - 4;
                        this.pes1(this.pesBuffer, this.pesFileStart, (((filePos - this.pesFileStart)) | 0), this.stream);
                    }
                    this.pesFileStart = -1;
                    this._pes = false;
                    this.stream = -1;
                } else if (this.lenFieldLeft > 0) {
                    this.pesLen = (this.pesLen << 8) | bt;
                    this.lenFieldLeft--;
                    if (this.lenFieldLeft == 0) {
                        this.pesLeft = this.pesLen;
                        if (this.pesLen != 0) {
                            this.flushMarker();
                            this.marker = -1;
                        }
                    }
                }
            }
        };
        prototype.flushMarker = function() {
            this.pesBuffer.put(((this.marker >>> 24) << 24 >> 24));
            this.pesBuffer.put((((this.marker >>> 16) & 255) << 24 >> 24));
            this.pesBuffer.put((((this.marker >>> 8) & 255) << 24 >> 24));
            this.pesBuffer.put(((this.marker & 255) << 24 >> 24));
        };
        prototype.pes1 = function(pesBuffer, start, pesLen, stream) {
            pesBuffer.flip();
            this.pes(pesBuffer, start, pesLen, stream);
            pesBuffer.clear();
        };
        prototype.finishRead = function() {
            if (this.pesLeft <= 4) {
                this.flushMarker();
                this.pes1(this.pesBuffer, this.pesFileStart, this.pesBuffer.position(), this.stream);
            }
        };
    }, {pesBuffer: "ByteBuffer"}, {});
    constructor.readPESHeader = function(iss, pos) {
        var streamId = iss.getInt() & 255;
        var len = iss.getShort() & 65535;
        if (streamId != 191) {
            var b0 = iss.get() & 255;
            if ((b0 & 192) == 128) 
                return MPSUtils.mpeg2Pes(b0, len, streamId, iss, pos);
             else 
                return MPSUtils.mpeg1Pes(b0, len, streamId, iss, pos);
        }
        return new PESPacket(null, -1, streamId, len, pos, -1);
    };
    constructor.mpeg1Pes = function(b0, len, streamId, is, pos) {
        var c = b0;
         while (c == 255){
            c = is.get() & 255;
        }
        if ((c & 192) == 64) {
            is.get();
            c = is.get() & 255;
        }
        var pts = -1, dts = -1;
        if ((c & 240) == 32) {
            pts = MPSUtils._readTs(is, c);
        } else if ((c & 240) == 48) {
            pts = MPSUtils._readTs(is, c);
            dts = MPSUtils.readTs(is);
        } else {
            if (c != 15) 
                 throw new RuntimeException("Invalid data");
        }
        return new PESPacket(null, pts, streamId, len, pos, dts);
    };
    constructor._readTs = function(is, c) {
        return ((stjs.trunc(c) & 14) << 29) | ((is.get() & 255) << 22) | (((is.get() & 255) >> 1) << 15) | ((is.get() & 255) << 7) | ((is.get() & 255) >> 1);
    };
    constructor.mpeg2Pes = function(b0, len, streamId, is, pos) {
        var flags1 = b0;
        var flags2 = is.get() & 255;
        var header_len = is.get() & 255;
        var pts = -1, dts = -1;
        if ((flags2 & 192) == 128) {
            pts = MPSUtils.readTs(is);
            NIOUtils.skip(is, header_len - 5);
        } else if ((flags2 & 192) == 192) {
            pts = MPSUtils.readTs(is);
            dts = MPSUtils.readTs(is);
            NIOUtils.skip(is, header_len - 10);
        } else 
            NIOUtils.skip(is, header_len);
        return new PESPacket(null, pts, streamId, len, pos, dts);
    };
    constructor.readTs = function(is) {
        return ((stjs.trunc(is.get()) & 14) << 29) | ((is.get() & 255) << 22) | (((is.get() & 255) >> 1) << 15) | ((is.get() & 255) << 7) | ((is.get() & 255) >> 1);
    };
    constructor.writeTs = function(is, ts) {
        is.put((((ts >> 29) << 1) << 24 >> 24));
        is.put(((ts >> 22) << 24 >> 24));
        is.put((((ts >> 15) << 1) << 24 >> 24));
        is.put(((ts >> 7) << 24 >> 24));
        is.put(((ts >> 1) << 24 >> 24));
    };
    constructor.MPEGMediaDescriptor = function() {};
    constructor.MPEGMediaDescriptor = stjs.extend(constructor.MPEGMediaDescriptor, null, [], function(constructor, prototype) {
        prototype.tag = 0;
        prototype.len = 0;
        prototype.parse = function(buf) {
            this.tag = buf.get() & 255;
            this.len = buf.get() & 255;
        };
        prototype.getTag = function() {
            return this.tag;
        };
        prototype.getLen = function() {
            return this.len;
        };
    }, {}, {});
    constructor.VideoStreamDescriptor = function() {
        MPSUtils.MPEGMediaDescriptor.call(this);
        this.frameRates = [null, new Rational(24000, 1001), new Rational(24, 1), new Rational(25, 1), new Rational(30000, 1001), new Rational(30, 1), new Rational(50, 1), new Rational(60000, 1001), new Rational(60, 1), null, null, null, null, null, null, null];
    };
    constructor.VideoStreamDescriptor = stjs.extend(constructor.VideoStreamDescriptor, MPSUtils.MPEGMediaDescriptor, [], function(constructor, prototype) {
        prototype.multipleFrameRate = 0;
        prototype.frameRateCode = 0;
        prototype.mpeg1Only = false;
        prototype.constrainedParameter = 0;
        prototype.stillPicture = 0;
        prototype.profileAndLevel = 0;
        prototype.chromaFormat = 0;
        prototype.frameRateExtension = 0;
        prototype.frameRates = null;
        prototype.parse = function(buf) {
            MPSUtils.MPEGMediaDescriptor.prototype.parse.call(this, buf);
            var b0 = buf.get() & 255;
            this.multipleFrameRate = (b0 >> 7) & 1;
            this.frameRateCode = (b0 >> 3) & 15;
            this.mpeg1Only = ((b0 >> 2) & 1) == 0;
            this.constrainedParameter = (b0 >> 1) & 1;
            this.stillPicture = b0 & 1;
            if (!this.mpeg1Only) {
                this.profileAndLevel = buf.get() & 255;
                var b1 = buf.get() & 255;
                this.chromaFormat = b1 >> 6;
                this.frameRateExtension = (b1 >> 5) & 1;
            }
        };
        prototype.getFrameRate = function() {
            return this.frameRates[this.frameRateCode];
        };
        prototype.getMultipleFrameRate = function() {
            return this.multipleFrameRate;
        };
        prototype.getFrameRateCode = function() {
            return this.frameRateCode;
        };
        prototype.isMpeg1Only = function() {
            return this.mpeg1Only;
        };
        prototype.getConstrainedParameter = function() {
            return this.constrainedParameter;
        };
        prototype.getStillPicture = function() {
            return this.stillPicture;
        };
        prototype.getProfileAndLevel = function() {
            return this.profileAndLevel;
        };
        prototype.getChromaFormat = function() {
            return this.chromaFormat;
        };
        prototype.getFrameRateExtension = function() {
            return this.frameRateExtension;
        };
    }, {frameRates: "Array"}, {});
    constructor.AudioStreamDescriptor = function() {
        MPSUtils.MPEGMediaDescriptor.call(this);
    };
    constructor.AudioStreamDescriptor = stjs.extend(constructor.AudioStreamDescriptor, MPSUtils.MPEGMediaDescriptor, [], function(constructor, prototype) {
        prototype.variableRateAudioIndicator = 0;
        prototype.freeFormatFlag = 0;
        prototype.id = 0;
        prototype.layer = 0;
        prototype.parse = function(buf) {
            MPSUtils.MPEGMediaDescriptor.prototype.parse.call(this, buf);
            var b0 = buf.get() & 255;
            this.freeFormatFlag = (b0 >> 7) & 1;
            this.id = (b0 >> 6) & 1;
            this.layer = (b0 >> 5) & 3;
            this.variableRateAudioIndicator = (b0 >> 3) & 1;
        };
        prototype.getVariableRateAudioIndicator = function() {
            return this.variableRateAudioIndicator;
        };
        prototype.getFreeFormatFlag = function() {
            return this.freeFormatFlag;
        };
        prototype.getId = function() {
            return this.id;
        };
        prototype.getLayer = function() {
            return this.layer;
        };
    }, {}, {});
    constructor.ISO639LanguageDescriptor = function() {
        MPSUtils.MPEGMediaDescriptor.call(this);
        this.languageCodes = IntArrayList.createIntArrayList();
    };
    constructor.ISO639LanguageDescriptor = stjs.extend(constructor.ISO639LanguageDescriptor, MPSUtils.MPEGMediaDescriptor, [], function(constructor, prototype) {
        prototype.languageCodes = null;
        prototype.parse = function(buf) {
            MPSUtils.MPEGMediaDescriptor.prototype.parse.call(this, buf);
             while (buf.remaining() >= 4){
                this.languageCodes.add(buf.getInt());
            }
        };
        prototype.getLanguageCodes = function() {
            return this.languageCodes;
        };
    }, {languageCodes: "IntArrayList"}, {});
    constructor.Mpeg4VideoDescriptor = function() {
        MPSUtils.MPEGMediaDescriptor.call(this);
    };
    constructor.Mpeg4VideoDescriptor = stjs.extend(constructor.Mpeg4VideoDescriptor, MPSUtils.MPEGMediaDescriptor, [], function(constructor, prototype) {
        prototype.profileLevel = 0;
        prototype.parse = function(buf) {
            MPSUtils.MPEGMediaDescriptor.prototype.parse.call(this, buf);
            this.profileLevel = buf.get() & 255;
        };
    }, {}, {});
    constructor.Mpeg4AudioDescriptor = function() {
        MPSUtils.MPEGMediaDescriptor.call(this);
    };
    constructor.Mpeg4AudioDescriptor = stjs.extend(constructor.Mpeg4AudioDescriptor, MPSUtils.MPEGMediaDescriptor, [], function(constructor, prototype) {
        prototype.profileLevel = 0;
        prototype.parse = function(buf) {
            MPSUtils.MPEGMediaDescriptor.prototype.parse.call(this, buf);
            this.profileLevel = buf.get() & 255;
        };
        prototype.getProfileLevel = function() {
            return this.profileLevel;
        };
    }, {}, {});
    constructor.AVCVideoDescriptor = function() {
        MPSUtils.MPEGMediaDescriptor.call(this);
    };
    constructor.AVCVideoDescriptor = stjs.extend(constructor.AVCVideoDescriptor, MPSUtils.MPEGMediaDescriptor, [], function(constructor, prototype) {
        prototype.profileIdc = 0;
        prototype.flags = 0;
        prototype.level = 0;
        prototype.parse = function(buf) {
            MPSUtils.MPEGMediaDescriptor.prototype.parse.call(this, buf);
            this.profileIdc = buf.get() & 255;
            this.flags = buf.get() & 255;
            this.level = buf.get() & 255;
        };
        prototype.getProfileIdc = function() {
            return this.profileIdc;
        };
        prototype.getFlags = function() {
            return this.flags;
        };
        prototype.getLevel = function() {
            return this.level;
        };
    }, {}, {});
    constructor.AACAudioDescriptor = function() {
        MPSUtils.MPEGMediaDescriptor.call(this);
    };
    constructor.AACAudioDescriptor = stjs.extend(constructor.AACAudioDescriptor, MPSUtils.MPEGMediaDescriptor, [], function(constructor, prototype) {
        prototype.profile = 0;
        prototype.channel = 0;
        prototype.flags = 0;
        prototype.parse = function(buf) {
            MPSUtils.MPEGMediaDescriptor.prototype.parse.call(this, buf);
            this.profile = buf.get() & 255;
            this.channel = buf.get() & 255;
            this.flags = buf.get() & 255;
        };
        prototype.getProfile = function() {
            return this.profile;
        };
        prototype.getChannel = function() {
            return this.channel;
        };
        prototype.getFlags = function() {
            return this.flags;
        };
    }, {}, {});
    constructor.DataStreamAlignmentDescriptor = function() {
        MPSUtils.MPEGMediaDescriptor.call(this);
    };
    constructor.DataStreamAlignmentDescriptor = stjs.extend(constructor.DataStreamAlignmentDescriptor, MPSUtils.MPEGMediaDescriptor, [], function(constructor, prototype) {
        prototype.alignmentType = 0;
        prototype.parse = function(buf) {
            MPSUtils.MPEGMediaDescriptor.prototype.parse.call(this, buf);
            this.alignmentType = buf.get() & 255;
        };
        prototype.getAlignmentType = function() {
            return this.alignmentType;
        };
    }, {}, {});
    constructor.RegistrationDescriptor = function() {
        MPSUtils.MPEGMediaDescriptor.call(this);
        this.additionalFormatIdentifiers = IntArrayList.createIntArrayList();
    };
    constructor.RegistrationDescriptor = stjs.extend(constructor.RegistrationDescriptor, MPSUtils.MPEGMediaDescriptor, [], function(constructor, prototype) {
        prototype.formatIdentifier = 0;
        prototype.additionalFormatIdentifiers = null;
        prototype.parse = function(buf) {
            MPSUtils.MPEGMediaDescriptor.prototype.parse.call(this, buf);
            this.formatIdentifier = buf.getInt();
             while (buf.hasRemaining()){
                this.additionalFormatIdentifiers.add(buf.get() & 255);
            }
        };
        prototype.getFormatIdentifier = function() {
            return this.formatIdentifier;
        };
        prototype.getAdditionalFormatIdentifiers = function() {
            return this.additionalFormatIdentifiers;
        };
    }, {additionalFormatIdentifiers: "IntArrayList"}, {});
    constructor.dMapping = Array(256);
    constructor.parseDescriptors = function(bb) {
        var result = new ArrayList();
         while (bb.remaining() >= 2){
            var dup = bb.duplicate();
            var tag = dup.get() & 255;
            var len = dup.get() & 255;
            var descriptorBuffer = NIOUtils.read(bb, len + 2);
            if (MPSUtils.dMapping[tag] != null) 
                try {
                    var descriptor = MPSUtils.dMapping[tag].newInstance();
                    descriptor.parse(descriptorBuffer);
                    result.add(descriptor);
                }catch (e) {
                     throw new RuntimeException(e);
                }
        }
        return result;
    };
}, {dMapping: "Array"}, {});
(function() {
    MPSUtils.dMapping[2] = MPSUtils.VideoStreamDescriptor;
    MPSUtils.dMapping[3] = MPSUtils.AudioStreamDescriptor;
    MPSUtils.dMapping[6] = MPSUtils.DataStreamAlignmentDescriptor;
    MPSUtils.dMapping[5] = MPSUtils.RegistrationDescriptor;
    MPSUtils.dMapping[10] = MPSUtils.ISO639LanguageDescriptor;
    MPSUtils.dMapping[27] = MPSUtils.Mpeg4VideoDescriptor;
    MPSUtils.dMapping[28] = MPSUtils.Mpeg4AudioDescriptor;
    MPSUtils.dMapping[40] = MPSUtils.AVCVideoDescriptor;
    MPSUtils.dMapping[43] = MPSUtils.AACAudioDescriptor;
})();
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var BER = function() {};
BER = stjs.extend(BER, null, [], function(constructor, prototype) {
    constructor.ASN_LONG_LEN = (128 << 24 >> 24);
    constructor.decodeLength = function(is) {
        var length = 0;
        var lengthbyte = NIOUtils.readByte(is) & 255;
        if ((lengthbyte & BER.ASN_LONG_LEN) > 0) {
            lengthbyte &= ~BER.ASN_LONG_LEN;
            if (lengthbyte == 0) 
                 throw new IOException("Indefinite lengths are not supported");
            if (lengthbyte > 8) 
                 throw new IOException("Data length > 4 bytes are not supported!");
            var bb = NIOUtils.readNByte(is, lengthbyte);
            for (var i = 0; i < lengthbyte; i++) 
                length = (length << 8) | (bb[i] & 255);
            if (length < 0) 
                 throw new IOException("mxflib does not support data lengths > 2^63");
        } else {
            length = lengthbyte & 255;
        }
        return length;
    };
    constructor.decodeLengthBuf = function(buffer) {
        var length = 0;
        var lengthbyte = buffer.get() & 255;
        if ((lengthbyte & BER.ASN_LONG_LEN) > 0) {
            lengthbyte &= ~BER.ASN_LONG_LEN;
            if (lengthbyte == 0) 
                 throw new RuntimeException("Indefinite lengths are not supported");
            if (lengthbyte > 8) 
                 throw new RuntimeException("Data length > 8 bytes are not supported!");
            for (var i = 0; i < lengthbyte; i++) 
                length = (length << 8) | (buffer.get() & 255);
            if (length < 0) 
                 throw new RuntimeException("mxflib does not support data lengths > 2^63");
        } else {
            length = lengthbyte & 255;
        }
        return length;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Y4MDecoder = function(_is) {
    this.is = _is;
    var buf = NIOUtils.fetchFromChannel(this.is, 2048);
    var header = StringUtils.splitC(Y4MDecoder.readLine(buf), ' ');
    if (!"YUV4MPEG2".equals(header[0])) {
        this.invalidFormat = "Not yuv4mpeg stream";
        return;
    }
    var chroma = Y4MDecoder.find(header, 'C');
    if (chroma != null && !chroma.startsWith("420")) {
        this.invalidFormat = "Only yuv420p is supported";
        return;
    }
    this.width = Integer.parseInt(Y4MDecoder.find(header, 'W'));
    this.height = Integer.parseInt(Y4MDecoder.find(header, 'H'));
    var fpsStr = Y4MDecoder.find(header, 'F');
    if (fpsStr != null) {
        var numden = StringUtils.splitC(fpsStr, ':');
        this.fps = new Rational(Integer.parseInt(numden[0]), Integer.parseInt(numden[1]));
    }
    this.is.setPosition(buf.position());
    this.bufSize = this.width * this.height;
    this.bufSize += stjs.trunc(this.bufSize / 2);
};
Y4MDecoder = stjs.extend(Y4MDecoder, null, [], function(constructor, prototype) {
    prototype.is = null;
    prototype.width = 0;
    prototype.height = 0;
    prototype.invalidFormat = null;
    prototype.fps = null;
    prototype.bufSize = 0;
    prototype.nextFrame8Bit = function(buffer) {
        if (this.invalidFormat != null) 
             throw new RuntimeException("Invalid input: " + this.invalidFormat);
        var buf = NIOUtils.fetchFromChannel(this.is, 2048);
        var frame = Y4MDecoder.readLine(buf);
        if (frame == null || !frame.startsWith("FRAME")) 
            return null;
        this.is.setPosition(this.is.position() - buf.remaining());
        var pix = NIOUtils.fetchFromChannel(this.is, this.bufSize);
        var create = Picture8Bit.createPicture8Bit(this.width, this.height, buffer, ColorSpace.YUV420);
        this.copy(pix, create.getPlaneData(0), this.width * this.height);
        this.copy(pix, create.getPlaneData(1), stjs.trunc(this.width * this.height / 4));
        this.copy(pix, create.getPlaneData(2), stjs.trunc(this.width * this.height / 4));
        return create;
    };
    prototype.copy = function(b, ii, size) {
        for (var i = 0; b.hasRemaining() && i < size; i++) {
            ii[i] = (((b.get() & 255) - 128) << 24 >> 24);
        }
    };
    constructor.find = function(header, c) {
        for (var i = 0; i < header.length; i++) {
            var string = header[i];
            if (string.charAt(0) == c) 
                return string.substring(1);
        }
        return null;
    };
    constructor.readLine = function(y4m) {
        var duplicate = y4m.duplicate();
         while (y4m.hasRemaining() && y4m.get() != '\n')
            ;
        if (y4m.hasRemaining()) 
            duplicate.setLimit(y4m.position() - 1);
        return Platform.stringFromBytes(NIOUtils.toArray(duplicate));
    };
    prototype.getWidth = function() {
        return this.width;
    };
    prototype.getHeight = function() {
        return this.height;
    };
    prototype.getFps = function() {
        return this.fps;
    };
    prototype.getSize = function() {
        return new Size(this.width, this.height);
    };
}, {is: "SeekableByteChannel", fps: "Rational"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Simple JSON serializer, introduced because jcodec can not use dependencies as
 *  they bring frastration on some platforms
 *  
 *  @author The JCodec project
 */
var ToJSON = function() {};
ToJSON = stjs.extend(ToJSON, null, [], function(constructor, prototype) {
    constructor.primitive = new HashSet();
    constructor.omitMethods = new HashSet();
    constructor.allFields = function(claz) {
        return ToJSON.allFieldsExcept(claz, []);
    };
    constructor.allFieldsExcept = function(claz, except) {
        var result = new ArrayList();
        for (var method in Platform.getDeclaredMethods(claz)) {
            if (!ToJSON.isGetter(method)) 
                continue;
            try {
                var name = ToJSON.toName(method);
                result.add(name);
            }catch (e) {}
        }
        return result;
    };
    /**
     *  Converts an object to JSON
     *  
     *  @param obj
     *  @return
     */
    constructor.toJSON = function(obj) {
        var builder = new StringBuilder();
        var stack = IntArrayList.createIntArrayList();
        ToJSON.toJSONSub(obj, stack, builder);
        return builder.toString();
    };
    /**
     *  Converts specified fields of an object to JSON
     *  
     *  Useful because it doesn't enclose the field list into JSON object
     *  brackets "{}" leaving flexibility to append any other information. Makes
     *  it possible to specify only selected fields.
     *  
     *  @param obj
     *  @param builder
     *  @param fields
     */
    constructor.fieldsToJSON = function(obj, builder, fields) {
        var methods = Platform.getMethods(obj.getClass());
        for (var field in fields) {
            var m = ToJSON.findGetter(methods, field);
            if (m == null) 
                continue;
            ToJSON.invoke(obj, IntArrayList.createIntArrayList(), builder, m, field);
        }
    };
    constructor.findGetter = function(methods, field) {
        var isGetter = ToJSON.getterName("is", field);
        var getGetter = ToJSON.getterName("get", field);
        for (var method in methods) {
            if ((isGetter.equals(method.getName()) || getGetter.equals(method.getName())) && ToJSON.isGetter(method)) 
                return method;
        }
        return null;
    };
    constructor.getterName = function(pref, field) {
        if (field == null) 
             throw new NullPointerException("Passed null string as field name");
        var ch = field.toCharArray();
        if (ch.length == 0) 
            return pref;
        if (ch.length > 1 && Character.isUpperCase(ch[1])) 
            ch[0] = Character.toLowerCase(ch[0]);
         else 
            ch[0] = Character.toUpperCase(ch[0]);
        return pref + new String(ch);
    };
    constructor.toJSONSub = function(obj, stack, builder) {
        if (obj == null) {
            builder.append("null");
            return;
        }
        var className = obj.getClass().getName();
        if (className.startsWith("java.lang") && !className.equals("java.lang.String")) {
            builder.append("null");
            return;
        }
        var id = System.identityHashCode(obj);
        if (stack.contains(id)) {
            builder.append("null");
            return;
        }
        stack.push(id);
        if (stjs.isInstanceOf(obj.constructor, ByteBuffer)) 
            obj = NIOUtils.toArray(obj);
        if (obj == null) {
            builder.append("null");
        } else if (stjs.isInstanceOf(obj.constructor, String)) {
            builder.append("\"");
            ToJSON.escape(obj, builder);
            builder.append("\"");
        } else if (stjs.isInstanceOf(obj.constructor, Map)) {
            var it = (obj).entrySet().iterator();
            builder.append("{");
             while (it.hasNext()){
                var e = it.next();
                builder.append("\"");
                builder.append(e.getKey());
                builder.append("\":");
                ToJSON.toJSONSub(e.getValue(), stack, builder);
                if (it.hasNext()) 
                    builder.append(",");
            }
            builder.append("}");
        } else if (stjs.isInstanceOf(obj.constructor, Iterable)) {
            var it = (obj).iterator();
            builder.append("[");
             while (it.hasNext()){
                ToJSON.toJSONSub(it.next(), stack, builder);
                if (it.hasNext()) 
                    builder.append(",");
            }
            builder.append("]");
        } else if (obj.getClass().isEnum()) {
            builder.append(String.valueOf(obj));
        } else {
            builder.append("{");
            for (var method in Platform.getMethods(obj.getClass())) {
                if (ToJSON.omitMethods.contains(method.getName()) || !ToJSON.isGetter(method)) 
                    continue;
                var name = ToJSON.toName(method);
                ToJSON.invoke(obj, stack, builder, method, name);
            }
            builder.append("}");
        }
        stack.pop();
    };
    constructor.invoke = function(obj, stack, builder, method, name) {
        try {
            var invoke = method.invoke(obj);
            builder.append('"');
            builder.append(name);
            builder.append("\":");
            if (invoke != null && ToJSON.primitive.contains(invoke.getClass())) 
                builder.append(invoke);
             else 
                ToJSON.toJSONSub(invoke, stack, builder);
            builder.append(",");
        }catch (e) {}
    };
    constructor.escape = function(invoke, sb) {
        var ch = invoke.toCharArray();
        for (var c in ch) {
            if (c < 32) 
                sb.append(String.format("\\%02x", stjs.trunc(c)));
             else 
                sb.append(c);
        }
    };
    constructor.toName = function(method) {
        if (!ToJSON.isGetter(method)) 
             throw new IllegalArgumentException("Not a getter");
        var name = method.getName().toCharArray();
        var ind = name[0] == 'g' ? 3 : 2;
        name[ind] = Character.toLowerCase(name[ind]);
        return new String(name, ind, name.length - ind);
    };
    constructor.isGetter = function(method) {
        if (!Modifier.isPublic(method.getModifiers())) 
            return false;
        if (!method.getName().startsWith("get") && !(method.getName().startsWith("is") && method.getReturnType() == Boolean.TYPE)) 
            return false;
        if (method.getParameterTypes().length != 0) 
            return false;
        return true;
    };
}, {primitive: {name: "Set", arguments: ["Class"]}, omitMethods: {name: "Set", arguments: [null]}}, {});
(function() {
    ToJSON.primitive.add(Boolean);
    ToJSON.primitive.add(Byte);
    ToJSON.primitive.add(Short);
    ToJSON.primitive.add(Integer);
    ToJSON.primitive.add(Long);
    ToJSON.primitive.add(Float);
    ToJSON.primitive.add(Double);
})();
(function() {
    ToJSON.omitMethods.add("getClass");
    ToJSON.omitMethods.add("get");
})();
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  FLV ( Flash Media Video ) muxer
 *  
 *  @author Stan Vitvitskyy
 *  
 */
var FLVWriter = function(out) {
    this.out = out;
    this.writeBuf = ByteBuffer.allocate(FLVWriter.WRITE_BUFFER_SIZE);
    FLVWriter.writeHeader(this.writeBuf);
};
FLVWriter = stjs.extend(FLVWriter, null, [], function(constructor, prototype) {
    constructor.WRITE_BUFFER_SIZE = 1048576;
    prototype.startOfLastPacket = 9;
    prototype.out = null;
    prototype.writeBuf = null;
    /**
     *  Add a packet to the underlying file
     *  
     *  @param pkt
     *  @throws IOException
     */
    prototype.addPacket = function(pkt) {
        if (!this.writePacket(this.writeBuf, pkt)) {
            this.writeBuf.flip();
            this.startOfLastPacket -= this.out.write(this.writeBuf);
            this.writeBuf.clear();
            if (!this.writePacket(this.writeBuf, pkt)) 
                 throw new RuntimeException("Unexpected");
        }
    };
    /**
     *  Finish muxing and write the remaining data
     *  
     *  @throws IOException
     */
    prototype.finish = function() {
        this.writeBuf.flip();
        this.out.write(this.writeBuf);
    };
    prototype.writePacket = function(writeBuf, pkt) {
        var pktType = pkt.getType() == FLVTag.Type.VIDEO ? 9 : (pkt.getType() == FLVTag.Type.SCRIPT ? 18 : 8);
        var dataLen = pkt.getData().remaining();
        if (writeBuf.remaining() < 15 + dataLen) 
            return false;
        writeBuf.putInt(writeBuf.position() - this.startOfLastPacket);
        this.startOfLastPacket = writeBuf.position();
        writeBuf.put((pktType << 24 >> 24));
        writeBuf.putShort((((dataLen >> 8)) << 16 >> 16));
        writeBuf.put(((dataLen & 255) << 24 >> 24));
        writeBuf.putShort(((((pkt.getPts() >> 8) & 65535)) << 16 >> 16));
        writeBuf.put(((pkt.getPts() & 255) << 24 >> 24));
        writeBuf.put((((pkt.getPts() >> 24) & 255) << 24 >> 24));
        writeBuf.putShort(((0) << 16 >> 16));
        writeBuf.put((0 << 24 >> 24));
        NIOUtils.write(writeBuf, pkt.getData().duplicate());
        return true;
    };
    constructor.writeHeader = function(writeBuf) {
        writeBuf.put(('F' << 24 >> 24));
        writeBuf.put(('L' << 24 >> 24));
        writeBuf.put(('V' << 24 >> 24));
        writeBuf.put((1 << 24 >> 24));
        writeBuf.put((5 << 24 >> 24));
        writeBuf.putInt(9);
    };
}, {out: "SeekableByteChannel", writeBuf: "ByteBuffer"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Edits PCM sample track placing chunks of PCM data in place creating and
 *  edit-less track
 *  
 *  @author The JCodec project
 *  
 */
var EditedPCMTrack = function(src) {
    this.src = src;
    this.edits = src.getEdits();
    this.buckets = Array(this.edits.length);
    for (var i = 0; i < this.edits.length; i++) 
        this.buckets[i] = new ArrayList();
    var pkt;
     while ((pkt = src.nextPacket()) != null){
        for (var e = 0; e < this.edits.length; e++) {
            var ed = this.edits[e];
            if (pkt.getPts() < ed.getIn() + ed.getDuration() && pkt.getPts() + pkt.getDuration() > ed.getIn()) {
                this.buckets[e].add(pkt);
            }
        }
    }
    var ase = src.getCodecMeta();
    this.frameSize = ase.getFrameSize();
    this.sampleRate = ase.getSampleRate();
};
EditedPCMTrack = stjs.extend(EditedPCMTrack, null, [VirtualTrack], function(constructor, prototype) {
    prototype.src = null;
    prototype.buckets = null;
    prototype.edits = null;
    prototype.curEdit = 0;
    prototype.curPkt = 0;
    prototype.frameNo = 0;
    prototype.pts = 0.0;
    prototype.frameSize = 0;
    prototype.sampleRate = 0.0;
    prototype.nextPacket = function() {
        if (this.curEdit >= this.edits.length) 
            return null;
        var pkt = this.buckets[this.curEdit].get(this.curPkt);
        var edt = this.edits[this.curEdit];
        var start = Math.max(pkt.getPts(), edt.getIn());
        var end = Math.min(pkt.getPts() + pkt.getDuration(), edt.getIn() + edt.getDuration());
        var duration = end - start;
        var lead = start - pkt.getPts();
        var ret = new EditedPCMTrack.EditedPCMPacket(pkt, (((Math.round(lead * this.sampleRate) * this.frameSize)) | 0), (((Math.round(duration * this.sampleRate) * this.frameSize)) | 0), this.pts, duration, this.frameNo);
        ++this.curPkt;
        if (this.curPkt >= this.buckets[this.curEdit].size()) {
            this.curEdit++;
            this.curPkt = 0;
        }
        this.frameNo++;
        this.pts += duration;
        return ret;
    };
    prototype.getCodecMeta = function() {
        return this.src.getCodecMeta();
    };
    prototype.getEdits = function() {
        return null;
    };
    prototype.close = function() {
        this.src.close();
    };
    constructor.EditedPCMPacket = function(src, inBytes, dataLen, pts, duration, frameNo) {
        this.src = src;
        this.inBytes = inBytes;
        this.dataLen = dataLen;
        this.pts = pts;
        this.duration = duration;
        this.frameNo = frameNo;
    };
    constructor.EditedPCMPacket = stjs.extend(constructor.EditedPCMPacket, null, [VirtualPacket], function(constructor, prototype) {
        prototype.src = null;
        prototype.inBytes = 0;
        prototype.dataLen = 0;
        prototype.pts = 0.0;
        prototype.duration = 0.0;
        prototype.frameNo = 0;
        prototype.getData = function() {
            var data = this.src.getData();
            NIOUtils.skip(data, this.inBytes);
            return NIOUtils.read(data, this.dataLen);
        };
        prototype.getDataLen = function() {
            return this.dataLen;
        };
        prototype.getPts = function() {
            return this.pts;
        };
        prototype.getDuration = function() {
            return this.duration;
        };
        prototype.isKeyframe = function() {
            return true;
        };
        prototype.getFrameNo = function() {
            return this.frameNo;
        };
    }, {src: "VirtualPacket", byPts: {name: "Comparator", arguments: ["Object"]}}, {});
    prototype.getPreferredTimescale = function() {
        return this.src.getPreferredTimescale();
    };
}, {src: "VirtualTrack", buckets: "Array", edits: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var RunLength = function() {
    this.counts = IntArrayList.createIntArrayList();
};
RunLength = stjs.extend(RunLength, null, [], function(constructor, prototype) {
    prototype.counts = null;
    prototype.estimateSize = function() {
        var counts = this.getCounts();
        var recCount = 0;
        for (var i = 0; i < counts.length; i++ , recCount++) {
            var count = counts[i];
             while (count >= 256){
                ++recCount;
                count -= 256;
            }
        }
        return recCount * this.recSize() + 4;
    };
    prototype.recSize = function() {};
    prototype.finish = function() {};
    prototype.getCounts = function() {
        this.finish();
        return this.counts.toArray();
    };
    constructor.Integer = function() {
        RunLength.call(this);
        this.lastValue = RunLength.Integer.MIN_VALUE;
        this.values = IntArrayList.createIntArrayList();
    };
    constructor.Integer = stjs.extend(constructor.Integer, RunLength, [], function(constructor, prototype) {
        constructor.MIN_VALUE = Integer.MIN_VALUE;
        prototype.lastValue = 0;
        prototype.count = 0;
        prototype.values = null;
        prototype.add = function(value) {
            if (this.lastValue == RunLength.Integer.MIN_VALUE || this.lastValue != value) {
                if (this.lastValue != RunLength.Integer.MIN_VALUE) {
                    this.values.add(this.lastValue);
                    this.counts.add(this.count);
                    this.count = 0;
                }
                this.lastValue = value;
            }
            ++this.count;
        };
        prototype.getValues = function() {
            this.finish();
            return this.values.toArray();
        };
        prototype.finish = function() {
            if (this.lastValue != RunLength.Integer.MIN_VALUE) {
                this.values.add(this.lastValue);
                this.counts.add(this.count);
                this.lastValue = RunLength.Integer.MIN_VALUE;
                this.count = 0;
            }
        };
        prototype.serialize = function(bb) {
            var dup = bb.duplicate();
            var counts = this.getCounts();
            var values = this.getValues();
            NIOUtils.skip(bb, 4);
            var recCount = 0;
            for (var i = 0; i < counts.length; i++ , recCount++) {
                var count = counts[i];
                 while (count >= 256){
                    bb.put((255 << 24 >> 24));
                    bb.putInt(values[i]);
                    ++recCount;
                    count -= 256;
                }
                bb.put(((count - 1) << 24 >> 24));
                bb.putInt(values[i]);
            }
            dup.putInt(recCount);
        };
        constructor.parse = function(bb) {
            var rl = new RunLength.Integer();
            var recCount = bb.getInt();
            for (var i = 0; i < recCount; i++) {
                var count = (bb.get() & 255) + 1;
                var value = bb.getInt();
                rl.counts.add(count);
                rl.values.add(value);
            }
            return rl;
        };
        prototype.recSize = function() {
            return 5;
        };
        prototype.flattern = function() {
            var counts = this.getCounts();
            var total = 0;
            for (var i = 0; i < counts.length; i++) {
                total += counts[i];
            }
            var values = this.getValues();
            var result = new Int32Array(total);
            for (var i = 0, ind = 0; i < counts.length; i++) {
                for (var j = 0; j < counts[i]; j++ , ind++) 
                    result[ind] = values[i];
            }
            return result;
        };
    }, {values: "IntArrayList", counts: "IntArrayList"}, {});
    constructor.Long = function() {
        RunLength.call(this);
        this.lastValue = RunLength.Long.MIN_VALUE;
        this.values = LongArrayList.createLongArrayList();
    };
    constructor.Long = stjs.extend(constructor.Long, RunLength, [], function(constructor, prototype) {
        constructor.MIN_VALUE = Long.MIN_VALUE;
        prototype.lastValue = 0;
        prototype.count = 0;
        prototype.values = null;
        prototype.add = function(value) {
            if (this.lastValue == RunLength.Long.MIN_VALUE || this.lastValue != value) {
                if (this.lastValue != RunLength.Long.MIN_VALUE) {
                    this.values.add(this.lastValue);
                    this.counts.add(this.count);
                    this.count = 0;
                }
                this.lastValue = value;
            }
            ++this.count;
        };
        prototype.getCounts = function() {
            this.finish();
            return this.counts.toArray();
        };
        prototype.getValues = function() {
            this.finish();
            return this.values.toArray();
        };
        prototype.finish = function() {
            if (this.lastValue != RunLength.Long.MIN_VALUE) {
                this.values.add(this.lastValue);
                this.counts.add(this.count);
                this.lastValue = RunLength.Long.MIN_VALUE;
                this.count = 0;
            }
        };
        prototype.serialize = function(bb) {
            var dup = bb.duplicate();
            var counts = this.getCounts();
            var values = this.getValues();
            NIOUtils.skip(bb, 4);
            var recCount = 0;
            for (var i = 0; i < counts.length; i++ , recCount++) {
                var count = counts[i];
                 while (count >= 256){
                    bb.put((255 << 24 >> 24));
                    bb.putLong(values[i]);
                    ++recCount;
                    count -= 256;
                }
                bb.put(((count - 1) << 24 >> 24));
                bb.putLong(values[i]);
            }
            dup.putInt(recCount);
        };
        constructor.parse = function(bb) {
            var rl = new RunLength.Long();
            var recCount = bb.getInt();
            for (var i = 0; i < recCount; i++) {
                var count = (bb.get() & 255) + 1;
                var value = bb.getLong();
                rl.counts.add(count);
                rl.values.add(value);
            }
            return rl;
        };
        prototype.recSize = function() {
            return 9;
        };
        prototype.flattern = function() {
            var counts = this.getCounts();
            var total = 0;
            for (var i = 0; i < counts.length; i++) {
                total += counts[i];
            }
            var values = this.getValues();
            var result = Array(total);
            for (var i = 0, ind = 0; i < counts.length; i++) {
                for (var j = 0; j < counts[i]; j++ , ind++) 
                    result[ind] = values[i];
            }
            return result;
        };
    }, {values: "LongArrayList", counts: "IntArrayList"}, {});
}, {counts: "IntArrayList"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var IOUtils = function() {};
IOUtils = stjs.extend(IOUtils, null, [], function(constructor, prototype) {
    constructor.DEFAULT_BUFFER_SIZE = 4096;
    constructor.closeQuietly = function(c) {
        if (c == null) 
            return;
        try {
            c.close();
        }catch (e) {}
    };
    constructor.toByteArray = function(input) {
        var output = new ByteArrayOutputStream();
        IOUtils.copy(input, output);
        return output.toByteArray();
    };
    constructor.copy = function(input, output) {
        var buffer = new Int8Array(IOUtils.DEFAULT_BUFFER_SIZE);
        var count = 0;
        var n = 0;
         while (-1 != (n = input.read(buffer))){
            output.write(buffer, 0, n);
            count += n;
        }
        return count;
    };
    constructor.copyDumb = function(input, output) {
        var count = 0;
        var n = 0;
         while (-1 != (n = input.read())){
            output.write(n);
            count++;
        }
        return count;
    };
    constructor.readFileToByteArray = function(file) {
        return NIOUtils.toArray(NIOUtils.fetchFromFile(file));
    };
    constructor.readToString = function(is) {
        return Platform.stringFromBytes(IOUtils.toByteArray(is));
    };
    constructor.writeStringToFile = function(file, str) {
        NIOUtils.writeTo(ByteBuffer.wrap(str.getBytes()), file);
    };
    constructor.forceMkdir = function(directory) {
        if (directory.exists()) {
            if (!directory.isDirectory()) {
                var message = "File " + directory + " exists and is not a directory. Unable to create directory.";
                 throw new IOException(message);
            }
        } else {
            if (!directory.mkdirs()) {
                if (!directory.isDirectory()) {
                    var message = "Unable to create directory " + directory;
                     throw new IOException(message);
                }
            }
        }
    };
    constructor.copyFile = function(src, dst) {
        var _in = null;
        var out = null;
        try {
            _in = NIOUtils.readableChannel(src);
            out = NIOUtils.writableChannel(dst);
            NIOUtils.copy(_in, out, Long.MAX_VALUE);
        } finally {
            NIOUtils.closeQuietly(_in);
            NIOUtils.closeQuietly(out);
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var IVFMuxer = function(ch, w, h, frameRate) {
    var ivf = ByteBuffer.allocate(32);
    ivf.order(ByteOrder.LITTLE_ENDIAN);
    ivf.put(('D' << 24 >> 24));
    ivf.put(('K' << 24 >> 24));
    ivf.put(('I' << 24 >> 24));
    ivf.put(('F' << 24 >> 24));
    ivf.putShort(((0) << 16 >> 16));
    ivf.putShort(((32) << 16 >> 16));
    ivf.putInt(808996950);
    ivf.putShort(((w) << 16 >> 16));
    ivf.putShort(((h) << 16 >> 16));
    ivf.putInt(frameRate);
    ivf.putInt(1);
    ivf.putInt(1);
    ivf.clear();
    ch.write(ivf);
    this.ch = ch;
};
IVFMuxer = stjs.extend(IVFMuxer, null, [], function(constructor, prototype) {
    prototype.ch = null;
    prototype.nFrames = 0;
    prototype.addFrame = function(pkt) {
        var fh = ByteBuffer.allocate(12);
        fh.order(ByteOrder.LITTLE_ENDIAN);
        var frame = pkt.getData();
        fh.putInt(frame.remaining());
        fh.putLong(this.nFrames);
        fh.clear();
        this.ch.write(fh);
        this.ch.write(frame);
        this.nFrames++;
    };
    prototype.close = function() {
        this.ch.setPosition(24);
        NIOUtils.writeIntLE(this.ch, this.nFrames);
    };
}, {ch: "SeekableByteChannel"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  This utility relocates PAT/PMT PSI packets from anywhere within a file to the
 *  beginning of the file so that the file is playable
 *  
 *  @author The JCodec project
 *  
 */
var HLSRelocatePMT = function() {};
HLSRelocatePMT = stjs.extend(HLSRelocatePMT, null, [], function(constructor, prototype) {
    constructor.TS_START_CODE = 71;
    constructor.CHUNK_SIZE_PKT = 1024;
    constructor.TS_PKT_SIZE = 188;
    constructor.main1 = function(args) {
        var cmd = MainUtils.parseArguments(args);
        if (cmd.args.length < 2) {
            MainUtils.printHelpNoFlags("file _in", "file out");
            return;
        }
        var _in = null;
        var out = null;
        try {
            _in = NIOUtils.readableChannel(new File(cmd.args[0]));
            out = NIOUtils.writableChannel(new File(cmd.args[1]));
            System.err.println("Processed: " + HLSRelocatePMT.replocatePMT(_in, out) + " packets.");
        } finally {
            NIOUtils.closeQuietly(_in);
            NIOUtils.closeQuietly(out);
        }
    };
    constructor.replocatePMT = function(_in, out) {
        var buf = ByteBuffer.allocate(HLSRelocatePMT.TS_PKT_SIZE * HLSRelocatePMT.CHUNK_SIZE_PKT);
        var pmtPids = new HashSet();
        var held = new ArrayList();
        var patPkt = null;
        var pmtPkt = null;
        var totalPkt = 0;
         while (_in.read(buf) != -1){
            buf.flip();
            buf.setLimit((stjs.trunc(buf.limit() / HLSRelocatePMT.TS_PKT_SIZE)) * HLSRelocatePMT.TS_PKT_SIZE);
             while (buf.hasRemaining()){
                var pkt = NIOUtils.read(buf, HLSRelocatePMT.TS_PKT_SIZE);
                var pktRead = pkt.duplicate();
                Assert.assertEquals(HLSRelocatePMT.TS_START_CODE, pktRead.get() & 255);
                ++totalPkt;
                var guidFlags = ((pktRead.get() & 255) << 8) | (pktRead.get() & 255);
                var guid = stjs.trunc(guidFlags) & 8191;
                var payloadStart = (guidFlags >> 14) & 1;
                var b0 = pktRead.get() & 255;
                var counter = b0 & 15;
                if ((b0 & 32) != 0) {
                    NIOUtils.skip(pktRead, (pktRead.get() & 255));
                }
                if (guid == 0 || pmtPids.contains(guid)) {
                    if (payloadStart == 1) {
                        NIOUtils.skip(pktRead, (pktRead.get() & 255));
                    }
                    if (guid == 0) {
                        patPkt = pkt;
                        var pat = PATSection.parsePAT(pktRead);
                        var values = pat.getPrograms().values();
                        for (var i = 0; i < values.length; i++) {
                            var pmtPid = values[i];
                            pmtPids.add(pmtPid);
                        }
                    } else if (pmtPids.contains(guid)) {
                        pmtPkt = pkt;
                        out.write(patPkt);
                        out.write(pmtPkt);
                        for (var iterator$heldPkt = held.iterator(); iterator$heldPkt.hasNext(); ) {
                            var heldPkt = iterator$heldPkt.next();
                            out.write(heldPkt);
                        }
                        held.clear();
                    }
                } else {
                    if (pmtPkt == null) 
                        held.add(pkt);
                     else 
                        out.write(pkt);
                }
            }
            buf.clear();
        }
        return totalPkt;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  PCM DVD decoder
 *  
 *  @author The JCodec project
 *  
 */
var PCMDVDDecoder = function() {};
PCMDVDDecoder = stjs.extend(PCMDVDDecoder, null, [AudioDecoder], function(constructor, prototype) {
    constructor.lpcm_freq_tab = new Int32Array([48000, 96000, 44100, 32000]);
    prototype.decodeFrame = function(_frame, _dst) {
        var dst = _dst.duplicate();
        var frame = _frame.duplicate();
        frame.order(ByteOrder.BIG_ENDIAN);
        dst.order(ByteOrder.LITTLE_ENDIAN);
        var dvdaudioSubstreamType = frame.get() & 255;
        NIOUtils.skip(frame, 3);
        if ((dvdaudioSubstreamType & 224) == 160) {} else if ((dvdaudioSubstreamType & 224) == 128) {
            if ((dvdaudioSubstreamType & 248) == 136) 
                 throw new RuntimeException("CODEC_ID_DTS");
             else 
                 throw new RuntimeException("CODEC_ID_AC3");
        } else 
             throw new RuntimeException("MPEG DVD unknown coded");
        var b0 = frame.get() & 255;
        var b1 = frame.get() & 255;
        var b2 = frame.get() & 255;
        var freq = (b1 >> 4) & 3;
        var sampleRate = PCMDVDDecoder.lpcm_freq_tab[freq];
        var channelCount = 1 + (b1 & 7);
        var sampleSizeInBits = 16 + ((b1 >> 6) & 3) * 4;
        var nFrames = stjs.trunc(frame.remaining() / (channelCount * (sampleSizeInBits >> 3)));
        switch (sampleSizeInBits) {
            case 20:
                for (var n = 0; n < (nFrames >> 1); n++) {
                    for (var c = 0; c < channelCount; c++) {
                        var s0 = frame.getShort();
                        dst.putShort(s0);
                        var s1 = frame.getShort();
                        dst.putShort(s1);
                    }
                    NIOUtils.skip(frame, channelCount);
                }
                break;
            case 24:
                for (var n = 0; n < (nFrames >> 1); n++) {
                    for (var c = 0; c < channelCount; c++) {
                        var s0 = frame.getShort();
                        dst.putShort(s0);
                        var s1 = frame.getShort();
                        dst.putShort(s1);
                    }
                    NIOUtils.skip(frame, channelCount << 1);
                }
                break;
        }
        dst.flip();
        return new AudioBuffer(dst, new AudioFormat(sampleRate, 16, channelCount, true, false), nFrames);
    };
}, {lpcm_freq_tab: "Int32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var NALUnitWriter = function(to) {
    this.to = to;
};
NALUnitWriter = stjs.extend(NALUnitWriter, null, [], function(constructor, prototype) {
    prototype.to = null;
    constructor._MARKER = ByteBuffer.allocate(4);
    prototype.writeUnit = function(nal, data) {
        var emprev = ByteBuffer.allocate(data.remaining() + 1024);
        NIOUtils.write(emprev, NALUnitWriter._MARKER);
        nal.write(emprev);
        this.emprev(emprev, data);
        emprev.flip();
        this.to.write(emprev);
    };
    prototype.emprev = function(emprev, data) {
        var dd = data.duplicate();
        var prev1 = 1, prev2 = 1;
         while (dd.hasRemaining()){
            var b = dd.get();
            if (prev1 == 0 && prev2 == 0 && ((b & 3) == b)) {
                prev2 = prev1;
                prev1 = 3;
                emprev.put((3 << 24 >> 24));
            }
            prev2 = prev1;
            prev1 = b;
            emprev.put(stjs.trunc(b));
        }
    };
}, {to: "WritableByteChannel", _MARKER: "ByteBuffer"}, {});
(function() {
    NALUnitWriter._MARKER.putInt(1);
    NALUnitWriter._MARKER.flip();
})();
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var IndexEntries = function(displayOff, keyFrameOff, flags, fileOff) {
    this.displayOff = displayOff;
    this.keyFrameOff = keyFrameOff;
    this.flags = flags;
    this.fileOff = fileOff;
};
IndexEntries = stjs.extend(IndexEntries, null, [], function(constructor, prototype) {
    prototype.displayOff = null;
    prototype.flags = null;
    prototype.fileOff = null;
    prototype.keyFrameOff = null;
    prototype.getDisplayOff = function() {
        return this.displayOff;
    };
    prototype.getFlags = function() {
        return this.flags;
    };
    prototype.getFileOff = function() {
        return this.fileOff;
    };
    prototype.getKeyFrameOff = function() {
        return this.keyFrameOff;
    };
    constructor.read = function(bb) {
        bb.order(ByteOrder.BIG_ENDIAN);
        var n = bb.getInt();
        var len = bb.getInt();
        var temporalOff = new Int32Array(n);
        var flags = new Int8Array(n);
        var fileOff = Array(n);
        var keyFrameOff = new Int8Array(n);
        for (var i = 0; i < n; i++) {
            temporalOff[i] = i + bb.get();
            keyFrameOff[i] = bb.get();
            flags[i] = bb.get();
            fileOff[i] = bb.getLong();
            NIOUtils.skip(bb, len - 11);
        }
        var displayOff = new Int8Array(n);
        for (var i = 0; i < n; i++) {
            for (var j = 0; j < n; j++) {
                if (temporalOff[j] == i) {
                    displayOff[i] = ((j - i) << 24 >> 24);
                    break;
                }
            }
        }
        return new IndexEntries(displayOff, keyFrameOff, flags, fileOff);
    };
}, {displayOff: "Int8Array", flags: "Int8Array", fileOff: "Array", keyFrameOff: "Int8Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MXFMetadata = function(ul) {
    this.ul = ul;
};
MXFMetadata = stjs.extend(MXFMetadata, null, [], function(constructor, prototype) {
    prototype.ul = null;
    prototype.uid = null;
    prototype.readBuf = function(bb) {};
    /**
     *  Utility method to read a batch of ULS
     *  
     *  @param _bb
     *  @return
     */
    constructor.readULBatch = function(_bb) {
        var count = _bb.getInt();
        _bb.getInt();
        var result = Array(count);
        for (var i = 0; i < count; i++) {
            result[i] = UL.read(_bb);
        }
        return result;
    };
    /**
     *  Utility method to read a batch of int32
     *  
     *  @param _bb
     *  @return
     */
    constructor.readInt32Batch = function(_bb) {
        var count = _bb.getInt();
        _bb.getInt();
        var result = new Int32Array(count);
        for (var i = 0; i < count; i++) {
            result[i] = _bb.getInt();
        }
        return result;
    };
    constructor.readDate = function(_bb) {
        var calendar = Calendar.getInstance();
        calendar.set(Calendar.YEAR, _bb.getShort());
        calendar.set(Calendar.MONTH, _bb.get());
        calendar.set(Calendar.DAY_OF_MONTH, _bb.get());
        calendar.set(Calendar.HOUR, _bb.get());
        calendar.set(Calendar.MINUTE, _bb.get());
        calendar.set(Calendar.SECOND, _bb.get());
        calendar.set(Calendar.MILLISECOND, (_bb.get() & 255) << 2);
        return calendar.getTime();
    };
    prototype.readUtf16String = function(_bb) {
        return Platform.stringFromCharset(NIOUtils.toArray(_bb), Charset.forName("utf-16"));
    };
    prototype.getUl = function() {
        return this.ul;
    };
    prototype.getUid = function() {
        return this.uid;
    };
}, {ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  PCM track that outputs packets of exactly set size in PCM frames
 *  
 *  @author The JCodec project
 *  
 */
var PCMFlatternTrack = function(src, samplesPerPkt) {
    this.pktBuffer = new ArrayList();
    this.framesPerPkt = samplesPerPkt;
    this.src = src;
    this.se = src.getCodecMeta();
    this.dataLen = this.se.getFrameSize() * this.framesPerPkt;
    this.packetDur = this.framesPerPkt / this.se.getSampleRate();
};
PCMFlatternTrack = stjs.extend(PCMFlatternTrack, null, [VirtualTrack], function(constructor, prototype) {
    constructor.EMPTY = Array(0);
    prototype.framesPerPkt = 0;
    prototype.src = null;
    prototype.se = null;
    prototype.dataLen = 0;
    prototype.packetDur = 0.0;
    prototype.leftover = null;
    prototype.leftoverOffset = 0;
    prototype.frameNo = 0;
    prototype.pktBuffer = null;
    prototype.nextPacket = function() {
        this.pktBuffer.clear();
        var pkt = this.leftover == null ? this.src.nextPacket() : this.leftover;
        if (pkt == null) 
            return null;
        var rem = this.dataLen + this.leftoverOffset;
        do {
            this.pktBuffer.add(pkt);
            rem -= pkt.getDataLen();
            if (rem > 0) 
                pkt = this.src.nextPacket();
        } while (rem > 0 && pkt != null);
        var result = new PCMFlatternTrack.FlatternPacket(this, this.frameNo, this.pktBuffer.toArray(PCMFlatternTrack.EMPTY), this.leftoverOffset, this.dataLen - Math.max(rem, 0));
        this.frameNo += this.framesPerPkt;
        if (rem < 0) {
            this.leftover = this.pktBuffer.get(this.pktBuffer.size() - 1);
            this.leftoverOffset = this.leftover.getDataLen() + rem;
        } else {
            this.leftover = null;
            this.leftoverOffset = 0;
        }
        return result;
    };
    prototype.getCodecMeta = function() {
        return this.se;
    };
    prototype.close = function() {
        this.src.close();
    };
    constructor.FlatternPacket = function(track, frameNo, pN, lead, dataLen) {
        this.track = track;
        this.frameNo = frameNo;
        this.leading = lead;
        this.pN = pN;
        this.dataLen = dataLen;
    };
    constructor.FlatternPacket = stjs.extend(constructor.FlatternPacket, null, [VirtualPacket], function(constructor, prototype) {
        prototype.frameNo = 0;
        prototype.leading = 0;
        prototype.pN = null;
        prototype.dataLen = 0;
        prototype.track = null;
        prototype.getData = function() {
            var result = ByteBuffer.allocate(this.dataLen);
            var d0 = this.pN[0].getData();
            NIOUtils.skip(d0, this.leading);
            NIOUtils.write(result, d0);
            for (var i = 1; i < this.pN.length && result.hasRemaining(); i++) {
                var dN = this.pN[i].getData();
                var toWrite = Math.min(dN.remaining(), result.remaining());
                NIOUtils.writeL(result, dN, toWrite);
            }
            result.flip();
            return result;
        };
        prototype.getDataLen = function() {
            return this.dataLen;
        };
        prototype.getPts = function() {
            return (this.frameNo * this.track.framesPerPkt) / this.track.se.getSampleRate();
        };
        prototype.getDuration = function() {
            return this.track.packetDur;
        };
        prototype.isKeyframe = function() {
            return true;
        };
        prototype.getFrameNo = function() {
            return this.frameNo;
        };
    }, {pN: "Array", track: "PCMFlatternTrack", byPts: {name: "Comparator", arguments: ["Object"]}}, {});
    prototype.getEdits = function() {
        return this.src.getEdits();
    };
    prototype.getPreferredTimescale = function() {
        return this.src.getPreferredTimescale();
    };
}, {EMPTY: "Array", src: "VirtualTrack", se: "AudioCodecMeta", leftover: "VirtualPacket", pktBuffer: {name: "List", arguments: ["VirtualPacket"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A pool of open file references used to read data
 *  
 *  @author The JCodec project
 *  
 */
var FilePool = function(file, max) {
    this.file = file;
    this.max = max;
    this.channels = new LinkedBlockingQueue();
    this.allChannels = Collections.synchronizedList(new ArrayList());
};
FilePool = stjs.extend(FilePool, null, [ByteChannelPool], function(constructor, prototype) {
    prototype.channels = null;
    prototype.allChannels = null;
    prototype.file = null;
    prototype.max = 0;
    prototype.getChannel = function() {
        var channel = this.channels.poll();
        if (channel == null) {
            if (this.allChannels.size() < this.max) {
                channel = this.newChannel(this.file);
                this.allChannels.add(channel);
            } else {
                 while (true){
                    try {
                        channel = this.channels.take();
                        break;
                    }catch (e) {}
                }
            }
        }
        return new FilePool.PoolChannel(this, channel);
    };
    prototype.newChannel = function(file) {
        return NIOUtils.readableChannel(file);
    };
    constructor.PoolChannel = function(pool, src) {
        SeekableByteChannelWrapper.call(this, src);
        this.pool = pool;
        src.setPosition(0);
    };
    constructor.PoolChannel = stjs.extend(constructor.PoolChannel, SeekableByteChannelWrapper, [], function(constructor, prototype) {
        prototype.pool = null;
        prototype.isOpen = function() {
            return this.src != null;
        };
        prototype.close = function() {
            var ret = this.src;
            this.src = null;
             while (true){
                try {
                    this.pool.channels.put(ret);
                    break;
                }catch (e) {}
            }
        };
    }, {pool: "FilePool", src: "SeekableByteChannel"}, {});
    prototype.close = function() {
         while (!this.allChannels.isEmpty()){
            var channel = this.allChannels.remove(0);
            if (channel != null) {
                try {
                    channel.close();
                }catch (e) {}
            }
        }
    };
}, {channels: {name: "BlockingQueue", arguments: ["SeekableByteChannel"]}, allChannels: {name: "List", arguments: ["SeekableByteChannel"]}, file: "File"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed under FreeBSD License
 *  
 *  EBML IO implementation
 *  
 *  @author The JCodec project
 *  
 */
var EbmlUint = function(id) {
    EbmlBin.call(this, id);
};
EbmlUint = stjs.extend(EbmlUint, EbmlBin, [], function(constructor, prototype) {
    constructor.createEbmlUint = function(id, value) {
        var e = new EbmlUint(id);
        e.setUint(value);
        return e;
    };
    prototype.setUint = function(value) {
        this.data = ByteBuffer.wrap(EbmlUint.longToBytes(value));
        this.dataLen = this.data.limit();
    };
    prototype.getUint = function() {
        var l = 0;
        var tmp = 0;
        for (var i = 0; i < this.data.limit(); i++) {
            tmp = (stjs.trunc(this.data.getAt(this.data.limit() - 1 - i))) << 56;
            tmp >>>= (56 - (i * 8));
            l |= tmp;
        }
        return l;
    };
    constructor.longToBytes = function(value) {
        var b = new Int8Array(EbmlUint.calculatePayloadSize(value));
        for (var i = b.length - 1; i >= 0; i--) {
            b[i] = ((value >>> (8 * (b.length - i - 1))) << 24 >> 24);
        }
        return b;
    };
    constructor.calculatePayloadSize = function(value) {
        if (value == 0) 
            return 1;
        var mask = -72057594037927936;
        var i = 0;
         while ((value & (mask >>> 8 * i)) == 0 && i < 8)
            i++;
        return 8 - i;
    };
}, {data: "ByteBuffer", parent: "EbmlMaster", type: "MKVType", id: "Int8Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed under FreeBSD License
 *  
 *  EBML IO implementation
 *  
 *  @author The JCodec project
 *  
 */
var EbmlString = function(id) {
    EbmlBin.call(this, id);
};
EbmlString = stjs.extend(EbmlString, EbmlBin, [], function(constructor, prototype) {
    prototype.charset = "UTF-8";
    constructor.createEbmlString = function(id, value) {
        var e = new EbmlString(id);
        e.setString(value);
        return e;
    };
    prototype.getString = function() {
        try {
            return new String(this.data.array(), this.charset);
        }catch (ex) {
            ex.printStackTrace();
            return "";
        }
    };
    prototype.setString = function(value) {
        try {
            this.data = ByteBuffer.wrap(value.getBytes(this.charset));
        }catch (ex) {
            ex.printStackTrace();
        }
    };
}, {data: "ByteBuffer", parent: "EbmlMaster", type: "MKVType", id: "Int8Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed under FreeBSD License
 *  
 *  EBML IO implementation
 *  
 *  @author The JCodec project
 *  
 */
var EbmlUlong = function(id) {
    EbmlBin.call(this, id);
    this.data = ByteBuffer.allocate(8);
};
EbmlUlong = stjs.extend(EbmlUlong, EbmlBin, [], function(constructor, prototype) {
    constructor.createEbmlUlong = function(id, value) {
        var e = new EbmlUlong(id);
        e.setUlong(value);
        return e;
    };
    prototype.setUlong = function(value) {
        this.data.putLong(value);
        this.data.flip();
    };
    prototype.getUlong = function() {
        return this.data.duplicate().getLong();
    };
}, {data: "ByteBuffer", parent: "EbmlMaster", type: "MKVType", id: "Int8Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed under FreeBSD License
 *  
 *  EBML IO implementation
 *  
 *  @author The JCodec project
 *  
 */
var EbmlSint = function(id) {
    EbmlBin.call(this, id);
};
EbmlSint = stjs.extend(EbmlSint, EbmlBin, [], function(constructor, prototype) {
    prototype.setLong = function(value) {
        this.data = ByteBuffer.wrap(EbmlSint.convertToBytes(value));
    };
    prototype.getLong = function() {
        if ((this.data.limit() - this.data.position()) == 8) 
            return this.data.duplicate().getLong();
        var b = this.data.array();
        var l = 0;
        for (var i = b.length - 1; i >= 0; i--) 
            l |= (b[i] & 255) << (8 * (b.length - 1 - i));
        return l;
    };
    constructor.ebmlSignedLength = function(val) {
        if (val <= 64 && val >= (-63)) {
            return 1;
        } else if (val <= 8192 && val >= (-8191)) {
            return 2;
        } else if (val <= 1048576 && val >= (-1048575)) {
            return 3;
        } else if (val <= 134217728 && val >= (-134217727)) {
            return 4;
        } else if (val <= 17179869184 && val >= -17179869183) {
            return 5;
        } else if (val <= 2199023255552 && val >= -2199023255551) {
            return 6;
        } else if (val <= 281474976710656 && val >= -281474976710655) {
            return 7;
        } else {
            return 8;
        }
    };
    constructor.signedComplement = [0, 63, 8191, 1048575, 134217727, 17179869183, 2199023255551, 281474976710655, 36028797018963967];
    constructor.convertToBytes = function(val) {
        var num = EbmlSint.ebmlSignedLength(val);
        val += EbmlSint.signedComplement[num];
        return EbmlUtil.ebmlEncodeLen(val, num);
    };
}, {signedComplement: "Array", data: "ByteBuffer", parent: "EbmlMaster", type: "MKVType", id: "Int8Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed under FreeBSD License
 *  
 *  EBML IO implementation
 *  
 *  @author The JCodec project
 *  
 */
var EbmlFloat = function(id) {
    EbmlBin.call(this, id);
};
EbmlFloat = stjs.extend(EbmlFloat, EbmlBin, [], function(constructor, prototype) {
    prototype.setDouble = function(value) {
        if (value < Float.MAX_VALUE) {
            var bb = ByteBuffer.allocate(4);
            bb.putFloat(value);
            bb.flip();
            this.data = bb;
        } else if (value < Double.MAX_VALUE) {
            var bb = ByteBuffer.allocate(8);
            bb.putDouble(value);
            bb.flip();
            this.data = bb;
        }
    };
    prototype.getDouble = function() {
        if (this.data.limit() == 4) 
            return this.data.duplicate().getFloat();
        return this.data.duplicate().getDouble();
    };
}, {data: "ByteBuffer", parent: "EbmlMaster", type: "MKVType", id: "Int8Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  EBML IO implementation
 *  
 *  @author The JCodec project
 *  
 */
var MkvSegment = function(id) {
    EbmlMaster.call(this, id);
};
MkvSegment = stjs.extend(MkvSegment, EbmlMaster, [], function(constructor, prototype) {
    prototype.headerSize = 0;
    constructor.SEGMENT_ID = new Int8Array([24, 83, (128 << 24 >> 24), 103]);
    constructor.createMkvSegment = function() {
        return new MkvSegment(MkvSegment.SEGMENT_ID);
    };
    prototype.getHeader = function() {
        var headerSize = this.getHeaderSize();
        if (headerSize > Integer.MAX_VALUE) 
            System.out.println("MkvSegment.getHeader: id.length " + this.id.length + "  Element.getEbmlSize(" + this.dataLen + "): " + EbmlUtil.ebmlLength(this.dataLen) + " size: " + this.dataLen);
        var bb = ByteBuffer.allocate(((headerSize) | 0));
        bb.putArr(this.id);
        bb.putArr(EbmlUtil.ebmlEncode(this.getDataLen()));
        if (this.children != null && !this.children.isEmpty()) {
            for (var iterator$e = this.children.iterator(); iterator$e.hasNext(); ) {
                var e = iterator$e.next();
                if (Platform.arrayEqualsByte(EbmlMaster.CLUSTER_ID, e.type.id)) 
                    continue;
                bb.putBuf(e.getData());
            }
        }
        bb.flip();
        return bb;
    };
    prototype.getHeaderSize = function() {
        var returnValue = this.id.length;
        returnValue += EbmlUtil.ebmlLength(this.getDataLen());
        if (this.children != null && !this.children.isEmpty()) {
            for (var iterator$e = this.children.iterator(); iterator$e.hasNext(); ) {
                var e = iterator$e.next();
                if (Platform.arrayEqualsByte(EbmlMaster.CLUSTER_ID, e.type.id)) 
                    continue;
                returnValue += e.size();
            }
        }
        return returnValue;
    };
}, {SEGMENT_ID: "Int8Array", children: {name: "ArrayList", arguments: ["EbmlBase"]}, CLUSTER_ID: "Int8Array", parent: "EbmlMaster", type: "MKVType", id: "Int8Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  JCodec has to be dependancy free, so it can run both on Java SE and Android
 *  hence defining here our small logger that can be plugged into the logging
 *  framework of choice on the target platform
 *  
 *  @author The JCodec project
 */
stjs.ns("jcodec");
jcodec.Logger = function() {};
jcodec.Logger = stjs.extend(jcodec.Logger, null, [], function(constructor, prototype) {
    constructor.stageSinks = new LinkedList();
    constructor.sinks = null;
    constructor.debug = function(message) {
        jcodec.Logger.message(LogLevel.DEBUG, message);
    };
    constructor.info = function(message) {
        jcodec.Logger.message(LogLevel.INFO, message);
    };
    constructor.warn = function(message) {
        jcodec.Logger.message(LogLevel.WARN, message);
    };
    constructor.error = function(message) {
        jcodec.Logger.message(LogLevel.ERROR, message);
    };
    constructor.message = function(level, message) {
        if (jcodec.Logger.sinks == null) {
            {
                if (jcodec.Logger.sinks == null) {
                    jcodec.Logger.sinks = jcodec.Logger.stageSinks;
                    jcodec.Logger.stageSinks = null;
                    if (jcodec.Logger.sinks.isEmpty()) 
                        jcodec.Logger.sinks.add(OutLogSink.createOutLogSink());
                }
            }}
        var tr = Thread.currentThread().getStackTrace()[3];
        var msg = new Message(level, tr.getFileName(), tr.getClassName(), tr.getMethodName(), tr.getLineNumber(), message);
        for (var iterator$logSink = jcodec.Logger.sinks.iterator(); iterator$logSink.hasNext(); ) {
            var logSink = iterator$logSink.next();
            logSink.postMessage(msg);
        }
    };
    constructor.addSink = function(sink) {
        if (jcodec.Logger.stageSinks == null) 
             throw new IllegalStateException("Logger already started");
        jcodec.Logger.stageSinks.add(sink);
    };
}, {stageSinks: {name: "List", arguments: ["LogSink"]}, sinks: {name: "List", arguments: ["LogSink"]}}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  @author in-somnia
 */
var GainControl = function(frameLen) {
    this.frameLen = frameLen;
    this.lbLong = stjs.trunc(frameLen / GCConstants.BANDS);
    this.lbShort = stjs.trunc(this.lbLong / 8);
    this.imdct = new IMDCT(frameLen);
    this.ipqf = new IPQF();
    this.levelPrev = Array(0);
    this.locationPrev = Array(0);
    this.buffer1 = new Float32Array(stjs.trunc(frameLen / 2));
    this.buffer2 = Array.apply(null, Array(GCConstants.BANDS)).map(function() {
        return new Float32Array(this.lbLong);
    });
    this._function = new Float32Array(this.lbLong * 2);
    this.overlap = Array.apply(null, Array(GCConstants.BANDS)).map(function() {
        return new Float32Array(this.lbLong * 2);
    });
};
GainControl = stjs.extend(GainControl, null, [GCConstants], function(constructor, prototype) {
    prototype.frameLen = 0;
    prototype.lbLong = 0;
    prototype.lbShort = 0;
    prototype.imdct = null;
    prototype.ipqf = null;
    prototype.buffer1 = null;
    prototype._function = null;
    prototype.buffer2 = null;
    prototype.overlap = null;
    prototype.maxBand = 0;
    prototype.level = null;
    prototype.levelPrev = null;
    prototype.location = null;
    prototype.locationPrev = null;
    prototype.decode = function(_in, winSeq) {
        this.maxBand = _in.readBits(2) + 1;
        var wdLen, locBits, locBits2 = 0;
        switch (winSeq) {
            case ICSInfo.WindowSequence.ONLY_LONG_SEQUENCE:
                wdLen = 1;
                locBits = 5;
                locBits2 = 5;
                break;
            case ICSInfo.WindowSequence.EIGHT_SHORT_SEQUENCE:
                wdLen = 8;
                locBits = 2;
                locBits2 = 2;
                break;
            case ICSInfo.WindowSequence.LONG_START_SEQUENCE:
                wdLen = 2;
                locBits = 4;
                locBits2 = 2;
                break;
            case ICSInfo.WindowSequence.LONG_STOP_SEQUENCE:
                wdLen = 2;
                locBits = 4;
                locBits2 = 5;
                break;
            default:
                return;
        }
        this.level = Array.apply(null, Array(this.maxBand)).map(function() {
            return Array(wdLen);
        });
        this.location = Array.apply(null, Array(this.maxBand)).map(function() {
            return Array(wdLen);
        });
        var wd, k, len, bits;
        for (var bd = 1; bd < this.maxBand; bd++) {
            for (wd = 0; wd < wdLen; wd++) {
                len = _in.readBits(3);
                this.level[bd][wd] = new Int32Array(len);
                this.location[bd][wd] = new Int32Array(len);
                for (k = 0; k < len; k++) {
                    this.level[bd][wd][k] = _in.readBits(4);
                    bits = (wd == 0) ? locBits : locBits2;
                    this.location[bd][wd][k] = _in.readBits(bits);
                }
            }
        }
    };
    prototype.process = function(data, winShape, winShapePrev, winSeq) {
        this.imdct.process(data, this.buffer1, winShape, winShapePrev, winSeq);
        for (var i = 0; i < GCConstants.BANDS; i++) {
            this.compensate(this.buffer1, this.buffer2, winSeq, i);
        }
        this.ipqf.process(this.buffer2, this.frameLen, this.maxBand, data);
    };
    /**
     *  gain compensation and overlap-add:
     *  - the gain control function is calculated
     *  - the gain control function applies to IMDCT output samples as a another IMDCT window
     *  - the reconstructed time domain signal produces by overlap-add
     */
    prototype.compensate = function(_in, out, winSeq, band) {
        var j;
        if (winSeq.equals(ICSInfo.WindowSequence.EIGHT_SHORT_SEQUENCE)) {
            var a, b;
            for (var k = 0; k < 8; k++) {
                this.calculateFunctionData(this.lbShort * 2, band, winSeq, k);
                for (j = 0; j < this.lbShort * 2; j++) {
                    a = band * this.lbLong * 2 + k * this.lbShort * 2 + j;
                    _in[a] *= this._function[j];
                }
                for (j = 0; j < this.lbShort; j++) {
                    a = j + stjs.trunc(this.lbLong * 7 / 16) + this.lbShort * k;
                    b = band * this.lbLong * 2 + k * this.lbShort * 2 + j;
                    this.overlap[band][a] += _in[b];
                }
                for (j = 0; j < this.lbShort; j++) {
                    a = j + stjs.trunc(this.lbLong * 7 / 16) + this.lbShort * (k + 1);
                    b = band * this.lbLong * 2 + k * this.lbShort * 2 + this.lbShort + j;
                    this.overlap[band][a] = _in[b];
                }
                this.locationPrev[band][0] = Platform.copyOfInt(this.location[band][k], this.location[band][k].length);
                this.levelPrev[band][0] = Platform.copyOfInt(this.level[band][k], this.level[band][k].length);
            }
            System.arraycopy(this.overlap[band], 0, out[band], 0, this.lbLong);
            System.arraycopy(this.overlap[band], this.lbLong, this.overlap[band], 0, this.lbLong);
        } else {
            this.calculateFunctionData(this.lbLong * 2, band, winSeq, 0);
            for (j = 0; j < this.lbLong * 2; j++) {
                _in[band * this.lbLong * 2 + j] *= this._function[j];
            }
            for (j = 0; j < this.lbLong; j++) {
                out[band][j] = this.overlap[band][j] + _in[band * this.lbLong * 2 + j];
            }
            for (j = 0; j < this.lbLong; j++) {
                this.overlap[band][j] = _in[band * this.lbLong * 2 + this.lbLong + j];
            }
            var lastBlock = winSeq.equals(ICSInfo.WindowSequence.ONLY_LONG_SEQUENCE) ? 1 : 0;
            this.locationPrev[band][0] = Platform.copyOfInt(this.location[band][lastBlock], this.location[band][lastBlock].length);
            this.levelPrev[band][0] = Platform.copyOfInt(this.level[band][lastBlock], this.level[band][lastBlock].length);
        }
    };
    prototype.calculateFunctionData = function(samples, band, winSeq, blockID) {
        var locA = new Int32Array(10);
        var levA = new Float32Array(10);
        var modFunc = new Float32Array(samples);
        var buf1 = new Float32Array(stjs.trunc(samples / 2));
        var buf2 = new Float32Array(stjs.trunc(samples / 2));
        var buf3 = new Float32Array(stjs.trunc(samples / 2));
        var maxLocGain0 = 0, maxLocGain1 = 0, maxLocGain2 = 0;
        switch (winSeq) {
            case ICSInfo.WindowSequence.ONLY_LONG_SEQUENCE:
            case ICSInfo.WindowSequence.EIGHT_SHORT_SEQUENCE:
                maxLocGain0 = maxLocGain1 = stjs.trunc(samples / 2);
                maxLocGain2 = 0;
                break;
            case ICSInfo.WindowSequence.LONG_START_SEQUENCE:
                maxLocGain0 = stjs.trunc(samples / 2);
                maxLocGain1 = stjs.trunc(samples * 7 / 32);
                maxLocGain2 = stjs.trunc(samples / 16);
                break;
            case ICSInfo.WindowSequence.LONG_STOP_SEQUENCE:
                maxLocGain0 = stjs.trunc(samples / 16);
                maxLocGain1 = stjs.trunc(samples * 7 / 32);
                maxLocGain2 = stjs.trunc(samples / 2);
                break;
        }
        this.calculateFMD(band, 0, true, maxLocGain0, samples, locA, levA, buf1);
        var block = (winSeq.equals(ICSInfo.WindowSequence.EIGHT_SHORT_SEQUENCE)) ? blockID : 0;
        var secLevel = this.calculateFMD(band, block, false, maxLocGain1, samples, locA, levA, buf2);
        if (winSeq.equals(ICSInfo.WindowSequence.LONG_START_SEQUENCE) || winSeq.equals(ICSInfo.WindowSequence.LONG_STOP_SEQUENCE)) {
            this.calculateFMD(band, 1, false, maxLocGain2, samples, locA, levA, buf3);
        }
        var i;
        var flatLen = 0;
        if (winSeq.equals(ICSInfo.WindowSequence.LONG_STOP_SEQUENCE)) {
            flatLen = stjs.trunc(samples / 2) - maxLocGain0 - maxLocGain1;
            for (i = 0; i < flatLen; i++) {
                modFunc[i] = 1.0;
            }
        }
        if (winSeq.equals(ICSInfo.WindowSequence.ONLY_LONG_SEQUENCE) || winSeq.equals(ICSInfo.WindowSequence.EIGHT_SHORT_SEQUENCE)) 
            levA[0] = 1.0;
        for (i = 0; i < maxLocGain0; i++) {
            modFunc[i + flatLen] = levA[0] * secLevel * buf1[i];
        }
        for (i = 0; i < maxLocGain1; i++) {
            modFunc[i + flatLen + maxLocGain0] = levA[0] * buf2[i];
        }
        if (winSeq.equals(ICSInfo.WindowSequence.LONG_START_SEQUENCE)) {
            for (i = 0; i < maxLocGain2; i++) {
                modFunc[i + maxLocGain0 + maxLocGain1] = buf3[i];
            }
            flatLen = stjs.trunc(samples / 2) - maxLocGain1 - maxLocGain2;
            for (i = 0; i < flatLen; i++) {
                modFunc[i + maxLocGain0 + maxLocGain1 + maxLocGain2] = 1.0;
            }
        } else if (winSeq.equals(ICSInfo.WindowSequence.LONG_STOP_SEQUENCE)) {
            for (i = 0; i < maxLocGain2; i++) {
                modFunc[i + flatLen + maxLocGain0 + maxLocGain1] = buf3[i];
            }
        }
        for (i = 0; i < samples; i++) {
            this._function[i] = 1.0 / modFunc[i];
        }
    };
    prototype.calculateFMD = function(bd, wd, prev, maxLocGain, samples, loc, lev, fmd) {
        var m = new Int32Array(stjs.trunc(samples / 2));
        var lct = prev ? this.locationPrev[bd][wd] : this.location[bd][wd];
        var lvl = prev ? this.levelPrev[bd][wd] : this.level[bd][wd];
        var length = lct.length;
        var lngain;
        var i;
        for (i = 0; i < length; i++) {
            loc[i + 1] = 8 * lct[i];
            lngain = this.getGainChangePointID(lvl[i]);
            if (lngain < 0) 
                lev[i + 1] = 1.0 / Math.pow(2, -lngain);
             else 
                lev[i + 1] = Math.pow(2, lngain);
        }
        loc[0] = 0;
        if (length == 0) 
            lev[0] = 1.0;
         else 
            lev[0] = lev[1];
        var secLevel = lev[0];
        loc[length + 1] = maxLocGain;
        lev[length + 1] = 1.0;
        var j;
        for (i = 0; i < maxLocGain; i++) {
            m[i] = 0;
            for (j = 0; j <= length + 1; j++) {
                if (loc[j] <= i) 
                    m[i] = j;
            }
        }
        for (i = 0; i < maxLocGain; i++) {
            if ((i >= loc[m[i]]) && (i <= loc[m[i]] + 7)) 
                fmd[i] = this.interpolateGain(lev[m[i]], lev[m[i] + 1], i - loc[m[i]]);
             else 
                fmd[i] = lev[m[i] + 1];
        }
        return secLevel;
    };
    /**
     *  transformes the exponent value of the gain to the id of the gain change
     *  point
     */
    prototype.getGainChangePointID = function(lngain) {
        for (var i = 0; i < GCConstants.ID_GAIN; i++) {
            if (lngain == GCConstants.LN_GAIN[i]) 
                return i;
        }
        return 0;
    };
    /**
     *  calculates a fragment modification function
     *  the interpolated gain value between the gain values of two gain change
     *  positions is calculated by the formula:
     *  f(a,b,j) = 2^(((8-j)log2(a)+j*log2(b))/8)
     */
    prototype.interpolateGain = function(alev0, alev1, iloc) {
        var a0 = (Math.log(alev0) / Math.log(2));
        var a1 = (Math.log(alev1) / Math.log(2));
        return Math.pow(2.0, (((8 - iloc) * a0 + iloc * a1) / 8));
    };
}, {imdct: "IMDCT", ipqf: "IPQF", buffer1: "Float32Array", _function: "Float32Array", buffer2: "Array", overlap: "Array", level: "Array", levelPrev: "Array", location: "Array", locationPrev: "Array", LN_GAIN: "Int32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var JpegDecoder = function(interlace, topFieldFirst) {
    VideoDecoder.call(this);
    this.buf = new Int32Array(64);
    this.interlace = interlace;
    this.topFieldFirst = topFieldFirst;
};
JpegDecoder = stjs.extend(JpegDecoder, VideoDecoder, [], function(constructor, prototype) {
    prototype.interlace = false;
    prototype.topFieldFirst = false;
    prototype.buf = null;
    prototype.decodeScan = function(data, header, scan, huffTables, quant, data2, field, step) {
        var blockW = header.getHmax();
        var blockH = header.getVmax();
        var mcuW = blockW << 3;
        var mcuH = blockH << 3;
        var width = header.width;
        var height = header.height;
        var xBlocks = (width + mcuW - 1) >> (blockW + 2);
        var yBlocks = (height + mcuH - 1) >> (blockH + 2);
        var nn = blockW + blockH;
        var result = new Picture8Bit(xBlocks << (blockW + 2), yBlocks << (blockH + 2), data2, nn == 4 ? ColorSpace.YUV420J : (nn == 3 ? ColorSpace.YUV422J : ColorSpace.YUV444J), new Rect(0, 0, width, height));
        var bits = BitReader.createBitReader(data);
        var dcPredictor = new Int32Array([1024, 1024, 1024]);
        for (var by = 0; by < yBlocks; by++) 
            for (var bx = 0; bx < xBlocks && bits.moreData(); bx++) 
                this.decodeMCU(bits, dcPredictor, quant, huffTables, result, bx, by, blockW, blockH, field, step);
        return result;
    };
    prototype.putBlock = function(plane, stride, patch, x, y, field, step) {
        var dstride = step * stride;
        for (var i = 0, off = field * stride + y * dstride + x, poff = 0; i < 8; i++) {
            for (var j = 0; j < 8; j++) 
                plane[j + off] = ((MathUtil.clip(patch[j + poff], 0, 255) - 128) << 24 >> 24);
            off += dstride;
            poff += 8;
        }
    };
    prototype.decodeMCU = function(bits, dcPredictor, quant, huff, result, bx, by, blockH, blockV, field, step) {
        var sx = bx << (blockH - 1);
        var sy = by << (blockV - 1);
        for (var i = 0; i < blockV; i++) 
            for (var j = 0; j < blockH; j++) {
                this.decodeBlock(bits, dcPredictor, quant, huff, result, this.buf, (sx + j) << 3, (sy + i) << 3, 0, 0, field, step);
            }
        this.decodeBlock(bits, dcPredictor, quant, huff, result, this.buf, bx << 3, by << 3, 1, 1, field, step);
        this.decodeBlock(bits, dcPredictor, quant, huff, result, this.buf, bx << 3, by << 3, 2, 1, field, step);
    };
    prototype.decodeBlock = function(bits, dcPredictor, quant, huff, result, buf, blkX, blkY, plane, chroma, field, step) {
        Arrays.fill(buf, 0);
        dcPredictor[plane] = buf[0] = this.readDCValue(bits, huff[chroma]) * quant[chroma][0] + dcPredictor[plane];
        this.readACValues(bits, buf, huff[chroma + 2], quant[chroma]);
        SimpleIDCT10Bit.idct10(buf, 0);
        this.putBlock(result.getPlaneData(plane), result.getPlaneWidth(plane), buf, blkX, blkY, field, step);
    };
    prototype.readDCValue = function(_in, table) {
        var code = table.readVLC16(_in);
        return code != 0 ? JpegDecoder.toValue(_in.readNBit(code), code) : 0;
    };
    prototype.readACValues = function(_in, target, table, quantTable) {
        var code;
        var curOff = 1;
        do {
            code = table.readVLC16(_in);
            if (code == 240) {
                curOff += 16;
            } else if (code > 0) {
                var rle = code >> 4;
                curOff += rle;
                var len = code & 15;
                target[JpegConst.naturalOrder[curOff]] = JpegDecoder.toValue(_in.readNBit(len), len) * quantTable[curOff];
                curOff++;
            }
        } while (code != 0 && curOff < 64);
    };
    constructor.toValue = function(raw, length) {
        return (length >= 1 && raw < (1 << length - 1)) ? -(1 << length) + 1 + raw : raw;
    };
    prototype.decodeFrame8Bit = function(data, data2) {
        if (this.interlace) {
            var r1 = this.decodeField(data, data2, this.topFieldFirst ? 0 : 1, 2);
            var r2 = this.decodeField(data, data2, this.topFieldFirst ? 1 : 0, 2);
            return Picture8Bit.createPicture8Bit(r1.getWidth(), r1.getHeight() << 1, data2, r1.getColor());
        } else {
            return this.decodeField(data, data2, 0, 1);
        }
    };
    prototype.decodeField = function(data, data2, field, step) {
        var result = null;
        var header = null;
        var huffTables = [JpegConst.YDC_DEFAULT, JpegConst.CDC_DEFAULT, JpegConst.YAC_DEFAULT, JpegConst.CAC_DEFAULT];
        var quant = [JpegConst.DEFAULT_QUANT_LUMA, JpegConst.DEFAULT_QUANT_CHROMA];
        var scan = null;
         while (data.hasRemaining()){
            var marker = data.get() & 255;
            if (marker == 0) 
                continue;
            if (marker != 255) 
                 throw new RuntimeException("@" + Long.toHexString(data.position()) + " Marker expected: 0x" + Integer.toHexString(marker));
            var b;
             while ((b = data.get() & 255) == 255)
                ;
            if (b == JpegConst.SOF0) {
                header = FrameHeader.read(data);
            } else if (b == JpegConst.DHT) {
                var len1 = data.getShort() & 65535;
                var buf = NIOUtils.read(data, len1 - 2);
                 while (buf.hasRemaining()){
                    var tableNo = buf.get() & 255;
                    huffTables[(tableNo & 1) | ((tableNo >> 3) & 2)] = JpegDecoder.readHuffmanTable(buf);
                }
            } else if (b == JpegConst.DQT) {
                var len4 = data.getShort() & 65535;
                var buf = NIOUtils.read(data, len4 - 2);
                 while (buf.hasRemaining()){
                    var ind = buf.get() & 255;
                    quant[ind] = JpegDecoder.readQuantTable(buf);
                }
            } else if (b == JpegConst.SOS) {
                if (scan != null) {
                     throw new UnhandledStateException("unhandled - more than one scan header");
                }
                scan = ScanHeader.read(data);
                result = this.decodeScan(JpegDecoder.readToMarker(data), header, scan, huffTables, quant, data2, field, step);
            } else if (b == JpegConst.SOI || (b >= JpegConst.RST0 && b <= JpegConst.RST7)) {} else if (b == JpegConst.EOI) {
                break;
            } else if (b >= JpegConst.APP0 && b <= JpegConst.COM) {
                var len3 = data.getShort() & 65535;
                NIOUtils.read(data, len3 - 2);
            } else if (b == JpegConst.DRI) {
                var lr = data.getShort() & 65535;
                var ri = data.getShort() & 65535;
                Asserts.assertEquals(0, ri);
            } else {
                 throw new UnhandledStateException("unhandled marker " + JpegConst.markerToString(b));
            }
        }
        return result;
    };
    constructor.readToMarker = function(data) {
        var out = ByteBuffer.allocate(data.remaining());
         while (data.hasRemaining()){
            var b0 = data.get();
            if (b0 == -1) {
                var b1 = data.get();
                if (b1 == 0) 
                    out.put((-1 << 24 >> 24));
                 else {
                    data.setPosition(data.position() - 2);
                    break;
                }
            } else 
                out.put(b0);
        }
        out.flip();
        return out;
    };
    constructor.readHuffmanTable = function(data) {
        var builder = new VLCBuilder();
        var levelSizes = NIOUtils.toArray(NIOUtils.read(data, 16));
        var levelStart = 0;
        for (var i = 0; i < 16; i++) {
            var length = levelSizes[i] & 255;
            for (var c = 0; c < length; c++) {
                var val = data.get() & 255;
                var code = levelStart++;
                builder.setInt(code, i + 1, val);
            }
            levelStart <<= 1;
        }
        return builder.getVLC();
    };
    constructor.readQuantTable = function(data) {
        var result = new Int32Array(64);
        for (var i = 0; i < 64; i++) {
            result[i] = data.get() & 255;
        }
        return result;
    };
    prototype.probe = function(data) {
        return 0;
    };
}, {buf: "Int32Array", byteBuffer: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var PictureHeader = function() {};
PictureHeader = stjs.extend(PictureHeader, null, [MPEGHeader], function(constructor, prototype) {
    prototype.temporal_reference = 0;
    prototype.picture_coding_type = 0;
    prototype.vbv_delay = 0;
    prototype.full_pel_forward_vector = 0;
    prototype.forward_f_code = 0;
    prototype.full_pel_backward_vector = 0;
    prototype.backward_f_code = 0;
    prototype.quantMatrixExtension = null;
    prototype.copyrightExtension = null;
    prototype.pictureDisplayExtension = null;
    prototype.pictureCodingExtension = null;
    prototype.pictureSpatialScalableExtension = null;
    prototype.pictureTemporalScalableExtension = null;
    prototype._hasExtensions = false;
    constructor.createPictureHeader = function(temporal_reference, picture_coding_type, vbv_delay, full_pel_forward_vector, forward_f_code, full_pel_backward_vector, backward_f_code) {
        var p = new PictureHeader();
        p.temporal_reference = temporal_reference;
        p.picture_coding_type = picture_coding_type;
        p.vbv_delay = vbv_delay;
        p.full_pel_forward_vector = full_pel_forward_vector;
        p.forward_f_code = forward_f_code;
        p.full_pel_backward_vector = full_pel_backward_vector;
        p.backward_f_code = backward_f_code;
        return p;
    };
    constructor.read = function(bb) {
        var _in = BitReader.createBitReader(bb);
        var ph = new PictureHeader();
        ph.temporal_reference = _in.readNBit(10);
        ph.picture_coding_type = _in.readNBit(3);
        ph.vbv_delay = _in.readNBit(16);
        if (ph.picture_coding_type == 2 || ph.picture_coding_type == 3) {
            ph.full_pel_forward_vector = _in.read1Bit();
            ph.forward_f_code = _in.readNBit(3);
        }
        if (ph.picture_coding_type == 3) {
            ph.full_pel_backward_vector = _in.read1Bit();
            ph.backward_f_code = _in.readNBit(3);
        }
         while (_in.read1Bit() == 1){
            _in.readNBit(8);
        }
        return ph;
    };
    constructor.readExtension = function(bb, ph, sh) {
        ph._hasExtensions = true;
        var _in = BitReader.createBitReader(bb);
        var extType = _in.readNBit(4);
        switch (extType) {
            case QuantMatrixExtension.Quant_Matrix_Extension:
                ph.quantMatrixExtension = QuantMatrixExtension.read(_in);
                break;
            case CopyrightExtension.Copyright_Extension:
                ph.copyrightExtension = CopyrightExtension.read(_in);
                break;
            case PictureDisplayExtension.Picture_Display_Extension:
                ph.pictureDisplayExtension = PictureDisplayExtension.read(_in, sh.sequenceExtension, ph.pictureCodingExtension);
                break;
            case PictureCodingExtension.Picture_Coding_Extension:
                ph.pictureCodingExtension = PictureCodingExtension.read(_in);
                break;
            case PictureSpatialScalableExtension.Picture_Spatial_Scalable_Extension:
                ph.pictureSpatialScalableExtension = PictureSpatialScalableExtension.read(_in);
                break;
            case PictureTemporalScalableExtension.Picture_Temporal_Scalable_Extension:
                ph.pictureTemporalScalableExtension = PictureTemporalScalableExtension.read(_in);
                break;
            default:
                 throw new RuntimeException("Unsupported extension: " + extType);
        }
    };
    prototype.write = function(os) {
        var out = new BitWriter(os);
        out.writeNBit(this.temporal_reference, 10);
        out.writeNBit(this.picture_coding_type, 3);
        out.writeNBit(this.vbv_delay, 16);
        if (this.picture_coding_type == 2 || this.picture_coding_type == 3) {
            out.write1Bit(this.full_pel_forward_vector);
            out.write1Bit(this.forward_f_code);
        }
        if (this.picture_coding_type == 3) {
            out.write1Bit(this.full_pel_backward_vector);
            out.writeNBit(this.backward_f_code, 3);
        }
        out.write1Bit(0);
        out.flush();
        this.writeExtensions(os);
    };
    prototype.writeExtensions = function(out) {
        if (this.quantMatrixExtension != null) {
            out.putInt(MPEGConst.EXTENSION_START_CODE);
            this.quantMatrixExtension.write(out);
        }
        if (this.copyrightExtension != null) {
            out.putInt(MPEGConst.EXTENSION_START_CODE);
            this.copyrightExtension.write(out);
        }
        if (this.pictureCodingExtension != null) {
            out.putInt(MPEGConst.EXTENSION_START_CODE);
            this.pictureCodingExtension.write(out);
        }
        if (this.pictureDisplayExtension != null) {
            out.putInt(MPEGConst.EXTENSION_START_CODE);
            this.pictureDisplayExtension.write(out);
        }
        if (this.pictureSpatialScalableExtension != null) {
            out.putInt(MPEGConst.EXTENSION_START_CODE);
            this.pictureSpatialScalableExtension.write(out);
        }
        if (this.pictureTemporalScalableExtension != null) {
            out.putInt(MPEGConst.EXTENSION_START_CODE);
            this.pictureTemporalScalableExtension.write(out);
        }
    };
    prototype.hasExtensions = function() {
        return this._hasExtensions;
    };
}, {quantMatrixExtension: "QuantMatrixExtension", copyrightExtension: "CopyrightExtension", pictureDisplayExtension: "PictureDisplayExtension", pictureCodingExtension: "PictureCodingExtension", pictureSpatialScalableExtension: "PictureSpatialScalableExtension", pictureTemporalScalableExtension: "PictureTemporalScalableExtension"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  MPEG 1/2 decoder interframe motion compensation routines
 *  
 *  @author The JCodec project
 *  
 */
var MPEGPred = function(fCode, chromaFormat, topFieldFirst) {
    this.mvPred = Array.apply(null, Array(2)).map(function() {
        return Array.apply(null, Array(2)).map(function() {
            return new Int32Array(2);
        });
    });
    this.fCode = fCode;
    this.chromaFormat = chromaFormat;
    this.topFieldFirst = topFieldFirst;
};
MPEGPred = stjs.extend(MPEGPred, null, [], function(constructor, prototype) {
    prototype.mvPred = null;
    prototype.chromaFormat = 0;
    prototype.fCode = null;
    prototype.topFieldFirst = false;
    prototype.predictFullXFullYSafe = function(ref, refX, refY, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep) {
        var offRef = ((refY << refVertStep) + refVertOff) * refW + refX, offTgt = tgtW * tgtY, lfRef = (refW << refVertStep) - tgtW, lfTgt = tgtVertStep * tgtW;
        for (var i = 0; i < tgtH; i++) {
            for (var j = 0; j < tgtW; j++) 
                tgt[offTgt++] = ref[offRef++] + 128;
            offRef += lfRef;
            offTgt += lfTgt;
        }
    };
    prototype.predictEvenOddSafe = function(ref, refX, refY, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep) {
        var offRef = ((refY << refVertStep) + refVertOff) * refW + refX, offTgt = tgtW * tgtY, lfRef = (refW << refVertStep) - tgtW, lfTgt = tgtVertStep * tgtW;
        for (var i = 0; i < tgtH; i++) {
            for (var j = 0; j < tgtW; j++) {
                tgt[offTgt++] = ((ref[offRef] + ref[offRef + 1] + 1) >> 1) + 128;
                ++offRef;
            }
            offRef += lfRef;
            offTgt += lfTgt;
        }
    };
    prototype.predictOddEvenSafe = function(ref, refX, refY, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep) {
        var offRef = ((refY << refVertStep) + refVertOff) * refW + refX, offTgt = tgtW * tgtY, lfRef = (refW << refVertStep) - tgtW, lfTgt = tgtVertStep * tgtW, stride = refW << refVertStep;
        for (var i = 0; i < tgtH; i++) {
            for (var j = 0; j < tgtW; j++) {
                tgt[offTgt++] = ((ref[offRef] + ref[offRef + stride] + 1) >> 1) + 128;
                ++offRef;
            }
            offRef += lfRef;
            offTgt += lfTgt;
        }
    };
    prototype.predictOddOddSafe = function(ref, refX, refY, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep) {
        var offRef = ((refY << refVertStep) + refVertOff) * refW + refX, offTgt = tgtW * tgtY, lfRef = (refW << refVertStep) - tgtW, lfTgt = tgtVertStep * tgtW, stride = refW << refVertStep;
        for (var i = 0; i < tgtH; i++) {
            for (var j = 0; j < tgtW; j++) {
                tgt[offTgt++] = ((ref[offRef] + ref[offRef + 1] + ref[offRef + stride] + ref[offRef + stride + 1] + 3) >> 2) + 128;
                ++offRef;
            }
            offRef += lfRef;
            offTgt += lfTgt;
        }
    };
    prototype.getPix1 = function(ref, refW, refH, x, y, refVertStep, refVertOff) {
        x = MathUtil.clip(x, 0, refW - 1);
        y = MathUtil.clip(y, 0, refH - (1 << refVertStep) + refVertOff);
        return ref[y * refW + x] + 128;
    };
    prototype.getPix2 = function(ref, refW, refH, x1, y1, x2, y2, refVertStep, refVertOff) {
        x1 = MathUtil.clip(x1, 0, refW - 1);
        var lastLine = refH - (1 << refVertStep) + refVertOff;
        y1 = MathUtil.clip(y1, 0, lastLine);
        x2 = MathUtil.clip(x2, 0, refW - 1);
        y2 = MathUtil.clip(y2, 0, lastLine);
        return ((ref[y1 * refW + x1] + ref[y2 * refW + x2] + 1) >> 1) + 128;
    };
    prototype.getPix4 = function(ref, refW, refH, x1, y1, x2, y2, x3, y3, x4, y4, refVertStep, refVertOff) {
        var lastLine = refH - (1 << refVertStep) + refVertOff;
        x1 = MathUtil.clip(x1, 0, refW - 1);
        y1 = MathUtil.clip(y1, 0, lastLine);
        x2 = MathUtil.clip(x2, 0, refW - 1);
        y2 = MathUtil.clip(y2, 0, lastLine);
        x3 = MathUtil.clip(x3, 0, refW - 1);
        y3 = MathUtil.clip(y3, 0, lastLine);
        x4 = MathUtil.clip(x4, 0, refW - 1);
        y4 = MathUtil.clip(y4, 0, lastLine);
        return ((ref[y1 * refW + x1] + ref[y2 * refW + x2] + ref[y3 * refW + x3] + ref[y4 * refW + x4] + 3) >> 2) + 128;
    };
    prototype.predictFullXFullYUnSafe = function(ref, refX, refY, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep) {
        var tgtOff = tgtW * tgtY, jump = tgtVertStep * tgtW;
        for (var j = 0; j < tgtH; j++) {
            var y = ((j + refY) << refVertStep) + refVertOff;
            for (var i = 0; i < tgtW; i++) {
                tgt[tgtOff++] = this.getPix1(ref, refW, refH, i + refX, y, refVertStep, refVertOff);
            }
            tgtOff += jump;
        }
    };
    prototype.predictEvenOddUnSafe = function(ref, refX, refY, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep) {
        var tgtOff = tgtW * tgtY, jump = tgtVertStep * tgtW;
        for (var j = 0; j < tgtH; j++) {
            var y = ((j + refY) << refVertStep) + refVertOff;
            for (var i = 0; i < tgtW; i++) {
                tgt[tgtOff++] = this.getPix2(ref, refW, refH, i + refX, y, i + refX + 1, y, refVertStep, refVertOff);
            }
            tgtOff += jump;
        }
    };
    prototype.predictOddEvenUnSafe = function(ref, refX, refY, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep) {
        var tgtOff = tgtW * tgtY, jump = tgtVertStep * tgtW;
        for (var j = 0; j < tgtH; j++) {
            var y1 = ((j + refY) << refVertStep) + refVertOff;
            var y2 = ((j + refY + 1) << refVertStep) + refVertOff;
            for (var i = 0; i < tgtW; i++) {
                tgt[tgtOff++] = this.getPix2(ref, refW, refH, i + refX, y1, i + refX, y2, refVertStep, refVertOff);
            }
            tgtOff += jump;
        }
    };
    prototype.predictOddOddUnSafe = function(ref, refX, refY, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep) {
        var tgtOff = tgtW * tgtY, jump = tgtVertStep * tgtW;
        for (var j = 0; j < tgtH; j++) {
            var y1 = ((j + refY) << refVertStep) + refVertOff;
            var y2 = ((j + refY + 1) << refVertStep) + refVertOff;
            for (var i = 0; i < tgtW; i++) {
                var ptX = i + refX;
                tgt[tgtOff++] = this.getPix4(ref, refW, refH, ptX, y1, ptX + 1, y1, ptX, y2, ptX + 1, y2, refVertStep, refVertOff);
            }
            tgtOff += jump;
        }
    };
    prototype.predictPlane = function(ref, refX, refY, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep) {
        var rx = refX >> 1, ry = refY >> 1;
        var safe = rx >= 0 && ry >= 0 && rx + tgtW < refW && (ry + tgtH << refVertStep) < refH;
        if ((refX & 1) == 0) {
            if ((refY & 1) == 0) {
                if (safe) 
                    this.predictFullXFullYSafe(ref, rx, ry, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep);
                 else 
                    this.predictFullXFullYUnSafe(ref, rx, ry, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep);
            } else {
                if (safe) 
                    this.predictOddEvenSafe(ref, rx, ry, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep);
                 else 
                    this.predictOddEvenUnSafe(ref, rx, ry, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep);
            }
        } else if ((refY & 1) == 0) {
            if (safe) 
                this.predictEvenOddSafe(ref, rx, ry, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep);
             else 
                this.predictEvenOddUnSafe(ref, rx, ry, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep);
        } else {
            if (safe) 
                this.predictOddOddSafe(ref, rx, ry, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep);
             else 
                this.predictOddOddUnSafe(ref, rx, ry, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep);
        }
    };
    prototype.predictInField = function(reference, x, y, mbPix, bits, motionType, backward, fieldNo) {
        switch (motionType) {
            case 1:
                this.predict16x16Field(reference, x, y, bits, backward, mbPix);
                break;
            case 2:
                this.predict16x8MC(reference, x, y, bits, backward, mbPix, 0, 0);
                this.predict16x8MC(reference, x, y, bits, backward, mbPix, 8, 1);
                break;
            case 3:
                this.predict16x16DualPrimeField(reference, x, y, bits, mbPix, fieldNo);
        }
    };
    prototype.predictInFrame = function(reference, x, y, mbPix, _in, motionType, backward, spatial_temporal_weight_code) {
        var refs = [reference, reference];
        switch (motionType) {
            case 1:
                this.predictFieldInFrame(reference, x, y, mbPix, _in, backward, spatial_temporal_weight_code);
                break;
            case 2:
                this.predict16x16Frame(reference, x, y, _in, backward, mbPix);
                break;
            case 3:
                this.predict16x16DualPrimeFrame(refs, x, y, _in, backward, mbPix);
                break;
        }
    };
    prototype.predict16x16DualPrimeField = function(reference, x, y, bits, mbPix, fieldNo) {
        var vect1X = this.mvectDecode(bits, this.fCode[0][0], this.mvPred[0][0][0]);
        var dmX = MPEGConst.vlcDualPrime.readVLC(bits) - 1;
        var vect1Y = this.mvectDecode(bits, this.fCode[0][1], this.mvPred[0][0][1]);
        var dmY = MPEGConst.vlcDualPrime.readVLC(bits) - 1;
        var vect2X = this.dpXField(vect1X, dmX, 1 - fieldNo);
        var vect2Y = this.dpYField(vect1Y, dmY, 1 - fieldNo);
        var ch = this.chromaFormat == SequenceExtension.Chroma420 ? 1 : 0;
        var cw = this.chromaFormat == SequenceExtension.Chroma444 ? 0 : 1;
        var sh = this.chromaFormat == SequenceExtension.Chroma420 ? 2 : 1;
        var sw = this.chromaFormat == SequenceExtension.Chroma444 ? 1 : 2;
        var mbPix1 = Array.apply(null, Array(3)).map(function() {
            return new Int32Array(256);
        }), mbPix2 = Array.apply(null, Array(3)).map(function() {
            return new Int32Array(256);
        });
        var refX1 = (x << 1) + vect1X;
        var refY1 = (y << 1) + vect1Y;
        var refX1Chr = ((x << 1) >> cw) + stjs.trunc(vect1X / sw);
        var refY1Chr = ((y << 1) >> ch) + stjs.trunc(vect1Y / sh);
        this.predictPlane(reference[fieldNo].getPlaneData(0), refX1, refY1, reference[fieldNo].getPlaneWidth(0), reference[fieldNo].getPlaneHeight(0), 1, fieldNo, mbPix1[0], 0, 16, 16, 0);
        this.predictPlane(reference[fieldNo].getPlaneData(1), refX1Chr, refY1Chr, reference[fieldNo].getPlaneWidth(1), reference[fieldNo].getPlaneHeight(1), 1, fieldNo, mbPix1[1], 0, 16 >> cw, 16 >> ch, 0);
        this.predictPlane(reference[fieldNo].getPlaneData(2), refX1Chr, refY1Chr, reference[fieldNo].getPlaneWidth(2), reference[fieldNo].getPlaneHeight(2), 1, fieldNo, mbPix1[2], 0, 16 >> cw, 16 >> ch, 0);
        var refX2 = (x << 1) + vect2X;
        var refY2 = (y << 1) + vect2Y;
        var refX2Chr = ((x << 1) >> cw) + stjs.trunc(vect2X / sw);
        var refY2Chr = ((y << 1) >> ch) + stjs.trunc(vect2Y / sh);
        var opposite = 1 - fieldNo;
        this.predictPlane(reference[opposite].getPlaneData(0), refX2, refY2, reference[opposite].getPlaneWidth(0), reference[opposite].getPlaneHeight(0), 1, opposite, mbPix2[0], 0, 16, 16, 0);
        this.predictPlane(reference[opposite].getPlaneData(1), refX2Chr, refY2Chr, reference[opposite].getPlaneWidth(1), reference[opposite].getPlaneHeight(1), 1, opposite, mbPix2[1], 0, 16 >> cw, 16 >> ch, 0);
        this.predictPlane(reference[opposite].getPlaneData(2), refX2Chr, refY2Chr, reference[opposite].getPlaneWidth(2), reference[opposite].getPlaneHeight(2), 1, opposite, mbPix2[2], 0, 16 >> cw, 16 >> ch, 0);
        for (var i = 0; i < 3; i++) {
            for (var j = 0; j < mbPix[i].length; j++) 
                mbPix[i][j] = (mbPix1[i][j] + mbPix2[i][j] + 1) >> 1;
        }
        this.mvPred[1][0][0] = this.mvPred[0][0][0] = vect1X;
        this.mvPred[1][0][1] = this.mvPred[0][0][1] = vect1Y;
    };
    prototype.dpYField = function(vect1y, dmY, topField) {
        return ((vect1y + (vect1y > 0 ? 1 : 0)) >> 1) + (1 - (topField << 1)) + dmY;
    };
    prototype.dpXField = function(vect1x, dmX, topField) {
        return ((vect1x + (vect1x > 0 ? 1 : 0)) >> 1) + dmX;
    };
    prototype.predict16x8MC = function(reference, x, y, bits, backward, mbPix, vertPos, vectIdx) {
        var field = bits.read1Bit();
        this.predictGeneric(reference[field], x, y + vertPos, bits, backward, mbPix, vertPos, 16, 8, 1, field, 0, vectIdx, 0);
    };
    prototype.predict16x16Field = function(reference, x, y, bits, backward, mbPix) {
        var field = bits.read1Bit();
        this.predictGeneric(reference[field], x, y, bits, backward, mbPix, 0, 16, 16, 1, field, 0, 0, 0);
        this.mvPred[1][backward][0] = this.mvPred[0][backward][0];
        this.mvPred[1][backward][1] = this.mvPred[0][backward][1];
    };
    prototype.predict16x16DualPrimeFrame = function(reference, x, y, bits, backward, mbPix) {
        var vect1X = this.mvectDecode(bits, this.fCode[0][0], this.mvPred[0][0][0]);
        var dmX = MPEGConst.vlcDualPrime.readVLC(bits) - 1;
        var vect1Y = this.mvectDecode(bits, this.fCode[0][1], this.mvPred[0][0][1] >> 1);
        var dmY = MPEGConst.vlcDualPrime.readVLC(bits) - 1;
        var m = this.topFieldFirst ? 1 : 3;
        var vect2X = ((vect1X * m + (vect1X > 0 ? 1 : 0)) >> 1) + dmX;
        var vect2Y = ((vect1Y * m + (vect1Y > 0 ? 1 : 0)) >> 1) + dmY - 1;
        m = 4 - m;
        var vect3X = ((vect1X * m + (vect1X > 0 ? 1 : 0)) >> 1) + dmX;
        var vect3Y = ((vect1Y * m + (vect1Y > 0 ? 1 : 0)) >> 1) + dmY + 1;
        var ch = this.chromaFormat == SequenceExtension.Chroma420 ? 1 : 0;
        var cw = this.chromaFormat == SequenceExtension.Chroma444 ? 0 : 1;
        var sh = this.chromaFormat == SequenceExtension.Chroma420 ? 2 : 1;
        var sw = this.chromaFormat == SequenceExtension.Chroma444 ? 1 : 2;
        var mbPix1 = Array.apply(null, Array(3)).map(function() {
            return new Int32Array(256);
        }), mbPix2 = Array.apply(null, Array(3)).map(function() {
            return new Int32Array(256);
        });
        var refX1 = (x << 1) + vect1X;
        var refY1 = y + vect1Y;
        var refX1Chr = ((x << 1) >> cw) + stjs.trunc(vect1X / sw);
        var refY1Chr = (y >> ch) + stjs.trunc(vect1Y / sh);
        this.predictPlane(reference[0].getPlaneData(0), refX1, refY1, reference[0].getPlaneWidth(0), reference[0].getPlaneHeight(0), 1, 0, mbPix1[0], 0, 16, 8, 1);
        this.predictPlane(reference[0].getPlaneData(1), refX1Chr, refY1Chr, reference[0].getPlaneWidth(1), reference[0].getPlaneHeight(1), 1, 0, mbPix1[1], 0, 16 >> cw, 8 >> ch, 1);
        this.predictPlane(reference[0].getPlaneData(2), refX1Chr, refY1Chr, reference[0].getPlaneWidth(2), reference[0].getPlaneHeight(2), 1, 0, mbPix1[2], 0, 16 >> cw, 8 >> ch, 1);
        this.predictPlane(reference[1].getPlaneData(0), refX1, refY1, reference[1].getPlaneWidth(0), reference[1].getPlaneHeight(0), 1, 1, mbPix1[0], 1, 16, 8, 1);
        this.predictPlane(reference[1].getPlaneData(1), refX1Chr, refY1Chr, reference[1].getPlaneWidth(1), reference[1].getPlaneHeight(1), 1, 1, mbPix1[1], 1, 16 >> cw, 8 >> ch, 1);
        this.predictPlane(reference[1].getPlaneData(2), refX1Chr, refY1Chr, reference[1].getPlaneWidth(2), reference[1].getPlaneHeight(2), 1, 1, mbPix1[2], 1, 16 >> cw, 8 >> ch, 1);
        var refX2 = (x << 1) + vect2X;
        var refY2 = y + vect2Y;
        var refX2Chr = ((x << 1) >> cw) + stjs.trunc(vect2X / sw);
        var refY2Chr = (y >> ch) + stjs.trunc(vect2Y / sh);
        this.predictPlane(reference[1].getPlaneData(0), refX2, refY2, reference[1].getPlaneWidth(0), reference[1].getPlaneHeight(0), 1, 1, mbPix2[0], 0, 16, 8, 1);
        this.predictPlane(reference[1].getPlaneData(1), refX2Chr, refY2Chr, reference[1].getPlaneWidth(1), reference[1].getPlaneHeight(1), 1, 1, mbPix2[1], 0, 16 >> cw, 8 >> ch, 1);
        this.predictPlane(reference[1].getPlaneData(2), refX2Chr, refY2Chr, reference[1].getPlaneWidth(2), reference[1].getPlaneHeight(2), 1, 1, mbPix2[2], 0, 16 >> cw, 8 >> ch, 1);
        var refX3 = (x << 1) + vect3X;
        var refY3 = y + vect3Y;
        var refX3Chr = ((x << 1) >> cw) + stjs.trunc(vect3X / sw);
        var refY3Chr = (y >> ch) + stjs.trunc(vect3Y / sh);
        this.predictPlane(reference[0].getPlaneData(0), refX3, refY3, reference[0].getPlaneWidth(0), reference[0].getPlaneHeight(0), 1, 0, mbPix2[0], 1, 16, 8, 1);
        this.predictPlane(reference[0].getPlaneData(1), refX3Chr, refY3Chr, reference[0].getPlaneWidth(1), reference[0].getPlaneHeight(1), 1, 0, mbPix2[1], 1, 16 >> cw, 8 >> ch, 1);
        this.predictPlane(reference[0].getPlaneData(2), refX3Chr, refY3Chr, reference[0].getPlaneWidth(2), reference[0].getPlaneHeight(2), 1, 0, mbPix2[2], 1, 16 >> cw, 8 >> ch, 1);
        for (var i = 0; i < 3; i++) {
            for (var j = 0; j < mbPix[i].length; j++) 
                mbPix[i][j] = (mbPix1[i][j] + mbPix2[i][j] + 1) >> 1;
        }
        this.mvPred[1][0][0] = this.mvPred[0][0][0] = vect1X;
        this.mvPred[1][0][1] = this.mvPred[0][0][1] = vect1Y << 1;
    };
    prototype.predict16x16Frame = function(reference, x, y, bits, backward, mbPix) {
        this.predictGeneric(reference, x, y, bits, backward, mbPix, 0, 16, 16, 0, 0, 0, 0, 0);
        this.mvPred[1][backward][0] = this.mvPred[0][backward][0];
        this.mvPred[1][backward][1] = this.mvPred[0][backward][1];
    };
    prototype.mvectDecode = function(bits, fcode, pred) {
        var code = MPEGConst.vlcMotionCode.readVLC(bits);
        if (code == 0) {
            return pred;
        }
        if (code < 0) {
            return 65535;
        }
        var sign, val, shift;
        sign = bits.read1Bit();
        shift = fcode - 1;
        val = code;
        if (shift > 0) {
            val = (val - 1) << shift;
            val |= bits.readNBit(shift);
            val++;
        }
        if (sign != 0) 
            val = -val;
        val += pred;
        return this.sign_extend(val, 5 + shift);
    };
    prototype.sign_extend = function(val, bits) {
        var shift = 32 - bits;
        return (val << shift) >> shift;
    };
    prototype.predictGeneric = function(reference, x, y, bits, backward, mbPix, tgtY, blkW, blkH, isSrcField, srcField, isDstField, vectIdx, predScale) {
        var vectX = this.mvectDecode(bits, this.fCode[backward][0], this.mvPred[vectIdx][backward][0]);
        var vectY = this.mvectDecode(bits, this.fCode[backward][1], this.mvPred[vectIdx][backward][1] >> predScale);
        this.predictMB(reference, (x << 1), vectX, (y << 1), vectY, blkW, blkH, isSrcField, srcField, mbPix, tgtY, isDstField);
        this.mvPred[vectIdx][backward][0] = vectX;
        this.mvPred[vectIdx][backward][1] = vectY << predScale;
    };
    prototype.predictFieldInFrame = function(reference, x, y, mbPix, bits, backward, spatial_temporal_weight_code) {
        y >>= 1;
        var field = bits.read1Bit();
        this.predictGeneric(reference, x, y, bits, backward, mbPix, 0, 16, 8, 1, field, 1, 0, 1);
        if (spatial_temporal_weight_code == 0 || spatial_temporal_weight_code == 1) {
            field = bits.read1Bit();
            this.predictGeneric(reference, x, y, bits, backward, mbPix, 1, 16, 8, 1, field, 1, 1, 1);
        } else {
            this.mvPred[1][backward][0] = this.mvPred[0][backward][0];
            this.mvPred[1][backward][1] = this.mvPred[0][backward][1];
            this.predictMB(reference, this.mvPred[1][backward][0], 0, this.mvPred[1][backward][1], 0, 16, 8, 1, 1 - field, mbPix, 1, 1);
        }
    };
    prototype.predictMB = function(ref, refX, vectX, refY, vectY, blkW, blkH, refVertStep, refVertOff, tgt, tgtY, tgtVertStep) {
        var ch = this.chromaFormat == SequenceExtension.Chroma420 ? 1 : 0;
        var cw = this.chromaFormat == SequenceExtension.Chroma444 ? 0 : 1;
        var sh = this.chromaFormat == SequenceExtension.Chroma420 ? 2 : 1;
        var sw = this.chromaFormat == SequenceExtension.Chroma444 ? 1 : 2;
        this.predictPlane(ref.getPlaneData(0), refX + vectX, refY + vectY, ref.getPlaneWidth(0), ref.getPlaneHeight(0), refVertStep, refVertOff, tgt[0], tgtY, blkW, blkH, tgtVertStep);
        this.predictPlane(ref.getPlaneData(1), (refX >> cw) + stjs.trunc(vectX / sw), (refY >> ch) + stjs.trunc(vectY / sh), ref.getPlaneWidth(1), ref.getPlaneHeight(1), refVertStep, refVertOff, tgt[1], tgtY, blkW >> cw, blkH >> ch, tgtVertStep);
        this.predictPlane(ref.getPlaneData(2), (refX >> cw) + stjs.trunc(vectX / sw), (refY >> ch) + stjs.trunc(vectY / sh), ref.getPlaneWidth(2), ref.getPlaneHeight(2), refVertStep, refVertOff, tgt[2], tgtY, blkW >> cw, blkH >> ch, tgtVertStep);
    };
    prototype.predict16x16NoMV = function(picture, x, y, pictureStructure, backward, mbPix) {
        if (pictureStructure == 3) {
            this.predictMB(picture, (x << 1), this.mvPred[0][backward][0], (y << 1), this.mvPred[0][backward][1], 16, 16, 0, 0, mbPix, 0, 0);
        } else 
            this.predictMB(picture, (x << 1), this.mvPred[0][backward][0], (y << 1), this.mvPred[0][backward][1], 16, 16, 1, pictureStructure - 1, mbPix, 0, 0);
    };
    prototype.reset = function() {
        this.mvPred[0][0][0] = this.mvPred[0][0][1] = this.mvPred[0][1][0] = this.mvPred[0][1][1] = this.mvPred[1][0][0] = this.mvPred[1][0][1] = this.mvPred[1][1][0] = this.mvPred[1][1][1] = 0;
    };
}, {mvPred: "Array", fCode: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var SequenceScalableExtension = function() {};
SequenceScalableExtension = stjs.extend(SequenceScalableExtension, null, [MPEGHeader], function(constructor, prototype) {
    constructor.DATA_PARTITIONING = 0;
    constructor.SPATIAL_SCALABILITY = 1;
    constructor.SNR_SCALABILITY = 2;
    constructor.TEMPORAL_SCALABILITY = 3;
    prototype.scalable_mode = 0;
    prototype.layer_id = 0;
    prototype.lower_layer_prediction_horizontal_size = 0;
    prototype.lower_layer_prediction_vertical_size = 0;
    prototype.horizontal_subsampling_factor_m = 0;
    prototype.horizontal_subsampling_factor_n = 0;
    prototype.vertical_subsampling_factor_m = 0;
    prototype.vertical_subsampling_factor_n = 0;
    prototype.picture_mux_enable = 0;
    prototype.mux_to_progressive_sequence = 0;
    prototype.picture_mux_order = 0;
    prototype.picture_mux_factor = 0;
    constructor.Sequence_Scalable_Extension = 5;
    constructor.read = function(_in) {
        var sse = new SequenceScalableExtension();
        sse.scalable_mode = _in.readNBit(2);
        sse.layer_id = _in.readNBit(4);
        if (sse.scalable_mode == SequenceScalableExtension.SPATIAL_SCALABILITY) {
            sse.lower_layer_prediction_horizontal_size = _in.readNBit(14);
            _in.read1Bit();
            sse.lower_layer_prediction_vertical_size = _in.readNBit(14);
            sse.horizontal_subsampling_factor_m = _in.readNBit(5);
            sse.horizontal_subsampling_factor_n = _in.readNBit(5);
            sse.vertical_subsampling_factor_m = _in.readNBit(5);
            sse.vertical_subsampling_factor_n = _in.readNBit(5);
        }
        if (sse.scalable_mode == SequenceScalableExtension.TEMPORAL_SCALABILITY) {
            sse.picture_mux_enable = _in.read1Bit();
            if (sse.picture_mux_enable != 0) 
                sse.mux_to_progressive_sequence = _in.read1Bit();
            sse.picture_mux_order = _in.readNBit(3);
            sse.picture_mux_factor = _in.readNBit(3);
        }
        return sse;
    };
    prototype.write = function(bb) {
        var bw = new BitWriter(bb);
        bw.writeNBit(SequenceScalableExtension.Sequence_Scalable_Extension, 4);
        bw.writeNBit(this.scalable_mode, 2);
        bw.writeNBit(this.layer_id, 4);
        if (this.scalable_mode == SequenceScalableExtension.SPATIAL_SCALABILITY) {
            bw.writeNBit(this.lower_layer_prediction_horizontal_size, 14);
            bw.write1Bit(1);
            bw.writeNBit(this.lower_layer_prediction_vertical_size, 14);
            bw.writeNBit(this.horizontal_subsampling_factor_m, 5);
            bw.writeNBit(this.horizontal_subsampling_factor_n, 5);
            bw.writeNBit(this.vertical_subsampling_factor_m, 5);
            bw.writeNBit(this.vertical_subsampling_factor_n, 5);
        }
        if (this.scalable_mode == SequenceScalableExtension.TEMPORAL_SCALABILITY) {
            bw.write1Bit(this.picture_mux_enable);
            if (this.picture_mux_enable != 0) 
                bw.write1Bit(this.mux_to_progressive_sequence);
            bw.writeNBit(this.picture_mux_order, 3);
            bw.writeNBit(this.picture_mux_factor, 3);
        }
        bw.flush();
    };
    constructor.mbTypeVal = function(picture_coding_type, sse) {
        if (sse != null && sse.scalable_mode == SequenceScalableExtension.SNR_SCALABILITY) {
            return MPEGConst.mbTypeValSNR;
        } else if (sse != null && sse.scalable_mode == SequenceScalableExtension.SPATIAL_SCALABILITY) {
            return picture_coding_type == MPEGConst.IntraCoded ? MPEGConst.mbTypeValISpat : (picture_coding_type == MPEGConst.PredictiveCoded ? MPEGConst.mbTypeValPSpat : MPEGConst.mbTypeValBSpat);
        } else {
            return picture_coding_type == MPEGConst.IntraCoded ? MPEGConst.mbTypeValI : (picture_coding_type == MPEGConst.PredictiveCoded ? MPEGConst.mbTypeValP : MPEGConst.mbTypeValB);
        }
    };
    constructor.vlcMBType = function(picture_coding_type, sse) {
        if (sse != null && sse.scalable_mode == SequenceScalableExtension.SNR_SCALABILITY) {
            return MPEGConst.vlcMBTypeSNR;
        } else if (sse != null && sse.scalable_mode == SequenceScalableExtension.SPATIAL_SCALABILITY) {
            return picture_coding_type == MPEGConst.IntraCoded ? MPEGConst.vlcMBTypeISpat : (picture_coding_type == MPEGConst.PredictiveCoded ? MPEGConst.vlcMBTypePSpat : MPEGConst.vlcMBTypeBSpat);
        } else {
            return picture_coding_type == MPEGConst.IntraCoded ? MPEGConst.vlcMBTypeI : (picture_coding_type == MPEGConst.PredictiveCoded ? MPEGConst.vlcMBTypeP : MPEGConst.vlcMBTypeB);
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Prediction builder class for intra 16x16 coded macroblocks
 *  
 *  
 *  @author The JCodec project
 *  
 */
var Intra16x16PredictionBuilder = function() {};
Intra16x16PredictionBuilder = stjs.extend(Intra16x16PredictionBuilder, null, [], function(constructor, prototype) {
    constructor.predictWithMode = function(predMode, residual, leftAvailable, topAvailable, leftRow, topLine, topLeft, x, pixOut) {
        switch (predMode) {
            case 0:
                Intra16x16PredictionBuilder.predictVertical(residual, topAvailable, topLine, x, pixOut);
                break;
            case 1:
                Intra16x16PredictionBuilder.predictHorizontal(residual, leftAvailable, leftRow, x, pixOut);
                break;
            case 2:
                Intra16x16PredictionBuilder.predictDC(residual, leftAvailable, topAvailable, leftRow, topLine, x, pixOut);
                break;
            case 3:
                Intra16x16PredictionBuilder.predictPlane(residual, leftAvailable, topAvailable, leftRow, topLine, topLeft, x, pixOut);
                break;
        }
    };
    constructor.predictVertical = function(residual, topAvailable, topLine, x, pixOut) {
        var off = 0;
        for (var j = 0; j < 16; j++) {
            for (var i = 0; i < 16; i++ , off++) 
                pixOut[off] = (MathUtil.clip(residual[H264Const.LUMA_4x4_BLOCK_LUT[off]][H264Const.LUMA_4x4_POS_LUT[off]] + topLine[x + i], -128, 127) << 24 >> 24);
        }
    };
    constructor.predictHorizontal = function(residual, leftAvailable, leftRow, x, pixOut) {
        var off = 0;
        for (var j = 0; j < 16; j++) {
            for (var i = 0; i < 16; i++ , off++) 
                pixOut[off] = (MathUtil.clip(residual[H264Const.LUMA_4x4_BLOCK_LUT[off]][H264Const.LUMA_4x4_POS_LUT[off]] + leftRow[j], -128, 127) << 24 >> 24);
        }
    };
    constructor.predictDC = function(residual, leftAvailable, topAvailable, leftRow, topLine, x, pixOut) {
        var s0;
        if (leftAvailable && topAvailable) {
            s0 = 0;
            for (var i = 0; i < 16; i++) 
                s0 += leftRow[i];
            for (var i = 0; i < 16; i++) 
                s0 += topLine[x + i];
            s0 = (s0 + 16) >> 5;
        } else if (leftAvailable) {
            s0 = 0;
            for (var i = 0; i < 16; i++) 
                s0 += leftRow[i];
            s0 = (s0 + 8) >> 4;
        } else if (topAvailable) {
            s0 = 0;
            for (var i = 0; i < 16; i++) 
                s0 += topLine[x + i];
            s0 = (s0 + 8) >> 4;
        } else {
            s0 = 0;
        }
        for (var i = 0; i < 256; i++) 
            pixOut[i] = (MathUtil.clip(residual[H264Const.LUMA_4x4_BLOCK_LUT[i]][H264Const.LUMA_4x4_POS_LUT[i]] + s0, -128, 127) << 24 >> 24);
    };
    constructor.predictPlane = function(residual, leftAvailable, topAvailable, leftRow, topLine, topLeft, x, pixOut) {
        var H = 0;
        for (var i = 0; i < 7; i++) {
            H += (i + 1) * (topLine[x + 8 + i] - topLine[x + 6 - i]);
        }
        H += 8 * (topLine[x + 15] - topLeft[0]);
        var V = 0;
        for (var j = 0; j < 7; j++) {
            V += (j + 1) * (leftRow[8 + j] - leftRow[6 - j]);
        }
        V += 8 * (leftRow[15] - topLeft[0]);
        var c = (5 * V + 32) >> 6;
        var b = (5 * H + 32) >> 6;
        var a = 16 * (leftRow[15] + topLine[x + 15]);
        var off = 0;
        for (var j = 0; j < 16; j++) {
            for (var i = 0; i < 16; i++ , off++) {
                var val = MathUtil.clip((a + b * (i - 7) + c * (j - 7) + 16) >> 5, -128, 127);
                pixOut[off] = (MathUtil.clip(residual[H264Const.LUMA_4x4_BLOCK_LUT[off]][H264Const.LUMA_4x4_POS_LUT[off]] + val, -128, 127) << 24 >> 24);
            }
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Prediction builder for chroma samples
 *  
 *  @author The JCodec project
 *  
 */
var ChromaPredictionBuilder = function() {};
ChromaPredictionBuilder = stjs.extend(ChromaPredictionBuilder, null, [], function(constructor, prototype) {
    constructor.predictWithMode = function(residual, chromaMode, mbX, leftAvailable, topAvailable, leftRow, topLine, topLeft, pixOut) {
        switch (chromaMode) {
            case 0:
                ChromaPredictionBuilder.predictDC(residual, mbX, leftAvailable, topAvailable, leftRow, topLine, pixOut);
                break;
            case 1:
                ChromaPredictionBuilder.predictHorizontal(residual, mbX, leftAvailable, leftRow, pixOut);
                break;
            case 2:
                ChromaPredictionBuilder.predictVertical(residual, mbX, topAvailable, topLine, pixOut);
                break;
            case 3:
                ChromaPredictionBuilder.predictPlane(residual, mbX, leftAvailable, topAvailable, leftRow, topLine, topLeft, pixOut);
                break;
        }
    };
    constructor.predictDC = function(planeData, mbX, leftAvailable, topAvailable, leftRow, topLine, pixOut) {
        ChromaPredictionBuilder.predictDCInside(planeData, 0, 0, mbX, leftAvailable, topAvailable, leftRow, topLine, pixOut);
        ChromaPredictionBuilder.predictDCTopBorder(planeData, 1, 0, mbX, leftAvailable, topAvailable, leftRow, topLine, pixOut);
        ChromaPredictionBuilder.predictDCLeftBorder(planeData, 0, 1, mbX, leftAvailable, topAvailable, leftRow, topLine, pixOut);
        ChromaPredictionBuilder.predictDCInside(planeData, 1, 1, mbX, leftAvailable, topAvailable, leftRow, topLine, pixOut);
    };
    constructor.predictVertical = function(residual, mbX, topAvailable, topLine, pixOut) {
        for (var off = 0, j = 0; j < 8; j++) {
            for (var i = 0; i < 8; i++ , off++) 
                pixOut[off] = (MathUtil.clip(residual[H264Const.CHROMA_BLOCK_LUT[off]][H264Const.CHROMA_POS_LUT[off]] + topLine[(mbX << 3) + i], -128, 127) << 24 >> 24);
        }
    };
    constructor.predictHorizontal = function(residual, mbX, leftAvailable, leftRow, pixOut) {
        for (var off = 0, j = 0; j < 8; j++) {
            for (var i = 0; i < 8; i++ , off++) 
                pixOut[off] = (MathUtil.clip(residual[H264Const.CHROMA_BLOCK_LUT[off]][H264Const.CHROMA_POS_LUT[off]] + leftRow[j], -128, 127) << 24 >> 24);
        }
    };
    constructor.predictDCInside = function(residual, blkX, blkY, mbX, leftAvailable, topAvailable, leftRow, topLine, pixOut) {
        var s0, blkOffX = (blkX << 2) + (mbX << 3), blkOffY = blkY << 2;
        if (leftAvailable && topAvailable) {
            s0 = 0;
            for (var i = 0; i < 4; i++) 
                s0 += leftRow[i + blkOffY];
            for (var i = 0; i < 4; i++) 
                s0 += topLine[blkOffX + i];
            s0 = (s0 + 4) >> 3;
        } else if (leftAvailable) {
            s0 = 0;
            for (var i = 0; i < 4; i++) 
                s0 += leftRow[blkOffY + i];
            s0 = (s0 + 2) >> 2;
        } else if (topAvailable) {
            s0 = 0;
            for (var i = 0; i < 4; i++) 
                s0 += topLine[blkOffX + i];
            s0 = (s0 + 2) >> 2;
        } else {
            s0 = 0;
        }
        for (var off = (blkY << 5) + (blkX << 2), j = 0; j < 4; j++ , off += 8) {
            pixOut[off] = (MathUtil.clip(residual[H264Const.CHROMA_BLOCK_LUT[off]][H264Const.CHROMA_POS_LUT[off]] + s0, -128, 127) << 24 >> 24);
            pixOut[off + 1] = (MathUtil.clip(residual[H264Const.CHROMA_BLOCK_LUT[off + 1]][H264Const.CHROMA_POS_LUT[off + 1]] + s0, -128, 127) << 24 >> 24);
            pixOut[off + 2] = (MathUtil.clip(residual[H264Const.CHROMA_BLOCK_LUT[off + 2]][H264Const.CHROMA_POS_LUT[off + 2]] + s0, -128, 127) << 24 >> 24);
            pixOut[off + 3] = (MathUtil.clip(residual[H264Const.CHROMA_BLOCK_LUT[off + 3]][H264Const.CHROMA_POS_LUT[off + 3]] + s0, -128, 127) << 24 >> 24);
        }
    };
    constructor.predictDCTopBorder = function(residual, blkX, blkY, mbX, leftAvailable, topAvailable, leftRow, topLine, pixOut) {
        var s1, blkOffX = (blkX << 2) + (mbX << 3), blkOffY = blkY << 2;
        if (topAvailable) {
            s1 = 0;
            for (var i = 0; i < 4; i++) 
                s1 += topLine[blkOffX + i];
            s1 = (s1 + 2) >> 2;
        } else if (leftAvailable) {
            s1 = 0;
            for (var i = 0; i < 4; i++) 
                s1 += leftRow[blkOffY + i];
            s1 = (s1 + 2) >> 2;
        } else {
            s1 = 0;
        }
        for (var off = (blkY << 5) + (blkX << 2), j = 0; j < 4; j++ , off += 8) {
            pixOut[off] = (MathUtil.clip(residual[H264Const.CHROMA_BLOCK_LUT[off]][H264Const.CHROMA_POS_LUT[off]] + s1, -128, 127) << 24 >> 24);
            pixOut[off + 1] = (MathUtil.clip(residual[H264Const.CHROMA_BLOCK_LUT[off + 1]][H264Const.CHROMA_POS_LUT[off + 1]] + s1, -128, 127) << 24 >> 24);
            pixOut[off + 2] = (MathUtil.clip(residual[H264Const.CHROMA_BLOCK_LUT[off + 2]][H264Const.CHROMA_POS_LUT[off + 2]] + s1, -128, 127) << 24 >> 24);
            pixOut[off + 3] = (MathUtil.clip(residual[H264Const.CHROMA_BLOCK_LUT[off + 3]][H264Const.CHROMA_POS_LUT[off + 3]] + s1, -128, 127) << 24 >> 24);
        }
    };
    constructor.predictDCLeftBorder = function(residual, blkX, blkY, mbX, leftAvailable, topAvailable, leftRow, topLine, pixOut) {
        var s2, blkOffX = (blkX << 2) + (mbX << 3), blkOffY = blkY << 2;
        if (leftAvailable) {
            s2 = 0;
            for (var i = 0; i < 4; i++) 
                s2 += leftRow[blkOffY + i];
            s2 = (s2 + 2) >> 2;
        } else if (topAvailable) {
            s2 = 0;
            for (var i = 0; i < 4; i++) 
                s2 += topLine[blkOffX + i];
            s2 = (s2 + 2) >> 2;
        } else {
            s2 = 0;
        }
        for (var off = (blkY << 5) + (blkX << 2), j = 0; j < 4; j++ , off += 8) {
            pixOut[off] = (MathUtil.clip(residual[H264Const.CHROMA_BLOCK_LUT[off]][H264Const.CHROMA_POS_LUT[off]] + s2, -128, 127) << 24 >> 24);
            pixOut[off + 1] = (MathUtil.clip(residual[H264Const.CHROMA_BLOCK_LUT[off + 1]][H264Const.CHROMA_POS_LUT[off + 1]] + s2, -128, 127) << 24 >> 24);
            pixOut[off + 2] = (MathUtil.clip(residual[H264Const.CHROMA_BLOCK_LUT[off + 2]][H264Const.CHROMA_POS_LUT[off + 2]] + s2, -128, 127) << 24 >> 24);
            pixOut[off + 3] = (MathUtil.clip(residual[H264Const.CHROMA_BLOCK_LUT[off + 3]][H264Const.CHROMA_POS_LUT[off + 3]] + s2, -128, 127) << 24 >> 24);
        }
    };
    constructor.predictPlane = function(residual, mbX, leftAvailable, topAvailable, leftRow, topLine, topLeft, pixOut) {
        var H = 0, blkOffX = (mbX << 3);
        for (var i = 0; i < 3; i++) {
            H += (i + 1) * (topLine[blkOffX + 4 + i] - topLine[blkOffX + 2 - i]);
        }
        H += 4 * (topLine[blkOffX + 7] - topLeft[0]);
        var V = 0;
        for (var j = 0; j < 3; j++) {
            V += (j + 1) * (leftRow[4 + j] - leftRow[2 - j]);
        }
        V += 4 * (leftRow[7] - topLeft[0]);
        var c = (34 * V + 32) >> 6;
        var b = (34 * H + 32) >> 6;
        var a = 16 * (leftRow[7] + topLine[blkOffX + 7]);
        for (var off = 0, j = 0; j < 8; j++) {
            for (var i = 0; i < 8; i++ , off++) {
                var val = (a + b * (i - 3) + c * (j - 3) + 16) >> 5;
                pixOut[off] = (MathUtil.clip(residual[H264Const.CHROMA_BLOCK_LUT[off]][H264Const.CHROMA_POS_LUT[off]] + MathUtil.clip(val, -128, 127), -128, 127) << 24 >> 24);
            }
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author JCodec project
 *  
 */
var CABAC = function(mbWidth) {
    this.tmp = new Int32Array(16);
    this.chromaPredModeLeft = 0;
    this.chromaPredModeTop = new Int32Array(mbWidth);
    this.codedBlkLeft = [new Int32Array(4), new Int32Array(2), new Int32Array(2)];
    this.codedBlkTop = [new Int32Array(mbWidth << 2), new Int32Array(mbWidth << 1), new Int32Array(mbWidth << 1)];
    this.codedBlkDCLeft = new Int32Array(3);
    this.codedBlkDCTop = Array.apply(null, Array(3)).map(function() {
        return new Int32Array(mbWidth);
    });
    this.refIdxLeft = Array.apply(null, Array(2)).map(function() {
        return new Int32Array(4);
    });
    this.refIdxTop = Array.apply(null, Array(2)).map(function() {
        return new Int32Array(mbWidth << 2);
    });
    this.skipFlagsTop = new Int8Array(mbWidth);
    this.mvdTop = Array.apply(null, Array(2)).map(function() {
        return Array.apply(null, Array(2)).map(function() {
            return new Int32Array(mbWidth << 2);
        });
    });
    this.mvdLeft = Array.apply(null, Array(2)).map(function() {
        return Array.apply(null, Array(2)).map(function() {
            return new Int32Array(4);
        });
    });
};
CABAC = stjs.extend(CABAC, null, [], function(constructor, prototype) {
    constructor.BlockType = function(codecBlockCtxOff, sigCoeffCtxOff, lastSigCoeffCtxOff, sigCoeffFlagFldCtxOff, lastSigCoeffFldCtxOff, coeffAbsLevelCtxOff, coeffAbsLevelAdjust) {
        this.codedBlockCtxOff = codecBlockCtxOff;
        this.sigCoeffFlagCtxOff = sigCoeffCtxOff;
        this.lastSigCoeffCtxOff = lastSigCoeffCtxOff;
        this.sigCoeffFlagFldCtxOff = sigCoeffFlagFldCtxOff;
        this.lastSigCoeffFldCtxOff = sigCoeffFlagFldCtxOff;
        this.coeffAbsLevelCtxOff = coeffAbsLevelCtxOff;
        this.coeffAbsLevelAdjust = coeffAbsLevelAdjust;
    };
    constructor.BlockType = stjs.extend(constructor.BlockType, null, [], function(constructor, prototype) {
        constructor.LUMA_16_DC = new CABAC.BlockType(85, 105, 166, 277, 338, 227, 0);
        constructor.LUMA_15_AC = new CABAC.BlockType(89, 120, 181, 292, 353, 237, 0);
        constructor.LUMA_16 = new CABAC.BlockType(93, 134, 195, 306, 367, 247, 0);
        constructor.CHROMA_DC = new CABAC.BlockType(97, 149, 210, 321, 382, 257, 1);
        constructor.CHROMA_AC = new CABAC.BlockType(101, 152, 213, 324, 385, 266, 0);
        constructor.LUMA_64 = new CABAC.BlockType(1012, 402, 417, 436, 451, 426, 0);
        constructor.CB_16_DC = new CABAC.BlockType(460, 484, 572, 776, 864, 952, 0);
        constructor.CB_15x16_AC = new CABAC.BlockType(464, 499, 587, 791, 879, 962, 0);
        constructor.CB_16 = new CABAC.BlockType(468, 513, 601, 805, 893, 972, 0);
        constructor.CB_64 = new CABAC.BlockType(1016, 660, 690, 675, 699, 708, 0);
        constructor.CR_16_DC = new CABAC.BlockType(472, 528, 616, 820, 908, 982, 0);
        constructor.CR_15x16_AC = new CABAC.BlockType(476, 543, 631, 835, 923, 992, 0);
        constructor.CR_16 = new CABAC.BlockType(480, 557, 645, 849, 937, 1002, 0);
        constructor.CR_64 = new CABAC.BlockType(1020, 718, 748, 733, 757, 766, 0);
        prototype.codedBlockCtxOff = 0;
        prototype.sigCoeffFlagCtxOff = 0;
        prototype.lastSigCoeffCtxOff = 0;
        prototype.sigCoeffFlagFldCtxOff = 0;
        prototype.lastSigCoeffFldCtxOff = 0;
        prototype.coeffAbsLevelCtxOff = 0;
        prototype.coeffAbsLevelAdjust = 0;
    }, {LUMA_16_DC: "CABAC.BlockType", LUMA_15_AC: "CABAC.BlockType", LUMA_16: "CABAC.BlockType", CHROMA_DC: "CABAC.BlockType", CHROMA_AC: "CABAC.BlockType", LUMA_64: "CABAC.BlockType", CB_16_DC: "CABAC.BlockType", CB_15x16_AC: "CABAC.BlockType", CB_16: "CABAC.BlockType", CB_64: "CABAC.BlockType", CR_16_DC: "CABAC.BlockType", CR_15x16_AC: "CABAC.BlockType", CR_16: "CABAC.BlockType", CR_64: "CABAC.BlockType"}, {});
    prototype.chromaPredModeLeft = 0;
    prototype.chromaPredModeTop = null;
    prototype.prevMbQpDelta = 0;
    prototype.prevCBP = 0;
    prototype.codedBlkLeft = null;
    prototype.codedBlkTop = null;
    prototype.codedBlkDCLeft = null;
    prototype.codedBlkDCTop = null;
    prototype.refIdxLeft = null;
    prototype.refIdxTop = null;
    prototype.skipFlagLeft = false;
    prototype.skipFlagsTop = null;
    prototype.mvdTop = null;
    prototype.mvdLeft = null;
    prototype.tmp = null;
    prototype.readCoeffs = function(decoder, blockType, out, first, num, reorder, scMapping, lscMapping) {
        var sigCoeff = new Int8Array(num);
        var numCoeff;
        for (numCoeff = 0; numCoeff < num - 1; numCoeff++) {
            sigCoeff[numCoeff] = decoder.decodeBin(blockType.sigCoeffFlagCtxOff + scMapping[numCoeff]) == 1;
            if (sigCoeff[numCoeff] && decoder.decodeBin(blockType.lastSigCoeffCtxOff + lscMapping[numCoeff]) == 1) 
                break;
        }
        sigCoeff[numCoeff++] = true;
        var numGt1 = 0, numEq1 = 0;
        for (var j = numCoeff - 1; j >= 0; j--) {
            if (!sigCoeff[j]) 
                continue;
            var absLev = this.readCoeffAbsLevel(decoder, blockType, numGt1, numEq1);
            if (absLev == 0) 
                ++numEq1;
             else 
                ++numGt1;
            out[reorder[j + first]] = MathUtil.toSigned(absLev + 1, -decoder.decodeBinBypass());
        }
        return numGt1 + numEq1;
    };
    prototype.readCoeffAbsLevel = function(decoder, blockType, numDecodAbsLevelGt1, numDecodAbsLevelEq1) {
        var incB0 = ((numDecodAbsLevelGt1 != 0) ? 0 : Math.min(4, 1 + numDecodAbsLevelEq1));
        var incBN = 5 + Math.min(4 - blockType.coeffAbsLevelAdjust, numDecodAbsLevelGt1);
        var val, b = decoder.decodeBin(blockType.coeffAbsLevelCtxOff + incB0);
        for (val = 0; b != 0 && val < 13; val++) 
            b = decoder.decodeBin(blockType.coeffAbsLevelCtxOff + incBN);
        val += b;
        if (val == 14) {
            var log = -2, add = 0, sum = 0;
            do {
                log++;
                b = decoder.decodeBinBypass();
            } while (b != 0);
            for (; log >= 0; log--) {
                add |= decoder.decodeBinBypass() << log;
                sum += 1 << log;
            }
            val += add + sum;
        }
        return val;
    };
    prototype.writeCoeffs = function(encoder, blockType, _out, first, num, reorder) {
        for (var i = 0; i < num; i++) 
            this.tmp[i] = _out[reorder[first + i]];
        var numCoeff = 0;
        for (var i = 0; i < num; i++) {
            if (this.tmp[i] != 0) 
                numCoeff = i + 1;
        }
        for (var i = 0; i < Math.min(numCoeff, num - 1); i++) {
            if (this.tmp[i] != 0) {
                encoder.encodeBin(blockType.sigCoeffFlagCtxOff + i, 1);
                encoder.encodeBin(blockType.lastSigCoeffCtxOff + i, i == numCoeff - 1 ? 1 : 0);
            } else {
                encoder.encodeBin(blockType.sigCoeffFlagCtxOff + i, 0);
            }
        }
        var numGt1 = 0, numEq1 = 0;
        for (var j = numCoeff - 1; j >= 0; j--) {
            if (this.tmp[j] == 0) 
                continue;
            var absLev = MathUtil.abs(this.tmp[j]) - 1;
            this.writeCoeffAbsLevel(encoder, blockType, numGt1, numEq1, absLev);
            if (absLev == 0) 
                ++numEq1;
             else 
                ++numGt1;
            encoder.encodeBinBypass(MathUtil.sign(this.tmp[j]));
        }
    };
    prototype.writeCoeffAbsLevel = function(encoder, blockType, numDecodAbsLevelGt1, numDecodAbsLevelEq1, absLev) {
        var incB0 = ((numDecodAbsLevelGt1 != 0) ? 0 : Math.min(4, 1 + numDecodAbsLevelEq1));
        var incBN = 5 + Math.min(4 - blockType.coeffAbsLevelAdjust, numDecodAbsLevelGt1);
        if (absLev == 0) {
            encoder.encodeBin(blockType.coeffAbsLevelCtxOff + incB0, 0);
        } else {
            encoder.encodeBin(blockType.coeffAbsLevelCtxOff + incB0, 1);
            if (absLev < 14) {
                for (var i = 1; i < absLev; i++) 
                    encoder.encodeBin(blockType.coeffAbsLevelCtxOff + incBN, 1);
                encoder.encodeBin(blockType.coeffAbsLevelCtxOff + incBN, 0);
            } else {
                for (var i = 1; i < 14; i++) 
                    encoder.encodeBin(blockType.coeffAbsLevelCtxOff + incBN, 1);
                absLev -= 14;
                var sufLen, pow;
                for (sufLen = 0 , pow = 1; absLev >= pow; sufLen++ , pow = (1 << sufLen)) {
                    encoder.encodeBinBypass(1);
                    absLev -= pow;
                }
                encoder.encodeBinBypass(0);
                for (sufLen--; sufLen >= 0; sufLen--) 
                    encoder.encodeBinBypass((absLev >> sufLen) & 1);
            }
        }
    };
    prototype.initModels = function(cm, sliceType, cabacIdc, sliceQp) {
        var tabA = sliceType.isIntra() ? CABACContst.cabac_context_init_I_A : CABACContst.cabac_context_init_PB_A[cabacIdc];
        var tabB = sliceType.isIntra() ? CABACContst.cabac_context_init_I_B : CABACContst.cabac_context_init_PB_B[cabacIdc];
        for (var i = 0; i < 1024; i++) {
            var preCtxState = MathUtil.clip(((tabA[i] * MathUtil.clip(sliceQp, 0, 51)) >> 4) + tabB[i], 1, 126);
            if (preCtxState <= 63) {
                cm[0][i] = 63 - preCtxState;
                cm[1][i] = 0;
            } else {
                cm[0][i] = preCtxState - 64;
                cm[1][i] = 1;
            }
        }
    };
    prototype.readMBTypeI = function(decoder, left, top, leftAvailable, topAvailable) {
        var ctx = 3;
        ctx += !leftAvailable || left == MBType.I_NxN ? 0 : 1;
        ctx += !topAvailable || top == MBType.I_NxN ? 0 : 1;
        if (decoder.decodeBin(ctx) == 0) {
            return 0;
        } else {
            return decoder.decodeFinalBin() == 1 ? 25 : 1 + this.readMBType16x16(decoder);
        }
    };
    prototype.readMBType16x16 = function(decoder) {
        var type = decoder.decodeBin(6) * 12;
        if (decoder.decodeBin(7) == 0) {
            return type + (decoder.decodeBin(9) << 1) + decoder.decodeBin(10);
        } else {
            return type + (decoder.decodeBin(8) << 2) + (decoder.decodeBin(9) << 1) + decoder.decodeBin(10) + 4;
        }
    };
    prototype.readMBTypeP = function(decoder) {
        if (decoder.decodeBin(14) == 1) {
            return 5 + this.readIntraP(decoder, 17);
        } else {
            if (decoder.decodeBin(15) == 0) {
                return decoder.decodeBin(16) == 0 ? 0 : 3;
            } else {
                return decoder.decodeBin(17) == 0 ? 2 : 1;
            }
        }
    };
    prototype.readIntraP = function(decoder, ctxOff) {
        if (decoder.decodeBin(ctxOff) == 0) {
            return 0;
        } else {
            return decoder.decodeFinalBin() == 1 ? 25 : 1 + this.readMBType16x16P(decoder, ctxOff);
        }
    };
    prototype.readMBType16x16P = function(decoder, ctxOff) {
        ctxOff++;
        var type = decoder.decodeBin(ctxOff) * 12;
        ctxOff++;
        if (decoder.decodeBin(ctxOff) == 0) {
            ctxOff++;
            return type + (decoder.decodeBin(ctxOff) << 1) + decoder.decodeBin(ctxOff);
        } else {
            return type + (decoder.decodeBin(ctxOff) << 2) + (decoder.decodeBin(ctxOff + 1) << 1) + decoder.decodeBin(ctxOff + 1) + 4;
        }
    };
    prototype.readMBTypeB = function(mDecoder, left, top, leftAvailable, topAvailable) {
        var ctx = 27;
        ctx += !leftAvailable || left == null || left == MBType.B_Direct_16x16 ? 0 : 1;
        ctx += !topAvailable || top == null || top == MBType.B_Direct_16x16 ? 0 : 1;
        if (mDecoder.decodeBin(ctx) == 0) 
            return 0;
        if (mDecoder.decodeBin(30) == 0) 
            return 1 + mDecoder.decodeBin(32);
        var b1 = mDecoder.decodeBin(31);
        if (b1 == 0) {
            return 3 + ((mDecoder.decodeBin(32) << 2) | (mDecoder.decodeBin(32) << 1) | mDecoder.decodeBin(32));
        } else {
            if (mDecoder.decodeBin(32) == 0) {
                return 12 + ((mDecoder.decodeBin(32) << 2) | (mDecoder.decodeBin(32) << 1) | mDecoder.decodeBin(32));
            } else {
                switch ((mDecoder.decodeBin(32) << 1) + mDecoder.decodeBin(32)) {
                    case 0:
                        return 20 + mDecoder.decodeBin(32);
                    case 1:
                        return 23 + this.readIntraP(mDecoder, 32);
                    case 2:
                        return 11;
                    case 3:
                        return 22;
                }
            }
        }
        return 0;
    };
    prototype.writeMBTypeI = function(encoder, left, top, leftAvailable, topAvailable, mbType) {
        var ctx = 3;
        ctx += !leftAvailable || left == MBType.I_NxN ? 0 : 1;
        ctx += !topAvailable || top == MBType.I_NxN ? 0 : 1;
        if (mbType == 0) 
            encoder.encodeBin(ctx, 0);
         else {
            encoder.encodeBin(ctx, 1);
            if (mbType == 25) 
                encoder.encodeBinFinal(1);
             else {
                encoder.encodeBinFinal(0);
                this.writeMBType16x16(encoder, mbType - 1);
            }
        }
    };
    prototype.writeMBType16x16 = function(encoder, mbType) {
        if (mbType < 12) {
            encoder.encodeBin(6, 0);
        } else {
            encoder.encodeBin(6, 1);
            mbType -= 12;
        }
        if (mbType < 4) {
            encoder.encodeBin(7, 0);
            encoder.encodeBin(9, mbType >> 1);
            encoder.encodeBin(10, mbType & 1);
        } else {
            mbType -= 4;
            encoder.encodeBin(7, 1);
            encoder.encodeBin(8, mbType >> 2);
            encoder.encodeBin(9, (mbType >> 1) & 1);
            encoder.encodeBin(10, mbType & 1);
        }
    };
    prototype.readMBQpDelta = function(decoder, prevMbType) {
        var ctx = 60;
        ctx += prevMbType == null || prevMbType == MBType.I_PCM || (prevMbType != MBType.I_16x16 && this.prevCBP == 0) || this.prevMbQpDelta == 0 ? 0 : 1;
        var val = 0;
        if (decoder.decodeBin(ctx) == 1) {
            val++;
            if (decoder.decodeBin(62) == 1) {
                val++;
                 while (decoder.decodeBin(63) == 1)
                    val++;
            }
        }
        this.prevMbQpDelta = H264Utils2.golomb2Signed(val);
        return this.prevMbQpDelta;
    };
    prototype.writeMBQpDelta = function(encoder, prevMbType, mbQpDelta) {
        var ctx = 60;
        ctx += prevMbType == null || prevMbType == MBType.I_PCM || (prevMbType != MBType.I_16x16 && this.prevCBP == 0) || this.prevMbQpDelta == 0 ? 0 : 1;
        this.prevMbQpDelta = mbQpDelta;
        if (mbQpDelta-- == 0) 
            encoder.encodeBin(ctx, 0);
         else {
            encoder.encodeBin(ctx, 1);
            if (mbQpDelta-- == 0) 
                encoder.encodeBin(62, 0);
             else {
                 while (mbQpDelta-- > 0)
                    encoder.encodeBin(63, 1);
                encoder.encodeBin(63, 0);
            }
        }
    };
    prototype.readIntraChromaPredMode = function(decoder, mbX, left, top, leftAvailable, topAvailable) {
        var ctx = 64;
        ctx += !leftAvailable || left == null || !left.isIntra() || this.chromaPredModeLeft == 0 ? 0 : 1;
        ctx += !topAvailable || top == null || !top.isIntra() || this.chromaPredModeTop[mbX] == 0 ? 0 : 1;
        var mode;
        if (decoder.decodeBin(ctx) == 0) 
            mode = 0;
         else if (decoder.decodeBin(67) == 0) 
            mode = 1;
         else if (decoder.decodeBin(67) == 0) 
            mode = 2;
         else 
            mode = 3;
        this.chromaPredModeLeft = this.chromaPredModeTop[mbX] = mode;
        return mode;
    };
    prototype.writeIntraChromaPredMode = function(encoder, mbX, left, top, leftAvailable, topAvailable, mode) {
        var ctx = 64;
        ctx += !leftAvailable || !left.isIntra() || this.chromaPredModeLeft == 0 ? 0 : 1;
        ctx += !topAvailable || !top.isIntra() || this.chromaPredModeTop[mbX] == 0 ? 0 : 1;
        encoder.encodeBin(ctx, mode-- == 0 ? 0 : 1);
        for (var i = 0; mode >= 0 && i < 2; i++) 
            encoder.encodeBin(67, mode-- == 0 ? 0 : 1);
        this.chromaPredModeLeft = this.chromaPredModeTop[mbX] = mode;
    };
    prototype.condTerm = function(mbCur, nAvb, mbN, nBlkAvb, cbpN) {
        if (!nAvb) 
            return mbCur.isIntra() ? 1 : 0;
        if (mbN == MBType.I_PCM) 
            return 1;
        if (!nBlkAvb) 
            return 0;
        return cbpN;
    };
    prototype.readCodedBlockFlagLumaDC = function(decoder, mbX, left, top, leftAvailable, topAvailable, cur) {
        var tLeft = this.condTerm(cur, leftAvailable, left, left == MBType.I_16x16, this.codedBlkDCLeft[0]);
        var tTop = this.condTerm(cur, topAvailable, top, top == MBType.I_16x16, this.codedBlkDCTop[0][mbX]);
        var decoded = decoder.decodeBin(CABAC.BlockType.LUMA_16_DC.codedBlockCtxOff + tLeft + 2 * tTop);
        this.codedBlkDCLeft[0] = decoded;
        this.codedBlkDCTop[0][mbX] = decoded;
        return decoded;
    };
    prototype.readCodedBlockFlagChromaDC = function(decoder, mbX, comp, left, top, leftAvailable, topAvailable, leftCBPChroma, topCBPChroma, cur) {
        var tLeft = this.condTerm(cur, leftAvailable, left, left != null && leftCBPChroma != 0, this.codedBlkDCLeft[comp]);
        var tTop = this.condTerm(cur, topAvailable, top, top != null && topCBPChroma != 0, this.codedBlkDCTop[comp][mbX]);
        var decoded = decoder.decodeBin(CABAC.BlockType.CHROMA_DC.codedBlockCtxOff + tLeft + 2 * tTop);
        this.codedBlkDCLeft[comp] = decoded;
        this.codedBlkDCTop[comp][mbX] = decoded;
        return decoded;
    };
    prototype.readCodedBlockFlagLumaAC = function(decoder, blkType, blkX, blkY, comp, left, top, leftAvailable, topAvailable, leftCBPLuma, topCBPLuma, curCBPLuma, cur) {
        var blkOffLeft = blkX & 3, blkOffTop = blkY & 3;
        var tLeft;
        if (blkOffLeft == 0) 
            tLeft = this.condTerm(cur, leftAvailable, left, left != null && left != MBType.I_PCM && this.cbp(leftCBPLuma, 3, blkOffTop), this.codedBlkLeft[comp][blkOffTop]);
         else 
            tLeft = this.condTerm(cur, true, cur, this.cbp(curCBPLuma, blkOffLeft - 1, blkOffTop), this.codedBlkLeft[comp][blkOffTop]);
        var tTop;
        if (blkOffTop == 0) 
            tTop = this.condTerm(cur, topAvailable, top, top != null && top != MBType.I_PCM && this.cbp(topCBPLuma, blkOffLeft, 3), this.codedBlkTop[comp][blkX]);
         else 
            tTop = this.condTerm(cur, true, cur, this.cbp(curCBPLuma, blkOffLeft, blkOffTop - 1), this.codedBlkTop[comp][blkX]);
        var decoded = decoder.decodeBin(blkType.codedBlockCtxOff + tLeft + 2 * tTop);
        this.codedBlkLeft[comp][blkOffTop] = decoded;
        this.codedBlkTop[comp][blkX] = decoded;
        return decoded;
    };
    prototype.readCodedBlockFlagLuma64 = function(decoder, blkX, blkY, comp, left, top, leftAvailable, topAvailable, leftCBPLuma, topCBPLuma, curCBPLuma, cur, is8x8Left, is8x8Top) {
        var blkOffLeft = blkX & 3, blkOffTop = blkY & 3;
        var tLeft;
        if (blkOffLeft == 0) 
            tLeft = this.condTerm(cur, leftAvailable, left, left != null && left != MBType.I_PCM && is8x8Left && this.cbp(leftCBPLuma, 3, blkOffTop), this.codedBlkLeft[comp][blkOffTop]);
         else 
            tLeft = this.condTerm(cur, true, cur, this.cbp(curCBPLuma, blkOffLeft - 1, blkOffTop), this.codedBlkLeft[comp][blkOffTop]);
        var tTop;
        if (blkOffTop == 0) 
            tTop = this.condTerm(cur, topAvailable, top, top != null && top != MBType.I_PCM && is8x8Top && this.cbp(topCBPLuma, blkOffLeft, 3), this.codedBlkTop[comp][blkX]);
         else 
            tTop = this.condTerm(cur, true, cur, this.cbp(curCBPLuma, blkOffLeft, blkOffTop - 1), this.codedBlkTop[comp][blkX]);
        var decoded = decoder.decodeBin(CABAC.BlockType.LUMA_64.codedBlockCtxOff + tLeft + 2 * tTop);
        this.codedBlkLeft[comp][blkOffTop] = decoded;
        this.codedBlkTop[comp][blkX] = decoded;
        return decoded;
    };
    prototype.cbp = function(cbpLuma, blkX, blkY) {
        var x8x8 = (blkY & 2) + (blkX >> 1);
        return ((cbpLuma >> x8x8) & 1) == 1;
    };
    prototype.readCodedBlockFlagChromaAC = function(decoder, blkX, blkY, comp, left, top, leftAvailable, topAvailable, leftCBPChroma, topCBPChroma, cur) {
        var blkOffLeft = blkX & 1, blkOffTop = blkY & 1;
        var tLeft;
        if (blkOffLeft == 0) 
            tLeft = this.condTerm(cur, leftAvailable, left, left != null && left != MBType.I_PCM && (leftCBPChroma & 2) != 0, this.codedBlkLeft[comp][blkOffTop]);
         else 
            tLeft = this.condTerm(cur, true, cur, true, this.codedBlkLeft[comp][blkOffTop]);
        var tTop;
        if (blkOffTop == 0) 
            tTop = this.condTerm(cur, topAvailable, top, top != null && top != MBType.I_PCM && (topCBPChroma & 2) != 0, this.codedBlkTop[comp][blkX]);
         else 
            tTop = this.condTerm(cur, true, cur, true, this.codedBlkTop[comp][blkX]);
        var decoded = decoder.decodeBin(CABAC.BlockType.CHROMA_AC.codedBlockCtxOff + tLeft + 2 * tTop);
        this.codedBlkLeft[comp][blkOffTop] = decoded;
        this.codedBlkTop[comp][blkX] = decoded;
        return decoded;
    };
    prototype.prev4x4PredModeFlag = function(decoder) {
        return decoder.decodeBin(68) == 1;
    };
    prototype.rem4x4PredMode = function(decoder) {
        return decoder.decodeBin(69) | (decoder.decodeBin(69) << 1) | (decoder.decodeBin(69) << 2);
    };
    prototype.codedBlockPatternIntra = function(mDecoder, leftAvailable, topAvailable, cbpLeft, cbpTop, mbLeft, mbTop) {
        var cbp0 = mDecoder.decodeBin(73 + this._condTerm(leftAvailable, mbLeft, (cbpLeft >> 1) & 1) + 2 * this._condTerm(topAvailable, mbTop, (cbpTop >> 2) & 1));
        var cbp1 = mDecoder.decodeBin(73 + (1 - cbp0) + 2 * this._condTerm(topAvailable, mbTop, (cbpTop >> 3) & 1));
        var cbp2 = mDecoder.decodeBin(73 + this._condTerm(leftAvailable, mbLeft, (cbpLeft >> 3) & 1) + 2 * (1 - cbp0));
        var cbp3 = mDecoder.decodeBin(73 + (1 - cbp2) + 2 * (1 - cbp1));
        var cr0 = mDecoder.decodeBin(77 + this.condTermCr0(leftAvailable, mbLeft, cbpLeft >> 4) + 2 * this.condTermCr0(topAvailable, mbTop, cbpTop >> 4));
        var cr1 = cr0 != 0 ? mDecoder.decodeBin(81 + this.condTermCr1(leftAvailable, mbLeft, cbpLeft >> 4) + 2 * this.condTermCr1(topAvailable, mbTop, cbpTop >> 4)) : 0;
        return cbp0 | (cbp1 << 1) | (cbp2 << 2) | (cbp3 << 3) | (cr0 << 4) | (cr1 << 5);
    };
    prototype.condTermCr0 = function(avb, mbt, cbpChroma) {
        return avb && (mbt == MBType.I_PCM || mbt != null && cbpChroma != 0) ? 1 : 0;
    };
    prototype.condTermCr1 = function(avb, mbt, cbpChroma) {
        return avb && (mbt == MBType.I_PCM || mbt != null && (cbpChroma & 2) != 0) ? 1 : 0;
    };
    prototype._condTerm = function(avb, mbt, cbp) {
        return !avb || mbt == MBType.I_PCM || (mbt != null && cbp == 1) ? 0 : 1;
    };
    prototype.setPrevCBP = function(prevCBP) {
        this.prevCBP = prevCBP;
    };
    prototype.readMVD = function(decoder, comp, leftAvailable, topAvailable, leftType, topType, leftPred, topPred, curPred, mbX, partX, partY, partW, partH, list) {
        var ctx = comp == 0 ? 40 : 47;
        var partAbsX = (mbX << 2) + partX;
        var predEqA = leftPred != null && leftPred != H264Const.PartPred.Direct && (leftPred == H264Const.PartPred.Bi || leftPred == curPred || (curPred == H264Const.PartPred.Bi && H264Const.usesList(leftPred, list)));
        var predEqB = topPred != null && topPred != H264Const.PartPred.Direct && (topPred == H264Const.PartPred.Bi || topPred == curPred || (curPred == H264Const.PartPred.Bi && H264Const.usesList(topPred, list)));
        var absMvdComp = !leftAvailable || leftType == null || leftType.isIntra() || !predEqA ? 0 : Math.abs(this.mvdLeft[list][comp][partY]);
        absMvdComp += !topAvailable || topType == null || topType.isIntra() || !predEqB ? 0 : Math.abs(this.mvdTop[list][comp][partAbsX]);
        var val, b = decoder.decodeBin(ctx + (absMvdComp < 3 ? 0 : (absMvdComp > 32 ? 2 : 1)));
        for (val = 0; b != 0 && val < 8; val++) 
            b = decoder.decodeBin(Math.min(ctx + val + 3, ctx + 6));
        val += b;
        if (val != 0) {
            if (val == 9) {
                var log = 2, add = 0, sum = 0, leftover = 0;
                do {
                    sum += leftover;
                    log++;
                    b = decoder.decodeBinBypass();
                    leftover = 1 << log;
                } while (b != 0);
                --log;
                for (; log >= 0; log--) {
                    add |= decoder.decodeBinBypass() << log;
                }
                val += add + sum;
            }
            val = MathUtil.toSigned(val, -decoder.decodeBinBypass());
        }
        for (var i = 0; i < partW; i++) {
            this.mvdTop[list][comp][partAbsX + i] = val;
        }
        for (var i = 0; i < partH; i++) {
            this.mvdLeft[list][comp][partY + i] = val;
        }
        return val;
    };
    prototype.readRefIdx = function(mDecoder, leftAvailable, topAvailable, leftType, topType, leftPred, topPred, curPred, mbX, partX, partY, partW, partH, list) {
        var partAbsX = (mbX << 2) + partX;
        var predEqA = leftPred != null && leftPred != H264Const.PartPred.Direct && (leftPred == H264Const.PartPred.Bi || leftPred == curPred || (curPred == H264Const.PartPred.Bi && H264Const.usesList(leftPred, list)));
        var predEqB = topPred != null && topPred != H264Const.PartPred.Direct && (topPred == H264Const.PartPred.Bi || topPred == curPred || (curPred == H264Const.PartPred.Bi && H264Const.usesList(topPred, list)));
        var ctA = !leftAvailable || leftType == null || leftType.isIntra() || !predEqA || this.refIdxLeft[list][partY] == 0 ? 0 : 1;
        var ctB = !topAvailable || topType == null || topType.isIntra() || !predEqB || this.refIdxTop[list][partAbsX] == 0 ? 0 : 1;
        var b0 = mDecoder.decodeBin(54 + ctA + 2 * ctB);
        var val;
        if (b0 == 0) 
            val = 0;
         else {
            var b1 = mDecoder.decodeBin(58);
            if (b1 == 0) 
                val = 1;
             else {
                for (val = 2; mDecoder.decodeBin(59) == 1; val++) 
                    ;
            }
        }
        for (var i = 0; i < partW; i++) {
            this.refIdxTop[list][partAbsX + i] = val;
        }
        for (var i = 0; i < partH; i++) {
            this.refIdxLeft[list][partY + i] = val;
        }
        return val;
    };
    prototype.readMBSkipFlag = function(mDecoder, slType, leftAvailable, topAvailable, mbX) {
        var base = slType == SliceType.P ? 11 : 24;
        var ret = mDecoder.decodeBin(base + (leftAvailable && !this.skipFlagLeft ? 1 : 0) + (topAvailable && !this.skipFlagsTop[mbX] ? 1 : 0)) == 1;
        this.skipFlagLeft = this.skipFlagsTop[mbX] = ret;
        return ret;
    };
    prototype.readSubMbTypeP = function(mDecoder) {
        if (mDecoder.decodeBin(21) == 1) 
            return 0;
         else if (mDecoder.decodeBin(22) == 0) 
            return 1;
         else if (mDecoder.decodeBin(23) == 1) 
            return 2;
         else 
            return 3;
    };
    prototype.readSubMbTypeB = function(mDecoder) {
        if (mDecoder.decodeBin(36) == 0) 
            return 0;
        if (mDecoder.decodeBin(37) == 0) 
            return 1 + mDecoder.decodeBin(39);
        if (mDecoder.decodeBin(38) == 0) 
            return 3 + (mDecoder.decodeBin(39) << 1) + mDecoder.decodeBin(39);
        if (mDecoder.decodeBin(39) == 0) 
            return 7 + (mDecoder.decodeBin(39) << 1) + mDecoder.decodeBin(39);
        return 11 + mDecoder.decodeBin(39);
    };
    prototype.readTransform8x8Flag = function(mDecoder, leftAvailable, topAvailable, leftType, topType, is8x8Left, is8x8Top) {
        var ctx = 399 + (leftAvailable && leftType != null && is8x8Left ? 1 : 0) + (topAvailable && topType != null && is8x8Top ? 1 : 0);
        return mDecoder.decodeBin(ctx) == 1;
    };
    prototype.setCodedBlock = function(blkX, blkY) {
        this.codedBlkLeft[0][blkY & 3] = this.codedBlkTop[0][blkX] = 1;
    };
}, {chromaPredModeTop: "Int32Array", codedBlkLeft: "Array", codedBlkTop: "Array", codedBlkDCLeft: "Int32Array", codedBlkDCTop: "Array", refIdxLeft: "Array", refIdxTop: "Array", skipFlagsTop: "Int8Array", mvdTop: "Array", mvdLeft: "Array", tmp: "Int32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Non-CABAC H.264 symbols read/write routines
 *  
 *  @author Jay Codec
 *  
 */
var CAVLC = function(sps, pps, mbW, mbH) {
    this.color = sps.chroma_format_idc;
    this.chromaDCVLC = this.codeTableChromaDC();
    this.mbWidth = sps.pic_width_in_mbs_minus1 + 1;
    this.mbMask = (1 << mbH) - 1;
    this.tokensLeft = new Int32Array(4);
    this.tokensTop = new Int32Array(this.mbWidth << mbW);
};
CAVLC = stjs.extend(CAVLC, null, [], function(constructor, prototype) {
    prototype.color = null;
    prototype.chromaDCVLC = null;
    prototype.tokensLeft = null;
    prototype.tokensTop = null;
    prototype.mbWidth = 0;
    prototype.mbMask = 0;
    prototype.writeACBlock = function(out, blkIndX, blkIndY, leftMBType, topMBType, coeff, totalZerosTab, firstCoeff, maxCoeff, scan) {
        var coeffTokenTab = this.getCoeffTokenVLCForLuma(blkIndX != 0, leftMBType, this.tokensLeft[blkIndY & this.mbMask], blkIndY != 0, topMBType, this.tokensTop[blkIndX]);
        var coeffToken = this.writeBlockGen(out, coeff, totalZerosTab, firstCoeff, maxCoeff, scan, coeffTokenTab);
        this.tokensLeft[blkIndY & this.mbMask] = coeffToken;
        this.tokensTop[blkIndX] = coeffToken;
        return coeffToken;
    };
    prototype.writeChrDCBlock = function(out, coeff, totalZerosTab, firstCoeff, maxCoeff, scan) {
        this.writeBlockGen(out, coeff, totalZerosTab, firstCoeff, maxCoeff, scan, this.getCoeffTokenVLCForChromaDC());
    };
    prototype.writeLumaDCBlock = function(out, blkIndX, blkIndY, leftMBType, topMBType, coeff, totalZerosTab, firstCoeff, maxCoeff, scan) {
        var coeffTokenTab = this.getCoeffTokenVLCForLuma(blkIndX != 0, leftMBType, this.tokensLeft[blkIndY & this.mbMask], blkIndY != 0, topMBType, this.tokensTop[blkIndX]);
        this.writeBlockGen(out, coeff, totalZerosTab, firstCoeff, maxCoeff, scan, coeffTokenTab);
    };
    prototype.writeBlockGen = function(out, coeff, totalZerosTab, firstCoeff, maxCoeff, scan, coeffTokenTab) {
        var trailingOnes = 0, totalCoeff = 0, totalZeros = 0;
        var runBefore = new Int32Array(maxCoeff);
        var levels = new Int32Array(maxCoeff);
        for (var i = 0; i < maxCoeff; i++) {
            var c = coeff[scan[i + firstCoeff]];
            if (c == 0) {
                runBefore[totalCoeff]++;
                totalZeros++;
            } else {
                levels[totalCoeff++] = c;
            }
        }
        if (totalCoeff < maxCoeff) 
            totalZeros -= runBefore[totalCoeff];
        for (trailingOnes = 0; trailingOnes < totalCoeff && trailingOnes < 3 && Math.abs(levels[totalCoeff - trailingOnes - 1]) == 1; trailingOnes++) 
            ;
        var coeffToken = H264Const.coeffToken(totalCoeff, trailingOnes);
        coeffTokenTab.writeVLC(out, coeffToken);
        if (totalCoeff > 0) {
            this.writeTrailingOnes(out, levels, totalCoeff, trailingOnes);
            this.writeLevels(out, levels, totalCoeff, trailingOnes);
            if (totalCoeff < maxCoeff) {
                totalZerosTab[totalCoeff - 1].writeVLC(out, totalZeros);
                this.writeRuns(out, runBefore, totalCoeff, totalZeros);
            }
        }
        return coeffToken;
    };
    prototype.writeTrailingOnes = function(out, levels, totalCoeff, trailingOne) {
        for (var i = totalCoeff - 1; i >= totalCoeff - trailingOne; i--) 
            out.write1Bit(levels[i] >>> 31);
    };
    prototype.writeLevels = function(out, levels, totalCoeff, trailingOnes) {
        var suffixLen = totalCoeff > 10 && trailingOnes < 3 ? 1 : 0;
        for (var i = totalCoeff - trailingOnes - 1; i >= 0; i--) {
            var absLev = this.unsigned(levels[i]);
            if (i == totalCoeff - trailingOnes - 1 && trailingOnes < 3) 
                absLev -= 2;
            var prefix = absLev >> suffixLen;
            if (suffixLen == 0 && prefix < 14 || suffixLen > 0 && prefix < 15) {
                out.writeNBit(1, prefix + 1);
                out.writeNBit(absLev, suffixLen);
            } else if (suffixLen == 0 && absLev < 30) {
                out.writeNBit(1, 15);
                out.writeNBit(absLev - 14, 4);
            } else {
                if (suffixLen == 0) 
                    absLev -= 15;
                var len, code;
                for (len = 12; (code = absLev - (len + 3 << suffixLen) - (1 << len) + 4096) >= (1 << len); len++) 
                    ;
                out.writeNBit(1, len + 4);
                out.writeNBit(code, len);
            }
            if (suffixLen == 0) 
                suffixLen = 1;
            if (MathUtil.abs(levels[i]) > (3 << (suffixLen - 1)) && suffixLen < 6) 
                suffixLen++;
        }
    };
    prototype.unsigned = function(signed) {
        var sign = signed >>> 31;
        var s = signed >> 31;
        return (((signed ^ s) - s) << 1) + sign - 2;
    };
    prototype.writeRuns = function(out, run, totalCoeff, totalZeros) {
        for (var i = totalCoeff - 1; i > 0 && totalZeros > 0; i--) {
            H264Const.run[Math.min(6, totalZeros - 1)].writeVLC(out, run[i]);
            totalZeros -= run[i];
        }
    };
    prototype.getCoeffTokenVLCForLuma = function(leftAvailable, leftMBType, leftToken, topAvailable, topMBType, topToken) {
        var nc = this.codeTableLuma(leftAvailable, leftMBType, leftToken, topAvailable, topMBType, topToken);
        return H264Const.CoeffToken[Math.min(nc, 8)];
    };
    prototype.getCoeffTokenVLCForChromaDC = function() {
        return this.chromaDCVLC;
    };
    prototype.codeTableLuma = function(leftAvailable, leftMBType, leftToken, topAvailable, topMBType, topToken) {
        var nA = leftMBType == null ? 0 : CAVLC.totalCoeff(leftToken);
        var nB = topMBType == null ? 0 : CAVLC.totalCoeff(topToken);
        if (leftAvailable && topAvailable) 
            return (nA + nB + 1) >> 1;
         else if (leftAvailable) 
            return nA;
         else if (topAvailable) 
            return nB;
         else 
            return 0;
    };
    prototype.codeTableChromaDC = function() {
        if (this.color == ColorSpace.YUV420J) {
            return H264Const.coeffTokenChromaDCY420;
        } else if (this.color == ColorSpace.YUV422) {
            return H264Const.coeffTokenChromaDCY422;
        } else if (this.color == ColorSpace.YUV444) {
            return H264Const.CoeffToken[0];
        }
        return null;
    };
    prototype.readCoeffs = function(_in, coeffTokenTab, totalZerosTab, coeffLevel, firstCoeff, nCoeff, zigzag) {
        var coeffToken = coeffTokenTab.readVLC(_in);
        var totalCoeff = CAVLC.totalCoeff(coeffToken);
        var trailingOnes = CAVLC.trailingOnes(coeffToken);
        if (totalCoeff > 0) {
            var suffixLength = totalCoeff > 10 && trailingOnes < 3 ? 1 : 0;
            var level = new Int32Array(totalCoeff);
            var i;
            for (i = 0; i < trailingOnes; i++) 
                level[i] = 1 - 2 * _in.read1Bit();
            for (; i < totalCoeff; i++) {
                var level_prefix = CAVLCReader.readZeroBitCount(_in, "");
                var levelSuffixSize = suffixLength;
                if (level_prefix == 14 && suffixLength == 0) 
                    levelSuffixSize = 4;
                if (level_prefix >= 15) 
                    levelSuffixSize = level_prefix - 3;
                var levelCode = (CAVLC.Min(15, level_prefix) << suffixLength);
                if (levelSuffixSize > 0) {
                    var level_suffix = CAVLCReader.readU(_in, levelSuffixSize, "RB: level_suffix");
                    levelCode += level_suffix;
                }
                if (level_prefix >= 15 && suffixLength == 0) 
                    levelCode += 15;
                if (level_prefix >= 16) 
                    levelCode += (1 << (level_prefix - 3)) - 4096;
                if (i == trailingOnes && trailingOnes < 3) 
                    levelCode += 2;
                if (levelCode % 2 == 0) 
                    level[i] = (levelCode + 2) >> 1;
                 else 
                    level[i] = (-levelCode - 1) >> 1;
                if (suffixLength == 0) 
                    suffixLength = 1;
                if (CAVLC.Abs(level[i]) > (3 << (suffixLength - 1)) && suffixLength < 6) 
                    suffixLength++;
            }
            var zerosLeft;
            if (totalCoeff < nCoeff) {
                if (coeffLevel.length == 4) {
                    zerosLeft = H264Const.totalZeros4[totalCoeff - 1].readVLC(_in);
                } else if (coeffLevel.length == 8) {
                    zerosLeft = H264Const.totalZeros8[totalCoeff - 1].readVLC(_in);
                } else {
                    zerosLeft = H264Const.totalZeros16[totalCoeff - 1].readVLC(_in);
                }
            } else 
                zerosLeft = 0;
            var runs = new Int32Array(totalCoeff);
            var r;
            for (r = 0; r < totalCoeff - 1 && zerosLeft > 0; r++) {
                var run = H264Const.run[Math.min(6, zerosLeft - 1)].readVLC(_in);
                zerosLeft -= run;
                runs[r] = run;
            }
            runs[r] = zerosLeft;
            for (var j = totalCoeff - 1, cn = 0; j >= 0 && cn < nCoeff; j-- , cn++) {
                cn += runs[j];
                coeffLevel[zigzag[cn + firstCoeff]] = level[j];
            }
        }
        return coeffToken;
    };
    constructor.Min = function(i, level_prefix) {
        return i < level_prefix ? i : level_prefix;
    };
    constructor.Abs = function(i) {
        return i < 0 ? -i : i;
    };
    constructor.totalCoeff = function(coeffToken) {
        return coeffToken >> 4;
    };
    constructor.trailingOnes = function(coeffToken) {
        return coeffToken & 15;
    };
    constructor.NO_ZIGZAG = new Int32Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);
    prototype.readChromaDCBlock = function(reader, coeff, leftAvailable, topAvailable) {
        var coeffTokenTab = this.getCoeffTokenVLCForChromaDC();
        this.readCoeffs(reader, coeffTokenTab, coeff.length == 16 ? H264Const.totalZeros16 : (coeff.length == 8 ? H264Const.totalZeros8 : H264Const.totalZeros4), coeff, 0, coeff.length, CAVLC.NO_ZIGZAG);
    };
    prototype.readLumaDCBlock = function(reader, coeff, mbX, leftAvailable, leftMbType, topAvailable, topMbType, zigzag4x4) {
        var coeffTokenTab = this.getCoeffTokenVLCForLuma(leftAvailable, leftMbType, this.tokensLeft[0], topAvailable, topMbType, this.tokensTop[mbX << 2]);
        this.readCoeffs(reader, coeffTokenTab, H264Const.totalZeros16, coeff, 0, 16, zigzag4x4);
    };
    prototype.readACBlock = function(reader, coeff, blkIndX, blkIndY, leftAvailable, leftMbType, topAvailable, topMbType, firstCoeff, nCoeff, zigzag4x4) {
        var coeffTokenTab = this.getCoeffTokenVLCForLuma(leftAvailable, leftMbType, this.tokensLeft[blkIndY & this.mbMask], topAvailable, topMbType, this.tokensTop[blkIndX]);
        var readCoeffs = this.readCoeffs(reader, coeffTokenTab, H264Const.totalZeros16, coeff, firstCoeff, nCoeff, zigzag4x4);
        this.tokensLeft[blkIndY & this.mbMask] = this.tokensTop[blkIndX] = readCoeffs;
        return CAVLC.totalCoeff(readCoeffs);
    };
    prototype.setZeroCoeff = function(blkIndX, blkIndY) {
        this.tokensLeft[blkIndY & this.mbMask] = this.tokensTop[blkIndX] = 0;
    };
}, {color: "ColorSpace", chromaDCVLC: "VLC", tokensLeft: "Int32Array", tokensTop: "Int32Array", NO_ZIGZAG: "Int32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Prediction merge and weight routines
 *  
 *  @author The JCodec project
 *  
 */
var PredictionMerger = function() {};
PredictionMerger = stjs.extend(PredictionMerger, null, [], function(constructor, prototype) {
    constructor.mergePrediction = function(sh, refIdxL0, refIdxL1, predType, comp, pred0, pred1, off, stride, blkW, blkH, out, refs, thisPoc) {
        var pps = sh.pps;
        if (sh.slice_type == SliceType.P) {
            if (pps.weighted_pred_flag && sh.pred_weight_table != null) {
                var w = sh.pred_weight_table;
                PredictionMerger.weight(pred0, stride, off, blkW, blkH, comp == 0 ? w.luma_log2_weight_denom : w.chroma_log2_weight_denom, comp == 0 ? w.luma_weight[0][refIdxL0] : w.chroma_weight[0][comp - 1][refIdxL0], comp == 0 ? w.luma_offset[0][refIdxL0] : w.chroma_offset[0][comp - 1][refIdxL0], out);
            } else {
                PredictionMerger.copyPrediction(pred0, stride, off, blkW, blkH, out);
            }
        } else {
            if (!pps.weighted_pred_flag || sh.pps.weighted_bipred_idc == 0 || (sh.pps.weighted_bipred_idc == 2 && predType != H264Const.PartPred.Bi)) {
                PredictionMerger.mergeAvg(pred0, pred1, stride, predType, off, blkW, blkH, out);
            } else if (sh.pps.weighted_bipred_idc == 1) {
                var w = sh.pred_weight_table;
                var w0 = refIdxL0 == -1 ? 0 : (comp == 0 ? w.luma_weight[0][refIdxL0] : w.chroma_weight[0][comp - 1][refIdxL0]);
                var w1 = refIdxL1 == -1 ? 0 : (comp == 0 ? w.luma_weight[1][refIdxL1] : w.chroma_weight[1][comp - 1][refIdxL1]);
                var o0 = refIdxL0 == -1 ? 0 : (comp == 0 ? w.luma_offset[0][refIdxL0] : w.chroma_offset[0][comp - 1][refIdxL0]);
                var o1 = refIdxL1 == -1 ? 0 : (comp == 0 ? w.luma_offset[1][refIdxL1] : w.chroma_offset[1][comp - 1][refIdxL1]);
                PredictionMerger.mergeWeight(pred0, pred1, stride, predType, off, blkW, blkH, comp == 0 ? w.luma_log2_weight_denom : w.chroma_log2_weight_denom, w0, w1, o0, o1, out);
            } else {
                var tb = MathUtil.clip(thisPoc - refs[0][refIdxL0].getPOC(), -128, 127);
                var td = MathUtil.clip(refs[1][refIdxL1].getPOC() - refs[0][refIdxL0].getPOC(), -128, 127);
                var w0 = 32, w1 = 32;
                if (td != 0 && refs[0][refIdxL0].isShortTerm() && refs[1][refIdxL1].isShortTerm()) {
                    var tx = stjs.trunc((16384 + Math.abs(stjs.trunc(td / 2))) / td);
                    var dsf = MathUtil.clip((tb * tx + 32) >> 6, -1024, 1023) >> 2;
                    if (dsf >= -64 && dsf <= 128) {
                        w1 = dsf;
                        w0 = 64 - dsf;
                    }
                }
                PredictionMerger.mergeWeight(pred0, pred1, stride, predType, off, blkW, blkH, 5, w0, w1, 0, 0, out);
            }
        }
    };
    constructor.mergeAvg = function(blk0, blk1, stride, p0, off, blkW, blkH, out) {
        if (p0 == H264Const.PartPred.Bi) 
            PredictionMerger._mergePrediction(blk0, blk1, stride, p0, off, blkW, blkH, out);
         else if (p0 == H264Const.PartPred.L0) 
            PredictionMerger.copyPrediction(blk0, stride, off, blkW, blkH, out);
         else if (p0 == H264Const.PartPred.L1) 
            PredictionMerger.copyPrediction(blk1, stride, off, blkW, blkH, out);
    };
    constructor.mergeWeight = function(blk0, blk1, stride, partPred, off, blkW, blkH, logWD, w0, w1, o0, o1, out) {
        if (partPred == H264Const.PartPred.L0) {
            PredictionMerger.weight(blk0, stride, off, blkW, blkH, logWD, w0, o0, out);
        } else if (partPred == H264Const.PartPred.L1) {
            PredictionMerger.weight(blk1, stride, off, blkW, blkH, logWD, w1, o1, out);
        } else if (partPred == H264Const.PartPred.Bi) {
            PredictionMerger.weightPrediction(blk0, blk1, stride, off, blkW, blkH, logWD, w0, w1, o0, o1, out);
        }
    };
    constructor.copyPrediction = function(_in, stride, off, blkW, blkH, out) {
        for (var i = 0; i < blkH; i++ , off += stride - blkW) 
            for (var j = 0; j < blkW; j++ , off++) 
                out[off] = _in[off];
    };
    constructor._mergePrediction = function(blk0, blk1, stride, p0, off, blkW, blkH, out) {
        for (var i = 0; i < blkH; i++ , off += stride - blkW) 
            for (var j = 0; j < blkW; j++ , off++) 
                out[off] = (((blk0[off] + blk1[off] + 1) >> 1) << 24 >> 24);
    };
    constructor.weightPrediction = function(blk0, blk1, stride, off, blkW, blkH, logWD, w0, w1, o0, o1, out) {
        var round = (1 << logWD) + ((w0 + w1) << 7);
        var sum = ((o0 + o1 + 1) >> 1) - 128;
        var logWDCP1 = logWD + 1;
        for (var i = 0; i < blkH; i++ , off += stride - blkW) 
            for (var j = 0; j < blkW; j++ , off++) {
                out[off] = (MathUtil.clip(((blk0[off] * w0 + blk1[off] * w1 + round) >> logWDCP1) + sum, -128, 127) << 24 >> 24);
            }
    };
    constructor.weight = function(blk0, stride, off, blkW, blkH, logWD, w, o, out) {
        var round = 1 << (logWD - 1);
        if (logWD >= 1) {
            o -= 128;
            round += w << 7;
            for (var i = 0; i < blkH; i++ , off += stride - blkW) 
                for (var j = 0; j < blkW; j++ , off++) 
                    out[off] = (MathUtil.clip(((blk0[off] * w + round) >> logWD) + o, -128, 127) << 24 >> 24);
        } else {
            o += (w << 7) - 128;
            for (var i = 0; i < blkH; i++ , off += stride - blkW) 
                for (var j = 0; j < blkW; j++ , off++) 
                    out[off] = (MathUtil.clip(blk0[off] * w + o, -128, 127) << 24 >> 24);
        }
    };
}, {}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license. 
 * 
 *  @author in-somnia
 */
var Element = function() {};
Element = stjs.extend(Element, null, [SyntaxConstants], function(constructor, prototype) {
    prototype.elementInstanceTag = 0;
    prototype.sbr = null;
    prototype.readElementInstanceTag = function(_in) {
        this.elementInstanceTag = _in.readBits(4);
    };
    prototype.getElementInstanceTag = function() {
        return this.elementInstanceTag;
    };
    prototype.decodeSBR = function(_in, sf, count, stereo, crc, downSampled, smallFrames) {
        if (this.sbr == null) 
            this.sbr = new SBR(smallFrames, this.elementInstanceTag == SyntaxConstants.ELEMENT_CPE, sf, downSampled);
        this.sbr.decode(_in, count);
    };
    prototype.isSBRPresent = function() {
        return this.sbr != null;
    };
    prototype.getSBR = function() {
        return this.sbr;
    };
}, {sbr: "SBR", LOGGER: "Logger"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Picture Parameter Set entity of H264 bitstream
 *  
 *  capable to serialize / deserialize with CAVLC bitstream
 *  
 *  @author The JCodec project
 *  
 */
var PictureParameterSet = function() {
    this.num_ref_idx_active_minus1 = new Int32Array(2);
};
PictureParameterSet = stjs.extend(PictureParameterSet, null, [], function(constructor, prototype) {
    constructor.PPSExt = function() {};
    constructor.PPSExt = stjs.extend(constructor.PPSExt, null, [], function(constructor, prototype) {
        prototype.transform_8x8_mode_flag = false;
        prototype.scalindMatrix = null;
        prototype.second_chroma_qp_index_offset = 0;
        prototype.pic_scaling_list_present_flag = null;
        prototype.isTransform_8x8_mode_flag = function() {
            return this.transform_8x8_mode_flag;
        };
        prototype.getScalindMatrix = function() {
            return this.scalindMatrix;
        };
        prototype.getSecond_chroma_qp_index_offset = function() {
            return this.second_chroma_qp_index_offset;
        };
        prototype.getPic_scaling_list_present_flag = function() {
            return this.pic_scaling_list_present_flag;
        };
    }, {scalindMatrix: "ScalingMatrix", pic_scaling_list_present_flag: "Int8Array"}, {});
    prototype.entropy_coding_mode_flag = false;
    prototype.num_ref_idx_active_minus1 = null;
    prototype.slice_group_change_rate_minus1 = 0;
    prototype.pic_parameter_set_id = 0;
    prototype.seq_parameter_set_id = 0;
    prototype.pic_order_present_flag = false;
    prototype.num_slice_groups_minus1 = 0;
    prototype.slice_group_map_type = 0;
    prototype.weighted_pred_flag = false;
    prototype.weighted_bipred_idc = 0;
    prototype.pic_init_qp_minus26 = 0;
    prototype.pic_init_qs_minus26 = 0;
    prototype.chroma_qp_index_offset = 0;
    prototype.deblocking_filter_control_present_flag = false;
    prototype.constrained_intra_pred_flag = false;
    prototype.redundant_pic_cnt_present_flag = false;
    prototype.top_left = null;
    prototype.bottom_right = null;
    prototype.run_length_minus1 = null;
    prototype.slice_group_change_direction_flag = false;
    prototype.slice_group_id = null;
    prototype.extended = null;
    constructor.read = function(is) {
        var _in = BitReader.createBitReader(is);
        var pps = new PictureParameterSet();
        pps.pic_parameter_set_id = CAVLCReader.readUEtrace(_in, "PPS: pic_parameter_set_id");
        pps.seq_parameter_set_id = CAVLCReader.readUEtrace(_in, "PPS: seq_parameter_set_id");
        pps.entropy_coding_mode_flag = CAVLCReader.readBool(_in, "PPS: entropy_coding_mode_flag");
        pps.pic_order_present_flag = CAVLCReader.readBool(_in, "PPS: pic_order_present_flag");
        pps.num_slice_groups_minus1 = CAVLCReader.readUEtrace(_in, "PPS: num_slice_groups_minus1");
        if (pps.num_slice_groups_minus1 > 0) {
            pps.slice_group_map_type = CAVLCReader.readUEtrace(_in, "PPS: slice_group_map_type");
            pps.top_left = new Int32Array(pps.num_slice_groups_minus1 + 1);
            pps.bottom_right = new Int32Array(pps.num_slice_groups_minus1 + 1);
            pps.run_length_minus1 = new Int32Array(pps.num_slice_groups_minus1 + 1);
            if (pps.slice_group_map_type == 0) 
                for (var iGroup = 0; iGroup <= pps.num_slice_groups_minus1; iGroup++) 
                    pps.run_length_minus1[iGroup] = CAVLCReader.readUEtrace(_in, "PPS: run_length_minus1");
             else if (pps.slice_group_map_type == 2) 
                for (var iGroup = 0; iGroup < pps.num_slice_groups_minus1; iGroup++) {
                    pps.top_left[iGroup] = CAVLCReader.readUEtrace(_in, "PPS: top_left");
                    pps.bottom_right[iGroup] = CAVLCReader.readUEtrace(_in, "PPS: bottom_right");
                }
             else if (pps.slice_group_map_type == 3 || pps.slice_group_map_type == 4 || pps.slice_group_map_type == 5) {
                pps.slice_group_change_direction_flag = CAVLCReader.readBool(_in, "PPS: slice_group_change_direction_flag");
                pps.slice_group_change_rate_minus1 = CAVLCReader.readUEtrace(_in, "PPS: slice_group_change_rate_minus1");
            } else if (pps.slice_group_map_type == 6) {
                var NumberBitsPerSliceGroupId;
                if (pps.num_slice_groups_minus1 + 1 > 4) 
                    NumberBitsPerSliceGroupId = 3;
                 else if (pps.num_slice_groups_minus1 + 1 > 2) 
                    NumberBitsPerSliceGroupId = 2;
                 else 
                    NumberBitsPerSliceGroupId = 1;
                var pic_size_in_map_units_minus1 = CAVLCReader.readUEtrace(_in, "PPS: pic_size_in_map_units_minus1");
                pps.slice_group_id = new Int32Array(pic_size_in_map_units_minus1 + 1);
                for (var i = 0; i <= pic_size_in_map_units_minus1; i++) {
                    pps.slice_group_id[i] = CAVLCReader.readU(_in, NumberBitsPerSliceGroupId, "PPS: slice_group_id [" + i + "]f");
                }
            }
        }
        pps.num_ref_idx_active_minus1 = new Int32Array([CAVLCReader.readUEtrace(_in, "PPS: num_ref_idx_l0_active_minus1"), CAVLCReader.readUEtrace(_in, "PPS: num_ref_idx_l1_active_minus1")]);
        pps.weighted_pred_flag = CAVLCReader.readBool(_in, "PPS: weighted_pred_flag");
        pps.weighted_bipred_idc = CAVLCReader.readNBit(_in, 2, "PPS: weighted_bipred_idc");
        pps.pic_init_qp_minus26 = CAVLCReader.readSE(_in, "PPS: pic_init_qp_minus26");
        pps.pic_init_qs_minus26 = CAVLCReader.readSE(_in, "PPS: pic_init_qs_minus26");
        pps.chroma_qp_index_offset = CAVLCReader.readSE(_in, "PPS: chroma_qp_index_offset");
        pps.deblocking_filter_control_present_flag = CAVLCReader.readBool(_in, "PPS: deblocking_filter_control_present_flag");
        pps.constrained_intra_pred_flag = CAVLCReader.readBool(_in, "PPS: constrained_intra_pred_flag");
        pps.redundant_pic_cnt_present_flag = CAVLCReader.readBool(_in, "PPS: redundant_pic_cnt_present_flag");
        if (CAVLCReader.moreRBSPData(_in)) {
            pps.extended = new PictureParameterSet.PPSExt();
            pps.extended.transform_8x8_mode_flag = CAVLCReader.readBool(_in, "PPS: transform_8x8_mode_flag");
            var pic_scaling_matrix_present_flag = CAVLCReader.readBool(_in, "PPS: pic_scaling_matrix_present_flag");
            if (pic_scaling_matrix_present_flag) {
                for (var i = 0; i < 6 + 2 * (pps.extended.transform_8x8_mode_flag ? 1 : 0); i++) {
                    var pic_scaling_list_present_flag = CAVLCReader.readBool(_in, "PPS: pic_scaling_list_present_flag");
                    if (pic_scaling_list_present_flag) {
                        pps.extended.scalindMatrix = new ScalingMatrix();
                        pps.extended.scalindMatrix.ScalingList4x4 = Array(8);
                        pps.extended.scalindMatrix.ScalingList8x8 = Array(8);
                        if (i < 6) {
                            pps.extended.scalindMatrix.ScalingList4x4[i] = ScalingList.read(_in, 16);
                        } else {
                            pps.extended.scalindMatrix.ScalingList8x8[i - 6] = ScalingList.read(_in, 64);
                        }
                    }
                }
            }
            pps.extended.second_chroma_qp_index_offset = CAVLCReader.readSE(_in, "PPS: second_chroma_qp_index_offset");
        }
        return pps;
    };
    prototype.write = function(out) {
        var writer = new BitWriter(out);
        CAVLCWriter.writeUEtrace(writer, this.pic_parameter_set_id, "PPS: pic_parameter_set_id");
        CAVLCWriter.writeUEtrace(writer, this.seq_parameter_set_id, "PPS: seq_parameter_set_id");
        CAVLCWriter.writeBool(writer, this.entropy_coding_mode_flag, "PPS: entropy_coding_mode_flag");
        CAVLCWriter.writeBool(writer, this.pic_order_present_flag, "PPS: pic_order_present_flag");
        CAVLCWriter.writeUEtrace(writer, this.num_slice_groups_minus1, "PPS: num_slice_groups_minus1");
        if (this.num_slice_groups_minus1 > 0) {
            CAVLCWriter.writeUEtrace(writer, this.slice_group_map_type, "PPS: slice_group_map_type");
            var top_left = new Int32Array(1);
            var bottom_right = new Int32Array(1);
            var run_length_minus1 = new Int32Array(1);
            if (this.slice_group_map_type == 0) {
                for (var iGroup = 0; iGroup <= this.num_slice_groups_minus1; iGroup++) {
                    CAVLCWriter.writeUEtrace(writer, run_length_minus1[iGroup], "PPS: ");
                }
            } else if (this.slice_group_map_type == 2) {
                for (var iGroup = 0; iGroup < this.num_slice_groups_minus1; iGroup++) {
                    CAVLCWriter.writeUEtrace(writer, top_left[iGroup], "PPS: ");
                    CAVLCWriter.writeUEtrace(writer, bottom_right[iGroup], "PPS: ");
                }
            } else if (this.slice_group_map_type == 3 || this.slice_group_map_type == 4 || this.slice_group_map_type == 5) {
                CAVLCWriter.writeBool(writer, this.slice_group_change_direction_flag, "PPS: slice_group_change_direction_flag");
                CAVLCWriter.writeUEtrace(writer, this.slice_group_change_rate_minus1, "PPS: slice_group_change_rate_minus1");
            } else if (this.slice_group_map_type == 6) {
                var NumberBitsPerSliceGroupId;
                if (this.num_slice_groups_minus1 + 1 > 4) 
                    NumberBitsPerSliceGroupId = 3;
                 else if (this.num_slice_groups_minus1 + 1 > 2) 
                    NumberBitsPerSliceGroupId = 2;
                 else 
                    NumberBitsPerSliceGroupId = 1;
                CAVLCWriter.writeUEtrace(writer, this.slice_group_id.length, "PPS: ");
                for (var i = 0; i <= this.slice_group_id.length; i++) {
                    CAVLCWriter.writeU(writer, this.slice_group_id[i], NumberBitsPerSliceGroupId);
                }
            }
        }
        CAVLCWriter.writeUEtrace(writer, this.num_ref_idx_active_minus1[0], "PPS: num_ref_idx_l0_active_minus1");
        CAVLCWriter.writeUEtrace(writer, this.num_ref_idx_active_minus1[1], "PPS: num_ref_idx_l1_active_minus1");
        CAVLCWriter.writeBool(writer, this.weighted_pred_flag, "PPS: weighted_pred_flag");
        CAVLCWriter.writeNBit(writer, this.weighted_bipred_idc, 2, "PPS: weighted_bipred_idc");
        CAVLCWriter.writeSEtrace(writer, this.pic_init_qp_minus26, "PPS: pic_init_qp_minus26");
        CAVLCWriter.writeSEtrace(writer, this.pic_init_qs_minus26, "PPS: pic_init_qs_minus26");
        CAVLCWriter.writeSEtrace(writer, this.chroma_qp_index_offset, "PPS: chroma_qp_index_offset");
        CAVLCWriter.writeBool(writer, this.deblocking_filter_control_present_flag, "PPS: deblocking_filter_control_present_flag");
        CAVLCWriter.writeBool(writer, this.constrained_intra_pred_flag, "PPS: constrained_intra_pred_flag");
        CAVLCWriter.writeBool(writer, this.redundant_pic_cnt_present_flag, "PPS: redundant_pic_cnt_present_flag");
        if (this.extended != null) {
            CAVLCWriter.writeBool(writer, this.extended.transform_8x8_mode_flag, "PPS: transform_8x8_mode_flag");
            CAVLCWriter.writeBool(writer, this.extended.scalindMatrix != null, "PPS: scalindMatrix");
            if (this.extended.scalindMatrix != null) {
                for (var i = 0; i < 6 + 2 * (this.extended.transform_8x8_mode_flag ? 1 : 0); i++) {
                    if (i < 6) {
                        CAVLCWriter.writeBool(writer, this.extended.scalindMatrix.ScalingList4x4[i] != null, "PPS: ");
                        if (this.extended.scalindMatrix.ScalingList4x4[i] != null) {
                            this.extended.scalindMatrix.ScalingList4x4[i].write(writer);
                        }
                    } else {
                        CAVLCWriter.writeBool(writer, this.extended.scalindMatrix.ScalingList8x8[i - 6] != null, "PPS: ");
                        if (this.extended.scalindMatrix.ScalingList8x8[i - 6] != null) {
                            this.extended.scalindMatrix.ScalingList8x8[i - 6].write(writer);
                        }
                    }
                }
            }
            CAVLCWriter.writeSEtrace(writer, this.extended.second_chroma_qp_index_offset, "PPS: ");
        }
        CAVLCWriter.writeTrailingBits(writer);
    };
    prototype.hashCode = function() {
        var prime = 31;
        var result = 1;
        result = prime * result + Arrays.hashCode(this.bottom_right);
        result = prime * result + this.chroma_qp_index_offset;
        result = prime * result + (this.constrained_intra_pred_flag ? 1231 : 1237);
        result = prime * result + (this.deblocking_filter_control_present_flag ? 1231 : 1237);
        result = prime * result + (this.entropy_coding_mode_flag ? 1231 : 1237);
        result = prime * result + ((this.extended == null) ? 0 : this.extended.hashCode());
        result = prime * result + this.num_ref_idx_active_minus1[0];
        result = prime * result + this.num_ref_idx_active_minus1[1];
        result = prime * result + this.num_slice_groups_minus1;
        result = prime * result + this.pic_init_qp_minus26;
        result = prime * result + this.pic_init_qs_minus26;
        result = prime * result + (this.pic_order_present_flag ? 1231 : 1237);
        result = prime * result + this.pic_parameter_set_id;
        result = prime * result + (this.redundant_pic_cnt_present_flag ? 1231 : 1237);
        result = prime * result + Arrays.hashCode(this.run_length_minus1);
        result = prime * result + this.seq_parameter_set_id;
        result = prime * result + (this.slice_group_change_direction_flag ? 1231 : 1237);
        result = prime * result + this.slice_group_change_rate_minus1;
        result = prime * result + Arrays.hashCode(this.slice_group_id);
        result = prime * result + this.slice_group_map_type;
        result = prime * result + Arrays.hashCode(this.top_left);
        result = prime * result + this.weighted_bipred_idc;
        result = prime * result + (this.weighted_pred_flag ? 1231 : 1237);
        return result;
    };
    prototype.equals = function(obj) {
        if (this == obj) 
            return true;
        if (obj == null) 
            return false;
        if (this.getClass() != obj.getClass()) 
            return false;
        var other = obj;
        if (!Platform.arrayEqualsInt(this.bottom_right, other.bottom_right)) 
            return false;
        if (this.chroma_qp_index_offset != other.chroma_qp_index_offset) 
            return false;
        if (this.constrained_intra_pred_flag != other.constrained_intra_pred_flag) 
            return false;
        if (this.deblocking_filter_control_present_flag != other.deblocking_filter_control_present_flag) 
            return false;
        if (this.entropy_coding_mode_flag != other.entropy_coding_mode_flag) 
            return false;
        if (this.extended == null) {
            if (other.extended != null) 
                return false;
        } else if (!this.extended.equals(other.extended)) 
            return false;
        if (this.num_ref_idx_active_minus1[0] != other.num_ref_idx_active_minus1[0]) 
            return false;
        if (this.num_ref_idx_active_minus1[1] != other.num_ref_idx_active_minus1[1]) 
            return false;
        if (this.num_slice_groups_minus1 != other.num_slice_groups_minus1) 
            return false;
        if (this.pic_init_qp_minus26 != other.pic_init_qp_minus26) 
            return false;
        if (this.pic_init_qs_minus26 != other.pic_init_qs_minus26) 
            return false;
        if (this.pic_order_present_flag != other.pic_order_present_flag) 
            return false;
        if (this.pic_parameter_set_id != other.pic_parameter_set_id) 
            return false;
        if (this.redundant_pic_cnt_present_flag != other.redundant_pic_cnt_present_flag) 
            return false;
        if (!Platform.arrayEqualsInt(this.run_length_minus1, other.run_length_minus1)) 
            return false;
        if (this.seq_parameter_set_id != other.seq_parameter_set_id) 
            return false;
        if (this.slice_group_change_direction_flag != other.slice_group_change_direction_flag) 
            return false;
        if (this.slice_group_change_rate_minus1 != other.slice_group_change_rate_minus1) 
            return false;
        if (!Platform.arrayEqualsInt(this.slice_group_id, other.slice_group_id)) 
            return false;
        if (this.slice_group_map_type != other.slice_group_map_type) 
            return false;
        if (!Platform.arrayEqualsInt(this.top_left, other.top_left)) 
            return false;
        if (this.weighted_bipred_idc != other.weighted_bipred_idc) 
            return false;
        if (this.weighted_pred_flag != other.weighted_pred_flag) 
            return false;
        return true;
    };
    prototype.copy = function() {
        var buf = ByteBuffer.allocate(2048);
        this.write(buf);
        buf.flip();
        return PictureParameterSet.read(buf);
    };
    prototype.isEntropy_coding_mode_flag = function() {
        return this.entropy_coding_mode_flag;
    };
    prototype.getNum_ref_idx_active_minus1 = function() {
        return this.num_ref_idx_active_minus1;
    };
    prototype.getSlice_group_change_rate_minus1 = function() {
        return this.slice_group_change_rate_minus1;
    };
    prototype.getPic_parameter_set_id = function() {
        return this.pic_parameter_set_id;
    };
    prototype.getSeq_parameter_set_id = function() {
        return this.seq_parameter_set_id;
    };
    prototype.isPic_order_present_flag = function() {
        return this.pic_order_present_flag;
    };
    prototype.getNum_slice_groups_minus1 = function() {
        return this.num_slice_groups_minus1;
    };
    prototype.getSlice_group_map_type = function() {
        return this.slice_group_map_type;
    };
    prototype.isWeighted_pred_flag = function() {
        return this.weighted_pred_flag;
    };
    prototype.getWeighted_bipred_idc = function() {
        return this.weighted_bipred_idc;
    };
    prototype.getPic_init_qp_minus26 = function() {
        return this.pic_init_qp_minus26;
    };
    prototype.getPic_init_qs_minus26 = function() {
        return this.pic_init_qs_minus26;
    };
    prototype.getChroma_qp_index_offset = function() {
        return this.chroma_qp_index_offset;
    };
    prototype.isDeblocking_filter_control_present_flag = function() {
        return this.deblocking_filter_control_present_flag;
    };
    prototype.isConstrained_intra_pred_flag = function() {
        return this.constrained_intra_pred_flag;
    };
    prototype.isRedundant_pic_cnt_present_flag = function() {
        return this.redundant_pic_cnt_present_flag;
    };
    prototype.getTop_left = function() {
        return this.top_left;
    };
    prototype.getBottom_right = function() {
        return this.bottom_right;
    };
    prototype.getRun_length_minus1 = function() {
        return this.run_length_minus1;
    };
    prototype.isSlice_group_change_direction_flag = function() {
        return this.slice_group_change_direction_flag;
    };
    prototype.getSlice_group_id = function() {
        return this.slice_group_id;
    };
    prototype.getExtended = function() {
        return this.extended;
    };
}, {num_ref_idx_active_minus1: "Int32Array", top_left: "Int32Array", bottom_right: "Int32Array", run_length_minus1: "Int32Array", slice_group_id: "Int32Array", extended: "PictureParameterSet.PPSExt"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Sequence Parameter Set structure of h264 bitstream
 *  
 *  capable to serialize and deserialize with CAVLC bitstream
 *  
 *  @author The JCodec project
 *  
 */
var SeqParameterSet = function() {};
SeqParameterSet = stjs.extend(SeqParameterSet, null, [], function(constructor, prototype) {
    prototype.pic_order_cnt_type = 0;
    prototype.field_pic_flag = false;
    prototype.delta_pic_order_always_zero_flag = false;
    prototype.mb_adaptive_frame_field_flag = false;
    prototype.direct_8x8_inference_flag = false;
    prototype.chroma_format_idc = null;
    prototype.log2_max_frame_num_minus4 = 0;
    prototype.log2_max_pic_order_cnt_lsb_minus4 = 0;
    prototype.pic_height_in_map_units_minus1 = 0;
    prototype.pic_width_in_mbs_minus1 = 0;
    prototype.bit_depth_luma_minus8 = 0;
    prototype.bit_depth_chroma_minus8 = 0;
    prototype.qpprime_y_zero_transform_bypass_flag = false;
    prototype.profile_idc = 0;
    prototype.constraint_set_0_flag = false;
    prototype.constraint_set_1_flag = false;
    prototype.constraint_set_2_flag = false;
    prototype.constraint_set_3_flag = false;
    prototype.constraint_set_4_flag = false;
    prototype.constraint_set_5_flag = false;
    prototype.level_idc = 0;
    prototype.seq_parameter_set_id = 0;
    prototype.residual_color_transform_flag = false;
    prototype.offset_for_non_ref_pic = 0;
    prototype.offset_for_top_to_bottom_field = 0;
    prototype.num_ref_frames = 0;
    prototype.gaps_in_frame_num_value_allowed_flag = false;
    prototype.frame_mbs_only_flag = false;
    prototype.frame_cropping_flag = false;
    prototype.frame_crop_left_offset = 0;
    prototype.frame_crop_right_offset = 0;
    prototype.frame_crop_top_offset = 0;
    prototype.frame_crop_bottom_offset = 0;
    prototype.offsetForRefFrame = null;
    prototype.vuiParams = null;
    prototype.scalingMatrix = null;
    prototype.num_ref_frames_in_pic_order_cnt_cycle = 0;
    constructor.getColor = function(id) {
        switch (id) {
            case 0:
                return ColorSpace.MONO;
            case 1:
                return ColorSpace.YUV420J;
            case 2:
                return ColorSpace.YUV422;
            case 3:
                return ColorSpace.YUV444;
        }
         throw new RuntimeException("Colorspace not supported");
    };
    constructor.fromColor = function(color) {
        if (color == ColorSpace.MONO) {
            return 0;
        } else if (color == ColorSpace.YUV420J) {
            return 1;
        } else if (color == ColorSpace.YUV422) {
            return 2;
        } else if (color == ColorSpace.YUV444) {
            return 3;
        }
         throw new RuntimeException("Colorspace not supported");
    };
    constructor.read = function(is) {
        var _in = BitReader.createBitReader(is);
        var sps = new SeqParameterSet();
        sps.profile_idc = CAVLCReader.readNBit(_in, 8, "SPS: profile_idc");
        sps.constraint_set_0_flag = CAVLCReader.readBool(_in, "SPS: constraint_set_0_flag");
        sps.constraint_set_1_flag = CAVLCReader.readBool(_in, "SPS: constraint_set_1_flag");
        sps.constraint_set_2_flag = CAVLCReader.readBool(_in, "SPS: constraint_set_2_flag");
        sps.constraint_set_3_flag = CAVLCReader.readBool(_in, "SPS: constraint_set_3_flag");
        sps.constraint_set_4_flag = CAVLCReader.readBool(_in, "SPS: constraint_set_4_flag");
        sps.constraint_set_5_flag = CAVLCReader.readBool(_in, "SPS: constraint_set_5_flag");
        CAVLCReader.readNBit(_in, 2, "SPS: reserved_zero_2bits");
        sps.level_idc = stjs.trunc(CAVLCReader.readNBit(_in, 8, "SPS: level_idc"));
        sps.seq_parameter_set_id = CAVLCReader.readUEtrace(_in, "SPS: seq_parameter_set_id");
        if (sps.profile_idc == 100 || sps.profile_idc == 110 || sps.profile_idc == 122 || sps.profile_idc == 144) {
            sps.chroma_format_idc = SeqParameterSet.getColor(CAVLCReader.readUEtrace(_in, "SPS: chroma_format_idc"));
            if (sps.chroma_format_idc == ColorSpace.YUV444) {
                sps.residual_color_transform_flag = CAVLCReader.readBool(_in, "SPS: residual_color_transform_flag");
            }
            sps.bit_depth_luma_minus8 = CAVLCReader.readUEtrace(_in, "SPS: bit_depth_luma_minus8");
            sps.bit_depth_chroma_minus8 = CAVLCReader.readUEtrace(_in, "SPS: bit_depth_chroma_minus8");
            sps.qpprime_y_zero_transform_bypass_flag = CAVLCReader.readBool(_in, "SPS: qpprime_y_zero_transform_bypass_flag");
            var seqScalingMatrixPresent = CAVLCReader.readBool(_in, "SPS: seq_scaling_matrix_present_lag");
            if (seqScalingMatrixPresent) {
                SeqParameterSet.readScalingListMatrix(_in, sps);
            }
        } else {
            sps.chroma_format_idc = ColorSpace.YUV420J;
        }
        sps.log2_max_frame_num_minus4 = CAVLCReader.readUEtrace(_in, "SPS: log2_max_frame_num_minus4");
        sps.pic_order_cnt_type = CAVLCReader.readUEtrace(_in, "SPS: pic_order_cnt_type");
        if (sps.pic_order_cnt_type == 0) {
            sps.log2_max_pic_order_cnt_lsb_minus4 = CAVLCReader.readUEtrace(_in, "SPS: log2_max_pic_order_cnt_lsb_minus4");
        } else if (sps.pic_order_cnt_type == 1) {
            sps.delta_pic_order_always_zero_flag = CAVLCReader.readBool(_in, "SPS: delta_pic_order_always_zero_flag");
            sps.offset_for_non_ref_pic = CAVLCReader.readSE(_in, "SPS: offset_for_non_ref_pic");
            sps.offset_for_top_to_bottom_field = CAVLCReader.readSE(_in, "SPS: offset_for_top_to_bottom_field");
            sps.num_ref_frames_in_pic_order_cnt_cycle = CAVLCReader.readUEtrace(_in, "SPS: num_ref_frames_in_pic_order_cnt_cycle");
            sps.offsetForRefFrame = new Int32Array(sps.num_ref_frames_in_pic_order_cnt_cycle);
            for (var i = 0; i < sps.num_ref_frames_in_pic_order_cnt_cycle; i++) {
                sps.offsetForRefFrame[i] = CAVLCReader.readSE(_in, "SPS: offsetForRefFrame [" + i + "]");
            }
        }
        sps.num_ref_frames = CAVLCReader.readUEtrace(_in, "SPS: num_ref_frames");
        sps.gaps_in_frame_num_value_allowed_flag = CAVLCReader.readBool(_in, "SPS: gaps_in_frame_num_value_allowed_flag");
        sps.pic_width_in_mbs_minus1 = CAVLCReader.readUEtrace(_in, "SPS: pic_width_in_mbs_minus1");
        sps.pic_height_in_map_units_minus1 = CAVLCReader.readUEtrace(_in, "SPS: pic_height_in_map_units_minus1");
        sps.frame_mbs_only_flag = CAVLCReader.readBool(_in, "SPS: frame_mbs_only_flag");
        if (!sps.frame_mbs_only_flag) {
            sps.mb_adaptive_frame_field_flag = CAVLCReader.readBool(_in, "SPS: mb_adaptive_frame_field_flag");
        }
        sps.direct_8x8_inference_flag = CAVLCReader.readBool(_in, "SPS: direct_8x8_inference_flag");
        sps.frame_cropping_flag = CAVLCReader.readBool(_in, "SPS: frame_cropping_flag");
        if (sps.frame_cropping_flag) {
            sps.frame_crop_left_offset = CAVLCReader.readUEtrace(_in, "SPS: frame_crop_left_offset");
            sps.frame_crop_right_offset = CAVLCReader.readUEtrace(_in, "SPS: frame_crop_right_offset");
            sps.frame_crop_top_offset = CAVLCReader.readUEtrace(_in, "SPS: frame_crop_top_offset");
            sps.frame_crop_bottom_offset = CAVLCReader.readUEtrace(_in, "SPS: frame_crop_bottom_offset");
        }
        var vui_parameters_present_flag = CAVLCReader.readBool(_in, "SPS: vui_parameters_present_flag");
        if (vui_parameters_present_flag) 
            sps.vuiParams = SeqParameterSet.readVUIParameters(_in);
        return sps;
    };
    constructor.readScalingListMatrix = function(_in, sps) {
        sps.scalingMatrix = new ScalingMatrix();
        for (var i = 0; i < 8; i++) {
            var seqScalingListPresentFlag = CAVLCReader.readBool(_in, "SPS: seqScalingListPresentFlag");
            if (seqScalingListPresentFlag) {
                sps.scalingMatrix.ScalingList4x4 = Array(8);
                sps.scalingMatrix.ScalingList8x8 = Array(8);
                if (i < 6) {
                    sps.scalingMatrix.ScalingList4x4[i] = ScalingList.read(_in, 16);
                } else {
                    sps.scalingMatrix.ScalingList8x8[i - 6] = ScalingList.read(_in, 64);
                }
            }
        }
    };
    constructor.readVUIParameters = function(_in) {
        var vuip = new VUIParameters();
        vuip.aspect_ratio_info_present_flag = CAVLCReader.readBool(_in, "VUI: aspect_ratio_info_present_flag");
        if (vuip.aspect_ratio_info_present_flag) {
            vuip.aspect_ratio = AspectRatio.fromValue(stjs.trunc(CAVLCReader.readNBit(_in, 8, "VUI: aspect_ratio")));
            if (vuip.aspect_ratio == AspectRatio.Extended_SAR) {
                vuip.sar_width = stjs.trunc(CAVLCReader.readNBit(_in, 16, "VUI: sar_width"));
                vuip.sar_height = stjs.trunc(CAVLCReader.readNBit(_in, 16, "VUI: sar_height"));
            }
        }
        vuip.overscan_info_present_flag = CAVLCReader.readBool(_in, "VUI: overscan_info_present_flag");
        if (vuip.overscan_info_present_flag) {
            vuip.overscan_appropriate_flag = CAVLCReader.readBool(_in, "VUI: overscan_appropriate_flag");
        }
        vuip.video_signal_type_present_flag = CAVLCReader.readBool(_in, "VUI: video_signal_type_present_flag");
        if (vuip.video_signal_type_present_flag) {
            vuip.video_format = stjs.trunc(CAVLCReader.readNBit(_in, 3, "VUI: video_format"));
            vuip.video_full_range_flag = CAVLCReader.readBool(_in, "VUI: video_full_range_flag");
            vuip.colour_description_present_flag = CAVLCReader.readBool(_in, "VUI: colour_description_present_flag");
            if (vuip.colour_description_present_flag) {
                vuip.colour_primaries = stjs.trunc(CAVLCReader.readNBit(_in, 8, "VUI: colour_primaries"));
                vuip.transfer_characteristics = stjs.trunc(CAVLCReader.readNBit(_in, 8, "VUI: transfer_characteristics"));
                vuip.matrix_coefficients = stjs.trunc(CAVLCReader.readNBit(_in, 8, "VUI: matrix_coefficients"));
            }
        }
        vuip.chroma_loc_info_present_flag = CAVLCReader.readBool(_in, "VUI: chroma_loc_info_present_flag");
        if (vuip.chroma_loc_info_present_flag) {
            vuip.chroma_sample_loc_type_top_field = CAVLCReader.readUEtrace(_in, "VUI chroma_sample_loc_type_top_field");
            vuip.chroma_sample_loc_type_bottom_field = CAVLCReader.readUEtrace(_in, "VUI chroma_sample_loc_type_bottom_field");
        }
        vuip.timing_info_present_flag = CAVLCReader.readBool(_in, "VUI: timing_info_present_flag");
        if (vuip.timing_info_present_flag) {
            vuip.num_units_in_tick = stjs.trunc(CAVLCReader.readNBit(_in, 32, "VUI: num_units_in_tick"));
            vuip.time_scale = stjs.trunc(CAVLCReader.readNBit(_in, 32, "VUI: time_scale"));
            vuip.fixed_frame_rate_flag = CAVLCReader.readBool(_in, "VUI: fixed_frame_rate_flag");
        }
        var nal_hrd_parameters_present_flag = CAVLCReader.readBool(_in, "VUI: nal_hrd_parameters_present_flag");
        if (nal_hrd_parameters_present_flag) 
            vuip.nalHRDParams = SeqParameterSet.readHRDParameters(_in);
        var vcl_hrd_parameters_present_flag = CAVLCReader.readBool(_in, "VUI: vcl_hrd_parameters_present_flag");
        if (vcl_hrd_parameters_present_flag) 
            vuip.vclHRDParams = SeqParameterSet.readHRDParameters(_in);
        if (nal_hrd_parameters_present_flag || vcl_hrd_parameters_present_flag) {
            vuip.low_delay_hrd_flag = CAVLCReader.readBool(_in, "VUI: low_delay_hrd_flag");
        }
        vuip.pic_struct_present_flag = CAVLCReader.readBool(_in, "VUI: pic_struct_present_flag");
        var bitstream_restriction_flag = CAVLCReader.readBool(_in, "VUI: bitstream_restriction_flag");
        if (bitstream_restriction_flag) {
            vuip.bitstreamRestriction = new VUIParameters.BitstreamRestriction();
            vuip.bitstreamRestriction.motion_vectors_over_pic_boundaries_flag = CAVLCReader.readBool(_in, "VUI: motion_vectors_over_pic_boundaries_flag");
            vuip.bitstreamRestriction.max_bytes_per_pic_denom = CAVLCReader.readUEtrace(_in, "VUI max_bytes_per_pic_denom");
            vuip.bitstreamRestriction.max_bits_per_mb_denom = CAVLCReader.readUEtrace(_in, "VUI max_bits_per_mb_denom");
            vuip.bitstreamRestriction.log2_max_mv_length_horizontal = CAVLCReader.readUEtrace(_in, "VUI log2_max_mv_length_horizontal");
            vuip.bitstreamRestriction.log2_max_mv_length_vertical = CAVLCReader.readUEtrace(_in, "VUI log2_max_mv_length_vertical");
            vuip.bitstreamRestriction.num_reorder_frames = CAVLCReader.readUEtrace(_in, "VUI num_reorder_frames");
            vuip.bitstreamRestriction.max_dec_frame_buffering = CAVLCReader.readUEtrace(_in, "VUI max_dec_frame_buffering");
        }
        return vuip;
    };
    constructor.readHRDParameters = function(_in) {
        var hrd = new HRDParameters();
        hrd.cpb_cnt_minus1 = CAVLCReader.readUEtrace(_in, "SPS: cpb_cnt_minus1");
        hrd.bit_rate_scale = stjs.trunc(CAVLCReader.readNBit(_in, 4, "HRD: bit_rate_scale"));
        hrd.cpb_size_scale = stjs.trunc(CAVLCReader.readNBit(_in, 4, "HRD: cpb_size_scale"));
        hrd.bit_rate_value_minus1 = new Int32Array(hrd.cpb_cnt_minus1 + 1);
        hrd.cpb_size_value_minus1 = new Int32Array(hrd.cpb_cnt_minus1 + 1);
        hrd.cbr_flag = new Int8Array(hrd.cpb_cnt_minus1 + 1);
        for (var SchedSelIdx = 0; SchedSelIdx <= hrd.cpb_cnt_minus1; SchedSelIdx++) {
            hrd.bit_rate_value_minus1[SchedSelIdx] = CAVLCReader.readUEtrace(_in, "HRD: bit_rate_value_minus1");
            hrd.cpb_size_value_minus1[SchedSelIdx] = CAVLCReader.readUEtrace(_in, "HRD: cpb_size_value_minus1");
            hrd.cbr_flag[SchedSelIdx] = CAVLCReader.readBool(_in, "HRD: cbr_flag");
        }
        hrd.initial_cpb_removal_delay_length_minus1 = stjs.trunc(CAVLCReader.readNBit(_in, 5, "HRD: initial_cpb_removal_delay_length_minus1"));
        hrd.cpb_removal_delay_length_minus1 = stjs.trunc(CAVLCReader.readNBit(_in, 5, "HRD: cpb_removal_delay_length_minus1"));
        hrd.dpb_output_delay_length_minus1 = stjs.trunc(CAVLCReader.readNBit(_in, 5, "HRD: dpb_output_delay_length_minus1"));
        hrd.time_offset_length = stjs.trunc(CAVLCReader.readNBit(_in, 5, "HRD: time_offset_length"));
        return hrd;
    };
    prototype.write = function(out) {
        var writer = new BitWriter(out);
        CAVLCWriter.writeNBit(writer, this.profile_idc, 8, "SPS: profile_idc");
        CAVLCWriter.writeBool(writer, this.constraint_set_0_flag, "SPS: constraint_set_0_flag");
        CAVLCWriter.writeBool(writer, this.constraint_set_1_flag, "SPS: constraint_set_1_flag");
        CAVLCWriter.writeBool(writer, this.constraint_set_2_flag, "SPS: constraint_set_2_flag");
        CAVLCWriter.writeBool(writer, this.constraint_set_3_flag, "SPS: constraint_set_3_flag");
        CAVLCWriter.writeBool(writer, this.constraint_set_4_flag, "SPS: constraint_set_4_flag");
        CAVLCWriter.writeBool(writer, this.constraint_set_5_flag, "SPS: constraint_set_5_flag");
        CAVLCWriter.writeNBit(writer, 0, 2, "SPS: reserved");
        CAVLCWriter.writeNBit(writer, this.level_idc, 8, "SPS: level_idc");
        CAVLCWriter.writeUEtrace(writer, this.seq_parameter_set_id, "SPS: seq_parameter_set_id");
        if (this.profile_idc == 100 || this.profile_idc == 110 || this.profile_idc == 122 || this.profile_idc == 144) {
            CAVLCWriter.writeUEtrace(writer, SeqParameterSet.fromColor(this.chroma_format_idc), "SPS: chroma_format_idc");
            if (this.chroma_format_idc == ColorSpace.YUV444) {
                CAVLCWriter.writeBool(writer, this.residual_color_transform_flag, "SPS: residual_color_transform_flag");
            }
            CAVLCWriter.writeUEtrace(writer, this.bit_depth_luma_minus8, "SPS: ");
            CAVLCWriter.writeUEtrace(writer, this.bit_depth_chroma_minus8, "SPS: ");
            CAVLCWriter.writeBool(writer, this.qpprime_y_zero_transform_bypass_flag, "SPS: qpprime_y_zero_transform_bypass_flag");
            CAVLCWriter.writeBool(writer, this.scalingMatrix != null, "SPS: ");
            if (this.scalingMatrix != null) {
                for (var i = 0; i < 8; i++) {
                    if (i < 6) {
                        CAVLCWriter.writeBool(writer, this.scalingMatrix.ScalingList4x4[i] != null, "SPS: ");
                        if (this.scalingMatrix.ScalingList4x4[i] != null) {
                            this.scalingMatrix.ScalingList4x4[i].write(writer);
                        }
                    } else {
                        CAVLCWriter.writeBool(writer, this.scalingMatrix.ScalingList8x8[i - 6] != null, "SPS: ");
                        if (this.scalingMatrix.ScalingList8x8[i - 6] != null) {
                            this.scalingMatrix.ScalingList8x8[i - 6].write(writer);
                        }
                    }
                }
            }
        }
        CAVLCWriter.writeUEtrace(writer, this.log2_max_frame_num_minus4, "SPS: log2_max_frame_num_minus4");
        CAVLCWriter.writeUEtrace(writer, this.pic_order_cnt_type, "SPS: pic_order_cnt_type");
        if (this.pic_order_cnt_type == 0) {
            CAVLCWriter.writeUEtrace(writer, this.log2_max_pic_order_cnt_lsb_minus4, "SPS: log2_max_pic_order_cnt_lsb_minus4");
        } else if (this.pic_order_cnt_type == 1) {
            CAVLCWriter.writeBool(writer, this.delta_pic_order_always_zero_flag, "SPS: delta_pic_order_always_zero_flag");
            CAVLCWriter.writeSEtrace(writer, this.offset_for_non_ref_pic, "SPS: offset_for_non_ref_pic");
            CAVLCWriter.writeSEtrace(writer, this.offset_for_top_to_bottom_field, "SPS: offset_for_top_to_bottom_field");
            CAVLCWriter.writeUEtrace(writer, this.offsetForRefFrame.length, "SPS: ");
            for (var i = 0; i < this.offsetForRefFrame.length; i++) 
                CAVLCWriter.writeSEtrace(writer, this.offsetForRefFrame[i], "SPS: ");
        }
        CAVLCWriter.writeUEtrace(writer, this.num_ref_frames, "SPS: num_ref_frames");
        CAVLCWriter.writeBool(writer, this.gaps_in_frame_num_value_allowed_flag, "SPS: gaps_in_frame_num_value_allowed_flag");
        CAVLCWriter.writeUEtrace(writer, this.pic_width_in_mbs_minus1, "SPS: pic_width_in_mbs_minus1");
        CAVLCWriter.writeUEtrace(writer, this.pic_height_in_map_units_minus1, "SPS: pic_height_in_map_units_minus1");
        CAVLCWriter.writeBool(writer, this.frame_mbs_only_flag, "SPS: frame_mbs_only_flag");
        if (!this.frame_mbs_only_flag) {
            CAVLCWriter.writeBool(writer, this.mb_adaptive_frame_field_flag, "SPS: mb_adaptive_frame_field_flag");
        }
        CAVLCWriter.writeBool(writer, this.direct_8x8_inference_flag, "SPS: direct_8x8_inference_flag");
        CAVLCWriter.writeBool(writer, this.frame_cropping_flag, "SPS: frame_cropping_flag");
        if (this.frame_cropping_flag) {
            CAVLCWriter.writeUEtrace(writer, this.frame_crop_left_offset, "SPS: frame_crop_left_offset");
            CAVLCWriter.writeUEtrace(writer, this.frame_crop_right_offset, "SPS: frame_crop_right_offset");
            CAVLCWriter.writeUEtrace(writer, this.frame_crop_top_offset, "SPS: frame_crop_top_offset");
            CAVLCWriter.writeUEtrace(writer, this.frame_crop_bottom_offset, "SPS: frame_crop_bottom_offset");
        }
        CAVLCWriter.writeBool(writer, this.vuiParams != null, "SPS: ");
        if (this.vuiParams != null) 
            this.writeVUIParameters(this.vuiParams, writer);
        CAVLCWriter.writeTrailingBits(writer);
    };
    prototype.writeVUIParameters = function(vuip, writer) {
        CAVLCWriter.writeBool(writer, vuip.aspect_ratio_info_present_flag, "VUI: aspect_ratio_info_present_flag");
        if (vuip.aspect_ratio_info_present_flag) {
            CAVLCWriter.writeNBit(writer, vuip.aspect_ratio.getValue(), 8, "VUI: aspect_ratio");
            if (vuip.aspect_ratio == AspectRatio.Extended_SAR) {
                CAVLCWriter.writeNBit(writer, vuip.sar_width, 16, "VUI: sar_width");
                CAVLCWriter.writeNBit(writer, vuip.sar_height, 16, "VUI: sar_height");
            }
        }
        CAVLCWriter.writeBool(writer, vuip.overscan_info_present_flag, "VUI: overscan_info_present_flag");
        if (vuip.overscan_info_present_flag) {
            CAVLCWriter.writeBool(writer, vuip.overscan_appropriate_flag, "VUI: overscan_appropriate_flag");
        }
        CAVLCWriter.writeBool(writer, vuip.video_signal_type_present_flag, "VUI: video_signal_type_present_flag");
        if (vuip.video_signal_type_present_flag) {
            CAVLCWriter.writeNBit(writer, vuip.video_format, 3, "VUI: video_format");
            CAVLCWriter.writeBool(writer, vuip.video_full_range_flag, "VUI: video_full_range_flag");
            CAVLCWriter.writeBool(writer, vuip.colour_description_present_flag, "VUI: colour_description_present_flag");
            if (vuip.colour_description_present_flag) {
                CAVLCWriter.writeNBit(writer, vuip.colour_primaries, 8, "VUI: colour_primaries");
                CAVLCWriter.writeNBit(writer, vuip.transfer_characteristics, 8, "VUI: transfer_characteristics");
                CAVLCWriter.writeNBit(writer, vuip.matrix_coefficients, 8, "VUI: matrix_coefficients");
            }
        }
        CAVLCWriter.writeBool(writer, vuip.chroma_loc_info_present_flag, "VUI: chroma_loc_info_present_flag");
        if (vuip.chroma_loc_info_present_flag) {
            CAVLCWriter.writeUEtrace(writer, vuip.chroma_sample_loc_type_top_field, "VUI: chroma_sample_loc_type_top_field");
            CAVLCWriter.writeUEtrace(writer, vuip.chroma_sample_loc_type_bottom_field, "VUI: chroma_sample_loc_type_bottom_field");
        }
        CAVLCWriter.writeBool(writer, vuip.timing_info_present_flag, "VUI: timing_info_present_flag");
        if (vuip.timing_info_present_flag) {
            CAVLCWriter.writeNBit(writer, vuip.num_units_in_tick, 32, "VUI: num_units_in_tick");
            CAVLCWriter.writeNBit(writer, vuip.time_scale, 32, "VUI: time_scale");
            CAVLCWriter.writeBool(writer, vuip.fixed_frame_rate_flag, "VUI: fixed_frame_rate_flag");
        }
        CAVLCWriter.writeBool(writer, vuip.nalHRDParams != null, "VUI: ");
        if (vuip.nalHRDParams != null) {
            this.writeHRDParameters(vuip.nalHRDParams, writer);
        }
        CAVLCWriter.writeBool(writer, vuip.vclHRDParams != null, "VUI: ");
        if (vuip.vclHRDParams != null) {
            this.writeHRDParameters(vuip.vclHRDParams, writer);
        }
        if (vuip.nalHRDParams != null || vuip.vclHRDParams != null) {
            CAVLCWriter.writeBool(writer, vuip.low_delay_hrd_flag, "VUI: low_delay_hrd_flag");
        }
        CAVLCWriter.writeBool(writer, vuip.pic_struct_present_flag, "VUI: pic_struct_present_flag");
        CAVLCWriter.writeBool(writer, vuip.bitstreamRestriction != null, "VUI: ");
        if (vuip.bitstreamRestriction != null) {
            CAVLCWriter.writeBool(writer, vuip.bitstreamRestriction.motion_vectors_over_pic_boundaries_flag, "VUI: motion_vectors_over_pic_boundaries_flag");
            CAVLCWriter.writeUEtrace(writer, vuip.bitstreamRestriction.max_bytes_per_pic_denom, "VUI: max_bytes_per_pic_denom");
            CAVLCWriter.writeUEtrace(writer, vuip.bitstreamRestriction.max_bits_per_mb_denom, "VUI: max_bits_per_mb_denom");
            CAVLCWriter.writeUEtrace(writer, vuip.bitstreamRestriction.log2_max_mv_length_horizontal, "VUI: log2_max_mv_length_horizontal");
            CAVLCWriter.writeUEtrace(writer, vuip.bitstreamRestriction.log2_max_mv_length_vertical, "VUI: log2_max_mv_length_vertical");
            CAVLCWriter.writeUEtrace(writer, vuip.bitstreamRestriction.num_reorder_frames, "VUI: num_reorder_frames");
            CAVLCWriter.writeUEtrace(writer, vuip.bitstreamRestriction.max_dec_frame_buffering, "VUI: max_dec_frame_buffering");
        }
    };
    prototype.writeHRDParameters = function(hrd, writer) {
        CAVLCWriter.writeUEtrace(writer, hrd.cpb_cnt_minus1, "HRD: cpb_cnt_minus1");
        CAVLCWriter.writeNBit(writer, hrd.bit_rate_scale, 4, "HRD: bit_rate_scale");
        CAVLCWriter.writeNBit(writer, hrd.cpb_size_scale, 4, "HRD: cpb_size_scale");
        for (var SchedSelIdx = 0; SchedSelIdx <= hrd.cpb_cnt_minus1; SchedSelIdx++) {
            CAVLCWriter.writeUEtrace(writer, hrd.bit_rate_value_minus1[SchedSelIdx], "HRD: ");
            CAVLCWriter.writeUEtrace(writer, hrd.cpb_size_value_minus1[SchedSelIdx], "HRD: ");
            CAVLCWriter.writeBool(writer, hrd.cbr_flag[SchedSelIdx], "HRD: ");
        }
        CAVLCWriter.writeNBit(writer, hrd.initial_cpb_removal_delay_length_minus1, 5, "HRD: initial_cpb_removal_delay_length_minus1");
        CAVLCWriter.writeNBit(writer, hrd.cpb_removal_delay_length_minus1, 5, "HRD: cpb_removal_delay_length_minus1");
        CAVLCWriter.writeNBit(writer, hrd.dpb_output_delay_length_minus1, 5, "HRD: dpb_output_delay_length_minus1");
        CAVLCWriter.writeNBit(writer, hrd.time_offset_length, 5, "HRD: time_offset_length");
    };
    prototype.copy = function() {
        var buf = ByteBuffer.allocate(2048);
        this.write(buf);
        buf.flip();
        return SeqParameterSet.read(buf);
    };
    prototype.getPic_order_cnt_type = function() {
        return this.pic_order_cnt_type;
    };
    prototype.isField_pic_flag = function() {
        return this.field_pic_flag;
    };
    prototype.isDelta_pic_order_always_zero_flag = function() {
        return this.delta_pic_order_always_zero_flag;
    };
    prototype.isMb_adaptive_frame_field_flag = function() {
        return this.mb_adaptive_frame_field_flag;
    };
    prototype.isDirect_8x8_inference_flag = function() {
        return this.direct_8x8_inference_flag;
    };
    prototype.getChroma_format_idc = function() {
        return this.chroma_format_idc;
    };
    prototype.getLog2_max_frame_num_minus4 = function() {
        return this.log2_max_frame_num_minus4;
    };
    prototype.getLog2_max_pic_order_cnt_lsb_minus4 = function() {
        return this.log2_max_pic_order_cnt_lsb_minus4;
    };
    prototype.getPic_height_in_map_units_minus1 = function() {
        return this.pic_height_in_map_units_minus1;
    };
    prototype.getPic_width_in_mbs_minus1 = function() {
        return this.pic_width_in_mbs_minus1;
    };
    prototype.getBit_depth_luma_minus8 = function() {
        return this.bit_depth_luma_minus8;
    };
    prototype.getBit_depth_chroma_minus8 = function() {
        return this.bit_depth_chroma_minus8;
    };
    prototype.isQpprime_y_zero_transform_bypass_flag = function() {
        return this.qpprime_y_zero_transform_bypass_flag;
    };
    prototype.getProfile_idc = function() {
        return this.profile_idc;
    };
    prototype.isConstraint_set_0_flag = function() {
        return this.constraint_set_0_flag;
    };
    prototype.isConstraint_set_1_flag = function() {
        return this.constraint_set_1_flag;
    };
    prototype.isConstraint_set_2_flag = function() {
        return this.constraint_set_2_flag;
    };
    prototype.isConstraint_set_3_flag = function() {
        return this.constraint_set_3_flag;
    };
    prototype.isConstraint_set_4_flag = function() {
        return this.constraint_set_4_flag;
    };
    prototype.isConstraint_set_5_flag = function() {
        return this.constraint_set_5_flag;
    };
    prototype.getLevel_idc = function() {
        return this.level_idc;
    };
    prototype.getSeq_parameter_set_id = function() {
        return this.seq_parameter_set_id;
    };
    prototype.isResidual_color_transform_flag = function() {
        return this.residual_color_transform_flag;
    };
    prototype.getOffset_for_non_ref_pic = function() {
        return this.offset_for_non_ref_pic;
    };
    prototype.getOffset_for_top_to_bottom_field = function() {
        return this.offset_for_top_to_bottom_field;
    };
    prototype.getNum_ref_frames = function() {
        return this.num_ref_frames;
    };
    prototype.isGaps_in_frame_num_value_allowed_flag = function() {
        return this.gaps_in_frame_num_value_allowed_flag;
    };
    prototype.isFrame_mbs_only_flag = function() {
        return this.frame_mbs_only_flag;
    };
    prototype.isFrame_cropping_flag = function() {
        return this.frame_cropping_flag;
    };
    prototype.getFrame_crop_left_offset = function() {
        return this.frame_crop_left_offset;
    };
    prototype.getFrame_crop_right_offset = function() {
        return this.frame_crop_right_offset;
    };
    prototype.getFrame_crop_top_offset = function() {
        return this.frame_crop_top_offset;
    };
    prototype.getFrame_crop_bottom_offset = function() {
        return this.frame_crop_bottom_offset;
    };
    prototype.getOffsetForRefFrame = function() {
        return this.offsetForRefFrame;
    };
    prototype.getVuiParams = function() {
        return this.vuiParams;
    };
    prototype.getScalingMatrix = function() {
        return this.scalingMatrix;
    };
    prototype.getNum_ref_frames_in_pic_order_cnt_cycle = function() {
        return this.num_ref_frames_in_pic_order_cnt_cycle;
    };
    constructor.getPicHeightInMbs = function(sps) {
        var picHeightInMbs = (sps.pic_height_in_map_units_minus1 + 1) << (sps.frame_mbs_only_flag ? 0 : 1);
        return picHeightInMbs;
    };
}, {chroma_format_idc: "ColorSpace", offsetForRefFrame: "Int32Array", vuiParams: "VUIParameters", scalingMatrix: "ScalingMatrix"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Pulls frames from MPEG elementary stream
 *  
 *  @author The JCodec project
 *  
 */
var MPEGES = function(channel, fetchSize) {
    SegmentReader.call(this, channel, fetchSize);
};
MPEGES = stjs.extend(MPEGES, SegmentReader, [], function(constructor, prototype) {
    prototype.frameNo = 0;
    prototype.curPts = 0;
    prototype.getFrame = function(buffer) {
        var dup = buffer.duplicate();
         while (this.curMarker != 256 && this.curMarker != 435 && this.skipToMarker())
            ;
         while (this.curMarker != 256 && this.readToNextMarker(dup))
            ;
        this.readToNextMarker(dup);
         while (this.curMarker != 256 && this.curMarker != 435 && this.readToNextMarker(dup))
            ;
        dup.flip();
        return dup.hasRemaining() ? new MPEGPacket(dup, this.curPts, 90000, 0, this.frameNo++, true, null) : null;
    };
}, {channel: "ReadableByteChannel", buf: "ByteBuffer"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Retrieves chunks for the range concurrently allowing for concurrent
 *  transcode-on-the-fly
 *  
 *  @author The JCodec project
 *  
 */
var ConcurrentMovieRangeService = function(movie, nThreads) {
    this.exec = Executors.newFixedThreadPool(nThreads, new (stjs.extend(function ConcurrentMovieRangeService$1() {}, null, [ThreadFactory], function(constructor, prototype) {
        prototype.newThread = function(runnable) {
            var thread = Executors.defaultThreadFactory().newThread(runnable);
            thread.setDaemon(true);
            return thread;
        };
    }, {}, {}))());
    this.movie = movie;
};
ConcurrentMovieRangeService = stjs.extend(ConcurrentMovieRangeService, null, [], function(constructor, prototype) {
    prototype.exec = null;
    prototype.movie = null;
    prototype.shutdown = function() {
        this.exec.shutdown();
    };
    prototype.getRange = function(from, to) {
        return new ConcurrentMovieRangeService.ConcurrentMovieRange(this, from, to);
    };
    constructor.GetCallable = function(segment) {
        this.segment = segment;
    };
    constructor.GetCallable = stjs.extend(constructor.GetCallable, null, [Callable], function(constructor, prototype) {
        prototype.segment = null;
        prototype.call = function() {
            return MovieRange.checkDataLen(this.segment.getData() == null ? null : this.segment.getData().duplicate(), this.segment.getDataLen());
        };
    }, {segment: "MovieSegment"}, {});
    constructor.ConcurrentMovieRange = function(svc, from, to) {
        BaseInputStream.call(this);
        this.segments = new ArrayList();
        this.svc = svc;
        if (to < from) 
             throw new IllegalArgumentException("from < to");
        this.remaining = to - from + 1;
        this.to = to;
        var segment = svc.movie.getPacketAt(from);
        if (segment != null) {
            this.nextReadAheadNo = segment.getNo();
            this.scheduleSegmentRetrieve(segment);
            for (var i = 0; i < ConcurrentMovieRangeService.ConcurrentMovieRange.READ_AHEAD_SEGMENTS; i++) 
                this.tryReadAhead();
            var data = this.segmentData();
            NIOUtils.skip(data, (((from - segment.getPos())) | 0));
        }
    };
    constructor.ConcurrentMovieRange = stjs.extend(constructor.ConcurrentMovieRange, BaseInputStream, [], function(constructor, prototype) {
        constructor.READ_AHEAD_SEGMENTS = 10;
        prototype.segments = null;
        prototype.nextReadAheadNo = 0;
        prototype.remaining = 0;
        prototype.to = 0;
        prototype.svc = null;
        prototype.readBuffer = function(b, from, len) {
            if (this.segments.size() == 0 || this.remaining == 0) 
                return -1;
            len = ((Math.min(len, this.remaining)) | 0);
            var totalRead = 0;
             while (len > 0 && this.segments.size() > 0){
                var segmentData = this.segmentData();
                var toRead = Math.min(segmentData.remaining(), len);
                segmentData.getBuf3(b, from, toRead);
                totalRead += toRead;
                len -= toRead;
                from += toRead;
                this.disposeReadAhead(segmentData);
            }
            this.remaining -= totalRead;
            return totalRead;
        };
        prototype.disposeReadAhead = function(segmentData) {
            if (!segmentData.hasRemaining()) {
                this.segments.remove(0);
                this.tryReadAhead();
            }
        };
        prototype.tryReadAhead = function() {
            var segment = this.svc.movie.getPacketByNo(this.nextReadAheadNo);
            if (segment != null && segment.getPos() < this.to) {
                this.scheduleSegmentRetrieve(segment);
            }
        };
        prototype.scheduleSegmentRetrieve = function(segment) {
            var submit = this.svc.exec.submit(new ConcurrentMovieRangeService.GetCallable(segment));
            this.segments.add(submit);
            this.nextReadAheadNo++;
        };
        prototype.segmentData = function() {
            var segmentData;
            try {
                segmentData = this.segments.get(0).get();
            }catch (e) {
                 throw new IOException(e);
            }
            return segmentData;
        };
        prototype.close = function() {
            for (var iterator$future = this.segments.iterator(); iterator$future.hasNext(); ) {
                var future = iterator$future.next();
                future.cancel(false);
            }
        };
        prototype.readByte = function() {
            if (this.segments.size() == 0 || this.remaining == 0) 
                return -1;
            var segmentData = this.segmentData();
            var ret = segmentData.get() & 255;
            this.disposeReadAhead(segmentData);
            --this.remaining;
            return ret;
        };
    }, {segments: {name: "List", arguments: [{name: "Future", arguments: ["ByteBuffer"]}]}, svc: "ConcurrentMovieRangeService"}, {});
}, {exec: "ExecutorService", movie: "VirtualMovie"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var DecoderSpecific = function(data) {
    Descriptor.call(this, DecoderSpecific.tag(), 0);
    this.data = data;
};
DecoderSpecific = stjs.extend(DecoderSpecific, Descriptor, [], function(constructor, prototype) {
    prototype.data = null;
    prototype.doWrite = function(out) {
        NIOUtils.write(out, this.data);
    };
    constructor.tag = function() {
        return 5;
    };
    prototype.getData = function() {
        return this.data;
    };
    prototype.parse = function(input) {
        this.data = NIOUtils.readBuf(input);
    };
}, {data: "ByteBuffer", factory: "IDescriptorFactory"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var SL = function() {
    Descriptor.call(this, SL.tag(), 0);
};
SL = stjs.extend(SL, Descriptor, [], function(constructor, prototype) {
    prototype.doWrite = function(out) {
        out.put((2 << 24 >> 24));
    };
    prototype.parse = function(input) {
        Assert.assertEquals(2, input.get() & 255);
    };
    constructor.tag = function() {
        return 6;
    };
}, {factory: "IDescriptorFactory"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var NodeDescriptor = function(tag, children) {
    Descriptor.call(this, tag, 0);
    this.children = new ArrayList();
    this.children.addAll(Arrays.asList(children));
};
NodeDescriptor = stjs.extend(NodeDescriptor, Descriptor, [], function(constructor, prototype) {
    prototype.children = null;
    prototype.doWrite = function(out) {
        for (var iterator$descr = this.children.iterator(); iterator$descr.hasNext(); ) {
            var descr = iterator$descr.next();
            descr.write(out);
        }
    };
    prototype.getChildren = function() {
        return this.children;
    };
    prototype.parse = function(input) {
        var d;
        do {
            d = Descriptor.read(input, this.factory);
            if (d != null) 
                this.children.add(d);
        } while (d != null);
    };
    constructor.find = function(es, class1, tag) {
        if (es.getTag() == tag) 
            return es;
         else {
            if (stjs.isInstanceOf(es.constructor, NodeDescriptor)) {
                for (var iterator$descriptor = (es).getChildren().iterator(); iterator$descriptor.hasNext(); ) {
                    var descriptor = iterator$descriptor.next();
                    var res = NodeDescriptor.find(descriptor, class1, tag);
                    if (res != null) 
                        return res;
                }
            }
        }
        return null;
    };
}, {children: {name: "Collection", arguments: ["Descriptor"]}, factory: "IDescriptorFactory"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Represents PMT ( Program Map Table ) of the MPEG Transport stream
 *  
 *  This section contains information about streams of an individual program, a
 *  program usually contains two or more streams, such as video, audio, text,
 *  etc..
 *  
 *  @author The JCodec project
 *  
 */
var PMTSection = function(psi, pcrPid, tags, streams) {
    PSISection.call(this, psi.tableId, psi.specificId, psi.versionNumber, psi.currentNextIndicator, psi.sectionNumber, psi.lastSectionNumber);
    this.pcrPid = pcrPid;
    this.tags = tags;
    this.streams = streams;
};
PMTSection = stjs.extend(PMTSection, PSISection, [], function(constructor, prototype) {
    prototype.pcrPid = 0;
    prototype.tags = null;
    prototype.streams = null;
    prototype.getPcrPid = function() {
        return this.pcrPid;
    };
    prototype.getTags = function() {
        return this.tags;
    };
    prototype.getStreams = function() {
        return this.streams;
    };
    constructor.parsePMT = function(data) {
        var psi = PSISection.parsePSI(data);
        var w1 = data.getShort() & 65535;
        var pcrPid = w1 & 8191;
        var w2 = data.getShort() & 65535;
        var programInfoLength = w2 & 4095;
        var tags = PMTSection.parseTags(NIOUtils.read(data, programInfoLength));
        var streams = new ArrayList();
         while (data.remaining() > 4){
            var streamType = data.get() & 255;
            var wn = data.getShort() & 65535;
            var elementaryPid = wn & 8191;
            var wn1 = data.getShort() & 65535;
            var esInfoLength = wn1 & 4095;
            var read = NIOUtils.read(data, esInfoLength);
            streams.add(new PMTSection.PMTStream(streamType, elementaryPid, MPSUtils.parseDescriptors(read)));
        }
        return new PMTSection(psi, pcrPid, tags.toArray(Array(0)), streams.toArray(Array(0)));
    };
    constructor.parseTags = function(bb) {
        var tags = new ArrayList();
         while (bb.hasRemaining()){
            var tag = bb.get();
            var tagLen = bb.get();
            tags.add(new PMTSection.Tag(tag, NIOUtils.read(bb, tagLen)));
        }
        return tags;
    };
    constructor.Tag = function(tag, content) {
        this.tag = tag;
        this.content = content;
    };
    constructor.Tag = stjs.extend(constructor.Tag, null, [], function(constructor, prototype) {
        prototype.tag = 0;
        prototype.content = null;
        prototype.getTag = function() {
            return this.tag;
        };
        prototype.getContent = function() {
            return this.content;
        };
    }, {content: "ByteBuffer"}, {});
    constructor.PMTStream = function(streamTypeTag, pid, descriptors) {
        this.streamTypeTag = streamTypeTag;
        this.pid = pid;
        this.descriptors = descriptors;
        this.streamType = MTSStreamType.fromTag(streamTypeTag);
    };
    constructor.PMTStream = stjs.extend(constructor.PMTStream, null, [], function(constructor, prototype) {
        prototype.streamTypeTag = 0;
        prototype.pid = 0;
        prototype.descriptors = null;
        prototype.streamType = null;
        prototype.getStreamTypeTag = function() {
            return this.streamTypeTag;
        };
        prototype.getStreamType = function() {
            return this.streamType;
        };
        prototype.getPid = function() {
            return this.pid;
        };
        prototype.getDesctiptors = function() {
            return this.descriptors;
        };
    }, {descriptors: {name: "List", arguments: ["MPSUtils.MPEGMediaDescriptor"]}, streamType: "MTSStreamType"}, {});
}, {tags: "Array", streams: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var KLV = function(k, len, offset, dataOffset) {
    this.key = k;
    this.len = len;
    this.offset = offset;
    this.dataOffset = dataOffset;
};
KLV = stjs.extend(KLV, null, [], function(constructor, prototype) {
    prototype.offset = 0;
    prototype.dataOffset = 0;
    prototype.key = null;
    prototype.len = 0;
    prototype.value = null;
    prototype.toString = function() {
        return "KLV [offset=" + this.offset + ", dataOffset=" + this.dataOffset + ", key=" + this.key + ", len=" + this.len + ", value=" + this.value + "]";
    };
    constructor.readKL = function(ch) {
        var offset = ch.position();
        if (offset >= ch.size() - 1) 
            return null;
        var key = new Int8Array(16);
        ch.read(ByteBuffer.wrap(key));
        var len = BER.decodeLength(ch);
        var dataOffset = ch.position();
        return new KLV(new UL(key), len, offset, dataOffset);
    };
    /**
     *  @return byte count of BER encoded "length" field
     */
    prototype.getLenByteCount = function() {
        var berlen = (((this.dataOffset - this.offset - 16)) | 0);
        return berlen <= 0 ? 4 : berlen;
    };
    constructor.matches = function(key1, key2, len) {
        for (var i = 0; i < len; i++) 
            if (key1[i] != key2[i]) 
                return false;
        return true;
    };
    constructor.readKLFromBuffer = function(buffer, baseOffset) {
        if (buffer.remaining() < 17) 
            return null;
        var offset = baseOffset + buffer.position();
        var ul = UL.read(buffer);
        var len = BER.decodeLengthBuf(buffer);
        return new KLV(ul, len, offset, baseOffset + buffer.position());
    };
}, {key: "UL", value: "ByteBuffer"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A script of instructions applied to reference picture list
 *  
 *  @author The JCodec project
 *  
 */
var RefPicMarking = function(instructions) {
    this.instructions = instructions;
};
RefPicMarking = stjs.extend(RefPicMarking, null, [], function(constructor, prototype) {
    constructor.InstrType = stjs.enumeration("REMOVE_SHORT", "REMOVE_LONG", "CONVERT_INTO_LONG", "TRUNK_LONG", "CLEAR", "MARK_LONG");
    constructor.Instruction = function(type, arg1, arg2) {
        this.type = type;
        this.arg1 = arg1;
        this.arg2 = arg2;
    };
    constructor.Instruction = stjs.extend(constructor.Instruction, null, [], function(constructor, prototype) {
        prototype.type = null;
        prototype.arg1 = 0;
        prototype.arg2 = 0;
        prototype.getType = function() {
            return this.type;
        };
        prototype.getArg1 = function() {
            return this.arg1;
        };
        prototype.getArg2 = function() {
            return this.arg2;
        };
    }, {type: {name: "Enum", arguments: ["RefPicMarking.InstrType"]}}, {});
    prototype.instructions = null;
    prototype.getInstructions = function() {
        return this.instructions;
    };
    prototype.toString = function() {
        return ToJSON.toJSON(this);
    };
}, {instructions: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Slice header H264 bitstream entity
 *  
 *  capable to serialize / deserialize with CAVLC bitstream
 *  
 *  @author The JCodec project
 *  
 */
var SliceHeader = function() {
    this.num_ref_idx_active_minus1 = new Int32Array(2);
};
SliceHeader = stjs.extend(SliceHeader, null, [], function(constructor, prototype) {
    prototype.sps = null;
    prototype.pps = null;
    prototype.refPicMarkingNonIDR = null;
    prototype.refPicMarkingIDR = null;
    prototype.refPicReordering = null;
    prototype.pred_weight_table = null;
    prototype.first_mb_in_slice = 0;
    prototype.field_pic_flag = false;
    prototype.slice_type = null;
    prototype.slice_type_restr = false;
    prototype.pic_parameter_set_id = 0;
    prototype.frame_num = 0;
    prototype.bottom_field_flag = false;
    prototype.idr_pic_id = 0;
    prototype.pic_order_cnt_lsb = 0;
    prototype.delta_pic_order_cnt_bottom = 0;
    prototype.delta_pic_order_cnt = null;
    prototype.redundant_pic_cnt = 0;
    prototype.direct_spatial_mv_pred_flag = false;
    prototype.num_ref_idx_active_override_flag = false;
    prototype.num_ref_idx_active_minus1 = null;
    prototype.cabac_init_idc = 0;
    prototype.slice_qp_delta = 0;
    prototype.sp_for_switch_flag = false;
    prototype.slice_qs_delta = 0;
    prototype.disable_deblocking_filter_idc = 0;
    prototype.slice_alpha_c0_offset_div2 = 0;
    prototype.slice_beta_offset_div2 = 0;
    prototype.slice_group_change_cycle = 0;
    prototype.toString = function() {
        return ToJSON.toJSON(this);
    };
}, {sps: "SeqParameterSet", pps: "PictureParameterSet", refPicMarkingNonIDR: "RefPicMarking", refPicMarkingIDR: "RefPicMarkingIDR", refPicReordering: "Array", pred_weight_table: "PredictionWeightTable", slice_type: "SliceType", delta_pic_order_cnt: "Int32Array", num_ref_idx_active_minus1: "Int32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Reference picture marking used for IDR frames
 *  
 *  @author The JCodec project
 *  
 */
var RefPicMarkingIDR = function(discardDecodedPics, useForlongTerm) {
    this.discardDecodedPics = discardDecodedPics;
    this.useForlongTerm = useForlongTerm;
};
RefPicMarkingIDR = stjs.extend(RefPicMarkingIDR, null, [], function(constructor, prototype) {
    prototype.discardDecodedPics = false;
    prototype.useForlongTerm = false;
    prototype.isDiscardDecodedPics = function() {
        return this.discardDecodedPics;
    };
    prototype.isUseForlongTerm = function() {
        return this.useForlongTerm;
    };
    prototype.toString = function() {
        return ToJSON.toJSON(this);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Represents index for MPEG PS stream, enables demuxers to do precise seek
 *  
 *  @author The JCodec project
 *  
 */
var MPSIndex = function(pesTokens, pesStreamIds, streams) {
    this.pesTokens = pesTokens;
    this.pesStreamIds = pesStreamIds;
    this.streams = streams;
};
MPSIndex = stjs.extend(MPSIndex, null, [], function(constructor, prototype) {
    prototype.pesTokens = null;
    prototype.pesStreamIds = null;
    prototype.streams = null;
    constructor.MPSStreamIndex = function(streamId, fsizes, fpts, fdur, sync) {
        this.streamId = streamId;
        this.fsizes = fsizes;
        this.fpts = fpts;
        this.fdur = fdur;
        this.sync = sync;
    };
    constructor.MPSStreamIndex = stjs.extend(constructor.MPSStreamIndex, null, [], function(constructor, prototype) {
        prototype.streamId = 0;
        prototype.fsizes = null;
        prototype.fpts = null;
        prototype.fdur = null;
        prototype.sync = null;
        prototype.getStreamId = function() {
            return this.streamId;
        };
        prototype.getFsizes = function() {
            return this.fsizes;
        };
        prototype.getFpts = function() {
            return this.fpts;
        };
        prototype.getFdur = function() {
            return this.fdur;
        };
        prototype.getSync = function() {
            return this.sync;
        };
        constructor.parseIndex = function(index) {
            var streamId = index.get() & 255;
            var fCnt = index.getInt();
            var fsizes = new Int32Array(fCnt);
            for (var i = 0; i < fCnt; i++) {
                fsizes[i] = index.getInt();
            }
            var fptsCnt = index.getInt();
            var fpts = new Int32Array(fptsCnt);
            for (var i = 0; i < fptsCnt; i++) {
                fpts[i] = index.getInt();
            }
            var fdurCnt = index.getInt();
            var fdur = new Int32Array(fdurCnt);
            for (var i = 0; i < fdurCnt; i++) {
                fdur[i] = index.getInt();
            }
            var syncCount = index.getInt();
            var sync = new Int32Array(syncCount);
            for (var i = 0; i < syncCount; i++) 
                sync[i] = index.getInt();
            return new MPSIndex.MPSStreamIndex(streamId, fsizes, fpts, fdur, sync);
        };
        prototype.serialize = function(index) {
            index.put((this.streamId << 24 >> 24));
            index.putInt(this.fsizes.length);
            for (var i = 0; i < this.fsizes.length; i++) 
                index.putInt(this.fsizes[i]);
            index.putInt(this.fpts.length);
            for (var i = 0; i < this.fpts.length; i++) 
                index.putInt(this.fpts[i]);
            index.putInt(this.fdur.length);
            for (var i = 0; i < this.fdur.length; i++) 
                index.putInt(this.fdur[i]);
            index.putInt(this.sync.length);
            for (var i = 0; i < this.sync.length; i++) 
                index.putInt(this.sync[i]);
        };
        prototype.estimateSize = function() {
            return (this.fpts.length << 2) + (this.fdur.length << 2) + (this.sync.length << 2) + (this.fsizes.length << 2) + 64;
        };
    }, {fsizes: "Int32Array", fpts: "Int32Array", fdur: "Int32Array", sync: "Int32Array"}, {});
    prototype.getPesTokens = function() {
        return this.pesTokens;
    };
    prototype.getPesStreamIds = function() {
        return this.pesStreamIds;
    };
    prototype.getStreams = function() {
        return this.streams;
    };
    constructor.parseIndex = function(index) {
        var pesCnt = index.getInt();
        var pesTokens = Array(pesCnt);
        for (var i = 0; i < pesCnt; i++) {
            pesTokens[i] = index.getLong();
        }
        var pesStreamId = RunLength.Integer.parse(index);
        var nStreams = index.getInt();
        var streams = Array(nStreams);
        for (var i = 0; i < nStreams; i++) {
            streams[i] = MPSIndex.MPSStreamIndex.parseIndex(index);
        }
        return new MPSIndex(pesTokens, pesStreamId, streams);
    };
    prototype.serializeTo = function(index) {
        index.putInt(this.pesTokens.length);
        for (var i = 0; i < this.pesTokens.length; i++) {
            index.putLong(this.pesTokens[i]);
        }
        this.pesStreamIds.serialize(index);
        index.putInt(this.streams.length);
        for (var mpsStreamIndex in this.streams) {
            mpsStreamIndex.serialize(index);
        }
    };
    prototype.estimateSize = function() {
        var size = (this.pesTokens.length << 3) + this.pesStreamIds.estimateSize();
        for (var mpsStreamIndex in this.streams) {
            size += mpsStreamIndex.estimateSize();
        }
        return size + 64;
    };
    constructor.makePESToken = function(leading, pesLen, payloadLen) {
        return (leading << 48) | (pesLen << 24) | payloadLen;
    };
    constructor.leadingSize = function(token) {
        return (((token >> 48)) | 0) & 65535;
    };
    constructor.pesLen = function(token) {
        return (((token >> 24)) | 0) & 16777215;
    };
    constructor.payLoadSize = function(token) {
        return ((token) | 0) & 16777215;
    };
}, {pesTokens: "Array", pesStreamIds: "RunLength.Integer", streams: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Compresses a set of long's creating a dictionary and then outputting it using
 *  a huffman table
 *  
 *  @author The JCodec project
 *  
 */
var DictionaryCompressor = function() {};
DictionaryCompressor = stjs.extend(DictionaryCompressor, null, [], function(constructor, prototype) {
    prototype.buildCodes = function(counts, esc) {
        var codes = new Int32Array(counts.length);
        var codeSizes = new Int32Array(counts.length);
        var code = 0;
        for (; code < Math.min(codes.length, esc); code++) {
            var max = 0;
            for (var i = 0; i < counts.length; i++) {
                if (counts[i] > counts[max]) 
                    max = i;
            }
            codes[max] = code;
            codeSizes[max] = Math.max(1, MathUtil.log2(code));
            counts[max] = Integer.MIN_VALUE;
        }
        var escSize = MathUtil.log2(esc);
        for (var i = 0; i < counts.length; i++) 
            if (counts[i] >= 0) {
                codes[i] = esc;
                codeSizes[i] = escSize;
            }
        return new VLC(codes, codeSizes);
    };
    constructor.Long = function() {
        DictionaryCompressor.call(this);
    };
    constructor.Long = stjs.extend(constructor.Long, DictionaryCompressor, [], function(constructor, prototype) {
        prototype.compress = function(values, bb) {
            var rl = this.getValueStats(values);
            var counts = rl.getCounts();
            var keys = rl.getValues();
            var vlc = this.buildCodes(counts, stjs.trunc(values.length / 10));
            var codes = vlc.getCodes();
            var codeSizes = vlc.getCodeSizes();
            bb.putInt(codes.length);
            for (var i = 0; i < codes.length; i++) {
                bb.put((codeSizes[i] << 24 >> 24));
                bb.putShort((((codes[i] >>> 16)) << 16 >> 16));
                bb.putLong(keys[i]);
            }
            var br = new BitWriter(bb);
            for (var j = 0; j < values.length; j++) {
                var l = values[j];
                for (var i = 0; i < keys.length; i++) 
                    if (keys[i] == l) {
                        vlc.writeVLC(br, i);
                        if (codes[i] == 15) 
                            br.writeNBit(16, i);
                    }
            }
            br.flush();
        };
        prototype.getValueStats = function(values) {
            var copy = Platform.copyOfLong(values, values.length);
            Arrays.sort(copy);
            var rl = new RunLength.Long();
            for (var i = 0; i < copy.length; i++) {
                var l = copy[i];
                rl.add(l);
            }
            return rl;
        };
    }, {}, {});
    constructor.Int = function() {
        DictionaryCompressor.call(this);
    };
    constructor.Int = stjs.extend(constructor.Int, DictionaryCompressor, [], function(constructor, prototype) {
        prototype.compress = function(values, bb) {
            var rl = this.getValueStats(values);
            var counts = rl.getCounts();
            var keys = rl.getValues();
            var esc = Math.max(1, (1 << (MathUtil.log2(counts.length) - 2)) - 1);
            var vlc = this.buildCodes(counts, esc);
            var codes = vlc.getCodes();
            var codeSizes = vlc.getCodeSizes();
            bb.putInt(codes.length);
            for (var i = 0; i < codes.length; i++) {
                bb.put((codeSizes[i] << 24 >> 24));
                bb.putShort((((codes[i] >>> 16)) << 16 >> 16));
                bb.putInt(keys[i]);
            }
            var br = new BitWriter(bb);
            for (var j = 0; j < values.length; j++) {
                var l = values[j];
                for (var i = 0; i < keys.length; i++) 
                    if (keys[i] == l) {
                        vlc.writeVLC(br, i);
                        if (codes[i] == esc) 
                            br.writeNBit(i, 16);
                    }
            }
            br.flush();
        };
        prototype.getValueStats = function(values) {
            var copy = Platform.copyOfInt(values, values.length);
            Arrays.sort(copy);
            var rl = new RunLength.Integer();
            for (var i = 0; i < copy.length; i++) {
                var l = copy[i];
                rl.add(l);
            }
            return rl;
        };
    }, {}, {});
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var WavHeader = function(chunkId, chunkSize, format, fmt, dataOffset, dataSize) {
    this.chunkId = chunkId;
    this.chunkSize = chunkSize;
    this.format = format;
    this.fmt = fmt;
    this.dataOffset = dataOffset;
    this.dataSize = dataSize;
};
WavHeader = stjs.extend(WavHeader, null, [], function(constructor, prototype) {
    constructor.FmtChunkExtended = function(other, cbSize, bitsPerCodedSample, channelLayout, guid) {
        WavHeader.FmtChunk.call(this, other.audioFormat, other.numChannels, other.sampleRate, other.byteRate, other.blockAlign, other.bitsPerSample);
        this.cbSize = cbSize;
        this.bitsPerCodedSample = bitsPerCodedSample;
        this.channelLayout = channelLayout;
        this.guid = guid;
    };
    constructor.FmtChunkExtended = stjs.extend(constructor.FmtChunkExtended, WavHeader.FmtChunk, [], function(constructor, prototype) {
        prototype.cbSize = 0;
        prototype.bitsPerCodedSample = 0;
        prototype.channelLayout = 0;
        prototype.guid = 0;
        constructor.read = function(bb) {
            var fmtChunk = WavHeader.FmtChunk.get(bb);
            var old = bb.getOrder();
            try {
                bb.order(ByteOrder.LITTLE_ENDIAN);
                return new WavHeader.FmtChunkExtended(fmtChunk, bb.getShort(), bb.getShort(), bb.getInt(), bb.getInt());
            } finally {
                bb.order(old);
            }
        };
        prototype.put = function(bb) {
            WavHeader.FmtChunk.prototype.put.call(this, bb);
            var old = bb.getOrder();
            bb.order(ByteOrder.LITTLE_ENDIAN);
            bb.putShort(this.cbSize);
            bb.putShort(this.bitsPerCodedSample);
            bb.putInt(this.channelLayout);
            bb.putInt(this.guid);
            bb.order(old);
        };
        prototype.size = function() {
            return WavHeader.FmtChunk.prototype.size.call(this) + 12;
        };
        prototype.getLabels = function() {
            var labels = new ArrayList();
            for (var i = 0; i < WavHeader.mapping.length; i++) {
                if ((this.channelLayout & (1 << i)) != 0) 
                    labels.add(WavHeader.mapping[i]);
            }
            return labels.toArray(Array(0));
        };
    }, {}, {});
    constructor.mapping = [ChannelLabel.FRONT_LEFT, ChannelLabel.FRONT_RIGHT, ChannelLabel.CENTER, ChannelLabel.LFE, ChannelLabel.REAR_LEFT, ChannelLabel.REAR_RIGHT, ChannelLabel.FRONT_CENTER_LEFT, ChannelLabel.FRONT_CENTER_RIGHT, ChannelLabel.REAR_CENTER, ChannelLabel.SIDE_LEFT, ChannelLabel.SIDE_RIGHT, ChannelLabel.CENTER, ChannelLabel.FRONT_LEFT, ChannelLabel.CENTER, ChannelLabel.FRONT_RIGHT, ChannelLabel.REAR_LEFT, ChannelLabel.REAR_CENTER, ChannelLabel.REAR_RIGHT, ChannelLabel.STEREO_LEFT, ChannelLabel.STEREO_RIGHT];
    constructor.FmtChunk = function(audioFormat, numChannels, sampleRate, byteRate, blockAlign, bitsPerSample) {
        this.audioFormat = audioFormat;
        this.numChannels = numChannels;
        this.sampleRate = sampleRate;
        this.byteRate = byteRate;
        this.blockAlign = blockAlign;
        this.bitsPerSample = bitsPerSample;
    };
    constructor.FmtChunk = stjs.extend(constructor.FmtChunk, null, [], function(constructor, prototype) {
        prototype.audioFormat = 0;
        prototype.numChannels = 0;
        prototype.sampleRate = 0;
        prototype.byteRate = 0;
        prototype.blockAlign = 0;
        prototype.bitsPerSample = 0;
        constructor.get = function(bb) {
            var old = bb.getOrder();
            try {
                bb.order(ByteOrder.LITTLE_ENDIAN);
                return new WavHeader.FmtChunk(bb.getShort(), bb.getShort(), bb.getInt(), bb.getInt(), bb.getShort(), bb.getShort());
            } finally {
                bb.order(old);
            }
        };
        prototype.put = function(bb) {
            var old = bb.getOrder();
            bb.order(ByteOrder.LITTLE_ENDIAN);
            bb.putShort(this.audioFormat);
            bb.putShort(this.numChannels);
            bb.putInt(this.sampleRate);
            bb.putInt(this.byteRate);
            bb.putShort(this.blockAlign);
            bb.putShort(this.bitsPerSample);
            bb.order(old);
        };
        prototype.size = function() {
            return 16;
        };
    }, {}, {});
    prototype.chunkId = null;
    prototype.chunkSize = 0;
    prototype.format = null;
    prototype.fmt = null;
    prototype.dataOffset = 0;
    prototype.dataSize = 0;
    constructor.WAV_HEADER_SIZE = 44;
    constructor.copyWithRate = function(header, rate) {
        var result = new WavHeader(header.chunkId, header.chunkSize, header.format, WavHeader.copyFmt(header.fmt), header.dataOffset, header.dataSize);
        result.fmt.sampleRate = rate;
        return result;
    };
    constructor.copyWithChannels = function(header, channels) {
        var result = new WavHeader(header.chunkId, header.chunkSize, header.format, WavHeader.copyFmt(header.fmt), header.dataOffset, header.dataSize);
        result.fmt.numChannels = ((channels) << 16 >> 16);
        return result;
    };
    constructor.copyFmt = function(fmt) {
        if (stjs.isInstanceOf(fmt.constructor, WavHeader.FmtChunkExtended)) {
            var fmtext = fmt;
            fmt = new WavHeader.FmtChunkExtended(fmtext, fmtext.cbSize, fmtext.bitsPerCodedSample, fmtext.channelLayout, fmtext.guid);
        } else {
            fmt = new WavHeader.FmtChunk(fmt.audioFormat, fmt.numChannels, fmt.sampleRate, fmt.byteRate, fmt.blockAlign, fmt.bitsPerSample);
        }
        return fmt;
    };
    /**
     *  Creates wav header for the specified audio format
     *  
     *  @param format
     *  @param samples
     */
    constructor.createWavHeader = function(format, samples) {
        var w = new WavHeader("RIFF", 40, "WAVE", new WavHeader.FmtChunk(((1) << 16 >> 16), ((format.getChannels()) << 16 >> 16), format.getSampleRate(), format.getSampleRate() * format.getChannels() * (format.getSampleSizeInBits() >> 3), (((format.getChannels() * (format.getSampleSizeInBits() >> 3))) << 16 >> 16), ((format.getSampleSizeInBits()) << 16 >> 16)), 44, WavHeader.calcDataSize(format.getChannels(), format.getSampleSizeInBits() >> 3, samples));
        return w;
    };
    constructor.stereo48k = function() {
        return WavHeader.stereo48kWithSamples(0);
    };
    constructor.stereo48kWithSamples = function(samples) {
        return new WavHeader("RIFF", 40, "WAVE", new WavHeader.FmtChunk(((1) << 16 >> 16), ((2) << 16 >> 16), 48000, stjs.trunc(48000 * 2 * 16 / 8), ((4) << 16 >> 16), ((16) << 16 >> 16)), 44, WavHeader.calcDataSize(2, 2, samples));
    };
    constructor.mono48k = function(samples) {
        return new WavHeader("RIFF", 40, "WAVE", new WavHeader.FmtChunk(((1) << 16 >> 16), ((1) << 16 >> 16), 48000, stjs.trunc(48000 * 1 * 16 / 8), ((2) << 16 >> 16), ((16) << 16 >> 16)), 44, WavHeader.calcDataSize(1, 2, samples));
    };
    constructor.emptyWavHeader = function() {
        return new WavHeader("RIFF", 40, "WAVE", WavHeader.newFmtChunk(), 44, 0);
    };
    constructor.newFmtChunk = function() {
        return new WavHeader.FmtChunk(((1) << 16 >> 16), ((0) << 16 >> 16), 0, 0, ((0) << 16 >> 16), ((0) << 16 >> 16));
    };
    constructor.read = function(file) {
        var is = null;
        try {
            is = NIOUtils.readableChannel(file);
            return WavHeader.readChannel(is);
        } finally {
            IOUtils.closeQuietly(is);
        }
    };
    constructor.readChannel = function(_in) {
        var buf = ByteBuffer.allocate(128);
        buf.order(ByteOrder.LITTLE_ENDIAN);
        _in.read(buf);
        if (buf.remaining() > 0) 
             throw new IOException("Incomplete wav header found");
        buf.flip();
        var chunkId = NIOUtils.readString(buf, 4);
        var chunkSize = buf.getInt();
        var format = NIOUtils.readString(buf, 4);
        var fmt = null;
        if (!"RIFF".equals(chunkId) || !"WAVE".equals(format)) {
            return null;
        }
        var fourcc;
        var size = 0;
        do {
            fourcc = NIOUtils.readString(buf, 4);
            size = buf.getInt();
            if ("fmt ".equals(fourcc) && size >= 14 && size <= 1024 * 1024) {
                switch (size) {
                    case 16:
                        fmt = WavHeader.FmtChunk.get(buf);
                        break;
                    case 18:
                        fmt = WavHeader.FmtChunk.get(buf);
                        NIOUtils.skip(buf, 2);
                        break;
                    case 40:
                        fmt = WavHeader.FmtChunkExtended.get(buf);
                        NIOUtils.skip(buf, 12);
                        break;
                    case 28:
                        fmt = WavHeader.FmtChunkExtended.get(buf);
                        break;
                    default:
                         throw new UnhandledStateException("Don't know how to handle fmt size: " + size);
                }
            } else if (!"data".equals(fourcc)) {
                NIOUtils.skip(buf, size);
            }
        } while (!"data".equals(fourcc));
        return new WavHeader(chunkId, chunkSize, format, fmt, buf.position(), size);
    };
    constructor.multiChannelWavFromFiles = function(_arguments) {
        var headers = Array(arguments.length);
        for (var i = 0; i < arguments.length; i++) {
            headers[i] = WavHeader.read(arguments[i]);
        }
        return WavHeader.multiChannelWav(headers);
    };
    /**
     * Takes single channel wavs as input produces multi channel wav 
     */
    constructor.multiChannelWav = function(_arguments) {
        var w = WavHeader.emptyWavHeader();
        var totalSize = 0;
        for (var i = 0; i < arguments.length; i++) {
            var wavHeader = arguments[i];
            totalSize += wavHeader.dataSize;
        }
        w.dataSize = totalSize;
        var fmt = arguments[0].fmt;
        var bitsPerSample = fmt.bitsPerSample;
        var bytesPerSample = stjs.trunc(bitsPerSample / 8);
        var sampleRate = stjs.trunc(fmt.sampleRate);
        w.fmt.bitsPerSample = ((bitsPerSample) << 16 >> 16);
        w.fmt.blockAlign = (((arguments.length * bytesPerSample)) << 16 >> 16);
        w.fmt.byteRate = arguments.length * bytesPerSample * sampleRate;
        w.fmt.numChannels = ((arguments.length) << 16 >> 16);
        w.fmt.sampleRate = sampleRate;
        return w;
    };
    prototype.write = function(out) {
        var bb = ByteBuffer.allocate(44);
        bb.order(ByteOrder.LITTLE_ENDIAN);
        var chunkSize;
        if (this.dataSize <= 4294967295) {
            chunkSize = this.dataSize + 36;
        } else {
            chunkSize = 40;
        }
        bb.putArr(JCodecUtil2.asciiString("RIFF"));
        bb.putInt(((chunkSize) | 0));
        bb.putArr(JCodecUtil2.asciiString("WAVE"));
        bb.putArr(JCodecUtil2.asciiString("fmt "));
        bb.putInt(this.fmt.size());
        this.fmt.put(bb);
        bb.putArr(JCodecUtil2.asciiString("data"));
        if (this.dataSize <= 4294967295) {
            bb.putInt(((this.dataSize) | 0));
        } else {
            bb.putInt(0);
        }
        bb.flip();
        out.write(bb);
    };
    constructor.calcDataSize = function(numChannels, bytesPerSample, samples) {
        return samples * numChannels * bytesPerSample;
    };
    constructor.create = function(af, size) {
        var w = WavHeader.emptyWavHeader();
        w.dataSize = size;
        var fmt = WavHeader.newFmtChunk();
        var bitsPerSample = af.getSampleSizeInBits();
        var bytesPerSample = stjs.trunc(bitsPerSample / 8);
        var sampleRate = stjs.trunc(af.getSampleRate());
        w.fmt.bitsPerSample = ((bitsPerSample) << 16 >> 16);
        w.fmt.blockAlign = stjs.trunc((af.getFrameSize()));
        w.fmt.byteRate = stjs.trunc(af.getFrameRate()) * af.getFrameSize();
        w.fmt.numChannels = ((af.getChannels()) << 16 >> 16);
        w.fmt.sampleRate = stjs.trunc(af.getSampleRate());
        return w;
    };
    prototype.getChannelLabels = function() {
        if (stjs.isInstanceOf(this.fmt.constructor, WavHeader.FmtChunkExtended)) {
            return (this.fmt).getLabels();
        } else {
            switch (this.fmt.numChannels) {
                case 1:
                    return [ChannelLabel.MONO];
                case 2:
                    return [ChannelLabel.STEREO_LEFT, ChannelLabel.STEREO_RIGHT];
                case 3:
                    return [ChannelLabel.FRONT_LEFT, ChannelLabel.FRONT_RIGHT, ChannelLabel.REAR_CENTER];
                case 4:
                    return [ChannelLabel.FRONT_LEFT, ChannelLabel.FRONT_RIGHT, ChannelLabel.REAR_LEFT, ChannelLabel.REAR_RIGHT];
                case 5:
                    return [ChannelLabel.FRONT_LEFT, ChannelLabel.FRONT_RIGHT, ChannelLabel.CENTER, ChannelLabel.REAR_LEFT, ChannelLabel.REAR_RIGHT];
                case 6:
                    return [ChannelLabel.FRONT_LEFT, ChannelLabel.FRONT_RIGHT, ChannelLabel.CENTER, ChannelLabel.LFE, ChannelLabel.REAR_LEFT, ChannelLabel.REAR_RIGHT];
                case 7:
                    return [ChannelLabel.FRONT_LEFT, ChannelLabel.FRONT_RIGHT, ChannelLabel.CENTER, ChannelLabel.LFE, ChannelLabel.REAR_LEFT, ChannelLabel.REAR_RIGHT, ChannelLabel.REAR_CENTER];
                case 8:
                    return [ChannelLabel.FRONT_LEFT, ChannelLabel.FRONT_RIGHT, ChannelLabel.CENTER, ChannelLabel.LFE, ChannelLabel.REAR_LEFT, ChannelLabel.REAR_RIGHT, ChannelLabel.REAR_LEFT, ChannelLabel.REAR_RIGHT];
                default:
                    var labels = Array(this.fmt.numChannels);
                    Arrays.fill(labels, ChannelLabel.MONO);
                    return labels;
            }
        }
    };
    prototype.getFormat = function() {
        return new AudioFormat(this.fmt.sampleRate, this.fmt.bitsPerSample, this.fmt.numChannels, true, false);
    };
}, {mapping: "Array", fmt: "WavHeader.FmtChunk"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MXFInterchangeObject = function(ul) {
    MXFMetadata.call(this, ul);
};
MXFInterchangeObject = stjs.extend(MXFInterchangeObject, MXFMetadata, [], function(constructor, prototype) {
    prototype.generationUID = null;
    prototype.objectClass = null;
    prototype.readBuf = function(bb) {
        bb.order(ByteOrder.BIG_ENDIAN);
        var tags = new HashMap();
         while (bb.hasRemaining()){
            var tag = bb.getShort() & 65535;
            var size = bb.getShort() & 65535;
            var _bb = NIOUtils.read(bb, size);
            switch (tag) {
                case 15370:
                    this.uid = UL.read(_bb);
                    break;
                case 258:
                    this.generationUID = UL.read(_bb);
                    break;
                case 257:
                    this.objectClass = UL.read(_bb);
                    break;
                default:
                    tags.put(tag, _bb);
            }
        }
        if (tags.size() > 0) 
            this.read(tags);
    };
    prototype.read = function(tags) {};
    prototype.getGenerationUID = function() {
        return this.generationUID;
    };
    prototype.getObjectClass = function() {
        return this.objectClass;
    };
}, {generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MXFPartitionPack = function(ul) {
    MXFMetadata.call(this, ul);
};
MXFPartitionPack = stjs.extend(MXFPartitionPack, MXFMetadata, [], function(constructor, prototype) {
    prototype.kagSize = 0;
    prototype.thisPartition = 0;
    prototype.prevPartition = 0;
    prototype.footerPartition = 0;
    prototype.headerByteCount = 0;
    prototype.indexByteCount = 0;
    prototype.indexSid = 0;
    prototype.bodySid = 0;
    prototype.op = null;
    prototype.nbEssenceContainers = 0;
    prototype.readBuf = function(bb) {
        bb.order(ByteOrder.BIG_ENDIAN);
        NIOUtils.skip(bb, 4);
        this.kagSize = bb.getInt();
        this.thisPartition = bb.getLong();
        this.prevPartition = bb.getLong();
        this.footerPartition = bb.getLong();
        this.headerByteCount = bb.getLong();
        this.indexByteCount = bb.getLong();
        this.indexSid = bb.getInt();
        NIOUtils.skip(bb, 8);
        this.bodySid = bb.getInt();
        this.op = UL.read(bb);
        this.nbEssenceContainers = bb.getInt();
    };
    prototype.getKagSize = function() {
        return this.kagSize;
    };
    prototype.getThisPartition = function() {
        return this.thisPartition;
    };
    prototype.getPrevPartition = function() {
        return this.prevPartition;
    };
    prototype.getFooterPartition = function() {
        return this.footerPartition;
    };
    prototype.getHeaderByteCount = function() {
        return this.headerByteCount;
    };
    prototype.getIndexByteCount = function() {
        return this.indexByteCount;
    };
    prototype.getIndexSid = function() {
        return this.indexSid;
    };
    prototype.getBodySid = function() {
        return this.bodySid;
    };
    prototype.getOp = function() {
        return this.op;
    };
    prototype.getNbEssenceContainers = function() {
        return this.nbEssenceContainers;
    };
}, {op: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A factory for MPEG PS virtual tracks coming out of streams of MPEG PS
 *  
 *  @author The JCodec project
 *  
 */
var MPSTrackFactory = function(index, fp) {
    this.fp = fp;
    this.tracks = new HashMap();
    this.readIndex(index);
};
MPSTrackFactory = stjs.extend(MPSTrackFactory, null, [], function(constructor, prototype) {
    prototype.tracks = null;
    prototype.fp = null;
    prototype.pesTokens = null;
    prototype.streams = null;
    prototype.readIndex = function(index) {
        var nTokens = index.getInt();
        this.pesTokens = Array(nTokens);
        for (var i = 0; i < this.pesTokens.length; i++) 
            this.pesTokens[i] = index.getLong();
        this.streams = RunLength.Integer.parse(index).flattern();
         while (index.hasRemaining()){
            var stream = index.get() & 255;
            this.getStream(this.tracks, stream).parseIndex(index);
        }
    };
    prototype.getStream = function(streams, streamId) {
        var stream = streams.get(streamId);
        if (stream == null) {
            stream = this.createStream(streamId);
            streams.put(streamId, stream);
        }
        return stream;
    };
    prototype.createStream = function(streamId) {
        return new MPSTrackFactory.Stream(streamId, this);
    };
    constructor.Stream = function(streamId, factory) {
        this.streamId = streamId;
        this.factory = factory;
    };
    constructor.Stream = stjs.extend(constructor.Stream, null, [VirtualTrack], function(constructor, prototype) {
        prototype.siLen = 0;
        prototype.fsizes = null;
        prototype.fpts = null;
        prototype.sync = null;
        prototype.duration = 0;
        prototype.streamId = 0;
        prototype.fileOff = 0;
        prototype.pesIdx = 0;
        prototype.curFrame = 0;
        prototype.offInPayload = 0;
        prototype.si = null;
        prototype.factory = null;
        prototype.parseIndex = function(index) {
            this.siLen = index.getInt();
            var fCnt = index.getInt();
            this.fsizes = new Int32Array(fCnt);
            this.fpts = Array(fCnt);
            for (var i = 0; i < fCnt; i++) {
                var size = index.getInt();
                this.fsizes[i] = size;
            }
            var syncCount = index.getInt();
            this.sync = new Int32Array(syncCount);
            for (var i = 0; i < syncCount; i++) 
                this.sync[i] = index.getInt();
            for (var i = 0; i < fCnt; i++) {
                this.fpts[i] = index.getInt() & 4294967295;
            }
            var seg0 = Platform.copyOfLong(this.fpts, 10);
            Arrays.sort(seg0);
            var seg1 = Array(10);
            System.arraycopy(this.fpts, this.fpts.length - 10, seg1, 0, 10);
            Arrays.sort(seg1);
            this.duration = stjs.trunc((seg1[9] - seg0[0] + (this.fpts.length >> 1)) / this.fpts.length);
            this.offInPayload = this.siLen;
            for (this.fileOff = 0; this.factory.streams[this.pesIdx] != this.streamId; this.fileOff += this.pesLen(this.factory.pesTokens[this.pesIdx]) + this.leadingSize(this.factory.pesTokens[this.pesIdx]) , this.pesIdx++) 
                ;
            this.fileOff += this.leadingSize(this.factory.pesTokens[this.pesIdx]);
            var ch = null;
            try {
                ch = this.factory.fp.getChannel();
                var firstPes = this.readPes(ch, this.fileOff, this.pesLen(this.factory.pesTokens[this.pesIdx]), this.payloadLen(this.factory.pesTokens[this.pesIdx]), this.pesIdx);
                this.si = NIOUtils.read(firstPes, this.siLen);
            } finally {
                NIOUtils.closeQuietly(ch);
            }
        };
        prototype.readPes = function(ch, pesPosition, pesSize, payloadSize, pesIdx) {
            ch.setPosition(pesPosition);
            var pes = NIOUtils.fetchFromChannel(ch, pesSize);
            MPSUtils.readPESHeader(pes, 0);
            return pes;
        };
        prototype.pesLen = function(token) {
            return ((((token >>> 24) & 16777215)) | 0);
        };
        prototype.payloadLen = function(token) {
            return (((token & 16777215)) | 0);
        };
        prototype.leadingSize = function(token) {
            return ((((token >>> 48) & 65535)) | 0);
        };
        prototype.nextPacket = function() {
            if (this.curFrame >= this.fsizes.length) 
                return null;
            var pkt = new MPSTrackFactory.Stream.MPSPacket(this, this.offInPayload, this.fileOff, this.curFrame, this.pesIdx);
            this.offInPayload += this.fsizes[this.curFrame];
             while (this.pesIdx < this.factory.streams.length && this.offInPayload >= this.payloadLen(this.factory.pesTokens[this.pesIdx])){
                var ps = this.payloadLen(this.factory.pesTokens[this.pesIdx]);
                this.offInPayload -= ps;
                this.fileOff += this.pesLen(this.factory.pesTokens[this.pesIdx]);
                ++this.pesIdx;
                if (this.pesIdx < this.factory.streams.length) {
                    var posShift = 0;
                    for (; this.factory.streams[this.pesIdx] != this.streamId; this.pesIdx++) 
                        posShift += this.pesLen(this.factory.pesTokens[this.pesIdx]) + this.leadingSize(this.factory.pesTokens[this.pesIdx]);
                    this.fileOff += posShift + this.leadingSize(this.factory.pesTokens[this.pesIdx]);
                }
            }
            this.curFrame++;
            return pkt;
        };
        constructor.MPSPacket = function(stream, pesOff, fileOff, curFrame, pesIdx) {
            this.s = stream;
            this.pesOff = pesOff;
            this.fileOff = fileOff;
            this.curFrame = curFrame;
            this.pesIdx = pesIdx;
        };
        constructor.MPSPacket = stjs.extend(constructor.MPSPacket, null, [VirtualPacket], function(constructor, prototype) {
            prototype.fileOff = 0;
            prototype.curFrame = 0;
            prototype.pesOff = 0;
            prototype.pesIdx = 0;
            prototype.s = null;
            prototype.getData = function() {
                var result = ByteBuffer.allocate(this.s.siLen + this.s.fsizes[this.curFrame]);
                result.putBuf(this.s.si.duplicate());
                var ch = null;
                try {
                    ch = this.s.factory.fp.getChannel();
                    var curOff = this.fileOff;
                    var pesBuf = this.s.readPes(ch, curOff, this.s.pesLen(this.s.factory.pesTokens[this.pesIdx]), this.s.payloadLen(this.s.factory.pesTokens[this.pesIdx]), this.pesIdx);
                    curOff += this.s.pesLen(this.s.factory.pesTokens[this.pesIdx]);
                    NIOUtils.skip(pesBuf, this.pesOff);
                    result.putBuf(NIOUtils.read(pesBuf, Math.min(pesBuf.remaining(), result.remaining())));
                    for (var idx = this.pesIdx; result.hasRemaining(); ) {
                        var posShift = 0;
                        idx++;
                        for (; this.s.factory.streams[idx] != this.s.streamId && idx < this.s.factory.pesTokens.length; idx++) 
                            posShift += this.s.pesLen(this.s.factory.pesTokens[idx]) + this.s.leadingSize(this.s.factory.pesTokens[idx]);
                        pesBuf = this.s.readPes(ch, curOff + posShift + this.s.leadingSize(this.s.factory.pesTokens[idx]), this.s.pesLen(this.s.factory.pesTokens[idx]), this.s.payloadLen(this.s.factory.pesTokens[idx]), idx);
                        curOff += posShift + this.s.leadingSize(this.s.factory.pesTokens[idx]) + this.s.pesLen(this.s.factory.pesTokens[idx]);
                        result.putBuf(NIOUtils.read(pesBuf, Math.min(pesBuf.remaining(), result.remaining())));
                    }
                    result.flip();
                    return result;
                } finally {
                    NIOUtils.closeQuietly(ch);
                }
            };
            prototype.getDataLen = function() {
                return this.s.siLen + this.s.fsizes[this.curFrame];
            };
            prototype.getPts = function() {
                return (this.s.fpts[this.curFrame] - this.s.fpts[0]) / 90000;
            };
            prototype.getDuration = function() {
                return this.s.duration / 90000;
            };
            prototype.isKeyframe = function() {
                return this.s.sync.length == 0 || Arrays.binarySearch(this.s.sync, this.curFrame) >= 0;
            };
            prototype.getFrameNo = function() {
                return this.curFrame;
            };
        }, {s: "MPSTrackFactory.Stream", byPts: {name: "Comparator", arguments: ["Object"]}}, {});
        prototype.getCodecMeta = function() {
            return VideoCodecMeta.createVideoCodecMeta("m2v1", ByteBuffer.allocate(0), new Size(1920, 1080), new Rational(1, 1));
        };
        prototype.getEdits = function() {
            return null;
        };
        prototype.getPreferredTimescale = function() {
            return 90000;
        };
        prototype.close = function() {
            this.factory.fp.close();
        };
    }, {fsizes: "Int32Array", fpts: "Array", sync: "Int32Array", si: "ByteBuffer", factory: "MPSTrackFactory"}, {});
    prototype.getVideoStreams = function() {
        var ret = new ArrayList();
        var entrySet = this.tracks.entrySet();
        for (var iterator$entry = entrySet.iterator(); iterator$entry.hasNext(); ) {
            var entry = iterator$entry.next();
            if (MPSUtils.videoStream(entry.getKey())) 
                ret.add(entry.getValue());
        }
        return ret;
    };
    prototype.getAudioStreams = function() {
        var ret = new ArrayList();
        var entrySet = this.tracks.entrySet();
        for (var iterator$entry = entrySet.iterator(); iterator$entry.hasNext(); ) {
            var entry = iterator$entry.next();
            if (MPSUtils.audioStream(entry.getKey())) 
                ret.add(entry.getValue());
        }
        return ret;
    };
    prototype.getStreams = function() {
        return new ArrayList(this.tracks.values());
    };
    constructor.main1 = function(args) {
        var fp = new FilePool(new File(args[0]), 10);
        var factory = new MPSTrackFactory(NIOUtils.fetchFromFile(new File(args[1])), fp);
        var stream = factory.getVideoStreams().get(0);
        var ch = NIOUtils.writableChannel(new File(args[2]));
        var pkt = new ArrayList();
        for (var i = 0; i < 2000; i++) {
            pkt.add(stream.nextPacket());
        }
        for (var iterator$virtualPacket = pkt.iterator(); iterator$virtualPacket.hasNext(); ) {
            var virtualPacket = iterator$virtualPacket.next();
            ch.write(virtualPacket.getData());
        }
        ch.close();
    };
}, {tracks: {name: "Map", arguments: [null, "MPSTrackFactory.Stream"]}, fp: "FilePool", pesTokens: "Array", streams: "Int32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed under FreeBSD License
 *  
 *  EBML IO implementation
 *  
 *  @author The JCodec project
 *  
 */
var EbmlDate = function(id) {
    EbmlSint.call(this, id);
};
EbmlDate = stjs.extend(EbmlDate, EbmlSint, [], function(constructor, prototype) {
    constructor.NANOSECONDS_IN_A_SECOND = 1000000000;
    constructor.MILISECONDS_IN_A_SECOND = 1000;
    constructor.NANOSECONDS_IN_A_MILISECOND = stjs.trunc(EbmlDate.NANOSECONDS_IN_A_SECOND / EbmlDate.MILISECONDS_IN_A_SECOND);
    constructor.MILISECONDS_SINCE_UNIX_EPOCH_START = 978307200;
    prototype.setDate = function(value) {
        this.setMiliseconds(value.getTime());
    };
    prototype.getDate = function() {
        var val = this.getLong();
        val = stjs.trunc(val / EbmlDate.NANOSECONDS_IN_A_MILISECOND) + EbmlDate.MILISECONDS_SINCE_UNIX_EPOCH_START;
        return new jsutil.Date(val);
    };
    prototype.setMiliseconds = function(milliseconds) {
        this.setLong((milliseconds - EbmlDate.MILISECONDS_SINCE_UNIX_EPOCH_START) * EbmlDate.NANOSECONDS_IN_A_MILISECOND);
    };
    prototype.setLong = function(value) {
        this.data = ByteBuffer.allocate(8);
        this.data.putLong(value);
        this.data.flip();
    };
}, {signedComplement: "Array", data: "ByteBuffer", parent: "EbmlMaster", type: "MKVType", id: "Int8Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MkvBlock = function(type) {
    EbmlBin.call(this, type);
    if (!Platform.arrayEqualsByte(MkvBlock.SIMPLEBLOCK_ID, type) && !Platform.arrayEqualsByte(MkvBlock.BLOCK_ID, type)) 
         throw new IllegalArgumentException("Block initiated with invalid id: " + EbmlUtil.toHexString(type));
};
MkvBlock = stjs.extend(MkvBlock, EbmlBin, [], function(constructor, prototype) {
    constructor.XIPH = "Xiph";
    constructor.EBML = "EBML";
    constructor.FIXED = "Fixed";
    constructor.MAX_BLOCK_HEADER_SIZE = 512;
    prototype.frameOffsets = null;
    prototype.frameSizes = null;
    prototype.trackNumber = 0;
    prototype.timecode = 0;
    prototype.absoluteTimecode = 0;
    prototype._keyFrame = false;
    prototype.headerSize = 0;
    prototype.lacing = null;
    prototype.discardable = false;
    prototype.lacingPresent = false;
    prototype.frames = null;
    constructor.BLOCK_ID = new Int8Array([(161 << 24 >> 24)]);
    constructor.SIMPLEBLOCK_ID = new Int8Array([(163 << 24 >> 24)]);
    constructor.copy = function(old) {
        var be = new MkvBlock(old.id);
        be.trackNumber = old.trackNumber;
        be.timecode = old.timecode;
        be.absoluteTimecode = old.absoluteTimecode;
        be._keyFrame = old._keyFrame;
        be.headerSize = old.headerSize;
        be.lacing = old.lacing;
        be.discardable = old.discardable;
        be.lacingPresent = old.lacingPresent;
        be.frameOffsets = new Int32Array(old.frameOffsets.length);
        be.frameSizes = new Int32Array(old.frameSizes.length);
        be.dataOffset = old.dataOffset;
        be.offset = old.offset;
        be.type = old.type;
        System.arraycopy(old.frameOffsets, 0, be.frameOffsets, 0, be.frameOffsets.length);
        System.arraycopy(old.frameSizes, 0, be.frameSizes, 0, be.frameSizes.length);
        return be;
    };
    constructor.keyFrame = function(trackNumber, timecode, frame) {
        var be = new MkvBlock(MkvBlock.SIMPLEBLOCK_ID);
        be.frames = [frame];
        be.frameSizes = new Int32Array([frame.limit()]);
        be._keyFrame = true;
        be.trackNumber = trackNumber;
        be.timecode = timecode;
        return be;
    };
    prototype.readChannel = function(is) {
        var bb = ByteBuffer.allocate(stjs.trunc(100));
        is.read(bb);
        bb.flip();
        this.read(bb);
        is.setPosition(this.dataOffset + this.dataLen);
    };
    prototype.read = function(source) {
        var bb = source.slice();
        this.trackNumber = MkvBlock.ebmlDecode(bb);
        var tcPart1 = bb.get() & 255;
        var tcPart2 = bb.get() & 255;
        this.timecode = ((((((tcPart1) << 16 >> 16) << 8) | ((tcPart2) << 16 >> 16))) << 16 >> 16);
        var flags = bb.get() & 255;
        this._keyFrame = (flags & 128) > 0;
        this.discardable = (flags & 1) > 0;
        var laceFlags = flags & 6;
        this.lacingPresent = laceFlags != 0;
        if (this.lacingPresent) {
            var lacesCount = bb.get() & 255;
            this.frameSizes = new Int32Array(lacesCount + 1);
            if (laceFlags == 2) {
                this.lacing = MkvBlock.XIPH;
                this.headerSize = MkvBlock.readXiphLaceSizes(bb, this.frameSizes, stjs.trunc(this.dataLen), bb.position());
            } else if (laceFlags == 6) {
                this.lacing = MkvBlock.EBML;
                this.headerSize = MkvBlock.readEBMLLaceSizes(bb, this.frameSizes, stjs.trunc(this.dataLen), bb.position());
            } else if (laceFlags == 4) {
                this.lacing = MkvBlock.FIXED;
                this.headerSize = bb.position();
                var aLaceSize = stjs.trunc((stjs.trunc((this.dataLen - this.headerSize) / (lacesCount + 1))));
                Arrays.fill(this.frameSizes, aLaceSize);
            } else {
                 throw new RuntimeException("Unsupported lacing type flag.");
            }
            this.turnSizesToFrameOffsets(this.frameSizes);
        } else {
            this.lacing = "";
            var frameOffset = bb.position();
            this.frameOffsets = new Int32Array(1);
            this.frameOffsets[0] = frameOffset;
            this.headerSize = bb.position();
            this.frameSizes = new Int32Array(1);
            this.frameSizes[0] = stjs.trunc((this.dataLen - this.headerSize));
        }
    };
    prototype.turnSizesToFrameOffsets = function(sizes) {
        this.frameOffsets = new Int32Array(sizes.length);
        this.frameOffsets[0] = this.headerSize;
        for (var i = 1; i < sizes.length; i++) 
            this.frameOffsets[i] = this.frameOffsets[i - 1] + sizes[i - 1];
    };
    constructor.readXiphLaceSizes = function(bb, sizes, size, preLacingHeaderSize) {
        var startPos = bb.position();
        var lastIndex = sizes.length - 1;
        sizes[lastIndex] = size;
        for (var l = 0; l < lastIndex; l++) {
            var laceSize = 255;
             while (laceSize == 255){
                laceSize = bb.get() & 255;
                sizes[l] += laceSize;
            }
            sizes[lastIndex] -= sizes[l];
        }
        var headerSize = (bb.position() - startPos) + preLacingHeaderSize;
        sizes[lastIndex] -= headerSize;
        return headerSize;
    };
    constructor.readEBMLLaceSizes = function(source, sizes, size, preLacingHeaderSize) {
        var lastIndex = sizes.length - 1;
        sizes[lastIndex] = size;
        var startPos = source.position();
        sizes[0] = ((MkvBlock.ebmlDecode(source)) | 0);
        sizes[lastIndex] -= sizes[0];
        var laceSize = sizes[0];
        var laceSizeDiff = 0;
        for (var l = 1; l < lastIndex; l++) {
            laceSizeDiff = MkvBlock.ebmlDecodeSigned(source);
            laceSize += laceSizeDiff;
            sizes[l] = laceSize;
            sizes[lastIndex] -= sizes[l];
        }
        var headerSize = (source.position() - startPos) + preLacingHeaderSize;
        sizes[lastIndex] -= headerSize;
        return headerSize;
    };
    prototype.toString = function() {
        var sb = new StringBuilder();
        sb.append("{dataOffset: ").append(this.dataOffset);
        sb.append(", trackNumber: ").append(this.trackNumber);
        sb.append(", timecode: ").append(this.timecode);
        sb.append(", keyFrame: ").append(this._keyFrame);
        sb.append(", headerSize: ").append(this.headerSize);
        sb.append(", lacing: ").append(this.lacing);
        for (var i = 0; i < this.frameSizes.length; i++) 
            sb.append(", frame[").append(i).append("]  offset ").append(this.frameOffsets[i]).append(" size ").append(this.frameSizes[i]);
        sb.append(" }");
        return sb.toString();
    };
    prototype.getFrames = function(source) {
        var frames = Array(this.frameSizes.length);
        for (var i = 0; i < this.frameSizes.length; i++) {
            if (this.frameOffsets[i] > source.limit()) 
                System.err.println("frame offset: " + this.frameOffsets[i] + " limit: " + source.limit());
            source.setPosition(this.frameOffsets[i]);
            var bb = source.slice();
            bb.setLimit(this.frameSizes[i]);
            frames[i] = bb;
        }
        return frames;
    };
    prototype.readFrames = function(source) {
        this.frames = this.getFrames(source);
    };
    prototype.getData = function() {
        var dataSize = stjs.trunc(this.getDataSize());
        var bb = ByteBuffer.allocate(dataSize + EbmlUtil.ebmlLength(dataSize) + this.id.length);
        bb.putArr(this.id);
        bb.putArr(EbmlUtil.ebmlEncode(dataSize));
        bb.putArr(EbmlUtil.ebmlEncode(this.trackNumber));
        bb.put((((this.timecode >>> 8) & 255) << 24 >> 24));
        bb.put(((this.timecode & 255) << 24 >> 24));
        var flags = 0;
        if (MkvBlock.XIPH.equals(this.lacing)) {
            flags = 2;
        } else if (MkvBlock.EBML.equals(this.lacing)) {
            flags = 6;
        } else if (MkvBlock.FIXED.equals(this.lacing)) {
            flags = 4;
        }
        if (this.discardable) 
            flags |= 1;
        if (this._keyFrame) 
            flags |= 128;
        bb.put(flags);
        if ((flags & 6) != 0) {
            bb.put((((this.frames.length - 1) & 255) << 24 >> 24));
            bb.putArr(this.muxLacingInfo());
        }
        for (var i = 0; i < this.frames.length; i++) {
            var frame = this.frames[i];
            bb.putBuf(frame);
        }
        bb.flip();
        return bb;
    };
    prototype.seekAndReadContent = function(source) {
        this.data = ByteBuffer.allocate(stjs.trunc(this.dataLen));
        source.position(this.dataOffset);
        source.read(this.data);
        this.data.flip();
    };
    /**
     *  Get the total size of this element
     */
    prototype.size = function() {
        var size = this.getDataSize();
        size += EbmlUtil.ebmlLength(size);
        size += this.id.length;
        return size;
    };
    prototype.getDataSize = function() {
        var size = 0;
        for (var fsize in this.frameSizes) 
            size += fsize;
        if (this.lacingPresent) {
            size += this.muxLacingInfo().length;
            size += 1;
        }
        size += 3;
        size += EbmlUtil.ebmlLength(this.trackNumber);
        return size;
    };
    prototype.muxLacingInfo = function() {
        if (MkvBlock.EBML.equals(this.lacing)) 
            return MkvBlock.muxEbmlLacing(this.frameSizes);
        if (MkvBlock.XIPH.equals(this.lacing)) 
            return MkvBlock.muxXiphLacing(this.frameSizes);
        if (MkvBlock.FIXED.equals(this.lacing)) 
            return new Int8Array(0);
        return null;
    };
    constructor.ebmlDecode = function(bb) {
        var firstByte = bb.get();
        var length = EbmlUtil.computeLength(firstByte);
        if (length == 0) 
             throw new RuntimeException("Invalid ebml integer size.");
        var value = firstByte & (255 >>> length);
        length--;
         while (length > 0){
            value = (value << 8) | (bb.get() & 255);
            length--;
        }
        return value;
    };
    constructor.ebmlDecodeSigned = function(source) {
        var firstByte = source.get();
        var size = EbmlUtil.computeLength(firstByte);
        if (size == 0) 
             throw new RuntimeException("Invalid ebml integer size.");
        var value = firstByte & (255 >>> size);
        var remaining = size - 1;
         while (remaining > 0){
            value = (value << 8) | (source.get() & 255);
            remaining--;
        }
        return value - EbmlSint.signedComplement[size];
    };
    constructor.calcEbmlLacingDiffs = function(laceSizes) {
        var lacesCount = laceSizes.length - 1;
        var out = Array(lacesCount);
        out[0] = stjs.trunc(laceSizes[0]);
        for (var i = 1; i < lacesCount; i++) {
            out[i] = laceSizes[i] - laceSizes[i - 1];
        }
        return out;
    };
    constructor.muxEbmlLacing = function(laceSizes) {
        var bytes = ByteArrayList.createByteArrayList();
        var laceSizeDiffs = MkvBlock.calcEbmlLacingDiffs(laceSizes);
        bytes.addAll(EbmlUtil.ebmlEncode(laceSizeDiffs[0]));
        for (var i = 1; i < laceSizeDiffs.length; i++) {
            bytes.addAll(EbmlSint.convertToBytes(laceSizeDiffs[i]));
        }
        return bytes.toArray();
    };
    constructor.muxXiphLacing = function(laceSizes) {
        var bytes = ByteArrayList.createByteArrayList();
        for (var i = 0; i < laceSizes.length - 1; i++) {
            var laceSize = laceSizes[i];
             while (laceSize >= 255){
                bytes.add((255 << 24 >> 24));
                laceSize -= 255;
            }
            bytes.add((laceSize << 24 >> 24));
        }
        return bytes.toArray();
    };
}, {frameOffsets: "Int32Array", frameSizes: "Int32Array", frames: "Array", BLOCK_ID: "Int8Array", SIMPLEBLOCK_ID: "Int8Array", data: "ByteBuffer", parent: "EbmlMaster", type: "MKVType", id: "Int8Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  RIFF 'AVI '            Audio/Video Interleaved file
 *   LIST 'hdrl'        Header LIST
 *       'avih'         Main AVI header
 *       LIST 'strl'    Video stream LIST
 *           'strh'     Video stream header
 *           'strf'     Video format
 *           <Optional Open DML Super Index + List of standard indexes >
 *       LIST 'strl'    Audio stream LIST
 *           'strh'     Audio stream header
 *           'strf'     Audio format
 *           <Optional Open DML Super Index + List of standard indexes >
 *   LIST 'movi'        Main data LIST
 *       '01wb'         Audio data
 *       '00dc'         Video frame
 *       ...
 *   'idx1'             Index    <Optional old Avi Index>
 *  
 *  @author Owen McGovern
 */
var AVIReader = function(src) {
    this.raf = DataReader.createDataReader(src, ByteOrder.LITTLE_ENDIAN);
    this.aviIndexes = new ArrayList();
};
AVIReader = stjs.extend(AVIReader, null, [], function(constructor, prototype) {
    constructor.FOURCC_RIFF = 1179011410;
    constructor.FOURCC_AVI = 541677121;
    constructor.FOURCC_AVIX = 1481201217;
    constructor.FOURCC_AVIH = 1751742049;
    constructor.FOURCC_LIST = 1414744396;
    constructor.FOURCC_HDRL = 1819436136;
    constructor.FOURCC_JUNK = 1263424842;
    constructor.FOURCC_INDX = 2019847785;
    constructor.FOURCC_IDXL = 829973609;
    constructor.FOURCC_STRL = 1819440243;
    constructor.FOURCC_STRH = 1752331379;
    constructor.FOURCC_STRF = 1718776947;
    constructor.FOURCC_MOVI = 1769369453;
    constructor.FOURCC_REC = 543384946;
    constructor.FOURCC_SEGM = 1835492723;
    constructor.FOURCC_ODML = 1819108463;
    constructor.FOURCC_VIDS = 1935960438;
    constructor.FOURCC_AUDS = 1935963489;
    constructor.FOURCC_MIDS = 1935960429;
    constructor.FOURCC_TXTS = 1937012852;
    constructor.FOURCC_strd = 1685222515;
    constructor.FOURCC_strn = 1852994675;
    constructor.AVIF_HASINDEX = 16;
    constructor.AVIF_MUSTUSEINDEX = 32;
    constructor.AVIF_ISINTERLEAVED = 256;
    constructor.AVIF_TRUSTCKTYPE = 2048;
    constructor.AVIF_WASCAPTUREFILE = 65536;
    constructor.AVIF_COPYRIGHTED = 131072;
    constructor.AVIIF_LIST = 1;
    constructor.AVIIF_KEYFRAME = 16;
    constructor.AVIIF_FIRSTPART = 32;
    constructor.AVIIF_LASTPART = 64;
    constructor.AVIIF_NOTIME = 256;
    constructor.AUDIO_FORMAT_PCM = 1;
    constructor.AUDIO_FORMAT_MP3 = 85;
    constructor.AUDIO_FORMAT_AC3 = 8192;
    constructor.AUDIO_FORMAT_DTS = 8193;
    constructor.AUDIO_FORMAT_VORBIS = 22127;
    constructor.AUDIO_FORMAT_EXTENSIBLE = 65534;
    prototype.AVI_INDEX_OF_INDEXES = 0;
    prototype.AVI_INDEX_OF_CHUNKS = 1;
    prototype.AVI_INDEX_OF_TIMED_CHUNKS = 2;
    prototype.AVI_INDEX_OF_SUB_2FIELD = 3;
    prototype.AVI_INDEX_IS_DATA = 128;
    constructor.STDINDEXSIZE = 16384;
    constructor.SIZE_MASK = 4294967295;
    prototype.raf = null;
    prototype.fileLeft = 0;
    prototype.aviHeader = null;
    prototype.streamHeaders = null;
    prototype.streamFormats = null;
    prototype.aviIndexes = null;
    prototype.openDmlSuperIndex = null;
    prototype.ps = null;
    prototype.skipFrames = true;
    constructor.fromFourCC = function(str) {
        var strBytes = str.getBytes();
        if (strBytes.length != 4) 
             throw new IllegalArgumentException("Expected 4 bytes not " + strBytes.length);
        var fourCCInt = strBytes[3];
        fourCCInt = (fourCCInt <<= 8) | strBytes[2];
        fourCCInt = (fourCCInt <<= 8) | strBytes[1];
        fourCCInt = (fourCCInt <<= 8) | strBytes[0];
        return (fourCCInt);
    };
    /**
     *  
     *  @param fourcc
     *  @return
     */
    constructor.toFourCC = function(fourcc) {
        var sb = new StringBuilder();
        for (var i = 0; i < 4; i++) {
            var c = fourcc & 255;
            sb.append(Character.toString(((c) & 65535)));
            fourcc >>= 8;
        }
        return sb.toString();
    };
    prototype.getFileLeft = function() {
        return (this.fileLeft);
    };
    prototype.getAviIndexes = function() {
        return (this.aviIndexes);
    };
    prototype.parse = function() {
        try {
            var t1 = System.currentTimeMillis();
            var fileSize = this.raf.size();
            this.fileLeft = fileSize;
            var numStreams = 0;
            var streamIndex = -1;
            var videoFrameNo = 1;
            var dwFourCC = this.raf.readInt();
            if (dwFourCC != AVIReader.FOURCC_RIFF) 
                 throw new FormatException("No RIFF header found");
            var aviItem = new AVIReader.AVIList();
            aviItem.read(dwFourCC, this.raf);
            jcodec.Logger.debug(aviItem.toString());
            var previousStreamType = 0;
            do {
                dwFourCC = this.raf.readInt();
                var dwFourCCStr = AVIReader.toFourCC(dwFourCC);
                switch (dwFourCC) {
                    case AVIReader.FOURCC_RIFF:
                        {
                            aviItem = new AVIReader.AVIList();
                            aviItem.read(dwFourCC, this.raf);
                            break;
                        }case AVIReader.FOURCC_LIST:
                        {
                            aviItem = new AVIReader.AVIList();
                            aviItem.read(dwFourCC, this.raf);
                            if ((aviItem).getListType() == AVIReader.FOURCC_MOVI) {
                                aviItem.skip(this.raf);
                            }
                            break;
                        }case AVIReader.FOURCC_STRL:
                        {
                            aviItem = new AVIReader.AVIList();
                            aviItem.read(dwFourCC, this.raf);
                            break;
                        }case AVIReader.FOURCC_AVIH:
                        {
                            aviItem = this.aviHeader = new AVIReader.AVITag_AVIH();
                            aviItem.read(dwFourCC, this.raf);
                            numStreams = this.aviHeader.getStreams();
                            this.streamHeaders = Array(numStreams);
                            this.streamFormats = Array(numStreams);
                            this.openDmlSuperIndex = Array(numStreams);
                            break;
                        }case AVIReader.FOURCC_STRH:
                        {
                            if (streamIndex >= numStreams) {
                                 throw new IllegalStateException("Read more stream headers than expected, expected [" + numStreams + "]");
                            }
                            streamIndex++;
                            aviItem = this.streamHeaders[streamIndex] = new AVIReader.AVITag_STRH();
                            aviItem.read(dwFourCC, this.raf);
                            previousStreamType = (aviItem).getType();
                            break;
                        }case AVIReader.FOURCC_STRF:
                        {
                            switch (previousStreamType) {
                                case AVIReader.FOURCC_VIDS:
                                    {
                                        aviItem = this.streamFormats[streamIndex] = new AVIReader.AVITag_BitmapInfoHeader();
                                        aviItem.read(dwFourCC, this.raf);
                                        break;
                                    }case AVIReader.FOURCC_AUDS:
                                    {
                                        aviItem = this.streamFormats[streamIndex] = new AVIReader.AVITag_WaveFormatEx();
                                        aviItem.read(dwFourCC, this.raf);
                                        break;
                                    }default:
                                    {
                                         throw new IOException("Expected vids or auds got [" + AVIReader.toFourCC(previousStreamType) + "]");
                                    }}
                            break;
                        }case AVIReader.FOURCC_SEGM:
                        {
                            aviItem = new AVIReader.AVI_SEGM();
                            aviItem.read(dwFourCC, this.raf);
                            aviItem.skip(this.raf);
                            break;
                        }case AVIReader.FOURCC_IDXL:
                        {
                            aviItem = new AVIReader.AVITag_AviIndex();
                            aviItem.read(dwFourCC, this.raf);
                            this.aviIndexes.add(aviItem);
                            break;
                        }case AVIReader.FOURCC_INDX:
                        {
                            this.openDmlSuperIndex[streamIndex] = new AVIReader.AVITag_AviDmlSuperIndex();
                            this.openDmlSuperIndex[streamIndex].read(dwFourCC, this.raf);
                            aviItem = this.openDmlSuperIndex[streamIndex];
                            break;
                        }default:
                        {
                            if (dwFourCCStr.endsWith("db")) {
                                aviItem = new AVIReader.AVITag_VideoChunk(false, this.raf);
                                aviItem.read(dwFourCC, this.raf);
                                if (this.skipFrames) {
                                    aviItem.skip(this.raf);
                                } else {
                                    var videoFrameData = (aviItem).getVideoPacket();
                                    var bb = ByteBuffer.wrap(videoFrameData);
                                }
                            } else if (dwFourCCStr.endsWith("dc")) {
                                aviItem = new AVIReader.AVITag_VideoChunk(true, this.raf);
                                aviItem.read(dwFourCC, this.raf);
                                (aviItem).setFrameNo(videoFrameNo);
                                videoFrameNo++;
                                var fourccStr = AVIReader.toFourCC(dwFourCC);
                                var streamNo = Integer.parseInt(fourccStr.substring(0, 2));
                                if (this.skipFrames) {
                                    aviItem.skip(this.raf);
                                } else {
                                    var videoFrameData = (aviItem).getVideoPacket();
                                    var bb = ByteBuffer.wrap(videoFrameData);
                                }
                            } else if (dwFourCCStr.endsWith("wb")) {
                                aviItem = new AVIReader.AVITag_AudioChunk();
                                aviItem.read(dwFourCC, this.raf);
                                aviItem.skip(this.raf);
                            } else if (dwFourCCStr.endsWith("tx")) {
                                aviItem = new AVIReader.AVIChunk();
                                aviItem.read(dwFourCC, this.raf);
                                aviItem.skip(this.raf);
                            } else if (dwFourCCStr.startsWith("ix")) {
                                aviItem = new AVIReader.AVITag_AviDmlStandardIndex();
                                aviItem.read(dwFourCC, this.raf);
                            } else {
                                aviItem = new AVIReader.AVIChunk();
                                aviItem.read(dwFourCC, this.raf);
                                aviItem.skip(this.raf);
                            }
                            break;
                        }}
                jcodec.Logger.debug(aviItem.toString());
                this.fileLeft = fileSize - this.raf.position();
            } while (this.fileLeft > 0);
            var t2 = System.currentTimeMillis();
            jcodec.Logger.debug("\tFile Left [" + this.fileLeft + "]");
            jcodec.Logger.debug("\tParse time : " + (t2 - t1) + "ms");
        } finally {
            if (this.ps != null) {
                this.ps.close();
            }
        }
    };
    constructor.AVIChunk = function() {};
    constructor.AVIChunk = stjs.extend(constructor.AVIChunk, null, [], function(constructor, prototype) {
        prototype.dwFourCC = 0;
        prototype.fwFourCCStr = null;
        prototype.dwChunkSize = 0;
        prototype.startOfChunk = 0;
        prototype.read = function(dwFourCC, raf) {
            this.startOfChunk = raf.position() - 4;
            this.dwFourCC = dwFourCC;
            this.fwFourCCStr = AVIReader.toFourCC(dwFourCC);
            this.dwChunkSize = raf.readInt();
        };
        prototype.getStartOfChunk = function() {
            return (this.startOfChunk);
        };
        prototype.getEndOfChunk = function() {
            return (this.startOfChunk + 8 + this.getChunkSize());
        };
        prototype.getFourCC = function() {
            return (this.dwFourCC);
        };
        prototype.skip = function(raf) {
            var chunkSize = this.getChunkSize();
            if (chunkSize < 0) 
                 throw new IOException("Negative chunk size for chunk [" + AVIReader.toFourCC(this.dwFourCC) + "]");
            raf.skipBytes(chunkSize);
        };
        prototype.getChunkSize = function() {
            if ((this.dwChunkSize & 1) == 1) 
                return (this.dwChunkSize + 1);
             else 
                return (this.dwChunkSize);
        };
        prototype.toString = function() {
            var chunkStr = AVIReader.toFourCC(this.dwFourCC);
            if (chunkStr.trim().length == 0) {
                chunkStr = Integer.toHexString(this.dwFourCC);
            }
            return ("\tCHUNK [" + chunkStr + "], Size [" + this.dwChunkSize + "], StartOfChunk [" + this.getStartOfChunk() + "]");
        };
    }, {}, {});
    constructor.AVIList = function() {
        AVIReader.AVIChunk.call(this);
    };
    constructor.AVIList = stjs.extend(constructor.AVIList, AVIReader.AVIChunk, [], function(constructor, prototype) {
        prototype.dwListTypeFourCC = 0;
        prototype.dwListTypeFourCCStr = null;
        prototype.read = function(dwFourCC, raf) {
            AVIReader.AVIChunk.prototype.read.call(this, dwFourCC, raf);
            this.dwChunkSize -= 4;
            this.dwListTypeFourCC = raf.readInt();
            this.dwListTypeFourCCStr = AVIReader.toFourCC(this.dwListTypeFourCC);
        };
        prototype.getListType = function() {
            return (this.dwListTypeFourCC);
        };
        prototype.toString = function() {
            var dwFourCCStr = AVIReader.toFourCC(this.dwFourCC);
            return (dwFourCCStr + " [" + this.dwListTypeFourCCStr + "], Size [" + this.dwChunkSize + "], StartOfChunk [" + this.getStartOfChunk() + "]");
        };
    }, {}, {});
    constructor.AVI_SEGM = function() {
        AVIReader.AVIChunk.call(this);
    };
    constructor.AVI_SEGM = stjs.extend(constructor.AVI_SEGM, AVIReader.AVIChunk, [], function(constructor, prototype) {
        prototype.read = function(dwFourCC, raf) {
            AVIReader.AVIChunk.prototype.read.call(this, dwFourCC, raf);
        };
        prototype.getChunkSize = function() {
            if (this.dwChunkSize == 0) 
                return (0);
             else 
                return (this.dwChunkSize + 1);
        };
        prototype.toString = function() {
            return ("SEGMENT Align, Size [" + this.dwChunkSize + "], StartOfChunk [" + this.getStartOfChunk() + "]");
        };
    }, {}, {});
    constructor.AVITag_AVIH = function() {
        AVIReader.AVIChunk.call(this);
        this.dwReserved = new Int32Array(4);
    };
    constructor.AVITag_AVIH = stjs.extend(constructor.AVITag_AVIH, AVIReader.AVIChunk, [], function(constructor, prototype) {
        prototype._getHeight = null;
        constructor.AVIF_HASINDEX = 16;
        constructor.AVIF_MUSTUSEINDEX = 32;
        constructor.AVIF_ISINTERLEAVED = 256;
        constructor.AVIF_TRUSTCKTYPE = 2048;
        constructor.AVIF_WASCAPTUREFILE = 65536;
        constructor.AVIF_COPYRIGHTED = 131072;
        prototype.dwMicroSecPerFrame = 0;
        prototype.dwMaxBytesPerSec = 0;
        prototype.dwPaddingGranularity = 0;
        prototype.dwFlags = 0;
        prototype.dwTotalFrames = 0;
        prototype.dwInitialFrames = 0;
        prototype.dwStreams = 0;
        prototype.dwSuggestedBufferSize = 0;
        prototype.dwWidth = 0;
        prototype.dwHeight = 0;
        prototype.dwReserved = null;
        prototype.read = function(dwFourCC, raf) {
            AVIReader.AVIChunk.prototype.read.call(this, dwFourCC, raf);
            if (dwFourCC != AVIReader.FOURCC_AVIH) 
                 throw new IOException("Unexpected AVI header : " + AVIReader.toFourCC(dwFourCC));
            if (this.getChunkSize() != 56) 
                 throw new IOException("Expected dwSize=56");
            this.dwMicroSecPerFrame = raf.readInt();
            this.dwMaxBytesPerSec = raf.readInt();
            this.dwPaddingGranularity = raf.readInt();
            this.dwFlags = raf.readInt();
            this.dwTotalFrames = raf.readInt();
            this.dwInitialFrames = raf.readInt();
            this.dwStreams = raf.readInt();
            this.dwSuggestedBufferSize = raf.readInt();
            this.dwWidth = raf.readInt();
            this.dwHeight = raf.readInt();
            this.dwReserved[0] = raf.readInt();
            this.dwReserved[1] = raf.readInt();
            this.dwReserved[2] = raf.readInt();
            this.dwReserved[3] = raf.readInt();
        };
        prototype.getWidth = function() {
            return this.dwWidth;
        };
        prototype.getHeight = function() {
            return this.dwHeight;
        };
        prototype.getStreams = function() {
            return (this.dwStreams);
        };
        prototype.getTotalFrames = function() {
            return (this.dwTotalFrames);
        };
        prototype.toString = function() {
            var sb = new StringBuilder();
            if ((this.dwFlags & AVIReader.AVITag_AVIH.AVIF_HASINDEX) != 0) 
                sb.append("HASINDEX ");
            if ((this.dwFlags & AVIReader.AVITag_AVIH.AVIF_MUSTUSEINDEX) != 0) 
                sb.append("MUSTUSEINDEX ");
            if ((this.dwFlags & AVIReader.AVITag_AVIH.AVIF_ISINTERLEAVED) != 0) 
                sb.append("ISINTERLEAVED ");
            if ((this.dwFlags & AVIReader.AVITag_AVIH.AVIF_WASCAPTUREFILE) != 0) 
                sb.append("AVIF_WASCAPTUREFILE ");
            if ((this.dwFlags & AVIReader.AVITag_AVIH.AVIF_COPYRIGHTED) != 0) 
                sb.append("AVIF_COPYRIGHTED ");
            return ("AVIH Resolution [" + this.dwWidth + "x" + this.dwHeight + "], NumFrames [" + this.dwTotalFrames + "], Flags [" + Integer.toHexString(this.dwFlags) + "] - [" + sb.toString().trim() + "]");
        };
    }, {dwReserved: "Int32Array"}, {});
    constructor.AVITag_STRH = function() {
        AVIReader.AVIChunk.call(this);
    };
    constructor.AVITag_STRH = stjs.extend(constructor.AVITag_STRH, AVIReader.AVIChunk, [], function(constructor, prototype) {
        constructor.AVISF_DISABLED = 1;
        constructor.AVISF_VIDEO_PALCHANGES = 65536;
        prototype.fccType = 0;
        prototype.fccCodecHandler = 0;
        prototype.dwFlags = 0;
        prototype.wPriority = 0;
        prototype.wLanguage = 0;
        prototype.dwInitialFrames = 0;
        prototype.dwScale = 0;
        prototype.dwRate = 1000000;
        prototype.dwStart = 0;
        prototype.dwLength = 0;
        prototype.dwSuggestedBufferSize = 0;
        prototype.dwQuality = -1;
        prototype.dwSampleSize = 0;
        prototype.left = 0;
        prototype.top = 0;
        prototype.right = 0;
        prototype.bottom = 0;
        prototype.read = function(dwFourCC, raf) {
            AVIReader.AVIChunk.prototype.read.call(this, dwFourCC, raf);
            if (dwFourCC != AVIReader.FOURCC_STRH) 
                 throw new IOException("Expected 'strh' fourcc got [" + AVIReader.toFourCC(this.dwFourCC) + "]");
            this.fccType = raf.readInt();
            this.fccCodecHandler = raf.readInt();
            this.dwFlags = raf.readInt();
            this.wPriority = raf.readShort();
            this.wLanguage = raf.readShort();
            this.dwInitialFrames = raf.readInt();
            this.dwScale = raf.readInt();
            this.dwRate = raf.readInt();
            this.dwStart = raf.readInt();
            this.dwLength = raf.readInt();
            this.dwSuggestedBufferSize = raf.readInt();
            this.dwQuality = raf.readInt();
            this.dwSampleSize = raf.readInt();
            this.left = raf.readShort();
            this.top = raf.readShort();
            this.right = raf.readShort();
            this.bottom = raf.readShort();
        };
        prototype.getType = function() {
            return (this.fccType);
        };
        prototype.getHandler = function() {
            return (this.fccCodecHandler);
        };
        prototype.getHandlerStr = function() {
            if (this.fccCodecHandler != 0) 
                return (AVIReader.toFourCC(this.fccCodecHandler));
             else 
                return ("");
        };
        prototype.getInitialFrames = function() {
            return this.dwInitialFrames;
        };
        prototype.toString = function() {
            return ("\tCHUNK [" + AVIReader.toFourCC(this.dwFourCC) + "], Type[" + (this.fccType > 0 ? AVIReader.toFourCC(this.fccType) : "    ") + "], Handler [" + (this.fccCodecHandler > 0 ? AVIReader.toFourCC(this.fccCodecHandler) : "    ") + "]");
        };
    }, {}, {});
    /**
     *  typedef struct tagBITMAPINFOHEADER { DWORD biSize; LONG biWidth; LONG
     *  biHeight; WORD biPlanes; WORD biBitCount; DWORD biCompression; DWORD
     *  biSizeImage; LONG biXPelsPerMeter; LONG biYPelsPerMeter; DWORD biClrUsed;
     *  DWORD biClrImportant; } BITMAPINFOHEADER;
     */
    constructor.AVITag_BitmapInfoHeader = function() {
        AVIReader.AVIChunk.call(this);
    };
    constructor.AVITag_BitmapInfoHeader = stjs.extend(constructor.AVITag_BitmapInfoHeader, AVIReader.AVIChunk, [], function(constructor, prototype) {
        prototype.biSize = 0;
        prototype.biWidth = 0;
        prototype.biHeight = 0;
        prototype.biPlanes = 0;
        prototype.biBitCount = 0;
        prototype.biCompression = 0;
        prototype.biSizeImage = 0;
        prototype.biXPelsPerMeter = 0;
        prototype.biYPelsPerMeter = 0;
        prototype.biClrUsed = 0;
        prototype.biClrImportant = 0;
        prototype.r = 0;
        prototype.g = 0;
        prototype.b = 0;
        prototype.x = 0;
        prototype.read = function(dwFourCC, raf) {
            AVIReader.AVIChunk.prototype.read.call(this, dwFourCC, raf);
            this.biSize = raf.readInt();
            this.biWidth = raf.readInt();
            this.biHeight = raf.readInt();
            this.biPlanes = raf.readShort();
            this.biBitCount = raf.readShort();
            this.biCompression = raf.readInt();
            this.biSizeImage = raf.readInt();
            this.biXPelsPerMeter = raf.readInt();
            this.biYPelsPerMeter = raf.readInt();
            this.biClrUsed = raf.readInt();
            this.biClrImportant = raf.readInt();
            if (this.getChunkSize() == 56) {
                this.r = raf.readByte();
                this.g = raf.readByte();
                this.b = raf.readByte();
                this.x = raf.readByte();
            }
        };
        prototype.getChunkSize = function() {
            return (this.biSize);
        };
        prototype.toString = function() {
            return ("\tCHUNK [" + AVIReader.toFourCC(this.dwFourCC) + "], BitsPerPixel [" + this.biBitCount + "], Resolution [" + (this.biWidth & AVIReader.SIZE_MASK) + " x " + (this.biHeight & AVIReader.SIZE_MASK) + "], Planes [" + this.biPlanes + "]");
        };
    }, {}, {});
    constructor.AVITag_WaveFormatEx = function() {
        AVIReader.AVIChunk.call(this);
        this.guid_data4 = new Int8Array(8);
    };
    constructor.AVITag_WaveFormatEx = stjs.extend(constructor.AVITag_WaveFormatEx, AVIReader.AVIChunk, [], function(constructor, prototype) {
        constructor.SPEAKER_FRONT_LEFT = 1;
        constructor.SPEAKER_FRONT_RIGHT = 2;
        constructor.SPEAKER_FRONT_CENTER = 4;
        constructor.SPEAKER_LOW_FREQUENCY = 8;
        constructor.SPEAKER_BACK_LEFT = 16;
        constructor.SPEAKER_BACK_RIGHT = 32;
        constructor.SPEAKER_FRONT_LEFT_OF_CENTER = 64;
        constructor.SPEAKER_FRONT_RIGHT_OF_CENTER = 128;
        constructor.SPEAKER_BACK_CENTER = 256;
        constructor.SPEAKER_SIDE_LEFT = 512;
        constructor.SPEAKER_SIDE_RIGHT = 1024;
        constructor.SPEAKER_TOP_CENTER = 2048;
        constructor.SPEAKER_TOP_FRONT_LEFT = 4096;
        constructor.SPEAKER_TOP_FRONT_CENTER = 8192;
        constructor.SPEAKER_TOP_FRONT_RIGHT = 16384;
        constructor.SPEAKER_TOP_BACK_LEFT = 32768;
        constructor.SPEAKER_TOP_BACK_CENTER = 65536;
        constructor.SPEAKER_TOP_BACK_RIGHT = 131072;
        prototype.wFormatTag = 0;
        prototype.channels = 0;
        prototype.nSamplesPerSec = 0;
        prototype.nAvgBytesPerSec = 0;
        prototype.nBlockAlign = 0;
        prototype.wBitsPerSample = 0;
        prototype.cbSize = 0;
        prototype.wValidBitsPerSample = 0;
        prototype.samplesValidBitsPerSample = 0;
        prototype.wReserved = 0;
        prototype.channelMask = 0;
        prototype.guid_data1 = 0;
        prototype.guid_data2 = 0;
        prototype.guid_data3 = 0;
        prototype.guid_data4 = null;
        prototype.mp3Flag = false;
        prototype.wID = 0;
        prototype.fdwFlags = 0;
        prototype.nBlockSize = 0;
        prototype.nFramesPerBlock = 0;
        prototype.nCodecDelay = 0;
        prototype.audioFormat = "?";
        prototype.read = function(dwFourCC, raf) {
            AVIReader.AVIChunk.prototype.read.call(this, dwFourCC, raf);
            this.wFormatTag = raf.readShort();
            this.channels = raf.readShort();
            this.nSamplesPerSec = raf.readInt();
            this.nAvgBytesPerSec = raf.readInt();
            this.nBlockAlign = raf.readShort();
            switch (stjs.trunc(this.wFormatTag)) {
                case AVIReader.AUDIO_FORMAT_PCM:
                    {
                        this.wBitsPerSample = raf.readShort();
                        if (this.dwChunkSize == 40) {
                            this.wValidBitsPerSample = this.samplesValidBitsPerSample = this.wReserved = raf.readShort();
                            this.cbSize = raf.readShort();
                            this.channelMask = raf.readInt();
                            this.guid_data1 = raf.readInt();
                            this.guid_data2 = raf.readShort();
                            this.guid_data3 = raf.readShort();
                            raf.readFully(this.guid_data4);
                        }
                        this.audioFormat = "PCM";
                        break;
                    }case AVIReader.AUDIO_FORMAT_MP3:
                    {
                        this.wBitsPerSample = raf.readShort();
                        this.cbSize = raf.readShort();
                        this.wID = raf.readShort();
                        this.fdwFlags = raf.readInt();
                        this.nBlockSize = raf.readShort();
                        this.nFramesPerBlock = raf.readShort();
                        this.nCodecDelay = raf.readShort();
                        this.mp3Flag = true;
                        this.audioFormat = "MP3";
                        break;
                    }case AVIReader.AUDIO_FORMAT_AC3:
                    {
                        this.audioFormat = "AC3";
                        break;
                    }case AVIReader.AUDIO_FORMAT_DTS:
                    {
                        this.audioFormat = "DTS";
                        break;
                    }case AVIReader.AUDIO_FORMAT_VORBIS:
                    {
                        this.audioFormat = "VORBIS";
                        break;
                    }case AVIReader.AUDIO_FORMAT_EXTENSIBLE:
                    {
                        this.wBitsPerSample = raf.readShort();
                        this.cbSize = raf.readShort();
                        this.wValidBitsPerSample = this.samplesValidBitsPerSample = this.wReserved = raf.readShort();
                        this.channelMask = raf.readInt();
                        this.guid_data1 = raf.readInt();
                        this.guid_data2 = raf.readShort();
                        this.guid_data3 = raf.readShort();
                        raf.readFully(this.guid_data4);
                        this.audioFormat = "EXTENSIBLE";
                        break;
                    }default:
                    {
                        this.audioFormat = "Unknown : " + Integer.toHexString(this.wFormatTag);
                        break;
                    }}
        };
        prototype.isMP3 = function() {
            return (this.mp3Flag);
        };
        prototype.getCbSize = function() {
            return (this.cbSize);
        };
        prototype.toString = function() {
            return (String.format("\tCHUNK [%s], ChunkSize [%d], Format [%s], Channels [%d], Channel Mask [%s], MP3 [%b], SamplesPerSec [%d], nBlockAlign [%d]", AVIReader.toFourCC(this.dwFourCC), this.getChunkSize(), this.audioFormat, this.channels, Integer.toHexString(this.channelMask), this.mp3Flag, this.nSamplesPerSec, this.getStartOfChunk(), this.nBlockAlign));
        };
    }, {guid_data4: "Int8Array"}, {});
    constructor.AVITag_VideoChunk = function(compressed, raf) {
        AVIReader.AVIChunk.call(this);
        this.compressed = compressed;
        this.raf = raf;
    };
    constructor.AVITag_VideoChunk = stjs.extend(constructor.AVITag_VideoChunk, AVIReader.AVIChunk, [], function(constructor, prototype) {
        prototype.streamNo = 0;
        prototype.compressed = false;
        prototype.frameNo = -1;
        prototype.raf = null;
        prototype.getStreamNo = function() {
            return (this.streamNo);
        };
        prototype.setFrameNo = function(frameNo) {
            this.frameNo = frameNo;
        };
        prototype.getChunkSize = function() {
            if ((this.dwChunkSize & 1) == 1) 
                return (this.dwChunkSize + 1);
             else 
                return (this.dwChunkSize);
        };
        prototype.read = function(dwFourCC, raf) {
            AVIReader.AVIChunk.prototype.read.call(this, dwFourCC, raf);
            var fourccStr = AVIReader.toFourCC(dwFourCC);
            this.streamNo = Integer.parseInt(fourccStr.substring(0, 2));
        };
        prototype.getVideoPacket = function() {
            var videoFrameData = new Int8Array(this.dwChunkSize);
            var bytesRead = this.raf.readFully(videoFrameData);
            if (bytesRead != this.dwChunkSize) 
                 throw new IOException("Read mismatch expected chunksize [" + this.dwChunkSize + "], Actual read [" + bytesRead + "]");
            var alignment = this.getChunkSize() - this.dwChunkSize;
            if (alignment > 0) 
                this.raf.skipBytes(alignment);
            return (videoFrameData);
        };
        prototype.toString = function() {
            return ("\tVIDEO CHUNK - Stream " + this.streamNo + ",  chunkStart=" + this.getStartOfChunk() + ", " + (this.compressed ? "compressed" : "uncompressed") + ", ChunkSize=" + this.getChunkSize() + ", FrameNo=" + this.frameNo);
        };
    }, {raf: "DataReader"}, {});
    constructor.AVITag_AudioChunk = function() {
        AVIReader.AVIChunk.call(this);
    };
    constructor.AVITag_AudioChunk = stjs.extend(constructor.AVITag_AudioChunk, AVIReader.AVIChunk, [], function(constructor, prototype) {
        prototype.streamNo = 0;
        prototype.raf = null;
        prototype.read = function(dwFourCC, raf) {
            this.raf = raf;
            AVIReader.AVIChunk.prototype.read.call(this, dwFourCC, raf);
            var fourccStr = AVIReader.toFourCC(dwFourCC);
            this.streamNo = Integer.parseInt(fourccStr.substring(0, 2));
        };
        prototype.getChunkSize = function() {
            if ((this.dwChunkSize & 1) == 1) 
                return (this.dwChunkSize + 1);
             else 
                return (this.dwChunkSize);
        };
        prototype.getAudioPacket = function() {
            var audioFrameData = new Int8Array(this.dwChunkSize);
            var bytesRead = this.raf.readFully(audioFrameData);
            if (bytesRead != this.dwChunkSize) 
                 throw new IOException("Read mismatch expected chunksize [" + this.dwChunkSize + "], Actual read [" + bytesRead + "]");
            var alignment = this.getChunkSize() - this.dwChunkSize;
            if (alignment > 0) 
                this.raf.skipBytes(alignment);
            return (audioFrameData);
        };
        prototype.toString = function() {
            return ("\tAUDIO CHUNK - Stream " + this.streamNo + ", StartOfChunk=" + this.getStartOfChunk() + ", ChunkSize=" + this.getChunkSize());
        };
    }, {raf: "DataReader"}, {});
    /**
     *  AVIINDEXENTRY index_entry[n]
     *  
     *  typedef struct { DWORD ckid; DWORD dwFlags; DWORD dwChunkOffset; DWORD
     *  dwChunkLength; } AVIINDEXENTRY;
     *  
     *  // Flag bitmasks #define AVIIF_LIST 0x00000001 #define AVIIF_KEYFRAME
     *  0x00000010 #define AVIIF_NO_TIME 0x00000100 #define AVIIF_COMPRESSOR
     *  0x0FFF0000 // unused?
     */
    constructor.AVITag_AviIndex = function() {
        AVIReader.AVIChunk.call(this);
    };
    constructor.AVITag_AviIndex = stjs.extend(constructor.AVITag_AviIndex, AVIReader.AVIChunk, [], function(constructor, prototype) {
        prototype.numIndexes = 0;
        prototype.ckid = null;
        prototype.dwFlags = null;
        prototype.dwChunkOffset = null;
        prototype.dwChunkLength = null;
        prototype.read = function(dwFourCC, raf) {
            AVIReader.AVIChunk.prototype.read.call(this, dwFourCC, raf);
            this.numIndexes = this.getChunkSize() >> 4;
            this.ckid = new Int32Array(this.numIndexes);
            this.dwFlags = new Int32Array(this.numIndexes);
            this.dwChunkOffset = new Int32Array(this.numIndexes);
            this.dwChunkLength = new Int32Array(this.numIndexes);
            for (var i = 0; i < this.numIndexes; i++) {
                this.ckid[i] = raf.readInt();
                this.dwFlags[i] = raf.readInt();
                this.dwChunkOffset[i] = raf.readInt();
                this.dwChunkLength[i] = raf.readInt();
            }
            raf.setPosition(this.getEndOfChunk());
            var alignment = this.getChunkSize() - this.dwChunkSize;
            if (alignment > 0) 
                raf.skipBytes(alignment);
        };
        prototype.getNumIndexes = function() {
            return this.numIndexes;
        };
        prototype.getCkid = function() {
            return this.ckid;
        };
        prototype.getDwFlags = function() {
            return this.dwFlags;
        };
        prototype.getDwChunkOffset = function() {
            return this.dwChunkOffset;
        };
        prototype.getDwChunkLength = function() {
            return this.dwChunkLength;
        };
        prototype.debugOut = function() {
            for (var i = 0; i < this.numIndexes; i++) {
                jcodec.Logger.debug("\t");
            }
        };
        prototype.toString = function() {
            return (String.format("\tAvi Index List, StartOfChunk [%d], ChunkSize [%d], NumIndexes [%d]", this.getStartOfChunk(), this.dwChunkSize, (this.getChunkSize() >> 4)));
        };
    }, {ckid: "Int32Array", dwFlags: "Int32Array", dwChunkOffset: "Int32Array", dwChunkLength: "Int32Array"}, {});
    /**
     *  typedef struct _avisuperindex_chunk { FOURCC fcc; DWORD cb; WORD
     *  wLongsPerEntry; BYTE bIndexSubType; BYTE bIndexType; DWORD nEntriesInUse;
     *  DWORD dwChunkId; DWORD dwReserved[3]; struct _avisuperindex_entry {
     *  __int64 qwOffset; DWORD dwSize; DWORD dwDuration; } aIndex[ ]; }
     *  AVISUPERINDEX;
     *  
     *  #define STDINDEXSIZE 0x4000 #define NUMINDEX(wLongsPerEntry)
     *  ((STDINDEXSIZE-32)/4/(wLongsPerEntry)) #define
     *  NUMINDEXFILL(wLongsPerEntry) ((STDINDEXSIZE/4) -
     *  NUMINDEX(wLongsPerEntry))
     */
    constructor.AVITag_AviDmlSuperIndex = function() {
        AVIReader.AVIChunk.call(this);
        this.dwReserved = new Int32Array(3);
        this.sb = new StringBuilder();
    };
    constructor.AVITag_AviDmlSuperIndex = stjs.extend(constructor.AVITag_AviDmlSuperIndex, AVIReader.AVIChunk, [], function(constructor, prototype) {
        prototype.wLongsPerEntry = 0;
        prototype.bIndexSubType = 0;
        prototype.bIndexType = 0;
        prototype.nEntriesInUse = 0;
        prototype.dwChunkId = 0;
        prototype.dwReserved = null;
        prototype.qwOffset = null;
        prototype.dwSize = null;
        prototype.dwDuration = null;
        prototype.numIndex = 0;
        prototype.numIndexFill = 0;
        prototype.sb = null;
        prototype.streamNo = 0;
        prototype.read = function(dwFourCC, raf) {
            AVIReader.AVIChunk.prototype.read.call(this, dwFourCC, raf);
            this.wLongsPerEntry = raf.readShort();
            this.bIndexSubType = raf.readByte();
            this.bIndexType = raf.readByte();
            this.nEntriesInUse = raf.readInt();
            this.dwChunkId = raf.readInt();
            this.dwReserved[0] = raf.readInt();
            this.dwReserved[1] = raf.readInt();
            this.dwReserved[2] = raf.readInt();
            this.qwOffset = Array(this.nEntriesInUse);
            this.dwSize = new Int32Array(this.nEntriesInUse);
            this.dwDuration = new Int32Array(this.nEntriesInUse);
            var chunkIdStr = AVIReader.toFourCC(this.dwChunkId);
            this.sb.append(String.format("\tAvi DML Super Index List - ChunkSize=%d, NumIndexes = %d, longsPerEntry = %d, Stream = %s, Type = %s", this.getChunkSize(), this.nEntriesInUse, this.wLongsPerEntry, chunkIdStr.substring(0, 2), chunkIdStr.substring(2)));
            for (var i = 0; i < this.nEntriesInUse; i++) {
                this.qwOffset[i] = raf.readLong();
                this.dwSize[i] = raf.readInt();
                this.dwDuration[i] = raf.readInt();
                this.sb.append(String.format("\n\t\tStandard Index - Offset [%d], Size [%d], Duration [%d]", this.qwOffset[i], this.dwSize[i], this.dwDuration[i]));
            }
            raf.setPosition(this.getEndOfChunk());
        };
        prototype.toString = function() {
            return (this.sb.toString());
        };
    }, {dwReserved: "Int32Array", qwOffset: "Array", dwSize: "Int32Array", dwDuration: "Int32Array", sb: "StringBuilder"}, {});
    /**
     *  typedef struct _avistdindex_chunk { FOURCC fcc; DWORD cb; WORD
     *  wLongsPerEntry; // 2 bytes BYTE bIndexSubType; // 1 byte BYTE bIndexType;
     *  // 1 byte DWORD nEntriesInUse; // 4 bytes DWORD dwChunkId; // 4 bytes
     *  __int64 qwBaseOffset; // 8 bytes DWORD dwReserved3; // 4 bytes
     *  
     *  struct _avistdindex_entry { DWORD dwOffset; // 4 bytes DWORD dwSize; // 4
     *  bytes } aIndex[ ]; } AVISTDINDEX;
     *  
     *  
     *  #define AVISTDINDEX_DELTAFRAME ( 0x80000000) // Delta frames have the
     *  high bit set #define AVISTDINDEX_SIZEMASK (~0x80000000)
     *  
     *  #define AVI_INDEX_OF_INDEXES 0x00 #define AVI_INDEX_OF_CHUNKS 0x01
     *  #define AVI_INDEX_OF_TIMED_CHUNKS 0x02 #define AVI_INDEX_OF_SUB_2FIELD
     *  0x03 #define AVI_INDEX_IS_DATA 0x80
     */
    constructor.AVITag_AviDmlStandardIndex = function() {
        AVIReader.AVIChunk.call(this);
    };
    constructor.AVITag_AviDmlStandardIndex = stjs.extend(constructor.AVITag_AviDmlStandardIndex, AVIReader.AVIChunk, [], function(constructor, prototype) {
        prototype.wLongsPerEntry = 0;
        prototype.bIndexSubType = 0;
        prototype.bIndexType = 0;
        prototype.nEntriesInUse = 0;
        prototype.dwChunkId = 0;
        prototype.qwBaseOffset = 0;
        prototype.dwReserved2 = 0;
        prototype.dwOffset = null;
        prototype.dwDuration = null;
        prototype.lastOffset = -1;
        prototype.lastDuration = -1;
        prototype.getChunkSize = function() {
            return (this.dwChunkSize);
        };
        prototype.read = function(dwFourCC, raf) {
            AVIReader.AVIChunk.prototype.read.call(this, dwFourCC, raf);
            this.wLongsPerEntry = raf.readShort();
            this.bIndexSubType = raf.readByte();
            this.bIndexType = raf.readByte();
            this.nEntriesInUse = raf.readInt();
            this.dwChunkId = raf.readInt();
            this.qwBaseOffset = raf.readLong();
            this.dwReserved2 = raf.readInt();
            this.dwOffset = new Int32Array(this.nEntriesInUse);
            this.dwDuration = new Int32Array(this.nEntriesInUse);
            try {
                for (var i = 0; i < this.nEntriesInUse; i++) {
                    this.dwOffset[i] = raf.readInt();
                    this.dwDuration[i] = raf.readInt();
                    this.lastOffset = this.dwOffset[i];
                    this.lastDuration = this.dwDuration[i];
                }
            }catch (e) {
                jcodec.Logger.debug("Failed to read : " + this.toString());
            }
            raf.setPosition(this.getEndOfChunk());
        };
        prototype.toString = function() {
            return (String.format("\tAvi DML Standard Index List Type=%d, SubType=%d, ChunkId=%s, StartOfChunk=%d, NumIndexes=%d, LongsPerEntry=%d, ChunkSize=%d, FirstOffset=%d, FirstDuration=%d,LastOffset=%d, LastDuration=%d", this.bIndexType, this.bIndexSubType, AVIReader.toFourCC(this.dwChunkId), this.getStartOfChunk(), this.nEntriesInUse, this.wLongsPerEntry, this.getChunkSize(), this.dwOffset[0], this.dwDuration[0], this.lastOffset, this.lastDuration));
        };
    }, {dwOffset: "Int32Array", dwDuration: "Int32Array"}, {});
}, {raf: "DataReader", aviHeader: "AVIReader.AVITag_AVIH", streamHeaders: "Array", streamFormats: "Array", aviIndexes: {name: "List", arguments: ["AVIReader.AVITag_AviIndex"]}, openDmlSuperIndex: "Array", ps: "PrintStream"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Gets media info from MPEG PS file
 *  
 *  @author The JCodec project
 *  
 */
var MPSMediaInfo = function() {
    MPSUtils.PESReader.call(this);
    this.infos = new HashMap();
};
MPSMediaInfo = stjs.extend(MPSMediaInfo, MPSUtils.PESReader, [], function(constructor, prototype) {
    prototype.infos = null;
    prototype.pesTried = 0;
    prototype.psm = null;
    constructor.MPEGTimecodeMetadata = function() {};
    constructor.MPEGTimecodeMetadata = stjs.extend(constructor.MPEGTimecodeMetadata, null, [], function(constructor, prototype) {
        prototype.getNumFrames = function() {
            return null;
        };
        prototype.isDropFrame = function() {
            return null;
        };
        prototype.getStartCounter = function() {
            return null;
        };
    }, {}, {});
    constructor.MPEGTrackMetadata = function(streamId) {
        this.streamId = streamId;
    };
    constructor.MPEGTrackMetadata = stjs.extend(constructor.MPEGTrackMetadata, null, [], function(constructor, prototype) {
        prototype.streamId = 0;
        prototype.codec = null;
        prototype.probeData = null;
        prototype.getAudioFormat = function() {
            return null;
        };
        prototype.getChannelLables = function() {
            return null;
        };
        prototype.getDisplaySize = function() {
            return null;
        };
        prototype.getCodedSize = function() {
            return null;
        };
        prototype.getFps = function() {
            return 0;
        };
        prototype.getDuration = function() {
            return 0;
        };
        prototype.getFourcc = function() {
            return null;
        };
        prototype.getFpsR = function() {
            return null;
        };
        prototype.getNumFrames = function() {
            return 0;
        };
        prototype.getTimecode = function() {
            return null;
        };
    }, {codec: {name: "Enum", arguments: ["Codec"]}, probeData: "ByteBuffer"}, {});
    prototype.getMediaInfo = function(f) {
        try {
            new (stjs.extend(function MPSMediaInfo$1() {
                NIOUtils.FileReader.call(this);
            }, NIOUtils.FileReader, [], function(constructor, prototype) {
                prototype.data = function(data, filePos) {
                    this.analyseBuffer(data, filePos);
                };
                prototype.done = function() {};
            }, {}, {}))().readFile(f, 65536, null);
        }catch (e) {
            jcodec.Logger.info("Media info done");
        }
        return this.getInfos();
    };
    constructor.MediaInfoDone = function() {
        RuntimeException.call(this);
    };
    constructor.MediaInfoDone = stjs.extend(constructor.MediaInfoDone, RuntimeException, [], null, {}, {});
    prototype.pes = function(pesBuffer, start, pesLen, stream) {
        if (!MPSUtils.mediaStream(stream)) 
            return;
        var info = this.infos.get(stream);
        if (info == null) {
            info = new MPSMediaInfo.MPEGTrackMetadata(stream);
            this.infos.put(stream, info);
        }
        if (info.probeData == null) 
            info.probeData = NIOUtils.cloneBuffer(pesBuffer);
        if (++this.pesTried >= 100) {
            this.deriveMediaInfo();
             throw new MPSMediaInfo.MediaInfoDone();
        }
    };
    prototype.deriveMediaInfo = function() {
        var values = this.infos.values();
        for (var iterator$stream = values.iterator(); iterator$stream.hasNext(); ) {
            var stream = iterator$stream.next();
            var streamId = 256 | stream.streamId;
            if (streamId >= MPSUtils.AUDIO_MIN && streamId <= MPSUtils.AUDIO_MAX) {
                stream.codec = Codec.MP2;
            } else if (streamId == MPSUtils.PRIVATE_1) {
                var dup = stream.probeData.duplicate();
                MPSUtils.readPESHeader(dup, 0);
                var type = dup.get() & 255;
                if (type >= 128 && type <= 135) {
                    stream.codec = Codec.AC3;
                } else if ((type >= 136 && type <= 143) || (type >= 152 && type <= 159)) {
                    stream.codec = Codec.DTS;
                } else if (type >= 160 && type <= 175) {
                    stream.codec = Codec.PCM_DVD;
                } else if (type >= 176 && type <= 191) {
                    stream.codec = Codec.TRUEHD;
                } else if (type >= 192 && type <= 207) {
                    stream.codec = Codec.AC3;
                }
            } else if (streamId >= MPSUtils.VIDEO_MIN && streamId <= MPSUtils.VIDEO_MAX) {
                stream.codec = Codec.MPEG2;
            }
        }
    };
    prototype.parseSystem = function(pesBuffer) {
        NIOUtils.skip(pesBuffer, 12);
        var result = IntArrayList.createIntArrayList();
         while (pesBuffer.remaining() >= 3 && (pesBuffer.getAt(pesBuffer.position()) & 128) == 128){
            result.add(pesBuffer.get() & 255);
            pesBuffer.getShort();
        }
        return result.toArray();
    };
    constructor.PSM = function() {};
    constructor.PSM = stjs.extend(constructor.PSM, null, [], null, {}, {});
    prototype.parsePSM = function(pesBuffer) {
        pesBuffer.getInt();
        var psmLen = pesBuffer.getShort();
        if (psmLen > 1018) 
             throw new RuntimeException("Invalid PSM");
        var b0 = pesBuffer.get();
        var b1 = pesBuffer.get();
        if ((b1 & 1) != 1) 
             throw new RuntimeException("Invalid PSM");
        var psiLen = pesBuffer.getShort();
        var psi = NIOUtils.read(pesBuffer, psiLen & 65535);
        var elStreamLen = pesBuffer.getShort();
        this.parseElStreams(NIOUtils.read(pesBuffer, elStreamLen & 65535));
        var crc = pesBuffer.getInt();
        return new MPSMediaInfo.PSM();
    };
    prototype.parseElStreams = function(buf) {
         while (buf.hasRemaining()){
            var streamType = buf.get();
            var streamId = buf.get();
            var strInfoLen = buf.getShort();
            var strInfo = NIOUtils.read(buf, strInfoLen & 65535);
        }
    };
    prototype.getInfos = function() {
        return new ArrayList(this.infos.values());
    };
    constructor.main1 = function(args) {
        new MPSMediaInfo().getMediaInfo(new File(args[0]));
    };
    constructor.extract = function(input) {
        return null;
    };
    prototype.getAudioTracks = function() {
        return null;
    };
    prototype.getVideoTrack = function() {
        return null;
    };
}, {infos: {name: "Map", arguments: [null, "MPSMediaInfo.MPEGTrackMetadata"]}, psm: "MPSMediaInfo.PSM", pesBuffer: "ByteBuffer"}, {});
/**
 *  
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Decoder for Apple ProRes format
 *  
 *  As posted at http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=5554d
 *  e13b29b9bb812ee5cfd606349873ddf0945
 *  
 *  @author The JCodec project
 *  
 */
var ProresDecoder = function() {
    VideoDecoder.call(this);
};
ProresDecoder = stjs.extend(ProresDecoder, VideoDecoder, [], function(constructor, prototype) {
    constructor.table = new Int32Array([8, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    constructor.mask = new Int32Array([0, 0, 0, 0, 0, 0, 0, 0, -1]);
    constructor.nZeros = function(check16Bit) {
        var low = ProresDecoder.table[check16Bit & 255];
        check16Bit >>= 8;
        var high = ProresDecoder.table[check16Bit];
        return high + (ProresDecoder.mask[high] & low);
    };
    constructor.readCodeword = function(reader, codebook) {
        var q = ProresDecoder.nZeros(reader.check16Bits());
        reader.skipFast(q + 1);
        if (q > codebook.switchBits) {
            var bits = codebook.golombBits + q;
            if (bits > 16) 
                jcodec.Logger.error("Broken prores slice");
            return ((1 << bits) | reader.readFast16(bits)) - codebook.golombOffset;
        } else if (codebook.riceOrder > 0) 
            return (q << codebook.riceOrder) | reader.readFast16(codebook.riceOrder);
         else 
            return q;
    };
    constructor.golumbToSigned = function(val) {
        return (val >> 1) ^ ProresDecoder.golumbSign(val);
    };
    constructor.golumbSign = function(val) {
        return -(val & 1);
    };
    constructor.readDCCoeffs = function(bits, qMat, out, blocksPerSlice, blkSize) {
        var c = ProresDecoder.readCodeword(bits, ProresConsts.firstDCCodebook);
        if (c < 0) {
            return;
        }
        var prevDc = ProresDecoder.golumbToSigned(c);
        out[0] = 4096 + ProresDecoder.qScale(qMat, 0, prevDc);
        var code = 5, sign = 0, idx = blkSize;
        for (var i = 1; i < blocksPerSlice; i++ , idx += blkSize) {
            code = ProresDecoder.readCodeword(bits, ProresConsts.dcCodebooks[Math.min(code, 6)]);
            if (code < 0) {
                return;
            }
            if (code != 0) 
                sign ^= ProresDecoder.golumbSign(code);
             else 
                sign = 0;
            prevDc += MathUtil.toSigned((code + 1) >> 1, sign);
            out[idx] = 4096 + ProresDecoder.qScale(qMat, 0, prevDc);
        }
    };
    constructor.readACCoeffs = function(bits, qMat, out, blocksPerSlice, scan, max, log2blkSize) {
        var run = 4;
        var level = 2;
        var blockMask = blocksPerSlice - 1;
        var log2BlocksPerSlice = MathUtil.log2(blocksPerSlice);
        var maxCoeffs = 64 << log2BlocksPerSlice;
        var pos = blockMask;
         while (bits.remaining() > 32 || bits.checkAllBits() != 0){
            run = ProresDecoder.readCodeword(bits, ProresConsts.runCodebooks[Math.min(run, 15)]);
            if (run < 0 || run >= maxCoeffs - pos - 1) {
                return;
            }
            pos += run + 1;
            level = ProresDecoder.readCodeword(bits, ProresConsts.levCodebooks[Math.min(level, 9)]) + 1;
            if (level < 0 || level > 65535) {
                return;
            }
            var sign = -bits.read1Bit();
            var ind = pos >> log2BlocksPerSlice;
            if (ind >= max) 
                break;
            out[((pos & blockMask) << log2blkSize) + scan[ind]] = ProresDecoder.qScale(qMat, ind, MathUtil.toSigned(level, sign));
        }
    };
    constructor.qScale = function(qMat, ind, val) {
        return ((val * qMat[ind]) >> 2);
    };
    prototype.decodeOnePlane = function(bits, blocksPerSlice, out, qMat, scan, mbX, mbY, plane) {
        try {
            ProresDecoder.readDCCoeffs(bits, qMat, out, blocksPerSlice, 64);
            ProresDecoder.readACCoeffs(bits, qMat, out, blocksPerSlice, scan, 64, 6);
        }catch (e) {
            System.err.println("Suppressing slice error at [" + mbX + ", " + mbY + "].");
        }
        for (var i = 0; i < blocksPerSlice; i++) {
            SimpleIDCT10Bit.idct10(out, i << 6);
        }
    };
    prototype.decodeFrame8Bit = function(data, target) {
        var fh = ProresDecoder.readFrameHeader(data);
        var codedWidth = (fh.width + 15) & ~15;
        var codedHeight = (fh.height + 15) & ~15;
        var lumaSize = codedWidth * codedHeight;
        var chromaSize = lumaSize >> (3 - fh.chromaType);
        if (target == null || target[0].length < lumaSize || target[1].length < chromaSize || target[2].length < chromaSize) {
             throw new RuntimeException("Provided output picture won't fit into provided buffer");
        }
        if (fh.frameType == 0) {
            this.decodePicture(data, target, fh.width, fh.height, codedWidth >> 4, fh.qMatLuma, fh.qMatChroma, fh.scan, 0, fh.chromaType);
        } else {
            this.decodePicture(data, target, fh.width, fh.height >> 1, codedWidth >> 4, fh.qMatLuma, fh.qMatChroma, fh.scan, fh.topFieldFirst ? 1 : 2, fh.chromaType);
            this.decodePicture(data, target, fh.width, fh.height >> 1, codedWidth >> 4, fh.qMatLuma, fh.qMatChroma, fh.scan, fh.topFieldFirst ? 2 : 1, fh.chromaType);
        }
        return new Picture8Bit(codedWidth, codedHeight, target, fh.chromaType == 2 ? ColorSpace.YUV422 : ColorSpace.YUV444, new Rect(0, 0, fh.width, fh.height));
    };
    prototype.decodeFields8Bit = function(data, target) {
        var fh = ProresDecoder.readFrameHeader(data);
        var codedWidth = (fh.width + 15) & ~15;
        var codedHeight = (fh.height + 15) & ~15;
        var lumaSize = codedWidth * codedHeight;
        var chromaSize = lumaSize >> 1;
        if (fh.frameType == 0) {
            if (target == null || target[0][0].length < lumaSize || target[0][1].length < chromaSize || target[0][2].length < chromaSize) {
                 throw new RuntimeException("Provided output picture won't fit into provided buffer");
            }
            this.decodePicture(data, target[0], fh.width, fh.height, codedWidth >> 4, fh.qMatLuma, fh.qMatChroma, fh.scan, 0, fh.chromaType);
            return [Picture8Bit.createPicture8Bit(codedWidth, codedHeight, target[0], ColorSpace.YUV422)];
        } else {
            lumaSize >>= 1;
            chromaSize >>= 1;
            if (target == null || target[0][0].length < lumaSize || target[0][1].length < chromaSize || target[0][2].length < chromaSize || target[1][0].length < lumaSize || target[1][1].length < chromaSize || target[1][2].length < chromaSize) {
                 throw new RuntimeException("Provided output picture won't fit into provided buffer");
            }
            this.decodePicture(data, target[fh.topFieldFirst ? 0 : 1], fh.width, fh.height >> 1, codedWidth >> 4, fh.qMatLuma, fh.qMatChroma, fh.scan, 0, fh.chromaType);
            this.decodePicture(data, target[fh.topFieldFirst ? 1 : 0], fh.width, fh.height >> 1, codedWidth >> 4, fh.qMatLuma, fh.qMatChroma, fh.scan, 0, fh.chromaType);
            return [Picture8Bit.createPicture8Bit(codedWidth, codedHeight >> 1, target[0], ColorSpace.YUV422), Picture8Bit.createPicture8Bit(codedWidth, codedHeight >> 1, target[1], ColorSpace.YUV422)];
        }
    };
    constructor.readFrameHeader = function(inp) {
        var frameSize = inp.getInt();
        var sig = ProresDecoder.readSig(inp);
        if (!"icpf".equals(sig)) 
             throw new RuntimeException("Not a prores frame");
        var hdrSize = inp.getShort();
        var version = inp.getShort();
        var res1 = inp.getInt();
        var width = inp.getShort();
        var height = inp.getShort();
        var flags1 = inp.get();
        var frameType = (flags1 >> 2) & 3;
        var chromaType = (flags1 >> 6) & 3;
        var scan;
        var topFieldFirst = false;
        if (frameType == 0) {
            scan = ProresConsts.progressive_scan;
        } else {
            scan = ProresConsts.interlaced_scan;
            if (frameType == 1) 
                topFieldFirst = true;
        }
        var res2 = inp.get();
        var prim = inp.get();
        var transFunc = inp.get();
        var matrix = inp.get();
        var pixFmt = inp.get();
        var res3 = inp.get();
        var flags2 = inp.get() & 255;
        var qMatLuma = new Int32Array(64);
        var qMatChroma = new Int32Array(64);
        if (ProresDecoder.hasQMatLuma(flags2)) {
            ProresDecoder.readQMat(inp, qMatLuma, scan);
        } else {
            Arrays.fill(qMatLuma, 4);
        }
        if (ProresDecoder.hasQMatChroma(flags2)) {
            ProresDecoder.readQMat(inp, qMatChroma, scan);
        } else {
            Arrays.fill(qMatChroma, 4);
        }
        inp.setPosition(inp.position() + hdrSize - (20 + (ProresDecoder.hasQMatLuma(flags2) ? 64 : 0) + (ProresDecoder.hasQMatChroma(flags2) ? 64 : 0)));
        return new ProresConsts.FrameHeader(frameSize - hdrSize - 8, width, height, frameType, topFieldFirst, scan, qMatLuma, qMatChroma, chromaType);
    };
    constructor.readSig = function(inp) {
        var sig = new Int8Array(4);
        inp.getBuf(sig);
        return Platform.stringFromBytes(sig);
    };
    prototype.decodePicture = function(data, result, width, height, mbWidth, qMatLuma, qMatChroma, scan, pictureType, chromaType) {
        var ph = ProresDecoder.readPictureHeader(data);
        var mbX = 0, mbY = 0;
        var sliceMbCount = 1 << ph.log2SliceMbWidth;
        for (var i = 0; i < ph.sliceSizes.length; i++) {
             while (mbWidth - mbX < sliceMbCount)
                sliceMbCount >>= 1;
            this.decodeSlice(NIOUtils.read(data, ph.sliceSizes[i]), qMatLuma, qMatChroma, scan, sliceMbCount, mbX, mbY, ph.sliceSizes[i], result, width, pictureType, chromaType);
            mbX += sliceMbCount;
            if (mbX == mbWidth) {
                sliceMbCount = 1 << ph.log2SliceMbWidth;
                mbX = 0;
                mbY++;
            }
        }
    };
    constructor.readPictureHeader = function(inp) {
        var hdrSize = (inp.get() & 255) >> 3;
        inp.getInt();
        var sliceCount = inp.getShort();
        var a = inp.get() & 255;
        var log2SliceMbWidth = a >> 4;
        var sliceSizes = new Int16Array(sliceCount);
        for (var i = 0; i < sliceCount; i++) {
            sliceSizes[i] = inp.getShort();
        }
        return new ProresConsts.PictureHeader(log2SliceMbWidth, sliceSizes);
    };
    prototype.decodeSlice = function(data, qMatLuma, qMatChroma, scan, sliceMbCount, mbX, mbY, sliceSize, result, lumaStride, pictureType, chromaType) {
        var hdrSize = (data.get() & 255) >> 3;
        var qScale = ProresDecoder.clip(data.get() & 255, 1, 224);
        qScale = qScale > 128 ? qScale - 96 << 2 : qScale;
        var yDataSize = data.getShort();
        var uDataSize = data.getShort();
        var vDataSize = hdrSize > 7 ? data.getShort() : sliceSize - uDataSize - yDataSize - hdrSize;
        var y = new Int32Array(sliceMbCount << 8);
        this.decodeOnePlane(ProresDecoder.bitstream(data, yDataSize), sliceMbCount << 2, y, ProresDecoder.scaleMat(qMatLuma, qScale), scan, mbX, mbY, 0);
        var chromaBlkCount = (sliceMbCount << chromaType) >> 1;
        var u = new Int32Array(chromaBlkCount << 6);
        this.decodeOnePlane(ProresDecoder.bitstream(data, uDataSize), chromaBlkCount, u, ProresDecoder.scaleMat(qMatChroma, qScale), scan, mbX, mbY, 1);
        var v = new Int32Array(chromaBlkCount << 6);
        this.decodeOnePlane(ProresDecoder.bitstream(data, vDataSize), chromaBlkCount, v, ProresDecoder.scaleMat(qMatChroma, qScale), scan, mbX, mbY, 2);
        this.putSlice(result, lumaStride, mbX, mbY, y, u, v, pictureType == 0 ? 0 : 1, pictureType == 2 ? 1 : 0, chromaType, sliceMbCount);
    };
    constructor.scaleMat = function(qMatLuma, qScale) {
        var res = new Int32Array(qMatLuma.length);
        for (var i = 0; i < qMatLuma.length; i++) 
            res[i] = qMatLuma[i] * qScale;
        return res;
    };
    constructor.bitstream = function(data, dataSize) {
        return BitReader.createBitReader(NIOUtils.read(data, dataSize));
    };
    prototype.clipTo8Bit = function(val, min, max) {
        return ((((val < min ? min : (val > max ? max : val)) >> 2) - 128) << 24 >> 24);
    };
    constructor.clip = function(val, min, max) {
        return val < min ? min : (val > max ? max : val);
    };
    prototype.putSlice = function(result, lumaStride, mbX, mbY, y, u, v, dist, shift, chromaType, sliceMbCount) {
        var chromaStride = lumaStride >> 1;
        this.putLuma(result[0], shift * lumaStride, lumaStride << dist, mbX, mbY, y, sliceMbCount, dist, shift);
        if (chromaType == 2) {
            this.putChroma(result[1], shift * chromaStride, chromaStride << dist, mbX, mbY, u, sliceMbCount, dist, shift);
            this.putChroma(result[2], shift * chromaStride, chromaStride << dist, mbX, mbY, v, sliceMbCount, dist, shift);
        } else {
            this.putLuma(result[1], shift * lumaStride, lumaStride << dist, mbX, mbY, u, sliceMbCount, dist, shift);
            this.putLuma(result[2], shift * lumaStride, lumaStride << dist, mbX, mbY, v, sliceMbCount, dist, shift);
        }
    };
    prototype.putLuma = function(y, off, stride, mbX, mbY, luma, mbPerSlice, dist, shift) {
        off += (mbX << 4) + (mbY << 4) * stride;
        for (var k = 0; k < mbPerSlice; k++) {
            this.putBlock(y, off, stride, luma, k << 8, dist, shift);
            this.putBlock(y, off + 8, stride, luma, (k << 8) + 64, dist, shift);
            this.putBlock(y, off + 8 * stride, stride, luma, (k << 8) + 128, dist, shift);
            this.putBlock(y, off + 8 * stride + 8, stride, luma, (k << 8) + 192, dist, shift);
            off += 16;
        }
    };
    prototype.putChroma = function(y, off, stride, mbX, mbY, chroma, mbPerSlice, dist, shift) {
        off += (mbX << 3) + (mbY << 4) * stride;
        for (var k = 0; k < mbPerSlice; k++) {
            this.putBlock(y, off, stride, chroma, k << 7, dist, shift);
            this.putBlock(y, off + 8 * stride, stride, chroma, (k << 7) + 64, dist, shift);
            off += 8;
        }
    };
    prototype.putBlock = function(square, sqOff, sqStride, flat, flOff, dist, shift) {
        for (var i = 0; i < 8; i++) {
            for (var j = 0; j < 8; j++) 
                square[j + sqOff] = this.clipTo8Bit(flat[j + flOff], 4, 1019);
            sqOff += sqStride;
            flOff += 8;
        }
    };
    constructor.hasQMatChroma = function(flags2) {
        return (flags2 & 1) != 0;
    };
    constructor.readQMat = function(inp, qMatLuma, scan) {
        var b = new Int8Array(64);
        inp.getBuf(b);
        for (var i = 0; i < 64; i++) {
            qMatLuma[i] = b[scan[i]] & 255;
        }
    };
    constructor.hasQMatLuma = function(flags2) {
        return (flags2 & 2) != 0;
    };
    prototype.isProgressive = function(data) {
        return (((data.getAt(20) & 255) >> 2) & 3) == 0;
    };
    prototype.probe = function(data) {
        if (data.getAt(4) == 'i' && data.getAt(5) == 'c' && data.getAt(6) == 'p' && data.getAt(7) == 'f') 
            return 100;
        return 0;
    };
}, {table: "Int32Array", mask: "Int32Array", byteBuffer: "Array"}, {});
var MBlockDecoderUtils = function() {};
MBlockDecoderUtils = stjs.extend(MBlockDecoderUtils, null, [], function(constructor, prototype) {
    constructor.debug = false;
    constructor.NULL_VECTOR = new Int32Array([0, 0, -1]);
    constructor.debugPrint = function(_arguments) {
        if (MBlockDecoderUtils.debug && arguments.length > 0) {
            if (arguments.length == 1) {
                jcodec.Logger.debug("" + arguments[0]);
            } else {
                var fmt = arguments[0];
                ArrayUtil.shiftLeft1(arguments);
                jcodec.Logger.debug(String.format(fmt, arguments));
            }
        }
    };
    constructor.collectPredictors = function(sharedState, outMB, mbX) {
        sharedState.topLeft[0][0] = sharedState.topLine[0][(mbX << 4) + 15];
        sharedState.topLeft[0][1] = outMB.getPlaneData(0)[63];
        sharedState.topLeft[0][2] = outMB.getPlaneData(0)[127];
        sharedState.topLeft[0][3] = outMB.getPlaneData(0)[191];
        System.arraycopy(outMB.getPlaneData(0), 240, sharedState.topLine[0], mbX << 4, 16);
        MBlockDecoderUtils.copyCol(outMB.getPlaneData(0), 16, 15, 16, sharedState.leftRow[0]);
        MBlockDecoderUtils.collectChromaPredictors(sharedState, outMB, mbX);
    };
    constructor.collectChromaPredictors = function(sharedState, outMB, mbX) {
        sharedState.topLeft[1][0] = sharedState.topLine[1][(mbX << 3) + 7];
        sharedState.topLeft[2][0] = sharedState.topLine[2][(mbX << 3) + 7];
        System.arraycopy(outMB.getPlaneData(1), 56, sharedState.topLine[1], mbX << 3, 8);
        System.arraycopy(outMB.getPlaneData(2), 56, sharedState.topLine[2], mbX << 3, 8);
        MBlockDecoderUtils.copyCol(outMB.getPlaneData(1), 8, 7, 8, sharedState.leftRow[1]);
        MBlockDecoderUtils.copyCol(outMB.getPlaneData(2), 8, 7, 8, sharedState.leftRow[2]);
    };
    constructor.copyCol = function(planeData, n, off, stride, out) {
        for (var i = 0; i < n; i++ , off += stride) {
            out[i] = planeData[off];
        }
    };
    constructor.saveMvsIntra = function(di, mbX, mbY) {
        for (var j = 0, blkOffY = mbY << 2, blkInd = 0; j < 4; j++ , blkOffY++) {
            for (var i = 0, blkOffX = mbX << 2; i < 4; i++ , blkOffX++ , blkInd++) {
                di.mvs[0][blkOffY][blkOffX] = MBlockDecoderUtils.NULL_VECTOR;
                di.mvs[1][blkOffY][blkOffX] = MBlockDecoderUtils.NULL_VECTOR;
            }
        }
    };
    constructor.mergeResidual = function(mb, residual, blockLUT, posLUT) {
        for (var comp = 0; comp < 3; comp++) {
            var to = mb.getPlaneData(comp);
            for (var i = 0; i < to.length; i++) {
                to[i] = (MathUtil.clip(to[i] + residual[comp][blockLUT[comp][i]][posLUT[comp][i]], -128, 127) << 24 >> 24);
            }
        }
    };
    constructor.saveVect = function(mv, from, to, x, y, r) {
        for (var i = from; i < to; i++) {
            mv[i][0] = x;
            mv[i][1] = y;
            mv[i][2] = r;
        }
    };
    constructor.calcMVPredictionMedian = function(a, b, c, d, aAvb, bAvb, cAvb, dAvb, ref, comp) {
        if (!cAvb) {
            c = d;
            cAvb = dAvb;
        }
        if (aAvb && !bAvb && !cAvb) {
            b = c = a;
            bAvb = cAvb = aAvb;
        }
        a = aAvb ? a : MBlockDecoderUtils.NULL_VECTOR;
        b = bAvb ? b : MBlockDecoderUtils.NULL_VECTOR;
        c = cAvb ? c : MBlockDecoderUtils.NULL_VECTOR;
        if (a[2] == ref && b[2] != ref && c[2] != ref) 
            return a[comp];
         else if (b[2] == ref && a[2] != ref && c[2] != ref) 
            return b[comp];
         else if (c[2] == ref && a[2] != ref && b[2] != ref) 
            return c[comp];
        return a[comp] + b[comp] + c[comp] - MBlockDecoderUtils.min(a[comp], b[comp], c[comp]) - MBlockDecoderUtils.max(a[comp], b[comp], c[comp]);
    };
    constructor.max = function(x, x2, x3) {
        return x > x2 ? (x > x3 ? x : x3) : (x2 > x3 ? x2 : x3);
    };
    constructor.min = function(x, x2, x3) {
        return x < x2 ? (x < x3 ? x : x3) : (x2 < x3 ? x2 : x3);
    };
    constructor.copyVect = function(to, from) {
        to[0] = from[0];
        to[1] = from[1];
        to[2] = from[2];
    };
    constructor.saveMvs = function(di, x, mbX, mbY) {
        for (var j = 0, blkOffY = mbY << 2, blkInd = 0; j < 4; j++ , blkOffY++) {
            for (var i = 0, blkOffX = mbX << 2; i < 4; i++ , blkOffX++ , blkInd++) {
                di.mvs[0][blkOffY][blkOffX] = x[0][blkInd];
                di.mvs[1][blkOffY][blkOffX] = x[1][blkInd];
            }
        }
    };
    constructor.savePrediction8x8 = function(sharedState, mbX, x, list) {
        MBlockDecoderUtils.copyVect(sharedState.mvTopLeft[list], sharedState.mvTop[list][(mbX << 2) + 3]);
        MBlockDecoderUtils.copyVect(sharedState.mvLeft[list][0], x[3]);
        MBlockDecoderUtils.copyVect(sharedState.mvLeft[list][1], x[7]);
        MBlockDecoderUtils.copyVect(sharedState.mvLeft[list][2], x[11]);
        MBlockDecoderUtils.copyVect(sharedState.mvLeft[list][3], x[15]);
        MBlockDecoderUtils.copyVect(sharedState.mvTop[list][mbX << 2], x[12]);
        MBlockDecoderUtils.copyVect(sharedState.mvTop[list][(mbX << 2) + 1], x[13]);
        MBlockDecoderUtils.copyVect(sharedState.mvTop[list][(mbX << 2) + 2], x[14]);
        MBlockDecoderUtils.copyVect(sharedState.mvTop[list][(mbX << 2) + 3], x[15]);
    };
    constructor.saveVectIntra = function(sharedState, mbX) {
        var xx = mbX << 2;
        MBlockDecoderUtils.copyVect(sharedState.mvTopLeft[0], sharedState.mvTop[0][xx + 3]);
        MBlockDecoderUtils.copyVect(sharedState.mvTopLeft[1], sharedState.mvTop[1][xx + 3]);
        MBlockDecoderUtils.saveVect(sharedState.mvTop[0], xx, xx + 4, 0, 0, -1);
        MBlockDecoderUtils.saveVect(sharedState.mvLeft[0], 0, 4, 0, 0, -1);
        MBlockDecoderUtils.saveVect(sharedState.mvTop[1], xx, xx + 4, 0, 0, -1);
        MBlockDecoderUtils.saveVect(sharedState.mvLeft[1], 0, 4, 0, 0, -1);
    };
}, {NULL_VECTOR: "Int32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  An MP4 file structure (atom)
 *  
 *  @author The JCodec project
 *  
 */
var Header = function(fourcc) {
    this.fourcc = fourcc;
};
Header = stjs.extend(Header, null, [], function(constructor, prototype) {
    constructor.MAX_UNSIGNED_INT = 4294967296;
    prototype.fourcc = null;
    prototype.size = 0;
    prototype.lng = false;
    constructor.createHeader = function(fourcc, size) {
        var header = new Header(fourcc);
        header.size = size;
        return header;
    };
    constructor.newHeader = function(fourcc, size, lng) {
        var header = new Header(fourcc);
        header.size = size;
        header.lng = lng;
        return header;
    };
    constructor.read = function(input) {
        var size = 0;
         while (input.remaining() >= 4 && (size = ((stjs.trunc(input.getInt())) & 4294967295)) == 0)
            ;
        if (input.remaining() < 4 || size < 8 && size != 1) {
            jcodec.Logger.error("Broken atom of size " + size);
            return null;
        }
        var fourcc = NIOUtils.readString(input, 4);
        var lng = false;
        if (size == 1) {
            if (input.remaining() >= 8) {
                lng = true;
                size = input.getLong();
            } else {
                jcodec.Logger.error("Broken atom of size " + size);
                return null;
            }
        }
        return Header.newHeader(fourcc, size, lng);
    };
    prototype.skip = function(di) {
        StringReader.sureSkip(di, this.size - this.headerSize());
    };
    prototype.headerSize = function() {
        return this.lng || (this.size > Header.MAX_UNSIGNED_INT) ? 16 : 8;
    };
    prototype.readContents = function(di) {
        var baos = new ByteArrayOutputStream();
        for (var i = 0; i < this.size - this.headerSize(); i++) {
            baos.write(di.read());
        }
        return baos.toByteArray();
    };
    prototype.getFourcc = function() {
        return this.fourcc;
    };
    prototype.getBodySize = function() {
        return this.size - this.headerSize();
    };
    prototype.setBodySize = function(length) {
        this.size = length + this.headerSize();
    };
    prototype.write = function(out) {
        if (this.size > Header.MAX_UNSIGNED_INT) 
            out.putInt(1);
         else 
            out.putInt(((this.size) | 0));
        out.putArr(JCodecUtil2.asciiString(this.fourcc));
        if (this.size > Header.MAX_UNSIGNED_INT) {
            out.putLong(this.size);
        }
    };
    prototype.writeChannel = function(output) {
        var bb = ByteBuffer.allocate(16);
        this.write(bb);
        bb.flip();
        output.write(bb);
    };
    prototype.getSize = function() {
        return this.size;
    };
    prototype.hashCode = function() {
        var prime = 31;
        var result = 1;
        result = prime * result + ((this.fourcc == null) ? 0 : this.fourcc.hashCode());
        return result;
    };
    prototype.equals = function(obj) {
        if (this == obj) 
            return true;
        if (obj == null) 
            return false;
        if (this.getClass() != obj.getClass()) 
            return false;
        var other = obj;
        if (this.fourcc == null) {
            if (other.fourcc != null) 
                return false;
        } else if (!this.fourcc.equals(other.fourcc)) 
            return false;
        return true;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Downmixes PCM audio data into 16 bit stereo track
 *  
 *  @author The JCodec project
 *  
 */
var DownmixHelper = function(se, nSamples, solo) {
    this.fltBuf = new ThreadLocal();
    this.nSamples = nSamples;
    this.se = se;
    var matrixBuilder = new ArrayList();
    var countsBuilder = new ArrayList();
    var channelsBuilder = new ArrayList();
    for (var tr = 0; tr < se.length; tr++) {
        var channels = se[tr].getChannelLabels();
        var tmp = IntArrayList.createIntArrayList();
        for (var ch = 0; ch < channels.length; ch++) {
            if (solo != null && !solo[tr][ch]) 
                continue;
            tmp.add(ch);
            var label = channels[ch];
            if (label == Label.Left || label == Label.LeftTotal || label == Label.LeftCenter) {
                matrixBuilder.add(new Float32Array([1.0, 0.0]));
                countsBuilder.add(new Int32Array([1, 0]));
            } else if (label == Label.LeftSurround || label == Label.RearSurroundLeft) {
                matrixBuilder.add(new Float32Array([0.7, 0.0]));
                countsBuilder.add(new Int32Array([1, 0]));
            } else if (label == Label.Right || label == Label.RightTotal || label == Label.RightCenter) {
                matrixBuilder.add(new Float32Array([0.0, 1.0]));
                countsBuilder.add(new Int32Array([0, 1]));
            } else if (label == Label.RightSurround || label == Label.RearSurroundRight) {
                matrixBuilder.add(new Float32Array([0.0, 0.7]));
                countsBuilder.add(new Int32Array([0, 1]));
            } else if (label == Label.Mono || label == Label.LFEScreen || label == Label.Center || label == Label.LFE2 || label == Label.Discrete) {
                matrixBuilder.add(new Float32Array([0.7, 0.7]));
                countsBuilder.add(new Int32Array([1, 1]));
            } else if (label == Label.Unused) {} else {
                if ((label.getVal() >>> 16) == 1) {
                    matrixBuilder.add(new Float32Array([0.7, 0.7]));
                    countsBuilder.add(new Int32Array([1, 1]));
                    jcodec.Logger.info("Discrete" + (label.getVal() & 65535));
                }
            }
        }
        channelsBuilder.add(tmp.toArray());
    }
    this.matrix = matrixBuilder.toArray(Array(0));
    this.counts = countsBuilder.toArray(Array(0));
    this.channels = channelsBuilder.toArray(Array(0));
};
DownmixHelper = stjs.extend(DownmixHelper, null, [], function(constructor, prototype) {
    prototype.nSamples = 0;
    prototype.fltBuf = null;
    prototype.matrix = null;
    prototype.counts = null;
    prototype.channels = null;
    prototype.se = null;
    prototype.downmix = function(data, out) {
        out.order(ByteOrder.LITTLE_ENDIAN);
        if (this.matrix.length == 0) {
            out.setLimit(this.nSamples << 2);
            return;
        }
        var flt = this.fltBuf.get();
        if (flt == null) {
            flt = Array.apply(null, Array(this.matrix.length)).map(function() {
                return new Float32Array(this.nSamples);
            });
            this.fltBuf.set(flt);
        }
        for (var tr = 0, i = 0; tr < this.se.length; tr++) {
            for (var ch = 0; ch < this.channels[tr].length; ch++ , i++) {
                this.toFloat(flt[i], this.se[tr], data[tr], this.channels[tr][ch], this.se[tr].getChannelCount());
            }
        }
        for (var s = 0; s < this.nSamples; s++) {
            var lcount = 0, rcount = 0;
            var lSum = 0, lMul = 1, rSum = 0, rMul = 1;
            for (var inp = 0; inp < this.matrix.length; inp++) {
                var sample = flt[inp][s];
                var l = this.matrix[inp][0] * sample;
                var r = this.matrix[inp][1] * sample;
                lSum += l;
                lMul *= l;
                rSum += r;
                rMul *= r;
                lcount += this.counts[inp][0];
                rcount += this.counts[inp][1];
            }
            var outLeft = lcount > 1 ? DownmixHelper.clamp1f(lSum - lMul) : lSum;
            var outRight = rcount > 1 ? DownmixHelper.clamp1f(rSum - rMul) : rSum;
            var left = stjs.trunc((outLeft * 32767.0));
            var right = stjs.trunc((outRight * 32767.0));
            out.putShort(left);
            out.putShort(right);
        }
        out.flip();
    };
    prototype.toFloat = function(fSamples, se, bb, ch, nCh) {
        var ba;
        var off, len;
        if (bb.hasArray()) {
            ba = bb.array();
            off = bb.arrayOffset() + bb.position();
            len = bb.remaining();
        } else {
            ba = NIOUtils.toArray(bb);
            off = 0;
            len = ba.length;
        }
        var maxSamples;
        if (se.getSampleSize() == 3) {
            var step = nCh * 3;
            maxSamples = Math.min(this.nSamples, stjs.trunc(len / step));
            if (se.getEndian() == ByteOrder.BIG_ENDIAN) {
                for (var s = 0, bi = off + ch * 3; s < maxSamples; s++ , bi += step) {
                    fSamples[s] = DownmixHelper.nextSample24BE(ba, bi);
                }
            } else {
                for (var s = 0, bi = off + ch * 3; s < maxSamples; s++ , bi += step) {
                    fSamples[s] = DownmixHelper.nextSample24LE(ba, bi);
                }
            }
        } else {
            var step = nCh * 2;
            maxSamples = Math.min(this.nSamples, stjs.trunc(len / step));
            if (se.getEndian() == ByteOrder.BIG_ENDIAN) {
                for (var s = 0, bi = off + ch * 2; s < maxSamples; s++ , bi += step) {
                    fSamples[s] = DownmixHelper.nextSample16BE(ba, bi);
                }
            } else {
                for (var s = 0, bi = off + ch * 2; s < maxSamples; s++ , bi += step) {
                    fSamples[s] = DownmixHelper.nextSample16LE(ba, bi);
                }
            }
        }
        for (var s = maxSamples; s < this.nSamples; s++) 
            fSamples[s] = 0;
    };
    constructor.clamp1f = function(f) {
        if (f > 1.0) 
            return 1.0;
        if (f < -1.0) 
            return -1.0;
        return f;
    };
    constructor.rev = 1.0 / 2147483647;
    constructor.nextSample24BE = function(ba, bi) {
        return DownmixHelper.rev * (((ba[bi] & 255) << 24) | ((ba[bi + 1] & 255) << 16) | ((ba[bi + 2] & 255) << 8));
    };
    constructor.nextSample24LE = function(ba, bi) {
        return DownmixHelper.rev * (((ba[bi] & 255) << 8) | ((ba[bi + 1] & 255) << 16) | ((ba[bi + 2] & 255) << 24));
    };
    constructor.nextSample16BE = function(ba, bi) {
        return DownmixHelper.rev * (((ba[bi] & 255) << 24) | ((ba[bi + 1] & 255) << 16));
    };
    constructor.nextSample16LE = function(ba, bi) {
        return DownmixHelper.rev * (((ba[bi] & 255) << 16) | ((ba[bi + 1] & 255) << 24));
    };
}, {fltBuf: {name: "ThreadLocal", arguments: ["Array"]}, matrix: "Array", counts: "Array", channels: "Array", se: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  FLV ( Flash Media Video ) demuxer
 *  
 *  @author Stan Vitvitskyy
 *  
 */
var FLVReader = function(ch) {
    this.ch = ch;
    this.readBuf = ByteBuffer.allocate(FLVReader.READ_BUFFER_SIZE);
    this.readBuf.order(ByteOrder.BIG_ENDIAN);
    this.initialRead(ch);
    if (!FLVReader.readHeader(this.readBuf)) {
        this.readBuf.setPosition(0);
        if (!this.repositionFile()) 
             throw new RuntimeException("Invalid FLV file");
         else {
            jcodec.Logger.warn(String.format("Parsing a corrupt FLV file, first tag found at %d. %s", this.readBuf.position(), this.readBuf.position() == 0 ? "Did you forget the FLV 9-byte header?" : ""));
        }
    }
};
FLVReader = stjs.extend(FLVReader, null, [], function(constructor, prototype) {
    constructor.REPOSITION_BUFFER_READS = 10;
    constructor.TAG_HEADER_SIZE = 15;
    constructor.READ_BUFFER_SIZE = 1 << 10;
    prototype.frameNo = 0;
    prototype.readBuf = null;
    prototype.ch = null;
    prototype.eof = false;
    constructor.platformBigEndian = ByteBuffer.allocate(0).getOrder() == ByteOrder.BIG_ENDIAN;
    constructor.audioCodecMapping = [Codec.PCM, Codec.ADPCM, Codec.MP3, Codec.PCM, Codec.NELLYMOSER, Codec.NELLYMOSER, Codec.NELLYMOSER, Codec.G711, Codec.G711, null, Codec.AAC, Codec.SPEEX, Codec.MP3, null];
    constructor.videoCodecMapping = [null, null, Codec.SORENSON, Codec.FLASH_SCREEN_VIDEO, Codec.VP6, Codec.VP6, Codec.FLASH_SCREEN_V2, Codec.H264];
    constructor.sampleRates = new Int32Array([5500, 11000, 22000, 44100]);
    prototype.initialRead = function(ch) {
        this.readBuf.clear();
        if (ch.read(this.readBuf) == -1) 
            this.eof = true;
        this.readBuf.flip();
    };
    prototype.readNextPacket = function() {
        if (this.eof) 
            return null;
        var pkt = this.parsePacket(this.readBuf);
        if (pkt == null && !this.eof) {
            FLVReader.moveRemainderToTheStart(this.readBuf);
            if (this.ch.read(this.readBuf) == -1) {
                this.eof = true;
                return null;
            }
             while (MathUtil.log2(this.readBuf.capacity()) <= 22){
                this.readBuf.flip();
                pkt = this.parsePacket(this.readBuf);
                if (pkt != null || this.readBuf.position() > 0) 
                    break;
                var newBuf = ByteBuffer.allocate(this.readBuf.capacity() << 2);
                newBuf.putBuf(this.readBuf);
                this.readBuf = newBuf;
                if (this.ch.read(this.readBuf) == -1) {
                    this.eof = true;
                    return null;
                }
            }
        }
        return pkt;
    };
    prototype.readPrevPacket = function() {
        var startOfLastPacket = this.readBuf.getInt();
        this.readBuf.setPosition(this.readBuf.position() - 4);
        if (this.readBuf.position() > startOfLastPacket) {
            this.readBuf.setPosition(this.readBuf.position() - startOfLastPacket);
            return this.parsePacket(this.readBuf);
        } else {
            var oldPos = this.ch.position() - this.readBuf.remaining();
            if (oldPos <= 9) {
                return null;
            }
            var newPos = Math.max(0, oldPos - stjs.trunc(this.readBuf.capacity() / 2));
            this.ch.setPosition(newPos);
            this.readBuf.clear();
            this.ch.read(this.readBuf);
            this.readBuf.flip();
            this.readBuf.setPosition((((oldPos - newPos)) | 0));
            return this.readPrevPacket();
        }
    };
    constructor.moveRemainderToTheStart = function(readBuf) {
        var rem = readBuf.remaining();
        for (var i = 0; i < rem; i++) {
            readBuf.putAt(i, readBuf.get());
        }
        readBuf.clear();
        readBuf.setPosition(rem);
    };
    prototype.parsePacket = function(readBuf) {
        for (; ; ) {
            if (readBuf.remaining() < FLVReader.TAG_HEADER_SIZE) {
                return null;
            }
            var pos = readBuf.position();
            var packetPos = this.ch.position() - readBuf.remaining();
            var prevPacketSize = readBuf.getInt();
            var packetType = readBuf.get() & 255;
            var payloadSize = ((readBuf.getShort() & 65535) << 8) | (readBuf.get() & 255);
            var timestamp = ((readBuf.getShort() & 65535) << 8) | (readBuf.get() & 255) | ((readBuf.get() & 255) << 24);
            var streamId = ((readBuf.getShort() & 65535) << 8) | (readBuf.get() & 255);
            if (readBuf.remaining() >= payloadSize + 4) {
                var thisPacketSize = readBuf.getIntAt(readBuf.position() + payloadSize);
                if (thisPacketSize != payloadSize + 11) {
                    readBuf.setPosition(readBuf.position() - FLVReader.TAG_HEADER_SIZE);
                    if (!this.repositionFile()) {
                        jcodec.Logger.error(String.format("Corrupt FLV stream at %d, failed to reposition!", packetPos));
                        this.ch.setPosition(this.ch.size());
                        this.eof = true;
                        return null;
                    }
                    jcodec.Logger.warn(String.format("Corrupt FLV stream at %d, repositioned to %d.", packetPos, this.ch.position() - readBuf.remaining()));
                    continue;
                }
            }
            if (readBuf.remaining() < payloadSize) {
                readBuf.setPosition(pos);
                return null;
            }
            if (packetType != 8 && packetType != 9 && packetType != 18) {
                NIOUtils.skip(readBuf, payloadSize);
                continue;
            }
            var payload = NIOUtils.clone(NIOUtils.read(readBuf, payloadSize));
            var type;
            var tagHeader;
            if (packetType == 8) {
                type = FLVTag.Type.AUDIO;
                tagHeader = FLVReader.parseAudioTagHeader(payload.duplicate());
            } else if (packetType == 9) {
                type = FLVTag.Type.VIDEO;
                tagHeader = FLVReader.parseVideoTagHeader(payload.duplicate());
            } else if (packetType == 18) {
                type = FLVTag.Type.SCRIPT;
                tagHeader = null;
            } else {
                System.out.println("NON AV packet");
                continue;
            }
            var keyFrame = packetType == 8 || packetType == 9 && (tagHeader).getFrameType() == 1;
            return new FLVTag(type, packetPos, tagHeader, timestamp, payload, keyFrame, this.frameNo++, streamId, prevPacketSize);
        }
    };
    constructor.readHeader = function(readBuf) {
        if (readBuf.remaining() < 9 || readBuf.get() != 'F' || readBuf.get() != 'L' || readBuf.get() != 'V' || readBuf.get() != 1 || (readBuf.get() & 5) == 0 || readBuf.getInt() != 9) {
            return false;
        }
        return true;
    };
    constructor.parseMetadata = function(bb) {
        if ("onMetaData".equals(FLVReader.readAMFData(bb, -1))) 
            return new FLVMetadata(FLVReader.readAMFData(bb, -1));
        return null;
    };
    constructor.readAMFData = function(input, type) {
        if (type == -1) {
            type = input.get() & 255;
        }
        switch (type) {
            case 0:
                return input.getDouble();
            case 1:
                return input.get() == 1;
            case 2:
                return FLVReader.readAMFString(input);
            case 3:
                return FLVReader.readAMFObject(input);
            case 8:
                return FLVReader.readAMFEcmaArray(input);
            case 10:
                return FLVReader.readAMFStrictArray(input);
            case 11:
                var date = new jsutil.Date(stjs.trunc(input.getDouble()));
                input.getShort();
                return date;
            case 13:
                return "UNDEFINED";
            default:
                return null;
        }
    };
    constructor.readAMFStrictArray = function(input) {
        var count = input.getInt();
        var result = Array(count);
        for (var i = 0; i < count; i++) {
            result[i] = FLVReader.readAMFData(input, -1);
        }
        return result;
    };
    constructor.readAMFString = function(input) {
        var size = input.getShort() & 65535;
        return Platform.stringFromCharset(NIOUtils.toArray(NIOUtils.read(input, size)), Charset.forName("UTF-8"));
    };
    constructor.readAMFObject = function(input) {
        var array = new HashMap();
         while (true){
            var key = FLVReader.readAMFString(input);
            var dataType = input.get() & 255;
            if (dataType == 9) {
                break;
            }
            array.put(key, FLVReader.readAMFData(input, dataType));
        }
        return array;
    };
    constructor.readAMFEcmaArray = function(input) {
        var size = input.getInt();
        var array = new HashMap();
        for (var i = 0; i < size; i++) {
            var key = FLVReader.readAMFString(input);
            var dataType = input.get() & 255;
            array.put(key, FLVReader.readAMFData(input, dataType));
        }
        return array;
    };
    constructor.parseVideoTagHeader = function(dup) {
        var b0 = dup.get();
        var frameType = (b0 & 255) >> 4;
        var codecId = (b0 & 15);
        var codec = FLVReader.videoCodecMapping[codecId];
        if (codecId == 7) {
            var avcPacketType = dup.get();
            var compOffset = (dup.getShort() << 8) | (dup.get() & 255);
            return new FLVTag.AvcVideoTagHeader(codec, frameType, avcPacketType, compOffset);
        }
        return new FLVTag.VideoTagHeader(codec, frameType);
    };
    constructor.parseAudioTagHeader = function(dup) {
        var b = dup.get();
        var codecId = (b & 255) >> 4;
        var sampleRate = FLVReader.sampleRates[(b >> 2) & 3];
        if (codecId == 4 || codecId == 11) 
            sampleRate = 16000;
        if (codecId == 5 || codecId == 14) 
            sampleRate = 8000;
        var sampleSizeInBits = (b & 2) == 0 ? 8 : 16;
        var signed = codecId != 3 && codecId != 0 || sampleSizeInBits == 16;
        var channelCount = 1 + (b & 1);
        if (codecId == 11) 
            channelCount = 1;
        var audioFormat = new AudioFormat(sampleRate, sampleSizeInBits, channelCount, signed, codecId == 3 ? false : FLVReader.platformBigEndian);
        var codec = FLVReader.audioCodecMapping[codecId];
        if (codecId == 10) {
            var packetType = dup.get();
            return new FLVTag.AacAudioTagHeader(codec, audioFormat, packetType);
        }
        return new FLVTag.AudioTagHeader(codec, audioFormat);
    };
    constructor.probe = function(buf) {
        try {
            FLVReader.readHeader(buf);
            return 100;
        }catch (e) {
            return 0;
        }
    };
    prototype.reset = function() {
        this.initialRead(this.ch);
    };
    prototype.reposition = function() {
        this.reset();
        if (!FLVReader.positionAtPacket(this.readBuf)) {
             throw new RuntimeException("Could not find at FLV tag start");
        }
    };
    constructor.positionAtPacket = function(readBuf) {
        var dup = readBuf.duplicate();
        var payloadSize = 0;
        NIOUtils.skip(dup, 5);
         while (dup.hasRemaining()){
            payloadSize = ((payloadSize & 65535) << 8) | (dup.get() & 255);
            var pointerPos = dup.position() + 7 + payloadSize;
            if (dup.position() >= 8 && pointerPos < dup.limit() - 4 && dup.getIntAt(pointerPos) - payloadSize == 11) {
                readBuf.setPosition(dup.position() - 8);
                return true;
            }
        }
        return false;
    };
    /**
     *  Searching for the next tag in a file after corrupt segment
     *  
     *  @return
     *  @throws IOException
     */
    prototype.repositionFile = function() {
        var payloadSize = 0;
        for (var i = 0; i < FLVReader.REPOSITION_BUFFER_READS; i++) {
             while (this.readBuf.hasRemaining()){
                payloadSize = ((payloadSize & 65535) << 8) | (this.readBuf.get() & 255);
                var pointerPos = this.readBuf.position() + 7 + payloadSize;
                if (this.readBuf.position() >= 8 && pointerPos < this.readBuf.limit() - 4 && this.readBuf.getIntAt(pointerPos) - payloadSize == 11) {
                    this.readBuf.setPosition(this.readBuf.position() - 8);
                    return true;
                }
            }
            this.initialRead(this.ch);
            if (!this.readBuf.hasRemaining()) 
                break;
        }
        return false;
    };
}, {readBuf: "ByteBuffer", ch: "SeekableByteChannel", audioCodecMapping: "Array", videoCodecMapping: "Array", sampleRates: "Int32Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  @author in-somnia
 */
var ICStream = function(frameLength) {
    this.frameLength = frameLength;
    this.info = new ICSInfo(frameLength);
    this.sfbCB = new Int32Array(SyntaxConstants.MAX_SECTIONS);
    this.sectEnd = new Int32Array(SyntaxConstants.MAX_SECTIONS);
    this.data = new Float32Array(frameLength);
    this.scaleFactors = new Float32Array(SyntaxConstants.MAX_SECTIONS);
};
ICStream = stjs.extend(ICStream, null, [SyntaxConstants, HCB, ScaleFactorTable, IQTable], function(constructor, prototype) {
    constructor.SF_DELTA = 60;
    constructor.SF_OFFSET = 200;
    constructor.randomState = 523124044;
    prototype.frameLength = 0;
    prototype.info = null;
    prototype.sfbCB = null;
    prototype.sectEnd = null;
    prototype.data = null;
    prototype.scaleFactors = null;
    prototype.globalGain = 0;
    prototype.pulseDataPresent = false;
    prototype.tnsDataPresent = false;
    prototype.gainControlPresent = false;
    prototype.tns = null;
    prototype.gainControl = null;
    prototype.pulseOffset = null;
    prototype.pulseAmp = null;
    prototype.pulseCount = 0;
    prototype.pulseStartSWB = 0;
    prototype.noiseUsed = false;
    prototype.reorderedSpectralDataLen = 0;
    prototype.longestCodewordLen = 0;
    prototype.rvlc = null;
    prototype.decode = function(_in, commonWindow, conf) {
        if (conf.isScalefactorResilienceUsed() && this.rvlc == null) 
            this.rvlc = new RVLC();
        var er = conf.getProfile().isErrorResilientProfile();
        this.globalGain = _in.readBits(8);
        if (!commonWindow) 
            this.info.decode(_in, conf, commonWindow);
        this.decodeSectionData(_in, conf.isSectionDataResilienceUsed());
        this.decodeScaleFactors(_in);
        this.pulseDataPresent = _in.readBool();
        if (this.pulseDataPresent) {
            if (this.info.isEightShortFrame()) 
                 throw new AACException("pulse data not allowed for short frames");
            SyntaxConstants.LOGGER.log(Level.FINE, "PULSE");
            this.decodePulseData(_in);
        }
        this.tnsDataPresent = _in.readBool();
        if (this.tnsDataPresent && !er) {
            if (this.tns == null) 
                this.tns = new TNS();
            this.tns.decode(_in, this.info);
        }
        this.gainControlPresent = _in.readBool();
        if (this.gainControlPresent) {
            if (this.gainControl == null) 
                this.gainControl = new GainControl(this.frameLength);
            SyntaxConstants.LOGGER.log(Level.FINE, "GAIN");
            this.gainControl.decode(_in, this.info.getWindowSequence());
        }
        if (conf.isSpectralDataResilienceUsed()) {
            var max = (conf.getChannelConfiguration() == ChannelConfiguration.CHANNEL_CONFIG_STEREO) ? 6144 : 12288;
            this.reorderedSpectralDataLen = Math.max(_in.readBits(14), max);
            this.longestCodewordLen = Math.max(_in.readBits(6), 49);
        } else 
            this.decodeSpectralData(_in);
    };
    prototype.decodeSectionData = function(_in, sectionDataResilienceUsed) {
        Arrays.fill(this.sfbCB, 0);
        Arrays.fill(this.sectEnd, 0);
        var bits = this.info.isEightShortFrame() ? 3 : 5;
        var escVal = (1 << bits) - 1;
        var windowGroupCount = this.info.getWindowGroupCount();
        var maxSFB = this.info.getMaxSFB();
        var end, cb, incr;
        var idx = 0;
        for (var g = 0; g < windowGroupCount; g++) {
            var k = 0;
             while (k < maxSFB){
                end = k;
                cb = _in.readBits(4);
                if (cb == 12) 
                     throw new AACException("invalid huffman codebook: 12");
                 while ((incr = _in.readBits(bits)) == escVal){
                    end += incr;
                }
                end += incr;
                if (end > maxSFB) 
                     throw new AACException("too many bands: " + end + ", allowed: " + maxSFB);
                for (; k < end; k++) {
                    this.sfbCB[idx] = cb;
                    this.sectEnd[idx++] = end;
                }
            }
        }
    };
    prototype.decodePulseData = function(_in) {
        this.pulseCount = _in.readBits(2) + 1;
        this.pulseStartSWB = _in.readBits(6);
        if (this.pulseStartSWB >= this.info.getSWBCount()) 
             throw new AACException("pulse SWB out of range: " + this.pulseStartSWB + " > " + this.info.getSWBCount());
        if (this.pulseOffset == null || this.pulseCount != this.pulseOffset.length) {
            this.pulseOffset = new Int32Array(this.pulseCount);
            this.pulseAmp = new Int32Array(this.pulseCount);
        }
        this.pulseOffset[0] = this.info.getSWBOffsets()[this.pulseStartSWB];
        this.pulseOffset[0] += _in.readBits(5);
        this.pulseAmp[0] = _in.readBits(4);
        for (var i = 1; i < this.pulseCount; i++) {
            this.pulseOffset[i] = _in.readBits(5) + this.pulseOffset[i - 1];
            if (this.pulseOffset[i] > 1023) 
                 throw new AACException("pulse offset out of range: " + this.pulseOffset[0]);
            this.pulseAmp[i] = _in.readBits(4);
        }
    };
    prototype.decodeScaleFactors = function(_in) {
        var windowGroups = this.info.getWindowGroupCount();
        var maxSFB = this.info.getMaxSFB();
        var offset = new Int32Array([this.globalGain, this.globalGain - 90, 0]);
        var tmp;
        var noiseFlag = true;
        var sfb, idx = 0;
        for (var g = 0; g < windowGroups; g++) {
            for (sfb = 0; sfb < maxSFB; ) {
                var end = this.sectEnd[idx];
                switch (this.sfbCB[idx]) {
                    case HCB.ZERO_HCB:
                        for (; sfb < end; sfb++ , idx++) {
                            this.scaleFactors[idx] = 0;
                        }
                        break;
                    case HCB.INTENSITY_HCB:
                    case HCB.INTENSITY_HCB2:
                        for (; sfb < end; sfb++ , idx++) {
                            offset[2] += Huffman.decodeScaleFactor(_in) - ICStream.SF_DELTA;
                            tmp = Math.min(Math.max(offset[2], -155), 100);
                            this.scaleFactors[idx] = ScaleFactorTable.SCALEFACTOR_TABLE[-tmp + ICStream.SF_OFFSET];
                        }
                        break;
                    case HCB.NOISE_HCB:
                        for (; sfb < end; sfb++ , idx++) {
                            if (noiseFlag) {
                                offset[1] += _in.readBits(9) - 256;
                                noiseFlag = false;
                            } else 
                                offset[1] += Huffman.decodeScaleFactor(_in) - ICStream.SF_DELTA;
                            tmp = Math.min(Math.max(offset[1], -100), 155);
                            this.scaleFactors[idx] = -ScaleFactorTable.SCALEFACTOR_TABLE[tmp + ICStream.SF_OFFSET];
                        }
                        break;
                    default:
                        for (; sfb < end; sfb++ , idx++) {
                            offset[0] += Huffman.decodeScaleFactor(_in) - ICStream.SF_DELTA;
                            if (offset[0] > 255) 
                                 throw new AACException("scalefactor out of range: " + offset[0]);
                            this.scaleFactors[idx] = ScaleFactorTable.SCALEFACTOR_TABLE[offset[0] - 100 + ICStream.SF_OFFSET];
                        }
                        break;
                }
            }
        }
    };
    prototype.decodeSpectralData = function(_in) {
        Arrays.fill(this.data, 0);
        var maxSFB = this.info.getMaxSFB();
        var windowGroups = this.info.getWindowGroupCount();
        var offsets = this.info.getSWBOffsets();
        var buf = new Int32Array(4);
        var sfb, j, k, w, hcb, off, width, num;
        var groupOff = 0, idx = 0;
        for (var g = 0; g < windowGroups; g++) {
            var groupLen = this.info.getWindowGroupLength(g);
            for (sfb = 0; sfb < maxSFB; sfb++ , idx++) {
                hcb = this.sfbCB[idx];
                off = groupOff + offsets[sfb];
                width = offsets[sfb + 1] - offsets[sfb];
                if (hcb == HCB.ZERO_HCB || hcb == HCB.INTENSITY_HCB || hcb == HCB.INTENSITY_HCB2) {
                    for (w = 0; w < groupLen; w++ , off += 128) {
                        Arrays.fill(this.data, off, off + width, 0);
                    }
                } else if (hcb == HCB.NOISE_HCB) {
                    for (w = 0; w < groupLen; w++ , off += 128) {
                        var energy = 0;
                        for (k = 0; k < width; k++) {
                            ICStream.randomState *= 1664525 + 1013904223;
                            this.data[off + k] = ICStream.randomState;
                            energy += this.data[off + k] * this.data[off + k];
                        }
                        var scale = (this.scaleFactors[idx] / Math.sqrt(energy));
                        for (k = 0; k < width; k++) {
                            this.data[off + k] *= scale;
                        }
                    }
                } else {
                    for (w = 0; w < groupLen; w++ , off += 128) {
                        num = (hcb >= HCB.FIRST_PAIR_HCB) ? 2 : 4;
                        for (k = 0; k < width; k += num) {
                            Huffman.decodeSpectralData(_in, hcb, buf, 0);
                            for (j = 0; j < num; j++) {
                                this.data[off + k + j] = (buf[j] > 0) ? IQTable.IQ_TABLE[buf[j]] : -IQTable.IQ_TABLE[-buf[j]];
                                this.data[off + k + j] *= this.scaleFactors[idx];
                            }
                        }
                    }
                }
            }
            groupOff += groupLen << 7;
        }
    };
    /**
     *  Does inverse quantization and applies the scale factors on the decoded
     *  data. After this the noiseless decoding is finished and the decoded data
     *  is returned.
     *  @return the inverse quantized and scaled data
     */
    prototype.getInvQuantData = function() {
        return this.data;
    };
    prototype.getInfo = function() {
        return this.info;
    };
    prototype.getSectEnd = function() {
        return this.sectEnd;
    };
    prototype.getSfbCB = function() {
        return this.sfbCB;
    };
    prototype.getScaleFactors = function() {
        return this.scaleFactors;
    };
    prototype.isTNSDataPresent = function() {
        return this.tnsDataPresent;
    };
    prototype.getTNS = function() {
        return this.tns;
    };
    prototype.getGlobalGain = function() {
        return this.globalGain;
    };
    prototype.isNoiseUsed = function() {
        return this.noiseUsed;
    };
    prototype.getLongestCodewordLength = function() {
        return this.longestCodewordLen;
    };
    prototype.getReorderedSpectralDataLength = function() {
        return this.reorderedSpectralDataLen;
    };
    prototype.isGainControlPresent = function() {
        return this.gainControlPresent;
    };
    prototype.getGainControl = function() {
        return this.gainControl;
    };
}, {info: "ICSInfo", sfbCB: "Int32Array", sectEnd: "Int32Array", data: "Float32Array", scaleFactors: "Float32Array", tns: "TNS", gainControl: "GainControl", pulseOffset: "Int32Array", pulseAmp: "Int32Array", rvlc: "RVLC", LOGGER: "Logger", SCALEFACTOR_TABLE: "Float32Array", IQ_TABLE: "Float32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Decodes JPEG in low res taking only first 4 coefficients from each DCT block
 *  ( DCT 2x2 )
 *  
 *  @author The JCodec project
 *  
 */
var JpegToThumb2x2 = function(interlace, topFieldFirst) {
    JpegDecoder.call(this, interlace, topFieldFirst);
};
JpegToThumb2x2 = stjs.extend(JpegToThumb2x2, JpegDecoder, [], function(constructor, prototype) {
    constructor.createJpegToThumb2x2 = function() {
        return new JpegToThumb2x2(false, false);
    };
    constructor.mapping2x2 = new Int32Array([0, 1, 2, 4, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4]);
    prototype.decodeBlock = function(bits, dcPredictor, quant, huff, result, buf, blkX, blkY, plane, chroma, field, step) {
        buf[1] = buf[2] = buf[3] = 0;
        dcPredictor[plane] = buf[0] = this.readDCValue(bits, huff[chroma]) * quant[chroma][0] + dcPredictor[plane];
        this.readACValues(bits, buf, huff[chroma + 2], quant[chroma]);
        IDCT2x2.idct(buf, 0);
        this.putBlock2x2(result.getPlaneData(plane), result.getPlaneWidth(plane), buf, blkX, blkY, field, step);
    };
    prototype.putBlock2x2 = function(plane, stride, patch, x, y, field, step) {
        stride >>= 2;
        var dstride = stride * step;
        var off = field * stride + (y >> 2) * dstride + (x >> 2);
        plane[off] = ((MathUtil.clip(patch[0], 0, 255) - 128) << 24 >> 24);
        plane[off + 1] = ((MathUtil.clip(patch[1], 0, 255) - 128) << 24 >> 24);
        plane[off + dstride] = ((MathUtil.clip(patch[2], 0, 255) - 128) << 24 >> 24);
        plane[off + dstride + 1] = ((MathUtil.clip(patch[3], 0, 255) - 128) << 24 >> 24);
    };
    prototype.readACValues = function(_in, target, table, quantTable) {
        var code;
        var curOff = 1;
        do {
            code = table.readVLC16(_in);
            if (code == 240) {
                curOff += 16;
            } else if (code > 0) {
                var rle = code >> 4;
                curOff += rle;
                var len = code & 15;
                target[JpegToThumb2x2.mapping2x2[curOff]] = JpegDecoder.toValue(_in.readNBit(len), len) * quantTable[curOff];
                curOff++;
            }
        } while (code != 0 && curOff < 5);
        if (code != 0) {
            do {
                code = table.readVLC16(_in);
                if (code == 240) {
                    curOff += 16;
                } else if (code > 0) {
                    var rle = code >> 4;
                    curOff += rle;
                    var len = code & 15;
                    _in.skip(len);
                    curOff++;
                }
            } while (code != 0 && curOff < 64);
        }
    };
    prototype.decodeField = function(data, data2, field, step) {
        var res = JpegDecoder.prototype.decodeField.call(this, data, data2, field, step);
        return new Picture8Bit(res.getWidth() >> 2, res.getHeight() >> 2, res.getData(), res.getColor(), new Rect(0, 0, res.getCroppedWidth() >> 2, res.getCroppedHeight() >> 2));
    };
}, {mapping2x2: "Int32Array", buf: "Int32Array", byteBuffer: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Decodes JPEG in low res taking only first 4 coefficients from each DCT block
 *  ( DCT 4x4 )
 *  
 *  @author The JCodec project
 *  
 */
var JpegToThumb4x4 = function(interlace, topFieldFirst) {
    JpegDecoder.call(this, interlace, topFieldFirst);
};
JpegToThumb4x4 = stjs.extend(JpegToThumb4x4, JpegDecoder, [], function(constructor, prototype) {
    constructor.createJpegToThumb4x4 = function() {
        return new JpegToThumb4x4(false, false);
    };
    constructor.mapping4x4 = new Int32Array([0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 16, 13, 10, 7, 16, 16, 16, 11, 14, 16, 16, 16, 16, 16, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16]);
    prototype.decodeBlock = function(bits, dcPredictor, quant, huff, result, buf, blkX, blkY, plane, chroma, field, step) {
        buf[1] = buf[2] = buf[3] = buf[4] = buf[5] = buf[6] = buf[7] = buf[8] = buf[9] = buf[10] = buf[11] = buf[12] = buf[13] = buf[14] = buf[15] = 0;
        dcPredictor[plane] = buf[0] = this.readDCValue(bits, huff[chroma]) * quant[chroma][0] + dcPredictor[plane];
        this.readACValues(bits, buf, huff[chroma + 2], quant[chroma]);
        IDCT4x4.idct(buf, 0);
        this.putBlock4x4(result.getPlaneData(plane), result.getPlaneWidth(plane), buf, blkX, blkY, field, step);
    };
    prototype.putBlock4x4 = function(plane, stride, patch, x, y, field, step) {
        stride >>= 1;
        var dstride = step * stride;
        var off = field * stride + (y >> 1) * dstride + (x >> 1);
        for (var i = 0; i < 16; i += 4) {
            plane[off] = ((MathUtil.clip(patch[i], 0, 255) - 128) << 24 >> 24);
            plane[off + 1] = ((MathUtil.clip(patch[i + 1], 0, 255) - 128) << 24 >> 24);
            plane[off + 2] = ((MathUtil.clip(patch[i + 2], 0, 255) - 128) << 24 >> 24);
            plane[off + 3] = ((MathUtil.clip(patch[i + 3], 0, 255) - 128) << 24 >> 24);
            off += dstride;
        }
    };
    prototype.readACValues = function(_in, target, table, quantTable) {
        var code;
        var curOff = 1;
        do {
            code = table.readVLC16(_in);
            if (code == 240) {
                curOff += 16;
            } else if (code > 0) {
                var rle = code >> 4;
                curOff += rle;
                var len = code & 15;
                target[JpegToThumb4x4.mapping4x4[curOff]] = JpegDecoder.toValue(_in.readNBit(len), len) * quantTable[curOff];
                curOff++;
            }
        } while (code != 0 && curOff < 19);
        if (code != 0) {
            do {
                code = table.readVLC16(_in);
                if (code == 240) {
                    curOff += 16;
                } else if (code > 0) {
                    var rle = code >> 4;
                    curOff += rle;
                    var len = code & 15;
                    _in.skip(len);
                    curOff++;
                }
            } while (code != 0 && curOff < 64);
        }
    };
    prototype.decodeField = function(data, data2, field, step) {
        var res = JpegDecoder.prototype.decodeField.call(this, data, data2, field, step);
        return new Picture8Bit(res.getWidth() >> 1, res.getHeight() >> 1, res.getData(), res.getColor(), new Rect(0, 0, res.getCroppedWidth() >> 1, res.getCroppedHeight() >> 1));
    };
}, {mapping4x4: "Int32Array", buf: "Int32Array", byteBuffer: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  MPEG 1/2 decoder interframe motion compensation routines, octal interpolation
 *  
 *  @author The JCodec project
 *  
 */
var MPEGPredOct = function(other) {
    MPEGPred.call(this, other.fCode, other.chromaFormat, other.topFieldFirst);
    this.tmp = new Int32Array(16 * 21);
};
MPEGPredOct = stjs.extend(MPEGPredOct, MPEGPred, [], function(constructor, prototype) {
    prototype.tmp = null;
    constructor.COEFF = [new Int32Array([0, 0, 128, 0, 0, 0]), new Int32Array([0, -6, 123, 12, -1, 0]), new Int32Array([2, -11, 108, 36, -8, 1]), new Int32Array([0, -9, 93, 50, -6, 0]), new Int32Array([3, -16, 77, 77, -16, 3]), new Int32Array([0, -6, 50, 93, -9, 0]), new Int32Array([1, -8, 36, 108, -11, 2]), new Int32Array([0, -1, 12, 123, -6, 0])];
    prototype.predictPlane = function(ref, refX, refY, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep) {
        var rx = refX >> 3, ry = refY >> 3;
        tgtW >>= 3;
        tgtH >>= 3;
        var safe = rx >= 2 && ry >= 2 && rx + tgtW + 3 < refW && ((ry + tgtH + 3) << refVertStep) < refH;
        if ((refX & 7) == 0) {
            if ((refY & 7) == 0) {
                if (safe) 
                    this.predictFullXFullYSafe(ref, rx, ry, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep);
                 else 
                    this.predictFullXFullYUnSafe(ref, rx, ry, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep);
            } else {
                if (safe) 
                    this.predictFullXSubYSafe(ref, rx, ry, refY & 7, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep);
                 else 
                    this.predictFullXSubYUnSafe(ref, rx, ry, refY & 7, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep);
            }
        } else if ((refY & 7) == 0) {
            if (safe) 
                this.predictSubXFullYSafe(ref, rx, refX & 7, ry, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep);
             else 
                this.predictSubXFullYUnSafe(ref, rx, refX & 7, ry, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep);
        } else {
            if (safe) 
                this.predictSubXSubYSafe(ref, rx, refX & 7, ry, refY & 7, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep);
             else 
                this.predictSubXSubYUnSafe(ref, rx, refX & 7, ry, refY & 7, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep);
        }
    };
    prototype.getPix6 = function(ref, refW, refH, x, y, refVertStep, refVertOff, coeff) {
        var lastLine = refH - (1 << refVertStep) + refVertOff;
        var x0 = MathUtil.clip(x - 2, 0, refW - 1);
        var x1 = MathUtil.clip(x - 1, 0, refW - 1);
        var x2 = MathUtil.clip(x, 0, refW - 1);
        var x3 = MathUtil.clip(x + 1, 0, refW - 1);
        var x4 = MathUtil.clip(x + 2, 0, refW - 1);
        var x5 = MathUtil.clip(x + 3, 0, refW - 1);
        var off = MathUtil.clip(y, refVertOff, lastLine) * refW;
        return ref[off + x0] * coeff[0] + ref[off + x1] * coeff[1] + ref[off + x2] * coeff[2] + ref[off + x3] * coeff[3] + ref[off + x4] * coeff[4] + ref[off + x5] * coeff[5] + 16384;
    };
    prototype.getPix6Vert = function(ref, refW, refH, x, y, refVertStep, refVertOff, coeff) {
        var lastLine = refH - (1 << refVertStep) + refVertOff;
        var y0 = MathUtil.clip(y - (2 << refVertStep), refVertOff, lastLine);
        var y1 = MathUtil.clip(y - (1 << refVertStep), refVertOff, lastLine);
        var y2 = MathUtil.clip(y, 0, lastLine);
        var y3 = MathUtil.clip(y + (1 << refVertStep), refVertOff, lastLine);
        var y4 = MathUtil.clip(y + (2 << refVertStep), refVertOff, lastLine);
        var y5 = MathUtil.clip(y + (3 << refVertStep), refVertOff, lastLine);
        x = MathUtil.clip(x, 0, refW - 1);
        return ref[y0 * refW + x] * coeff[0] + ref[y1 * refW + x] * coeff[1] + ref[y2 * refW + x] * coeff[2] + ref[y3 * refW + x] * coeff[3] + ref[y4 * refW + x] * coeff[4] + ref[y5 * refW + x] * coeff[5] + 16384;
    };
    prototype.predictSubXSubYUnSafe = function(ref, rx, ix, ry, iy, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep) {
        var offTgt = tgtW * tgtY;
        var dblTgtW = tgtW << 1;
        var tripleTgtW = dblTgtW + tgtW;
        var lfTgt = tgtVertStep * tgtW;
        var coeff = MPEGPredOct.COEFF[ix];
        for (var i = -2, offTmp = 0; i < tgtH + 3; i++) {
            var y = ((i + ry) << refVertStep) + refVertOff;
            for (var j = 0; j < tgtW; j++ , ++offTmp) {
                this.tmp[offTmp] = this.getPix6(ref, refW, refH, j + rx, y, refVertStep, refVertOff, coeff);
            }
        }
        coeff = MPEGPredOct.COEFF[iy];
        for (var i = 0, offTmp = dblTgtW; i < tgtH; i++) {
            for (var j = 0; j < tgtW; j++ , ++offTmp , ++offTgt) {
                tgt[offTgt] = (this.tmp[offTmp - dblTgtW] * coeff[0] + this.tmp[offTmp - tgtW] * coeff[1] + this.tmp[offTmp] * coeff[2] + this.tmp[offTmp + tgtW] * coeff[3] + this.tmp[offTmp + dblTgtW] * coeff[4] + this.tmp[offTmp + tripleTgtW] * coeff[5] + 8192) >> 14;
            }
            offTgt += lfTgt;
        }
    };
    prototype.predictSubXSubYSafe = function(ref, rx, ix, ry, iy, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep) {
        var coeff = MPEGPredOct.COEFF[ix];
        var offRef = (((ry - 2) << refVertStep) + refVertOff) * refW + rx;
        var offTgt = tgtW * tgtY;
        var lfRef = (refW << refVertStep) - tgtW;
        var lfTgt = tgtVertStep * tgtW;
        var dblTgtW = tgtW << 1;
        var tripleTgtW = dblTgtW + tgtW;
        for (var i = 0, offTmp = 0; i < tgtH + 5; i++) {
            for (var j = 0; j < tgtW; j++ , ++offTmp , ++offRef) {
                this.tmp[offTmp] = ref[offRef - 2] * coeff[0] + ref[offRef - 1] * coeff[1] + ref[offRef] * coeff[2] + ref[offRef + 1] * coeff[3] + ref[offRef + 2] * coeff[4] + ref[offRef + 3] * coeff[5];
            }
            offRef += lfRef;
        }
        coeff = MPEGPredOct.COEFF[iy];
        for (var i = 0, offTmp = dblTgtW; i < tgtH; i++) {
            for (var j = 0; j < tgtW; j++ , ++offTmp , ++offTgt) {
                tgt[offTgt] = ((this.tmp[offTmp - dblTgtW] * coeff[0] + this.tmp[offTmp - tgtW] * coeff[1] + this.tmp[offTmp] * coeff[2] + this.tmp[offTmp + tgtW] * coeff[3] + this.tmp[offTmp + dblTgtW] * coeff[4] + this.tmp[offTmp + tripleTgtW] * coeff[5] + 8192) >> 14) + 128;
            }
            offTgt += lfTgt;
        }
    };
    prototype.predictSubXFullYUnSafe = function(ref, rx, ix, ry, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep) {
        var coeff = MPEGPredOct.COEFF[ix];
        var tgtOff = tgtW * tgtY;
        var lfTgt = tgtVertStep * tgtW;
        for (var i = 0; i < tgtH; i++) {
            var y = ((i + ry) << refVertStep) + refVertOff;
            for (var j = 0; j < tgtW; j++) {
                tgt[tgtOff++] = (this.getPix6(ref, refW, refH, j + rx, y, refVertStep, refVertOff, coeff) + 64) >> 7;
            }
            tgtOff += lfTgt;
        }
    };
    prototype.predictSubXFullYSafe = function(ref, rx, ix, ry, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep) {
        var coeff = MPEGPredOct.COEFF[ix];
        var offRef = ((ry << refVertStep) + refVertOff) * refW + rx;
        var offTgt = tgtW * tgtY;
        var lfRef = (refW << refVertStep) - tgtW;
        var lfTgt = tgtVertStep * tgtW;
        for (var i = 0; i < tgtH; i++) {
            for (var j = 0; j < tgtW; j++ , ++offRef) {
                tgt[offTgt++] = ((ref[offRef - 2] * coeff[0] + ref[offRef - 1] * coeff[1] + ref[offRef] * coeff[2] + ref[offRef + 1] * coeff[3] + ref[offRef + 2] * coeff[4] + ref[offRef + 3] * coeff[5] + 64) >> 7) + 128;
            }
            offRef += lfRef;
            offTgt += lfTgt;
        }
    };
    prototype.predictFullXSubYUnSafe = function(ref, rx, ry, iy, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep) {
        var coeff = MPEGPredOct.COEFF[iy];
        var tgtOff = tgtW * tgtY;
        var lfTgt = tgtVertStep * tgtW;
        for (var i = 0; i < tgtH; i++) {
            var y = ((i + ry) << refVertStep) + refVertOff;
            for (var j = 0; j < tgtW; j++) {
                tgt[tgtOff++] = (this.getPix6Vert(ref, refW, refH, j + rx, y, refVertStep, refVertOff, coeff) + 64) >> 7;
            }
            tgtOff += lfTgt;
        }
    };
    prototype.predictFullXSubYSafe = function(ref, rx, ry, iy, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep) {
        var coeff = MPEGPredOct.COEFF[iy];
        var offTgt = tgtW * tgtY;
        var offRef = ((ry << refVertStep) + refVertOff) * refW + rx;
        var singleRefW = refW << refVertStep;
        var dblRefW = refW << (1 + refVertStep);
        var tripleRefW = dblRefW + singleRefW;
        var lfTgt = tgtVertStep * tgtW;
        var lfRef = (refW << refVertStep) - tgtW;
        for (var i = 0; i < tgtH; i++) {
            for (var j = 0; j < tgtW; ++j , ++offTgt , ++offRef) {
                tgt[offTgt] = ((ref[offRef - dblRefW] * coeff[0] + ref[offRef - singleRefW] * coeff[1] + ref[offRef] * coeff[2] + ref[offRef + singleRefW] * coeff[3] + ref[offRef + dblRefW] * coeff[4] + ref[offRef + tripleRefW] * coeff[5] + 64) >> 7) + 128;
            }
            offRef += lfRef;
            offTgt += lfTgt;
        }
    };
}, {tmp: "Int32Array", COEFF: "Array", mvPred: "Array", fCode: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var SequenceHeader = function() {};
SequenceHeader = stjs.extend(SequenceHeader, null, [MPEGHeader], function(constructor, prototype) {
    constructor._hasExtensions = false;
    prototype.horizontal_size = 0;
    prototype.vertical_size = 0;
    prototype.aspect_ratio_information = 0;
    prototype.frame_rate_code = 0;
    prototype.bit_rate = 0;
    prototype.vbv_buffer_size_value = 0;
    prototype.constrained_parameters_flag = 0;
    prototype.intra_quantiser_matrix = null;
    prototype.non_intra_quantiser_matrix = null;
    prototype.sequenceExtension = null;
    prototype.sequenceScalableExtension = null;
    prototype.sequenceDisplayExtension = null;
    constructor.createSequenceHeader = function(horizontal_size, vertical_size, aspect_ratio_information, frame_rate_code, bit_rate, vbv_buffer_size_value, constrained_parameters_flag, intra_quantiser_matrix, non_intra_quantiser_matrix) {
        var sh = new SequenceHeader();
        sh.horizontal_size = horizontal_size;
        sh.vertical_size = vertical_size;
        sh.aspect_ratio_information = aspect_ratio_information;
        sh.frame_rate_code = frame_rate_code;
        sh.bit_rate = bit_rate;
        sh.vbv_buffer_size_value = vbv_buffer_size_value;
        sh.constrained_parameters_flag = constrained_parameters_flag;
        sh.intra_quantiser_matrix = intra_quantiser_matrix;
        sh.non_intra_quantiser_matrix = non_intra_quantiser_matrix;
        return sh;
    };
    constructor.read = function(bb) {
        var _in = BitReader.createBitReader(bb);
        var sh = new SequenceHeader();
        sh.horizontal_size = _in.readNBit(12);
        sh.vertical_size = _in.readNBit(12);
        sh.aspect_ratio_information = _in.readNBit(4);
        sh.frame_rate_code = _in.readNBit(4);
        sh.bit_rate = _in.readNBit(18);
        _in.read1Bit();
        sh.vbv_buffer_size_value = _in.readNBit(10);
        sh.constrained_parameters_flag = _in.read1Bit();
        if (_in.read1Bit() != 0) {
            sh.intra_quantiser_matrix = new Int32Array(64);
            for (var i = 0; i < 64; i++) {
                sh.intra_quantiser_matrix[i] = _in.readNBit(8);
            }
        }
        if (_in.read1Bit() != 0) {
            sh.non_intra_quantiser_matrix = new Int32Array(64);
            for (var i = 0; i < 64; i++) {
                sh.non_intra_quantiser_matrix[i] = _in.readNBit(8);
            }
        }
        return sh;
    };
    constructor.readExtension = function(bb, sh) {
        SequenceHeader._hasExtensions = true;
        var _in = BitReader.createBitReader(bb);
        var extType = _in.readNBit(4);
        switch (extType) {
            case SequenceExtension.Sequence_Extension:
                sh.sequenceExtension = SequenceExtension.read(_in);
                break;
            case SequenceScalableExtension.Sequence_Scalable_Extension:
                sh.sequenceScalableExtension = SequenceScalableExtension.read(_in);
                break;
            case SequenceDisplayExtension.Sequence_Display_Extension:
                sh.sequenceDisplayExtension = SequenceDisplayExtension.read(_in);
                break;
            default:
                 throw new RuntimeException("Unsupported extension: " + extType);
        }
    };
    prototype.write = function(bb) {
        var bw = new BitWriter(bb);
        bw.writeNBit(this.horizontal_size, 12);
        bw.writeNBit(this.vertical_size, 12);
        bw.writeNBit(this.aspect_ratio_information, 4);
        bw.writeNBit(this.frame_rate_code, 4);
        bw.writeNBit(this.bit_rate, 18);
        bw.write1Bit(1);
        bw.writeNBit(this.vbv_buffer_size_value, 10);
        bw.write1Bit(this.constrained_parameters_flag);
        bw.write1Bit(this.intra_quantiser_matrix != null ? 1 : 0);
        if (this.intra_quantiser_matrix != null) {
            for (var i = 0; i < 64; i++) {
                bw.writeNBit(this.intra_quantiser_matrix[i], 8);
            }
        }
        bw.write1Bit(this.non_intra_quantiser_matrix != null ? 1 : 0);
        if (this.non_intra_quantiser_matrix != null) {
            for (var i = 0; i < 64; i++) {
                bw.writeNBit(this.non_intra_quantiser_matrix[i], 8);
            }
        }
        bw.flush();
        this.writeExtensions(bb);
    };
    prototype.writeExtensions = function(out) {
        if (this.sequenceExtension != null) {
            out.putInt(MPEGConst.EXTENSION_START_CODE);
            this.sequenceExtension.write(out);
        }
        if (this.sequenceScalableExtension != null) {
            out.putInt(MPEGConst.EXTENSION_START_CODE);
            this.sequenceScalableExtension.write(out);
        }
        if (this.sequenceDisplayExtension != null) {
            out.putInt(MPEGConst.EXTENSION_START_CODE);
            this.sequenceDisplayExtension.write(out);
        }
    };
    prototype.hasExtensions = function() {
        return SequenceHeader._hasExtensions;
    };
    prototype.copyExtensions = function(sh) {
        this.sequenceExtension = sh.sequenceExtension;
        this.sequenceScalableExtension = sh.sequenceScalableExtension;
        this.sequenceDisplayExtension = sh.sequenceDisplayExtension;
    };
}, {intra_quantiser_matrix: "Int32Array", non_intra_quantiser_matrix: "Int32Array", sequenceExtension: "SequenceExtension", sequenceScalableExtension: "SequenceScalableExtension", sequenceDisplayExtension: "SequenceDisplayExtension"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Encodes macroblock as I16x16
 *  
 *  @author Stanislav Vitvitskyy
 */
var MBEncoderI16x16 = function(cavlc, leftRow, topLine) {
    this.cavlc = cavlc;
    this.leftRow = leftRow;
    this.topLine = topLine;
};
MBEncoderI16x16 = stjs.extend(MBEncoderI16x16, null, [], function(constructor, prototype) {
    prototype.cavlc = null;
    prototype.leftRow = null;
    prototype.topLine = null;
    prototype.encodeMacroblock = function(pic, mbX, mbY, out, outMB, leftOutMB, topOutMB, qp, qpDelta) {
        CAVLCWriter.writeUE(out, 0);
        CAVLCWriter.writeSE(out, qpDelta);
        outMB.setType(MBType.I_16x16);
        outMB.setQp(qp);
        this.luma(pic, mbX, mbY, out, qp, outMB.getPixels(), this.cavlc[0]);
        this.chroma(pic, mbX, mbY, out, qp, outMB.getPixels());
        new MBDeblocker().deblockMBI(outMB, leftOutMB, topOutMB);
    };
    constructor.DUMMY = new Int32Array(16);
    prototype.chroma = function(pic, mbX, mbY, out, qp, outMB) {
        var cw = pic.getColor().compWidth[1];
        var ch = pic.getColor().compHeight[1];
        var x = mbX << (4 - cw);
        var y = mbY << (4 - ch);
        var ac1 = Array.apply(null, Array(16 >> (cw + ch))).map(function() {
            return new Int32Array(16);
        });
        var ac2 = Array.apply(null, Array(16 >> (cw + ch))).map(function() {
            return new Int32Array(16);
        });
        var pred1 = Array.apply(null, Array(16 >> (cw + ch))).map(function() {
            return new Int8Array(16);
        });
        var pred2 = Array.apply(null, Array(16 >> (cw + ch))).map(function() {
            return new Int8Array(16);
        });
        this.predictChroma(pic, ac1, pred1, 1, cw, ch, x, y);
        this.predictChroma(pic, ac2, pred2, 2, cw, ch, x, y);
        MBEncoderI16x16.chromaResidual(pic, mbX, mbY, out, qp, ac1, ac2, this.cavlc[1], this.cavlc[2], MBType.I_16x16, MBType.I_16x16);
        this.putChroma(outMB.getData()[1], 1, x, y, ac1, pred1);
        this.putChroma(outMB.getData()[2], 2, x, y, ac2, pred2);
    };
    constructor.chromaResidual = function(pic, mbX, mbY, out, qp, ac1, ac2, cavlc1, cavlc2, leftMBType, topMBType) {
        MBEncoderI16x16.transformChroma(ac1);
        MBEncoderI16x16.transformChroma(ac2);
        var dc1 = MBEncoderI16x16.extractDC(ac1);
        var dc2 = MBEncoderI16x16.extractDC(ac2);
        MBEncoderI16x16.writeDC(cavlc1, mbX, mbY, out, qp, mbX << 1, mbY << 1, dc1, leftMBType, topMBType);
        MBEncoderI16x16.writeDC(cavlc2, mbX, mbY, out, qp, mbX << 1, mbY << 1, dc2, leftMBType, topMBType);
        MBEncoderI16x16.writeAC(cavlc1, mbX, mbY, out, mbX << 1, mbY << 1, ac1, qp, leftMBType, topMBType, MBEncoderI16x16.DUMMY);
        MBEncoderI16x16.writeAC(cavlc2, mbX, mbY, out, mbX << 1, mbY << 1, ac2, qp, leftMBType, topMBType, MBEncoderI16x16.DUMMY);
        MBEncoderI16x16.restorePlane(dc1, ac1, qp);
        MBEncoderI16x16.restorePlane(dc2, ac2, qp);
    };
    prototype.luma = function(pic, mbX, mbY, out, qp, outMB, cavlc) {
        var x = mbX << 4;
        var y = mbY << 4;
        var ac = Array.apply(null, Array(16)).map(function() {
            return new Int32Array(16);
        });
        var pred = Array.apply(null, Array(16)).map(function() {
            return new Int8Array(16);
        });
        this.lumaDCPred(x, y, pred);
        this.transform(pic, 0, ac, pred, x, y);
        var dc = MBEncoderI16x16.extractDC(ac);
        MBEncoderI16x16.writeDC(cavlc, mbX, mbY, out, qp, mbX << 2, mbY << 2, dc, MBType.I_16x16, MBType.I_16x16);
        MBEncoderI16x16.writeAC(cavlc, mbX, mbY, out, mbX << 2, mbY << 2, ac, qp, MBType.I_16x16, MBType.I_16x16, MBEncoderI16x16.DUMMY);
        MBEncoderI16x16.restorePlane(dc, ac, qp);
        for (var blk = 0; blk < ac.length; blk++) {
            MBEncoderHelper.putBlk(outMB.getPlaneData(0), ac[blk], pred[blk], 4, H264Const.BLK_X[blk], H264Const.BLK_Y[blk], 4, 4);
        }
    };
    prototype.putChroma = function(mb, comp, x, y, ac, pred) {
        MBEncoderHelper.putBlk(mb, ac[0], pred[0], 3, 0, 0, 4, 4);
        MBEncoderHelper.putBlk(mb, ac[1], pred[1], 3, 4, 0, 4, 4);
        MBEncoderHelper.putBlk(mb, ac[2], pred[2], 3, 0, 4, 4, 4);
        MBEncoderHelper.putBlk(mb, ac[3], pred[3], 3, 4, 4, 4, 4);
    };
    constructor.restorePlane = function(dc, ac, qp) {
        if (dc.length == 4) {
            CoeffTransformer.invDC2x2(dc);
            CoeffTransformer.dequantizeDC2x2(dc, qp);
        } else if (dc.length == 8) {
            CoeffTransformer.invDC4x2(dc);
            CoeffTransformer.dequantizeDC4x2(dc, qp);
        } else {
            CoeffTransformer.invDC4x4(dc);
            CoeffTransformer.dequantizeDC4x4(dc, qp);
            CoeffTransformer.reorderDC4x4(dc);
        }
        for (var i = 0; i < ac.length; i++) {
            CoeffTransformer.dequantizeAC(ac[i], qp);
            ac[i][0] = dc[i];
            CoeffTransformer.idct4x4(ac[i]);
        }
    };
    constructor.extractDC = function(ac) {
        var dc = new Int32Array(ac.length);
        for (var i = 0; i < ac.length; i++) {
            dc[i] = ac[i][0];
            ac[i][0] = 0;
        }
        return dc;
    };
    constructor.writeAC = function(cavlc, mbX, mbY, out, mbLeftBlk, mbTopBlk, ac, qp, leftMBType, topMBType, nc) {
        for (var i = 0; i < ac.length; i++) {
            CoeffTransformer.quantizeAC(ac[i], qp);
            nc[H264Const.BLK_INV_MAP[i]] = CAVLC.totalCoeff(cavlc.writeACBlock(out, mbLeftBlk + H264Const.MB_BLK_OFF_LEFT[i], mbTopBlk + H264Const.MB_BLK_OFF_TOP[i], leftMBType, topMBType, ac[i], H264Const.totalZeros16, 1, 15, CoeffTransformer.zigzag4x4));
        }
    };
    constructor.writeDC = function(cavlc, mbX, mbY, out, qp, mbLeftBlk, mbTopBlk, dc, leftMBType, topMBType) {
        if (dc.length == 4) {
            CoeffTransformer.quantizeDC2x2(dc, qp);
            CoeffTransformer.fvdDC2x2(dc);
            cavlc.writeChrDCBlock(out, dc, H264Const.totalZeros4, 0, dc.length, new Int32Array([0, 1, 2, 3]));
        } else if (dc.length == 8) {
            CoeffTransformer.quantizeDC4x2(dc, qp);
            CoeffTransformer.fvdDC4x2(dc);
            cavlc.writeChrDCBlock(out, dc, H264Const.totalZeros8, 0, dc.length, new Int32Array([0, 1, 2, 3, 4, 5, 6, 7]));
        } else {
            CoeffTransformer.reorderDC4x4(dc);
            CoeffTransformer.quantizeDC4x4(dc, qp);
            CoeffTransformer.fvdDC4x4(dc);
            cavlc.writeLumaDCBlock(out, mbLeftBlk, mbTopBlk, leftMBType, topMBType, dc, H264Const.totalZeros16, 0, 16, CoeffTransformer.zigzag4x4);
        }
    };
    constructor.transformChroma = function(ac) {
        for (var i = 0; i < 4; i++) {
            CoeffTransformer.fdct4x4(ac[i]);
        }
    };
    prototype.predictChroma = function(pic, ac, pred, comp, cw, ch, x, y) {
        this.chromaPredBlk0(comp, x, y, pred[0]);
        this.chromaPredBlk1(comp, x, y, pred[1]);
        this.chromaPredBlk2(comp, x, y, pred[2]);
        this.chromaPredBlk3(comp, x, y, pred[3]);
        MBEncoderHelper.takeSubtract(pic.getPlaneData(comp), pic.getPlaneWidth(comp), pic.getPlaneHeight(comp), x, y, ac[0], pred[0], 4, 4);
        MBEncoderHelper.takeSubtract(pic.getPlaneData(comp), pic.getPlaneWidth(comp), pic.getPlaneHeight(comp), x + 4, y, ac[1], pred[1], 4, 4);
        MBEncoderHelper.takeSubtract(pic.getPlaneData(comp), pic.getPlaneWidth(comp), pic.getPlaneHeight(comp), x, y + 4, ac[2], pred[2], 4, 4);
        MBEncoderHelper.takeSubtract(pic.getPlaneData(comp), pic.getPlaneWidth(comp), pic.getPlaneHeight(comp), x + 4, y + 4, ac[3], pred[3], 4, 4);
    };
    prototype.chromaPredOne = function(pix, x) {
        return (pix[x] + pix[x + 1] + pix[x + 2] + pix[x + 3] + 2) >> 2;
    };
    prototype.chromaPredTwo = function(pix1, pix2, x, y) {
        return (pix1[x] + pix1[x + 1] + pix1[x + 2] + pix1[x + 3] + pix2[y] + pix2[y + 1] + pix2[y + 2] + pix2[y + 3] + 4) >> 3;
    };
    prototype.chromaPredBlk0 = function(comp, x, y, pred) {
        var dc, predY = y & 7;
        if (x != 0 && y != 0) 
            dc = this.chromaPredTwo(this.leftRow[comp], this.topLine[comp], predY, x);
         else if (x != 0) 
            dc = this.chromaPredOne(this.leftRow[comp], predY);
         else if (y != 0) 
            dc = this.chromaPredOne(this.topLine[comp], x);
         else 
            dc = 0;
        for (var i = 0; i < pred.length; i++) 
            pred[i] += dc;
    };
    prototype.chromaPredBlk1 = function(comp, x, y, pred) {
        var dc, predY = y & 7;
        if (y != 0) 
            dc = this.chromaPredOne(this.topLine[comp], x + 4);
         else if (x != 0) 
            dc = this.chromaPredOne(this.leftRow[comp], predY);
         else 
            dc = 0;
        for (var i = 0; i < pred.length; i++) 
            pred[i] += dc;
    };
    prototype.chromaPredBlk2 = function(comp, x, y, pred) {
        var dc, predY = y & 7;
        if (x != 0) 
            dc = this.chromaPredOne(this.leftRow[comp], predY + 4);
         else if (y != 0) 
            dc = this.chromaPredOne(this.topLine[comp], x);
         else 
            dc = 0;
        for (var i = 0; i < pred.length; i++) 
            pred[i] += dc;
    };
    prototype.chromaPredBlk3 = function(comp, x, y, pred) {
        var dc, predY = y & 7;
        if (x != 0 && y != 0) 
            dc = this.chromaPredTwo(this.leftRow[comp], this.topLine[comp], predY + 4, x + 4);
         else if (x != 0) 
            dc = this.chromaPredOne(this.leftRow[comp], predY + 4);
         else if (y != 0) 
            dc = this.chromaPredOne(this.topLine[comp], x + 4);
         else 
            dc = 0;
        for (var i = 0; i < pred.length; i++) 
            pred[i] += dc;
    };
    prototype.lumaDCPred = function(x, y, pred) {
        var dc;
        if (x == 0 && y == 0) 
            dc = 0;
         else if (y == 0) 
            dc = (ArrayUtil.sumByte(this.leftRow[0]) + 8) >> 4;
         else if (x == 0) 
            dc = (ArrayUtil.sumByte3(this.topLine[0], x, 16) + 8) >> 4;
         else 
            dc = (ArrayUtil.sumByte(this.leftRow[0]) + ArrayUtil.sumByte3(this.topLine[0], x, 16) + 16) >> 5;
        for (var i = 0; i < pred.length; i++) 
            for (var j = 0; j < pred[i].length; j++) 
                pred[i][j] += dc;
    };
    prototype.transform = function(pic, comp, ac, pred, x, y) {
        for (var i = 0; i < ac.length; i++) {
            var coeff = ac[i];
            MBEncoderHelper.takeSubtract(pic.getPlaneData(comp), pic.getPlaneWidth(comp), pic.getPlaneHeight(comp), x + H264Const.BLK_X[i], y + H264Const.BLK_Y[i], coeff, pred[i], 4, 4);
            CoeffTransformer.fdct4x4(coeff);
        }
    };
    prototype.getPredMode = function(pic, mbX, mbY) {
        return 2;
    };
    prototype.getCbpChroma = function(pic, mbX, mbY) {
        return 2;
    };
    prototype.getCbpLuma = function(pic, mbX, mbY) {
        return 15;
    };
}, {cavlc: "Array", leftRow: "Array", topLine: "Array", DUMMY: "Int32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Base macroblock decoder that contains routines shared by many decoders
 *  
 *  @author The JCodec project
 *  
 */
var MBlockDecoderBase = function(sh, di, poc, decoderState) {
    this.interpolator = new BlockInterpolator();
    this.s = decoderState;
    this.sh = sh;
    this.di = di;
    this.poc = poc;
    this.mbb = [Picture8Bit.create(16, 16, this.s.chromaFormat), Picture8Bit.create(16, 16, this.s.chromaFormat)];
};
MBlockDecoderBase = stjs.extend(MBlockDecoderBase, null, [], function(constructor, prototype) {
    prototype.s = null;
    prototype.sh = null;
    prototype.di = null;
    prototype.poc = 0;
    prototype.interpolator = null;
    prototype.mbb = null;
    prototype.residualLuma = function(mBlock, leftAvailable, topAvailable, mbX, mbY) {
        if (!mBlock.transform8x8Used) {
            this._residualLuma(mBlock);
        } else if (this.sh.pps.entropy_coding_mode_flag) {
            this.residualLuma8x8CABAC(mBlock);
        } else {
            this.residualLuma8x8CAVLC(mBlock);
        }
    };
    prototype._residualLuma = function(mBlock) {
        for (var i = 0; i < 16; i++) {
            if ((mBlock.cbpLuma() & (1 << (i >> 2))) == 0) {
                continue;
            }
            CoeffTransformer.dequantizeAC(mBlock.ac[0][i], this.s.qp);
            CoeffTransformer.idct4x4(mBlock.ac[0][i]);
        }
    };
    prototype.residualLuma8x8CABAC = function(mBlock) {
        for (var i = 0; i < 4; i++) {
            if ((mBlock.cbpLuma() & (1 << i)) == 0) {
                continue;
            }
            CoeffTransformer.dequantizeAC8x8(mBlock.ac[0][i], this.s.qp);
            CoeffTransformer.idct8x8(mBlock.ac[0][i]);
        }
    };
    prototype.residualLuma8x8CAVLC = function(mBlock) {
        for (var i = 0; i < 4; i++) {
            if ((mBlock.cbpLuma() & (1 << i)) == 0) {
                continue;
            }
            CoeffTransformer.dequantizeAC8x8(mBlock.ac[0][i], this.s.qp);
            CoeffTransformer.idct8x8(mBlock.ac[0][i]);
        }
    };
    prototype.decodeChroma = function(mBlock, mbX, mbY, leftAvailable, topAvailable, mb, qp) {
        if (this.s.chromaFormat == ColorSpace.MONO) {
            Arrays.fill(mb.getPlaneData(1), (0 << 24 >> 24));
            Arrays.fill(mb.getPlaneData(2), (0 << 24 >> 24));
            return;
        }
        var qp1 = this.calcQpChroma(qp, this.s.chromaQpOffset[0]);
        var qp2 = this.calcQpChroma(qp, this.s.chromaQpOffset[1]);
        if (mBlock.cbpChroma() != 0) {
            this.decodeChromaResidual(mBlock, leftAvailable, topAvailable, mbX, mbY, qp1, qp2);
        }
        var addr = mbY * (this.sh.sps.pic_width_in_mbs_minus1 + 1) + mbX;
        this.di.mbQps[1][addr] = qp1;
        this.di.mbQps[2][addr] = qp2;
        ChromaPredictionBuilder.predictWithMode(mBlock.ac[1], mBlock.chromaPredictionMode, mbX, leftAvailable, topAvailable, this.s.leftRow[1], this.s.topLine[1], this.s.topLeft[1], mb.getPlaneData(1));
        ChromaPredictionBuilder.predictWithMode(mBlock.ac[2], mBlock.chromaPredictionMode, mbX, leftAvailable, topAvailable, this.s.leftRow[2], this.s.topLine[2], this.s.topLeft[2], mb.getPlaneData(2));
    };
    prototype.decodeChromaResidual = function(mBlock, leftAvailable, topAvailable, mbX, mbY, crQp1, crQp2) {
        if (mBlock.cbpChroma() != 0) {
            if ((mBlock.cbpChroma() & 3) > 0) {
                this.chromaDC(mbX, leftAvailable, topAvailable, mBlock.dc1, 1, crQp1, mBlock.curMbType);
                this.chromaDC(mbX, leftAvailable, topAvailable, mBlock.dc2, 2, crQp2, mBlock.curMbType);
            }
            this.chromaAC(leftAvailable, topAvailable, mbX, mbY, mBlock.dc1, 1, crQp1, mBlock.curMbType, (mBlock.cbpChroma() & 2) > 0, mBlock.ac[1]);
            this.chromaAC(leftAvailable, topAvailable, mbX, mbY, mBlock.dc2, 2, crQp2, mBlock.curMbType, (mBlock.cbpChroma() & 2) > 0, mBlock.ac[2]);
        }
    };
    prototype.chromaDC = function(mbX, leftAvailable, topAvailable, dc, comp, crQp, curMbType) {
        CoeffTransformer.invDC2x2(dc);
        CoeffTransformer.dequantizeDC2x2(dc, crQp);
    };
    prototype.chromaAC = function(leftAvailable, topAvailable, mbX, mbY, dc, comp, crQp, curMbType, codedAC, residualOut) {
        for (var i = 0; i < dc.length; i++) {
            var ac = residualOut[i];
            if (codedAC) {
                CoeffTransformer.dequantizeAC(ac, crQp);
            }
            ac[0] = dc[i];
            CoeffTransformer.idct4x4(ac);
        }
    };
    prototype.calcQpChroma = function(qp, crQpOffset) {
        return H264Const.QP_SCALE_CR[MathUtil.clip(qp + crQpOffset, 0, 51)];
    };
    prototype.predictChromaInter = function(refs, vectors, x, y, comp, mb, predType) {
        for (var blk8x8 = 0; blk8x8 < 4; blk8x8++) {
            for (var list = 0; list < 2; list++) {
                if (!H264Const.usesList(predType[blk8x8], list)) 
                    continue;
                for (var blk4x4 = 0; blk4x4 < 4; blk4x4++) {
                    var i = H264Const.BLK_INV_MAP[(blk8x8 << 2) + blk4x4];
                    var mv = vectors[list][i];
                    var ref = refs[list][mv[2]];
                    var blkPox = (i & 3) << 1;
                    var blkPoy = (i >> 2) << 1;
                    var xx = ((x + blkPox) << 3) + mv[0];
                    var yy = ((y + blkPoy) << 3) + mv[1];
                    this.interpolator.getBlockChroma(ref.getPlaneData(comp), ref.getPlaneWidth(comp), ref.getPlaneHeight(comp), this.mbb[list].getPlaneData(comp), blkPoy * mb.getPlaneWidth(comp) + blkPox, mb.getPlaneWidth(comp), xx, yy, 2, 2);
                }
            }
            var blk4x4 = H264Const.BLK8x8_BLOCKS[blk8x8][0];
            PredictionMerger.mergePrediction(this.sh, vectors[0][blk4x4][2], vectors[1][blk4x4][2], predType[blk8x8], comp, this.mbb[0].getPlaneData(comp), this.mbb[1].getPlaneData(comp), H264Const.BLK_8x8_MB_OFF_CHROMA[blk8x8], mb.getPlaneWidth(comp), 4, 4, mb.getPlaneData(comp), refs, this.poc);
        }
    };
}, {s: "DecoderState", sh: "SliceHeader", di: "DeblockerInput", interpolator: "BlockInterpolator", mbb: "Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license. 
 * 
 *  @author in-somnia
 */
var DSE = function() {
    Element.call(this);
};
DSE = stjs.extend(DSE, Element, [], function(constructor, prototype) {
    prototype.dataStreamBytes = null;
    prototype.decode = function(_in) {
        var byteAlign = _in.readBool();
        var count = _in.readBits(8);
        if (count == 255) 
            count += _in.readBits(8);
        if (byteAlign) 
            _in.byteAlign();
        this.dataStreamBytes = new Int8Array(count);
        for (var i = 0; i < count; i++) {
            this.dataStreamBytes[i] = (_in.readBits(8) << 24 >> 24);
        }
    };
}, {dataStreamBytes: "Int8Array", sbr: "SBR", LOGGER: "Logger"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  @author in-somnia
 */
var PCE = function() {
    Element.call(this);
    this.frontElements = Array(PCE.MAX_FRONT_CHANNEL_ELEMENTS);
    this.sideElements = Array(PCE.MAX_SIDE_CHANNEL_ELEMENTS);
    this.backElements = Array(PCE.MAX_BACK_CHANNEL_ELEMENTS);
    this.lfeElementTags = new Int32Array(PCE.MAX_LFE_CHANNEL_ELEMENTS);
    this.assocDataElementTags = new Int32Array(PCE.MAX_ASSOC_DATA_ELEMENTS);
    this.ccElements = Array(PCE.MAX_VALID_CC_ELEMENTS);
    this.sampleFrequency = SampleFrequency.SAMPLE_FREQUENCY_NONE;
};
PCE = stjs.extend(PCE, Element, [], function(constructor, prototype) {
    constructor.MAX_FRONT_CHANNEL_ELEMENTS = 16;
    constructor.MAX_SIDE_CHANNEL_ELEMENTS = 16;
    constructor.MAX_BACK_CHANNEL_ELEMENTS = 16;
    constructor.MAX_LFE_CHANNEL_ELEMENTS = 4;
    constructor.MAX_ASSOC_DATA_ELEMENTS = 8;
    constructor.MAX_VALID_CC_ELEMENTS = 16;
    constructor.TaggedElement = function(isCPE, tag) {
        this.isCPE = isCPE;
        this.tag = tag;
    };
    constructor.TaggedElement = stjs.extend(constructor.TaggedElement, null, [], function(constructor, prototype) {
        prototype.isCPE = false;
        prototype.tag = 0;
        prototype.isIsCPE = function() {
            return this.isCPE;
        };
        prototype.getTag = function() {
            return this.tag;
        };
    }, {}, {});
    constructor.CCE = function(isIndSW, tag) {
        this.isIndSW = isIndSW;
        this.tag = tag;
    };
    constructor.CCE = stjs.extend(constructor.CCE, null, [], function(constructor, prototype) {
        prototype.isIndSW = false;
        prototype.tag = 0;
        prototype.isIsIndSW = function() {
            return this.isIndSW;
        };
        prototype.getTag = function() {
            return this.tag;
        };
    }, {}, {});
    prototype.profile = null;
    prototype.sampleFrequency = null;
    prototype.frontChannelElementsCount = 0;
    prototype.sideChannelElementsCount = 0;
    prototype.backChannelElementsCount = 0;
    prototype.lfeChannelElementsCount = 0;
    prototype.assocDataElementsCount = 0;
    prototype.validCCElementsCount = 0;
    prototype.monoMixdown = false;
    prototype.stereoMixdown = false;
    prototype.matrixMixdownIDXPresent = false;
    prototype.monoMixdownElementNumber = 0;
    prototype.stereoMixdownElementNumber = 0;
    prototype.matrixMixdownIDX = 0;
    prototype.pseudoSurround = false;
    prototype.frontElements = null;
    prototype.sideElements = null;
    prototype.backElements = null;
    prototype.lfeElementTags = null;
    prototype.assocDataElementTags = null;
    prototype.ccElements = null;
    prototype.commentFieldData = null;
    prototype.decode = function(_in) {
        this.readElementInstanceTag(_in);
        this.profile = Profile.forInt(_in.readBits(2));
        this.sampleFrequency = SampleFrequency.forInt(_in.readBits(4));
        this.frontChannelElementsCount = _in.readBits(4);
        this.sideChannelElementsCount = _in.readBits(4);
        this.backChannelElementsCount = _in.readBits(4);
        this.lfeChannelElementsCount = _in.readBits(2);
        this.assocDataElementsCount = _in.readBits(3);
        this.validCCElementsCount = _in.readBits(4);
        if (this.monoMixdown = _in.readBool()) {
            SyntaxConstants.LOGGER.warning("mono mixdown present, but not yet supported");
            this.monoMixdownElementNumber = _in.readBits(4);
        }
        if (this.stereoMixdown = _in.readBool()) {
            SyntaxConstants.LOGGER.warning("stereo mixdown present, but not yet supported");
            this.stereoMixdownElementNumber = _in.readBits(4);
        }
        if (this.matrixMixdownIDXPresent = _in.readBool()) {
            SyntaxConstants.LOGGER.warning("matrix mixdown present, but not yet supported");
            this.matrixMixdownIDX = _in.readBits(2);
            this.pseudoSurround = _in.readBool();
        }
        this.readTaggedElementArray(this.frontElements, _in, this.frontChannelElementsCount);
        this.readTaggedElementArray(this.sideElements, _in, this.sideChannelElementsCount);
        this.readTaggedElementArray(this.backElements, _in, this.backChannelElementsCount);
        var i;
        for (i = 0; i < this.lfeChannelElementsCount; ++i) {
            this.lfeElementTags[i] = _in.readBits(4);
        }
        for (i = 0; i < this.assocDataElementsCount; ++i) {
            this.assocDataElementTags[i] = _in.readBits(4);
        }
        for (i = 0; i < this.validCCElementsCount; ++i) {
            this.ccElements[i] = new PCE.CCE(_in.readBool(), _in.readBits(4));
        }
        _in.byteAlign();
        var commentFieldBytes = _in.readBits(8);
        this.commentFieldData = new Int8Array(commentFieldBytes);
        for (i = 0; i < commentFieldBytes; i++) {
            this.commentFieldData[i] = (_in.readBits(8) << 24 >> 24);
        }
    };
    prototype.readTaggedElementArray = function(te, _in, len) {
        for (var i = 0; i < len; ++i) {
            te[i] = new PCE.TaggedElement(_in.readBool(), _in.readBits(4));
        }
    };
    prototype.getProfile = function() {
        return this.profile;
    };
    prototype.getSampleFrequency = function() {
        return this.sampleFrequency;
    };
    prototype.getChannelCount = function() {
        return this.frontChannelElementsCount + this.sideChannelElementsCount + this.backChannelElementsCount + this.lfeChannelElementsCount + this.assocDataElementsCount;
    };
}, {profile: "Profile", sampleFrequency: "SampleFrequency", frontElements: "Array", sideElements: "Array", backElements: "Array", lfeElementTags: "Int32Array", assocDataElementTags: "Int32Array", ccElements: "Array", commentFieldData: "Int8Array", sbr: "SBR", LOGGER: "Logger"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MapManager = function(sps, pps) {
    this.sps = sps;
    this.pps = pps;
    this.mbToSliceGroupMap = this.buildMap(sps, pps);
};
MapManager = stjs.extend(MapManager, null, [], function(constructor, prototype) {
    prototype.sps = null;
    prototype.pps = null;
    prototype.mbToSliceGroupMap = null;
    prototype.prevSliceGroupChangeCycle = 0;
    prototype.buildMap = function(sps, pps) {
        var numGroups = pps.num_slice_groups_minus1 + 1;
        if (numGroups > 1) {
            var map;
            var picWidthInMbs = sps.pic_width_in_mbs_minus1 + 1;
            var picHeightInMbs = SeqParameterSet.getPicHeightInMbs(sps);
            if (pps.slice_group_map_type == 0) {
                var runLength = new Int32Array(numGroups);
                for (var i = 0; i < numGroups; i++) {
                    runLength[i] = pps.run_length_minus1[i] + 1;
                }
                map = SliceGroupMapBuilder.buildInterleavedMap(picWidthInMbs, picHeightInMbs, runLength);
            } else if (pps.slice_group_map_type == 1) {
                map = SliceGroupMapBuilder.buildDispersedMap(picWidthInMbs, picHeightInMbs, numGroups);
            } else if (pps.slice_group_map_type == 2) {
                map = SliceGroupMapBuilder.buildForegroundMap(picWidthInMbs, picHeightInMbs, numGroups, pps.top_left, pps.bottom_right);
            } else if (pps.slice_group_map_type >= 3 && pps.slice_group_map_type <= 5) {
                return null;
            } else if (pps.slice_group_map_type == 6) {
                map = pps.slice_group_id;
            } else {
                 throw new RuntimeException("Unsupported slice group map type");
            }
            return this.buildMapIndices(map, numGroups);
        }
        return null;
    };
    prototype.buildMapIndices = function(map, numGroups) {
        var ind = new Int32Array(numGroups);
        var indices = new Int32Array(map.length);
        for (var i = 0; i < map.length; i++) {
            indices[i] = ind[map[i]]++;
        }
        var inverse = Array(numGroups);
        for (var i = 0; i < numGroups; i++) {
            inverse[i] = new Int32Array(ind[i]);
        }
        ind = new Int32Array(numGroups);
        for (var i = 0; i < map.length; i++) {
            var sliceGroup = map[i];
            inverse[sliceGroup][ind[sliceGroup]++] = i;
        }
        return new MBToSliceGroupMap(map, indices, inverse);
    };
    prototype.updateMap = function(sh) {
        var mapType = this.pps.slice_group_map_type;
        var numGroups = this.pps.num_slice_groups_minus1 + 1;
        if (numGroups > 1 && mapType >= 3 && mapType <= 5 && (sh.slice_group_change_cycle != this.prevSliceGroupChangeCycle || this.mbToSliceGroupMap == null)) {
            this.prevSliceGroupChangeCycle = sh.slice_group_change_cycle;
            var picWidthInMbs = this.sps.pic_width_in_mbs_minus1 + 1;
            var picHeightInMbs = SeqParameterSet.getPicHeightInMbs(this.sps);
            var picSizeInMapUnits = picWidthInMbs * picHeightInMbs;
            var mapUnitsInSliceGroup0 = sh.slice_group_change_cycle * (this.pps.slice_group_change_rate_minus1 + 1);
            mapUnitsInSliceGroup0 = mapUnitsInSliceGroup0 > picSizeInMapUnits ? picSizeInMapUnits : mapUnitsInSliceGroup0;
            var sizeOfUpperLeftGroup = (this.pps.slice_group_change_direction_flag ? (picSizeInMapUnits - mapUnitsInSliceGroup0) : mapUnitsInSliceGroup0);
            var map;
            if (mapType == 3) {
                map = SliceGroupMapBuilder.buildBoxOutMap(picWidthInMbs, picHeightInMbs, this.pps.slice_group_change_direction_flag, mapUnitsInSliceGroup0);
            } else if (mapType == 4) {
                map = SliceGroupMapBuilder.buildRasterScanMap(picWidthInMbs, picHeightInMbs, sizeOfUpperLeftGroup, this.pps.slice_group_change_direction_flag);
            } else {
                map = SliceGroupMapBuilder.buildWipeMap(picWidthInMbs, picHeightInMbs, sizeOfUpperLeftGroup, this.pps.slice_group_change_direction_flag);
            }
            this.mbToSliceGroupMap = this.buildMapIndices(map, numGroups);
        }
    };
    prototype.getMapper = function(sh) {
        this.updateMap(sh);
        var firstMBInSlice = sh.first_mb_in_slice;
        if (this.pps.num_slice_groups_minus1 > 0) {
            return new PrebuiltMBlockMapper(this.mbToSliceGroupMap, firstMBInSlice, this.sps.pic_width_in_mbs_minus1 + 1);
        } else {
            return new FlatMBlockMapper(this.sps.pic_width_in_mbs_minus1 + 1, firstMBInSlice);
        }
    };
}, {sps: "SeqParameterSet", pps: "PictureParameterSet", mbToSliceGroupMap: "MBToSliceGroupMap"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 * 
 *  Contains an input for deblocking filter
 *  
 *  @author The JCodec project
 *  
 */
var DeblockerInput = function(activeSps) {
    this.picWidthInMbs = activeSps.pic_width_in_mbs_minus1 + 1;
    this.picHeightInMbs = SeqParameterSet.getPicHeightInMbs(activeSps);
    var picHeight = this.picHeightInMbs << 2;
    var picWidth = this.picWidthInMbs << 2;
    var mbCount = this.picHeightInMbs * this.picWidthInMbs;
    this.nCoeff = Array.apply(null, Array(picHeight)).map(function() {
        return new Int32Array(picWidth);
    });
    this.mvs = Array.apply(null, Array(2)).map(function() {
        return Array.apply(null, Array(picHeight)).map(function() {
            return Array.apply(null, Array(picWidth)).map(function() {
                return new Int32Array(3);
            });
        });
    });
    this.mbTypes = Array(mbCount);
    this.tr8x8Used = new Int8Array(mbCount);
    this.mbQps = Array.apply(null, Array(3)).map(function() {
        return new Int32Array(mbCount);
    });
    this.shs = Array(mbCount);
    this.refsUsed = Array(mbCount);
};
DeblockerInput = stjs.extend(DeblockerInput, null, [], function(constructor, prototype) {
    prototype.nCoeff = null;
    prototype.mvs = null;
    prototype.mbTypes = null;
    prototype.mbQps = null;
    prototype.tr8x8Used = null;
    prototype.refsUsed = null;
    prototype.shs = null;
    prototype.picWidthInMbs = 0;
    prototype.picHeightInMbs = 0;
}, {nCoeff: "Array", mvs: "Array", mbTypes: "Array", mbQps: "Array", tr8x8Used: "Int8Array", refsUsed: "Array", shs: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Demuxer for MPEG Program Stream format
 *  
 *  @author The JCodec project
 *  
 */
var MPSDemuxer = function(channel) {
    SegmentReader.call(this, channel, 4096);
    this.streams = new HashMap();
    this.channel = channel;
    this.bufPool = new ArrayList();
    this.findStreams();
};
MPSDemuxer = stjs.extend(MPSDemuxer, SegmentReader, [MPEGDemuxer], function(constructor, prototype) {
    constructor.BUFFER_SIZE = 1048576;
    prototype.streams = null;
    prototype.channel = null;
    prototype.bufPool = null;
    prototype.findStreams = function() {
        for (var i = 0; i == 0 || i < 5 * this.streams.size() && this.streams.size() < 2; i++) {
            var nextPacket = this.nextPacket(this.getBuffer());
            if (nextPacket == null) 
                break;
            this.addToStream(nextPacket);
        }
    };
    prototype.getBuffer = function() {
        {
            if (this.bufPool.size() > 0) {
                return this.bufPool.remove(0);
            }
        }return ByteBuffer.allocate(MPSDemuxer.BUFFER_SIZE);
    };
    prototype.putBack = function(buffer) {
        buffer.clear();
        {
            this.bufPool.add(buffer);
        }};
    constructor.BaseTrack = function(demuxer, streamId, pkt) {
        this._pending = new ArrayList();
        this.demuxer = demuxer;
        this.streamId = streamId;
        this._pending.add(pkt);
    };
    constructor.BaseTrack = stjs.extend(constructor.BaseTrack, null, [MPEGDemuxer.MPEGDemuxerTrack], function(constructor, prototype) {
        prototype.streamId = 0;
        prototype._pending = null;
        prototype.demuxer = null;
        prototype.getSid = function() {
            return this.streamId;
        };
        prototype.pending = function(pkt) {
            if (this._pending != null) 
                this._pending.add(pkt);
             else 
                this.demuxer.putBack(pkt.data);
        };
        prototype.getPending = function() {
            return this._pending;
        };
        prototype.ignore = function() {
            if (this._pending == null) 
                return;
            for (var iterator$pesPacket = this._pending.iterator(); iterator$pesPacket.hasNext(); ) {
                var pesPacket = iterator$pesPacket.next();
                this.demuxer.putBack(pesPacket.data);
            }
            this._pending = null;
        };
    }, {_pending: {name: "List", arguments: ["PESPacket"]}, demuxer: "MPSDemuxer"}, {});
    constructor.MPEGTrack = function(demuxer, streamId, pkt) {
        MPSDemuxer.BaseTrack.call(this, demuxer, streamId, pkt);
        this.es = new MPEGES(this, 4096);
    };
    constructor.MPEGTrack = stjs.extend(constructor.MPEGTrack, MPSDemuxer.BaseTrack, [ReadableByteChannel], function(constructor, prototype) {
        prototype.es = null;
        prototype.isOpen = function() {
            return true;
        };
        prototype.getES = function() {
            return this.es;
        };
        prototype.close = function() {};
        prototype.read = function(arg0) {
            var pes = this._pending.size() > 0 ? this._pending.remove(0) : this.getPacket();
            if (pes == null || !pes.data.hasRemaining()) 
                return -1;
            var toRead = Math.min(arg0.remaining(), pes.data.remaining());
            arg0.putBuf(NIOUtils.read(pes.data, toRead));
            if (pes.data.hasRemaining()) 
                this._pending.add(0, pes);
             else 
                this.demuxer.putBack(pes.data);
            return toRead;
        };
        prototype.getPacket = function() {
            if (this._pending.size() > 0) 
                return this._pending.remove(0);
            var pkt;
             while ((pkt = this.demuxer.nextPacket(this.demuxer.getBuffer())) != null){
                if (pkt.streamId == this.streamId) {
                    if (pkt.pts != -1) {
                        this.es.curPts = pkt.pts;
                    }
                    return pkt;
                } else 
                    this.demuxer.addToStream(pkt);
            }
            return null;
        };
        prototype.nextFrame = function(buf) {
            return this.es.getFrame(buf);
        };
        prototype.getMeta = function() {
            var t = MPSUtils.videoStream(this.streamId) ? DemuxerTrackMeta.Type.VIDEO : (MPSUtils.audioStream(this.streamId) ? DemuxerTrackMeta.Type.AUDIO : DemuxerTrackMeta.Type.OTHER);
            return new DemuxerTrackMeta(t, Codec.MP2, null, 0, 0, null, null);
        };
    }, {es: "MPEGES", _pending: {name: "List", arguments: ["PESPacket"]}, demuxer: "MPSDemuxer"}, {});
    constructor.PlainTrack = function(demuxer, streamId, pkt) {
        MPSDemuxer.BaseTrack.call(this, demuxer, streamId, pkt);
    };
    constructor.PlainTrack = stjs.extend(constructor.PlainTrack, MPSDemuxer.BaseTrack, [], function(constructor, prototype) {
        prototype.frameNo = 0;
        prototype.isOpen = function() {
            return true;
        };
        prototype.close = function() {};
        prototype.nextFrame = function(buf) {
            var pkt;
            if (this._pending.size() > 0) {
                pkt = this._pending.remove(0);
            } else {
                 while ((pkt = this.demuxer.nextPacket(this.demuxer.getBuffer())) != null && pkt.streamId != this.streamId)
                    this.demuxer.addToStream(pkt);
            }
            return pkt == null ? null : Packet.createPacket(pkt.data, pkt.pts, 90000, 0, this.frameNo++, true, null);
        };
        prototype.getMeta = function() {
            var t = MPSUtils.videoStream(this.streamId) ? DemuxerTrackMeta.Type.VIDEO : (MPSUtils.audioStream(this.streamId) ? DemuxerTrackMeta.Type.AUDIO : DemuxerTrackMeta.Type.OTHER);
            return new DemuxerTrackMeta(t, Codec.MP2, null, 0, 0, null, null);
        };
    }, {_pending: {name: "List", arguments: ["PESPacket"]}, demuxer: "MPSDemuxer"}, {});
    prototype.seekByte = function(offset) {
        this.channel.setPosition(offset);
        this.reset();
    };
    prototype.reset = function() {
        for (var iterator$track = this.streams.values().iterator(); iterator$track.hasNext(); ) {
            var track = iterator$track.next();
            track._pending.clear();
        }
    };
    prototype.addToStream = function(pkt) {
        var pes = this.streams.get(pkt.streamId);
        if (pes == null) {
            if (this.isMPEG(pkt.data)) 
                pes = new MPSDemuxer.MPEGTrack(this, pkt.streamId, pkt);
             else 
                pes = new MPSDemuxer.PlainTrack(this, pkt.streamId, pkt);
            this.streams.put(pkt.streamId, pes);
        } else {
            pes.pending(pkt);
        }
    };
    prototype.nextPacket = function(out) {
        var dup = out.duplicate();
         while (!MPSUtils.psMarker(this.curMarker)){
            if (!this.skipToMarker()) 
                return null;
        }
        var fork = dup.duplicate();
        this.readToNextMarker(dup);
        var pkt = MPSUtils.readPESHeader(fork, this.curPos());
        if (pkt.length == 0) {
             while (!MPSUtils.psMarker(this.curMarker) && this.readToNextMarker(dup))
                ;
        } else {
            this.read(dup, pkt.length - dup.position() + 6);
        }
        fork.setLimit(dup.position());
        pkt.data = fork;
        return pkt;
    };
    prototype.getTracks = function() {
        return new ArrayList(this.streams.values());
    };
    prototype.getVideoTracks = function() {
        var result = new ArrayList();
        for (var iterator$p = this.streams.values().iterator(); iterator$p.hasNext(); ) {
            var p = iterator$p.next();
            if (MPSUtils.videoStream(p.streamId)) 
                result.add(p);
        }
        return result;
    };
    prototype.getAudioTracks = function() {
        var result = new ArrayList();
        for (var iterator$p = this.streams.values().iterator(); iterator$p.hasNext(); ) {
            var p = iterator$p.next();
            if (MPSUtils.audioStream(p.streamId)) 
                result.add(p);
        }
        return result;
    };
    prototype.isMPEG = function(_data) {
        var b = _data.duplicate();
        var marker = -1;
        var score = 0;
        var hasHeader = false, slicesStarted = false;
         while (b.hasRemaining()){
            var code = b.get() & 255;
            marker = (marker << 8) | code;
            if (marker < 256 || marker > 440) 
                continue;
            if (marker >= 432 && marker <= 440) {
                if ((hasHeader && marker != 437 && marker != 434) || slicesStarted) 
                    break;
                score += 5;
            } else if (marker == 256) {
                if (slicesStarted) 
                    break;
                hasHeader = true;
            } else if (marker > 256 && marker < 432) {
                if (!hasHeader) 
                    break;
                if (!slicesStarted) {
                    score += 50;
                    slicesStarted = true;
                }
                score += 1;
            }
        }
        return score > 50;
    };
    constructor.probe = function(b) {
        var marker = -1;
        var score = 0;
        var inVideoPes = false, hasHeader = false, slicesStarted = false, inNALUnit = false;
        var nuSeq = new ArrayList();
         while (b.hasRemaining()){
            var code = b.get() & 255;
            marker = (marker << 8) | code;
            if (inNALUnit) {
                var nu = NALUnit.read(NIOUtils.asByteBufferInt(code));
                if (nu.type != null) 
                    nuSeq.add(nu);
                inNALUnit = false;
            }
            if (inVideoPes && marker == 1) {
                inNALUnit = true;
                continue;
            } else if (marker < 256 || marker > 511) 
                continue;
            if (MPSUtils.videoMarker(marker)) {
                if (inVideoPes) 
                    break;
                 else 
                    inVideoPes = true;
            } else if (marker >= 432 && marker <= 440 && inVideoPes) {
                if ((hasHeader && marker != 437 && marker != 434) || slicesStarted) 
                    break;
                score += 5;
            } else if (marker == 256 && inVideoPes) {
                if (slicesStarted) 
                    break;
                hasHeader = true;
            } else if (marker > 256 && marker < 432) {
                if (!hasHeader) 
                    continue;
                if (!slicesStarted) {
                    score += 50;
                    slicesStarted = true;
                }
                score += 1;
            }
        }
        return !nuSeq.isEmpty() ? MPSDemuxer.rateSeq(nuSeq) : score;
    };
    constructor.rateSeq = function(nuSeq) {
        var score = 0;
        var hasSps = false, hasPps = false, hasSlice = false;
        for (var iterator$nalUnit = nuSeq.iterator(); iterator$nalUnit.hasNext(); ) {
            var nalUnit = iterator$nalUnit.next();
            if (NALUnitType.SPS == nalUnit.type) {
                if (hasSps && !hasSlice) 
                    score -= 30;
                 else 
                    score += 30;
                hasSps = true;
            } else if (NALUnitType.PPS == nalUnit.type) {
                if (hasPps && !hasSlice) 
                    score -= 30;
                if (hasSps) 
                    score += 20;
                hasPps = true;
            } else if (NALUnitType.IDR_SLICE == nalUnit.type || NALUnitType.NON_IDR_SLICE == nalUnit.type) {
                if (!hasSlice) 
                    score += 50;
                hasSlice = true;
            } else {
                score += 3;
            }
        }
        return score;
    };
}, {streams: {name: "Map", arguments: [null, "MPSDemuxer.BaseTrack"]}, channel: "SeekableByteChannel", bufPool: {name: "List", arguments: ["ByteBuffer"]}, channel: "ReadableByteChannel", buf: "ByteBuffer"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var ES = function(trackId, children) {
    NodeDescriptor.call(this, ES.tag(), children);
    this.trackId = trackId;
};
ES = stjs.extend(ES, NodeDescriptor, [], function(constructor, prototype) {
    prototype.trackId = 0;
    constructor.tag = function() {
        return 3;
    };
    prototype.doWrite = function(out) {
        out.putShort(((this.trackId) << 16 >> 16));
        out.put((0 << 24 >> 24));
        NodeDescriptor.prototype.doWrite.call(this, out);
    };
    prototype.parse = function(input) {
        this.trackId = input.getShort();
        input.get();
        NodeDescriptor.prototype.parse.call(this, input);
    };
    prototype.getTrackId = function() {
        return this.trackId;
    };
}, {children: {name: "Collection", arguments: ["Descriptor"]}, factory: "IDescriptorFactory"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var DecoderConfig = function(objectType, bufSize, maxBitrate, avgBitrate, children) {
    NodeDescriptor.call(this, DecoderConfig.tag(), children);
    this.objectType = objectType;
    this.bufSize = bufSize;
    this.maxBitrate = maxBitrate;
    this.avgBitrate = avgBitrate;
};
DecoderConfig = stjs.extend(DecoderConfig, NodeDescriptor, [], function(constructor, prototype) {
    prototype.objectType = 0;
    prototype.bufSize = 0;
    prototype.maxBitrate = 0;
    prototype.avgBitrate = 0;
    prototype.parse = function(input) {
        this.objectType = input.get() & 255;
        input.get();
        this.bufSize = ((input.get() & 255) << 16) | (input.getShort() & 65535);
        this.maxBitrate = input.getInt();
        this.avgBitrate = input.getInt();
        NodeDescriptor.prototype.parse.call(this, input);
    };
    prototype.doWrite = function(out) {
        out.put((this.objectType << 24 >> 24));
        out.put((21 << 24 >> 24));
        out.put(((this.bufSize >> 16) << 24 >> 24));
        out.putShort(((this.bufSize) << 16 >> 16));
        out.putInt(this.maxBitrate);
        out.putInt(this.avgBitrate);
        NodeDescriptor.prototype.doWrite.call(this, out);
    };
    constructor.tag = function() {
        return 4;
    };
    prototype.getObjectType = function() {
        return this.objectType;
    };
    prototype.getBufSize = function() {
        return this.bufSize;
    };
    prototype.getMaxBitrate = function() {
        return this.maxBitrate;
    };
    prototype.getAvgBitrate = function() {
        return this.avgBitrate;
    };
}, {children: {name: "Collection", arguments: ["Descriptor"]}, factory: "IDescriptorFactory"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MTSUtils = function() {};
MTSUtils = stjs.extend(MTSUtils, null, [], function(constructor, prototype) {
    /**
     *  Parses PAT ( Program Association Table )
     *  
     *  @param data
     *  @deprecated Use org.jcodec.containers.mps.psi.PAT.parse method instead,
     *              this method will not work correctly for streams with multiple
     *              programs
     *  @return Pid of the first PMT found in the PAT
     */
    constructor.parsePAT = function(data) {
        var pat = PATSection.parsePAT(data);
        if (pat.getPrograms().size() > 0) 
            return pat.getPrograms().values()[0];
         else 
            return -1;
    };
    constructor.parsePMT = function(data) {
        return PMTSection.parsePMT(data);
    };
    constructor.parseSection = function(data) {
        return PSISection.parsePSI(data);
    };
    constructor.parseEsInfo = function(read) {};
    constructor.getProgramGuids = function(src) {
        var ch = null;
        try {
            ch = NIOUtils.readableChannel(src);
            return MTSUtils.getProgramGuidsFromChannel(ch);
        } finally {
            NIOUtils.closeQuietly(ch);
        }
    };
    constructor.getProgramGuidsFromChannel = function(_in) {
        var ex = new MTSUtils.PMTExtractor();
        ex.readTsFile(_in);
        var pmt = ex.getPmt();
        return pmt.getStreams();
    };
    constructor.PMTExtractor = function() {
        MTSUtils.TSReader.call(this, false);
    };
    constructor.PMTExtractor = stjs.extend(constructor.PMTExtractor, MTSUtils.TSReader, [], function(constructor, prototype) {
        prototype.pmtGuid = -1;
        prototype.pmt = null;
        prototype.onPkt = function(guid, payloadStart, tsBuf, filePos, sectionSyntax, fullPkt) {
            if (guid == 0) {
                this.pmtGuid = MTSUtils.parsePAT(tsBuf);
            } else if (this.pmtGuid != -1 && guid == this.pmtGuid) {
                this.pmt = MTSUtils.parsePMT(tsBuf);
                return false;
            }
            return true;
        };
        prototype.getPmt = function() {
            return this.pmt;
        };
    }, {pmt: "PMTSection"}, {});
    constructor.TSReader = function(flush) {
        this.flush = flush;
    };
    constructor.TSReader = stjs.extend(constructor.TSReader, null, [], function(constructor, prototype) {
        constructor.TS_SYNC_MARKER = 71;
        constructor.TS_PKT_SIZE = 188;
        constructor.BUFFER_SIZE = MTSUtils.TSReader.TS_PKT_SIZE << 9;
        prototype.flush = false;
        prototype.readTsFile = function(ch) {
            ch.setPosition(0);
            var buf = ByteBuffer.allocate(MTSUtils.TSReader.BUFFER_SIZE);
            for (var pos = ch.position(); ch.read(buf) >= MTSUtils.TSReader.TS_PKT_SIZE; pos = ch.position()) {
                var posRem = pos;
                buf.flip();
                 while (buf.remaining() >= MTSUtils.TSReader.TS_PKT_SIZE){
                    var tsBuf = NIOUtils.read(buf, MTSUtils.TSReader.TS_PKT_SIZE);
                    var fullPkt = tsBuf.duplicate();
                    pos += MTSUtils.TSReader.TS_PKT_SIZE;
                    Assert.assertEquals(MTSUtils.TSReader.TS_SYNC_MARKER, tsBuf.get() & 255);
                    var guidFlags = ((tsBuf.get() & 255) << 8) | (tsBuf.get() & 255);
                    var guid = stjs.trunc(guidFlags) & 8191;
                    var payloadStart = (guidFlags >> 14) & 1;
                    var b0 = tsBuf.get() & 255;
                    var counter = b0 & 15;
                    if ((b0 & 32) != 0) {
                        NIOUtils.skip(tsBuf, tsBuf.get() & 255);
                    }
                    var sectionSyntax = payloadStart == 1 && (NIOUtils.getRel(tsBuf, NIOUtils.getRel(tsBuf, 0) + 2) & 128) == 128;
                    if (sectionSyntax) {
                        NIOUtils.skip(tsBuf, tsBuf.get() & 255);
                    }
                    if (!this.onPkt(guid, payloadStart == 1, tsBuf, pos - tsBuf.remaining(), sectionSyntax, fullPkt)) 
                        return;
                }
                if (this.flush) {
                    buf.flip();
                    ch.setPosition(posRem);
                    ch.write(buf);
                }
                buf.clear();
            }
        };
        prototype.onPkt = function(guid, payloadStart, tsBuf, filePos, sectionSyntax, fullPkt) {
            return true;
        };
    }, {}, {});
    constructor.getVideoPid = function(src) {
        for (var stream in MTSUtils.getProgramGuids(src)) {
            if (stream.getStreamType().isVideo()) 
                return stream.getPid();
        }
         throw new RuntimeException("No video stream");
    };
    constructor.getAudioPid = function(src) {
        for (var stream in MTSUtils.getProgramGuids(src)) {
            if (stream.getStreamType().isAudio()) 
                return stream.getPid();
        }
         throw new RuntimeException("No audio stream");
    };
    constructor.getMediaPidsFromChannel = function(src) {
        return MTSUtils.filterMediaPids(MTSUtils.getProgramGuidsFromChannel(src));
    };
    constructor.getMediaPids = function(src) {
        return MTSUtils.filterMediaPids(MTSUtils.getProgramGuids(src));
    };
    constructor.filterMediaPids = function(programs) {
        var result = IntArrayList.createIntArrayList();
        for (var stream in programs) {
            if (stream.getStreamType().isVideo() || stream.getStreamType().isAudio()) 
                result.add(stream.getPid());
        }
        return result.toArray();
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var MTSPktDump = function() {};
MTSPktDump = stjs.extend(MTSPktDump, null, [], function(constructor, prototype) {
    constructor.main1 = function(args) {
        var cmd = MainUtils.parseArguments(args);
        if (cmd.args.length < 1) {
            MainUtils.printHelpNoFlags("file name");
            return;
        }
        var ch = null;
        try {
            ch = NIOUtils.readableChannel(new File(cmd.args[0]));
            MTSPktDump.dumpTSPackets(ch);
        } finally {
            NIOUtils.closeQuietly(ch);
        }
    };
    constructor.dumpTSPackets = function(_in) {
        var buf = ByteBuffer.allocate(188 * 1024);
         while (_in.read(buf) != -1){
            buf.flip();
            buf.setLimit((stjs.trunc(buf.limit() / 188)) * 188);
            var pmtPid = -1;
            for (var pkt = 0; buf.hasRemaining(); ++pkt) {
                var tsBuf = NIOUtils.read(buf, 188);
                Assert.assertEquals(71, tsBuf.get() & 255);
                var guidFlags = ((tsBuf.get() & 255) << 8) | (tsBuf.get() & 255);
                var guid = stjs.trunc(guidFlags) & 8191;
                var payloadStart = (guidFlags >> 14) & 1;
                var b0 = tsBuf.get() & 255;
                var counter = b0 & 15;
                if ((b0 & 32) != 0) {
                    NIOUtils.skip(tsBuf, (tsBuf.get() & 255));
                }
                System.out.print("#" + pkt + "[guid: " + guid + ", cnt: " + counter + ", start: " + (payloadStart == 1 ? "y" : "-"));
                if (guid == 0 || guid == pmtPid) {
                    System.out.print(", PSI]: ");
                    if (payloadStart == 1) {
                        NIOUtils.skip(tsBuf, (tsBuf.get() & 255));
                    }
                    if (guid == 0) {
                        var pat = PATSection.parsePAT(tsBuf);
                        var programs = pat.getPrograms();
                        pmtPid = programs.values()[0];
                        MTSPktDump.printPat(pat);
                    } else if (guid == pmtPid) {
                        var pmt = PMTSection.parsePMT(tsBuf);
                        MTSPktDump.printPmt(pmt);
                    }
                } else {
                    System.out.print("]: " + tsBuf.remaining());
                }
                System.out.println();
            }
            buf.clear();
        }
    };
    constructor.printPat = function(pat) {
        var programs = pat.getPrograms();
        System.out.print("PAT: ");
        var keys = programs.keys();
        for (var i in keys) {
            System.out.print(i + ":" + programs.get(i) + ", ");
        }
    };
    constructor.printPmt = function(pmt) {
        System.out.print("PMT: ");
        for (var pmtStream in pmt.getStreams()) {
            System.out.print(pmtStream.getPid() + ":" + pmtStream.getStreamTypeTag() + ", ");
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A writer for slice header data structure
 *  
 *  @author The JCodec project
 *  
 */
var SliceHeaderWriter = function() {};
SliceHeaderWriter = stjs.extend(SliceHeaderWriter, null, [], function(constructor, prototype) {
    prototype.write = function(sliceHeader, idrSlice, nalRefIdc, writer) {
        var sps = sliceHeader.sps;
        var pps = sliceHeader.pps;
        CAVLCWriter.writeUEtrace(writer, sliceHeader.first_mb_in_slice, "SH: first_mb_in_slice");
        CAVLCWriter.writeUEtrace(writer, sliceHeader.slice_type.ordinal() + (sliceHeader.slice_type_restr ? 5 : 0), "SH: slice_type");
        CAVLCWriter.writeUEtrace(writer, sliceHeader.pic_parameter_set_id, "SH: pic_parameter_set_id");
        if (sliceHeader.frame_num > (1 << (sps.log2_max_frame_num_minus4 + 4))) {
             throw new IllegalArgumentException("frame_num > " + (1 << (sps.log2_max_frame_num_minus4 + 4)));
        }
        CAVLCWriter.writeUtrace(writer, sliceHeader.frame_num, sps.log2_max_frame_num_minus4 + 4, "SH: frame_num");
        if (!sps.frame_mbs_only_flag) {
            CAVLCWriter.writeBool(writer, sliceHeader.field_pic_flag, "SH: field_pic_flag");
            if (sliceHeader.field_pic_flag) {
                CAVLCWriter.writeBool(writer, sliceHeader.bottom_field_flag, "SH: bottom_field_flag");
            }
        }
        if (idrSlice) {
            CAVLCWriter.writeUEtrace(writer, sliceHeader.idr_pic_id, "SH: idr_pic_id");
        }
        if (sps.pic_order_cnt_type == 0) {
            if (sliceHeader.pic_order_cnt_lsb > (1 << (sps.log2_max_pic_order_cnt_lsb_minus4 + 4))) {
                 throw new IllegalArgumentException("pic_order_cnt_lsb > " + (1 << (sps.log2_max_pic_order_cnt_lsb_minus4 + 4)));
            }
            CAVLCWriter.writeU(writer, sliceHeader.pic_order_cnt_lsb, sps.log2_max_pic_order_cnt_lsb_minus4 + 4);
            if (pps.pic_order_present_flag && !sps.field_pic_flag) {
                CAVLCWriter.writeSEtrace(writer, sliceHeader.delta_pic_order_cnt_bottom, "SH: delta_pic_order_cnt_bottom");
            }
        }
        if (sps.pic_order_cnt_type == 1 && !sps.delta_pic_order_always_zero_flag) {
            CAVLCWriter.writeSEtrace(writer, sliceHeader.delta_pic_order_cnt[0], "SH: delta_pic_order_cnt");
            if (pps.pic_order_present_flag && !sps.field_pic_flag) 
                CAVLCWriter.writeSEtrace(writer, sliceHeader.delta_pic_order_cnt[1], "SH: delta_pic_order_cnt");
        }
        if (pps.redundant_pic_cnt_present_flag) {
            CAVLCWriter.writeUEtrace(writer, sliceHeader.redundant_pic_cnt, "SH: redundant_pic_cnt");
        }
        if (sliceHeader.slice_type == SliceType.B) {
            CAVLCWriter.writeBool(writer, sliceHeader.direct_spatial_mv_pred_flag, "SH: direct_spatial_mv_pred_flag");
        }
        if (sliceHeader.slice_type == SliceType.P || sliceHeader.slice_type == SliceType.SP || sliceHeader.slice_type == SliceType.B) {
            CAVLCWriter.writeBool(writer, sliceHeader.num_ref_idx_active_override_flag, "SH: num_ref_idx_active_override_flag");
            if (sliceHeader.num_ref_idx_active_override_flag) {
                CAVLCWriter.writeUEtrace(writer, sliceHeader.num_ref_idx_active_minus1[0], "SH: num_ref_idx_l0_active_minus1");
                if (sliceHeader.slice_type == SliceType.B) {
                    CAVLCWriter.writeUEtrace(writer, sliceHeader.num_ref_idx_active_minus1[1], "SH: num_ref_idx_l1_active_minus1");
                }
            }
        }
        this.writeRefPicListReordering(sliceHeader, writer);
        if ((pps.weighted_pred_flag && (sliceHeader.slice_type == SliceType.P || sliceHeader.slice_type == SliceType.SP)) || (pps.weighted_bipred_idc == 1 && sliceHeader.slice_type == SliceType.B)) 
            this.writePredWeightTable(sliceHeader, writer);
        if (nalRefIdc != 0) 
            this.writeDecRefPicMarking(sliceHeader, idrSlice, writer);
        if (pps.entropy_coding_mode_flag && sliceHeader.slice_type.isInter()) {
            CAVLCWriter.writeUEtrace(writer, sliceHeader.cabac_init_idc, "SH: cabac_init_idc");
        }
        CAVLCWriter.writeSEtrace(writer, sliceHeader.slice_qp_delta, "SH: slice_qp_delta");
        if (sliceHeader.slice_type == SliceType.SP || sliceHeader.slice_type == SliceType.SI) {
            if (sliceHeader.slice_type == SliceType.SP) {
                CAVLCWriter.writeBool(writer, sliceHeader.sp_for_switch_flag, "SH: sp_for_switch_flag");
            }
            CAVLCWriter.writeSEtrace(writer, sliceHeader.slice_qs_delta, "SH: slice_qs_delta");
        }
        if (pps.deblocking_filter_control_present_flag) {
            CAVLCWriter.writeUEtrace(writer, sliceHeader.disable_deblocking_filter_idc, "SH: disable_deblocking_filter_idc");
            if (sliceHeader.disable_deblocking_filter_idc != 1) {
                CAVLCWriter.writeSEtrace(writer, sliceHeader.slice_alpha_c0_offset_div2, "SH: slice_alpha_c0_offset_div2");
                CAVLCWriter.writeSEtrace(writer, sliceHeader.slice_beta_offset_div2, "SH: slice_beta_offset_div2");
            }
        }
        if (pps.num_slice_groups_minus1 > 0 && pps.slice_group_map_type >= 3 && pps.slice_group_map_type <= 5) {
            var len = stjs.trunc((sps.pic_height_in_map_units_minus1 + 1) * (sps.pic_width_in_mbs_minus1 + 1) / (pps.slice_group_change_rate_minus1 + 1));
            if (((sps.pic_height_in_map_units_minus1 + 1) * (sps.pic_width_in_mbs_minus1 + 1)) % (pps.slice_group_change_rate_minus1 + 1) > 0) 
                len += 1;
            len = SliceHeaderWriter.CeilLog2(len + 1);
            CAVLCWriter.writeU(writer, sliceHeader.slice_group_change_cycle, len);
        }
    };
    constructor.CeilLog2 = function(uiVal) {
        var uiTmp = uiVal - 1;
        var uiRet = 0;
         while (uiTmp != 0){
            uiTmp >>= 1;
            uiRet++;
        }
        return uiRet;
    };
    prototype.writeDecRefPicMarking = function(sliceHeader, idrSlice, writer) {
        if (idrSlice) {
            var drpmidr = sliceHeader.refPicMarkingIDR;
            CAVLCWriter.writeBool(writer, drpmidr.isDiscardDecodedPics(), "SH: no_output_of_prior_pics_flag");
            CAVLCWriter.writeBool(writer, drpmidr.isUseForlongTerm(), "SH: long_term_reference_flag");
        } else {
            CAVLCWriter.writeBool(writer, sliceHeader.refPicMarkingNonIDR != null, "SH: adaptive_ref_pic_marking_mode_flag");
            if (sliceHeader.refPicMarkingNonIDR != null) {
                var drpmidr = sliceHeader.refPicMarkingNonIDR;
                var instructions = drpmidr.getInstructions();
                for (var i = 0; i < instructions.length; i++) {
                    var mmop = instructions[i];
                    switch (mmop.getType()) {
                        case RefPicMarking.InstrType.REMOVE_SHORT:
                            CAVLCWriter.writeUEtrace(writer, 1, "SH: memory_management_control_operation");
                            CAVLCWriter.writeUEtrace(writer, mmop.getArg1() - 1, "SH: difference_of_pic_nums_minus1");
                            break;
                        case RefPicMarking.InstrType.REMOVE_LONG:
                            CAVLCWriter.writeUEtrace(writer, 2, "SH: memory_management_control_operation");
                            CAVLCWriter.writeUEtrace(writer, mmop.getArg1(), "SH: long_term_pic_num");
                            break;
                        case RefPicMarking.InstrType.CONVERT_INTO_LONG:
                            CAVLCWriter.writeUEtrace(writer, 3, "SH: memory_management_control_operation");
                            CAVLCWriter.writeUEtrace(writer, mmop.getArg1() - 1, "SH: difference_of_pic_nums_minus1");
                            CAVLCWriter.writeUEtrace(writer, mmop.getArg2(), "SH: long_term_frame_idx");
                            break;
                        case RefPicMarking.InstrType.TRUNK_LONG:
                            CAVLCWriter.writeUEtrace(writer, 4, "SH: memory_management_control_operation");
                            CAVLCWriter.writeUEtrace(writer, mmop.getArg1() + 1, "SH: max_long_term_frame_idx_plus1");
                            break;
                        case RefPicMarking.InstrType.CLEAR:
                            CAVLCWriter.writeUEtrace(writer, 5, "SH: memory_management_control_operation");
                            break;
                        case RefPicMarking.InstrType.MARK_LONG:
                            CAVLCWriter.writeUEtrace(writer, 6, "SH: memory_management_control_operation");
                            CAVLCWriter.writeUEtrace(writer, mmop.getArg1(), "SH: long_term_frame_idx");
                            break;
                    }
                }
                CAVLCWriter.writeUEtrace(writer, 0, "SH: memory_management_control_operation");
            }
        }
    };
    prototype.writePredWeightTable = function(sliceHeader, writer) {
        var sps = sliceHeader.sps;
        CAVLCWriter.writeUEtrace(writer, sliceHeader.pred_weight_table.luma_log2_weight_denom, "SH: luma_log2_weight_denom");
        if (sps.chroma_format_idc != ColorSpace.MONO) {
            CAVLCWriter.writeUEtrace(writer, sliceHeader.pred_weight_table.chroma_log2_weight_denom, "SH: chroma_log2_weight_denom");
        }
        this.writeOffsetWeight(sliceHeader, writer, 0);
        if (sliceHeader.slice_type == SliceType.B) {
            this.writeOffsetWeight(sliceHeader, writer, 1);
        }
    };
    prototype.writeOffsetWeight = function(sliceHeader, writer, list) {
        var sps = sliceHeader.sps;
        var defaultLW = 1 << sliceHeader.pred_weight_table.luma_log2_weight_denom;
        var defaultCW = 1 << sliceHeader.pred_weight_table.chroma_log2_weight_denom;
        for (var i = 0; i < sliceHeader.pred_weight_table.luma_weight[list].length; i++) {
            var flagLuma = sliceHeader.pred_weight_table.luma_weight[list][i] != defaultLW || sliceHeader.pred_weight_table.luma_offset[list][i] != 0;
            CAVLCWriter.writeBool(writer, flagLuma, "SH: luma_weight_l0_flag");
            if (flagLuma) {
                CAVLCWriter.writeSEtrace(writer, sliceHeader.pred_weight_table.luma_weight[list][i], "SH: luma_weight_l" + list);
                CAVLCWriter.writeSEtrace(writer, sliceHeader.pred_weight_table.luma_offset[list][i], "SH: luma_offset_l" + list);
            }
            if (sps.chroma_format_idc != ColorSpace.MONO) {
                var flagChroma = sliceHeader.pred_weight_table.chroma_weight[list][0][i] != defaultCW || sliceHeader.pred_weight_table.chroma_offset[list][0][i] != 0 || sliceHeader.pred_weight_table.chroma_weight[list][1][i] != defaultCW || sliceHeader.pred_weight_table.chroma_offset[list][1][i] != 0;
                CAVLCWriter.writeBool(writer, flagChroma, "SH: chroma_weight_l0_flag");
                if (flagChroma) 
                    for (var j = 0; j < 2; j++) {
                        CAVLCWriter.writeSEtrace(writer, sliceHeader.pred_weight_table.chroma_weight[list][j][i], "SH: chroma_weight_l" + list);
                        CAVLCWriter.writeSEtrace(writer, sliceHeader.pred_weight_table.chroma_offset[list][j][i], "SH: chroma_offset_l" + list);
                    }
            }
        }
    };
    prototype.writeRefPicListReordering = function(sliceHeader, writer) {
        if (sliceHeader.slice_type.isInter()) {
            var l0ReorderingPresent = sliceHeader.refPicReordering != null && sliceHeader.refPicReordering[0] != null;
            CAVLCWriter.writeBool(writer, l0ReorderingPresent, "SH: ref_pic_list_reordering_flag_l0");
            if (l0ReorderingPresent) 
                this.writeReorderingList(sliceHeader.refPicReordering[0], writer);
        }
        if (sliceHeader.slice_type == SliceType.B) {
            var l1ReorderingPresent = sliceHeader.refPicReordering != null && sliceHeader.refPicReordering[1] != null;
            CAVLCWriter.writeBool(writer, l1ReorderingPresent, "SH: ref_pic_list_reordering_flag_l1");
            if (l1ReorderingPresent) 
                this.writeReorderingList(sliceHeader.refPicReordering[1], writer);
        }
    };
    prototype.writeReorderingList = function(reordering, writer) {
        if (reordering == null) 
            return;
        for (var i = 0; i < reordering[0].length; i++) {
            CAVLCWriter.writeUEtrace(writer, reordering[0][i], "SH: reordering_of_pic_nums_idc");
            CAVLCWriter.writeUEtrace(writer, reordering[1][i], "SH: abs_diff_pic_num_minus1");
        }
        CAVLCWriter.writeUEtrace(writer, 3, "SH: reordering_of_pic_nums_idc");
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  POC ( Picture Order Count ) manager
 *  
 *  Picture Order Count is used to represent an order of picture in a GOP ( Group
 *  of Pictures ) this is needed to correctly reorder and B-framed GOPs. POC is
 *  also used when building lists of reference pictures ( see 8.2.4.2 ).
 *  
 *  There are 3 possible ways of assigning POC to decoded pictures:
 *  
 *  - Explicit, i.e. POC is directly specified in a slice header in form <POC
 *  Pred> + <POC Dec>. <POC Pred> is a significant part of POC ( see 8.2.1.1 ). -
 *  Frame based type 1 ( see 8.2.1.2 ). - Frame based type 2 ( see 8.2.1.3 ).
 *  
 *  @author The JCodec project
 *  
 */
var POCManager = function() {};
POCManager = stjs.extend(POCManager, null, [], function(constructor, prototype) {
    prototype.prevPOCMsb = 0;
    prototype.prevPOCLsb = 0;
    prototype.calcPOC = function(firstSliceHeader, firstNu) {
        switch (firstSliceHeader.sps.pic_order_cnt_type) {
            case 0:
                return this.calcPOC0(firstSliceHeader, firstNu);
            case 1:
                return this.calcPOC1(firstSliceHeader, firstNu);
            case 2:
                return this.calcPOC2(firstSliceHeader, firstNu);
            default:
                 throw new RuntimeException("POC no!!!");
        }
    };
    prototype.calcPOC2 = function(firstSliceHeader, firstNu) {
        return firstSliceHeader.frame_num << 1;
    };
    prototype.calcPOC1 = function(firstSliceHeader, firstNu) {
        return firstSliceHeader.frame_num << 1;
    };
    prototype.calcPOC0 = function(firstSliceHeader, firstNu) {
        if (firstNu.type == NALUnitType.IDR_SLICE) {
            this.prevPOCMsb = this.prevPOCLsb = 0;
        }
        var maxPOCLsbDiv2 = 1 << (firstSliceHeader.sps.log2_max_pic_order_cnt_lsb_minus4 + 3), maxPOCLsb = maxPOCLsbDiv2 << 1;
        var POCLsb = firstSliceHeader.pic_order_cnt_lsb;
        var POCMsb, POC;
        if ((POCLsb < this.prevPOCLsb) && ((this.prevPOCLsb - POCLsb) >= maxPOCLsbDiv2)) 
            POCMsb = this.prevPOCMsb + maxPOCLsb;
         else if ((POCLsb > this.prevPOCLsb) && ((POCLsb - this.prevPOCLsb) > maxPOCLsbDiv2)) 
            POCMsb = this.prevPOCMsb - maxPOCLsb;
         else 
            POCMsb = this.prevPOCMsb;
        POC = POCMsb + POCLsb;
        if (firstNu.nal_ref_idc > 0) {
            if (this.hasMMCO5(firstSliceHeader, firstNu)) {
                this.prevPOCMsb = 0;
                this.prevPOCLsb = POC;
            } else {
                this.prevPOCMsb = POCMsb;
                this.prevPOCLsb = POCLsb;
            }
        }
        return POC;
    };
    prototype.hasMMCO5 = function(firstSliceHeader, firstNu) {
        if (firstNu.type != NALUnitType.IDR_SLICE && firstSliceHeader.refPicMarkingNonIDR != null) {
            var instructions = firstSliceHeader.refPicMarkingNonIDR.getInstructions();
            for (var i = 0; i < instructions.length; i++) {
                var instruction = instructions[i];
                if (instruction.getType() == RefPicMarking.InstrType.CLEAR) 
                    return true;
            }
        }
        return false;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Reads header of the coded slice
 *  
 *  @author The JCodec project
 *  
 */
var SliceHeaderReader = function() {};
SliceHeaderReader = stjs.extend(SliceHeaderReader, null, [], function(constructor, prototype) {
    prototype.readPart1 = function(_in) {
        var sh = new SliceHeader();
        sh.first_mb_in_slice = CAVLCReader.readUEtrace(_in, "SH: first_mb_in_slice");
        var sh_type = CAVLCReader.readUEtrace(_in, "SH: slice_type");
        sh.slice_type = SliceType.fromValue(sh_type % 5);
        sh.slice_type_restr = (stjs.trunc(sh_type / 5)) > 0;
        sh.pic_parameter_set_id = CAVLCReader.readUEtrace(_in, "SH: pic_parameter_set_id");
        return sh;
    };
    prototype.readPart2 = function(sh, nalUnit, sps, pps, _in) {
        sh.pps = pps;
        sh.sps = sps;
        sh.frame_num = CAVLCReader.readU(_in, sps.log2_max_frame_num_minus4 + 4, "SH: frame_num");
        if (!sps.frame_mbs_only_flag) {
            sh.field_pic_flag = CAVLCReader.readBool(_in, "SH: field_pic_flag");
            if (sh.field_pic_flag) {
                sh.bottom_field_flag = CAVLCReader.readBool(_in, "SH: bottom_field_flag");
            }
        }
        if (nalUnit.type == NALUnitType.IDR_SLICE) {
            sh.idr_pic_id = CAVLCReader.readUEtrace(_in, "SH: idr_pic_id");
        }
        if (sps.pic_order_cnt_type == 0) {
            sh.pic_order_cnt_lsb = CAVLCReader.readU(_in, sps.log2_max_pic_order_cnt_lsb_minus4 + 4, "SH: pic_order_cnt_lsb");
            if (pps.pic_order_present_flag && !sps.field_pic_flag) {
                sh.delta_pic_order_cnt_bottom = CAVLCReader.readSE(_in, "SH: delta_pic_order_cnt_bottom");
            }
        }
        sh.delta_pic_order_cnt = new Int32Array(2);
        if (sps.pic_order_cnt_type == 1 && !sps.delta_pic_order_always_zero_flag) {
            sh.delta_pic_order_cnt[0] = CAVLCReader.readSE(_in, "SH: delta_pic_order_cnt[0]");
            if (pps.pic_order_present_flag && !sps.field_pic_flag) 
                sh.delta_pic_order_cnt[1] = CAVLCReader.readSE(_in, "SH: delta_pic_order_cnt[1]");
        }
        if (pps.redundant_pic_cnt_present_flag) {
            sh.redundant_pic_cnt = CAVLCReader.readUEtrace(_in, "SH: redundant_pic_cnt");
        }
        if (sh.slice_type == SliceType.B) {
            sh.direct_spatial_mv_pred_flag = CAVLCReader.readBool(_in, "SH: direct_spatial_mv_pred_flag");
        }
        if (sh.slice_type == SliceType.P || sh.slice_type == SliceType.SP || sh.slice_type == SliceType.B) {
            sh.num_ref_idx_active_override_flag = CAVLCReader.readBool(_in, "SH: num_ref_idx_active_override_flag");
            if (sh.num_ref_idx_active_override_flag) {
                sh.num_ref_idx_active_minus1[0] = CAVLCReader.readUEtrace(_in, "SH: num_ref_idx_l0_active_minus1");
                if (sh.slice_type == SliceType.B) {
                    sh.num_ref_idx_active_minus1[1] = CAVLCReader.readUEtrace(_in, "SH: num_ref_idx_l1_active_minus1");
                }
            }
        }
        SliceHeaderReader.readRefPicListReordering(sh, _in);
        if ((pps.weighted_pred_flag && (sh.slice_type == SliceType.P || sh.slice_type == SliceType.SP)) || (pps.weighted_bipred_idc == 1 && sh.slice_type == SliceType.B)) 
            SliceHeaderReader.readPredWeightTable(sps, pps, sh, _in);
        if (nalUnit.nal_ref_idc != 0) 
            SliceHeaderReader.readDecoderPicMarking(nalUnit, sh, _in);
        if (pps.entropy_coding_mode_flag && sh.slice_type.isInter()) {
            sh.cabac_init_idc = CAVLCReader.readUEtrace(_in, "SH: cabac_init_idc");
        }
        sh.slice_qp_delta = CAVLCReader.readSE(_in, "SH: slice_qp_delta");
        if (sh.slice_type == SliceType.SP || sh.slice_type == SliceType.SI) {
            if (sh.slice_type == SliceType.SP) {
                sh.sp_for_switch_flag = CAVLCReader.readBool(_in, "SH: sp_for_switch_flag");
            }
            sh.slice_qs_delta = CAVLCReader.readSE(_in, "SH: slice_qs_delta");
        }
        if (pps.deblocking_filter_control_present_flag) {
            sh.disable_deblocking_filter_idc = CAVLCReader.readUEtrace(_in, "SH: disable_deblocking_filter_idc");
            if (sh.disable_deblocking_filter_idc != 1) {
                sh.slice_alpha_c0_offset_div2 = CAVLCReader.readSE(_in, "SH: slice_alpha_c0_offset_div2");
                sh.slice_beta_offset_div2 = CAVLCReader.readSE(_in, "SH: slice_beta_offset_div2");
            }
        }
        if (pps.num_slice_groups_minus1 > 0 && pps.slice_group_map_type >= 3 && pps.slice_group_map_type <= 5) {
            var len = stjs.trunc(SeqParameterSet.getPicHeightInMbs(sps) * (sps.pic_width_in_mbs_minus1 + 1) / (pps.slice_group_change_rate_minus1 + 1));
            if ((SeqParameterSet.getPicHeightInMbs(sps) * (sps.pic_width_in_mbs_minus1 + 1)) % (pps.slice_group_change_rate_minus1 + 1) > 0) 
                len += 1;
            len = SliceHeaderReader.CeilLog2(len + 1);
            sh.slice_group_change_cycle = CAVLCReader.readU(_in, len, "SH: slice_group_change_cycle");
        }
        return sh;
    };
    constructor.CeilLog2 = function(uiVal) {
        var uiTmp = uiVal - 1;
        var uiRet = 0;
         while (uiTmp != 0){
            uiTmp >>= 1;
            uiRet++;
        }
        return uiRet;
    };
    constructor.readDecoderPicMarking = function(nalUnit, sh, _in) {
        if (nalUnit.type == NALUnitType.IDR_SLICE) {
            var no_output_of_prior_pics_flag = CAVLCReader.readBool(_in, "SH: no_output_of_prior_pics_flag");
            var long_term_reference_flag = CAVLCReader.readBool(_in, "SH: long_term_reference_flag");
            sh.refPicMarkingIDR = new RefPicMarkingIDR(no_output_of_prior_pics_flag, long_term_reference_flag);
        } else {
            var adaptive_ref_pic_marking_mode_flag = CAVLCReader.readBool(_in, "SH: adaptive_ref_pic_marking_mode_flag");
            if (adaptive_ref_pic_marking_mode_flag) {
                var mmops = new ArrayList();
                var memory_management_control_operation;
                do {
                    memory_management_control_operation = CAVLCReader.readUEtrace(_in, "SH: memory_management_control_operation");
                    var instr = null;
                    switch (memory_management_control_operation) {
                        case 1:
                            instr = new RefPicMarking.Instruction(RefPicMarking.InstrType.REMOVE_SHORT, CAVLCReader.readUEtrace(_in, "SH: difference_of_pic_nums_minus1") + 1, 0);
                            break;
                        case 2:
                            instr = new RefPicMarking.Instruction(RefPicMarking.InstrType.REMOVE_LONG, CAVLCReader.readUEtrace(_in, "SH: long_term_pic_num"), 0);
                            break;
                        case 3:
                            instr = new RefPicMarking.Instruction(RefPicMarking.InstrType.CONVERT_INTO_LONG, CAVLCReader.readUEtrace(_in, "SH: difference_of_pic_nums_minus1") + 1, CAVLCReader.readUEtrace(_in, "SH: long_term_frame_idx"));
                            break;
                        case 4:
                            instr = new RefPicMarking.Instruction(RefPicMarking.InstrType.TRUNK_LONG, CAVLCReader.readUEtrace(_in, "SH: max_long_term_frame_idx_plus1") - 1, 0);
                            break;
                        case 5:
                            instr = new RefPicMarking.Instruction(RefPicMarking.InstrType.CLEAR, 0, 0);
                            break;
                        case 6:
                            instr = new RefPicMarking.Instruction(RefPicMarking.InstrType.MARK_LONG, CAVLCReader.readUEtrace(_in, "SH: long_term_frame_idx"), 0);
                            break;
                    }
                    if (instr != null) 
                        mmops.add(instr);
                } while (memory_management_control_operation != 0);
                sh.refPicMarkingNonIDR = new RefPicMarking(mmops.toArray([]));
            }
        }
    };
    constructor.readPredWeightTable = function(sps, pps, sh, _in) {
        sh.pred_weight_table = new PredictionWeightTable();
        var numRefsMinus1 = sh.num_ref_idx_active_override_flag ? sh.num_ref_idx_active_minus1 : pps.num_ref_idx_active_minus1;
        var nr = new Int32Array([numRefsMinus1[0] + 1, numRefsMinus1[1] + 1]);
        sh.pred_weight_table.luma_log2_weight_denom = CAVLCReader.readUEtrace(_in, "SH: luma_log2_weight_denom");
        if (sps.chroma_format_idc != ColorSpace.MONO) {
            sh.pred_weight_table.chroma_log2_weight_denom = CAVLCReader.readUEtrace(_in, "SH: chroma_log2_weight_denom");
        }
        var defaultLW = 1 << sh.pred_weight_table.luma_log2_weight_denom;
        var defaultCW = 1 << sh.pred_weight_table.chroma_log2_weight_denom;
        for (var list = 0; list < 2; list++) {
            sh.pred_weight_table.luma_weight[list] = new Int32Array(nr[list]);
            sh.pred_weight_table.luma_offset[list] = new Int32Array(nr[list]);
            sh.pred_weight_table.chroma_weight[list] = Array.apply(null, Array(2)).map(function() {
                return new Int32Array(nr[list]);
            });
            sh.pred_weight_table.chroma_offset[list] = Array.apply(null, Array(2)).map(function() {
                return new Int32Array(nr[list]);
            });
            for (var i = 0; i < nr[list]; i++) {
                sh.pred_weight_table.luma_weight[list][i] = defaultLW;
                sh.pred_weight_table.luma_offset[list][i] = 0;
                sh.pred_weight_table.chroma_weight[list][0][i] = defaultCW;
                sh.pred_weight_table.chroma_offset[list][0][i] = 0;
                sh.pred_weight_table.chroma_weight[list][1][i] = defaultCW;
                sh.pred_weight_table.chroma_offset[list][1][i] = 0;
            }
        }
        SliceHeaderReader.readWeightOffset(sps, pps, sh, _in, nr, 0);
        if (sh.slice_type == SliceType.B) {
            SliceHeaderReader.readWeightOffset(sps, pps, sh, _in, nr, 1);
        }
    };
    constructor.readWeightOffset = function(sps, pps, sh, _in, numRefs, list) {
        for (var i = 0; i < numRefs[list]; i++) {
            var luma_weight_l0_flag = CAVLCReader.readBool(_in, "SH: luma_weight_l0_flag");
            if (luma_weight_l0_flag) {
                sh.pred_weight_table.luma_weight[list][i] = CAVLCReader.readSE(_in, "SH: weight");
                sh.pred_weight_table.luma_offset[list][i] = CAVLCReader.readSE(_in, "SH: offset");
            }
            if (sps.chroma_format_idc != ColorSpace.MONO) {
                var chroma_weight_l0_flag = CAVLCReader.readBool(_in, "SH: chroma_weight_l0_flag");
                if (chroma_weight_l0_flag) {
                    sh.pred_weight_table.chroma_weight[list][0][i] = CAVLCReader.readSE(_in, "SH: weight");
                    sh.pred_weight_table.chroma_offset[list][0][i] = CAVLCReader.readSE(_in, "SH: offset");
                    sh.pred_weight_table.chroma_weight[list][1][i] = CAVLCReader.readSE(_in, "SH: weight");
                    sh.pred_weight_table.chroma_offset[list][1][i] = CAVLCReader.readSE(_in, "SH: offset");
                }
            }
        }
    };
    constructor.readRefPicListReordering = function(sh, _in) {
        sh.refPicReordering = Array(2);
        if (sh.slice_type.isInter()) {
            var ref_pic_list_reordering_flag_l0 = CAVLCReader.readBool(_in, "SH: ref_pic_list_reordering_flag_l0");
            if (ref_pic_list_reordering_flag_l0) {
                sh.refPicReordering[0] = SliceHeaderReader.readReorderingEntries(_in);
            }
        }
        if (sh.slice_type == SliceType.B) {
            var ref_pic_list_reordering_flag_l1 = CAVLCReader.readBool(_in, "SH: ref_pic_list_reordering_flag_l1");
            if (ref_pic_list_reordering_flag_l1) {
                sh.refPicReordering[1] = SliceHeaderReader.readReorderingEntries(_in);
            }
        }
    };
    constructor.readReorderingEntries = function(_in) {
        var ops = IntArrayList.createIntArrayList();
        var args = IntArrayList.createIntArrayList();
        do {
            var idc = CAVLCReader.readUEtrace(_in, "SH: reordering_of_pic_nums_idc");
            if (idc == 3) 
                break;
            ops.add(idc);
            args.add(CAVLCReader.readUEtrace(_in, "SH: abs_diff_pic_num_minus1"));
        } while (true);
        return [ops.toArray(), args.toArray()];
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Demuxer for MPEG Program Stream format with random access
 *  
 *  Uses index to assist random access, see MPSIndexer
 *  
 *  @author The JCodec project
 *  
 */
var MPSRandomAccessDemuxer = function(ch, mpsIndex) {
    this.pesTokens = mpsIndex.getPesTokens();
    this.pesStreamIds = mpsIndex.getPesStreamIds().flattern();
    var streamIndices = mpsIndex.getStreams();
    this.streams = Array(streamIndices.length);
    for (var i = 0; i < streamIndices.length; i++) {
        this.streams[i] = this.newStream(ch, streamIndices[i]);
    }
};
MPSRandomAccessDemuxer = stjs.extend(MPSRandomAccessDemuxer, null, [], function(constructor, prototype) {
    prototype.streams = null;
    prototype.pesTokens = null;
    prototype.pesStreamIds = null;
    prototype.newStream = function(ch, streamIndex) {
        return new MPSRandomAccessDemuxer.Stream(this, streamIndex, ch);
    };
    prototype.getStreams = function() {
        return this.streams;
    };
    constructor.Stream = function(demuxer, streamIndex, source) {
        MPSIndex.MPSStreamIndex.call(this, streamIndex.streamId, streamIndex.fsizes, streamIndex.fpts, streamIndex.fdur, streamIndex.sync);
        this.demuxer = demuxer;
        this.source = source;
        this.foffs = Array(this.fsizes.length);
        var curOff = 0;
        for (var i = 0; i < this.fsizes.length; i++) {
            this.foffs[i] = curOff;
            curOff += this.fsizes[i];
        }
        var seg = Platform.copyOfInt(streamIndex.getFpts(), 100);
        Arrays.sort(seg);
        this._seekToFrame = 0;
        this.seekToFrame();
    };
    constructor.Stream = stjs.extend(constructor.Stream, MPSIndex.MPSStreamIndex, [SeekableDemuxerTrack], function(constructor, prototype) {
        constructor.MPEG_TIMESCALE = 90000;
        prototype.curPesIdx = 0;
        prototype.curFrame = 0;
        prototype.pesBuf = null;
        prototype._seekToFrame = -1;
        prototype.source = null;
        prototype.foffs = null;
        prototype.demuxer = null;
        prototype.nextFrame = function() {
            this.seekToFrame();
            if (this.curFrame >= this.fsizes.length) 
                return null;
            var fs = this.fsizes[this.curFrame];
            var result = ByteBuffer.allocate(fs);
            return this._nextFrame(result);
        };
        prototype._nextFrame = function(buf) {
            this.seekToFrame();
            if (this.curFrame >= this.fsizes.length) 
                return null;
            var fs = this.fsizes[this.curFrame];
            var result = buf.duplicate();
            result.setLimit(result.position() + fs);
             while (result.hasRemaining()){
                if (this.pesBuf.hasRemaining()) {
                    result.putBuf(NIOUtils.read(this.pesBuf, Math.min(this.pesBuf.remaining(), result.remaining())));
                } else {
                    ++this.curPesIdx;
                    var posShift = 0;
                     while (this.demuxer.pesStreamIds[this.curPesIdx] != this.streamId){
                        posShift += MPSIndex.pesLen(this.demuxer.pesTokens[this.curPesIdx]) + MPSIndex.leadingSize(this.demuxer.pesTokens[this.curPesIdx]);
                        ++this.curPesIdx;
                    }
                    this.skip(posShift + MPSIndex.leadingSize(this.demuxer.pesTokens[this.curPesIdx]));
                    var pesLen = MPSIndex.pesLen(this.demuxer.pesTokens[this.curPesIdx]);
                    this.pesBuf = this.fetch(pesLen);
                    MPSUtils.readPESHeader(this.pesBuf, 0);
                }
            }
            result.flip();
            var pkt = Packet.createPacket(result, this.fpts[this.curFrame], MPSRandomAccessDemuxer.Stream.MPEG_TIMESCALE, this.fdur[this.curFrame], this.curFrame, this.sync.length == 0 || Arrays.binarySearch(this.sync, this.curFrame) >= 0, null);
            this.curFrame++;
            return pkt;
        };
        prototype.fetch = function(pesLen) {
            return NIOUtils.fetchFromChannel(this.source, pesLen);
        };
        prototype.skip = function(leadingSize) {
            this.source.setPosition(this.source.position() + leadingSize);
        };
        prototype.reset = function() {
            this.source.setPosition(0);
        };
        prototype.getMeta = function() {
            return null;
        };
        prototype.gotoFrame = function(frameNo) {
            this._seekToFrame = ((frameNo) | 0);
            return true;
        };
        prototype.gotoSyncFrame = function(frameNo) {
            for (var i = 0; i < this.sync.length; i++) {
                if (this.sync[i] > frameNo) {
                    this._seekToFrame = this.sync[i - 1];
                    return true;
                }
            }
            this._seekToFrame = this.sync[this.sync.length - 1];
            return true;
        };
        prototype.seekToFrame = function() {
            if (this._seekToFrame == -1) 
                return;
            this.curFrame = this._seekToFrame;
            var payloadOff = this.foffs[this.curFrame];
            var posShift = 0;
            this.reset();
            for (this.curPesIdx = 0; ; this.curPesIdx++) {
                if (this.demuxer.pesStreamIds[this.curPesIdx] == this.streamId) {
                    var payloadSize = MPSIndex.payLoadSize(this.demuxer.pesTokens[this.curPesIdx]);
                    if (payloadOff < payloadSize) 
                        break;
                    payloadOff -= payloadSize;
                }
                posShift += MPSIndex.pesLen(this.demuxer.pesTokens[this.curPesIdx]) + MPSIndex.leadingSize(this.demuxer.pesTokens[this.curPesIdx]);
            }
            this.skip(posShift + MPSIndex.leadingSize(this.demuxer.pesTokens[this.curPesIdx]));
            this.pesBuf = this.fetch(MPSIndex.pesLen(this.demuxer.pesTokens[this.curPesIdx]));
            MPSUtils.readPESHeader(this.pesBuf, 0);
            NIOUtils.skip(this.pesBuf, ((payloadOff) | 0));
            this._seekToFrame = -1;
        };
        prototype.getCurFrame = function() {
            return this.curFrame;
        };
        prototype.seek = function(second) {
             throw new NotSupportedException();
        };
    }, {pesBuf: "ByteBuffer", source: "SeekableByteChannel", foffs: "Array", demuxer: "MPSRandomAccessDemuxer", fsizes: "Int32Array", fpts: "Int32Array", fdur: "Int32Array", sync: "Int32Array"}, {});
}, {streams: "Array", pesTokens: "Array", pesStreamIds: "Int32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Indexes MPEG PS/TS file for the purpose of quick random access in the future
 *  
 *  @author The JCodec project
 *  
 */
var BaseIndexer = function() {
    MPSUtils.PESReader.call(this);
    this.analyzers = new HashMap();
    this.tokens = LongArrayList.createLongArrayList();
    this.streams = new RunLength.Integer();
};
BaseIndexer = stjs.extend(BaseIndexer, MPSUtils.PESReader, [], function(constructor, prototype) {
    prototype.analyzers = null;
    prototype.tokens = null;
    prototype.streams = null;
    prototype.estimateSize = function() {
        var sizeEstimate = (this.tokens.size() << 3) + this.streams.estimateSize() + 128;
        for (var iterator$stream = this.analyzers.keySet().iterator(); iterator$stream.hasNext(); ) {
            var stream = iterator$stream.next();
            sizeEstimate += this.analyzers.get(stream).estimateSize();
        }
        return sizeEstimate;
    };
    constructor.BaseAnalyser = function() {
        this.pts = new IntArrayList(250000);
        this.dur = new IntArrayList(250000);
    };
    constructor.BaseAnalyser = stjs.extend(constructor.BaseAnalyser, null, [], function(constructor, prototype) {
        prototype.pts = null;
        prototype.dur = null;
        prototype.pkt = function(pkt, pesHeader) {};
        prototype.finishAnalyse = function() {};
        prototype.estimateSize = function() {
            return (this.pts.size() << 2) + 4;
        };
        prototype.serialize = function(streamId) {};
    }, {pts: "IntArrayList", dur: "IntArrayList"}, {});
    constructor.GenericAnalyser = function() {
        BaseIndexer.BaseAnalyser.call(this);
        this.sizes = new IntArrayList(250000);
    };
    constructor.GenericAnalyser = stjs.extend(constructor.GenericAnalyser, BaseIndexer.BaseAnalyser, [], function(constructor, prototype) {
        prototype.sizes = null;
        prototype.knownDuration = 0;
        prototype.lastPts = 0;
        prototype.pkt = function(pkt, pesHeader) {
            this.sizes.add(pkt.remaining());
            if (pesHeader.pts == -1) {
                pesHeader.pts = this.lastPts + this.knownDuration;
            } else {
                this.knownDuration = (((pesHeader.pts - this.lastPts)) | 0);
                this.lastPts = pesHeader.pts;
            }
            this.pts.add(((pesHeader.pts) | 0));
            this.dur.add(this.knownDuration);
        };
        prototype.serialize = function(streamId) {
            return new MPSIndex.MPSStreamIndex(streamId, this.sizes.toArray(), this.pts.toArray(), this.dur.toArray(), new Int32Array(0));
        };
        prototype.estimateSize = function() {
            return BaseIndexer.BaseAnalyser.prototype.estimateSize.call(this) + (this.sizes.size() << 2) + 32;
        };
        prototype.finishAnalyse = function() {};
    }, {sizes: "IntArrayList", pts: "IntArrayList", dur: "IntArrayList"}, {});
    constructor.MPEGVideoAnalyser = function() {
        BaseIndexer.BaseAnalyser.call(this);
        this.sizes = new IntArrayList(250000);
        this.keyFrames = new IntArrayList(20000);
        this.curGop = new ArrayList();
    };
    constructor.MPEGVideoAnalyser = stjs.extend(constructor.MPEGVideoAnalyser, BaseIndexer.BaseAnalyser, [], function(constructor, prototype) {
        prototype.marker = -1;
        prototype.position = 0;
        prototype.sizes = null;
        prototype.keyFrames = null;
        prototype.frameNo = 0;
        prototype.inFrameData = false;
        prototype.lastFrame = null;
        prototype.curGop = null;
        prototype.phPos = -1;
        prototype.lastFrameOfLastGop = null;
        constructor.Frame = function() {};
        constructor.Frame = stjs.extend(constructor.Frame, null, [], function(constructor, prototype) {
            prototype.offset = 0;
            prototype.size = 0;
            prototype.pts = 0;
            prototype.tempRef = 0;
        }, {}, {});
        prototype.pkt = function(pkt, pesHeader) {
             while (pkt.hasRemaining()){
                var b = pkt.get() & 255;
                ++this.position;
                this.marker = (this.marker << 8) | b;
                if (this.phPos != -1) {
                    var phOffset = this.position - this.phPos;
                    if (phOffset == 5) 
                        this.lastFrame.tempRef = b << 2;
                     else if (phOffset == 6) {
                        var picCodingType = (b >> 3) & 7;
                        this.lastFrame.tempRef |= b >> 6;
                        if (picCodingType == MPEGConst.IntraCoded) {
                            this.keyFrames.add(this.frameNo - 1);
                            if (this.curGop.size() > 0) 
                                this.outGop();
                        }
                    }
                }
                if ((this.marker & -256) != 256) 
                    continue;
                if (this.inFrameData && (this.marker == 256 || this.marker > 431)) {
                    this.lastFrame.size = (((this.position - 4 - this.lastFrame.offset)) | 0);
                    this.curGop.add(this.lastFrame);
                    this.lastFrame = null;
                    this.inFrameData = false;
                } else if (!this.inFrameData && (this.marker > 256 && this.marker <= 431)) {
                    this.inFrameData = true;
                }
                if (this.lastFrame == null && (this.marker == 435 || this.marker == 440 || this.marker == 256)) {
                    var frame = new BaseIndexer.MPEGVideoAnalyser.Frame();
                    frame.pts = ((pesHeader.pts) | 0);
                    frame.offset = this.position - 4;
                    jcodec.Logger.info(String.format("FRAME[%d]: %012x, %d", this.frameNo, (pesHeader.pos + pkt.position() - 4), pesHeader.pts));
                    this.frameNo++;
                    this.lastFrame = frame;
                }
                if (this.lastFrame != null && this.lastFrame.pts == -1 && this.marker == 256) {
                    this.lastFrame.pts = ((pesHeader.pts) | 0);
                }
                this.phPos = this.marker == 256 ? this.position - 4 : -1;
            }
        };
        prototype.outGop = function() {
            this.fixPts(this.curGop);
            for (var iterator$frame = this.curGop.iterator(); iterator$frame.hasNext(); ) {
                var frame = iterator$frame.next();
                this.sizes.add(frame.size);
                this.pts.add(frame.pts);
            }
            this.curGop.clear();
        };
        prototype.fixPts = function(curGop) {
            var frames = curGop.toArray(Array(0));
            Arrays.sort(frames, new (stjs.extend(function BaseIndexer$MPEGVideoAnalyser$1() {}, null, [Comparator], function(constructor, prototype) {
                prototype.compare = function(o1, o2) {
                    return o1.tempRef > o2.tempRef ? 1 : (o1.tempRef == o2.tempRef ? 0 : -1);
                };
            }, {}, {}))());
            for (var dir = 0; dir < 3; dir++) {
                for (var i = 0, lastPts = -1, secondLastPts = -1, lastTref = -1, secondLastTref = -1; i < frames.length; i++) {
                    if (frames[i].pts == -1 && lastPts != -1 && secondLastPts != -1) 
                        frames[i].pts = lastPts + stjs.trunc((lastPts - secondLastPts) / MathUtil.abs(lastTref - secondLastTref));
                    if (frames[i].pts != -1) {
                        secondLastPts = lastPts;
                        secondLastTref = lastTref;
                        lastPts = frames[i].pts;
                        lastTref = frames[i].tempRef;
                    }
                }
                ArrayUtil.reverse(frames);
            }
            if (this.lastFrameOfLastGop != null) {
                this.dur.add(frames[0].pts - this.lastFrameOfLastGop.pts);
            }
            for (var i = 1; i < frames.length; i++) {
                this.dur.add(frames[i].pts - frames[i - 1].pts);
            }
            this.lastFrameOfLastGop = frames[frames.length - 1];
        };
        prototype.finishAnalyse = function() {
            if (this.lastFrame == null) 
                return;
            this.lastFrame.size = (((this.position - this.lastFrame.offset)) | 0);
            this.curGop.add(this.lastFrame);
            this.outGop();
        };
        prototype.serialize = function(streamId) {
            return new MPSIndex.MPSStreamIndex(streamId, this.sizes.toArray(), this.pts.toArray(), this.dur.toArray(), this.keyFrames.toArray());
        };
    }, {sizes: "IntArrayList", keyFrames: "IntArrayList", lastFrame: "BaseIndexer.MPEGVideoAnalyser.Frame", curGop: {name: "List", arguments: ["BaseIndexer.MPEGVideoAnalyser.Frame"]}, lastFrameOfLastGop: "BaseIndexer.MPEGVideoAnalyser.Frame", pts: "IntArrayList", dur: "IntArrayList"}, {});
    prototype.getAnalyser = function(stream) {
        var analizer = this.analyzers.get(stream);
        if (analizer == null) {
            analizer = stream >= 224 && stream <= 239 ? new BaseIndexer.MPEGVideoAnalyser() : new BaseIndexer.GenericAnalyser();
            this.analyzers.put(stream, analizer);
        }
        return this.analyzers.get(stream);
    };
    prototype.serialize = function() {
        var streamsIndices = new ArrayList();
        var entrySet = this.analyzers.entrySet();
        for (var iterator$entry = entrySet.iterator(); iterator$entry.hasNext(); ) {
            var entry = iterator$entry.next();
            streamsIndices.add(entry.getValue().serialize(entry.getKey()));
        }
        return new MPSIndex(this.tokens.toArray(), this.streams, streamsIndices.toArray(Array(0)));
    };
    prototype.savePESMeta = function(stream, token) {
        this.tokens.add(token);
        this.streams.add(stream);
    };
    prototype.finishAnalyse = function() {
        MPSUtils.PESReader.prototype.finishRead.call(this);
        for (var iterator$baseAnalyser = this.analyzers.values().iterator(); iterator$baseAnalyser.hasNext(); ) {
            var baseAnalyser = iterator$baseAnalyser.next();
            baseAnalyser.finishAnalyse();
        }
    };
}, {analyzers: {name: "Map", arguments: [null, "BaseIndexer.BaseAnalyser"]}, tokens: "LongArrayList", streams: "RunLength.Integer", pesBuffer: "ByteBuffer"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Represents index for MPEG TS stream, enables demuxers to do precise seek
 *  
 *  Note: some values inside the MPSIndex are not expressed in bytes anymore, but
 *  rather in integral MPEG TS packets.
 *  
 *  @author The JCodec project
 *  
 */
var MTSIndex = function(programs) {
    this.programs = programs;
};
MTSIndex = stjs.extend(MTSIndex, null, [], function(constructor, prototype) {
    prototype.programs = null;
    constructor.createMTSProgram = function(mpsIndex, target) {
        var m = new MTSIndex.MTSProgram(mpsIndex.pesTokens, mpsIndex.pesStreamIds, mpsIndex.streams, target);
        return m;
    };
    constructor.MTSProgram = function(pesTokens, pesStreamIds, streams, targetGuid) {
        MPSIndex.call(this, pesTokens, pesStreamIds, streams);
        this.targetGuid = targetGuid;
    };
    constructor.MTSProgram = stjs.extend(constructor.MTSProgram, MPSIndex, [], function(constructor, prototype) {
        prototype.targetGuid = 0;
        prototype.getTargetGuid = function() {
            return this.targetGuid;
        };
        prototype.serializeTo = function(index) {
            index.putInt(this.targetGuid);
            MPSIndex.prototype.serializeTo.call(this, index);
        };
        constructor.parse = function(read) {
            var targetGuid = read.getInt();
            return MTSIndex.createMTSProgram(MPSIndex.parseIndex(read), targetGuid);
        };
    }, {pesTokens: "Array", pesStreamIds: "RunLength.Integer", streams: "Array"}, {});
    prototype.getPrograms = function() {
        return this.programs;
    };
    constructor.parse = function(buf) {
        var numPrograms = buf.getInt();
        var programs = Array(numPrograms);
        for (var i = 0; i < numPrograms; i++) {
            var programDataSize = buf.getInt();
            programs[i] = MTSIndex.MTSProgram.parse(NIOUtils.read(buf, programDataSize));
        }
        return new MTSIndex(programs);
    };
    prototype.estimateSize = function() {
        var totalSize = 64;
        for (var mtsProgram in this.programs) {
            totalSize += 4 + mtsProgram.estimateSize();
        }
        return totalSize;
    };
    prototype.serializeTo = function(buf) {
        buf.putInt(this.programs.length);
        for (var mtsAnalyser in this.programs) {
            var dup = buf.duplicate();
            NIOUtils.skip(buf, 4);
            mtsAnalyser.serializeTo(buf);
            dup.putInt(buf.position() - dup.position() - 4);
        }
    };
    prototype.serialize = function() {
        var bb = ByteBuffer.allocate(this.estimateSize());
        this.serializeTo(bb);
        bb.flip();
        return bb;
    };
}, {programs: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Reads data from a wave file
 *  
 *  @author The JCodec project
 *  
 */
var WavTrack = function(pool, labels) {
    this.pool = pool;
    var ch = null;
    try {
        ch = pool.getChannel();
        this.header = WavHeader.readChannel(ch);
        this.size = this.header.dataSize <= 0 ? ch.size() : this.header.dataSize;
    } finally {
        ch.close();
    }
    this.se = AudioCodecMeta.createAudioCodecMeta3("sowt", ByteBuffer.allocate(0), new AudioFormat(this.header.fmt.sampleRate, this.header.fmt.bitsPerSample >> 3, this.header.fmt.numChannels, true, false), true, labels);
    this.pktDataLen = WavTrack.FRAMES_PER_PKT * this.header.fmt.numChannels * (this.header.fmt.bitsPerSample >> 3);
    this.pktDuration = WavTrack.FRAMES_PER_PKT / this.header.fmt.sampleRate;
    this.offset = this.header.dataOffset;
    this.pts = 0;
    this.frameNo = 0;
};
WavTrack = stjs.extend(WavTrack, null, [VirtualTrack], function(constructor, prototype) {
    constructor.FRAMES_PER_PKT = 1024;
    prototype.pool = null;
    prototype.header = null;
    prototype.se = null;
    prototype.pktDataLen = 0;
    prototype.pktDuration = 0.0;
    prototype.offset = 0;
    prototype.pts = 0.0;
    prototype.frameNo = 0;
    prototype.size = 0;
    prototype.nextPacket = function() {
        if (this.offset >= this.size) 
            return null;
        var pkt = new WavTrack.WavPacket(this, this.frameNo, this.pts, this.offset, ((Math.min(this.size - this.offset, this.pktDataLen)) | 0));
        this.offset += this.pktDataLen;
        this.frameNo += WavTrack.FRAMES_PER_PKT;
        this.pts = this.frameNo / this.header.fmt.sampleRate;
        return pkt;
    };
    prototype.getCodecMeta = function() {
        return this.se;
    };
    prototype.getEdits = function() {
        return null;
    };
    prototype.getPreferredTimescale = function() {
        return this.header.fmt.sampleRate;
    };
    prototype.close = function() {
        this.pool.close();
    };
    constructor.WavPacket = function(track, frameNo, pts, offset, dataLen) {
        this.track = track;
        this.frameNo = frameNo;
        this.pts = pts;
        this.offset = offset;
        this.dataLen = dataLen;
    };
    constructor.WavPacket = stjs.extend(constructor.WavPacket, null, [VirtualPacket], function(constructor, prototype) {
        prototype.frameNo = 0;
        prototype.pts = 0.0;
        prototype.offset = 0;
        prototype.dataLen = 0;
        prototype.track = null;
        prototype.getData = function() {
            var ch = null;
            try {
                ch = this.track.pool.getChannel();
                ch.setPosition(this.offset);
                var buffer = ByteBuffer.allocate(this.dataLen);
                NIOUtils.readFromChannel(ch, buffer);
                buffer.flip();
                return buffer;
            } finally {
                ch.close();
            }
        };
        prototype.getDataLen = function() {
            return this.dataLen;
        };
        prototype.getPts = function() {
            return this.pts;
        };
        prototype.getDuration = function() {
            return this.track.pktDuration;
        };
        prototype.isKeyframe = function() {
            return true;
        };
        prototype.getFrameNo = function() {
            return this.frameNo;
        };
    }, {track: "WavTrack", byPts: {name: "Comparator", arguments: ["Object"]}}, {});
}, {pool: "ByteChannelPool", header: "WavHeader", se: "AudioCodecMeta"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Outputs integer samples into wav file
 *  
 *  @author The JCodec project
 */
var WavOutput = function(out, format) {
    this.out = out;
    this.format = format;
    this.header = WavHeader.createWavHeader(format, 0);
    this.header.write(out);
};
WavOutput = stjs.extend(WavOutput, null, [Closeable], function(constructor, prototype) {
    prototype.out = null;
    prototype.header = null;
    prototype.written = 0;
    prototype.format = null;
    prototype.write = function(samples) {
        this.written += this.out.write(samples);
    };
    prototype.close = function() {
        this.out.setPosition(0);
        WavHeader.createWavHeader(this.format, this.format.bytesToFrames(this.written)).write(this.out);
        NIOUtils.closeQuietly(this.out);
    };
    /**
     *  Manages the file resource on top of WavOutput
     */
    constructor.WavOutFile = function(f, format) {
        WavOutput.call(this, NIOUtils.writableChannel(f), format);
    };
    constructor.WavOutFile = stjs.extend(constructor.WavOutFile, WavOutput, [], function(constructor, prototype) {
        prototype.close = function() {
            WavOutput.prototype.close.call(this);
            NIOUtils.closeQuietly(this.out);
        };
    }, {out: "SeekableByteChannel", header: "WavHeader", format: "AudioFormat"}, {});
    /**
     *  Supports more high-level float and int array output on top of WavOutput
     */
    constructor.Sink = function(out) {
        this.out = out;
    };
    constructor.Sink = stjs.extend(constructor.Sink, null, [AudioSink, Closeable], function(constructor, prototype) {
        prototype.out = null;
        prototype.writeFloat = function(data) {
            var buf = ByteBuffer.allocate(this.out.format.samplesToBytes(data.remaining()));
            AudioUtil.fromFloat(data, this.out.format, buf);
            buf.flip();
            this.out.write(buf);
        };
        prototype.write = function(data, len) {
            len = Math.min(data.length, len);
            var buf = ByteBuffer.allocate(this.out.format.samplesToBytes(len));
            AudioUtil.fromInt(data, len, this.out.format, buf);
            buf.flip();
            this.out.write(buf);
        };
        prototype.close = function() {
            this.out.close();
        };
    }, {out: "WavOutput"}, {});
}, {out: "SeekableByteChannel", header: "WavHeader", format: "AudioFormat"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Splits a multichannel wave file into a number of single-channel wavs
 *  
 *  @author The JCodec project
 *  
 */
var WavSplit = function() {};
WavSplit = stjs.extend(WavSplit, null, [], function(constructor, prototype) {
    constructor.main1 = function(args) {
        var cmd = MainUtils.parseArguments(args);
        if (cmd.argsLength() < 1) {
            var map = new HashMap();
            map.put("pattern", "Output file name pattern, i.e. out%02d.wav");
            MainUtils.printHelp(map, Arrays.asList("filename.wav"));
            System.exit(-1);
        }
        var s = new File(args[0]);
        var pattern = cmd.getStringFlagD("pattern", "c%02d.wav");
        var wavHeader = WavHeader.read(s);
        System.out.println("WAV: " + wavHeader.getFormat());
        Assert.assertEquals(2, wavHeader.fmt.numChannels);
        var dataOffset = wavHeader.dataOffset;
        var is = NIOUtils.readableChannel(s);
        is.setPosition(dataOffset);
        var channels = wavHeader.getFormat().getChannels();
        var out = Array(channels);
        for (var i = 0; i < channels; i++) {
            out[i] = NIOUtils.writableChannel((new File(s.getParentFile(), String.format(pattern, i))));
            WavHeader.copyWithChannels(wavHeader, 1).write(out[i]);
        }
        WavSplit.copy(wavHeader.getFormat(), is, out);
        for (var i = 0; i < channels; i++) {
            out[i].close();
        }
    };
    constructor.copy = function(format, is, out) {
        var outs = Array(out.length);
        for (var i = 0; i < out.length; i++) {
            outs[i] = ByteBuffer.allocate(format.framesToBytes(4096));
        }
        var inb = ByteBuffer.allocate(format.framesToBytes(4096) * out.length);
         while (is.read(inb) != -1){
            inb.flip();
            AudioUtil.deinterleave(format, inb, outs);
            inb.clear();
            for (var i = 0; i < out.length; i++) {
                outs[i].flip();
                out[i].write(outs[i]);
                outs[i].clear();
            }
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Reads integer samples from the wav file
 *  
 *  @author The JCodec project
 */
var WavInput = function(_in) {
    this.header = WavHeader.readChannel(_in);
    this.format = this.header.getFormat();
    this._in = _in;
};
WavInput = stjs.extend(WavInput, null, [Closeable], function(constructor, prototype) {
    prototype.header = null;
    prototype.prevBuf = null;
    prototype._in = null;
    prototype.format = null;
    prototype.read = function(buf) {
        var maxRead = this.format.framesToBytes(this.format.bytesToFrames(buf.remaining()));
        return NIOUtils.readL(this._in, buf, maxRead);
    };
    prototype.close = function() {
        this._in.close();
    };
    prototype.getHeader = function() {
        return this.header;
    };
    prototype.getFormat = function() {
        return this.format;
    };
    /**
     *  Manages file resource on top of WavInput
     */
    constructor.WavFile = function(f) {
        WavInput.call(this, NIOUtils.readableChannel(f));
    };
    constructor.WavFile = stjs.extend(constructor.WavFile, WavInput, [], function(constructor, prototype) {
        prototype.close = function() {
            WavInput.prototype.close.call(this);
            this._in.close();
        };
    }, {header: "WavHeader", prevBuf: "Int8Array", _in: "ReadableByteChannel", format: "AudioFormat"}, {});
    /**
     *  Supports more high-level float and integer input on top of WavInput
     */
    constructor.Source = function(src) {
        this.src = src;
        this.format = src.getFormat();
    };
    constructor.Source = stjs.extend(constructor.Source, null, [AudioSource, Closeable], function(constructor, prototype) {
        prototype.src = null;
        prototype.format = null;
        prototype.pos = 0;
        prototype.getFormat = function() {
            return this.src.getFormat();
        };
        prototype.close = function() {
            this.src.close();
        };
        prototype.read = function(samples, max) {
            max = Math.min(max, samples.length);
            var bb = ByteBuffer.allocate(this.format.samplesToBytes(max));
            var read = this.src.read(bb);
            bb.flip();
            AudioUtil.toInt(this.format, bb, samples);
            return this.format.bytesToFrames(read);
        };
        prototype.readFloat = function(samples) {
            var bb = ByteBuffer.allocate(this.format.samplesToBytes(samples.remaining()));
            var i = this.src.read(bb);
            if (i == -1) 
                return -1;
            bb.flip();
            AudioUtil.toFloat(this.format, bb, samples);
            var read = this.format.bytesToFrames(i);
            this.pos += read;
            return read;
        };
    }, {src: "WavInput", format: "AudioFormat"}, {});
}, {header: "WavHeader", prevBuf: "Int8Array", _in: "ReadableByteChannel", format: "AudioFormat"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Interleaves 2 or more single channel wave files into a multichannel wav
 *  
 *  @author The JCodec project
 *  
 */
var WavMerge = function() {};
WavMerge = stjs.extend(WavMerge, null, [], function(constructor, prototype) {
    constructor.main1 = function(args) {
        if (args.length < 3) {
            System.out.println("wavmerge <output wav> <input wav> .... <input wav>");
            System.exit(-1);
        }
        var out = new File(args[0]);
        var ins = Array(args.length - 1);
        for (var i = 1; i < args.length; i++) 
            ins[i - 1] = new File(args[i]);
        WavMerge.merge(out, ins);
    };
    constructor.merge = function(result, src) {
        var out = null;
        var inputs = Array(src.length);
        var headers = Array(src.length);
        var ins = Array(src.length);
        try {
            var sampleSize = -1;
            for (var i = 0; i < src.length; i++) {
                inputs[i] = NIOUtils.readableChannel(src[i]);
                var hdr = WavHeader.readChannel(inputs[i]);
                if (sampleSize != -1 && sampleSize != hdr.fmt.bitsPerSample) 
                     throw new RuntimeException("Input files have different sample sizes");
                sampleSize = hdr.fmt.bitsPerSample;
                headers[i] = hdr;
                ins[i] = ByteBuffer.allocate(hdr.getFormat().framesToBytes(4096));
            }
            var outb = ByteBuffer.allocate(headers[0].getFormat().framesToBytes(4096) * src.length);
            var newHeader = WavHeader.multiChannelWav(headers);
            out = NIOUtils.writableChannel(result);
            newHeader.write(out);
            for (var readOnce = true; ; ) {
                readOnce = false;
                for (var i = 0; i < ins.length; i++) {
                    if (inputs[i] != null) {
                        ins[i].clear();
                        if (inputs[i].read(ins[i]) == -1) {
                            NIOUtils.closeQuietly(inputs[i]);
                            inputs[i] = null;
                        } else 
                            readOnce = true;
                        ins[i].flip();
                    }
                }
                if (!readOnce) 
                    break;
                outb.clear();
                AudioUtil.interleave(headers[0].getFormat(), ins, outb);
                outb.flip();
                out.write(outb);
            }
        } finally {
            IOUtils.closeQuietly(out);
            for (var inputStream in inputs) {
                IOUtils.closeQuietly(inputStream);
            }
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Identification = function(ul) {
    MXFInterchangeObject.call(this, ul);
};
Identification = stjs.extend(Identification, MXFInterchangeObject, [], function(constructor, prototype) {
    prototype.thisGenerationUID = null;
    prototype.companyName = null;
    prototype.productName = null;
    prototype.versionString = 0;
    prototype.productUID = null;
    prototype.modificationDate = null;
    prototype.platform = null;
    prototype.read = function(tags) {
        for (var it = tags.entrySet().iterator(); it.hasNext(); ) {
            var entry = it.next();
            var _bb = entry.getValue();
            switch (entry.getKey()) {
                case 15369:
                    this.thisGenerationUID = UL.read(_bb);
                    break;
                case 15361:
                    this.companyName = this.readUtf16String(_bb);
                    break;
                case 15362:
                    this.productName = this.readUtf16String(_bb);
                    break;
                case 15364:
                    this.versionString = _bb.getShort();
                    break;
                case 15365:
                    this.productUID = UL.read(_bb);
                    break;
                case 15366:
                    this.modificationDate = MXFMetadata.readDate(_bb);
                    break;
                case 15368:
                    this.platform = this.readUtf16String(_bb);
                    break;
                default:
                    jcodec.Logger.warn(String.format("Unknown tag [ " + this.ul + "]: %04x", entry.getKey()));
                    continue;
            }
            it.remove();
        }
    };
    prototype.getThisGenerationUID = function() {
        return this.thisGenerationUID;
    };
    prototype.getCompanyName = function() {
        return this.companyName;
    };
    prototype.getProductName = function() {
        return this.productName;
    };
    prototype.getVersionString = function() {
        return this.versionString;
    };
    prototype.getProductUID = function() {
        return this.productUID;
    };
    prototype.getModificationDate = function() {
        return this.modificationDate;
    };
    prototype.getPlatform = function() {
        return this.platform;
    };
}, {thisGenerationUID: "UL", productUID: "UL", modificationDate: "jsutil.Date", generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var GenericDescriptor = function(ul) {
    MXFInterchangeObject.call(this, ul);
};
GenericDescriptor = stjs.extend(GenericDescriptor, MXFInterchangeObject, [], function(constructor, prototype) {
    prototype.locators = null;
    prototype.subDescriptors = null;
    prototype.read = function(tags) {
        for (var it = tags.entrySet().iterator(); it.hasNext(); ) {
            var entry = it.next();
            var _bb = entry.getValue();
            switch (entry.getKey()) {
                case 12033:
                    this.locators = MXFMetadata.readULBatch(_bb);
                case 16129:
                    this.subDescriptors = MXFMetadata.readULBatch(_bb);
                    break;
                default:
                    jcodec.Logger.warn(String.format("Unknown tag [ " + this.ul + "]: %04x", entry.getKey()));
                    continue;
            }
            it.remove();
        }
    };
    prototype.getLocators = function() {
        return this.locators;
    };
    prototype.getSubDescriptors = function() {
        return this.subDescriptors;
    };
}, {locators: "Array", subDescriptors: "Array", generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  MXF demuxer, Index segment structure. Contains information about frame
 *  offsets. Used for rapid random positioning within the movie.
 *  
 *  @author The JCodec project
 *  
 */
var IndexSegment = function(ul) {
    MXFInterchangeObject.call(this, ul);
};
IndexSegment = stjs.extend(IndexSegment, MXFInterchangeObject, [], function(constructor, prototype) {
    prototype.ie = null;
    prototype.editUnitByteCount = 0;
    prototype.deltaEntries = null;
    prototype.indexSID = 0;
    prototype.bodySID = 0;
    prototype.indexEditRateNum = 0;
    prototype.indexEditRateDen = 0;
    prototype.indexStartPosition = 0;
    prototype.indexDuration = 0;
    prototype.instanceUID = null;
    prototype.sliceCount = 0;
    prototype.posTableCount = 0;
    prototype.read = function(tags) {
        for (var it = tags.entrySet().iterator(); it.hasNext(); ) {
            var entry = it.next();
            var _bb = entry.getValue();
            switch (entry.getKey()) {
                case 15370:
                    this.instanceUID = UL.read(_bb);
                    break;
                case 16133:
                    this.editUnitByteCount = _bb.getInt();
                    break;
                case 16134:
                    this.indexSID = _bb.getInt();
                    break;
                case 16135:
                    this.bodySID = _bb.getInt();
                    break;
                case 16136:
                    this.sliceCount = _bb.get() & 255;
                    break;
                case 16137:
                    this.deltaEntries = DeltaEntries.read(_bb);
                    break;
                case 16138:
                    this.ie = IndexEntries.read(_bb);
                    break;
                case 16139:
                    this.indexEditRateNum = _bb.getInt();
                    this.indexEditRateDen = _bb.getInt();
                    break;
                case 16140:
                    this.indexStartPosition = _bb.getLong();
                    break;
                case 16141:
                    this.indexDuration = _bb.getLong();
                    break;
                case 16142:
                    this.posTableCount = _bb.get() & 255;
                    break;
                default:
                    jcodec.Logger.warn(String.format("Unknown tag [" + this.ul + "]: %04x", entry.getKey()));
                    continue;
            }
            it.remove();
        }
    };
    prototype.getIe = function() {
        return this.ie;
    };
    prototype.getEditUnitByteCount = function() {
        return this.editUnitByteCount;
    };
    prototype.getDeltaEntries = function() {
        return this.deltaEntries;
    };
    prototype.getIndexSID = function() {
        return this.indexSID;
    };
    prototype.getBodySID = function() {
        return this.bodySID;
    };
    prototype.getIndexEditRateNum = function() {
        return this.indexEditRateNum;
    };
    prototype.getIndexEditRateDen = function() {
        return this.indexEditRateDen;
    };
    prototype.getIndexStartPosition = function() {
        return this.indexStartPosition;
    };
    prototype.getIndexDuration = function() {
        return this.indexDuration;
    };
    prototype.getInstanceUID = function() {
        return this.instanceUID;
    };
    prototype.getSliceCount = function() {
        return this.sliceCount;
    };
    prototype.getPosTableCount = function() {
        return this.posTableCount;
    };
}, {ie: "IndexEntries", deltaEntries: "DeltaEntries", instanceUID: "UL", generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Preface = function(ul) {
    MXFInterchangeObject.call(this, ul);
};
Preface = stjs.extend(Preface, MXFInterchangeObject, [], function(constructor, prototype) {
    prototype.lastModifiedDate = null;
    prototype.objectModelVersion = 0;
    prototype.op = null;
    prototype.essenceContainers = null;
    prototype.dmSchemes = null;
    prototype.read = function(tags) {
        for (var it = tags.entrySet().iterator(); it.hasNext(); ) {
            var entry = it.next();
            var _bb = entry.getValue();
            switch (entry.getKey()) {
                case 15106:
                    this.lastModifiedDate = MXFMetadata.readDate(_bb);
                    break;
                case 15111:
                    this.objectModelVersion = _bb.getInt();
                    break;
                case 15113:
                    this.op = UL.read(_bb);
                    break;
                case 15114:
                    this.essenceContainers = MXFMetadata.readULBatch(_bb);
                    break;
                case 15115:
                    this.dmSchemes = MXFMetadata.readULBatch(_bb);
                    break;
                default:
                    jcodec.Logger.warn(String.format("Unknown tag [ " + this.ul + "]: %04x", entry.getKey()));
                    continue;
            }
            it.remove();
        }
    };
    prototype.getLastModifiedDate = function() {
        return this.lastModifiedDate;
    };
    prototype.getObjectModelVersion = function() {
        return this.objectModelVersion;
    };
    prototype.getOp = function() {
        return this.op;
    };
    prototype.getEssenceContainers = function() {
        return this.essenceContainers;
    };
    prototype.getDmSchemes = function() {
        return this.dmSchemes;
    };
}, {lastModifiedDate: "jsutil.Date", op: "UL", essenceContainers: "Array", dmSchemes: "Array", generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var GenericPackage = function(ul) {
    MXFInterchangeObject.call(this, ul);
};
GenericPackage = stjs.extend(GenericPackage, MXFInterchangeObject, [], function(constructor, prototype) {
    prototype.tracks = null;
    prototype.packageUID = null;
    prototype.name = null;
    prototype.packageModifiedDate = null;
    prototype.packageCreationDate = null;
    prototype.read = function(tags) {
        for (var it = tags.entrySet().iterator(); it.hasNext(); ) {
            var entry = it.next();
            var _bb = entry.getValue();
            switch (entry.getKey()) {
                case 17409:
                    this.packageUID = UL.read(_bb);
                    break;
                case 17410:
                    this.name = this.readUtf16String(_bb);
                    break;
                case 17411:
                    this.tracks = MXFMetadata.readULBatch(_bb);
                    break;
                case 17412:
                    this.packageModifiedDate = MXFMetadata.readDate(_bb);
                    break;
                case 17413:
                    this.packageCreationDate = MXFMetadata.readDate(_bb);
                    break;
                default:
                    jcodec.Logger.warn(String.format("Unknown tag [ " + this.ul + "]: %04x", entry.getKey()));
                    continue;
            }
            it.remove();
        }
    };
    prototype.getTracks = function() {
        return this.tracks;
    };
    prototype.getPackageUID = function() {
        return this.packageUID;
    };
    prototype.getName = function() {
        return this.name;
    };
    prototype.getPackageModifiedDate = function() {
        return this.packageModifiedDate;
    };
    prototype.getPackageCreationDate = function() {
        return this.packageCreationDate;
    };
}, {tracks: "Array", packageUID: "UL", packageModifiedDate: "jsutil.Date", packageCreationDate: "jsutil.Date", generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MXFStructuralComponent = function(ul) {
    MXFInterchangeObject.call(this, ul);
};
MXFStructuralComponent = stjs.extend(MXFStructuralComponent, MXFInterchangeObject, [], function(constructor, prototype) {
    prototype.duration = 0;
    prototype.dataDefinitionUL = null;
    prototype.read = function(tags) {
        for (var it = tags.entrySet().iterator(); it.hasNext(); ) {
            var entry = it.next();
            switch (entry.getKey()) {
                case 514:
                    this.duration = entry.getValue().getLong();
                    break;
                case 513:
                    this.dataDefinitionUL = UL.read(entry.getValue());
                    break;
                default:
                    jcodec.Logger.warn(String.format("Unknown tag [ " + this.ul + "]: %04x", entry.getKey()));
                    continue;
            }
            it.remove();
        }
    };
    prototype.getDuration = function() {
        return this.duration;
    };
    prototype.getDataDefinitionUL = function() {
        return this.dataDefinitionUL;
    };
}, {dataDefinitionUL: "UL", generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var EssenceContainerData = function(ul) {
    MXFInterchangeObject.call(this, ul);
};
EssenceContainerData = stjs.extend(EssenceContainerData, MXFInterchangeObject, [], function(constructor, prototype) {
    prototype.linkedPackageUID = null;
    prototype.indexSID = 0;
    prototype.bodySID = 0;
    prototype.read = function(tags) {
        for (var it = tags.entrySet().iterator(); it.hasNext(); ) {
            var entry = it.next();
            var _bb = entry.getValue();
            switch (entry.getKey()) {
                case 9985:
                    this.linkedPackageUID = UL.read(_bb);
                    break;
                case 16134:
                    this.indexSID = _bb.getInt();
                    break;
                case 16135:
                    this.bodySID = _bb.getInt();
                    break;
                default:
                    jcodec.Logger.warn(String.format("Unknown tag [ EssenceContainerData: " + this.ul + "]: %04x", entry.getKey()));
                    continue;
            }
            it.remove();
        }
    };
    prototype.getLinkedPackageUID = function() {
        return this.linkedPackageUID;
    };
    prototype.getIndexSID = function() {
        return this.indexSID;
    };
    prototype.getBodySID = function() {
        return this.bodySID;
    };
}, {linkedPackageUID: "UL", generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var ContentStorage = function(ul) {
    MXFInterchangeObject.call(this, ul);
};
ContentStorage = stjs.extend(ContentStorage, MXFInterchangeObject, [], function(constructor, prototype) {
    prototype.packageRefs = null;
    prototype.essenceContainerData = null;
    prototype.read = function(tags) {
        for (var it = tags.entrySet().iterator(); it.hasNext(); ) {
            var entry = it.next();
            var _bb = entry.getValue();
            switch (entry.getKey()) {
                case 6401:
                    this.packageRefs = MXFMetadata.readULBatch(_bb);
                    break;
                case 6402:
                    this.essenceContainerData = MXFMetadata.readULBatch(_bb);
                    break;
                default:
                    jcodec.Logger.warn(String.format("Unknown tag [ ContentStorage: " + this.ul + "]: %04x", entry.getKey()));
                    continue;
            }
            it.remove();
        }
    };
    prototype.getPackageRefs = function() {
        return this.packageRefs;
    };
    prototype.getEssenceContainerData = function() {
        return this.essenceContainerData;
    };
}, {packageRefs: "Array", essenceContainerData: "Array", generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var GenericTrack = function(ul) {
    MXFInterchangeObject.call(this, ul);
};
GenericTrack = stjs.extend(GenericTrack, MXFInterchangeObject, [], function(constructor, prototype) {
    prototype.trackId = 0;
    prototype.name = null;
    prototype.sequenceRef = null;
    prototype.trackNumber = 0;
    prototype.read = function(tags) {
        for (var it = tags.entrySet().iterator(); it.hasNext(); ) {
            var entry = it.next();
            var _bb = entry.getValue();
            switch (entry.getKey()) {
                case 18433:
                    this.trackId = _bb.getInt();
                    break;
                case 18434:
                    this.name = this.readUtf16String(_bb);
                    break;
                case 18435:
                    this.sequenceRef = UL.read(_bb);
                    break;
                case 18436:
                    this.trackNumber = _bb.getInt();
                    break;
                default:
                    jcodec.Logger.warn(String.format("Unknown tag [ " + this.ul + "]: %04x", entry.getKey()));
                    continue;
            }
            it.remove();
        }
    };
    prototype.getTrackId = function() {
        return this.trackId;
    };
    prototype.getName = function() {
        return this.name;
    };
    prototype.getSequenceRef = function() {
        return this.sequenceRef;
    };
    prototype.getTrackNumber = function() {
        return this.trackNumber;
    };
}, {sequenceRef: "UL", generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var J2KPictureDescriptor = function(ul) {
    MXFInterchangeObject.call(this, ul);
};
J2KPictureDescriptor = stjs.extend(J2KPictureDescriptor, MXFInterchangeObject, [], function(constructor, prototype) {
    prototype.rsiz = 0;
    prototype.xsiz = 0;
    prototype.ysiz = 0;
    prototype.xOsiz = 0;
    prototype.yOsiz = 0;
    prototype.xTsiz = 0;
    prototype.yTsiz = 0;
    prototype.xTOsiz = 0;
    prototype.yTOsiz = 0;
    prototype.csiz = 0;
    prototype.read = function(tags) {
        for (var it = tags.entrySet().iterator(); it.hasNext(); ) {
            var entry = it.next();
            var _bb = entry.getValue();
            switch (entry.getKey()) {
                case 24836:
                    this.rsiz = _bb.getShort();
                    break;
                case 24837:
                    this.xsiz = _bb.getInt();
                    break;
                case 24838:
                    this.ysiz = _bb.getInt();
                    break;
                case 24839:
                    this.xOsiz = _bb.getInt();
                    break;
                case 24840:
                    this.yOsiz = _bb.getInt();
                    break;
                case 24841:
                    this.xTsiz = _bb.getInt();
                    break;
                case 24842:
                    this.yTsiz = _bb.getInt();
                    break;
                case 24843:
                    this.xTOsiz = _bb.getInt();
                    break;
                case 24844:
                    this.yTOsiz = _bb.getInt();
                    break;
                case 24845:
                    this.csiz = _bb.getShort();
                    break;
                default:
                    jcodec.Logger.warn(String.format("Unknown tag [ " + this.ul + "]: %04x", entry.getKey()));
                    continue;
            }
            it.remove();
        }
    };
    prototype.getRsiz = function() {
        return this.rsiz;
    };
    prototype.getXsiz = function() {
        return this.xsiz;
    };
    prototype.getYsiz = function() {
        return this.ysiz;
    };
    prototype.getxOsiz = function() {
        return this.xOsiz;
    };
    prototype.getyOsiz = function() {
        return this.yOsiz;
    };
    prototype.getxTsiz = function() {
        return this.xTsiz;
    };
    prototype.getyTsiz = function() {
        return this.yTsiz;
    };
    prototype.getxTOsiz = function() {
        return this.xTOsiz;
    };
    prototype.getyTOsiz = function() {
        return this.yTOsiz;
    };
    prototype.getCsiz = function() {
        return this.csiz;
    };
}, {generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MXFPartition = function(pack, essenceFilePos, closed, complete, essenceLength) {
    this.pack = pack;
    this.essenceFilePos = essenceFilePos;
    this.closed = closed;
    this.complete = complete;
    this.essenceLength = essenceLength;
};
MXFPartition = stjs.extend(MXFPartition, null, [], function(constructor, prototype) {
    prototype.pack = null;
    prototype.essenceFilePos = 0;
    prototype.closed = false;
    prototype.complete = false;
    prototype.essenceLength = 0;
    constructor.read = function(ul, bb, packSize, nextPartition) {
        var closed = (ul.get(14) & 1) == 0;
        var complete = ul.get(14) > 2;
        var pp = new MXFPartitionPack(ul);
        pp.readBuf(bb);
        var essenceFilePos = MXFPartition.roundToKag(pp.getThisPartition() + packSize, pp.getKagSize()) + MXFPartition.roundToKag(pp.getHeaderByteCount(), pp.getKagSize()) + MXFPartition.roundToKag(pp.getIndexByteCount(), pp.getKagSize());
        return new MXFPartition(pp, essenceFilePos, closed, complete, nextPartition - essenceFilePos);
    };
    constructor.roundToKag = function(position, kag_size) {
        var ret = (stjs.trunc(position / kag_size)) * kag_size;
        return ret == position ? ret : ret + kag_size;
    };
    prototype.getPack = function() {
        return this.pack;
    };
    prototype.getEssenceFilePos = function() {
        return this.essenceFilePos;
    };
    prototype.isClosed = function() {
        return this.closed;
    };
    prototype.isComplete = function() {
        return this.complete;
    };
    prototype.getEssenceLength = function() {
        return this.essenceLength;
    };
}, {pack: "MXFPartitionPack"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A factory for MPEG TS virtual tracks coming out of streams of MPEG PS
 *  
 *  @author The JCodec project
 *  
 */
var MTSTrackFactory = function(index, fp) {
    this.programs = new ArrayList();
     while (index.remaining() >= 6){
        var len = index.getInt() - 4;
        var sub = NIOUtils.read(index, len);
        this.programs.add(new MTSTrackFactory.MTSProgram(sub, fp));
    }
};
MTSTrackFactory = stjs.extend(MTSTrackFactory, null, [], function(constructor, prototype) {
    prototype.programs = null;
    constructor.MTSProgram = function(index, fp) {
        MPSTrackFactory.call(this, index, fp);
    };
    constructor.MTSProgram = stjs.extend(constructor.MTSProgram, MPSTrackFactory, [], function(constructor, prototype) {
        prototype.targetGuid = 0;
        prototype.readIndex = function(index) {
            this.targetGuid = index.getShort() & 65535;
            MPSTrackFactory.prototype.readIndex.call(this, index);
        };
        prototype.createStream = function(streamId) {
            return new MTSTrackFactory.MTSProgram.MTSStream(streamId, this);
        };
        constructor.MTSStream = function(streamId, program) {
            MPSTrackFactory.Stream.call(this, streamId, program);
            this.program = program;
        };
        constructor.MTSStream = stjs.extend(constructor.MTSStream, MPSTrackFactory.Stream, [], function(constructor, prototype) {
            prototype.program = null;
            prototype.readPes = function(ch, pesPosition, pesSize, payloadSize, pesAbsIdx) {
                ch.setPosition(pesPosition * 188);
                var buf = NIOUtils.fetchFromChannel(ch, pesSize * 188);
                var dst = buf.duplicate();
                 while (buf.hasRemaining()){
                    var tsBuf = NIOUtils.read(buf, 188);
                    Assert.assertEquals(71, tsBuf.get() & 255);
                    var guidFlags = ((tsBuf.get() & 255) << 8) | (tsBuf.get() & 255);
                    var guid = stjs.trunc(guidFlags) & 8191;
                    if (guid == this.program.targetGuid) {
                        var b0 = tsBuf.get() & 255;
                        var counter = b0 & 15;
                        if ((b0 & 32) != 0) {
                            NIOUtils.skip(tsBuf, tsBuf.get() & 255);
                        }
                        dst.putBuf(tsBuf);
                    }
                }
                dst.flip();
                MPSUtils.readPESHeader(dst, 0);
                dst.setLimit(dst.position() + payloadSize);
                return dst;
            };
        }, {program: "MTSTrackFactory.MTSProgram", fsizes: "Int32Array", fpts: "Array", sync: "Int32Array", si: "ByteBuffer", factory: "MPSTrackFactory"}, {});
    }, {tracks: {name: "Map", arguments: [null, "MPSTrackFactory.Stream"]}, fp: "FilePool", pesTokens: "Array", streams: "Int32Array"}, {});
    prototype.getVideoStreams = function() {
        var ret = new ArrayList();
        for (var iterator$mtsProgram = this.programs.iterator(); iterator$mtsProgram.hasNext(); ) {
            var mtsProgram = iterator$mtsProgram.next();
            ret.addAll(mtsProgram.getVideoStreams());
        }
        return ret;
    };
    prototype.getAudioStreams = function() {
        var ret = new ArrayList();
        for (var iterator$mtsProgram = this.programs.iterator(); iterator$mtsProgram.hasNext(); ) {
            var mtsProgram = iterator$mtsProgram.next();
            ret.addAll(mtsProgram.getAudioStreams());
        }
        return ret;
    };
    prototype.getStreams = function() {
        var ret = new ArrayList();
        for (var iterator$mtsProgram = this.programs.iterator(); iterator$mtsProgram.hasNext(); ) {
            var mtsProgram = iterator$mtsProgram.next();
            ret.addAll(mtsProgram.getStreams());
        }
        return ret;
    };
    constructor.main1 = function(args) {
        var fp = new FilePool(new File(args[0]), 10);
        var factory = new MTSTrackFactory(NIOUtils.fetchFromFile(new File(args[1])), fp);
        var stream = factory.getVideoStreams().get(0);
        var ch = NIOUtils.writableChannel(new File(args[2]));
        var pkt = new ArrayList();
        for (var i = 0; i < 2000; i++) {
            pkt.add(stream.nextPacket());
        }
        for (var iterator$virtualPacket = pkt.iterator(); iterator$virtualPacket.hasNext(); ) {
            var virtualPacket = iterator$virtualPacket.next();
            ch.write(virtualPacket.getData());
        }
        ch.close();
    };
}, {programs: {name: "List", arguments: ["MTSTrackFactory.MTSProgram"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed under FreeBSD License
 *  
 *  EBML IO implementation
 *  
 *  @author The JCodec project
 *  
 */
var MKVType = function(name, id, clazz) {
    this._name = name;
    this.id = id;
    this.clazz = clazz;
    MKVType._values.add(this);
};
MKVType = stjs.extend(MKVType, null, [], function(constructor, prototype) {
    constructor._values = new ArrayList();
    constructor.Void = new MKVType("Void", new Int8Array([(236 << 24 >> 24)]), EbmlVoid);
    constructor.CRC32 = new MKVType("CRC32", new Int8Array([(191 << 24 >> 24)]), EbmlBin);
    constructor.EBML = new MKVType("EBML", new Int8Array([26, 69, (223 << 24 >> 24), (163 << 24 >> 24)]), EbmlMaster);
    constructor.EBMLVersion = new MKVType("EBMLVersion", new Int8Array([66, (134 << 24 >> 24)]), EbmlUint);
    constructor.EBMLReadVersion = new MKVType("EBMLReadVersion", new Int8Array([66, (247 << 24 >> 24)]), EbmlUint);
    constructor.EBMLMaxIDLength = new MKVType("EBMLMaxIDLength", new Int8Array([66, (242 << 24 >> 24)]), EbmlUint);
    constructor.EBMLMaxSizeLength = new MKVType("EBMLMaxSizeLength", new Int8Array([66, (243 << 24 >> 24)]), EbmlUint);
    constructor.DocType = new MKVType("DocType", new Int8Array([66, (130 << 24 >> 24)]), EbmlString);
    constructor.DocTypeVersion = new MKVType("DocTypeVersion", new Int8Array([66, (135 << 24 >> 24)]), EbmlUint);
    constructor.DocTypeReadVersion = new MKVType("DocTypeReadVersion", new Int8Array([66, (133 << 24 >> 24)]), EbmlUint);
    constructor.Segment = new MKVType("Segment", MkvSegment.SEGMENT_ID, MkvSegment);
    constructor.SeekHead = new MKVType("SeekHead", new Int8Array([17, 77, (155 << 24 >> 24), 116]), EbmlMaster);
    constructor.Seek = new MKVType("Seek", new Int8Array([77, (187 << 24 >> 24)]), EbmlMaster);
    constructor.SeekID = new MKVType("SeekID", new Int8Array([83, (171 << 24 >> 24)]), EbmlBin);
    constructor.SeekPosition = new MKVType("SeekPosition", new Int8Array([83, (172 << 24 >> 24)]), EbmlUint);
    constructor.Info = new MKVType("Info", new Int8Array([21, (73 << 24 >> 24), (169 << 24 >> 24), (102 << 24 >> 24)]), EbmlMaster);
    constructor.SegmentUID = new MKVType("SegmentUID", new Int8Array([115, (164 << 24 >> 24)]), EbmlBin);
    constructor.SegmentFilename = new MKVType("SegmentFilename", new Int8Array([115, (132 << 24 >> 24)]), EbmlString);
    constructor.PrevUID = new MKVType("PrevUID", new Int8Array([60, (185 << 24 >> 24), 35]), EbmlBin);
    constructor.PrevFilename = new MKVType("PrevFilename", new Int8Array([60, (131 << 24 >> 24), (171 << 24 >> 24)]), EbmlString);
    constructor.NextUID = new MKVType("NextUID", new Int8Array([62, (185 << 24 >> 24), 35]), EbmlBin);
    constructor.NextFilenam = new MKVType("NextFilenam", new Int8Array([62, (131 << 24 >> 24), (187 << 24 >> 24)]), EbmlString);
    constructor.SegmentFamily = new MKVType("SegmentFamily", new Int8Array([68, 68]), EbmlBin);
    constructor.ChapterTranslate = new MKVType("ChapterTranslate", new Int8Array([105, 36]), EbmlMaster);
    constructor.ChapterTranslateEditionUID = new MKVType("ChapterTranslateEditionUID", new Int8Array([105, (252 << 24 >> 24)]), EbmlUint);
    constructor.ChapterTranslateCodec = new MKVType("ChapterTranslateCodec", new Int8Array([105, (191 << 24 >> 24)]), EbmlUint);
    constructor.ChapterTranslateID = new MKVType("ChapterTranslateID", new Int8Array([105, (165 << 24 >> 24)]), EbmlBin);
    constructor.TimecodeScale = new MKVType("TimecodeScale", new Int8Array([42, (215 << 24 >> 24), (177 << 24 >> 24)]), EbmlUint);
    constructor.Duration = new MKVType("Duration", new Int8Array([68, (137 << 24 >> 24)]), EbmlFloat);
    constructor.DateUTC = new MKVType("DateUTC", new Int8Array([68, (97 << 24 >> 24)]), EbmlDate);
    constructor.Title = new MKVType("Title", new Int8Array([123, (169 << 24 >> 24)]), EbmlString);
    constructor.MuxingApp = new MKVType("MuxingApp", new Int8Array([77, (128 << 24 >> 24)]), EbmlString);
    constructor.WritingApp = new MKVType("WritingApp", new Int8Array([87, 65]), EbmlString);
    constructor.Cluster = new MKVType("Cluster", EbmlMaster.CLUSTER_ID, EbmlMaster);
    constructor.Timecode = new MKVType("Timecode", new Int8Array([(231 << 24 >> 24)]), EbmlUint);
    constructor.SilentTracks = new MKVType("SilentTracks", new Int8Array([88, 84]), EbmlMaster);
    constructor.SilentTrackNumber = new MKVType("SilentTrackNumber", new Int8Array([88, (215 << 24 >> 24)]), EbmlUint);
    constructor.Position = new MKVType("Position", new Int8Array([(167 << 24 >> 24)]), EbmlUint);
    constructor.PrevSize = new MKVType("PrevSize", new Int8Array([(171 << 24 >> 24)]), EbmlUint);
    constructor.SimpleBlock = new MKVType("SimpleBlock", MkvBlock.SIMPLEBLOCK_ID, MkvBlock);
    constructor.BlockGroup = new MKVType("BlockGroup", new Int8Array([(160 << 24 >> 24)]), EbmlMaster);
    constructor.Block = new MKVType("Block", MkvBlock.BLOCK_ID, MkvBlock);
    constructor.BlockAdditions = new MKVType("BlockAdditions", new Int8Array([117, (161 << 24 >> 24)]), EbmlMaster);
    constructor.BlockMore = new MKVType("BlockMore", new Int8Array([(166 << 24 >> 24)]), EbmlMaster);
    constructor.BlockAddID = new MKVType("BlockAddID", new Int8Array([(238 << 24 >> 24)]), EbmlUint);
    constructor.BlockAdditional = new MKVType("BlockAdditional", new Int8Array([(165 << 24 >> 24)]), EbmlBin);
    /**
     *  The duration of the Block (based on TimecodeScale). 
     *  This EbmlBase is mandatory when DefaultDuration is set for the track (but can be omitted as other default values). 
     *  When not written and with no DefaultDuration, the value is assumed to be the difference between the timecode 
     *  of this Block and the timecode of the next Block in "display" order (not coding order). 
     *  This EbmlBase can be useful at the end of a Track (as there is not other Block available); 
     *  or when there is a break in a track like for subtitle tracks. 
     *  When set to 0 that means the frame is not a keyframe.
     */
    constructor.BlockDuration = new MKVType("BlockDuration", new Int8Array([(155 << 24 >> 24)]), EbmlUint);
    constructor.ReferencePriority = new MKVType("ReferencePriority", new Int8Array([(250 << 24 >> 24)]), EbmlUint);
    constructor.ReferenceBlock = new MKVType("ReferenceBlock", new Int8Array([(251 << 24 >> 24)]), EbmlSint);
    constructor.CodecState = new MKVType("CodecState", new Int8Array([(164 << 24 >> 24)]), EbmlBin);
    constructor.Slices = new MKVType("Slices", new Int8Array([(142 << 24 >> 24)]), EbmlMaster);
    constructor.TimeSlice = new MKVType("TimeSlice", new Int8Array([(232 << 24 >> 24)]), EbmlMaster);
    constructor.LaceNumber = new MKVType("LaceNumber", new Int8Array([(204 << 24 >> 24)]), EbmlUint);
    constructor.Tracks = new MKVType("Tracks", new Int8Array([22, (84 << 24 >> 24), (174 << 24 >> 24), (107 << 24 >> 24)]), EbmlMaster);
    constructor.TrackEntry = new MKVType("TrackEntry", new Int8Array([(174 << 24 >> 24)]), EbmlMaster);
    constructor.TrackNumber = new MKVType("TrackNumber", new Int8Array([(215 << 24 >> 24)]), EbmlUint);
    constructor.TrackUID = new MKVType("TrackUID", new Int8Array([115, (197 << 24 >> 24)]), EbmlUint);
    constructor.TrackType = new MKVType("TrackType", new Int8Array([(131 << 24 >> 24)]), EbmlUint);
    constructor.FlagEnabled = new MKVType("FlagEnabled", new Int8Array([(185 << 24 >> 24)]), EbmlUint);
    constructor.FlagDefault = new MKVType("FlagDefault", new Int8Array([(136 << 24 >> 24)]), EbmlUint);
    constructor.FlagForced = new MKVType("FlagForced", new Int8Array([85, (170 << 24 >> 24)]), EbmlUint);
    constructor.FlagLacing = new MKVType("FlagLacing", new Int8Array([(156 << 24 >> 24)]), EbmlUint);
    constructor.MinCache = new MKVType("MinCache", new Int8Array([109, (231 << 24 >> 24)]), EbmlUint);
    constructor.MaxCache = new MKVType("MaxCache", new Int8Array([109, (248 << 24 >> 24)]), EbmlUint);
    constructor.DefaultDuration = new MKVType("DefaultDuration", new Int8Array([35, (227 << 24 >> 24), (131 << 24 >> 24)]), EbmlUint);
    constructor.MaxBlockAdditionID = new MKVType("MaxBlockAdditionID", new Int8Array([85, (238 << 24 >> 24)]), EbmlUint);
    constructor.Name = new MKVType("Name", new Int8Array([83, 110]), EbmlString);
    constructor.Language = new MKVType("Language", new Int8Array([34, (181 << 24 >> 24), (156 << 24 >> 24)]), EbmlString);
    constructor.CodecID = new MKVType("CodecID", new Int8Array([(134 << 24 >> 24)]), EbmlString);
    constructor.CodecPrivate = new MKVType("CodecPrivate", new Int8Array([(99 << 24 >> 24), (162 << 24 >> 24)]), EbmlBin);
    constructor.CodecName = new MKVType("CodecName", new Int8Array([(37 << 24 >> 24), (134 << 24 >> 24), (136 << 24 >> 24)]), EbmlString);
    constructor.AttachmentLink = new MKVType("AttachmentLink", new Int8Array([116, 70]), EbmlUint);
    constructor.CodecDecodeAll = new MKVType("CodecDecodeAll", new Int8Array([(170 << 24 >> 24)]), EbmlUint);
    constructor.TrackOverlay = new MKVType("TrackOverlay", new Int8Array([111, (171 << 24 >> 24)]), EbmlUint);
    constructor.TrackTranslate = new MKVType("TrackTranslate", new Int8Array([102, 36]), EbmlMaster);
    constructor.TrackTranslateEditionUID = new MKVType("TrackTranslateEditionUID", new Int8Array([102, (252 << 24 >> 24)]), EbmlUint);
    constructor.TrackTranslateCodec = new MKVType("TrackTranslateCodec", new Int8Array([102, (191 << 24 >> 24)]), EbmlUint);
    constructor.TrackTranslateTrackID = new MKVType("TrackTranslateTrackID", new Int8Array([102, (165 << 24 >> 24)]), EbmlBin);
    constructor.Video = new MKVType("Video", new Int8Array([(224 << 24 >> 24)]), EbmlMaster);
    constructor.FlagInterlaced = new MKVType("FlagInterlaced", new Int8Array([(154 << 24 >> 24)]), EbmlUint);
    constructor.StereoMode = new MKVType("StereoMode", new Int8Array([83, (184 << 24 >> 24)]), EbmlUint);
    constructor.AlphaMode = new MKVType("AlphaMode", new Int8Array([83, (192 << 24 >> 24)]), EbmlUint);
    constructor.PixelWidth = new MKVType("PixelWidth", new Int8Array([(176 << 24 >> 24)]), EbmlUint);
    constructor.PixelHeight = new MKVType("PixelHeight", new Int8Array([(186 << 24 >> 24)]), EbmlUint);
    constructor.PixelCropBottom = new MKVType("PixelCropBottom", new Int8Array([84, (170 << 24 >> 24)]), EbmlUint);
    constructor.PixelCropTop = new MKVType("PixelCropTop", new Int8Array([84, (187 << 24 >> 24)]), EbmlUint);
    constructor.PixelCropLeft = new MKVType("PixelCropLeft", new Int8Array([84, (204 << 24 >> 24)]), EbmlUint);
    constructor.PixelCropRight = new MKVType("PixelCropRight", new Int8Array([84, (221 << 24 >> 24)]), EbmlUint);
    constructor.DisplayWidth = new MKVType("DisplayWidth", new Int8Array([84, (176 << 24 >> 24)]), EbmlUint);
    constructor.DisplayHeight = new MKVType("DisplayHeight", new Int8Array([84, (186 << 24 >> 24)]), EbmlUint);
    constructor.DisplayUnit = new MKVType("DisplayUnit", new Int8Array([84, (178 << 24 >> 24)]), EbmlUint);
    constructor.AspectRatioType = new MKVType("AspectRatioType", new Int8Array([84, (179 << 24 >> 24)]), EbmlUint);
    constructor.ColourSpace = new MKVType("ColourSpace", new Int8Array([46, (181 << 24 >> 24), 36]), EbmlBin);
    constructor.Audio = new MKVType("Audio", new Int8Array([(225 << 24 >> 24)]), EbmlMaster);
    constructor.SamplingFrequency = new MKVType("SamplingFrequency", new Int8Array([(181 << 24 >> 24)]), EbmlFloat);
    constructor.OutputSamplingFrequency = new MKVType("OutputSamplingFrequency", new Int8Array([120, (181 << 24 >> 24)]), EbmlFloat);
    constructor.Channels = new MKVType("Channels", new Int8Array([(159 << 24 >> 24)]), EbmlUint);
    constructor.BitDepth = new MKVType("BitDepth", new Int8Array([98, 100]), EbmlUint);
    constructor.TrackOperation = new MKVType("TrackOperation", new Int8Array([(226 << 24 >> 24)]), EbmlMaster);
    constructor.TrackCombinePlanes = new MKVType("TrackCombinePlanes", new Int8Array([(227 << 24 >> 24)]), EbmlMaster);
    constructor.TrackPlane = new MKVType("TrackPlane", new Int8Array([(228 << 24 >> 24)]), EbmlMaster);
    constructor.TrackPlaneUID = new MKVType("TrackPlaneUID", new Int8Array([(229 << 24 >> 24)]), EbmlUint);
    constructor.TrackPlaneType = new MKVType("TrackPlaneType", new Int8Array([(230 << 24 >> 24)]), EbmlUint);
    constructor.TrackJoinBlocks = new MKVType("TrackJoinBlocks", new Int8Array([(233 << 24 >> 24)]), EbmlMaster);
    constructor.TrackJoinUID = new MKVType("TrackJoinUID", new Int8Array([(237 << 24 >> 24)]), EbmlUint);
    constructor.ContentEncodings = new MKVType("ContentEncodings", new Int8Array([109, (128 << 24 >> 24)]), EbmlMaster);
    constructor.ContentEncoding = new MKVType("ContentEncoding", new Int8Array([98, 64]), EbmlMaster);
    constructor.ContentEncodingOrder = new MKVType("ContentEncodingOrder", new Int8Array([80, 49]), EbmlUint);
    constructor.ContentEncodingScope = new MKVType("ContentEncodingScope", new Int8Array([80, 50]), EbmlUint);
    constructor.ContentEncodingType = new MKVType("ContentEncodingType", new Int8Array([80, 51]), EbmlUint);
    constructor.ContentCompression = new MKVType("ContentCompression", new Int8Array([80, 52]), EbmlMaster);
    constructor.ContentCompAlgo = new MKVType("ContentCompAlgo", new Int8Array([66, (84 << 24 >> 24)]), EbmlUint);
    constructor.ContentCompSettings = new MKVType("ContentCompSettings", new Int8Array([66, 85]), EbmlBin);
    constructor.ContentEncryption = new MKVType("ContentEncryption", new Int8Array([80, 53]), EbmlMaster);
    constructor.ContentEncAlgo = new MKVType("ContentEncAlgo", new Int8Array([71, (225 << 24 >> 24)]), EbmlUint);
    constructor.ContentEncKeyID = new MKVType("ContentEncKeyID", new Int8Array([71, (226 << 24 >> 24)]), EbmlBin);
    constructor.ContentSignature = new MKVType("ContentSignature", new Int8Array([71, (227 << 24 >> 24)]), EbmlBin);
    constructor.ContentSigKeyID = new MKVType("ContentSigKeyID", new Int8Array([71, (228 << 24 >> 24)]), EbmlBin);
    constructor.ContentSigAlgo = new MKVType("ContentSigAlgo", new Int8Array([71, (229 << 24 >> 24)]), EbmlUint);
    constructor.ContentSigHashAlgo = new MKVType("ContentSigHashAlgo", new Int8Array([71, (230 << 24 >> 24)]), EbmlUint);
    constructor.Cues = new MKVType("Cues", new Int8Array([28, 83, (187 << 24 >> 24), 107]), EbmlMaster);
    constructor.CuePoint = new MKVType("CuePoint", new Int8Array([(187 << 24 >> 24)]), EbmlMaster);
    constructor.CueTime = new MKVType("CueTime", new Int8Array([(179 << 24 >> 24)]), EbmlUint);
    constructor.CueTrackPositions = new MKVType("CueTrackPositions", new Int8Array([(183 << 24 >> 24)]), EbmlMaster);
    constructor.CueTrack = new MKVType("CueTrack", new Int8Array([(247 << 24 >> 24)]), EbmlUint);
    constructor.CueClusterPosition = new MKVType("CueClusterPosition", new Int8Array([(241 << 24 >> 24)]), EbmlUint);
    constructor.CueRelativePosition = new MKVType("CueRelativePosition", new Int8Array([(240 << 24 >> 24)]), EbmlUint);
    constructor.CueDuration = new MKVType("CueDuration", new Int8Array([(178 << 24 >> 24)]), EbmlUint);
    constructor.CueBlockNumber = new MKVType("CueBlockNumber", new Int8Array([83, 120]), EbmlUint);
    constructor.CueCodecState = new MKVType("CueCodecState", new Int8Array([(234 << 24 >> 24)]), EbmlUint);
    constructor.CueReference = new MKVType("CueReference", new Int8Array([(219 << 24 >> 24)]), EbmlMaster);
    constructor.CueRefTime = new MKVType("CueRefTime", new Int8Array([(150 << 24 >> 24)]), EbmlUint);
    constructor.Attachments = new MKVType("Attachments", new Int8Array([25, 65, (164 << 24 >> 24), 105]), EbmlMaster);
    constructor.AttachedFile = new MKVType("AttachedFile", new Int8Array([97, (167 << 24 >> 24)]), EbmlMaster);
    constructor.FileDescription = new MKVType("FileDescription", new Int8Array([70, (126 << 24 >> 24)]), EbmlString);
    constructor.FileName = new MKVType("FileName", new Int8Array([70, (110 << 24 >> 24)]), EbmlString);
    constructor.FileMimeType = new MKVType("FileMimeType", new Int8Array([70, (96 << 24 >> 24)]), EbmlString);
    constructor.FileData = new MKVType("FileData", new Int8Array([70, (92 << 24 >> 24)]), EbmlBin);
    constructor.FileUID = new MKVType("FileUID", new Int8Array([70, (174 << 24 >> 24)]), EbmlUint);
    constructor.Chapters = new MKVType("Chapters", new Int8Array([16, (67 << 24 >> 24), (167 << 24 >> 24), (112 << 24 >> 24)]), EbmlMaster);
    constructor.EditionEntry = new MKVType("EditionEntry", new Int8Array([(69 << 24 >> 24), (185 << 24 >> 24)]), EbmlMaster);
    constructor.EditionUID = new MKVType("EditionUID", new Int8Array([(69 << 24 >> 24), (188 << 24 >> 24)]), EbmlUint);
    constructor.EditionFlagHidden = new MKVType("EditionFlagHidden", new Int8Array([(69 << 24 >> 24), (189 << 24 >> 24)]), EbmlUint);
    constructor.EditionFlagDefault = new MKVType("EditionFlagDefault", new Int8Array([(69 << 24 >> 24), (219 << 24 >> 24)]), EbmlUint);
    constructor.EditionFlagOrdered = new MKVType("EditionFlagOrdered", new Int8Array([(69 << 24 >> 24), (221 << 24 >> 24)]), EbmlUint);
    constructor.ChapterAtom = new MKVType("ChapterAtom", new Int8Array([(182 << 24 >> 24)]), EbmlMaster);
    constructor.ChapterUID = new MKVType("ChapterUID", new Int8Array([(115 << 24 >> 24), (196 << 24 >> 24)]), EbmlUint);
    constructor.ChapterStringUID = new MKVType("ChapterStringUID", new Int8Array([86, 84]), EbmlString);
    constructor.ChapterTimeStart = new MKVType("ChapterTimeStart", new Int8Array([(145 << 24 >> 24)]), EbmlUint);
    constructor.ChapterTimeEnd = new MKVType("ChapterTimeEnd", new Int8Array([(146 << 24 >> 24)]), EbmlUint);
    constructor.ChapterFlagHidden = new MKVType("ChapterFlagHidden", new Int8Array([(152 << 24 >> 24)]), EbmlUint);
    constructor.ChapterFlagEnabled = new MKVType("ChapterFlagEnabled", new Int8Array([(69 << 24 >> 24), (152 << 24 >> 24)]), EbmlUint);
    constructor.ChapterSegmentUID = new MKVType("ChapterSegmentUID", new Int8Array([110, 103]), EbmlBin);
    constructor.ChapterSegmentEditionUID = new MKVType("ChapterSegmentEditionUID", new Int8Array([110, (188 << 24 >> 24)]), EbmlUint);
    constructor.ChapterPhysicalEquiv = new MKVType("ChapterPhysicalEquiv", new Int8Array([(99 << 24 >> 24), (195 << 24 >> 24)]), EbmlUint);
    constructor.ChapterTrack = new MKVType("ChapterTrack", new Int8Array([(143 << 24 >> 24)]), EbmlMaster);
    constructor.ChapterTrackNumber = new MKVType("ChapterTrackNumber", new Int8Array([(137 << 24 >> 24)]), EbmlUint);
    constructor.ChapterDisplay = new MKVType("ChapterDisplay", new Int8Array([(128 << 24 >> 24)]), EbmlMaster);
    constructor.ChapString = new MKVType("ChapString", new Int8Array([(133 << 24 >> 24)]), EbmlString);
    constructor.ChapLanguage = new MKVType("ChapLanguage", new Int8Array([(67 << 24 >> 24), (124 << 24 >> 24)]), EbmlString);
    constructor.ChapCountry = new MKVType("ChapCountry", new Int8Array([(67 << 24 >> 24), (126 << 24 >> 24)]), EbmlString);
    constructor.ChapProcess = new MKVType("ChapProcess", new Int8Array([105, 68]), EbmlMaster);
    constructor.ChapProcessCodecID = new MKVType("ChapProcessCodecID", new Int8Array([105, 85]), EbmlUint);
    constructor.ChapProcessPrivate = new MKVType("ChapProcessPrivate", new Int8Array([69, 13]), EbmlBin);
    constructor.ChapProcessCommand = new MKVType("ChapProcessCommand", new Int8Array([105, 17]), EbmlMaster);
    constructor.ChapProcessTime = new MKVType("ChapProcessTime", new Int8Array([105, 34]), EbmlUint);
    constructor.ChapProcessData = new MKVType("ChapProcessData", new Int8Array([105, 51]), EbmlBin);
    constructor.Tags = new MKVType("Tags", new Int8Array([18, (84 << 24 >> 24), (195 << 24 >> 24), (103 << 24 >> 24)]), EbmlMaster);
    constructor.Tag = new MKVType("Tag", new Int8Array([115, (115 << 24 >> 24)]), EbmlMaster);
    constructor.Targets = new MKVType("Targets", new Int8Array([99, (192 << 24 >> 24)]), EbmlMaster);
    constructor.TargetTypeValue = new MKVType("TargetTypeValue", new Int8Array([104, (202 << 24 >> 24)]), EbmlUint);
    constructor.TargetType = new MKVType("TargetType", new Int8Array([99, (202 << 24 >> 24)]), EbmlString);
    constructor.TagTrackUID = new MKVType("TagTrackUID", new Int8Array([99, (197 << 24 >> 24)]), EbmlUint);
    constructor.TagEditionUID = new MKVType("TagEditionUID", new Int8Array([99, (201 << 24 >> 24)]), EbmlUint);
    constructor.TagChapterUID = new MKVType("TagChapterUID", new Int8Array([99, (196 << 24 >> 24)]), EbmlUint);
    constructor.TagAttachmentUID = new MKVType("TagAttachmentUID", new Int8Array([99, (198 << 24 >> 24)]), EbmlUint);
    constructor.SimpleTag = new MKVType("SimpleTag", new Int8Array([103, (200 << 24 >> 24)]), EbmlMaster);
    constructor.TagName = new MKVType("TagName", new Int8Array([69, (163 << 24 >> 24)]), EbmlString);
    constructor.TagLanguage = new MKVType("TagLanguage", new Int8Array([68, 122]), EbmlString);
    constructor.TagDefault = new MKVType("TagDefault", new Int8Array([68, (132 << 24 >> 24)]), EbmlUint);
    constructor.TagString = new MKVType("TagString", new Int8Array([68, (135 << 24 >> 24)]), EbmlString);
    constructor.TagBinary = new MKVType("TagBinary", new Int8Array([68, (133 << 24 >> 24)]), EbmlBin);
    constructor.firstLevelHeaders = [MKVType.SeekHead, MKVType.Info, MKVType.Cluster, MKVType.Tracks, MKVType.Cues, MKVType.Attachments, MKVType.Chapters, MKVType.Tags, MKVType.EBMLVersion, MKVType.EBMLReadVersion, MKVType.EBMLMaxIDLength, MKVType.EBMLMaxSizeLength, MKVType.DocType, MKVType.DocTypeVersion, MKVType.DocTypeReadVersion];
    prototype.id = null;
    prototype.clazz = null;
    prototype._name = null;
    prototype.name = function() {
        return this._name;
    };
    prototype.toString = function() {
        return this._name;
    };
    constructor.values = function() {
        return MKVType._values.toArray(Array(0));
    };
    constructor.createByType = function(g) {
        try {
            var elem = Platform.newInstance(g.clazz, [g.id]);
            elem.type = g;
            return elem;
        }catch (e) {
            e.printStackTrace();
            return new EbmlBin(g.id);
        }
    };
    constructor.createById = function(id, offset) {
        var values = MKVType.values();
        for (var i = 0; i < values.length; i++) {
            var t = values[i];
            if (Platform.arrayEqualsByte(t.id, id)) 
                return MKVType.createByType(t);
        }
        System.err.println("WARNING: unspecified ebml ID (" + EbmlUtil.toHexString(id) + ") encountered at position 0x" + Long.toHexString(offset).toUpperCase());
        var t = new EbmlVoid(id);
        t.type = MKVType.Void;
        return t;
    };
    constructor.isHeaderFirstByte = function(b) {
        var values = MKVType.values();
        for (var i = 0; i < values.length; i++) {
            var t = values[i];
            if (t.id[0] == b) 
                return true;
        }
        return false;
    };
    constructor.isSpecifiedHeader = function(b) {
        var values = MKVType.values();
        for (var i = 0; i < values.length; i++) {
            var firstLevelHeader = values[i];
            if (Platform.arrayEqualsByte(firstLevelHeader.id, b)) 
                return true;
        }
        return false;
    };
    constructor.isFirstLevelHeader = function(b) {
        for (var firstLevelHeader in MKVType.firstLevelHeaders) 
            if (Platform.arrayEqualsByte(firstLevelHeader.id, b)) 
                return true;
        return false;
    };
    constructor.children = new HashMap();
    constructor.getParent = function(t) {
        for (var iterator$ent = MKVType.children.entrySet().iterator(); iterator$ent.hasNext(); ) {
            var ent = iterator$ent.next();
            if (ent.getValue().contains(t)) 
                return ent.getKey();
        }
        return null;
    };
    constructor.possibleChild = function(parent, child) {
        if (parent == null) 
            if (child.type == MKVType.EBML || child.type == MKVType.Segment) 
                return true;
             else 
                return false;
        if (Platform.arrayEqualsByte(child.id, MKVType.Void.id) || Platform.arrayEqualsByte(child.id, MKVType.CRC32.id)) 
            return !(child.offset == (parent.dataOffset + parent.dataLen));
        if (child.type == MKVType.Void || child.type == MKVType.CRC32) 
            return true;
        var candidates = MKVType.children.get(parent.type);
        return candidates != null && candidates.contains(child.type);
    };
    constructor.possibleChildById = function(parent, typeId) {
        if (parent == null && (Platform.arrayEqualsByte(MKVType.EBML.id, typeId) || Platform.arrayEqualsByte(MKVType.Segment.id, typeId))) 
            return true;
        if (parent == null) 
            return false;
        if (Platform.arrayEqualsByte(MKVType.Void.id, typeId) || Platform.arrayEqualsByte(MKVType.CRC32.id, typeId)) 
            return true;
        for (var iterator$aCandidate = MKVType.children.get(parent.type).iterator(); iterator$aCandidate.hasNext(); ) {
            var aCandidate = iterator$aCandidate.next();
            if (Platform.arrayEqualsByte(aCandidate.id, typeId)) 
                return true;
        }
        return false;
    };
    constructor.findFirst = function(master, path) {
        var tlist = new LinkedList(Arrays.asList(path));
        return MKVType.findFirstSub(master, tlist);
    };
    constructor.findFirstTree = function(tree, path) {
        var tlist = new LinkedList(Arrays.asList(path));
        for (var iterator$e = tree.iterator(); iterator$e.hasNext(); ) {
            var e = iterator$e.next();
            var z = MKVType.findFirstSub(e, tlist);
            if (z != null) 
                return z;
        }
        return null;
    };
    constructor.findFirstSub = function(elem, path) {
        if (path.size() == 0) 
            return null;
        if (!elem.type.equals(path.get(0))) 
            return null;
        if (path.size() == 1) 
            return elem;
        var head = path.remove(0);
        var result = null;
        if (stjs.isInstanceOf(elem.constructor, EbmlMaster)) {
            var iter = (elem).children.iterator();
             while (iter.hasNext() && result == null)
                result = MKVType.findFirstSub(iter.next(), path);
        }
        path.add(0, head);
        return result;
    };
    constructor.findList = function(tree, class1, path) {
        var result = new LinkedList();
        var tlist = new LinkedList(Arrays.asList(path));
        if (tlist.size() > 0) 
            for (var iterator$node = tree.iterator(); iterator$node.hasNext(); ) {
                var node = iterator$node.next();
                var head = tlist.remove(0);
                if (head == null || head.equals(node.type)) {
                    MKVType.findSubList(node, tlist, result);
                }
                tlist.add(0, head);
            }
        return result;
    };
    constructor.findSubList = function(element, path, result) {
        if (path.size() > 0) {
            var head = path.remove(0);
            if (stjs.isInstanceOf(element.constructor, EbmlMaster)) {
                var nb = element;
                for (var iterator$candidate = nb.children.iterator(); iterator$candidate.hasNext(); ) {
                    var candidate = iterator$candidate.next();
                    if (head == null || head.equals(candidate.type)) {
                        MKVType.findSubList(candidate, path, result);
                    }
                }
            }
            path.add(0, head);
        } else {
            result.add(element);
        }
    };
    constructor.findAllTree = function(tree, class1, path) {
        var result = new LinkedList();
        var tlist = new LinkedList(Arrays.asList(path));
        if (tlist.size() > 0) 
            for (var iterator$node = tree.iterator(); iterator$node.hasNext(); ) {
                var node = iterator$node.next();
                var head = tlist.remove(0);
                if (head == null || head.equals(node.type)) {
                    MKVType.findSub(node, tlist, result);
                }
                tlist.add(0, head);
            }
        return result.toArray(jslang.reflect.Array.newInstance(class1, 0));
    };
    constructor.findAll = function(master, class1, ga, path) {
        var result = new LinkedList();
        var tlist = new LinkedList(Arrays.asList(path));
        if (!master.type.equals(tlist.get(0))) 
            return result.toArray(jslang.reflect.Array.newInstance(class1, 0));
        tlist.remove(0);
        MKVType.findSub(master, tlist, result);
        return result.toArray(jslang.reflect.Array.newInstance(class1, 0));
    };
    constructor.findSub = function(master, path, result) {
        if (path.size() > 0) {
            var head = path.remove(0);
            if (stjs.isInstanceOf(master.constructor, EbmlMaster)) {
                var nb = master;
                for (var iterator$candidate = nb.children.iterator(); iterator$candidate.hasNext(); ) {
                    var candidate = iterator$candidate.next();
                    if (head == null || head.equals(candidate.type)) {
                        MKVType.findSub(candidate, path, result);
                    }
                }
            }
            path.add(0, head);
        } else {
            result.add(master);
        }
    };
}, {_values: {name: "List", arguments: ["MKVType"]}, Void: "MKVType", CRC32: "MKVType", EBML: "MKVType", EBMLVersion: "MKVType", EBMLReadVersion: "MKVType", EBMLMaxIDLength: "MKVType", EBMLMaxSizeLength: "MKVType", DocType: "MKVType", DocTypeVersion: "MKVType", DocTypeReadVersion: "MKVType", Segment: "MKVType", SeekHead: "MKVType", Seek: "MKVType", SeekID: "MKVType", SeekPosition: "MKVType", Info: "MKVType", SegmentUID: "MKVType", SegmentFilename: "MKVType", PrevUID: "MKVType", PrevFilename: "MKVType", NextUID: "MKVType", NextFilenam: "MKVType", SegmentFamily: "MKVType", ChapterTranslate: "MKVType", ChapterTranslateEditionUID: "MKVType", ChapterTranslateCodec: "MKVType", ChapterTranslateID: "MKVType", TimecodeScale: "MKVType", Duration: "MKVType", DateUTC: "MKVType", Title: "MKVType", MuxingApp: "MKVType", WritingApp: "MKVType", Cluster: "MKVType", Timecode: "MKVType", SilentTracks: "MKVType", SilentTrackNumber: "MKVType", Position: "MKVType", PrevSize: "MKVType", SimpleBlock: "MKVType", BlockGroup: "MKVType", Block: "MKVType", BlockAdditions: "MKVType", BlockMore: "MKVType", BlockAddID: "MKVType", BlockAdditional: "MKVType", BlockDuration: "MKVType", ReferencePriority: "MKVType", ReferenceBlock: "MKVType", CodecState: "MKVType", Slices: "MKVType", TimeSlice: "MKVType", LaceNumber: "MKVType", Tracks: "MKVType", TrackEntry: "MKVType", TrackNumber: "MKVType", TrackUID: "MKVType", TrackType: "MKVType", FlagEnabled: "MKVType", FlagDefault: "MKVType", FlagForced: "MKVType", FlagLacing: "MKVType", MinCache: "MKVType", MaxCache: "MKVType", DefaultDuration: "MKVType", MaxBlockAdditionID: "MKVType", Name: "MKVType", Language: "MKVType", CodecID: "MKVType", CodecPrivate: "MKVType", CodecName: "MKVType", AttachmentLink: "MKVType", CodecDecodeAll: "MKVType", TrackOverlay: "MKVType", TrackTranslate: "MKVType", TrackTranslateEditionUID: "MKVType", TrackTranslateCodec: "MKVType", TrackTranslateTrackID: "MKVType", Video: "MKVType", FlagInterlaced: "MKVType", StereoMode: "MKVType", AlphaMode: "MKVType", PixelWidth: "MKVType", PixelHeight: "MKVType", PixelCropBottom: "MKVType", PixelCropTop: "MKVType", PixelCropLeft: "MKVType", PixelCropRight: "MKVType", DisplayWidth: "MKVType", DisplayHeight: "MKVType", DisplayUnit: "MKVType", AspectRatioType: "MKVType", ColourSpace: "MKVType", Audio: "MKVType", SamplingFrequency: "MKVType", OutputSamplingFrequency: "MKVType", Channels: "MKVType", BitDepth: "MKVType", TrackOperation: "MKVType", TrackCombinePlanes: "MKVType", TrackPlane: "MKVType", TrackPlaneUID: "MKVType", TrackPlaneType: "MKVType", TrackJoinBlocks: "MKVType", TrackJoinUID: "MKVType", ContentEncodings: "MKVType", ContentEncoding: "MKVType", ContentEncodingOrder: "MKVType", ContentEncodingScope: "MKVType", ContentEncodingType: "MKVType", ContentCompression: "MKVType", ContentCompAlgo: "MKVType", ContentCompSettings: "MKVType", ContentEncryption: "MKVType", ContentEncAlgo: "MKVType", ContentEncKeyID: "MKVType", ContentSignature: "MKVType", ContentSigKeyID: "MKVType", ContentSigAlgo: "MKVType", ContentSigHashAlgo: "MKVType", Cues: "MKVType", CuePoint: "MKVType", CueTime: "MKVType", CueTrackPositions: "MKVType", CueTrack: "MKVType", CueClusterPosition: "MKVType", CueRelativePosition: "MKVType", CueDuration: "MKVType", CueBlockNumber: "MKVType", CueCodecState: "MKVType", CueReference: "MKVType", CueRefTime: "MKVType", Attachments: "MKVType", AttachedFile: "MKVType", FileDescription: "MKVType", FileName: "MKVType", FileMimeType: "MKVType", FileData: "MKVType", FileUID: "MKVType", Chapters: "MKVType", EditionEntry: "MKVType", EditionUID: "MKVType", EditionFlagHidden: "MKVType", EditionFlagDefault: "MKVType", EditionFlagOrdered: "MKVType", ChapterAtom: "MKVType", ChapterUID: "MKVType", ChapterStringUID: "MKVType", ChapterTimeStart: "MKVType", ChapterTimeEnd: "MKVType", ChapterFlagHidden: "MKVType", ChapterFlagEnabled: "MKVType", ChapterSegmentUID: "MKVType", ChapterSegmentEditionUID: "MKVType", ChapterPhysicalEquiv: "MKVType", ChapterTrack: "MKVType", ChapterTrackNumber: "MKVType", ChapterDisplay: "MKVType", ChapString: "MKVType", ChapLanguage: "MKVType", ChapCountry: "MKVType", ChapProcess: "MKVType", ChapProcessCodecID: "MKVType", ChapProcessPrivate: "MKVType", ChapProcessCommand: "MKVType", ChapProcessTime: "MKVType", ChapProcessData: "MKVType", Tags: "MKVType", Tag: "MKVType", Targets: "MKVType", TargetTypeValue: "MKVType", TargetType: "MKVType", TagTrackUID: "MKVType", TagEditionUID: "MKVType", TagChapterUID: "MKVType", TagAttachmentUID: "MKVType", SimpleTag: "MKVType", TagName: "MKVType", TagLanguage: "MKVType", TagDefault: "MKVType", TagString: "MKVType", TagBinary: "MKVType", firstLevelHeaders: "Array", id: "Int8Array", clazz: {name: "Class", arguments: ["Object"]}, children: {name: "Map", arguments: ["MKVType", {name: "Set", arguments: ["MKVType"]}]}}, {});
(function() {
    MKVType.children.put(MKVType.EBML, new HashSet(Arrays.asList([MKVType.EBMLVersion, MKVType.EBMLReadVersion, MKVType.EBMLMaxIDLength, MKVType.EBMLMaxSizeLength, MKVType.DocType, MKVType.DocTypeVersion, MKVType.DocTypeReadVersion])));
    MKVType.children.put(MKVType.Segment, new HashSet(Arrays.asList([MKVType.SeekHead, MKVType.Info, MKVType.Cluster, MKVType.Tracks, MKVType.Cues, MKVType.Attachments, MKVType.Chapters, MKVType.Tags])));
    MKVType.children.put(MKVType.SeekHead, new HashSet(Arrays.asList([MKVType.Seek])));
    MKVType.children.put(MKVType.Seek, new HashSet(Arrays.asList([MKVType.SeekID, MKVType.SeekPosition])));
    MKVType.children.put(MKVType.Info, new HashSet(Arrays.asList([MKVType.SegmentUID, MKVType.SegmentFilename, MKVType.PrevUID, MKVType.PrevFilename, MKVType.NextUID, MKVType.NextFilenam, MKVType.SegmentFamily, MKVType.ChapterTranslate, MKVType.TimecodeScale, MKVType.Duration, MKVType.DateUTC, MKVType.Title, MKVType.MuxingApp, MKVType.WritingApp])));
    MKVType.children.put(MKVType.ChapterTranslate, new HashSet(Arrays.asList([MKVType.ChapterTranslateEditionUID, MKVType.ChapterTranslateCodec, MKVType.ChapterTranslateID])));
    MKVType.children.put(MKVType.Cluster, new HashSet(Arrays.asList([MKVType.Timecode, MKVType.SilentTracks, MKVType.Position, MKVType.PrevSize, MKVType.SimpleBlock, MKVType.BlockGroup])));
    MKVType.children.put(MKVType.SilentTracks, new HashSet(Arrays.asList([MKVType.SilentTrackNumber])));
    MKVType.children.put(MKVType.BlockGroup, new HashSet(Arrays.asList([MKVType.Block, MKVType.BlockAdditions, MKVType.BlockDuration, MKVType.ReferencePriority, MKVType.ReferenceBlock, MKVType.CodecState, MKVType.Slices])));
    MKVType.children.put(MKVType.BlockAdditions, new HashSet(Arrays.asList([MKVType.BlockMore])));
    MKVType.children.put(MKVType.BlockMore, new HashSet(Arrays.asList([MKVType.BlockAddID, MKVType.BlockAdditional])));
    MKVType.children.put(MKVType.Slices, new HashSet(Arrays.asList([MKVType.TimeSlice])));
    MKVType.children.put(MKVType.TimeSlice, new HashSet(Arrays.asList([MKVType.LaceNumber])));
    MKVType.children.put(MKVType.Tracks, new HashSet(Arrays.asList([MKVType.TrackEntry])));
    MKVType.children.put(MKVType.TrackEntry, new HashSet(Arrays.asList([MKVType.TrackNumber, MKVType.TrackUID, MKVType.TrackType, MKVType.TrackType, MKVType.FlagDefault, MKVType.FlagForced, MKVType.FlagLacing, MKVType.MinCache, MKVType.MaxCache, MKVType.DefaultDuration, MKVType.MaxBlockAdditionID, MKVType.Name, MKVType.Language, MKVType.CodecID, MKVType.CodecPrivate, MKVType.CodecName, MKVType.AttachmentLink, MKVType.CodecDecodeAll, MKVType.TrackOverlay, MKVType.TrackTranslate, MKVType.Video, MKVType.Audio, MKVType.TrackOperation, MKVType.ContentEncodings])));
    MKVType.children.put(MKVType.TrackTranslate, new HashSet(Arrays.asList([MKVType.TrackTranslateEditionUID, MKVType.TrackTranslateCodec, MKVType.TrackTranslateTrackID])));
    MKVType.children.put(MKVType.Video, new HashSet(Arrays.asList([MKVType.FlagInterlaced, MKVType.StereoMode, MKVType.AlphaMode, MKVType.PixelWidth, MKVType.PixelHeight, MKVType.PixelCropBottom, MKVType.PixelCropTop, MKVType.PixelCropLeft, MKVType.PixelCropRight, MKVType.DisplayWidth, MKVType.DisplayHeight, MKVType.DisplayUnit, MKVType.AspectRatioType, MKVType.ColourSpace])));
    MKVType.children.put(MKVType.Audio, new HashSet(Arrays.asList([MKVType.SamplingFrequency, MKVType.OutputSamplingFrequency, MKVType.Channels, MKVType.BitDepth])));
    MKVType.children.put(MKVType.TrackOperation, new HashSet(Arrays.asList([MKVType.TrackCombinePlanes, MKVType.TrackJoinBlocks])));
    MKVType.children.put(MKVType.TrackCombinePlanes, new HashSet(Arrays.asList([MKVType.TrackPlane])));
    MKVType.children.put(MKVType.TrackPlane, new HashSet(Arrays.asList([MKVType.TrackPlaneUID, MKVType.TrackPlaneType])));
    MKVType.children.put(MKVType.TrackJoinBlocks, new HashSet(Arrays.asList([MKVType.TrackJoinUID])));
    MKVType.children.put(MKVType.ContentEncodings, new HashSet(Arrays.asList([MKVType.ContentEncoding])));
    MKVType.children.put(MKVType.ContentEncoding, new HashSet(Arrays.asList([MKVType.ContentEncodingOrder, MKVType.ContentEncodingScope, MKVType.ContentEncodingType, MKVType.ContentCompression, MKVType.ContentEncryption])));
    MKVType.children.put(MKVType.ContentCompression, new HashSet(Arrays.asList([MKVType.ContentCompAlgo, MKVType.ContentCompSettings])));
    MKVType.children.put(MKVType.ContentEncryption, new HashSet(Arrays.asList([MKVType.ContentEncAlgo, MKVType.ContentEncKeyID, MKVType.ContentSignature, MKVType.ContentSigKeyID, MKVType.ContentSigAlgo, MKVType.ContentSigHashAlgo])));
    MKVType.children.put(MKVType.Cues, new HashSet(Arrays.asList([MKVType.CuePoint])));
    MKVType.children.put(MKVType.CuePoint, new HashSet(Arrays.asList([MKVType.CueTime, MKVType.CueTrackPositions])));
    MKVType.children.put(MKVType.CueTrackPositions, new HashSet(Arrays.asList([MKVType.CueTrack, MKVType.CueClusterPosition, MKVType.CueRelativePosition, MKVType.CueDuration, MKVType.CueBlockNumber, MKVType.CueCodecState, MKVType.CueReference])));
    MKVType.children.put(MKVType.CueReference, new HashSet(Arrays.asList([MKVType.CueRefTime])));
    MKVType.children.put(MKVType.Attachments, new HashSet(Arrays.asList([MKVType.AttachedFile])));
    MKVType.children.put(MKVType.AttachedFile, new HashSet(Arrays.asList([MKVType.FileDescription, MKVType.FileName, MKVType.FileMimeType, MKVType.FileData, MKVType.FileUID])));
    MKVType.children.put(MKVType.Chapters, new HashSet(Arrays.asList([MKVType.EditionEntry])));
    MKVType.children.put(MKVType.EditionEntry, new HashSet(Arrays.asList([MKVType.EditionUID, MKVType.EditionFlagHidden, MKVType.EditionFlagDefault, MKVType.EditionFlagOrdered, MKVType.ChapterAtom])));
    MKVType.children.put(MKVType.ChapterAtom, new HashSet(Arrays.asList([MKVType.ChapterUID, MKVType.ChapterStringUID, MKVType.ChapterTimeStart, MKVType.ChapterTimeEnd, MKVType.ChapterFlagHidden, MKVType.ChapterFlagEnabled, MKVType.ChapterSegmentUID, MKVType.ChapterSegmentEditionUID, MKVType.ChapterPhysicalEquiv, MKVType.ChapterTrack, MKVType.ChapterDisplay, MKVType.ChapProcess])));
    MKVType.children.put(MKVType.ChapterTrack, new HashSet(Arrays.asList([MKVType.ChapterTrackNumber])));
    MKVType.children.put(MKVType.ChapterDisplay, new HashSet(Arrays.asList([MKVType.ChapString, MKVType.ChapLanguage, MKVType.ChapCountry])));
    MKVType.children.put(MKVType.ChapProcess, new HashSet(Arrays.asList([MKVType.ChapProcessCodecID, MKVType.ChapProcessPrivate, MKVType.ChapProcessCommand])));
    MKVType.children.put(MKVType.ChapProcessCommand, new HashSet(Arrays.asList([MKVType.ChapProcessTime, MKVType.ChapProcessData])));
    MKVType.children.put(MKVType.Tags, new HashSet(Arrays.asList([MKVType.Tag])));
    MKVType.children.put(MKVType.Tag, new HashSet(Arrays.asList([MKVType.Targets, MKVType.SimpleTag])));
    MKVType.children.put(MKVType.Targets, new HashSet(Arrays.asList([MKVType.TargetTypeValue, MKVType.TargetType, MKVType.TagTrackUID, MKVType.TagEditionUID, MKVType.TagChapterUID, MKVType.TagAttachmentUID])));
    MKVType.children.put(MKVType.SimpleTag, new HashSet(Arrays.asList([MKVType.TagName, MKVType.TagLanguage, MKVType.TagDefault, MKVType.TagString, MKVType.TagBinary])));
})();
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MKVMuxerTrack = function() {
    this.trackBlocks = new ArrayList();
    this.type = MKVMuxerTrack.MKVMuxerTrackType.VIDEO;
};
MKVMuxerTrack = stjs.extend(MKVMuxerTrack, null, [], function(constructor, prototype) {
    constructor.MKVMuxerTrackType = stjs.enumeration("VIDEO");
    prototype.type = null;
    prototype.frameDimentions = null;
    prototype.codecId = null;
    prototype.trackNo = 0;
    prototype.frameDuration = 0;
    prototype.trackBlocks = null;
    constructor.DEFAULT_TIMESCALE = 1000000000;
    constructor.NANOSECONDS_IN_A_MILISECOND = 1000000;
    constructor.MULTIPLIER = stjs.trunc(MKVMuxerTrack.DEFAULT_TIMESCALE / MKVMuxerTrack.NANOSECONDS_IN_A_MILISECOND);
    prototype.getTimescale = function() {
        return MKVMuxerTrack.NANOSECONDS_IN_A_MILISECOND;
    };
    prototype.addSampleEntry = function(frameData, pts) {
        var frame = MkvBlock.keyFrame(this.trackNo, 0, frameData);
        frame.absoluteTimecode = pts - 1;
        this.trackBlocks.add(frame);
    };
    prototype.getTrackNo = function() {
        return this.trackNo;
    };
}, {type: {name: "Enum", arguments: ["MKVMuxerTrack.MKVMuxerTrackType"]}, frameDimentions: "Size", trackBlocks: {name: "List", arguments: ["MkvBlock"]}}, {});
/**
 *  
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Decodes a ProRes file in low res. Decodes each 8x8 block as a downscaled 2x2
 *  block.
 *  
 *  @author The JCodec project
 *  
 */
var ProresToThumb2x2 = function() {
    ProresDecoder.call(this);
};
ProresToThumb2x2 = stjs.extend(ProresToThumb2x2, ProresDecoder, [], function(constructor, prototype) {
    prototype.decodeOnePlane = function(bits, blocksPerSlice, out, qMat, scan, mbX, mbY, plane) {
        ProresDecoder.readDCCoeffs(bits, qMat, out, blocksPerSlice, 4);
        ProresDecoder.readACCoeffs(bits, qMat, out, blocksPerSlice, scan, 4, 2);
        for (var i = 0; i < blocksPerSlice; i++) {
            IDCT2x2.idct(out, i << 2);
        }
    };
    prototype.decodeFrame8Bit = function(data, target) {
        var fh = ProresDecoder.readFrameHeader(data);
        var codedWidth = ((fh.width + 15) & ~15) >> 2;
        var codedHeight = ((fh.height + 15) & ~15) >> 2;
        var lumaSize = codedWidth * codedHeight;
        var chromaSize = lumaSize >> 1;
        if (target == null || target[0].length < lumaSize || target[1].length < chromaSize || target[2].length < chromaSize) {
             throw new RuntimeException("Provided output picture won't fit into provided buffer");
        }
        if (fh.frameType == 0) {
            this.decodePicture(data, target, codedWidth, codedHeight, codedWidth >> 2, fh.qMatLuma, fh.qMatChroma, new Int32Array([0, 1, 2, 3]), 0, fh.chromaType);
        } else {
            this.decodePicture(data, target, codedWidth, codedHeight >> 1, codedWidth >> 2, fh.qMatLuma, fh.qMatChroma, new Int32Array([0, 2, 1, 3]), fh.topFieldFirst ? 1 : 2, fh.chromaType);
            this.decodePicture(data, target, codedWidth, codedHeight >> 1, codedWidth >> 2, fh.qMatLuma, fh.qMatChroma, new Int32Array([0, 2, 1, 3]), fh.topFieldFirst ? 2 : 1, fh.chromaType);
        }
        return Picture8Bit.createPicture8Bit(codedWidth, codedHeight, target, fh.chromaType == 2 ? ColorSpace.YUV422 : ColorSpace.YUV444);
    };
    prototype.putSlice = function(result, lumaStride, mbX, mbY, y, u, v, dist, shift, chromaType, sliceMbCount) {
        var chromaStride = lumaStride >> 1;
        this._putLuma(result[0], shift * lumaStride, lumaStride << dist, mbX, mbY, y, sliceMbCount, dist, shift);
        if (chromaType == 2) {
            this._putChroma(result[1], shift * chromaStride, chromaStride << dist, mbX, mbY, u, sliceMbCount, dist, shift);
            this._putChroma(result[2], shift * chromaStride, chromaStride << dist, mbX, mbY, v, sliceMbCount, dist, shift);
        } else {
            this._putLuma(result[1], shift * lumaStride, lumaStride << dist, mbX, mbY, u, sliceMbCount, dist, shift);
            this._putLuma(result[2], shift * lumaStride, lumaStride << dist, mbX, mbY, v, sliceMbCount, dist, shift);
        }
    };
    prototype._putLuma = function(y, off, stride, mbX, mbY, luma, mbPerSlice, dist, shift) {
        off += (mbX << 2) + (mbY << 2) * stride;
        var tstride = stride * 3;
        for (var k = 0, sOff = 0; k < mbPerSlice; k++) {
            y[off] = this.clipTo8Bit(luma[sOff], 4, 1019);
            y[off + 1] = this.clipTo8Bit(luma[sOff + 1], 4, 1019);
            y[off + 2] = this.clipTo8Bit(luma[sOff + 4], 4, 1019);
            y[off + 3] = this.clipTo8Bit(luma[sOff + 5], 4, 1019);
            off += stride;
            y[off] = this.clipTo8Bit(luma[sOff + 2], 4, 1019);
            y[off + 1] = this.clipTo8Bit(luma[sOff + 3], 4, 1019);
            y[off + 2] = this.clipTo8Bit(luma[sOff + 6], 4, 1019);
            y[off + 3] = this.clipTo8Bit(luma[sOff + 7], 4, 1019);
            off += stride;
            y[off] = this.clipTo8Bit(luma[sOff + 8], 4, 1019);
            y[off + 1] = this.clipTo8Bit(luma[sOff + 9], 4, 1019);
            y[off + 2] = this.clipTo8Bit(luma[sOff + 12], 4, 1019);
            y[off + 3] = this.clipTo8Bit(luma[sOff + 13], 4, 1019);
            off += stride;
            y[off] = this.clipTo8Bit(luma[sOff + 10], 4, 1019);
            y[off + 1] = this.clipTo8Bit(luma[sOff + 11], 4, 1019);
            y[off + 2] = this.clipTo8Bit(luma[sOff + 14], 4, 1019);
            y[off + 3] = this.clipTo8Bit(luma[sOff + 15], 4, 1019);
            off += 4 - tstride;
            sOff += 16;
        }
    };
    prototype._putChroma = function(y, off, stride, mbX, mbY, chroma, mbPerSlice, dist, shift) {
        var tstride = stride * 3;
        off += (mbX << 1) + (mbY << 2) * stride;
        for (var k = 0, sOff = 0; k < mbPerSlice; k++) {
            y[off] = this.clipTo8Bit(chroma[sOff], 4, 1019);
            y[off + 1] = this.clipTo8Bit(chroma[sOff + 1], 4, 1019);
            off += stride;
            y[off] = this.clipTo8Bit(chroma[sOff + 2], 4, 1019);
            y[off + 1] = this.clipTo8Bit(chroma[sOff + 3], 4, 1019);
            off += stride;
            y[off] = this.clipTo8Bit(chroma[sOff + 4], 4, 1019);
            y[off + 1] = this.clipTo8Bit(chroma[sOff + 5], 4, 1019);
            off += stride;
            y[off] = this.clipTo8Bit(chroma[sOff + 6], 4, 1019);
            y[off + 1] = this.clipTo8Bit(chroma[sOff + 7], 4, 1019);
            off += 2 - tstride;
            sOff += 8;
        }
    };
}, {table: "Int32Array", mask: "Int32Array", byteBuffer: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Individual Channel Stream info, AAC block
 *  
 *  @author The JCodec project
 *  
 */
var BlockICS = function() {
    Block.call(this);
    this.ff_aac_codebook_vector_vals = [AACTab.codebook_vector0_vals, AACTab.codebook_vector0_vals, AACTab.codebook_vector10_vals, AACTab.codebook_vector10_vals, AACTab.codebook_vector4_vals, AACTab.codebook_vector4_vals, AACTab.codebook_vector10_vals, AACTab.codebook_vector10_vals, AACTab.codebook_vector10_vals, AACTab.codebook_vector10_vals, AACTab.codebook_vector10_vals];
    this.group_len = new Int32Array(8);
    this.band_type = new Int32Array(120);
    this.band_type_run_end = new Int32Array(120);
};
BlockICS = stjs.extend(BlockICS, Block, [], function(constructor, prototype) {
    prototype.commonWindow = false;
    prototype.scaleFlag = false;
    prototype.profile = null;
    prototype.samplingIndex = 0;
    constructor.spectral = null;
    constructor.vlc = null;
    prototype.ff_aac_codebook_vector_vals = null;
    constructor.MAX_LTP_LONG_SFB = 40;
    prototype.windowSequence = 0;
    prototype.num_window_groups = 0;
    prototype.group_len = null;
    prototype.maxSfb = 0;
    prototype.band_type = null;
    prototype.band_type_run_end = null;
    prototype.globalGain = 0;
    constructor.WindowSequence = stjs.enumeration("ONLY_LONG_SEQUENCE", "LONG_START_SEQUENCE", "EIGHT_SHORT_SEQUENCE", "LONG_STOP_SEQUENCE");
    prototype.parseICSInfo = function(_in) {
        _in.read1Bit();
        this.windowSequence = stjs.trunc(_in.readNBit(2));
        var useKbWindow = _in.read1Bit();
        this.num_window_groups = 1;
        this.group_len[0] = 1;
        if (this.windowSequence == BlockICS.WindowSequence.EIGHT_SHORT_SEQUENCE.ordinal()) {
            var max_sfb = stjs.trunc(_in.readNBit(4));
            for (var i = 0; i < 7; i++) {
                if (_in.read1Bit() != 0) {
                    this.group_len[this.num_window_groups - 1]++;
                } else {
                    this.num_window_groups++;
                    this.group_len[this.num_window_groups - 1] = 1;
                }
            }
            this.numSwb = AACTab.ff_aac_num_swb_128[this.samplingIndex];
            this.swbOffset = AACTab.ff_swb_offset_128[this.samplingIndex];
            this.numWindows = 8;
        } else {
            this.maxSfb = stjs.trunc(_in.readNBit(6));
            this.numSwb = AACTab.ff_aac_num_swb_1024[this.samplingIndex];
            this.swbOffset = AACTab.ff_swb_offset_1024[this.samplingIndex];
            this.numWindows = 1;
            var predictor_present = _in.read1Bit();
            if (predictor_present != 0) {
                if (this.profile == Profile.MAIN) {
                    this.decodePrediction(_in, this.maxSfb);
                } else if (this.profile == Profile.LC) {
                     throw new RuntimeException("Prediction is not allowed _in AAC-LC.\n");
                } else {
                    var ltpPresent = _in.read1Bit();
                    if (ltpPresent != 0) 
                        this.decodeLtp(_in, this.maxSfb);
                }
            }
        }
        return 0;
    };
    prototype.decodePrediction = function(_in, maxSfb) {
        if (_in.read1Bit() != 0) {
            var predictorResetGroup = stjs.trunc(_in.readNBit(5));
        }
        for (var sfb = 0; sfb < Math.min(maxSfb, AACTab.maxSfbTab[this.samplingIndex]); sfb++) {
            _in.read1Bit();
        }
    };
    prototype.decodeLtp = function(_in, maxSfb) {
        var lag = stjs.trunc(_in.readNBit(11));
        var coef = AACTab.ltpCoefTab[stjs.trunc(_in.readNBit(3))];
        for (var sfb = 0; sfb < Math.min(maxSfb, BlockICS.MAX_LTP_LONG_SFB); sfb++) 
            _in.read1Bit();
    };
    prototype.decodeBandTypes = function(_in) {
        var g, idx = 0;
        var bits = (this.windowSequence == BlockICS.WindowSequence.EIGHT_SHORT_SEQUENCE.ordinal()) ? 3 : 5;
        for (g = 0; g < this.num_window_groups; g++) {
            var k = 0;
             while (k < this.maxSfb){
                var sect_end = k;
                var sect_len_incr;
                var sect_band_type = stjs.trunc(_in.readNBit(4));
                if (sect_band_type == 12) {
                     throw new RuntimeException("invalid band type");
                }
                 while ((sect_len_incr = stjs.trunc(_in.readNBit(bits))) == (1 << bits) - 1)
                    sect_end += sect_len_incr;
                sect_end += sect_len_incr;
                if (!_in.moreData() || sect_len_incr == (1 << bits) - 1) {
                     throw new RuntimeException("Overread");
                }
                if (sect_end > this.maxSfb) {
                     throw new RuntimeException(String.format("Number of bands (%d) exceeds limit (%d).\n", sect_end, this.maxSfb));
                }
                for (; k < sect_end; k++) {
                    this.band_type[idx] = sect_band_type;
                    this.band_type_run_end[idx++] = sect_end;
                }
            }
        }
    };
    constructor.BandType = stjs.enumeration("ZERO_BT", "BT_1", "BT_2", "BT_3", "BT_4", "FIRST_PAIR_BT", "BT_6", "BT_7", "BT_8", "BT_9", "BT_10", "ESC_BT", "BT_12", "NOISE_BT", "INTENSITY_BT2", "INTENSITY_BT");
    constructor.ff_aac_pow2sf_tab = new Float32Array(428);
    constructor.POW_SF2_ZERO = 200;
    prototype.sfs = null;
    prototype.numSwb = 0;
    prototype.swbOffset = null;
    prototype.numWindows = 0;
    prototype.decodeScalefactors = function(_in) {
        var offset = new Int32Array([this.globalGain, this.globalGain - 90, 0]);
        var clipped_offset;
        var noise_flag = 1;
        var sf_str = ["Global gain", "Noise gain", "Intensity stereo position"];
        var idx = 0;
        for (var g = 0; g < this.num_window_groups; g++) {
            for (var i = 0; i < this.maxSfb; ) {
                var run_end = this.band_type_run_end[idx];
                if (this.band_type[idx] == BlockICS.BandType.ZERO_BT.ordinal()) {
                    for (; i < run_end; i++ , idx++) 
                        this.sfs[idx] = 0.0;
                } else if ((this.band_type[idx] == BlockICS.BandType.INTENSITY_BT.ordinal()) || (this.band_type[idx] == BlockICS.BandType.INTENSITY_BT2.ordinal())) {
                    for (; i < run_end; i++ , idx++) {
                        offset[2] += BlockICS.vlc.readVLC(_in) - 60;
                        clipped_offset = MathUtil.clip(offset[2], -155, 100);
                        if (offset[2] != clipped_offset) {
                            System.out.println(String.format("Intensity stereo position clipped (%d -> %d).\nIf you heard an audible artifact, there may be a bug _in the decoder. ", offset[2], clipped_offset));
                        }
                        this.sfs[idx] = BlockICS.ff_aac_pow2sf_tab[-clipped_offset + BlockICS.POW_SF2_ZERO];
                    }
                } else if (this.band_type[idx] == BlockICS.BandType.NOISE_BT.ordinal()) {
                    for (; i < run_end; i++ , idx++) {
                        if (noise_flag-- > 0) 
                            offset[1] += _in.readNBit(9) - 256;
                         else 
                            offset[1] += BlockICS.vlc.readVLC(_in) - 60;
                        clipped_offset = MathUtil.clip(offset[1], -100, 155);
                        if (offset[1] != clipped_offset) {
                            System.out.println(String.format("Noise gain clipped (%d -> %d).\nIf you heard an audible artifact, there may be a bug _in the decoder. ", offset[1], clipped_offset));
                        }
                        this.sfs[idx] = -BlockICS.ff_aac_pow2sf_tab[clipped_offset + BlockICS.POW_SF2_ZERO];
                    }
                } else {
                    for (; i < run_end; i++ , idx++) {
                        offset[0] += BlockICS.vlc.readVLC(_in) - 60;
                        if (offset[0] > 255) {
                             throw new RuntimeException(String.format("%s (%d) out of range.\n", sf_str[0], offset[0]));
                        }
                        this.sfs[idx] = -BlockICS.ff_aac_pow2sf_tab[offset[0] - 100 + BlockICS.POW_SF2_ZERO];
                    }
                }
            }
        }
    };
    constructor.Pulse = function(numPulse, pos, amp) {
        this.numPulse = numPulse;
        this.pos = pos;
        this.amp = amp;
    };
    constructor.Pulse = stjs.extend(constructor.Pulse, null, [], function(constructor, prototype) {
        prototype.numPulse = 0;
        prototype.pos = null;
        prototype.amp = null;
        prototype.getNumPulse = function() {
            return this.numPulse;
        };
        prototype.getPos = function() {
            return this.pos;
        };
        prototype.getAmp = function() {
            return this.amp;
        };
    }, {pos: "Int32Array", amp: "Int32Array"}, {});
    prototype.decodePulses = function(_in) {
        var pos = new Int32Array(4);
        var amp = new Int32Array(4);
        var numPulse = stjs.trunc(_in.readNBit(2)) + 1;
        var pulseSwb = stjs.trunc(_in.readNBit(6));
        if (pulseSwb >= this.numSwb) 
             throw new RuntimeException("pulseSwb >= numSwb");
        pos[0] = this.swbOffset[pulseSwb];
        pos[0] += stjs.trunc(_in.readNBit(5));
        if (pos[0] > 1023) 
             throw new RuntimeException("pos[0] > 1023");
        amp[0] = stjs.trunc(_in.readNBit(4));
        for (var i = 1; i < numPulse; i++) {
            pos[i] = stjs.trunc(_in.readNBit(5)) + pos[i - 1];
            if (pos[i] > 1023) 
                 throw new RuntimeException("pos[" + i + "] > 1023");
            amp[i] = stjs.trunc(_in.readNBit(5));
        }
        return new BlockICS.Pulse(numPulse, pos, amp);
    };
    constructor.Tns = function(nFilt, length, order, direction, coeff) {
        this.nFilt = nFilt;
        this.length = length;
        this.order = order;
        this.direction = direction;
        this.coeff = coeff;
    };
    constructor.Tns = stjs.extend(constructor.Tns, null, [], function(constructor, prototype) {
        prototype.nFilt = null;
        prototype.length = null;
        prototype.order = null;
        prototype.direction = null;
        prototype.coeff = null;
    }, {nFilt: "Int32Array", length: "Array", order: "Array", direction: "Array", coeff: "Array"}, {});
    prototype.decodeTns = function(_in) {
        var is8 = this.windowSequence == BlockICS.WindowSequence.EIGHT_SHORT_SEQUENCE.ordinal() ? 1 : 0;
        var tns_max_order = is8 != 0 ? 7 : this.profile == Profile.MAIN ? 20 : 12;
        var nFilt = new Int32Array(this.numWindows);
        var length = Array.apply(null, Array(this.numWindows)).map(function() {
            return new Int32Array(2);
        });
        var order = Array.apply(null, Array(this.numWindows)).map(function() {
            return new Int32Array(2);
        });
        var direction = Array.apply(null, Array(this.numWindows)).map(function() {
            return new Int32Array(2);
        });
        var coeff = Array.apply(null, Array(this.numWindows)).map(function() {
            return Array.apply(null, Array(2)).map(function() {
                return new Float32Array(1 << (5 - 2 * is8));
            });
        });
        for (var w = 0; w < this.numWindows; w++) {
            if ((nFilt[w] = stjs.trunc(_in.readNBit(2 - is8))) != 0) {
                var coefRes = _in.read1Bit();
                for (var filt = 0; filt < nFilt[w]; filt++) {
                    var tmp2_idx;
                    length[w][filt] = stjs.trunc(_in.readNBit(6 - 2 * is8));
                    if ((order[w][filt] = stjs.trunc(_in.readNBit(5 - 2 * is8))) > tns_max_order) {
                         throw new RuntimeException(String.format("TNS filter order %d is greater than maximum %d.\n", order[w][filt], tns_max_order));
                    }
                    if (order[w][filt] != 0) {
                        direction[w][filt] = _in.read1Bit();
                        var coefCompress = _in.read1Bit();
                        var coefLen = coefRes + 3 - coefCompress;
                        tmp2_idx = 2 * coefCompress + coefRes;
                        for (var i = 0; i < order[w][filt]; i++) 
                            coeff[w][filt][i] = AACTab.tns_tmp2_map[tmp2_idx][stjs.trunc(_in.readNBit(coefLen))];
                    }
                }
            }
        }
        return new BlockICS.Tns(nFilt, length, order, direction, coeff);
    };
    prototype.VMUL4 = function(result, idx, v, code, scale) {
        result[idx] = v[code & 3] * scale;
        result[idx + 1] = v[code >> 2 & 3] * scale;
        result[idx + 2] = v[code >> 4 & 3] * scale;
        result[idx + 3] = v[code >> 6 & 3] * scale;
    };
    prototype.VMUL4S = function(result, idx, v, code, sign, scale) {
        var nz = code >> 12;
        result[idx + 0] = v[idx & 3] * scale;
        sign <<= nz & 1;
        nz >>= 1;
        result[idx + 1] = v[idx >> 2 & 3] * scale;
        sign <<= nz & 1;
        nz >>= 1;
        result[idx + 2] = v[idx >> 4 & 3] * scale;
        sign <<= nz & 1;
        nz >>= 1;
        result[idx + 3] = v[idx >> 6 & 3] * scale;
    };
    prototype.VMUL2 = function(result, idx, v, code, scale) {
        result[idx] = v[code & 15] * scale;
        result[idx + 1] = v[code >> 4 & 15] * scale;
    };
    prototype.VMUL2S = function(result, idx, v, code, sign, scale) {
        result[idx] = v[code & 15] * scale;
        result[idx + 1] = v[code >> 4 & 15] * scale;
    };
    prototype.decodeSpectrum = function(_in) {
        var coef = new Float32Array(1024);
        var idx = 0;
        for (var g = 0; g < this.num_window_groups; g++) {
            for (var i = 0; i < this.maxSfb; i++ , idx++) {
                var cbt_m1 = this.band_type[idx] - 1;
                if (cbt_m1 < BlockICS.BandType.INTENSITY_BT2.ordinal() - 1 && cbt_m1 != BlockICS.BandType.NOISE_BT.ordinal() - 1) {
                    var vq = this.ff_aac_codebook_vector_vals[cbt_m1];
                    var vlc = BlockICS.spectral[cbt_m1];
                    switch (cbt_m1 >> 1) {
                        case 0:
                            this.readBandType1And2(_in, coef, idx, g, i, vq, vlc);
                            break;
                        case 1:
                            this.readBandType3And4(_in, coef, idx, g, i, vq, vlc);
                            break;
                        case 2:
                            this.readBandType5And6(_in, coef, idx, g, i, vq, vlc);
                            break;
                        case 3:
                        case 4:
                            this.readBandType7Through10(_in, coef, idx, g, i, vq, vlc);
                            break;
                        default:
                            this.readOther(_in, coef, idx, g, i, vq, vlc);
                    }
                }
            }
        }
    };
    prototype.readBandType3And4 = function(_in, coef, idx, g, sfb, vq, vlc) {
        var g_len = this.group_len[g];
        var cfo = this.swbOffset[sfb];
        var off_len = this.swbOffset[sfb + 1] - this.swbOffset[sfb];
        for (var group = 0; group < g_len; group++ , cfo += 128) {
            var cf = cfo;
            var len = off_len;
            do {
                var cb_idx = vlc.readVLC(_in);
                var nnz = cb_idx >> 8 & 15;
                var bits = nnz == 0 ? 0 : _in.readNBit(nnz);
                this.VMUL4S(coef, cf, vq, cb_idx, bits, this.sfs[idx]);
                cf += 4;
                len -= 4;
            } while (len > 0);
        }
    };
    prototype.readBandType7Through10 = function(_in, coef, idx, g, sfb, vq, vlc) {
        var g_len = this.group_len[g];
        var cfo = this.swbOffset[sfb];
        var off_len = this.swbOffset[sfb + 1] - this.swbOffset[sfb];
        for (var group = 0; group < g_len; group++ , cfo += 128) {
            var cf = cfo;
            var len = off_len;
            do {
                var cb_idx = vlc.readVLC(_in);
                var nnz = cb_idx >> 8 & 15;
                var bits = nnz == 0 ? 0 : (_in.readNBit(nnz) << (cb_idx >> 12));
                this.VMUL2S(coef, cf, vq, cb_idx, bits, this.sfs[idx]);
                cf += 2;
                len -= 2;
            } while (len > 0);
        }
    };
    prototype.readOther = function(_in, coef, idx, g, sfb, vq, vlc) {
        var g_len = this.group_len[g];
        var cfo = this.swbOffset[sfb];
        var off_len = this.swbOffset[sfb + 1] - this.swbOffset[sfb];
        for (var group = 0; group < g_len; group++ , cfo += 128) {
            var cf = cfo;
            var len = off_len;
            do {
                var cb_idx = vlc.readVLC(_in);
                if (cb_idx != 0) {
                    var nnz = cb_idx >> 12;
                    var nzt = cb_idx >> 8;
                    var bits = _in.readNBit(nnz) << (32 - nnz);
                    for (var j = 0; j < 2; j++) {
                        if ((nzt & 1 << j) != 0) {
                            var b;
                            var n;
                            b = ProresDecoder.nZeros(~_in.checkNBit(14));
                            if (b > 8) {
                                 throw new RuntimeException("error _in spectral data, ESC overflow\n");
                            }
                            _in.skip(b + 1);
                            b += 4;
                            n = (1 << b) + _in.readNBit(b);
                            coef[cf++] = MathUtil.cubeRoot(n) | (bits & 1 << 31);
                            bits <<= 1;
                        } else {
                            var v = stjs.trunc(vq[cb_idx & 15]);
                            coef[cf++] = (bits & 1 << 31) | v;
                        }
                        cb_idx >>= 4;
                    }
                    cf += 2;
                    len += 2;
                }
            } while (len > 0);
        }
    };
    prototype.readBandType1And2 = function(_in, coef, idx, g, sfb, vq, vlc) {
        var g_len = this.group_len[g];
        var cfo = this.swbOffset[sfb];
        var off_len = this.swbOffset[sfb + 1] - this.swbOffset[sfb];
        for (var group = 0; group < g_len; group++ , cfo += 128) {
            var cf = cfo;
            var len = off_len;
            do {
                var cb_idx = vlc.readVLC(_in);
                this.VMUL4(coef, cf, vq, cb_idx, this.sfs[idx]);
                cf += 4;
                len -= 4;
            } while (len > 0);
        }
    };
    prototype.readBandType5And6 = function(_in, coef, idx, g, sfb, vq, vlc) {
        var g_len = this.group_len[g];
        var cfo = this.swbOffset[sfb];
        var off_len = this.swbOffset[sfb + 1] - this.swbOffset[sfb];
        for (var group = 0; group < g_len; group++ , cfo += 128) {
            var cf = cfo;
            var len = off_len;
            do {
                var cb_idx = vlc.readVLC(_in);
                this.VMUL2(coef, cf, vq, cb_idx, this.sfs[idx]);
                cf += 2;
                len -= 2;
            } while (len > 0);
        }
    };
    prototype.parse = function(_in) {
        this.globalGain = stjs.trunc(_in.readNBit(8));
        if (!this.commonWindow && !this.scaleFlag) {
            this.parseICSInfo(_in);
        }
        this.decodeBandTypes(_in);
        this.decodeScalefactors(_in);
        var pulse_present = 0;
        var tns_present;
        if (!this.scaleFlag) {
            if ((pulse_present = _in.read1Bit()) != 0) {
                if (this.windowSequence == BlockICS.WindowSequence.EIGHT_SHORT_SEQUENCE.ordinal()) {
                     throw new RuntimeException("Pulse tool not allowed _in eight short sequence.");
                }
                this.decodePulses(_in);
            }
            if ((tns_present = _in.read1Bit()) != 0) {
                this.decodeTns(_in);
            }
            if (_in.read1Bit() != 0) {
                 throw new RuntimeException("SSR is not supported");
            }
        }
        this.decodeSpectrum(_in);
    };
}, {profile: {name: "Enum", arguments: ["Profile"]}, spectral: "Array", vlc: "VLC", ff_aac_codebook_vector_vals: "Array", group_len: "Int32Array", band_type: "Int32Array", band_type_run_end: "Int32Array", ff_aac_pow2sf_tab: "Float32Array", sfs: "Float64Array", swbOffset: "Int32Array", type: {name: "Enum", arguments: ["BlockType"]}}, {});
(function() {
    BlockICS.vlc = new VLC(AACTab.ff_aac_scalefactor_code, AACTab.ff_aac_scalefactor_bits);
    BlockICS.spectral = [VLCBuilder.createVLCBuilder(AACTab.codes1, AACTab.bits1, AACTab.codebook_vector02_idx).getVLC(), VLCBuilder.createVLCBuilder(AACTab.codes2, AACTab.bits2, AACTab.codebook_vector02_idx).getVLC(), VLCBuilder.createVLCBuilder(AACTab.codes3, AACTab.bits3, AACTab.codebook_vector02_idx).getVLC(), VLCBuilder.createVLCBuilder(AACTab.codes4, AACTab.bits4, AACTab.codebook_vector02_idx).getVLC(), VLCBuilder.createVLCBuilder(AACTab.codes5, AACTab.bits5, AACTab.codebook_vector4_idx).getVLC(), VLCBuilder.createVLCBuilder(AACTab.codes6, AACTab.bits6, AACTab.codebook_vector4_idx).getVLC(), VLCBuilder.createVLCBuilder(AACTab.codes7, AACTab.bits7, AACTab.codebook_vector6_idx).getVLC(), VLCBuilder.createVLCBuilder(AACTab.codes8, AACTab.bits8, AACTab.codebook_vector6_idx).getVLC(), VLCBuilder.createVLCBuilder(AACTab.codes9, AACTab.bits9, AACTab.codebook_vector8_idx).getVLC(), VLCBuilder.createVLCBuilder(AACTab.codes10, AACTab.bits10, AACTab.codebook_vector8_idx).getVLC(), VLCBuilder.createVLCBuilder(AACTab.codes11, AACTab.bits11, AACTab.codebook_vector10_idx).getVLC()];
})();
(function() {
    var i;
    for (i = 0; i < 428; i++) 
        BlockICS.ff_aac_pow2sf_tab[i] = Math.pow(2, (i - BlockICS.POW_SF2_ZERO) / 4.0);
})();
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Rewrites DCT coefficients to new ProRes bitstream concealing errors
 *  
 *  @author The JCodec project
 *  
 */
var ProresFix = function() {};
ProresFix = stjs.extend(ProresFix, null, [], function(constructor, prototype) {
    constructor.readDCCoeffs = function(bits, out, blocksPerSlice) {
        out[0] = ProresDecoder.readCodeword(bits, ProresConsts.firstDCCodebook);
        if (out[0] < 0) {
             throw new RuntimeException("First DC coeff damaged");
        }
        var code = 5, idx = 64;
        for (var i = 1; i < blocksPerSlice; i++ , idx += 64) {
            code = ProresDecoder.readCodeword(bits, ProresConsts.dcCodebooks[Math.min(code, 6)]);
            if (code < 0) {
                 throw new RuntimeException("DC coeff damaged");
            }
            out[idx] = code;
        }
    };
    constructor.readACCoeffs = function(bits, out, blocksPerSlice, scan) {
        var run = 4;
        var level = 2;
        var blockMask = blocksPerSlice - 1;
        var log2BlocksPerSlice = MathUtil.log2(blocksPerSlice);
        var maxCoeffs = 64 << log2BlocksPerSlice;
        var pos = blockMask;
         while (bits.remaining() > 32 || bits.checkNBit(24) != 0){
            run = ProresDecoder.readCodeword(bits, ProresConsts.runCodebooks[Math.min(run, 15)]);
            if (run < 0 || run >= maxCoeffs - pos - 1) {
                 throw new RuntimeException("Run codeword damaged");
            }
            pos += run + 1;
            level = ProresDecoder.readCodeword(bits, ProresConsts.levCodebooks[Math.min(level, 9)]) + 1;
            if (level < 0 || level > 65535) {
                 throw new RuntimeException("Level codeword damaged");
            }
            var sign = -bits.read1Bit();
            var ind = pos >> log2BlocksPerSlice;
            out[((pos & blockMask) << 6) + scan[ind]] = MathUtil.toSigned(level, sign);
        }
    };
    constructor.writeDCCoeffs = function(bits, _in, blocksPerSlice) {
        ProresEncoder.writeCodeword(bits, ProresConsts.firstDCCodebook, _in[0]);
        var code = 5, idx = 64;
        for (var i = 1; i < blocksPerSlice; i++ , idx += 64) {
            ProresEncoder.writeCodeword(bits, ProresConsts.dcCodebooks[Math.min(code, 6)], _in[idx]);
            code = _in[idx];
        }
    };
    constructor.writeACCoeffs = function(bits, _in, blocksPerSlice, scan) {
        var prevRun = 4;
        var prevLevel = 2;
        var run = 0;
        for (var i = 1; i < 64; i++) {
            var indp = scan[i];
            for (var j = 0; j < blocksPerSlice; j++) {
                var val = _in[(j << 6) + indp];
                if (val == 0) 
                    run++;
                 else {
                    ProresEncoder.writeCodeword(bits, ProresConsts.runCodebooks[Math.min(prevRun, 15)], run);
                    prevRun = run;
                    run = 0;
                    var level = ProresEncoder.getLevel(val);
                    ProresEncoder.writeCodeword(bits, ProresConsts.levCodebooks[Math.min(prevLevel, 9)], level - 1);
                    prevLevel = level;
                    bits.write1Bit(MathUtil.sign(val));
                }
            }
        }
    };
    constructor.copyCoeff = function(ib, ob, blocksPerSlice, scan) {
        var out = new Int32Array(blocksPerSlice << 6);
        try {
            ProresFix.readDCCoeffs(ib, out, blocksPerSlice);
            ProresFix.readACCoeffs(ib, out, blocksPerSlice, scan);
        }catch (e) {}
        ProresFix.writeDCCoeffs(ob, out, blocksPerSlice);
        ProresFix.writeACCoeffs(ob, out, blocksPerSlice, scan);
        ob.flush();
    };
    constructor.transcode = function(inBuf, _outBuf) {
        var outBuf = _outBuf.slice();
        var fork = outBuf.duplicate();
        var fh = ProresDecoder.readFrameHeader(inBuf);
        ProresEncoder.writeFrameHeader(outBuf, fh);
        if (fh.frameType == 0) {
            ProresFix.transcodePicture(inBuf, outBuf, fh);
        } else {
            ProresFix.transcodePicture(inBuf, outBuf, fh);
            ProresFix.transcodePicture(inBuf, outBuf, fh);
        }
        ProresEncoder.writeFrameHeader(fork, fh);
        outBuf.flip();
        return outBuf;
    };
    constructor.transcodePicture = function(inBuf, outBuf, fh) {
        var ph = ProresDecoder.readPictureHeader(inBuf);
        ProresEncoder.writePictureHeader(ph.log2SliceMbWidth, ph.sliceSizes.length, outBuf);
        var fork = outBuf.duplicate();
        outBuf.setPosition(outBuf.position() + (ph.sliceSizes.length << 1));
        var mbWidth = (fh.width + 15) >> 4;
        var sliceMbCount = 1 << ph.log2SliceMbWidth;
        var mbX = 0;
        for (var i = 0; i < ph.sliceSizes.length; i++) {
             while (mbWidth - mbX < sliceMbCount)
                sliceMbCount >>= 1;
            var savedPoint = outBuf.position();
            ProresFix.transcodeSlice(inBuf, outBuf, sliceMbCount, ph.sliceSizes[i], fh);
            fork.putShort((((outBuf.position() - savedPoint)) << 16 >> 16));
            mbX += sliceMbCount;
            if (mbX == mbWidth) {
                sliceMbCount = 1 << ph.log2SliceMbWidth;
                mbX = 0;
            }
        }
    };
    constructor.transcodeSlice = function(inBuf, outBuf, sliceMbCount, sliceSize, fh) {
        var hdrSize = (inBuf.get() & 255) >> 3;
        var qScaleOrig = inBuf.get() & 255;
        var yDataSize = inBuf.getShort();
        var uDataSize = inBuf.getShort();
        var vDataSize = sliceSize - uDataSize - yDataSize - hdrSize;
        outBuf.put(((6 << 3) << 24 >> 24));
        outBuf.put((qScaleOrig << 24 >> 24));
        var beforeSizes = outBuf.duplicate();
        outBuf.putInt(0);
        var beforeY = outBuf.position();
        ProresFix.copyCoeff(ProresDecoder.bitstream(inBuf, yDataSize), new BitWriter(outBuf), sliceMbCount << 2, fh.scan);
        var beforeCb = outBuf.position();
        ProresFix.copyCoeff(ProresDecoder.bitstream(inBuf, uDataSize), new BitWriter(outBuf), sliceMbCount << 1, fh.scan);
        var beforeCr = outBuf.position();
        ProresFix.copyCoeff(ProresDecoder.bitstream(inBuf, vDataSize), new BitWriter(outBuf), sliceMbCount << 1, fh.scan);
        beforeSizes.putShort((((beforeCb - beforeY)) << 16 >> 16));
        beforeSizes.putShort((((beforeCr - beforeCb)) << 16 >> 16));
    };
    constructor.check = function(data) {
        var messages = new ArrayList();
        var frameSize = data.getInt();
        if (!"icpf".equals(ProresDecoder.readSig(data))) {
            messages.add("[ERROR] Missing ProRes signature (icpf).");
            return messages;
        }
        var headerSize = data.getShort();
        if (headerSize > 148) {
            messages.add("[ERROR] Wrong ProRes frame header.");
            return messages;
        }
        var version = data.getShort();
        var res1 = data.getInt();
        var width = data.getShort();
        var height = data.getShort();
        if (width < 0 || width > 10000 || height < 0 || height > 10000) {
            messages.add("[ERROR] Wrong ProRes frame header, invalid image size [" + width + "x" + height + "].");
            return messages;
        }
        var flags1 = data.get();
        data.setPosition(data.position() + headerSize - 13);
        if (((flags1 >> 2) & 3) == 0) {
            ProresFix.checkPicture(data, width, height, messages);
        } else {
            ProresFix.checkPicture(data, width, stjs.trunc(height / 2), messages);
            ProresFix.checkPicture(data, width, stjs.trunc(height / 2), messages);
        }
        return messages;
    };
    constructor.checkPicture = function(data, width, height, messages) {
        var ph = ProresDecoder.readPictureHeader(data);
        var mbWidth = (width + 15) >> 4;
        var mbHeight = (height + 15) >> 4;
        var sliceMbCount = 1 << ph.log2SliceMbWidth;
        var mbX = 0, mbY = 0;
        for (var i = 0; i < ph.sliceSizes.length; i++) {
             while (mbWidth - mbX < sliceMbCount)
                sliceMbCount >>= 1;
            try {
                ProresFix.checkSlice(NIOUtils.read(data, ph.sliceSizes[i]), sliceMbCount);
            }catch (e) {
                messages.add("[ERROR] Slice data corrupt: mbX = " + mbX + ", mbY = " + mbY + ". " + e.getMessage());
            }
            mbX += sliceMbCount;
            if (mbX == mbWidth) {
                sliceMbCount = 1 << ph.log2SliceMbWidth;
                mbX = 0;
                mbY++;
            }
        }
    };
    constructor.checkSlice = function(sliceData, sliceMbCount) {
        var sliceSize = sliceData.remaining();
        var hdrSize = (sliceData.get() & 255) >> 3;
        var qScaleOrig = sliceData.get() & 255;
        var yDataSize = sliceData.getShort();
        var uDataSize = sliceData.getShort();
        var vDataSize = sliceSize - uDataSize - yDataSize - hdrSize;
        ProresFix.checkCoeff(ProresDecoder.bitstream(sliceData, yDataSize), sliceMbCount << 2);
        ProresFix.checkCoeff(ProresDecoder.bitstream(sliceData, uDataSize), sliceMbCount << 1);
        ProresFix.checkCoeff(ProresDecoder.bitstream(sliceData, vDataSize), sliceMbCount << 1);
    };
    constructor.checkCoeff = function(ib, blocksPerSlice) {
        var scan = new Int32Array(64);
        var out = new Int32Array(blocksPerSlice << 6);
        ProresFix.readDCCoeffs(ib, out, blocksPerSlice);
        ProresFix.readACCoeffs(ib, out, blocksPerSlice, scan);
    };
}, {}, {});
/**
 *  
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Decodes a ProRes file in low res. Decodes each 8x8 block as 1 pixel.
 *  
 *  @author The JCodec project
 *  
 */
var ProresToThumb = function() {
    ProresDecoder.call(this);
};
ProresToThumb = stjs.extend(ProresToThumb, ProresDecoder, [], function(constructor, prototype) {
    prototype.decodeOnePlane = function(bits, blocksPerSlice, out, qMat, scan, mbX, mbY, plane) {
        try {
            ProresDecoder.readDCCoeffs(bits, qMat, out, blocksPerSlice, 1);
        }catch (e) {
            System.err.println("Suppressing slice error at [" + mbX + ", " + mbY + "].");
        }
        for (var i = 0; i < blocksPerSlice; i++) {
            out[i] >>= 3;
        }
    };
    prototype.decodeFrame8Bit = function(data, target) {
        var fh = ProresDecoder.readFrameHeader(data);
        var codedWidth = ((fh.width + 15) & ~15) >> 3;
        var codedHeight = ((fh.height + 15) & ~15) >> 3;
        var lumaSize = codedWidth * codedHeight;
        var chromaSize = lumaSize >> 1;
        if (target == null || target[0].length < lumaSize || target[1].length < chromaSize || target[2].length < chromaSize) {
             throw new RuntimeException("Provided output picture won't fit into provided buffer");
        }
        if (fh.frameType == 0) {
            this.decodePicture(data, target, codedWidth, codedHeight, codedWidth >> 1, fh.qMatLuma, fh.qMatChroma, new Int32Array([0]), 0, fh.chromaType);
        } else {
            this.decodePicture(data, target, codedWidth, codedHeight >> 1, codedWidth >> 1, fh.qMatLuma, fh.qMatChroma, new Int32Array([0]), fh.topFieldFirst ? 1 : 2, fh.chromaType);
            this.decodePicture(data, target, codedWidth, codedHeight >> 1, codedWidth >> 1, fh.qMatLuma, fh.qMatChroma, new Int32Array([0]), fh.topFieldFirst ? 2 : 1, fh.chromaType);
        }
        return Picture8Bit.createPicture8Bit(codedWidth, codedHeight, target, fh.chromaType == 2 ? ColorSpace.YUV422 : ColorSpace.YUV444);
    };
    prototype.putSlice = function(result, lumaStride, mbX, mbY, y, u, v, dist, shift, chromaType, sliceMbCount) {
        var chromaStride = lumaStride >> 1;
        this._putLuma(result[0], shift * lumaStride, lumaStride << dist, mbX, mbY, y, sliceMbCount, dist, shift);
        if (chromaType == 2) {
            this._putChroma(result[1], shift * chromaStride, chromaStride << dist, mbX, mbY, u, sliceMbCount, dist, shift);
            this._putChroma(result[2], shift * chromaStride, chromaStride << dist, mbX, mbY, v, sliceMbCount, dist, shift);
        } else {
            this._putLuma(result[1], shift * lumaStride, lumaStride << dist, mbX, mbY, u, sliceMbCount, dist, shift);
            this._putLuma(result[2], shift * lumaStride, lumaStride << dist, mbX, mbY, v, sliceMbCount, dist, shift);
        }
    };
    prototype._putLuma = function(y, off, stride, mbX, mbY, luma, mbPerSlice, dist, shift) {
        off += (mbX << 1) + (mbY << 1) * stride;
        for (var k = 0, sOff = 0; k < mbPerSlice; k++) {
            y[off] = this.clipTo8Bit(luma[sOff], 4, 1019);
            y[off + 1] = this.clipTo8Bit(luma[sOff + 1], 4, 1019);
            off += stride;
            y[off] = this.clipTo8Bit(luma[sOff + 2], 4, 1019);
            y[off + 1] = this.clipTo8Bit(luma[sOff + 3], 4, 1019);
            off += 2 - stride;
            sOff += 4;
        }
    };
    prototype._putChroma = function(y, off, stride, mbX, mbY, chroma, mbPerSlice, dist, shift) {
        off += mbX + (mbY << 1) * stride;
        for (var k = 0, sOff = 0; k < mbPerSlice; k++) {
            y[off] = this.clipTo8Bit(chroma[sOff], 4, 1019);
            off += stride;
            y[off] = this.clipTo8Bit(chroma[sOff + 1], 4, 1019);
            off += 1 - stride;
            sOff += 2;
        }
    };
}, {table: "Int32Array", mask: "Int32Array", byteBuffer: "Array"}, {});
/**
 *  
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Decodes a ProRes file in low res. Decodes each 8x8 block as downscaled 4x4
 *  block.
 *  
 *  @author The JCodec project
 *  
 */
var ProresToThumb4x4 = function() {
    ProresDecoder.call(this);
};
ProresToThumb4x4 = stjs.extend(ProresToThumb4x4, ProresDecoder, [], function(constructor, prototype) {
    prototype.decodeOnePlane = function(bits, blocksPerSlice, out, qMat, scan, mbX, mbY, plane) {
        ProresDecoder.readDCCoeffs(bits, qMat, out, blocksPerSlice, 16);
        ProresDecoder.readACCoeffs(bits, qMat, out, blocksPerSlice, scan, 16, 4);
        for (var i = 0; i < blocksPerSlice; i++) {
            IDCT4x4.idct(out, i << 4);
        }
    };
    constructor.progressive_scan_4x4 = new Int32Array([0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 11, 12, 14, 15]);
    constructor.interlaced_scan_4x4 = new Int32Array([0, 4, 1, 5, 8, 12, 9, 13, 2, 6, 3, 7, 10, 14, 11, 15]);
    prototype.decodeFrame8Bit = function(data, target) {
        var fh = ProresDecoder.readFrameHeader(data);
        var codedWidth = ((fh.width + 15) & ~15) >> 1;
        var codedHeight = ((fh.height + 15) & ~15) >> 1;
        var lumaSize = codedWidth * codedHeight;
        var chromaSize = lumaSize >> 1;
        if (target == null || target[0].length < lumaSize || target[1].length < chromaSize || target[2].length < chromaSize) {
             throw new RuntimeException("Provided output picture won't fit into provided buffer");
        }
        if (fh.frameType == 0) {
            this.decodePicture(data, target, codedWidth, codedHeight, codedWidth >> 3, fh.qMatLuma, fh.qMatChroma, ProresToThumb4x4.progressive_scan_4x4, 0, fh.chromaType);
        } else {
            this.decodePicture(data, target, codedWidth, codedHeight >> 1, codedWidth >> 3, fh.qMatLuma, fh.qMatChroma, ProresToThumb4x4.interlaced_scan_4x4, fh.topFieldFirst ? 1 : 2, fh.chromaType);
            this.decodePicture(data, target, codedWidth, codedHeight >> 1, codedWidth >> 3, fh.qMatLuma, fh.qMatChroma, ProresToThumb4x4.interlaced_scan_4x4, fh.topFieldFirst ? 2 : 1, fh.chromaType);
        }
        return Picture8Bit.createPicture8Bit(codedWidth, codedHeight, target, fh.chromaType == 2 ? ColorSpace.YUV422 : ColorSpace.YUV444);
    };
    prototype.putSlice = function(result, lumaStride, mbX, mbY, y, u, v, dist, shift, chromaType, sliceMbCount) {
        var chromaStride = lumaStride >> 1;
        this._putLuma(result[0], shift * lumaStride, lumaStride << dist, mbX, mbY, y, sliceMbCount, dist, shift);
        if (chromaType == 2) {
            this._putChroma(result[1], shift * chromaStride, chromaStride << dist, mbX, mbY, u, sliceMbCount, dist, shift);
            this._putChroma(result[2], shift * chromaStride, chromaStride << dist, mbX, mbY, v, sliceMbCount, dist, shift);
        } else {
            this._putLuma(result[1], shift * lumaStride, lumaStride << dist, mbX, mbY, u, sliceMbCount, dist, shift);
            this._putLuma(result[2], shift * lumaStride, lumaStride << dist, mbX, mbY, v, sliceMbCount, dist, shift);
        }
    };
    constructor.srcIncLuma = new Int32Array([4, 4, 4, 20, 4, 4, 4, 20]);
    prototype._putLuma = function(y, off, stride, mbX, mbY, luma, mbPerSlice, dist, shift) {
        off += (mbX << 3) + (mbY << 3) * stride;
        for (var mb = 0, sOff = 0; mb < mbPerSlice; mb++ , off += 8) {
            var _off = off;
            for (var line = 0; line < 8; line++) {
                y[_off] = this.clipTo8Bit(luma[sOff], 4, 1019);
                y[_off + 1] = this.clipTo8Bit(luma[sOff + 1], 4, 1019);
                y[_off + 2] = this.clipTo8Bit(luma[sOff + 2], 4, 1019);
                y[_off + 3] = this.clipTo8Bit(luma[sOff + 3], 4, 1019);
                y[_off + 4] = this.clipTo8Bit(luma[sOff + 16], 4, 1019);
                y[_off + 5] = this.clipTo8Bit(luma[sOff + 17], 4, 1019);
                y[_off + 6] = this.clipTo8Bit(luma[sOff + 18], 4, 1019);
                y[_off + 7] = this.clipTo8Bit(luma[sOff + 19], 4, 1019);
                sOff += ProresToThumb4x4.srcIncLuma[line];
                _off += stride;
            }
        }
    };
    prototype._putChroma = function(y, off, stride, mbX, mbY, chroma, mbPerSlice, dist, shift) {
        off += (mbX << 2) + (mbY << 3) * stride;
        for (var k = 0, sOff = 0; k < mbPerSlice; k++ , off += 4) {
            var _off = off;
            for (var line = 0; line < 8; line++) {
                y[_off] = this.clipTo8Bit(chroma[sOff], 4, 1019);
                y[_off + 1] = this.clipTo8Bit(chroma[sOff + 1], 4, 1019);
                y[_off + 2] = this.clipTo8Bit(chroma[sOff + 2], 4, 1019);
                y[_off + 3] = this.clipTo8Bit(chroma[sOff + 3], 4, 1019);
                sOff += 4;
                _off += stride;
            }
        }
    };
}, {progressive_scan_4x4: "Int32Array", interlaced_scan_4x4: "Int32Array", srcIncLuma: "Int32Array", table: "Int32Array", mask: "Int32Array", byteBuffer: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Turns a ProRes frame into ProRes proxy frame
 *  
 *  @author The JCodec project
 *  
 */
var ProresToProxy = function(width, height, frameSize) {
    this.qMatLumaTo = ProresConsts.QMAT_LUMA_APCO;
    this.qMatChromaTo = ProresConsts.QMAT_CHROMA_APCO;
    this.frameSize = frameSize;
    var headerBytes = (height >> 4) * (((width >> 4) + 7) >> 3) * 8 + 148;
    var dataBits = (frameSize - headerBytes) << 3;
    this.bitsPer1024 = stjs.trunc((dataBits << 10) / (width * height));
    this.bitsPer1024High = this.bitsPer1024 - stjs.trunc(this.bitsPer1024 / 10);
    this.bitsPer1024Low = this.bitsPer1024 - stjs.trunc(this.bitsPer1024 / 20);
    this.nCoeffs = Math.max(Math.min(stjs.trunc(33000 / (width * height >> 8)), 64), 4);
};
ProresToProxy = stjs.extend(ProresToProxy, null, [], function(constructor, prototype) {
    prototype.qMatLumaTo = null;
    prototype.qMatChromaTo = null;
    prototype.frameSize = 0;
    constructor.START_QP = 6;
    prototype.bitsPer1024 = 0;
    prototype.bitsPer1024High = 0;
    prototype.bitsPer1024Low = 0;
    prototype.nCoeffs = 0;
    prototype.getFrameSize = function() {
        return this.frameSize;
    };
    prototype.requant = function(ib, ob, blocksPerSlice, qMatFrom, qMatTo, scan, mbX, mbY, plane) {
        var out = new Int32Array(blocksPerSlice << 6);
        try {
            ProresDecoder.readDCCoeffs(ib, qMatFrom, out, blocksPerSlice, 64);
            ProresDecoder.readACCoeffs(ib, qMatFrom, out, blocksPerSlice, scan, this.nCoeffs, 6);
        }catch (e) {}
        for (var i = 0; i < out.length; i++) 
            out[i] <<= 2;
        ProresEncoder.writeDCCoeffs(ob, qMatTo, out, blocksPerSlice);
        ProresEncoder.writeACCoeffs(ob, qMatTo, out, blocksPerSlice, scan, this.nCoeffs);
        ob.flush();
    };
    prototype.transcode = function(inBuf, outBuf) {
        var fork = outBuf.duplicate();
        var fh = ProresDecoder.readFrameHeader(inBuf);
        ProresEncoder.writeFrameHeader(outBuf, fh);
        var beforePicture = outBuf.position();
        if (fh.frameType == 0) {
            this.transcodePicture(inBuf, outBuf, fh);
        } else {
            this.transcodePicture(inBuf, outBuf, fh);
            this.transcodePicture(inBuf, outBuf, fh);
        }
        fh.qMatLuma = this.qMatLumaTo;
        fh.qMatChroma = this.qMatChromaTo;
        fh.payloadSize = outBuf.position() - beforePicture;
        ProresEncoder.writeFrameHeader(fork, fh);
    };
    prototype.transcodePicture = function(inBuf, outBuf, fh) {
        var ph = ProresDecoder.readPictureHeader(inBuf);
        ProresEncoder.writePictureHeader(ph.log2SliceMbWidth, ph.sliceSizes.length, outBuf);
        var sliceSizes = outBuf.duplicate();
        outBuf.setPosition(outBuf.position() + (ph.sliceSizes.length << 1));
        var mbX = 0, mbY = 0;
        var mbWidth = (fh.width + 15) >> 4;
        var sliceMbCount = 1 << ph.log2SliceMbWidth;
        var balance = 0, qp = ProresToProxy.START_QP;
        for (var i = 0; i < ph.sliceSizes.length; i++) {
             while (mbWidth - mbX < sliceMbCount)
                sliceMbCount >>= 1;
            var savedPoint = outBuf.position();
            this.transcodeSlice(inBuf, outBuf, fh.qMatLuma, fh.qMatChroma, fh.scan, sliceMbCount, mbX, mbY, ph.sliceSizes[i], qp);
            var encodedSize = (((outBuf.position() - savedPoint)) << 16 >> 16);
            sliceSizes.putShort(encodedSize);
            var max = (sliceMbCount * this.bitsPer1024High >> 5) + 6;
            var low = (sliceMbCount * this.bitsPer1024Low >> 5) + 6;
            if (encodedSize > max && qp < 128) {
                qp++;
                if ((encodedSize > max + balance) && qp < 128) 
                    qp++;
            } else {
                if (encodedSize < low && qp > 2 && balance > 0) 
                    qp--;
            }
            balance += max - encodedSize;
            mbX += sliceMbCount;
            if (mbX == mbWidth) {
                sliceMbCount = 1 << ph.log2SliceMbWidth;
                mbX = 0;
                mbY++;
            }
        }
    };
    prototype.transcodeSlice = function(inBuf, outBuf, qMatLuma, qMatChroma, scan, sliceMbCount, mbX, mbY, sliceSize, qp) {
        var hdrSize = (inBuf.get() & 255) >> 3;
        var qScaleOrig = ProresDecoder.clip(inBuf.get() & 255, 1, 224);
        var qScale = qScaleOrig > 128 ? qScaleOrig - 96 << 2 : qScaleOrig;
        var yDataSize = inBuf.getShort();
        var uDataSize = inBuf.getShort();
        var vDataSize = sliceSize - uDataSize - yDataSize - hdrSize;
        outBuf.put(((6 << 3) << 24 >> 24));
        outBuf.put((qp << 24 >> 24));
        var beforeSizes = outBuf.duplicate();
        outBuf.putInt(0);
        var beforeY = outBuf.position();
        this.requant(ProresDecoder.bitstream(inBuf, yDataSize), new BitWriter(outBuf), sliceMbCount << 2, ProresDecoder.scaleMat(qMatLuma, qScale), ProresDecoder.scaleMat(this.qMatLumaTo, qp), scan, mbX, mbY, 0);
        var beforeCb = outBuf.position();
        this.requant(ProresDecoder.bitstream(inBuf, uDataSize), new BitWriter(outBuf), sliceMbCount << 1, ProresDecoder.scaleMat(qMatChroma, qScale), ProresDecoder.scaleMat(this.qMatChromaTo, qp), scan, mbX, mbY, 1);
        var beforeCr = outBuf.position();
        this.requant(ProresDecoder.bitstream(inBuf, vDataSize), new BitWriter(outBuf), sliceMbCount << 1, ProresDecoder.scaleMat(qMatChroma, qScale), ProresDecoder.scaleMat(this.qMatChromaTo, qp), scan, mbX, mbY, 2);
        beforeSizes.putShort((((beforeCb - beforeY)) << 16 >> 16));
        beforeSizes.putShort((((beforeCr - beforeCb)) << 16 >> 16));
    };
}, {qMatLumaTo: "Int32Array", qMatChromaTo: "Int32Array"}, {});
/**
 *  Contains reference picture list management logic
 *  
 *  @author The JCodec Project
 */
var RefListManager = function(sh, sRefs, lRefs, frameOut) {
    this.sh = sh;
    this.sRefs = sRefs;
    this.lRefs = lRefs;
    if (sh.num_ref_idx_active_override_flag) 
        this.numRef = new Int32Array([sh.num_ref_idx_active_minus1[0] + 1, sh.num_ref_idx_active_minus1[1] + 1]);
     else 
        this.numRef = new Int32Array([sh.pps.num_ref_idx_active_minus1[0] + 1, sh.pps.num_ref_idx_active_minus1[1] + 1]);
    this.frameOut = frameOut;
};
RefListManager = stjs.extend(RefListManager, null, [], function(constructor, prototype) {
    prototype.sh = null;
    prototype.numRef = null;
    prototype.sRefs = null;
    prototype.lRefs = null;
    prototype.frameOut = null;
    prototype.getRefList = function() {
        var refList = null;
        if (this.sh.slice_type == SliceType.P) {
            refList = [this.buildRefListP(), null];
        } else if (this.sh.slice_type == SliceType.B) {
            refList = this.buildRefListB();
        }
        MBlockDecoderUtils.debugPrint("------");
        if (refList != null) {
            for (var l = 0; l < 2; l++) {
                if (refList[l] != null) 
                    for (var i = 0; i < refList[l].length; i++) 
                        if (refList[l][i] != null) 
                            MBlockDecoderUtils.debugPrint("REF[%d][%d]: ", l, i, (refList[l][i]).getPOC());
            }
        }
        return refList;
    };
    prototype.buildRefListP = function() {
        var frame_num = this.sh.frame_num;
        var maxFrames = 1 << (this.sh.sps.log2_max_frame_num_minus4 + 4);
        var result = Array(this.numRef[0]);
        var refs = 0;
        for (var i = frame_num - 1; i >= frame_num - maxFrames && refs < this.numRef[0]; i--) {
            var fn = i < 0 ? i + maxFrames : i;
            if (this.sRefs[fn] != null) {
                result[refs] = this.sRefs[fn] == H264Const.NO_PIC ? null : this.sRefs[fn];
                ++refs;
            }
        }
        var keys = this.lRefs.keys();
        Arrays.sort(keys);
        for (var i = 0; i < keys.length && refs < this.numRef[0]; i++) {
            result[refs++] = this.lRefs.get(keys[i]);
        }
        this.reorder(result, 0);
        return result;
    };
    prototype.buildRefListB = function() {
        var l0 = this.buildList(Frame.POCDesc, Frame.POCAsc);
        var l1 = this.buildList(Frame.POCAsc, Frame.POCDesc);
        if (Platform.arrayEqualsObj(l0, l1) && this.count(l1) > 1) {
            var frame = l1[1];
            l1[1] = l1[0];
            l1[0] = frame;
        }
        var result = [Platform.copyOfObj(l0, this.numRef[0]), Platform.copyOfObj(l1, this.numRef[1])];
        this.reorder(result[0], 0);
        this.reorder(result[1], 1);
        return result;
    };
    prototype.buildList = function(cmpFwd, cmpInv) {
        var refs = Array(this.sRefs.length + this.lRefs.size());
        var fwd = this.copySort(cmpFwd, this.frameOut);
        var inv = this.copySort(cmpInv, this.frameOut);
        var nFwd = this.count(fwd);
        var nInv = this.count(inv);
        var ref = 0;
        for (var i = 0; i < nFwd; i++ , ref++) 
            refs[ref] = fwd[i];
        for (var i = 0; i < nInv; i++ , ref++) 
            refs[ref] = inv[i];
        var keys = this.lRefs.keys();
        Arrays.sort(keys);
        for (var i = 0; i < keys.length; i++ , ref++) 
            refs[ref] = this.lRefs.get(keys[i]);
        return refs;
    };
    prototype.count = function(arr) {
        for (var nn = 0; nn < arr.length; nn++) 
            if (arr[nn] == null) 
                return nn;
        return arr.length;
    };
    prototype.copySort = function(fwd, dummy) {
        var copyOf = Platform.copyOfObj(this.sRefs, this.sRefs.length);
        for (var i = 0; i < copyOf.length; i++) 
            if (fwd.compare(dummy, copyOf[i]) > 0) 
                copyOf[i] = null;
        Arrays.sort(copyOf, fwd);
        return copyOf;
    };
    prototype.reorder = function(result, list) {
        if (this.sh.refPicReordering[list] == null) 
            return;
        var predict = this.sh.frame_num;
        var maxFrames = 1 << (this.sh.sps.log2_max_frame_num_minus4 + 4);
        for (var ind = 0; ind < this.sh.refPicReordering[list][0].length; ind++) {
            switch (this.sh.refPicReordering[list][0][ind]) {
                case 0:
                    predict = MathUtil.wrap(predict - this.sh.refPicReordering[list][1][ind] - 1, maxFrames);
                    break;
                case 1:
                    predict = MathUtil.wrap(predict + this.sh.refPicReordering[list][1][ind] + 1, maxFrames);
                    break;
                case 2:
                     throw new RuntimeException("long term");
            }
            for (var i = this.numRef[list] - 1; i > ind; i--) 
                result[i] = result[i - 1];
            result[ind] = this.sRefs[predict];
            for (var i = ind + 1, j = i; i < this.numRef[list] && result[i] != null; i++) {
                if (result[i] != this.sRefs[predict]) 
                    result[j++] = result[i];
            }
        }
    };
}, {sh: "SliceHeader", numRef: "Int32Array", sRefs: "Array", lRefs: {name: "IntObjectMap", arguments: ["Frame"]}, frameOut: "Frame"}, {});
/**
 *  Contains methods for reading high-level symbols out of H.264 bitstream
 *  
 *  @author The JCodec Project
 */
var SliceReader = function(activePps, cabac, cavlc, mDecoder, reader, mapper, sh, nalUnit) {
    this.activePps = activePps;
    this.cabac = cabac;
    this.mDecoder = mDecoder;
    this.cavlc = cavlc;
    this.reader = reader;
    this.mapper = mapper;
    this.sh = sh;
    this.nalUnit = nalUnit;
    var mbWidth = sh.sps.pic_width_in_mbs_minus1 + 1;
    this.topMBType = Array(mbWidth);
    this.topCBPLuma = new Int32Array(mbWidth);
    this.topCBPChroma = new Int32Array(mbWidth);
    this.chromaFormat = sh.sps.chroma_format_idc;
    this.transform8x8 = sh.pps.extended == null ? false : sh.pps.extended.transform_8x8_mode_flag;
    if (sh.num_ref_idx_active_override_flag) 
        this.numRef = new Int32Array([sh.num_ref_idx_active_minus1[0] + 1, sh.num_ref_idx_active_minus1[1] + 1]);
     else 
        this.numRef = new Int32Array([sh.pps.num_ref_idx_active_minus1[0] + 1, sh.pps.num_ref_idx_active_minus1[1] + 1]);
    this.tf8x8Top = new Int8Array(mbWidth);
    this.predModeLeft = Array(2);
    this.predModeTop = Array(mbWidth << 1);
    this.i4x4PredLeft = new Int32Array(4);
    this.i4x4PredTop = new Int32Array(mbWidth << 2);
};
SliceReader = stjs.extend(SliceReader, null, [], function(constructor, prototype) {
    prototype.activePps = null;
    prototype.cabac = null;
    prototype.mDecoder = null;
    prototype.cavlc = null;
    prototype.reader = null;
    prototype.mapper = null;
    prototype.sh = null;
    prototype.nalUnit = null;
    prototype.prevMbSkipped = false;
    prototype.mbIdx = 0;
    prototype.prevMBType = null;
    prototype.mbSkipRun = 0;
    prototype.endOfData = false;
    prototype.topMBType = null;
    prototype.leftMBType = null;
    prototype.leftCBPLuma = 0;
    prototype.topCBPLuma = null;
    prototype.leftCBPChroma = 0;
    prototype.topCBPChroma = null;
    prototype.chromaFormat = null;
    prototype.transform8x8 = false;
    prototype.numRef = null;
    prototype.tf8x8Left = false;
    prototype.tf8x8Top = null;
    prototype.i4x4PredTop = null;
    prototype.i4x4PredLeft = null;
    prototype.predModeLeft = null;
    prototype.predModeTop = null;
    prototype.readMacroblock = function(mBlock) {
        if (this.endOfData && this.mbSkipRun == 0) 
            return false;
        mBlock.mbIdx = this.mbIdx;
        mBlock.prevMbType = this.prevMBType;
        var mbWidth1 = this.sh.sps.pic_width_in_mbs_minus1 + 1;
        var mbaffFrameFlag = (this.sh.sps.mb_adaptive_frame_field_flag && !this.sh.field_pic_flag);
        if (this.sh.slice_type.isInter() && !this.activePps.entropy_coding_mode_flag) {
            if (!this.prevMbSkipped && this.mbSkipRun == 0) {
                this.mbSkipRun = CAVLCReader.readUEtrace(this.reader, "mb_skip_run");
                if (!CAVLCReader.moreRBSPData(this.reader)) {
                    this.endOfData = true;
                }
            }
            if (this.mbSkipRun > 0) {
                --this.mbSkipRun;
                var mbAddr = this.mapper.getAddress(this.mbIdx);
                this.prevMbSkipped = true;
                this.prevMBType = null;
                MBlockDecoderUtils.debugPrint("---------------------- MB (%d,%d) ---------------------", (mbAddr % mbWidth1), (stjs.trunc(mbAddr / mbWidth1)));
                mBlock.skipped = true;
                var mbX = this.mapper.getMbX(mBlock.mbIdx);
                this.topMBType[mbX] = this.leftMBType = null;
                var blk8x8X = mbX << 1;
                this.predModeLeft[0] = this.predModeLeft[1] = this.predModeTop[blk8x8X] = this.predModeTop[blk8x8X + 1] = H264Const.PartPred.L0;
                ++this.mbIdx;
                return true;
            } else {
                this.prevMbSkipped = false;
            }
        }
        var mbAddr = this.mapper.getAddress(this.mbIdx);
        var mbX = mbAddr % mbWidth1;
        var mbY = stjs.trunc(mbAddr / mbWidth1);
        MBlockDecoderUtils.debugPrint("---------------------- MB (%d,%d) ---------------------", mbX, mbY);
        if (this.sh.slice_type.isIntra() || (!this.activePps.entropy_coding_mode_flag || !this.readMBSkipFlag(this.sh.slice_type, this.mapper.leftAvailable(this.mbIdx), this.mapper.topAvailable(this.mbIdx), mbX))) {
            var mb_field_decoding_flag = false;
            if (mbaffFrameFlag && (this.mbIdx % 2 == 0 || (this.mbIdx % 2 == 1 && this.prevMbSkipped))) {
                mb_field_decoding_flag = CAVLCReader.readBool(this.reader, "mb_field_decoding_flag");
            }
            mBlock.fieldDecoding = mb_field_decoding_flag;
            this.readMBlock(mBlock, this.sh.slice_type);
            this.prevMBType = mBlock.curMbType;
        } else {
            this.prevMBType = null;
            this.prevMbSkipped = true;
            mBlock.skipped = true;
            var blk8x8X = mbX << 1;
            this.predModeLeft[0] = this.predModeLeft[1] = this.predModeTop[blk8x8X] = this.predModeTop[blk8x8X + 1] = H264Const.PartPred.L0;
        }
        this.endOfData = (this.activePps.entropy_coding_mode_flag && this.mDecoder.decodeFinalBin() == 1) || (!this.activePps.entropy_coding_mode_flag && !CAVLCReader.moreRBSPData(this.reader));
        ++this.mbIdx;
        this.topMBType[this.mapper.getMbX(mBlock.mbIdx)] = this.leftMBType = mBlock.curMbType;
        return true;
    };
    prototype.readMBQpDelta = function(prevMbType) {
        var mbQPDelta;
        if (!this.activePps.entropy_coding_mode_flag) {
            mbQPDelta = CAVLCReader.readSE(this.reader, "mb_qp_delta");
        } else {
            mbQPDelta = this.cabac.readMBQpDelta(this.mDecoder, prevMbType);
        }
        return mbQPDelta;
    };
    prototype.readChromaPredMode = function(mbX, leftAvailable, topAvailable) {
        var chromaPredictionMode;
        if (!this.activePps.entropy_coding_mode_flag) {
            chromaPredictionMode = CAVLCReader.readUEtrace(this.reader, "MBP: intra_chroma_pred_mode");
        } else {
            chromaPredictionMode = this.cabac.readIntraChromaPredMode(this.mDecoder, mbX, this.leftMBType, this.topMBType[mbX], leftAvailable, topAvailable);
        }
        return chromaPredictionMode;
    };
    prototype.readTransform8x8Flag = function(leftAvailable, topAvailable, leftType, topType, is8x8Left, is8x8Top) {
        if (!this.activePps.entropy_coding_mode_flag) 
            return CAVLCReader.readBool(this.reader, "transform_size_8x8_flag");
         else 
            return this.cabac.readTransform8x8Flag(this.mDecoder, leftAvailable, topAvailable, leftType, topType, is8x8Left, is8x8Top);
    };
    prototype.readCodedBlockPatternIntra = function(leftAvailable, topAvailable, leftCBP, topCBP, leftMB, topMB) {
        if (!this.activePps.entropy_coding_mode_flag) 
            return H264Const.CODED_BLOCK_PATTERN_INTRA_COLOR[CAVLCReader.readUEtrace(this.reader, "coded_block_pattern")];
         else 
            return this.cabac.codedBlockPatternIntra(this.mDecoder, leftAvailable, topAvailable, leftCBP, topCBP, leftMB, topMB);
    };
    prototype.readCodedBlockPatternInter = function(leftAvailable, topAvailable, leftCBP, topCBP, leftMB, topMB) {
        if (!this.activePps.entropy_coding_mode_flag) {
            var code = CAVLCReader.readUEtrace(this.reader, "coded_block_pattern");
            return H264Const.CODED_BLOCK_PATTERN_INTER_COLOR[code];
        } else 
            return this.cabac.codedBlockPatternIntra(this.mDecoder, leftAvailable, topAvailable, leftCBP, topCBP, leftMB, topMB);
    };
    prototype.readRefIdx = function(leftAvailable, topAvailable, leftType, topType, leftPred, topPred, curPred, mbX, partX, partY, partW, partH, list) {
        if (!this.activePps.entropy_coding_mode_flag) 
            return CAVLCReader.readTE(this.reader, this.numRef[list] - 1);
         else 
            return this.cabac.readRefIdx(this.mDecoder, leftAvailable, topAvailable, leftType, topType, leftPred, topPred, curPred, mbX, partX, partY, partW, partH, list);
    };
    prototype.readMVD = function(comp, leftAvailable, topAvailable, leftType, topType, leftPred, topPred, curPred, mbX, partX, partY, partW, partH, list) {
        if (!this.activePps.entropy_coding_mode_flag) 
            return CAVLCReader.readSE(this.reader, "mvd_l0_x");
         else 
            return this.cabac.readMVD(this.mDecoder, comp, leftAvailable, topAvailable, leftType, topType, leftPred, topPred, curPred, mbX, partX, partY, partW, partH, list);
    };
    prototype.readPredictionI4x4Block = function(leftAvailable, topAvailable, leftMBType, topMBType, blkX, blkY, mbX) {
        var mode = 2;
        if ((leftAvailable || blkX > 0) && (topAvailable || blkY > 0)) {
            var predModeB = topMBType == MBType.I_NxN || blkY > 0 ? this.i4x4PredTop[(mbX << 2) + blkX] : 2;
            var predModeA = leftMBType == MBType.I_NxN || blkX > 0 ? this.i4x4PredLeft[blkY] : 2;
            mode = Math.min(predModeB, predModeA);
        }
        if (!this.prev4x4PredMode()) {
            var rem_intra4x4_pred_mode = this.rem4x4PredMode();
            mode = rem_intra4x4_pred_mode + (rem_intra4x4_pred_mode < mode ? 0 : 1);
        }
        this.i4x4PredTop[(mbX << 2) + blkX] = this.i4x4PredLeft[blkY] = mode;
        return mode;
    };
    prototype.rem4x4PredMode = function() {
        if (!this.activePps.entropy_coding_mode_flag) 
            return CAVLCReader.readNBit(this.reader, 3, "MB: rem_intra4x4_pred_mode");
         else 
            return this.cabac.rem4x4PredMode(this.mDecoder);
    };
    prototype.prev4x4PredMode = function() {
        if (!this.activePps.entropy_coding_mode_flag) 
            return CAVLCReader.readBool(this.reader, "MBP: prev_intra4x4_pred_mode_flag");
         else 
            return this.cabac.prev4x4PredModeFlag(this.mDecoder);
    };
    prototype.read16x16DC = function(leftAvailable, topAvailable, mbX, dc) {
        if (!this.activePps.entropy_coding_mode_flag) 
            this.cavlc[0].readLumaDCBlock(this.reader, dc, mbX, leftAvailable, this.leftMBType, topAvailable, this.topMBType[mbX], CoeffTransformer.zigzag4x4);
         else {
            if (this.cabac.readCodedBlockFlagLumaDC(this.mDecoder, mbX, this.leftMBType, this.topMBType[mbX], leftAvailable, topAvailable, MBType.I_16x16) == 1) 
                this.cabac.readCoeffs(this.mDecoder, CABAC.BlockType.LUMA_16_DC, dc, 0, 16, CoeffTransformer.zigzag4x4, H264Const.identityMapping16, H264Const.identityMapping16);
        }
    };
    /**
     *  Reads AC block of macroblock encoded as I_16x16, returns number of
     *  non-zero coefficients
     *  
     *  @return
     */
    prototype.read16x16AC = function(leftAvailable, topAvailable, mbX, cbpLuma, ac, blkOffLeft, blkOffTop, blkX, blkY) {
        if (!this.activePps.entropy_coding_mode_flag) {
            return this.cavlc[0].readACBlock(this.reader, ac, blkX, blkOffTop, blkOffLeft != 0 || leftAvailable, blkOffLeft == 0 ? this.leftMBType : MBType.I_16x16, blkOffTop != 0 || topAvailable, blkOffTop == 0 ? this.topMBType[mbX] : MBType.I_16x16, 1, 15, CoeffTransformer.zigzag4x4);
        } else {
            if (this.cabac.readCodedBlockFlagLumaAC(this.mDecoder, CABAC.BlockType.LUMA_15_AC, blkX, blkOffTop, 0, this.leftMBType, this.topMBType[mbX], leftAvailable, topAvailable, this.leftCBPLuma, this.topCBPLuma[mbX], cbpLuma, MBType.I_16x16) == 1) 
                return this.cabac.readCoeffs(this.mDecoder, CABAC.BlockType.LUMA_15_AC, ac, 1, 15, CoeffTransformer.zigzag4x4, H264Const.identityMapping16, H264Const.identityMapping16);
        }
        return 0;
    };
    /**
     *  Reads AC block of a macroblock, return number of non-zero coefficients
     *  
     *  @return
     */
    prototype.readResidualAC = function(leftAvailable, topAvailable, mbX, curMbType, cbpLuma, blkOffLeft, blkOffTop, blkX, blkY, ac) {
        if (!this.activePps.entropy_coding_mode_flag) {
            return this.cavlc[0].readACBlock(this.reader, ac, blkX, blkOffTop, blkOffLeft != 0 || leftAvailable, blkOffLeft == 0 ? this.leftMBType : curMbType, blkOffTop != 0 || topAvailable, blkOffTop == 0 ? this.topMBType[mbX] : curMbType, 0, 16, CoeffTransformer.zigzag4x4);
        } else {
            if (this.cabac.readCodedBlockFlagLumaAC(this.mDecoder, CABAC.BlockType.LUMA_16, blkX, blkOffTop, 0, this.leftMBType, this.topMBType[mbX], leftAvailable, topAvailable, this.leftCBPLuma, this.topCBPLuma[mbX], cbpLuma, curMbType) == 1) 
                return this.cabac.readCoeffs(this.mDecoder, CABAC.BlockType.LUMA_16, ac, 0, 16, CoeffTransformer.zigzag4x4, H264Const.identityMapping16, H264Const.identityMapping16);
        }
        return 0;
    };
    prototype.setZeroCoeff = function(comp, blkX, blkOffTop) {
        this.cavlc[comp].setZeroCoeff(blkX, blkOffTop);
    };
    prototype.savePrevCBP = function(codedBlockPattern) {
        if (this.activePps.entropy_coding_mode_flag) 
            this.cabac.setPrevCBP(codedBlockPattern);
    };
    prototype.readLumaAC = function(leftAvailable, topAvailable, mbX, curMbType, blkX, j, ac16, blkOffLeft, blkOffTop) {
        return this.cavlc[0].readACBlock(this.reader, ac16, blkX + (j & 1), blkOffTop, blkOffLeft != 0 || leftAvailable, blkOffLeft == 0 ? this.leftMBType : curMbType, blkOffTop != 0 || topAvailable, blkOffTop == 0 ? this.topMBType[mbX] : curMbType, 0, 16, H264Const.identityMapping16);
    };
    /**
     *  Reads luma AC coeffiecients for 8x8 blocks, returns number of non-zero
     *  coefficients
     *  
     *  @return
     */
    prototype.readLumaAC8x8 = function(blkX, blkY, ac) {
        var readCoeffs = this.cabac.readCoeffs(this.mDecoder, CABAC.BlockType.LUMA_64, ac, 0, 64, CoeffTransformer.zigzag8x8, H264Const.sig_coeff_map_8x8, H264Const.last_sig_coeff_map_8x8);
        this.cabac.setCodedBlock(blkX, blkY);
        this.cabac.setCodedBlock(blkX + 1, blkY);
        this.cabac.setCodedBlock(blkX, blkY + 1);
        this.cabac.setCodedBlock(blkX + 1, blkY + 1);
        return readCoeffs;
    };
    prototype.readSubMBTypeP = function() {
        if (!this.activePps.entropy_coding_mode_flag) 
            return CAVLCReader.readUEtrace(this.reader, "SUB: sub_mb_type");
         else 
            return this.cabac.readSubMbTypeP(this.mDecoder);
    };
    prototype.readSubMBTypeB = function() {
        if (!this.activePps.entropy_coding_mode_flag) 
            return CAVLCReader.readUEtrace(this.reader, "SUB: sub_mb_type");
         else 
            return this.cabac.readSubMbTypeB(this.mDecoder);
    };
    prototype.readChromaDC = function(mbX, leftAvailable, topAvailable, dc, comp, curMbType) {
        if (!this.activePps.entropy_coding_mode_flag) 
            this.cavlc[comp].readChromaDCBlock(this.reader, dc, leftAvailable, topAvailable);
         else {
            if (this.cabac.readCodedBlockFlagChromaDC(this.mDecoder, mbX, comp, this.leftMBType, this.topMBType[mbX], leftAvailable, topAvailable, this.leftCBPChroma, this.topCBPChroma[mbX], curMbType) == 1) 
                this.cabac.readCoeffs(this.mDecoder, CABAC.BlockType.CHROMA_DC, dc, 0, 4, H264Const.identityMapping16, H264Const.identityMapping16, H264Const.identityMapping16);
        }
    };
    prototype.readChromaAC = function(leftAvailable, topAvailable, mbX, comp, curMbType, ac, blkOffLeft, blkOffTop, blkX) {
        if (!this.activePps.entropy_coding_mode_flag) 
            this.cavlc[comp].readACBlock(this.reader, ac, blkX, blkOffTop, blkOffLeft != 0 || leftAvailable, blkOffLeft == 0 ? this.leftMBType : curMbType, blkOffTop != 0 || topAvailable, blkOffTop == 0 ? this.topMBType[mbX] : curMbType, 1, 15, CoeffTransformer.zigzag4x4);
         else {
            if (this.cabac.readCodedBlockFlagChromaAC(this.mDecoder, blkX, blkOffTop, comp, this.leftMBType, this.topMBType[mbX], leftAvailable, topAvailable, this.leftCBPChroma, this.topCBPChroma[mbX], curMbType) == 1) 
                this.cabac.readCoeffs(this.mDecoder, CABAC.BlockType.CHROMA_AC, ac, 1, 15, CoeffTransformer.zigzag4x4, H264Const.identityMapping16, H264Const.identityMapping16);
        }
    };
    prototype.decodeMBTypeI = function(mbIdx, leftAvailable, topAvailable, leftMBType, topMBType) {
        var mbType;
        if (!this.activePps.entropy_coding_mode_flag) 
            mbType = CAVLCReader.readUEtrace(this.reader, "MB: mb_type");
         else 
            mbType = this.cabac.readMBTypeI(this.mDecoder, leftMBType, topMBType, leftAvailable, topAvailable);
        return mbType;
    };
    prototype.readMBTypeP = function() {
        var mbType;
        if (!this.activePps.entropy_coding_mode_flag) 
            mbType = CAVLCReader.readUEtrace(this.reader, "MB: mb_type");
         else 
            mbType = this.cabac.readMBTypeP(this.mDecoder);
        return mbType;
    };
    prototype.readMBTypeB = function(mbIdx, leftAvailable, topAvailable, leftMBType, topMBType) {
        var mbType;
        if (!this.activePps.entropy_coding_mode_flag) 
            mbType = CAVLCReader.readUEtrace(this.reader, "MB: mb_type");
         else 
            mbType = this.cabac.readMBTypeB(this.mDecoder, leftMBType, topMBType, leftAvailable, topAvailable);
        return mbType;
    };
    prototype.readMBSkipFlag = function(slType, leftAvailable, topAvailable, mbX) {
        return this.cabac.readMBSkipFlag(this.mDecoder, slType, leftAvailable, topAvailable, mbX);
    };
    prototype.readIntra16x16 = function(mbType, mBlock) {
        var mbX = this.mapper.getMbX(mBlock.mbIdx);
        var mbY = this.mapper.getMbY(mBlock.mbIdx);
        var leftAvailable = this.mapper.leftAvailable(mBlock.mbIdx);
        var topAvailable = this.mapper.topAvailable(mBlock.mbIdx);
        mBlock.cbp((stjs.trunc(mbType / 12)) * 15, (stjs.trunc(mbType / 4)) % 3);
        mBlock.luma16x16Mode = mbType % 4;
        mBlock.chromaPredictionMode = this.readChromaPredMode(mbX, leftAvailable, topAvailable);
        mBlock.mbQPDelta = this.readMBQpDelta(mBlock.prevMbType);
        this.read16x16DC(leftAvailable, topAvailable, mbX, mBlock.dc);
        for (var i = 0; i < 16; i++) {
            var blkOffLeft = H264Const.MB_BLK_OFF_LEFT[i];
            var blkOffTop = H264Const.MB_BLK_OFF_TOP[i];
            var blkX = (mbX << 2) + blkOffLeft;
            var blkY = (mbY << 2) + blkOffTop;
            if ((mBlock.cbpLuma() & (1 << (i >> 2))) != 0) {
                mBlock.nCoeff[i] = this.read16x16AC(leftAvailable, topAvailable, mbX, mBlock.cbpLuma(), mBlock.ac[0][i], blkOffLeft, blkOffTop, blkX, blkY);
            } else {
                if (!this.sh.pps.entropy_coding_mode_flag) 
                    this.setZeroCoeff(0, blkX, blkOffTop);
            }
        }
        if (this.chromaFormat != ColorSpace.MONO) {
            this.readChromaResidual(mBlock, leftAvailable, topAvailable, mbX);
        }
    };
    prototype.readMBlockBDirect = function(mBlock) {
        var mbX = this.mapper.getMbX(mBlock.mbIdx);
        var mbY = this.mapper.getMbY(mBlock.mbIdx);
        var lAvb = this.mapper.leftAvailable(mBlock.mbIdx);
        var tAvb = this.mapper.topAvailable(mBlock.mbIdx);
        mBlock._cbp = this.readCodedBlockPatternInter(lAvb, tAvb, this.leftCBPLuma | (this.leftCBPChroma << 4), this.topCBPLuma[mbX] | (this.topCBPChroma[mbX] << 4), this.leftMBType, this.topMBType[mbX]);
        mBlock.transform8x8Used = false;
        if (this.transform8x8 && mBlock.cbpLuma() != 0 && this.sh.sps.direct_8x8_inference_flag) {
            mBlock.transform8x8Used = this.readTransform8x8Flag(lAvb, tAvb, this.leftMBType, this.topMBType[mbX], this.tf8x8Left, this.tf8x8Top[mbX]);
        }
        if (mBlock.cbpLuma() > 0 || mBlock.cbpChroma() > 0) {
            mBlock.mbQPDelta = this.readMBQpDelta(mBlock.prevMbType);
        }
        this.readResidualLuma(mBlock, lAvb, tAvb, mbX, mbY);
        this.readChromaResidual(mBlock, lAvb, tAvb, mbX);
        this.predModeTop[mbX << 1] = this.predModeTop[(mbX << 1) + 1] = this.predModeLeft[0] = this.predModeLeft[1] = H264Const.PartPred.Direct;
    };
    prototype.readInter16x16 = function(p0, mBlock) {
        var mbX = this.mapper.getMbX(mBlock.mbIdx);
        var mbY = this.mapper.getMbY(mBlock.mbIdx);
        var leftAvailable = this.mapper.leftAvailable(mBlock.mbIdx);
        var topAvailable = this.mapper.topAvailable(mBlock.mbIdx);
        for (var list = 0; list < 2; list++) {
            if (H264Const.usesList(p0, list) && this.numRef[list] > 1) 
                mBlock.pb16x16.refIdx[list] = this.readRefIdx(leftAvailable, topAvailable, this.leftMBType, this.topMBType[mbX], this.predModeLeft[0], this.predModeTop[(mbX << 1)], p0, mbX, 0, 0, 4, 4, list);
        }
        for (var list = 0; list < 2; list++) {
            this.readPredictionInter16x16(mBlock, mbX, leftAvailable, topAvailable, list, p0);
        }
        this.readResidualInter(mBlock, leftAvailable, topAvailable, mbX, mbY);
        this.predModeLeft[0] = this.predModeLeft[1] = this.predModeTop[mbX << 1] = this.predModeTop[(mbX << 1) + 1] = p0;
    };
    prototype.readPredInter8x16 = function(mBlock, mbX, leftAvailable, topAvailable, list, p0, p1) {
        var blk8x8X = (mbX << 1);
        if (H264Const.usesList(p0, list)) {
            mBlock.pb168x168.mvdX1[list] = this.readMVD(0, leftAvailable, topAvailable, this.leftMBType, this.topMBType[mbX], this.predModeLeft[0], this.predModeTop[blk8x8X], p0, mbX, 0, 0, 2, 4, list);
            mBlock.pb168x168.mvdY1[list] = this.readMVD(1, leftAvailable, topAvailable, this.leftMBType, this.topMBType[mbX], this.predModeLeft[0], this.predModeTop[blk8x8X], p0, mbX, 0, 0, 2, 4, list);
        }
        if (H264Const.usesList(p1, list)) {
            mBlock.pb168x168.mvdX2[list] = this.readMVD(0, true, topAvailable, MBType.P_8x16, this.topMBType[mbX], p0, this.predModeTop[blk8x8X + 1], p1, mbX, 2, 0, 2, 4, list);
            mBlock.pb168x168.mvdY2[list] = this.readMVD(1, true, topAvailable, MBType.P_8x16, this.topMBType[mbX], p0, this.predModeTop[blk8x8X + 1], p1, mbX, 2, 0, 2, 4, list);
        }
    };
    prototype.readPredictionInter16x8 = function(mBlock, mbX, leftAvailable, topAvailable, p0, p1, list) {
        var blk8x8X = mbX << 1;
        if (H264Const.usesList(p0, list)) {
            mBlock.pb168x168.mvdX1[list] = this.readMVD(0, leftAvailable, topAvailable, this.leftMBType, this.topMBType[mbX], this.predModeLeft[0], this.predModeTop[blk8x8X], p0, mbX, 0, 0, 4, 2, list);
            mBlock.pb168x168.mvdY1[list] = this.readMVD(1, leftAvailable, topAvailable, this.leftMBType, this.topMBType[mbX], this.predModeLeft[0], this.predModeTop[blk8x8X], p0, mbX, 0, 0, 4, 2, list);
        }
        if (H264Const.usesList(p1, list)) {
            mBlock.pb168x168.mvdX2[list] = this.readMVD(0, leftAvailable, true, this.leftMBType, MBType.P_16x8, this.predModeLeft[1], p0, p1, mbX, 0, 2, 4, 2, list);
            mBlock.pb168x168.mvdY2[list] = this.readMVD(1, leftAvailable, true, this.leftMBType, MBType.P_16x8, this.predModeLeft[1], p0, p1, mbX, 0, 2, 4, 2, list);
        }
    };
    prototype.readInter16x8 = function(p0, p1, mBlock) {
        var mbX = this.mapper.getMbX(mBlock.mbIdx);
        var mbY = this.mapper.getMbY(mBlock.mbIdx);
        var leftAvailable = this.mapper.leftAvailable(mBlock.mbIdx);
        var topAvailable = this.mapper.topAvailable(mBlock.mbIdx);
        for (var list = 0; list < 2; list++) {
            if (H264Const.usesList(p0, list) && this.numRef[list] > 1) 
                mBlock.pb168x168.refIdx1[list] = this.readRefIdx(leftAvailable, topAvailable, this.leftMBType, this.topMBType[mbX], this.predModeLeft[0], this.predModeTop[(mbX << 1)], p0, mbX, 0, 0, 4, 2, list);
            if (H264Const.usesList(p1, list) && this.numRef[list] > 1) 
                mBlock.pb168x168.refIdx2[list] = this.readRefIdx(leftAvailable, true, this.leftMBType, mBlock.curMbType, this.predModeLeft[1], p0, p1, mbX, 0, 2, 4, 2, list);
        }
        for (var list = 0; list < 2; list++) {
            this.readPredictionInter16x8(mBlock, mbX, leftAvailable, topAvailable, p0, p1, list);
        }
        this.readResidualInter(mBlock, leftAvailable, topAvailable, mbX, mbY);
        this.predModeLeft[0] = p0;
        this.predModeLeft[1] = this.predModeTop[mbX << 1] = this.predModeTop[(mbX << 1) + 1] = p1;
    };
    prototype.readIntra8x16 = function(p0, p1, mBlock) {
        var mbX = this.mapper.getMbX(mBlock.mbIdx);
        var mbY = this.mapper.getMbY(mBlock.mbIdx);
        var leftAvailable = this.mapper.leftAvailable(mBlock.mbIdx);
        var topAvailable = this.mapper.topAvailable(mBlock.mbIdx);
        for (var list = 0; list < 2; list++) {
            if (H264Const.usesList(p0, list) && this.numRef[list] > 1) 
                mBlock.pb168x168.refIdx1[list] = this.readRefIdx(leftAvailable, topAvailable, this.leftMBType, this.topMBType[mbX], this.predModeLeft[0], this.predModeTop[mbX << 1], p0, mbX, 0, 0, 2, 4, list);
            if (H264Const.usesList(p1, list) && this.numRef[list] > 1) 
                mBlock.pb168x168.refIdx2[list] = this.readRefIdx(true, topAvailable, mBlock.curMbType, this.topMBType[mbX], p0, this.predModeTop[(mbX << 1) + 1], p1, mbX, 2, 0, 2, 4, list);
        }
        for (var list = 0; list < 2; list++) {
            this.readPredInter8x16(mBlock, mbX, leftAvailable, topAvailable, list, p0, p1);
        }
        this.readResidualInter(mBlock, leftAvailable, topAvailable, mbX, mbY);
        this.predModeTop[mbX << 1] = p0;
        this.predModeTop[(mbX << 1) + 1] = this.predModeLeft[0] = this.predModeLeft[1] = p1;
    };
    prototype.readPredictionInter16x16 = function(mBlock, mbX, leftAvailable, topAvailable, list, curPred) {
        var blk8x8X = (mbX << 1);
        if (H264Const.usesList(curPred, list)) {
            mBlock.pb16x16.mvdX[list] = this.readMVD(0, leftAvailable, topAvailable, this.leftMBType, this.topMBType[mbX], this.predModeLeft[0], this.predModeTop[blk8x8X], curPred, mbX, 0, 0, 4, 4, list);
            mBlock.pb16x16.mvdY[list] = this.readMVD(1, leftAvailable, topAvailable, this.leftMBType, this.topMBType[mbX], this.predModeLeft[0], this.predModeTop[blk8x8X], curPred, mbX, 0, 0, 4, 4, list);
        }
    };
    prototype.readResidualInter = function(mBlock, leftAvailable, topAvailable, mbX, mbY) {
        mBlock._cbp = this.readCodedBlockPatternInter(leftAvailable, topAvailable, this.leftCBPLuma | (this.leftCBPChroma << 4), this.topCBPLuma[mbX] | (this.topCBPChroma[mbX] << 4), this.leftMBType, this.topMBType[mbX]);
        mBlock.transform8x8Used = false;
        if (mBlock.cbpLuma() != 0 && this.transform8x8) {
            mBlock.transform8x8Used = this.readTransform8x8Flag(leftAvailable, topAvailable, this.leftMBType, this.topMBType[mbX], this.tf8x8Left, this.tf8x8Top[mbX]);
        }
        if (mBlock.cbpLuma() > 0 || mBlock.cbpChroma() > 0) {
            mBlock.mbQPDelta = this.readMBQpDelta(mBlock.prevMbType);
        }
        this.readResidualLuma(mBlock, leftAvailable, topAvailable, mbX, mbY);
        if (this.chromaFormat != ColorSpace.MONO) {
            this.readChromaResidual(mBlock, leftAvailable, topAvailable, mbX);
        }
    };
    prototype.readMBlock8x8 = function(mBlock) {
        var mbX = this.mapper.getMbX(mBlock.mbIdx);
        var mbY = this.mapper.getMbY(mBlock.mbIdx);
        var leftAvailable = this.mapper.leftAvailable(mBlock.mbIdx);
        var topAvailable = this.mapper.topAvailable(mBlock.mbIdx);
        var noSubMBLessThen8x8;
        if (mBlock.curMbType == MBType.P_8x8 || mBlock.curMbType == MBType.P_8x8ref0) {
            this.readPrediction8x8P(mBlock, mbX, leftAvailable, topAvailable);
            noSubMBLessThen8x8 = mBlock.pb8x8.subMbTypes[0] == 0 && mBlock.pb8x8.subMbTypes[1] == 0 && mBlock.pb8x8.subMbTypes[2] == 0 && mBlock.pb8x8.subMbTypes[3] == 0;
        } else {
            this.readPrediction8x8B(mBlock, mbX, leftAvailable, topAvailable);
            noSubMBLessThen8x8 = H264Const.bSubMbTypes[mBlock.pb8x8.subMbTypes[0]] == 0 && H264Const.bSubMbTypes[mBlock.pb8x8.subMbTypes[1]] == 0 && H264Const.bSubMbTypes[mBlock.pb8x8.subMbTypes[2]] == 0 && H264Const.bSubMbTypes[mBlock.pb8x8.subMbTypes[3]] == 0;
        }
        mBlock._cbp = this.readCodedBlockPatternInter(leftAvailable, topAvailable, this.leftCBPLuma | (this.leftCBPChroma << 4), this.topCBPLuma[mbX] | (this.topCBPChroma[mbX] << 4), this.leftMBType, this.topMBType[mbX]);
        mBlock.transform8x8Used = false;
        if (this.transform8x8 && mBlock.cbpLuma() != 0 && noSubMBLessThen8x8) {
            mBlock.transform8x8Used = this.readTransform8x8Flag(leftAvailable, topAvailable, this.leftMBType, this.topMBType[mbX], this.tf8x8Left, this.tf8x8Top[mbX]);
        }
        if (mBlock.cbpLuma() > 0 || mBlock.cbpChroma() > 0) {
            mBlock.mbQPDelta = this.readMBQpDelta(mBlock.prevMbType);
        }
        this.readResidualLuma(mBlock, leftAvailable, topAvailable, mbX, mbY);
        this.readChromaResidual(mBlock, leftAvailable, topAvailable, mbX);
    };
    prototype.readPrediction8x8P = function(mBlock, mbX, leftAvailable, topAvailable) {
        for (var i = 0; i < 4; i++) {
            mBlock.pb8x8.subMbTypes[i] = this.readSubMBTypeP();
        }
        if (this.numRef[0] > 1 && mBlock.curMbType != MBType.P_8x8ref0) {
            mBlock.pb8x8.refIdx[0][0] = this.readRefIdx(leftAvailable, topAvailable, this.leftMBType, this.topMBType[mbX], H264Const.PartPred.L0, H264Const.PartPred.L0, H264Const.PartPred.L0, mbX, 0, 0, 2, 2, 0);
            mBlock.pb8x8.refIdx[0][1] = this.readRefIdx(true, topAvailable, MBType.P_8x8, this.topMBType[mbX], H264Const.PartPred.L0, H264Const.PartPred.L0, H264Const.PartPred.L0, mbX, 2, 0, 2, 2, 0);
            mBlock.pb8x8.refIdx[0][2] = this.readRefIdx(leftAvailable, true, this.leftMBType, MBType.P_8x8, H264Const.PartPred.L0, H264Const.PartPred.L0, H264Const.PartPred.L0, mbX, 0, 2, 2, 2, 0);
            mBlock.pb8x8.refIdx[0][3] = this.readRefIdx(true, true, MBType.P_8x8, MBType.P_8x8, H264Const.PartPred.L0, H264Const.PartPred.L0, H264Const.PartPred.L0, mbX, 2, 2, 2, 2, 0);
        }
        this.readSubMb8x8(mBlock, 0, mBlock.pb8x8.subMbTypes[0], topAvailable, leftAvailable, 0, 0, mbX, this.leftMBType, this.topMBType[mbX], MBType.P_8x8, H264Const.PartPred.L0, H264Const.PartPred.L0, H264Const.PartPred.L0, 0);
        this.readSubMb8x8(mBlock, 1, mBlock.pb8x8.subMbTypes[1], topAvailable, true, 2, 0, mbX, MBType.P_8x8, this.topMBType[mbX], MBType.P_8x8, H264Const.PartPred.L0, H264Const.PartPred.L0, H264Const.PartPred.L0, 0);
        this.readSubMb8x8(mBlock, 2, mBlock.pb8x8.subMbTypes[2], true, leftAvailable, 0, 2, mbX, this.leftMBType, MBType.P_8x8, MBType.P_8x8, H264Const.PartPred.L0, H264Const.PartPred.L0, H264Const.PartPred.L0, 0);
        this.readSubMb8x8(mBlock, 3, mBlock.pb8x8.subMbTypes[3], true, true, 2, 2, mbX, MBType.P_8x8, MBType.P_8x8, MBType.P_8x8, H264Const.PartPred.L0, H264Const.PartPred.L0, H264Const.PartPred.L0, 0);
        var blk8x8X = mbX << 1;
        this.predModeLeft[0] = this.predModeLeft[1] = this.predModeTop[blk8x8X] = this.predModeTop[blk8x8X + 1] = H264Const.PartPred.L0;
    };
    prototype.readPrediction8x8B = function(mBlock, mbX, leftAvailable, topAvailable) {
        var p = Array(4);
        for (var i = 0; i < 4; i++) {
            mBlock.pb8x8.subMbTypes[i] = this.readSubMBTypeB();
            p[i] = H264Const.bPartPredModes[mBlock.pb8x8.subMbTypes[i]];
        }
        for (var list = 0; list < 2; list++) {
            if (this.numRef[list] <= 1) 
                continue;
            if (H264Const.usesList(p[0], list)) 
                mBlock.pb8x8.refIdx[list][0] = this.readRefIdx(leftAvailable, topAvailable, this.leftMBType, this.topMBType[mbX], this.predModeLeft[0], this.predModeTop[mbX << 1], p[0], mbX, 0, 0, 2, 2, list);
            if (H264Const.usesList(p[1], list)) 
                mBlock.pb8x8.refIdx[list][1] = this.readRefIdx(true, topAvailable, MBType.B_8x8, this.topMBType[mbX], p[0], this.predModeTop[(mbX << 1) + 1], p[1], mbX, 2, 0, 2, 2, list);
            if (H264Const.usesList(p[2], list)) 
                mBlock.pb8x8.refIdx[list][2] = this.readRefIdx(leftAvailable, true, this.leftMBType, MBType.B_8x8, this.predModeLeft[1], p[0], p[2], mbX, 0, 2, 2, 2, list);
            if (H264Const.usesList(p[3], list)) 
                mBlock.pb8x8.refIdx[list][3] = this.readRefIdx(true, true, MBType.B_8x8, MBType.B_8x8, p[2], p[1], p[3], mbX, 2, 2, 2, 2, list);
        }
        MBlockDecoderUtils.debugPrint("Pred: " + p[0] + ", " + p[1] + ", " + p[2] + ", " + p[3]);
        var blk8x8X = mbX << 1;
        for (var list = 0; list < 2; list++) {
            if (H264Const.usesList(p[0], list)) {
                this.readSubMb8x8(mBlock, 0, H264Const.bSubMbTypes[mBlock.pb8x8.subMbTypes[0]], topAvailable, leftAvailable, 0, 0, mbX, this.leftMBType, this.topMBType[mbX], MBType.B_8x8, this.predModeLeft[0], this.predModeTop[blk8x8X], p[0], list);
            }
            if (H264Const.usesList(p[1], list)) {
                this.readSubMb8x8(mBlock, 1, H264Const.bSubMbTypes[mBlock.pb8x8.subMbTypes[1]], topAvailable, true, 2, 0, mbX, MBType.B_8x8, this.topMBType[mbX], MBType.B_8x8, p[0], this.predModeTop[blk8x8X + 1], p[1], list);
            }
            if (H264Const.usesList(p[2], list)) {
                this.readSubMb8x8(mBlock, 2, H264Const.bSubMbTypes[mBlock.pb8x8.subMbTypes[2]], true, leftAvailable, 0, 2, mbX, this.leftMBType, MBType.B_8x8, MBType.B_8x8, this.predModeLeft[1], p[0], p[2], list);
            }
            if (H264Const.usesList(p[3], list)) {
                this.readSubMb8x8(mBlock, 3, H264Const.bSubMbTypes[mBlock.pb8x8.subMbTypes[3]], true, true, 2, 2, mbX, MBType.B_8x8, MBType.B_8x8, MBType.B_8x8, p[2], p[1], p[3], list);
            }
        }
        this.predModeLeft[0] = p[1];
        this.predModeTop[blk8x8X] = p[2];
        this.predModeLeft[1] = this.predModeTop[blk8x8X + 1] = p[3];
    };
    prototype.readSubMb8x8 = function(mBlock, partNo, subMbType, tAvb, lAvb, blk8x8X, blk8x8Y, mbX, leftMBType, topMBType, curMBType, leftPred, topPred, partPred, list) {
        switch (subMbType) {
            case 3:
                this.readSub4x4(mBlock, partNo, tAvb, lAvb, blk8x8X, blk8x8Y, mbX, leftMBType, topMBType, curMBType, leftPred, topPred, partPred, list);
                break;
            case 2:
                this.readSub4x8(mBlock, partNo, tAvb, lAvb, blk8x8X, blk8x8Y, mbX, leftMBType, topMBType, curMBType, leftPred, topPred, partPred, list);
                break;
            case 1:
                this.readSub8x4(mBlock, partNo, tAvb, lAvb, blk8x8X, blk8x8Y, mbX, leftMBType, topMBType, curMBType, leftPred, topPred, partPred, list);
                break;
            case 0:
                this.readSub8x8(mBlock, partNo, tAvb, lAvb, blk8x8X, blk8x8Y, mbX, leftMBType, topMBType, leftPred, topPred, partPred, list);
        }
    };
    prototype.readSub8x8 = function(mBlock, partNo, tAvb, lAvb, blk8x8X, blk8x8Y, mbX, leftMBType, topMBType, leftPred, topPred, partPred, list) {
        mBlock.pb8x8.mvdX1[list][partNo] = this.readMVD(0, lAvb, tAvb, leftMBType, topMBType, leftPred, topPred, partPred, mbX, blk8x8X, blk8x8Y, 2, 2, list);
        mBlock.pb8x8.mvdY1[list][partNo] = this.readMVD(1, lAvb, tAvb, leftMBType, topMBType, leftPred, topPred, partPred, mbX, blk8x8X, blk8x8Y, 2, 2, list);
        MBlockDecoderUtils.debugPrint("mvd: (%d, %d)", mBlock.pb8x8.mvdX1[list][partNo], mBlock.pb8x8.mvdY1[list][partNo]);
    };
    prototype.readSub8x4 = function(mBlock, partNo, tAvb, lAvb, blk8x8X, blk8x8Y, mbX, leftMBType, topMBType, curMBType, leftPred, topPred, partPred, list) {
        mBlock.pb8x8.mvdX1[list][partNo] = this.readMVD(0, lAvb, tAvb, leftMBType, topMBType, leftPred, topPred, partPred, mbX, blk8x8X, blk8x8Y, 2, 1, list);
        mBlock.pb8x8.mvdY1[list][partNo] = this.readMVD(1, lAvb, tAvb, leftMBType, topMBType, leftPred, topPred, partPred, mbX, blk8x8X, blk8x8Y, 2, 1, list);
        mBlock.pb8x8.mvdX2[list][partNo] = this.readMVD(0, lAvb, true, leftMBType, curMBType, leftPred, partPred, partPred, mbX, blk8x8X, blk8x8Y + 1, 2, 1, list);
        mBlock.pb8x8.mvdY2[list][partNo] = this.readMVD(1, lAvb, true, leftMBType, curMBType, leftPred, partPred, partPred, mbX, blk8x8X, blk8x8Y + 1, 2, 1, list);
    };
    prototype.readSub4x8 = function(mBlock, partNo, tAvb, lAvb, blk8x8X, blk8x8Y, mbX, leftMBType, topMBType, curMBType, leftPred, topPred, partPred, list) {
        mBlock.pb8x8.mvdX1[list][partNo] = this.readMVD(0, lAvb, tAvb, leftMBType, topMBType, leftPred, topPred, partPred, mbX, blk8x8X, blk8x8Y, 1, 2, list);
        mBlock.pb8x8.mvdY1[list][partNo] = this.readMVD(1, lAvb, tAvb, leftMBType, topMBType, leftPred, topPred, partPred, mbX, blk8x8X, blk8x8Y, 1, 2, list);
        mBlock.pb8x8.mvdX2[list][partNo] = this.readMVD(0, true, tAvb, curMBType, topMBType, partPred, topPred, partPred, mbX, blk8x8X + 1, blk8x8Y, 1, 2, list);
        mBlock.pb8x8.mvdY2[list][partNo] = this.readMVD(1, true, tAvb, curMBType, topMBType, partPred, topPred, partPred, mbX, blk8x8X + 1, blk8x8Y, 1, 2, list);
    };
    prototype.readSub4x4 = function(mBlock, partNo, tAvb, lAvb, blk8x8X, blk8x8Y, mbX, leftMBType, topMBType, curMBType, leftPred, topPred, partPred, list) {
        mBlock.pb8x8.mvdX1[list][partNo] = this.readMVD(0, lAvb, tAvb, leftMBType, topMBType, leftPred, topPred, partPred, mbX, blk8x8X, blk8x8Y, 1, 1, list);
        mBlock.pb8x8.mvdY1[list][partNo] = this.readMVD(1, lAvb, tAvb, leftMBType, topMBType, leftPred, topPred, partPred, mbX, blk8x8X, blk8x8Y, 1, 1, list);
        mBlock.pb8x8.mvdX2[list][partNo] = this.readMVD(0, true, tAvb, curMBType, topMBType, partPred, topPred, partPred, mbX, blk8x8X + 1, blk8x8Y, 1, 1, list);
        mBlock.pb8x8.mvdY2[list][partNo] = this.readMVD(1, true, tAvb, curMBType, topMBType, partPred, topPred, partPred, mbX, blk8x8X + 1, blk8x8Y, 1, 1, list);
        mBlock.pb8x8.mvdX3[list][partNo] = this.readMVD(0, lAvb, true, leftMBType, curMBType, leftPred, partPred, partPred, mbX, blk8x8X, blk8x8Y + 1, 1, 1, list);
        mBlock.pb8x8.mvdY3[list][partNo] = this.readMVD(1, lAvb, true, leftMBType, curMBType, leftPred, partPred, partPred, mbX, blk8x8X, blk8x8Y + 1, 1, 1, list);
        mBlock.pb8x8.mvdX4[list][partNo] = this.readMVD(0, true, true, curMBType, curMBType, partPred, partPred, partPred, mbX, blk8x8X + 1, blk8x8Y + 1, 1, 1, list);
        mBlock.pb8x8.mvdY4[list][partNo] = this.readMVD(1, true, true, curMBType, curMBType, partPred, partPred, partPred, mbX, blk8x8X + 1, blk8x8Y + 1, 1, 1, list);
    };
    prototype.readIntraNxN = function(mBlock) {
        var mbX = this.mapper.getMbX(mBlock.mbIdx);
        var mbY = this.mapper.getMbY(mBlock.mbIdx);
        var leftAvailable = this.mapper.leftAvailable(mBlock.mbIdx);
        var topAvailable = this.mapper.topAvailable(mBlock.mbIdx);
        mBlock.transform8x8Used = false;
        if (this.transform8x8) {
            mBlock.transform8x8Used = this.readTransform8x8Flag(leftAvailable, topAvailable, this.leftMBType, this.topMBType[mbX], this.tf8x8Left, this.tf8x8Top[mbX]);
        }
        if (!mBlock.transform8x8Used) {
            for (var i = 0; i < 16; i++) {
                var blkX = H264Const.MB_BLK_OFF_LEFT[i];
                var blkY = H264Const.MB_BLK_OFF_TOP[i];
                mBlock.lumaModes[i] = this.readPredictionI4x4Block(leftAvailable, topAvailable, this.leftMBType, this.topMBType[mbX], blkX, blkY, mbX);
            }
        } else {
            for (var i = 0; i < 4; i++) {
                var blkX = (i & 1) << 1;
                var blkY = i & 2;
                mBlock.lumaModes[i] = this.readPredictionI4x4Block(leftAvailable, topAvailable, this.leftMBType, this.topMBType[mbX], blkX, blkY, mbX);
                this.i4x4PredLeft[blkY + 1] = this.i4x4PredLeft[blkY];
                this.i4x4PredTop[(mbX << 2) + blkX + 1] = this.i4x4PredTop[(mbX << 2) + blkX];
            }
        }
        mBlock.chromaPredictionMode = this.readChromaPredMode(mbX, leftAvailable, topAvailable);
        mBlock._cbp = this.readCodedBlockPatternIntra(leftAvailable, topAvailable, this.leftCBPLuma | (this.leftCBPChroma << 4), this.topCBPLuma[mbX] | (this.topCBPChroma[mbX] << 4), this.leftMBType, this.topMBType[mbX]);
        if (mBlock.cbpLuma() > 0 || mBlock.cbpChroma() > 0) {
            mBlock.mbQPDelta = this.readMBQpDelta(mBlock.prevMbType);
        }
        this.readResidualLuma(mBlock, leftAvailable, topAvailable, mbX, mbY);
        if (this.chromaFormat != ColorSpace.MONO) {
            this.readChromaResidual(mBlock, leftAvailable, topAvailable, mbX);
        }
    };
    prototype.readResidualLuma = function(mBlock, leftAvailable, topAvailable, mbX, mbY) {
        if (!mBlock.transform8x8Used) {
            this.readLuma(mBlock, leftAvailable, topAvailable, mbX, mbY);
        } else if (this.sh.pps.entropy_coding_mode_flag) {
            this.readLuma8x8CABAC(mBlock, mbX, mbY);
        } else {
            this.readLuma8x8CAVLC(mBlock, leftAvailable, topAvailable, mbX, mbY);
        }
    };
    prototype.readLuma = function(mBlock, leftAvailable, topAvailable, mbX, mbY) {
        for (var i = 0; i < 16; i++) {
            var blkOffLeft = H264Const.MB_BLK_OFF_LEFT[i];
            var blkOffTop = H264Const.MB_BLK_OFF_TOP[i];
            var blkX = (mbX << 2) + blkOffLeft;
            var blkY = (mbY << 2) + blkOffTop;
            if ((mBlock.cbpLuma() & (1 << (i >> 2))) == 0) {
                if (!this.sh.pps.entropy_coding_mode_flag) 
                    this.setZeroCoeff(0, blkX, blkOffTop);
                continue;
            }
            mBlock.nCoeff[i] = this.readResidualAC(leftAvailable, topAvailable, mbX, mBlock.curMbType, mBlock.cbpLuma(), blkOffLeft, blkOffTop, blkX, blkY, mBlock.ac[0][i]);
        }
        this.savePrevCBP(mBlock._cbp);
    };
    prototype.readLuma8x8CABAC = function(mBlock, mbX, mbY) {
        for (var i = 0; i < 4; i++) {
            var blkOffLeft = (i & 1) << 1;
            var blkOffTop = i & 2;
            var blkX = (mbX << 2) + blkOffLeft;
            var blkY = (mbY << 2) + blkOffTop;
            if ((mBlock.cbpLuma() & (1 << i)) == 0) {
                continue;
            }
            var nCoeff = this.readLumaAC8x8(blkX, blkY, mBlock.ac[0][i]);
            var blk4x4Offset = i << 2;
            mBlock.nCoeff[blk4x4Offset] = mBlock.nCoeff[blk4x4Offset + 1] = mBlock.nCoeff[blk4x4Offset + 2] = mBlock.nCoeff[blk4x4Offset + 3] = nCoeff;
        }
        this.savePrevCBP(mBlock._cbp);
    };
    prototype.readLuma8x8CAVLC = function(mBlock, leftAvailable, topAvailable, mbX, mbY) {
        for (var i = 0; i < 4; i++) {
            var blk8x8OffLeft = (i & 1) << 1;
            var blk8x8OffTop = i & 2;
            var blkX = (mbX << 2) + blk8x8OffLeft;
            var blkY = (mbY << 2) + blk8x8OffTop;
            if ((mBlock.cbpLuma() & (1 << i)) == 0) {
                this.setZeroCoeff(0, blkX, blk8x8OffTop);
                this.setZeroCoeff(0, blkX + 1, blk8x8OffTop);
                this.setZeroCoeff(0, blkX, blk8x8OffTop + 1);
                this.setZeroCoeff(0, blkX + 1, blk8x8OffTop + 1);
                continue;
            }
            var coeffs = 0;
            for (var j = 0; j < 4; j++) {
                var ac16 = new Int32Array(16);
                var blkOffLeft = blk8x8OffLeft + (j & 1);
                var blkOffTop = blk8x8OffTop + (j >> 1);
                coeffs += this.readLumaAC(leftAvailable, topAvailable, mbX, mBlock.curMbType, blkX, j, ac16, blkOffLeft, blkOffTop);
                for (var k = 0; k < 16; k++) 
                    mBlock.ac[0][i][CoeffTransformer.zigzag8x8[(k << 2) + j]] = ac16[k];
            }
            var blk4x4Offset = i << 2;
            mBlock.nCoeff[blk4x4Offset] = mBlock.nCoeff[blk4x4Offset + 1] = mBlock.nCoeff[blk4x4Offset + 2] = mBlock.nCoeff[blk4x4Offset + 3] = coeffs;
        }
    };
    prototype.readChromaResidual = function(mBlock, leftAvailable, topAvailable, mbX) {
        if (mBlock.cbpChroma() != 0) {
            if ((mBlock.cbpChroma() & 3) > 0) {
                this.readChromaDC(mbX, leftAvailable, topAvailable, mBlock.dc1, 1, mBlock.curMbType);
                this.readChromaDC(mbX, leftAvailable, topAvailable, mBlock.dc2, 2, mBlock.curMbType);
            }
            this._readChromaAC(leftAvailable, topAvailable, mbX, mBlock.dc1, 1, mBlock.curMbType, (mBlock.cbpChroma() & 2) > 0, mBlock.ac[1]);
            this._readChromaAC(leftAvailable, topAvailable, mbX, mBlock.dc2, 2, mBlock.curMbType, (mBlock.cbpChroma() & 2) > 0, mBlock.ac[2]);
        } else if (!this.sh.pps.entropy_coding_mode_flag) {
            this.setZeroCoeff(1, mbX << 1, 0);
            this.setZeroCoeff(1, (mbX << 1) + 1, 1);
            this.setZeroCoeff(2, mbX << 1, 0);
            this.setZeroCoeff(2, (mbX << 1) + 1, 1);
        }
    };
    prototype._readChromaAC = function(leftAvailable, topAvailable, mbX, dc, comp, curMbType, codedAC, residualOut) {
        for (var i = 0; i < dc.length; i++) {
            var ac = residualOut[i];
            var blkOffLeft = H264Const.MB_BLK_OFF_LEFT[i];
            var blkOffTop = H264Const.MB_BLK_OFF_TOP[i];
            var blkX = (mbX << 1) + blkOffLeft;
            if (codedAC) {
                this.readChromaAC(leftAvailable, topAvailable, mbX, comp, curMbType, ac, blkOffLeft, blkOffTop, blkX);
            } else {
                if (!this.sh.pps.entropy_coding_mode_flag) 
                    this.setZeroCoeff(comp, blkX, blkOffTop);
            }
        }
    };
    prototype.readIPCM = function(mBlock) {
        this.reader.align();
        for (var i = 0; i < 256; i++) {
            mBlock.ipcm.samplesLuma[i] = this.reader.readNBit(8);
        }
        var MbWidthC = 16 >> this.chromaFormat.compWidth[1];
        var MbHeightC = 16 >> this.chromaFormat.compHeight[1];
        for (var i = 0; i < 2 * MbWidthC * MbHeightC; i++) {
            mBlock.ipcm.samplesChroma[i] = this.reader.readNBit(8);
        }
    };
    prototype.readMBlock = function(mBlock, sliceType) {
        if (sliceType == SliceType.I) {
            this.readMBlockI(mBlock);
        } else if (sliceType == SliceType.P) {
            this.readMBlockP(mBlock);
        } else {
            this.readMBlockB(mBlock);
        }
        var mbX = this.mapper.getMbX(mBlock.mbIdx);
        this.topCBPLuma[mbX] = this.leftCBPLuma = mBlock.cbpLuma();
        this.topCBPChroma[mbX] = this.leftCBPChroma = mBlock.cbpChroma();
        this.tf8x8Left = this.tf8x8Top[mbX] = mBlock.transform8x8Used;
    };
    prototype.readMBlockI = function(mBlock) {
        mBlock.mbType = this.decodeMBTypeI(mBlock.mbIdx, this.mapper.leftAvailable(mBlock.mbIdx), this.mapper.topAvailable(mBlock.mbIdx), this.leftMBType, this.topMBType[this.mapper.getMbX(mBlock.mbIdx)]);
        this.readMBlockIInt(mBlock, mBlock.mbType);
    };
    prototype.readMBlockIInt = function(mBlock, mbType) {
        if (mbType == 0) {
            mBlock.curMbType = MBType.I_NxN;
            this.readIntraNxN(mBlock);
        } else if (mbType >= 1 && mbType <= 24) {
            mBlock.curMbType = MBType.I_16x16;
            this.readIntra16x16(mbType - 1, mBlock);
        } else {
            jcodec.Logger.warn("IPCM macroblock found. Not tested, may cause unpredictable behavior.");
            mBlock.curMbType = MBType.I_PCM;
            this.readIPCM(mBlock);
        }
    };
    prototype.readMBlockP = function(mBlock) {
        mBlock.mbType = this.readMBTypeP();
        switch (mBlock.mbType) {
            case 0:
                mBlock.curMbType = MBType.P_16x16;
                this.readInter16x16(H264Const.PartPred.L0, mBlock);
                break;
            case 1:
                mBlock.curMbType = MBType.P_16x8;
                this.readInter16x8(H264Const.PartPred.L0, H264Const.PartPred.L0, mBlock);
                break;
            case 2:
                mBlock.curMbType = MBType.P_8x16;
                this.readIntra8x16(H264Const.PartPred.L0, H264Const.PartPred.L0, mBlock);
                break;
            case 3:
                mBlock.curMbType = MBType.P_8x8;
                this.readMBlock8x8(mBlock);
                break;
            case 4:
                mBlock.curMbType = MBType.P_8x8ref0;
                this.readMBlock8x8(mBlock);
                break;
            default:
                this.readMBlockIInt(mBlock, mBlock.mbType - 5);
        }
    };
    prototype.readMBlockB = function(mBlock) {
        mBlock.mbType = this.readMBTypeB(mBlock.mbIdx, this.mapper.leftAvailable(mBlock.mbIdx), this.mapper.topAvailable(mBlock.mbIdx), this.leftMBType, this.topMBType[this.mapper.getMbX(mBlock.mbIdx)]);
        if (mBlock.mbType >= 23) {
            this.readMBlockIInt(mBlock, mBlock.mbType - 23);
        } else {
            mBlock.curMbType = H264Const.bMbTypes[mBlock.mbType];
            if (mBlock.mbType == 0) {
                this.readMBlockBDirect(mBlock);
            } else if (mBlock.mbType <= 3) {
                this.readInter16x16(H264Const.bPredModes[mBlock.mbType][0], mBlock);
            } else if (mBlock.mbType == 22) {
                this.readMBlock8x8(mBlock);
            } else if ((mBlock.mbType & 1) == 0) {
                this.readInter16x8(H264Const.bPredModes[mBlock.mbType][0], H264Const.bPredModes[mBlock.mbType][1], mBlock);
            } else {
                this.readIntra8x16(H264Const.bPredModes[mBlock.mbType][0], H264Const.bPredModes[mBlock.mbType][1], mBlock);
            }
        }
    };
    prototype.getSliceHeader = function() {
        return this.sh;
    };
    prototype.getNALUnit = function() {
        return this.nalUnit;
    };
}, {activePps: "PictureParameterSet", cabac: "CABAC", mDecoder: "MDecoder", cavlc: "Array", reader: "BitReader", mapper: "Mapper", sh: "SliceHeader", nalUnit: "NALUnit", prevMBType: "MBType", topMBType: "Array", leftMBType: "MBType", topCBPLuma: "Int32Array", topCBPChroma: "Int32Array", chromaFormat: "ColorSpace", numRef: "Int32Array", tf8x8Top: "Int8Array", i4x4PredTop: "Int32Array", i4x4PredLeft: "Int32Array", predModeLeft: "Array", predModeTop: "Array"}, {});
/**
 *  A decoder for Intra PCM macroblocks
 *  
 *  @author The JCodec project
 */
var MBlockDecoderIPCM = function(mapper, decoderState) {
    this.mapper = mapper;
    this.s = decoderState;
};
MBlockDecoderIPCM = stjs.extend(MBlockDecoderIPCM, null, [], function(constructor, prototype) {
    prototype.mapper = null;
    prototype.s = null;
    prototype.decode = function(mBlock, mb) {
        var mbX = this.mapper.getMbX(mBlock.mbIdx);
        MBlockDecoderUtils.collectPredictors(this.s, mb, mbX);
        MBlockDecoderUtils.saveVectIntra(this.s, this.mapper.getMbX(mBlock.mbIdx));
    };
}, {mapper: "Mapper", s: "DecoderState"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  An MP4 file struncture (box).
 *  
 *  @author The JCodec project
 *  
 */
var Box = function(header) {
    this.header = header;
};
Box = stjs.extend(Box, null, [], function(constructor, prototype) {
    constructor.GET_MODEL_FIELDS = "getModelFields";
    prototype.header = null;
    constructor.MAX_BOX_SIZE = 128 * 1024 * 1024;
    prototype.getHeader = function() {
        return this.header;
    };
    prototype.parse = function(buf) {};
    prototype.write = function(buf) {
        var dup = buf.duplicate();
        NIOUtils.skip(buf, 8);
        this.doWrite(buf);
        this.header.setBodySize(buf.position() - dup.position() - 8);
        Assert.assertEquals(this.header.headerSize(), 8);
        this.header.write(dup);
    };
    prototype.doWrite = function(out) {};
    prototype.getFourcc = function() {
        return this.header.getFourcc();
    };
    prototype.toString = function() {
        var sb = new StringBuilder();
        this.dump(sb);
        return sb.toString();
    };
    prototype.dump = function(sb) {
        sb.append("{\"tag\":\"" + this.header.getFourcc() + "\",");
        var fields = new ArrayList(0);
        this.collectModel(this.getClass(), fields);
        ToJSON.fieldsToJSON(this, sb, fields.toArray(Array(0)));
        sb.append("}");
    };
    prototype.collectModel = function(claz, model) {
        if (Box == claz || !Box.isAssignableFrom(claz)) 
            return;
        this.collectModel(claz.getSuperclass(), model);
        try {
            Platform.invokeMethod(this, Box.GET_MODEL_FIELDS, [model]);
        }catch (e) {
            this.checkWrongSignature(claz);
            model.addAll(ToJSON.allFields(claz));
        }
    };
    prototype.checkWrongSignature = function(claz) {
        var declaredMethods = Platform.getDeclaredMethods(claz);
        for (var i = 0; i < declaredMethods.length; i++) {
            var method = declaredMethods[i];
            if (method.getName().equals(Box.GET_MODEL_FIELDS)) {
                jcodec.Logger.warn("Class " + claz.getCanonicalName() + " contains 'getModelFields' of wrong signature.\nDid you mean to define 'protected void " + Box.GET_MODEL_FIELDS + "(List<String> model) ?");
                break;
            }
        }
    };
    constructor.path = function(path) {
        return StringUtils.splitC(path, '.');
    };
    constructor.createLeafBox = function(atom, data) {
        var leaf = new Box.LeafBox(atom);
        leaf.data = data;
        return leaf;
    };
    constructor.parseBox = function(input, childAtom, factory) {
        var box = factory.newBox(childAtom);
        if (childAtom.getBodySize() < Box.MAX_BOX_SIZE) {
            box.parse(input);
            return box;
        } else {
            return new Box.LeafBox(Header.createHeader("free", 8));
        }
    };
    constructor.asBox = function(class1, box) {
        console.log("asBox", box.header);
        try {
            var res = Platform.newInstance(class1, [box.getHeader()]);
            var buffer = ByteBuffer.allocate(((box.getHeader().getBodySize()) | 0));
            box.doWrite(buffer);
            buffer.flip();
            res.parse(buffer);
            return res;
        }catch (e) {
             throw new RuntimeException(e);
        }
    };
    constructor.LeafBox = function(atom) {
        Box.call(this, atom);
    };
    constructor.LeafBox = stjs.extend(constructor.LeafBox, Box, [], function(constructor, prototype) {
        prototype.data = null;
        prototype.parse = function(input) {
            this.data = NIOUtils.read(input, ((this.header.getBodySize()) | 0));
        };
        prototype.getData = function() {
            return this.data.duplicate();
        };
        prototype.doWrite = function(out) {
            NIOUtils.write(out, this.data);
        };
    }, {data: "ByteBuffer", header: "Header"}, {});
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Downmixes a set of input audio tracks ( possibly with multiple channels ) to
 *  one stereo track.
 *  
 *  Produces frames of exactly equal size regarless of underlying tracks PCM
 *  chunk sizes
 *  
 *  @author The JCodec project
 *  
 */
var StereoDownmixTrack = function(_arguments) {
    this.rate = -1;
    this.sources = Array(arguments.length);
    this.sampleEntries = Array(this.sources.length);
    this.solo = Array(arguments.length);
    for (var i = 0; i < arguments.length; i++) {
        var se = arguments[i].getCodecMeta();
        if (!(stjs.isInstanceOf(se.constructor, AudioCodecMeta))) 
             throw new IllegalArgumentException("Non audio track");
        var ase = se;
        if (!ase.isPCM()) 
             throw new IllegalArgumentException("Non PCM audio track.");
        var format = ase.getFormat();
        if (this.rate != -1 && this.rate != format.getFrameRate()) 
             throw new IllegalArgumentException("Can not downmix tracks of different rate.");
        this.rate = stjs.trunc(format.getFrameRate());
        this.sampleEntries[i] = ase;
        this.sources[i] = new PCMFlatternTrack(arguments[i], StereoDownmixTrack.FRAMES_IN_OUT_PACKET);
        this.solo[i] = new Int8Array(format.getChannels());
    }
    this.downmix = new DownmixHelper(this.sampleEntries, StereoDownmixTrack.FRAMES_IN_OUT_PACKET, null);
};
StereoDownmixTrack = stjs.extend(StereoDownmixTrack, null, [VirtualTrack], function(constructor, prototype) {
    constructor.FRAMES_IN_OUT_PACKET = 1024 * 20;
    prototype.sources = null;
    prototype.sampleEntries = null;
    prototype.rate = 0;
    prototype.frameNo = 0;
    prototype.solo = null;
    prototype.downmix = null;
    prototype.soloTrack = function(track, s) {
        for (var ch = 0; ch < this.solo[track].length; ch++) {
            this.solo[track][ch] = s;
        }
        this.downmix = new DownmixHelper(this.sampleEntries, StereoDownmixTrack.FRAMES_IN_OUT_PACKET, this.solo);
    };
    prototype.soloChannel = function(track, channel, s) {
        this.solo[track][channel] = s;
        this.downmix = new DownmixHelper(this.sampleEntries, StereoDownmixTrack.FRAMES_IN_OUT_PACKET, this.solo);
    };
    prototype.isChannelMute = function(track, channel) {
        return this.solo[track][channel];
    };
    prototype.bulkGetSolo = function() {
        return this.solo;
    };
    prototype.soloAll = function() {
        for (var i = 0; i < this.solo.length; i++) 
            for (var j = 0; j < this.solo[i].length; j++) 
                this.solo[i][j] = true;
    };
    prototype.muteAll = function() {
        for (var i = 0; i < this.solo.length; i++) 
            for (var j = 0; j < this.solo[i].length; j++) 
                this.solo[i][j] = false;
    };
    prototype.bulkSetSolo = function(solo) {
        this.solo = solo;
        this.downmix = new DownmixHelper(this.sampleEntries, StereoDownmixTrack.FRAMES_IN_OUT_PACKET, solo);
    };
    prototype.nextPacket = function() {
        var packets = Array(this.sources.length);
        var allNull = true;
        for (var i = 0; i < packets.length; i++) {
            packets[i] = this.sources[i].nextPacket();
            allNull &= packets[i] == null;
        }
        if (allNull) 
            return null;
        var ret = new StereoDownmixTrack.DownmixVirtualPacket(this, packets, this.frameNo);
        this.frameNo += StereoDownmixTrack.FRAMES_IN_OUT_PACKET;
        return ret;
    };
    prototype.getCodecMeta = function() {
        return AudioCodecMeta.createAudioCodecMeta("sowt", 2, 2, this.rate, ByteOrder.LITTLE_ENDIAN, true, [Label.Left, Label.Right], null);
    };
    prototype.close = function() {
        for (var virtualTrack in this.sources) {
            virtualTrack.close();
        }
    };
    constructor.DownmixVirtualPacket = function(track, packets, pktNo) {
        this.track = track;
        this.packets = packets;
        this.frameNo = pktNo;
    };
    constructor.DownmixVirtualPacket = stjs.extend(constructor.DownmixVirtualPacket, null, [VirtualPacket], function(constructor, prototype) {
        prototype.packets = null;
        prototype.frameNo = 0;
        prototype.track = null;
        prototype.getData = function() {
            var data = Array(this.packets.length);
            for (var i = 0; i < data.length; i++) 
                data[i] = this.packets[i] == null ? null : this.packets[i].getData();
            var out = ByteBuffer.allocate(StereoDownmixTrack.FRAMES_IN_OUT_PACKET << 2);
            this.track.downmix.downmix(data, out);
            return out;
        };
        prototype.getDataLen = function() {
            return StereoDownmixTrack.FRAMES_IN_OUT_PACKET << 2;
        };
        prototype.getPts = function() {
            return this.frameNo / this.track.rate;
        };
        prototype.getDuration = function() {
            return StereoDownmixTrack.FRAMES_IN_OUT_PACKET / this.track.rate;
        };
        prototype.isKeyframe = function() {
            return true;
        };
        prototype.getFrameNo = function() {
            return this.frameNo;
        };
    }, {packets: "Array", track: "StereoDownmixTrack", byPts: {name: "Comparator", arguments: ["Object"]}}, {});
    prototype.getEdits = function() {
        return null;
    };
    prototype.getPreferredTimescale = function() {
        return this.rate;
    };
}, {sources: "Array", sampleEntries: "Array", solo: "Array", downmix: "DownmixHelper"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Demuxer frontend for FLV, track based wrapper
 *  
 *  @author The JCodec project
 *  
 */
var FLVTrackDemuxer = function(_in) {
    this.packets = new LinkedList();
    this._in = _in;
    _in.setPosition(0);
    this.demuxer = new FLVReader(_in);
    this.video = new FLVTrackDemuxer.FLVDemuxerTrack(this, FLVTag.Type.VIDEO);
    this.audio = new FLVTrackDemuxer.FLVDemuxerTrack(this, FLVTag.Type.AUDIO);
};
FLVTrackDemuxer = stjs.extend(FLVTrackDemuxer, null, [], function(constructor, prototype) {
    constructor.MAX_CRAWL_DISTANCE_SEC = 10;
    prototype.demuxer = null;
    prototype.video = null;
    prototype.audio = null;
    prototype.packets = null;
    prototype._in = null;
    constructor.FLVDemuxerTrack = function(demuxer, type) {
        this.framePositions = LongArrayList.createLongArrayList();
        this.demuxer = demuxer;
        this.type = type;
        var frame = demuxer.nextFrameI(type, false);
        this.codec = frame.getTagHeader().getCodec();
    };
    constructor.FLVDemuxerTrack = stjs.extend(constructor.FLVDemuxerTrack, null, [SeekableDemuxerTrack], function(constructor, prototype) {
        prototype.type = null;
        prototype.curFrame = 0;
        prototype.codec = null;
        prototype.framePositions = null;
        prototype.codecPrivate = null;
        prototype.demuxer = null;
        prototype.nextFrame = function() {
            var frame = this.demuxer.nextFrameI(this.type, true);
            this.framePositions.add(frame.getPosition());
            return this.toPacket(frame);
        };
        prototype.prevFrame = function() {
            var frame = this.demuxer.prevFrameI(this.type, true);
            return this.toPacket(frame);
        };
        prototype.pickFrame = function() {
            var frame = this.demuxer.nextFrameI(this.type, false);
            return this.toPacket(frame);
        };
        prototype.toPacket = function(frame) {
            return null;
        };
        prototype.getMeta = function() {
            var t = this.type == FLVTag.Type.VIDEO ? DemuxerTrackMeta.Type.VIDEO : DemuxerTrackMeta.Type.AUDIO;
            return new DemuxerTrackMeta(t, this.codec, null, 0, 0, new Size(0, 0), this.codecPrivate);
        };
        prototype.gotoFrame = function(i) {
            if (i >= this.framePositions.size()) 
                return false;
            this.demuxer.resetToPosition(this.framePositions.get(((i) | 0)));
            return true;
        };
        prototype.gotoSyncFrame = function(i) {
             throw new RuntimeException();
        };
        prototype.getCurFrame = function() {
            return this.curFrame;
        };
        prototype.seek = function(second) {
            this.demuxer.seekI(second);
        };
    }, {type: {name: "Enum", arguments: ["FLVTag.Type"]}, codec: {name: "Enum", arguments: ["Codec"]}, framePositions: "LongArrayList", codecPrivate: "Int8Array", demuxer: "FLVTrackDemuxer"}, {});
    prototype.resetToPosition = function(position) {
        this._in.setPosition(position);
        this.demuxer.reset();
        this.packets.clear();
    };
    prototype.seekI = function(second) {
        this.packets.clear();
        var base;
         while ((base = this.demuxer.readNextPacket()) != null && base.getPtsD() == 0)
            ;
        this._in.setPosition(base.getPosition() + 1048576);
        this.demuxer.reposition();
        var off = this.demuxer.readNextPacket();
        var byteRate = stjs.trunc(((off.getPosition() - base.getPosition()) / (off.getPtsD() - base.getPtsD())));
        var offset = base.getPosition() + stjs.trunc(((second - base.getPtsD()) * byteRate));
        this._in.setPosition(offset);
        this.demuxer.reposition();
        for (var i = 0; i < 5; ++i) {
            var pkt = this.demuxer.readNextPacket();
            var distance = second - pkt.getPtsD();
            if (distance > 0 && distance < FLVTrackDemuxer.MAX_CRAWL_DISTANCE_SEC) {
                System.out.println("Crawling forward: " + distance);
                var testPkt;
                 while ((testPkt = this.demuxer.readNextPacket()) != null && testPkt.getPtsD() < second)
                    ;
                if (testPkt != null) 
                    this.packets.add(pkt);
                return;
            } else if (distance < 0 && distance > -FLVTrackDemuxer.MAX_CRAWL_DISTANCE_SEC) {
                System.out.println("Overshoot by: " + (-distance));
                this._in.setPosition(pkt.getPosition() + stjs.trunc(((distance - 1) * byteRate)));
                this.demuxer.reposition();
            }
        }
    };
    prototype.nextFrameI = function(type, remove) {
        for (var it = this.packets.iterator(); it.hasNext(); ) {
            var pkt = it.next();
            if (pkt.getType() == type) {
                if (remove) 
                    it.remove();
                return pkt;
            }
        }
        var pkt;
         while ((pkt = this.demuxer.readNextPacket()) != null && pkt.getType() != type)
            this.packets.add(pkt);
        if (!remove) 
            this.packets.add(pkt);
        return pkt;
    };
    prototype.prevFrameI = function(type, remove) {
        for (var it = this.packets.listIterator(); it.hasPrevious(); ) {
            var pkt = it.previous();
            if (pkt.getType() == type) {
                if (remove) 
                    it.remove();
                return pkt;
            }
        }
        var pkt;
         while ((pkt = this.demuxer.readPrevPacket()) != null && pkt.getType() != type)
            this.packets.add(0, pkt);
        if (!remove) 
            this.packets.add(0, pkt);
        return pkt;
    };
    prototype.getTracks = function() {
        return [this.video, this.audio];
    };
    prototype.getVideoTrack = function() {
        return this.video;
    };
    prototype.getAudioTrack = function() {
        return this.video;
    };
}, {demuxer: "FLVReader", video: "FLVTrackDemuxer.FLVDemuxerTrack", audio: "FLVTrackDemuxer.FLVDemuxerTrack", packets: {name: "LinkedList", arguments: ["FLVTag"]}, _in: "SeekableByteChannel"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license. 
 * 
 *  @author in-somnia
 */
var CCE = function(frameLength) {
    Element.call(this);
    this.ics = new ICStream(frameLength);
    this.channelPair = new Int8Array(8);
    this.idSelect = new Int32Array(8);
    this.chSelect = new Int32Array(8);
    this.gain = Array.apply(null, Array(16)).map(function() {
        return new Float32Array(120);
    });
};
CCE = stjs.extend(CCE, Element, [SyntaxConstants], function(constructor, prototype) {
    constructor.BEFORE_TNS = 0;
    constructor.AFTER_TNS = 1;
    constructor.AFTER_IMDCT = 2;
    constructor.CCE_SCALE = new Float32Array([1.0905077, 1.1892071, 1.4142135, 2.0]);
    prototype.ics = null;
    prototype.iqData = null;
    prototype.couplingPoint = 0;
    prototype.coupledCount = 0;
    prototype.channelPair = null;
    prototype.idSelect = null;
    prototype.chSelect = null;
    prototype.gain = null;
    prototype.getCouplingPoint = function() {
        return this.couplingPoint;
    };
    prototype.getCoupledCount = function() {
        return this.coupledCount;
    };
    prototype.isChannelPair = function(index) {
        return this.channelPair[index];
    };
    prototype.getIDSelect = function(index) {
        return this.idSelect[index];
    };
    prototype.getCHSelect = function(index) {
        return this.chSelect[index];
    };
    prototype.decode = function(_in, conf) {
        this.couplingPoint = 2 * _in.readBit();
        this.coupledCount = _in.readBits(3);
        var gainCount = 0;
        var i;
        for (i = 0; i <= this.coupledCount; i++) {
            gainCount++;
            this.channelPair[i] = _in.readBool();
            this.idSelect[i] = _in.readBits(4);
            if (this.channelPair[i]) {
                this.chSelect[i] = _in.readBits(2);
                if (this.chSelect[i] == 3) 
                    gainCount++;
            } else 
                this.chSelect[i] = 2;
        }
        this.couplingPoint += _in.readBit();
        this.couplingPoint |= (this.couplingPoint >> 1);
        var sign = _in.readBool();
        var scale = CCE.CCE_SCALE[_in.readBits(2)];
        this.ics.decode(_in, false, conf);
        var info = this.ics.getInfo();
        var windowGroupCount = info.getWindowGroupCount();
        var maxSFB = info.getMaxSFB();
        var sfbCB = [new Int32Array()];
        for (i = 0; i < gainCount; i++) {
            var idx = 0;
            var cge = 1;
            var xg = 0;
            var gainCache = 1.0;
            if (i > 0) {
                cge = this.couplingPoint == 2 ? 1 : _in.readBit();
                xg = cge == 0 ? 0 : Huffman.decodeScaleFactor(_in) - 60;
                gainCache = Math.pow(scale, -xg);
            }
            if (this.couplingPoint == 2) 
                this.gain[i][0] = gainCache;
             else {
                var sfb;
                for (var g = 0; g < windowGroupCount; g++) {
                    for (sfb = 0; sfb < maxSFB; sfb++ , idx++) {
                        if (sfbCB[g][sfb] != HCB.ZERO_HCB) {
                            if (cge == 0) {
                                var t = Huffman.decodeScaleFactor(_in) - 60;
                                if (t != 0) {
                                    var s = 1;
                                    t = xg += t;
                                    if (!sign) {
                                        s -= 2 * (t & 1);
                                        t >>= 1;
                                    }
                                    gainCache = (Math.pow(scale, -t) * s);
                                }
                            }
                            this.gain[i][idx] = gainCache;
                        }
                    }
                }
            }
        }
    };
    prototype.process = function() {
        this.iqData = this.ics.getInvQuantData();
    };
    prototype.applyIndependentCoupling = function(index, data) {
        var g = this.gain[index][0];
        for (var i = 0; i < data.length; i++) {
            data[i] += g * this.iqData[i];
        }
    };
    prototype.applyDependentCoupling = function(index, data) {
        var info = this.ics.getInfo();
        var swbOffsets = info.getSWBOffsets();
        var windowGroupCount = info.getWindowGroupCount();
        var maxSFB = info.getMaxSFB();
        var sfbCB = [new Int32Array()];
        var srcOff = 0;
        var dstOff = 0;
        var len, sfb, group, k, idx = 0;
        var x;
        for (var g = 0; g < windowGroupCount; g++) {
            len = info.getWindowGroupLength(g);
            for (sfb = 0; sfb < maxSFB; sfb++ , idx++) {
                if (sfbCB[g][sfb] != HCB.ZERO_HCB) {
                    x = this.gain[index][idx];
                    for (group = 0; group < len; group++) {
                        for (k = swbOffsets[sfb]; k < swbOffsets[sfb + 1]; k++) {
                            data[dstOff + group * 128 + k] += x * this.iqData[srcOff + group * 128 + k];
                        }
                    }
                }
            }
            dstOff += len * 128;
            srcOff += len * 128;
        }
    };
}, {CCE_SCALE: "Float32Array", ics: "ICStream", iqData: "Float32Array", channelPair: "Int8Array", idSelect: "Int32Array", chSelect: "Int32Array", gain: "Array", sbr: "SBR", LOGGER: "Logger"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  @author in-somnia
 */
var SCE_LFE = function(frameLength) {
    Element.call(this);
    this.ics = new ICStream(frameLength);
};
SCE_LFE = stjs.extend(SCE_LFE, Element, [], function(constructor, prototype) {
    prototype.ics = null;
    prototype.decode = function(_in, conf) {
        this.readElementInstanceTag(_in);
        this.ics.decode(_in, false, conf);
    };
    prototype.getICStream = function() {
        return this.ics;
    };
}, {ics: "ICStream", sbr: "SBR", LOGGER: "Logger"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license. 
 * 
 *  @author in-somnia
 */
var CPE = function(frameLength) {
    Element.call(this);
    this.msUsed = new Int8Array(SyntaxConstants.MAX_MS_MASK);
    this.icsL = new ICStream(frameLength);
    this.icsR = new ICStream(frameLength);
};
CPE = stjs.extend(CPE, Element, [SyntaxConstants], function(constructor, prototype) {
    prototype.msMask = null;
    prototype.msUsed = null;
    prototype.commonWindow = false;
    prototype.icsL = null;
    prototype.icsR = null;
    prototype.decode = function(_in, conf) {
        var profile = conf.getProfile();
        var sf = conf.getSampleFrequency();
        if (sf.equals(SampleFrequency.SAMPLE_FREQUENCY_NONE)) 
             throw new AACException("invalid sample frequency");
        this.readElementInstanceTag(_in);
        this.commonWindow = _in.readBool();
        var info = this.icsL.getInfo();
        if (this.commonWindow) {
            info.decode(_in, conf, this.commonWindow);
            this.icsR.getInfo().setData(info);
            this.msMask = CPE.msMaskFromInt(_in.readBits(2));
            if (this.msMask.equals(MSMask.TYPE_USED)) {
                var maxSFB = info.getMaxSFB();
                var windowGroupCount = info.getWindowGroupCount();
                for (var idx = 0; idx < windowGroupCount * maxSFB; idx++) {
                    this.msUsed[idx] = _in.readBool();
                }
            } else if (this.msMask.equals(MSMask.TYPE_ALL_1)) 
                Arrays.fill(this.msUsed, true);
             else if (this.msMask.equals(MSMask.TYPE_ALL_0)) 
                Arrays.fill(this.msUsed, false);
             else 
                 throw new AACException("reserved MS mask type used");
        } else {
            this.msMask = MSMask.TYPE_ALL_0;
            Arrays.fill(this.msUsed, false);
        }
        if (profile.isErrorResilientProfile() && (info.isLTPrediction1Present())) {
            if (info.ltpData2Present = _in.readBool()) 
                info.getLTPrediction2().decode(_in, info, profile);
        }
        this.icsL.decode(_in, this.commonWindow, conf);
        this.icsR.decode(_in, this.commonWindow, conf);
    };
    prototype.getLeftChannel = function() {
        return this.icsL;
    };
    prototype.getRightChannel = function() {
        return this.icsR;
    };
    prototype.getMSMask = function() {
        return this.msMask;
    };
    prototype.isMSUsed = function(off) {
        return this.msUsed[off];
    };
    prototype.isMSMaskPresent = function() {
        return !this.msMask.equals(MSMask.TYPE_ALL_0);
    };
    prototype.isCommonWindow = function() {
        return this.commonWindow;
    };
    constructor.msMaskFromInt = function(i) {
        var values = MSMask.values();
        if (values.length >= i) {
             throw new AACException("unknown MS mask type");
        }
        return values[i];
    };
}, {msMask: {name: "Enum", arguments: ["MSMask"]}, msUsed: "Int8Array", icsL: "ICStream", icsR: "ICStream", sbr: "SBR", LOGGER: "Logger"}, {});
var MPEGPredDbl = function(other) {
    MPEGPredOct.call(this, other);
};
MPEGPredDbl = stjs.extend(MPEGPredDbl, MPEGPredOct, [], function(constructor, prototype) {
    prototype.predictPlane = function(ref, refX, refY, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep) {
        MPEGPredOct.prototype.predictPlane.call(this, ref, refX << 1, refY << 1, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW << 2, tgtH << 2, tgtVertStep);
    };
}, {tmp: "Int32Array", COEFF: "Array", mvPred: "Array", fCode: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  MPEG 1/2 decoder interframe motion compensation routines.
 *  
 *  Quad subpixel interpolator which is just a sub-case of octal subpixel
 *  interpolator.
 *  
 *  @author The JCodec project
 *  
 */
var MPEGPredQuad = function(other) {
    MPEGPredOct.call(this, other);
};
MPEGPredQuad = stjs.extend(MPEGPredQuad, MPEGPredOct, [], function(constructor, prototype) {
    prototype.predictPlane = function(ref, refX, refY, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep) {
        MPEGPredOct.prototype.predictPlane.call(this, ref, refX, refY, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW << 1, tgtH << 1, tgtVertStep);
    };
}, {tmp: "Int32Array", COEFF: "Array", mvPred: "Array", fCode: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Dumps MPEG Proram stream file. Can firther parse MPEG elementary stream
 *  packets.
 *  
 *  @author The JCodec project
 *  
 */
var MPSDump = function(ch) {
    this.ch = ch;
};
MPSDump = stjs.extend(MPSDump, null, [], function(constructor, prototype) {
    constructor.DUMP_FROM = "dump-from";
    constructor.STOP_AT = "stop-at";
    prototype.ch = null;
    constructor.main1 = function(args) {
        var ch = null;
        try {
            var cmd = MainUtils.parseArguments(args);
            if (cmd.args.length < 1) {
                var map = new HashMap();
                map.put(MPSDump.STOP_AT, "Stop reading at timestamp");
                map.put(MPSDump.DUMP_FROM, "Start dumping from timestamp");
                MainUtils.printHelp(map, Arrays.asList("file name"));
                return;
            }
            ch = NIOUtils.readableChannel(new File(cmd.args[0]));
            var dumpAfterPts = cmd.getLongFlag(MPSDump.DUMP_FROM);
            var stopPts = cmd.getLongFlag(MPSDump.STOP_AT);
            new MPSDump(ch).dump(dumpAfterPts, stopPts);
        } finally {
            NIOUtils.closeQuietly(ch);
        }
    };
    prototype.dump = function(dumpAfterPts, stopPts) {
        var analyzer = null;
        var buffer = ByteBuffer.allocate(1048576);
        var pkt = null;
        var hdrSize = 0;
        for (var position = 0; ; ) {
            position -= buffer.position();
            if (this.fillBuffer(buffer) == -1) 
                break;
            buffer.flip();
            if (buffer.remaining() < 4) 
                break;
            position += buffer.remaining();
             while (true){
                var payload = null;
                if (pkt != null && pkt.length > 0) {
                    var pesLen = pkt.length - hdrSize + 6;
                    if (pesLen <= buffer.remaining()) 
                        payload = NIOUtils.read(buffer, pesLen);
                } else {
                    payload = MPSDump.getPesPayload(buffer);
                }
                if (payload == null) 
                    break;
                if (pkt != null) 
                    this.logPes(pkt, hdrSize, payload);
                if (analyzer != null && pkt != null && pkt.streamId >= 224 && pkt.streamId <= 239) {
                    analyzer.analyzeMpegVideoPacket(payload);
                }
                if (buffer.remaining() < 32) {
                    pkt = null;
                    break;
                }
                MPSDump.skipToNextPES(buffer);
                if (buffer.remaining() < 32) {
                    pkt = null;
                    break;
                }
                hdrSize = buffer.position();
                pkt = MPSUtils.readPESHeader(buffer, position - buffer.remaining());
                hdrSize = buffer.position() - hdrSize;
                if (dumpAfterPts != null && pkt.pts >= dumpAfterPts) 
                    analyzer = new MPSDump.MPEGVideoAnalyzer();
                if (stopPts != null && pkt.pts >= stopPts) 
                    return;
            }
            buffer = this.transferRemainder(buffer);
        }
    };
    prototype.fillBuffer = function(buffer) {
        return this.ch.read(buffer);
    };
    prototype.logPes = function(pkt, hdrSize, payload) {
        System.out.println(pkt.streamId + "(" + (pkt.streamId >= 224 ? "video" : "audio") + ") [" + pkt.pos + ", " + (payload.remaining() + hdrSize) + "], pts: " + pkt.pts + ", dts: " + pkt.dts);
    };
    prototype.transferRemainder = function(buffer) {
        var dup = buffer.duplicate();
        dup.clear();
         while (buffer.hasRemaining())
            dup.put(buffer.get());
        return dup;
    };
    constructor.skipToNextPES = function(buffer) {
         while (buffer.hasRemaining()){
            var marker = buffer.duplicate().getInt();
            if (marker >= 445 && marker <= 511 && marker != 446) 
                break;
            buffer.getInt();
            MPEGUtil.gotoNextMarker(buffer);
        }
    };
    constructor.getPesPayload = function(buffer) {
        var copy = buffer.duplicate();
        var result = buffer.duplicate();
         while (copy.hasRemaining()){
            var marker = copy.duplicate().getInt();
            if (marker >= 441) {
                result.setLimit(copy.position());
                buffer.setPosition(copy.position());
                return result;
            }
            copy.getInt();
            MPEGUtil.gotoNextMarker(copy);
        }
        return null;
    };
    constructor.MPEGVideoAnalyzer = function() {
        this.bselPayload = ByteBuffer.allocate(1048576);
    };
    constructor.MPEGVideoAnalyzer = stjs.extend(constructor.MPEGVideoAnalyzer, null, [], function(constructor, prototype) {
        prototype.nextStartCode = -1;
        prototype.bselPayload = null;
        prototype.bselStartCode = 0;
        prototype.bselOffset = 0;
        prototype.bselBufInd = 0;
        prototype.prevBufSize = 0;
        prototype.curBufInd = 0;
        prototype.picHeader = null;
        prototype.sequenceHeader = null;
        prototype.pictureCodingExtension = null;
        prototype.sequenceExtension = null;
        prototype.analyzeMpegVideoPacket = function(buffer) {
            var pos = buffer.position();
            var bufSize = buffer.remaining();
             while (buffer.hasRemaining()){
                this.bselPayload.put(((this.nextStartCode >> 24) << 24 >> 24));
                this.nextStartCode = (this.nextStartCode << 8) | (buffer.get() & 255);
                if (this.nextStartCode >= 256 && this.nextStartCode <= 440) {
                    this.bselPayload.flip();
                    this.bselPayload.getInt();
                    if (this.bselStartCode != 0) {
                        if (this.bselBufInd != this.curBufInd) 
                            this.bselOffset -= this.prevBufSize;
                        this.dumpBSEl(this.bselStartCode, this.bselOffset, this.bselPayload);
                    }
                    this.bselPayload.clear();
                    this.bselStartCode = this.nextStartCode;
                    this.bselOffset = buffer.position() - 4 - pos;
                    this.bselBufInd = this.curBufInd;
                }
            }
            ++this.curBufInd;
            this.prevBufSize = bufSize;
        };
        prototype.dumpBSEl = function(mark, offset, b) {
            System.out.print(String.format("marker: 0x%02x [@%d] ( ", mark, offset));
            if (mark == 256) 
                this.dumpPictureHeader(b);
             else if (mark <= 431) 
                System.out.print(MainUtils.colorBright(String.format("slice @0x%02x", mark - 257), MainUtils.ANSIColor.BLACK, true));
             else if (mark == 435) 
                this.dumpSequenceHeader(b);
             else if (mark == 437) 
                this.dumpExtension(b);
             else if (mark == 440) 
                this.dumpGroupHeader(b);
             else 
                System.out.print("--");
            System.out.println(" )");
        };
        prototype.dumpExtension = function(b) {
            var _in = BitReader.createBitReader(b);
            var extType = _in.readNBit(4);
            if (this.picHeader == null) {
                if (this.sequenceHeader != null) {
                    switch (extType) {
                        case SequenceExtension.Sequence_Extension:
                            this.sequenceExtension = SequenceExtension.read(_in);
                            this.dumpSequenceExtension(this.sequenceExtension);
                            break;
                        case SequenceScalableExtension.Sequence_Scalable_Extension:
                            this.dumpSequenceScalableExtension(SequenceScalableExtension.read(_in));
                            break;
                        case SequenceDisplayExtension.Sequence_Display_Extension:
                            this.dumpSequenceDisplayExtension(SequenceDisplayExtension.read(_in));
                            break;
                        default:
                            System.out.print(MainUtils.colorBright("extension " + extType, MainUtils.ANSIColor.GREEN, true));
                    }
                } else {
                    System.out.print(MainUtils.colorBright("dangling extension " + extType, MainUtils.ANSIColor.GREEN, true));
                }
            } else {
                switch (extType) {
                    case QuantMatrixExtension.Quant_Matrix_Extension:
                        this.dumpQuantMatrixExtension(QuantMatrixExtension.read(_in));
                        break;
                    case CopyrightExtension.Copyright_Extension:
                        this.dumpCopyrightExtension(CopyrightExtension.read(_in));
                        break;
                    case PictureDisplayExtension.Picture_Display_Extension:
                        if (this.sequenceHeader != null && this.pictureCodingExtension != null) 
                            this.dumpPictureDisplayExtension(PictureDisplayExtension.read(_in, this.sequenceExtension, this.pictureCodingExtension));
                        break;
                    case PictureCodingExtension.Picture_Coding_Extension:
                        this.pictureCodingExtension = PictureCodingExtension.read(_in);
                        this.dumpPictureCodingExtension(this.pictureCodingExtension);
                        break;
                    case PictureSpatialScalableExtension.Picture_Spatial_Scalable_Extension:
                        this.dumpPictureSpatialScalableExtension(PictureSpatialScalableExtension.read(_in));
                        break;
                    case PictureTemporalScalableExtension.Picture_Temporal_Scalable_Extension:
                        this.dumpPictureTemporalScalableExtension(PictureTemporalScalableExtension.read(_in));
                        break;
                    default:
                        System.out.print(MainUtils.colorBright("extension " + extType, MainUtils.ANSIColor.GREEN, true));
                }
            }
        };
        prototype.dumpSequenceDisplayExtension = function(read) {
            System.out.print(MainUtils.colorBright("sequence display extension " + this.dumpBin(read), MainUtils.ANSIColor.GREEN, true));
        };
        prototype.dumpSequenceScalableExtension = function(read) {
            System.out.print(MainUtils.colorBright("sequence scalable extension " + this.dumpBin(read), MainUtils.ANSIColor.GREEN, true));
        };
        prototype.dumpSequenceExtension = function(read) {
            System.out.print(MainUtils.colorBright("sequence extension " + this.dumpBin(read), MainUtils.ANSIColor.GREEN, true));
        };
        prototype.dumpPictureTemporalScalableExtension = function(read) {
            System.out.print(MainUtils.colorBright("picture temporal scalable extension " + this.dumpBin(read), MainUtils.ANSIColor.GREEN, true));
        };
        prototype.dumpPictureSpatialScalableExtension = function(read) {
            System.out.print(MainUtils.colorBright("picture spatial scalable extension " + this.dumpBin(read), MainUtils.ANSIColor.GREEN, true));
        };
        prototype.dumpPictureCodingExtension = function(read) {
            System.out.print(MainUtils.colorBright("picture coding extension " + this.dumpBin(read), MainUtils.ANSIColor.GREEN, true));
        };
        prototype.dumpPictureDisplayExtension = function(read) {
            System.out.print(MainUtils.colorBright("picture display extension " + this.dumpBin(read), MainUtils.ANSIColor.GREEN, true));
        };
        prototype.dumpCopyrightExtension = function(read) {
            System.out.print(MainUtils.colorBright("copyright extension " + this.dumpBin(read), MainUtils.ANSIColor.GREEN, true));
        };
        prototype.dumpQuantMatrixExtension = function(read) {
            System.out.print(MainUtils.colorBright("quant matrix extension " + this.dumpBin(read), MainUtils.ANSIColor.GREEN, true));
        };
        prototype.dumpBin = function(read) {
            var bldr = new StringBuilder();
            bldr.append("<");
            var fields = Platform.getFields(read.getClass());
            for (var i = 0; i < fields.length; i++) {
                if (!Modifier.isPublic(fields[i].getModifiers()) || Modifier.isStatic(fields[i].getModifiers())) 
                    continue;
                bldr.append(this.convertName(fields[i].getName()) + ": ");
                if (fields[i].getType().isPrimitive()) {
                    try {
                        bldr.append(fields[i].get(read));
                    }catch (e) {}
                } else {
                    try {
                        var val = fields[i].get(read);
                        if (val != null) 
                            bldr.append(this.dumpBin(val));
                         else 
                            bldr.append("N/A");
                    }catch (e) {}
                }
                if (i < fields.length - 1) 
                    bldr.append(",");
            }
            bldr.append(">");
            return bldr.toString();
        };
        prototype.convertName = function(name) {
            return name.replaceAll("([A-Z])", " $1").replaceFirst("^ ", "").toLowerCase();
        };
        prototype.dumpGroupHeader = function(b) {
            var gopHeader = GOPHeader.read(b);
            System.out.print(MainUtils.colorBright("group header <closed:" + gopHeader.isClosedGop() + ",broken link:" + gopHeader.isBrokenLink() + (gopHeader.getTimeCode() != null ? (",timecode:" + gopHeader.getTimeCode().toString()) : "") + ">", MainUtils.ANSIColor.MAGENTA, true));
        };
        prototype.dumpSequenceHeader = function(b) {
            this.picHeader = null;
            this.pictureCodingExtension = null;
            this.sequenceExtension = null;
            this.sequenceHeader = SequenceHeader.read(b);
            System.out.print(MainUtils.colorBright("sequence header", MainUtils.ANSIColor.BLUE, true));
        };
        prototype.dumpPictureHeader = function(b) {
            this.picHeader = PictureHeader.read(b);
            this.pictureCodingExtension = null;
            System.out.print(MainUtils.colorBright("picture header <type:" + (this.picHeader.picture_coding_type == 1 ? "I" : (this.picHeader.picture_coding_type == 2 ? "P" : "B")) + ", temp_ref:" + this.picHeader.temporal_reference + ">", MainUtils.ANSIColor.BROWN, true));
        };
    }, {bselPayload: "ByteBuffer", picHeader: "PictureHeader", sequenceHeader: "SequenceHeader", pictureCodingExtension: "PictureCodingExtension", sequenceExtension: "SequenceExtension"}, {});
}, {ch: "ReadableByteChannel"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  MPEG 1/2 Decoder
 *  
 *  Supports I/P/B frames, frame/field/interlaced frame encoding
 *  
 *  Conforms to H.262 ( ISO/IEC 13818-2, ISO/IEC 11172-2 ) specifications
 *  
 *  @author The JCodec project
 *  
 */
var MPEGDecoder = function() {
    VideoDecoder.call(this);
    this.refFrames = Array(2);
    this.refFields = Array(2);
};
MPEGDecoder = stjs.extend(MPEGDecoder, VideoDecoder, [], function(constructor, prototype) {
    prototype.sh = null;
    prototype.gh = null;
    prototype.refFrames = null;
    prototype.refFields = null;
    constructor.Context = function() {
        this.intra_dc_predictor = new Int32Array(3);
    };
    constructor.Context = stjs.extend(constructor.Context, null, [], function(constructor, prototype) {
        prototype.intra_dc_predictor = null;
        prototype.mbWidth = 0;
        prototype.mbNo = 0;
        prototype.codedWidth = 0;
        prototype.codedHeight = 0;
        prototype.mbHeight = 0;
        prototype.color = null;
        prototype.lastPredB = null;
        prototype.qMats = null;
        prototype.scan = null;
        prototype.picWidth = 0;
        prototype.picHeight = 0;
    }, {intra_dc_predictor: "Int32Array", color: "ColorSpace", lastPredB: "MPEGConst.MBType", qMats: "Array", scan: "Int32Array"}, {});
    prototype.decodeFrame8Bit = function(ByteBuffer, buf) {
        var ph = this.readHeader(ByteBuffer);
        if (this.refFrames[0] == null && ph.picture_coding_type > 1 || this.refFrames[1] == null && ph.picture_coding_type > 2) {
             throw new RuntimeException("Not enough references to decode " + (ph.picture_coding_type == 1 ? "P" : "B") + " frame");
        }
        var context = this.initContext(this.sh, ph);
        var pic = new Picture8Bit(context.codedWidth, context.codedHeight, buf, context.color, new Rect(0, 0, context.picWidth, context.picHeight));
        if (ph.pictureCodingExtension != null && ph.pictureCodingExtension.picture_structure != PictureCodingExtension.Frame) {
            this.decodePicture(context, ph, ByteBuffer, buf, ph.pictureCodingExtension.picture_structure - 1, 1);
            ph = this.readHeader(ByteBuffer);
            context = this.initContext(this.sh, ph);
            this.decodePicture(context, ph, ByteBuffer, buf, ph.pictureCodingExtension.picture_structure - 1, 1);
        } else {
            this.decodePicture(context, ph, ByteBuffer, buf, 0, 0);
        }
        if (ph.picture_coding_type == MPEGConst.IntraCoded || ph.picture_coding_type == MPEGConst.PredictiveCoded) {
            var unused = this.refFrames[1];
            this.refFrames[1] = this.refFrames[0];
            this.refFrames[0] = this.copyAndCreateIfNeeded(pic, unused);
        }
        return pic;
    };
    prototype.copyAndCreateIfNeeded = function(src, dst) {
        if (dst == null || !dst.compatible(src)) {
            dst = src.createCompatible();
        }
        dst.copyFrom(src);
        return dst;
    };
    prototype.readHeader = function(buffer) {
        var ph = null;
        var segment;
        var fork = buffer.duplicate();
         while ((segment = MPEGUtil.nextSegment(fork)) != null){
            var code = segment.getInt() & 255;
            if (code == MPEGConst.SEQUENCE_HEADER_CODE) {
                var newSh = SequenceHeader.read(segment);
                if (this.sh != null) {
                    newSh.copyExtensions(this.sh);
                }
                this.sh = newSh;
            } else if (code == MPEGConst.GROUP_START_CODE) {
                this.gh = GOPHeader.read(segment);
            } else if (code == MPEGConst.PICTURE_START_CODE) {
                ph = PictureHeader.read(segment);
            } else if (code == MPEGConst.EXTENSION_START_CODE) {
                var extType = segment.getAt(4) >> 4;
                if (extType == SequenceExtension.Sequence_Extension || extType == SequenceScalableExtension.Sequence_Scalable_Extension || extType == SequenceDisplayExtension.Sequence_Display_Extension) 
                    SequenceHeader.readExtension(segment, this.sh);
                 else 
                    PictureHeader.readExtension(segment, ph, this.sh);
            } else if (code == MPEGConst.USER_DATA_START_CODE) {} else {
                break;
            }
            buffer.setPosition(fork.position());
        }
        return ph;
    };
    prototype.initContext = function(sh, ph) {
        var context = new MPEGDecoder.Context();
        context.codedWidth = (sh.horizontal_size + 15) & ~15;
        context.codedHeight = MPEGDecoder.getCodedHeight(sh, ph);
        context.mbWidth = (sh.horizontal_size + 15) >> 4;
        context.mbHeight = (sh.vertical_size + 15) >> 4;
        context.picWidth = sh.horizontal_size;
        context.picHeight = sh.vertical_size;
        var chromaFormat = SequenceExtension.Chroma420;
        if (sh.sequenceExtension != null) 
            chromaFormat = sh.sequenceExtension.chroma_format;
        context.color = this.getColor(chromaFormat);
        context.scan = MPEGConst.scan[ph.pictureCodingExtension == null ? 0 : ph.pictureCodingExtension.alternate_scan];
        var inter = sh.non_intra_quantiser_matrix == null ? this.zigzag(MPEGConst.defaultQMatInter, context.scan) : sh.non_intra_quantiser_matrix;
        var intra = sh.intra_quantiser_matrix == null ? this.zigzag(MPEGConst.defaultQMatIntra, context.scan) : sh.intra_quantiser_matrix;
        context.qMats = [inter, inter, intra, intra];
        if (ph.quantMatrixExtension != null) {
            if (ph.quantMatrixExtension.non_intra_quantiser_matrix != null) 
                context.qMats[0] = ph.quantMatrixExtension.non_intra_quantiser_matrix;
            if (ph.quantMatrixExtension.chroma_non_intra_quantiser_matrix != null) 
                context.qMats[1] = ph.quantMatrixExtension.chroma_non_intra_quantiser_matrix;
            if (ph.quantMatrixExtension.intra_quantiser_matrix != null) 
                context.qMats[2] = ph.quantMatrixExtension.intra_quantiser_matrix;
            if (ph.quantMatrixExtension.chroma_intra_quantiser_matrix != null) 
                context.qMats[3] = ph.quantMatrixExtension.chroma_intra_quantiser_matrix;
        }
        return context;
    };
    prototype.zigzag = function(array, scan) {
        var result = new Int32Array(64);
        for (var i = 0; i < scan.length; i++) 
            result[i] = array[scan[i]];
        return result;
    };
    constructor.getCodedHeight = function(sh, ph) {
        var field = ph.pictureCodingExtension != null && ph.pictureCodingExtension.picture_structure != PictureCodingExtension.Frame ? 1 : 0;
        return (((sh.vertical_size >> field) + 15) & ~15) << field;
    };
    prototype.decodePicture = function(context, ph, buffer, buf, vertOff, vertStep) {
        var planeSize = context.codedWidth * context.codedHeight;
        if (buf.length < 3 || buf[0].length < planeSize || buf[1].length < planeSize || buf[2].length < planeSize) {
             throw new RuntimeException("ByteBuffer too small to hold output picture [" + context.codedWidth + "x" + context.codedHeight + "]");
        }
        try {
            var segment;
             while ((segment = MPEGUtil.nextSegment(buffer)) != null){
                var startCode = segment.getAt(3) & 255;
                if (startCode >= MPEGConst.SLICE_START_CODE_FIRST && startCode <= MPEGConst.SLICE_START_CODE_LAST) {
                    this.doDecodeSlice(context, ph, buf, vertOff, vertStep, segment);
                } else if (startCode >= 179 && startCode != 182 && startCode != 183) {
                     throw new RuntimeException("Unexpected start code " + startCode);
                } else if (startCode == 0) {
                    buffer.reset();
                    break;
                }
            }
            var pic = Picture8Bit.createPicture8Bit(context.codedWidth, context.codedHeight, buf, context.color);
            if ((ph.picture_coding_type == MPEGConst.IntraCoded || ph.picture_coding_type == MPEGConst.PredictiveCoded) && ph.pictureCodingExtension != null && ph.pictureCodingExtension.picture_structure != PictureCodingExtension.Frame) {
                this.refFields[ph.pictureCodingExtension.picture_structure - 1] = this.copyAndCreateIfNeeded(pic, this.refFields[ph.pictureCodingExtension.picture_structure - 1]);
            }
            return pic;
        }catch (e) {
             throw new RuntimeException(e);
        }
    };
    prototype.doDecodeSlice = function(context, ph, buf, vertOff, vertStep, segment) {
        var startCode = segment.getAt(3) & 255;
        var dup = segment.duplicate();
        dup.setPosition(4);
        try {
            this.decodeSlice(ph, startCode, context, buf, BitReader.createBitReader(dup), vertOff, vertStep);
        }catch (e) {
            e.printStackTrace();
        }
    };
    prototype.getColor = function(chromaFormat) {
        switch (chromaFormat) {
            case SequenceExtension.Chroma420:
                return ColorSpace.YUV420;
            case SequenceExtension.Chroma422:
                return ColorSpace.YUV422;
            case SequenceExtension.Chroma444:
                return ColorSpace.YUV444;
        }
        return null;
    };
    prototype.decodeSlice = function(ph, verticalPos, context, buf, _in, vertOff, vertStep) {
        var stride = context.codedWidth;
        this.resetDCPredictors(context, ph);
        var mbRow = verticalPos - 1;
        if (this.sh.vertical_size > 2800) {
            mbRow += (_in.readNBit(3) << 7);
        }
        if (this.sh.sequenceScalableExtension != null && this.sh.sequenceScalableExtension.scalable_mode == SequenceScalableExtension.DATA_PARTITIONING) {
            var priorityBreakpoint = _in.readNBit(7);
        }
        var qScaleCode = _in.readNBit(5);
        if (_in.read1Bit() == 1) {
            var intraSlice = _in.read1Bit();
            _in.skip(7);
             while (_in.read1Bit() == 1)
                _in.readNBit(8);
        }
        var pred = new MPEGPred(ph.pictureCodingExtension != null ? ph.pictureCodingExtension.f_code : [new Int32Array([ph.forward_f_code, ph.forward_f_code]), new Int32Array([ph.backward_f_code, ph.backward_f_code])], this.sh.sequenceExtension != null ? this.sh.sequenceExtension.chroma_format : SequenceExtension.Chroma420, ph.pictureCodingExtension != null && ph.pictureCodingExtension.top_field_first == 0 ? false : true);
        var ctx = new Int32Array([qScaleCode]);
        for (var prevAddr = mbRow * context.mbWidth - 1; _in.checkNBit(23) != 0; ) {
            prevAddr = this.decodeMacroblock(ph, context, prevAddr, ctx, buf, stride, _in, vertOff, vertStep, pred);
            context.mbNo++;
        }
    };
    prototype.resetDCPredictors = function(context, ph) {
        var rval = 1 << 7;
        if (ph.pictureCodingExtension != null) 
            rval = 1 << (7 + ph.pictureCodingExtension.intra_dc_precision);
        context.intra_dc_predictor[0] = context.intra_dc_predictor[1] = context.intra_dc_predictor[2] = rval;
    };
    prototype.decodeMacroblock = function(ph, context, prevAddr, qScaleCode, buf, stride, bits, vertOff, vertStep, pred) {
        var mbAddr = prevAddr;
         while (bits.checkNBit(11) == 8){
            bits.skip(11);
            mbAddr += 33;
        }
        mbAddr += MPEGConst.vlcAddressIncrement.readVLC(bits) + 1;
        var chromaFormat = SequenceExtension.Chroma420;
        if (this.sh.sequenceExtension != null) 
            chromaFormat = this.sh.sequenceExtension.chroma_format;
        for (var i = prevAddr + 1; i < mbAddr; i++) {
            var predFwd = [new Int32Array(256), new Int32Array(1 << (chromaFormat + 5)), new Int32Array(1 << (chromaFormat + 5))];
            var mbX = i % context.mbWidth;
            var mbY = stjs.trunc(i / context.mbWidth);
            if (ph.picture_coding_type == MPEGConst.PredictiveCoded) 
                pred.reset();
            this.mvZero(context, ph, pred, mbX, mbY, predFwd);
            this.put(predFwd, buf, stride, chromaFormat, mbX, mbY, context.codedWidth, context.codedHeight >> vertStep, vertOff, vertStep);
        }
        var vlcMBType = SequenceScalableExtension.vlcMBType(ph.picture_coding_type, this.sh.sequenceScalableExtension);
        var mbTypeVal = SequenceScalableExtension.mbTypeVal(ph.picture_coding_type, this.sh.sequenceScalableExtension);
        var mbType = mbTypeVal[vlcMBType.readVLC(bits)];
        if (mbType.macroblock_intra != 1 || (mbAddr - prevAddr) > 1) {
            this.resetDCPredictors(context, ph);
        }
        var spatial_temporal_weight_code = 0;
        if (mbType.spatial_temporal_weight_code_flag == 1 && ph.pictureSpatialScalableExtension != null && ph.pictureSpatialScalableExtension.spatial_temporal_weight_code_table_index != 0) {
            spatial_temporal_weight_code = bits.readNBit(2);
        }
        var motion_type = -1;
        if (mbType.macroblock_motion_forward != 0 || mbType.macroblock_motion_backward != 0) {
            if (ph.pictureCodingExtension == null || ph.pictureCodingExtension.picture_structure == PictureCodingExtension.Frame && ph.pictureCodingExtension.frame_pred_frame_dct == 1) 
                motion_type = 2;
             else 
                motion_type = bits.readNBit(2);
        }
        var dctType = 0;
        if (ph.pictureCodingExtension != null && ph.pictureCodingExtension.picture_structure == PictureCodingExtension.Frame && ph.pictureCodingExtension.frame_pred_frame_dct == 0 && (mbType.macroblock_intra != 0 || mbType.macroblock_pattern != 0)) {
            dctType = bits.read1Bit();
        }
        if (mbType.macroblock_quant != 0) {
            qScaleCode[0] = bits.readNBit(5);
        }
        var concealmentMv = ph.pictureCodingExtension != null && ph.pictureCodingExtension.concealment_motion_vectors != 0;
        var predFwd = null;
        var mbX = mbAddr % context.mbWidth;
        var mbY = stjs.trunc(mbAddr / context.mbWidth);
        if (mbType.macroblock_intra == 1) {
            if (concealmentMv) {} else 
                pred.reset();
        } else if (mbType.macroblock_motion_forward != 0) {
            var refIdx = ph.picture_coding_type == MPEGConst.PredictiveCoded ? 0 : 1;
            predFwd = [new Int32Array(256), new Int32Array(1 << (chromaFormat + 5)), new Int32Array(1 << (chromaFormat + 5))];
            if (ph.pictureCodingExtension == null || ph.pictureCodingExtension.picture_structure == PictureCodingExtension.Frame) {
                pred.predictInFrame(this.refFrames[refIdx], mbX << 4, mbY << 4, predFwd, bits, motion_type, 0, spatial_temporal_weight_code);
            } else {
                if (ph.picture_coding_type == MPEGConst.PredictiveCoded) {
                    pred.predictInField(this.refFields, mbX << 4, mbY << 4, predFwd, bits, motion_type, 0, ph.pictureCodingExtension.picture_structure - 1);
                } else {
                    pred.predictInField([this.refFrames[refIdx], this.refFrames[refIdx]], mbX << 4, mbY << 4, predFwd, bits, motion_type, 0, ph.pictureCodingExtension.picture_structure - 1);
                }
            }
        } else if (ph.picture_coding_type == MPEGConst.PredictiveCoded) {
            predFwd = [new Int32Array(256), new Int32Array(1 << (chromaFormat + 5)), new Int32Array(1 << (chromaFormat + 5))];
            pred.reset();
            this.mvZero(context, ph, pred, mbX, mbY, predFwd);
        }
        var predBack = null;
        if (mbType.macroblock_motion_backward != 0) {
            predBack = [new Int32Array(256), new Int32Array(1 << (chromaFormat + 5)), new Int32Array(1 << (chromaFormat + 5))];
            if (ph.pictureCodingExtension == null || ph.pictureCodingExtension.picture_structure == PictureCodingExtension.Frame) {
                pred.predictInFrame(this.refFrames[0], mbX << 4, mbY << 4, predBack, bits, motion_type, 1, spatial_temporal_weight_code);
            } else {
                pred.predictInField([this.refFrames[0], this.refFrames[0]], mbX << 4, mbY << 4, predBack, bits, motion_type, 1, ph.pictureCodingExtension.picture_structure - 1);
            }
        }
        context.lastPredB = mbType;
        var pp = mbType.macroblock_intra == 1 ? [new Int32Array(256), new Int32Array(1 << (chromaFormat + 5)), new Int32Array(1 << (chromaFormat + 5))] : MPEGDecoder.buildPred(predFwd, predBack);
        if (mbType.macroblock_intra != 0 && concealmentMv) 
            Assert.assertEquals(1, bits.read1Bit());
        var cbp = mbType.macroblock_intra == 1 ? 4095 : 0;
        if (mbType.macroblock_pattern != 0) {
            cbp = this.readCbPattern(bits);
        }
        var vlcCoeff = MPEGConst.vlcCoeff0;
        if (ph.pictureCodingExtension != null && mbType.macroblock_intra == 1 && ph.pictureCodingExtension.intra_vlc_format == 1) 
            vlcCoeff = MPEGConst.vlcCoeff1;
        var qScaleTab = ph.pictureCodingExtension != null && ph.pictureCodingExtension.q_scale_type == 1 ? MPEGConst.qScaleTab2 : MPEGConst.qScaleTab1;
        var qScale = qScaleTab[qScaleCode[0]];
        var intra_dc_mult = 8;
        if (ph.pictureCodingExtension != null) 
            intra_dc_mult = 8 >> ph.pictureCodingExtension.intra_dc_precision;
        var blkCount = 6 + (chromaFormat == SequenceExtension.Chroma420 ? 0 : (chromaFormat == SequenceExtension.Chroma422 ? 2 : 6));
        var block = new Int32Array(64);
        for (var i = 0, cbpMask = 1 << (blkCount - 1); i < blkCount; i++ , cbpMask >>= 1) {
            if ((cbp & cbpMask) == 0) 
                continue;
            var qmat = context.qMats[(i >= 4 ? 1 : 0) + (mbType.macroblock_intra << 1)];
            if (mbType.macroblock_intra == 1) 
                this.blockIntra(bits, vlcCoeff, block, context.intra_dc_predictor, i, context.scan, this.sh.hasExtensions() || ph.hasExtensions() ? 12 : 8, intra_dc_mult, qScale, qmat);
             else 
                this.blockInter(bits, vlcCoeff, block, context.scan, this.sh.hasExtensions() || ph.hasExtensions() ? 12 : 8, qScale, qmat);
            this.mapBlock(block, pp[MPEGConst.BLOCK_TO_CC[i]], i, dctType, chromaFormat);
        }
        this.put(pp, buf, stride, chromaFormat, mbX, mbY, context.codedWidth, context.codedHeight >> vertStep, vertOff, vertStep);
        return mbAddr;
    };
    prototype.mapBlock = function(block, out, blkIdx, dctType, chromaFormat) {
        var stepVert = chromaFormat == SequenceExtension.Chroma420 && (blkIdx == 4 || blkIdx == 5) ? 0 : dctType;
        var log2stride = blkIdx < 4 ? 4 : 4 - MPEGConst.SQUEEZE_X[chromaFormat];
        var blkIdxExt = blkIdx + (dctType << 4);
        var x = MPEGConst.BLOCK_POS_X[blkIdxExt];
        var y = MPEGConst.BLOCK_POS_Y[blkIdxExt];
        var off = (y << log2stride) + x, stride = 1 << (log2stride + stepVert);
        for (var i = 0, coeff = 0; i < 8; i++ , coeff += 8) {
            out[off] += block[coeff];
            out[off + 1] += block[coeff + 1];
            out[off + 2] += block[coeff + 2];
            out[off + 3] += block[coeff + 3];
            out[off + 4] += block[coeff + 4];
            out[off + 5] += block[coeff + 5];
            out[off + 6] += block[coeff + 6];
            out[off + 7] += block[coeff + 7];
            off += stride;
        }
    };
    constructor.buildPred = function(predFwd, predBack) {
        if (predFwd != null && predBack != null) {
            MPEGDecoder.avgPred(predFwd, predBack);
            return predFwd;
        } else if (predFwd != null) 
            return predFwd;
         else if (predBack != null) 
            return predBack;
         else 
             throw new RuntimeException("Omited pred _in B-frames --> invalid");
    };
    constructor.avgPred = function(predFwd, predBack) {
        for (var i = 0; i < predFwd.length; i++) {
            for (var j = 0; j < predFwd[i].length; j += 4) {
                predFwd[i][j] = (predFwd[i][j] + predBack[i][j] + 1) >> 1;
                predFwd[i][j + 1] = (predFwd[i][j + 1] + predBack[i][j + 1] + 1) >> 1;
                predFwd[i][j + 2] = (predFwd[i][j + 2] + predBack[i][j + 2] + 1) >> 1;
                predFwd[i][j + 3] = (predFwd[i][j + 3] + predBack[i][j + 3] + 1) >> 1;
            }
        }
    };
    prototype.mvZero = function(context, ph, pred, mbX, mbY, mbPix) {
        if (ph.picture_coding_type == MPEGConst.PredictiveCoded) {
            pred.predict16x16NoMV(this.refFrames[0], mbX << 4, mbY << 4, ph.pictureCodingExtension == null ? PictureCodingExtension.Frame : ph.pictureCodingExtension.picture_structure, 0, mbPix);
        } else {
            var pp = mbPix;
            if (context.lastPredB.macroblock_motion_backward == 1) {
                pred.predict16x16NoMV(this.refFrames[0], mbX << 4, mbY << 4, ph.pictureCodingExtension == null ? PictureCodingExtension.Frame : ph.pictureCodingExtension.picture_structure, 1, pp);
                pp = [new Int32Array(mbPix[0].length), new Int32Array(mbPix[1].length), new Int32Array(mbPix[2].length)];
            }
            if (context.lastPredB.macroblock_motion_forward == 1) {
                pred.predict16x16NoMV(this.refFrames[1], mbX << 4, mbY << 4, ph.pictureCodingExtension == null ? PictureCodingExtension.Frame : ph.pictureCodingExtension.picture_structure, 0, pp);
                if (mbPix != pp) 
                    MPEGDecoder.avgPred(mbPix, pp);
            }
        }
    };
    prototype.put = function(mbPix, buf, stride, chromaFormat, mbX, mbY, width, height, vertOff, vertStep) {
        var chromaStride = (stride + (1 << MPEGConst.SQUEEZE_X[chromaFormat]) - 1) >> MPEGConst.SQUEEZE_X[chromaFormat];
        var chromaMBW = 4 - MPEGConst.SQUEEZE_X[chromaFormat];
        var chromaMBH = 4 - MPEGConst.SQUEEZE_Y[chromaFormat];
        this.putSub(buf[0], (mbY << 4) * (stride << vertStep) + vertOff * stride + (mbX << 4), stride << vertStep, mbPix[0], 4, 4);
        this.putSub(buf[1], (mbY << chromaMBH) * (chromaStride << vertStep) + vertOff * chromaStride + (mbX << chromaMBW), chromaStride << vertStep, mbPix[1], chromaMBW, chromaMBH);
        this.putSub(buf[2], (mbY << chromaMBH) * (chromaStride << vertStep) + vertOff * chromaStride + (mbX << chromaMBW), chromaStride << vertStep, mbPix[2], chromaMBW, chromaMBH);
    };
    prototype.putSub = function(big, off, stride, block, mbW, mbH) {
        var blOff = 0;
        if (mbW == 3) {
            for (var i = 0; i < (1 << mbH); i++) {
                big[off] = MPEGDecoder.clipTo8Bit(block[blOff]);
                big[off + 1] = MPEGDecoder.clipTo8Bit(block[blOff + 1]);
                big[off + 2] = MPEGDecoder.clipTo8Bit(block[blOff + 2]);
                big[off + 3] = MPEGDecoder.clipTo8Bit(block[blOff + 3]);
                big[off + 4] = MPEGDecoder.clipTo8Bit(block[blOff + 4]);
                big[off + 5] = MPEGDecoder.clipTo8Bit(block[blOff + 5]);
                big[off + 6] = MPEGDecoder.clipTo8Bit(block[blOff + 6]);
                big[off + 7] = MPEGDecoder.clipTo8Bit(block[blOff + 7]);
                blOff += 8;
                off += stride;
            }
        } else {
            for (var i = 0; i < (1 << mbH); i++) {
                big[off] = MPEGDecoder.clipTo8Bit(block[blOff]);
                big[off + 1] = MPEGDecoder.clipTo8Bit(block[blOff + 1]);
                big[off + 2] = MPEGDecoder.clipTo8Bit(block[blOff + 2]);
                big[off + 3] = MPEGDecoder.clipTo8Bit(block[blOff + 3]);
                big[off + 4] = MPEGDecoder.clipTo8Bit(block[blOff + 4]);
                big[off + 5] = MPEGDecoder.clipTo8Bit(block[blOff + 5]);
                big[off + 6] = MPEGDecoder.clipTo8Bit(block[blOff + 6]);
                big[off + 7] = MPEGDecoder.clipTo8Bit(block[blOff + 7]);
                big[off + 8] = MPEGDecoder.clipTo8Bit(block[blOff + 8]);
                big[off + 9] = MPEGDecoder.clipTo8Bit(block[blOff + 9]);
                big[off + 10] = MPEGDecoder.clipTo8Bit(block[blOff + 10]);
                big[off + 11] = MPEGDecoder.clipTo8Bit(block[blOff + 11]);
                big[off + 12] = MPEGDecoder.clipTo8Bit(block[blOff + 12]);
                big[off + 13] = MPEGDecoder.clipTo8Bit(block[blOff + 13]);
                big[off + 14] = MPEGDecoder.clipTo8Bit(block[blOff + 14]);
                big[off + 15] = MPEGDecoder.clipTo8Bit(block[blOff + 15]);
                blOff += 16;
                off += stride;
            }
        }
    };
    constructor.clipTo8Bit = function(val) {
        return (((val < 0 ? 0 : (val > 255 ? 255 : val)) - 128) << 24 >> 24);
    };
    constructor.clip = function(val) {
        return val < 0 ? 0 : (val > 255 ? 255 : val);
    };
    constructor.quantInter = function(level, quant) {
        return (((level << 1) + 1) * quant) >> 5;
    };
    constructor.quantInterSigned = function(level, quant) {
        return level >= 0 ? MPEGDecoder.quantInter(level, quant) : -MPEGDecoder.quantInter(-level, quant);
    };
    prototype.blockIntra = function(bits, vlcCoeff, block, intra_dc_predictor, blkIdx, scan, escSize, intra_dc_mult, qScale, qmat) {
        var cc = MPEGConst.BLOCK_TO_CC[blkIdx];
        var size = (cc == 0 ? MPEGConst.vlcDCSizeLuma : MPEGConst.vlcDCSizeChroma).readVLC(bits);
        var delta = (size != 0) ? MPEGDecoder.mpegSigned(bits, size) : 0;
        intra_dc_predictor[cc] = intra_dc_predictor[cc] + delta;
        var dc = intra_dc_predictor[cc] * intra_dc_mult;
        SparseIDCT.start(block, dc);
        for (var idx = 0; idx < 64; ) {
            var readVLC = vlcCoeff.readVLC(bits);
            var level;
            if (readVLC == MPEGConst.CODE_END) {
                break;
            } else if (readVLC == MPEGConst.CODE_ESCAPE) {
                idx += bits.readNBit(6) + 1;
                level = MPEGDecoder.twosSigned(bits, escSize) * qScale * qmat[idx];
                level = level >= 0 ? (level >> 4) : -(-level >> 4);
            } else {
                idx += (readVLC >> 6) + 1;
                level = MPEGDecoder.toSigned(((readVLC & 63) * qScale * qmat[idx]) >> 4, bits.read1Bit());
            }
            SparseIDCT.coeff(block, scan[idx], level);
        }
        SparseIDCT.finish(block);
    };
    prototype.blockInter = function(bits, vlcCoeff, block, scan, escSize, qScale, qmat) {
        var idx = -1;
        if (vlcCoeff == MPEGConst.vlcCoeff0 && bits.checkNBit(1) == 1) {
            bits.read1Bit();
            var dc = MPEGDecoder.toSigned(MPEGDecoder.quantInter(1, qScale * qmat[0]), bits.read1Bit());
            SparseIDCT.start(block, dc);
            idx++;
        } else {
            SparseIDCT.start(block, 0);
        }
        for (; idx < 64; ) {
            var readVLC = vlcCoeff.readVLC(bits);
            var ac;
            if (readVLC == MPEGConst.CODE_END) {
                break;
            } else if (readVLC == MPEGConst.CODE_ESCAPE) {
                idx += bits.readNBit(6) + 1;
                ac = MPEGDecoder.quantInterSigned(MPEGDecoder.twosSigned(bits, escSize), qScale * qmat[idx]);
            } else {
                idx += (readVLC >> 6) + 1;
                ac = MPEGDecoder.toSigned(MPEGDecoder.quantInter(readVLC & 63, qScale * qmat[idx]), bits.read1Bit());
            }
            SparseIDCT.coeff(block, scan[idx], ac);
        }
        SparseIDCT.finish(block);
    };
    constructor.twosSigned = function(bits, size) {
        var shift = 32 - size;
        return (bits.readNBit(size) << shift) >> shift;
    };
    constructor.mpegSigned = function(bits, size) {
        var val = bits.readNBit(size);
        var sign = (val >>> (size - 1)) ^ 1;
        return val + sign - (sign << size);
    };
    constructor.toSigned = function(val, s) {
        var sign = (s << 31) >> 31;
        return (val ^ sign) - sign;
    };
    prototype.readCbPattern = function(bits) {
        var cbp420 = MPEGConst.vlcCBP.readVLC(bits);
        if (this.sh.sequenceExtension == null || this.sh.sequenceExtension.chroma_format == SequenceExtension.Chroma420) 
            return cbp420;
         else if (this.sh.sequenceExtension.chroma_format == SequenceExtension.Chroma422) 
            return (cbp420 << 2) | bits.readNBit(2);
         else if (this.sh.sequenceExtension.chroma_format == SequenceExtension.Chroma444) 
            return (cbp420 << 6) | bits.readNBit(6);
         throw new RuntimeException("Unsupported chroma format: " + this.sh.sequenceExtension.chroma_format);
    };
    prototype.probe = function(data) {
        data = data.duplicate();
        data.order(ByteOrder.BIG_ENDIAN);
        for (var i = 0; i < 2; i++) {
            if (MPEGUtil.gotoNextMarker(data) == null) 
                break;
            if (!data.hasRemaining()) 
                break;
            var marker = data.getInt();
            if (marker == 256 || (marker >= 432 && marker <= 440)) 
                return 50 - i * 10;
             else if (marker > 256 && marker < 432) 
                return 20 - i * 10;
        }
        return 0;
    };
    constructor.getSize = function(data) {
        var sh = MPEGDecoder.getSequenceHeader(data.duplicate());
        return new Size(sh.horizontal_size, sh.vertical_size);
    };
    constructor.getSequenceHeader = function(data) {
        var segment = MPEGUtil.nextSegment(data);
         while (segment != null){
            var marker = segment.getInt();
            if (marker == (256 | MPEGConst.SEQUENCE_HEADER_CODE)) {
                return SequenceHeader.read(segment);
            }
            segment = MPEGUtil.nextSegment(data);
        }
        return null;
    };
    prototype.downscaled = function(ratio) {
        if (ratio == 1) 
            return this;
        return null;
    };
}, {sh: "SequenceHeader", gh: "GOPHeader", refFrames: "Array", refFields: "Array", byteBuffer: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Encodes macroblock as P16x16
 *  
 *  @author Stanislav Vitvitskyy
 */
var MBEncoderP16x16 = function(sps, ref, cavlc, me) {
    this.sps = sps;
    this.cavlc = cavlc;
    this.ref = ref;
    this.me = me;
    this.mvTopX = new Int32Array(sps.pic_width_in_mbs_minus1 + 1);
    this.mvTopY = new Int32Array(sps.pic_width_in_mbs_minus1 + 1);
    this.interpolator = new BlockInterpolator();
};
MBEncoderP16x16 = stjs.extend(MBEncoderP16x16, null, [], function(constructor, prototype) {
    prototype.cavlc = null;
    prototype.sps = null;
    prototype.ref = null;
    prototype.me = null;
    prototype.mvTopX = null;
    prototype.mvTopY = null;
    prototype.mvLeftX = 0;
    prototype.mvLeftY = 0;
    prototype.mvTopLeftX = 0;
    prototype.mvTopLeftY = 0;
    prototype.interpolator = null;
    prototype.encodeMacroblock = function(pic, mbX, mbY, out, outMB, leftOutMB, topOutMB, qp, qpDelta) {
        var cw = pic.getColor().compWidth[1];
        var ch = pic.getColor().compHeight[1];
        if (this.sps.num_ref_frames > 1) {
            var refIdx = this.decideRef();
            CAVLCWriter.writeTE(out, refIdx, this.sps.num_ref_frames - 1);
        }
        var trAvb = mbY > 0 && mbX < this.sps.pic_width_in_mbs_minus1;
        var tlAvb = mbX > 0 && mbY > 0;
        var mvpx = this.median(this.mvLeftX, this.mvTopX[mbX], trAvb ? this.mvTopX[mbX + 1] : 0, tlAvb ? this.mvTopLeftX : 0, mbX > 0, mbY > 0, trAvb, tlAvb);
        var mvpy = this.median(this.mvLeftY, this.mvTopY[mbX], trAvb ? this.mvTopY[mbX + 1] : 0, tlAvb ? this.mvTopLeftY : 0, mbX > 0, mbY > 0, trAvb, tlAvb);
        var mv = this.mvEstimate(pic, mbX, mbY, mvpx, mvpy);
        this.mvTopLeftX = this.mvTopX[mbX];
        this.mvTopLeftY = this.mvTopY[mbX];
        this.mvTopX[mbX] = mv[0];
        this.mvTopY[mbX] = mv[1];
        this.mvLeftX = mv[0];
        this.mvLeftY = mv[1];
        CAVLCWriter.writeSE(out, mv[0] - mvpx);
        CAVLCWriter.writeSE(out, mv[1] - mvpy);
        var mbRef = Picture8Bit.create(16, 16, this.sps.chroma_format_idc);
        var mb = [new Int32Array(256), new Int32Array(256 >> (cw + ch)), new Int32Array(256 >> (cw + ch))];
        this.interpolator.getBlockLuma(this.ref, mbRef, 0, (mbX << 6) + mv[0], (mbY << 6) + mv[1], 16, 16);
        this.interpolator.getBlockChroma(this.ref.getPlaneData(1), this.ref.getPlaneWidth(1), this.ref.getPlaneHeight(1), mbRef.getPlaneData(1), 0, mbRef.getPlaneWidth(1), (mbX << 6) + mv[0], (mbY << 6) + mv[1], 8, 8);
        this.interpolator.getBlockChroma(this.ref.getPlaneData(2), this.ref.getPlaneWidth(2), this.ref.getPlaneHeight(2), mbRef.getPlaneData(2), 0, mbRef.getPlaneWidth(2), (mbX << 6) + mv[0], (mbY << 6) + mv[1], 8, 8);
        MBEncoderHelper.takeSubtract(pic.getPlaneData(0), pic.getPlaneWidth(0), pic.getPlaneHeight(0), mbX << 4, mbY << 4, mb[0], mbRef.getPlaneData(0), 16, 16);
        MBEncoderHelper.takeSubtract(pic.getPlaneData(1), pic.getPlaneWidth(1), pic.getPlaneHeight(1), mbX << (4 - cw), mbY << (4 - ch), mb[1], mbRef.getPlaneData(1), 16 >> cw, 16 >> ch);
        MBEncoderHelper.takeSubtract(pic.getPlaneData(2), pic.getPlaneWidth(2), pic.getPlaneHeight(2), mbX << (4 - cw), mbY << (4 - ch), mb[2], mbRef.getPlaneData(2), 16 >> cw, 16 >> ch);
        var codedBlockPattern = this.getCodedBlockPattern();
        CAVLCWriter.writeUE(out, H264Const.CODED_BLOCK_PATTERN_INTER_COLOR_INV[codedBlockPattern]);
        CAVLCWriter.writeSE(out, qpDelta);
        this.luma(pic, mb[0], mbX, mbY, out, qp, outMB.getNc());
        this.chroma(pic, mb[1], mb[2], mbX, mbY, out, qp);
        MBEncoderHelper.putBlk(outMB.getPixels().getPlaneData(0), mb[0], mbRef.getPlaneData(0), 4, 0, 0, 16, 16);
        MBEncoderHelper.putBlk(outMB.getPixels().getPlaneData(1), mb[1], mbRef.getPlaneData(1), 4 - cw, 0, 0, 16 >> cw, 16 >> ch);
        MBEncoderHelper.putBlk(outMB.getPixels().getPlaneData(2), mb[2], mbRef.getPlaneData(2), 4 - cw, 0, 0, 16 >> cw, 16 >> ch);
        Arrays.fill(outMB.getMx(), mv[0]);
        Arrays.fill(outMB.getMy(), mv[1]);
        outMB.setType(MBType.P_16x16);
        outMB.setQp(qp);
        new MBDeblocker().deblockMBP(outMB, leftOutMB, topOutMB);
    };
    prototype.median = function(a, b, c, d, aAvb, bAvb, cAvb, dAvb) {
        if (!cAvb) {
            c = d;
            cAvb = dAvb;
        }
        if (aAvb && !bAvb && !cAvb) {
            b = c = a;
            bAvb = cAvb = aAvb;
        }
        a = aAvb ? a : 0;
        b = bAvb ? b : 0;
        c = cAvb ? c : 0;
        return a + b + c - Math.min(Math.min(a, b), c) - Math.max(Math.max(a, b), c);
    };
    prototype.getCodedBlockPattern = function() {
        return 47;
    };
    prototype.mvEstimate = function(pic, mbX, mbY, mvpx, mvpy) {
        var patch = new Int8Array(256);
        MBEncoderHelper.take(pic.getPlaneData(0), pic.getPlaneWidth(0), pic.getPlaneHeight(0), mbX << 4, mbY << 4, patch, 16, 16);
        return this.me.estimate(this.ref, patch, mbX, mbY, mvpx, mvpy);
    };
    /**
     *  Decides which reference to use
     *  
     *  @return
     */
    prototype.decideRef = function() {
        return 0;
    };
    prototype.luma = function(pic, pix, mbX, mbY, out, qp, nc) {
        var ac = Array.apply(null, Array(16)).map(function() {
            return new Int32Array(16);
        });
        for (var i = 0; i < ac.length; i++) {
            for (var j = 0; j < H264Const.PIX_MAP_SPLIT_4x4[i].length; j++) {
                ac[i][j] = pix[H264Const.PIX_MAP_SPLIT_4x4[i][j]];
            }
            CoeffTransformer.fdct4x4(ac[i]);
        }
        this.writeAC(0, mbX, mbY, out, mbX << 2, mbY << 2, ac, qp);
        for (var i = 0; i < ac.length; i++) {
            CoeffTransformer.dequantizeAC(ac[i], qp);
            CoeffTransformer.idct4x4(ac[i]);
            for (var j = 0; j < H264Const.PIX_MAP_SPLIT_4x4[i].length; j++) 
                pix[H264Const.PIX_MAP_SPLIT_4x4[i][j]] = ac[i][j];
        }
    };
    prototype.chroma = function(pic, pix1, pix2, mbX, mbY, out, qp) {
        var cw = pic.getColor().compWidth[1];
        var ch = pic.getColor().compHeight[1];
        var ac1 = Array.apply(null, Array(16 >> (cw + ch))).map(function() {
            return new Int32Array(16);
        });
        var ac2 = Array.apply(null, Array(16 >> (cw + ch))).map(function() {
            return new Int32Array(16);
        });
        for (var i = 0; i < ac1.length; i++) {
            for (var j = 0; j < H264Const.PIX_MAP_SPLIT_2x2[i].length; j++) 
                ac1[i][j] = pix1[H264Const.PIX_MAP_SPLIT_2x2[i][j]];
        }
        for (var i = 0; i < ac2.length; i++) {
            for (var j = 0; j < H264Const.PIX_MAP_SPLIT_2x2[i].length; j++) 
                ac2[i][j] = pix2[H264Const.PIX_MAP_SPLIT_2x2[i][j]];
        }
        MBEncoderI16x16.chromaResidual(pic, mbX, mbY, out, qp, ac1, ac2, this.cavlc[1], this.cavlc[2], MBType.P_16x16, MBType.P_16x16);
        for (var i = 0; i < ac1.length; i++) {
            for (var j = 0; j < H264Const.PIX_MAP_SPLIT_2x2[i].length; j++) 
                pix1[H264Const.PIX_MAP_SPLIT_2x2[i][j]] = ac1[i][j];
        }
        for (var i = 0; i < ac2.length; i++) {
            for (var j = 0; j < H264Const.PIX_MAP_SPLIT_2x2[i].length; j++) 
                pix2[H264Const.PIX_MAP_SPLIT_2x2[i][j]] = ac2[i][j];
        }
    };
    prototype.writeAC = function(comp, mbX, mbY, out, mbLeftBlk, mbTopBlk, ac, qp) {
        for (var i = 0; i < ac.length; i++) {
            var blkI = H264Const.BLK_INV_MAP[i];
            CoeffTransformer.quantizeAC(ac[blkI], qp);
            this.cavlc[comp].writeACBlock(out, mbLeftBlk + H264Const.MB_BLK_OFF_LEFT[i], mbTopBlk + H264Const.MB_BLK_OFF_TOP[i], MBType.P_16x16, MBType.P_16x16, ac[blkI], H264Const.totalZeros16, 0, 16, CoeffTransformer.zigzag4x4);
        }
    };
}, {cavlc: "Array", sps: "SeqParameterSet", ref: "Picture8Bit", me: "MotionEstimator", mvTopX: "Int32Array", mvTopY: "Int32Array", interpolator: "BlockInterpolator"}, {});
/**
 *  A decoder for P skip macroblocks
 *  
 *  @author The JCodec project
 */
var MBlockSkipDecoder = function(mapper, bDirectDecoder, sh, di, poc, sharedState) {
    MBlockDecoderBase.call(this, sh, di, poc, sharedState);
    this.mapper = mapper;
    this.bDirectDecoder = bDirectDecoder;
};
MBlockSkipDecoder = stjs.extend(MBlockSkipDecoder, MBlockDecoderBase, [], function(constructor, prototype) {
    prototype.mapper = null;
    prototype.bDirectDecoder = null;
    prototype.decodeSkip = function(mBlock, refs, mb, sliceType) {
        var mbX = this.mapper.getMbX(mBlock.mbIdx);
        var mbY = this.mapper.getMbY(mBlock.mbIdx);
        var mbAddr = this.mapper.getAddress(mBlock.mbIdx);
        var x = Array.apply(null, Array(2)).map(function() {
            return Array.apply(null, Array(16)).map(function() {
                return new Int32Array(3);
            });
        });
        var pp = Array(4);
        for (var i = 0; i < 16; i++) 
            x[0][i][2] = x[1][i][2] = -1;
        if (sliceType == SliceType.P) {
            this.predictPSkip(refs, mbX, mbY, this.mapper.leftAvailable(mBlock.mbIdx), this.mapper.topAvailable(mBlock.mbIdx), this.mapper.topLeftAvailable(mBlock.mbIdx), this.mapper.topRightAvailable(mBlock.mbIdx), x, mb);
            Arrays.fill(pp, H264Const.PartPred.L0);
        } else {
            this.bDirectDecoder.predictBDirect(refs, mbX, mbY, this.mapper.leftAvailable(mBlock.mbIdx), this.mapper.topAvailable(mBlock.mbIdx), this.mapper.topLeftAvailable(mBlock.mbIdx), this.mapper.topRightAvailable(mBlock.mbIdx), x, pp, mb, H264Const.identityMapping4);
            MBlockDecoderUtils.savePrediction8x8(this.s, mbX, x[0], 0);
            MBlockDecoderUtils.savePrediction8x8(this.s, mbX, x[1], 1);
        }
        this.decodeChromaSkip(refs, x, pp, mbX, mbY, mb);
        MBlockDecoderUtils.collectPredictors(this.s, mb, mbX);
        MBlockDecoderUtils.saveMvs(this.di, x, mbX, mbY);
        this.di.mbTypes[mbAddr] = mBlock.curMbType;
        this.di.mbQps[0][mbAddr] = this.s.qp;
        this.di.mbQps[1][mbAddr] = this.calcQpChroma(this.s.qp, this.s.chromaQpOffset[0]);
        this.di.mbQps[2][mbAddr] = this.calcQpChroma(this.s.qp, this.s.chromaQpOffset[1]);
    };
    prototype.predictPSkip = function(refs, mbX, mbY, lAvb, tAvb, tlAvb, trAvb, x, mb) {
        var mvX = 0, mvY = 0;
        if (lAvb && tAvb) {
            var b = this.s.mvTop[0][mbX << 2];
            var a = this.s.mvLeft[0][0];
            if ((a[0] != 0 || a[1] != 0 || a[2] != 0) && (b[0] != 0 || b[1] != 0 || b[2] != 0)) {
                mvX = MBlockDecoderUtils.calcMVPredictionMedian(a, b, this.s.mvTop[0][(mbX << 2) + 4], this.s.mvTopLeft[0], lAvb, tAvb, trAvb, tlAvb, 0, 0);
                mvY = MBlockDecoderUtils.calcMVPredictionMedian(a, b, this.s.mvTop[0][(mbX << 2) + 4], this.s.mvTopLeft[0], lAvb, tAvb, trAvb, tlAvb, 0, 1);
            }
        }
        var xx = mbX << 2;
        MBlockDecoderUtils.copyVect(this.s.mvTopLeft[0], this.s.mvTop[0][xx + 3]);
        MBlockDecoderUtils.saveVect(this.s.mvTop[0], xx, xx + 4, mvX, mvY, 0);
        MBlockDecoderUtils.saveVect(this.s.mvLeft[0], 0, 4, mvX, mvY, 0);
        for (var i = 0; i < 16; i++) {
            x[0][i][0] = mvX;
            x[0][i][1] = mvY;
            x[0][i][2] = 0;
        }
        this.interpolator.getBlockLuma(refs[0][0], mb, 0, (mbX << 6) + mvX, (mbY << 6) + mvY, 16, 16);
        PredictionMerger.mergePrediction(this.sh, 0, 0, H264Const.PartPred.L0, 0, mb.getPlaneData(0), null, 0, 16, 16, 16, mb.getPlaneData(0), refs, this.poc);
    };
    prototype.decodeChromaSkip = function(reference, vectors, pp, mbX, mbY, mb) {
        this.predictChromaInter(reference, vectors, mbX << 3, mbY << 3, 1, mb, pp);
        this.predictChromaInter(reference, vectors, mbX << 3, mbY << 3, 2, mb, pp);
    };
}, {mapper: "Mapper", bDirectDecoder: "MBlockDecoderBDirect", s: "DecoderState", sh: "SliceHeader", di: "DeblockerInput", interpolator: "BlockInterpolator", mbb: "Array"}, {});
/**
 *  A decoder for Inter 16x16, 16x8 and 8x16 macroblocks
 *  
 *  @author The JCodec project
 */
var MBlockDecoderInter = function(mapper, sh, di, poc, decoderState) {
    MBlockDecoderBase.call(this, sh, di, poc, decoderState);
    this.mapper = mapper;
};
MBlockDecoderInter = stjs.extend(MBlockDecoderInter, MBlockDecoderBase, [], function(constructor, prototype) {
    prototype.mapper = null;
    prototype.decode16x16 = function(mBlock, mb, refs, p0) {
        var mbX = this.mapper.getMbX(mBlock.mbIdx);
        var mbY = this.mapper.getMbY(mBlock.mbIdx);
        var leftAvailable = this.mapper.leftAvailable(mBlock.mbIdx);
        var topAvailable = this.mapper.topAvailable(mBlock.mbIdx);
        var topLeftAvailable = this.mapper.topLeftAvailable(mBlock.mbIdx);
        var topRightAvailable = this.mapper.topRightAvailable(mBlock.mbIdx);
        var address = this.mapper.getAddress(mBlock.mbIdx);
        var x = Array(2);
        var xx = mbX << 2;
        for (var list = 0; list < 2; list++) {
            this.predictInter16x16(mBlock, this.mbb[list], refs, mbX, mbY, leftAvailable, topAvailable, topLeftAvailable, topRightAvailable, x, xx, list, p0);
        }
        PredictionMerger.mergePrediction(this.sh, x[0][0][2], x[1][0][2], p0, 0, this.mbb[0].getPlaneData(0), this.mbb[1].getPlaneData(0), 0, 16, 16, 16, mb.getPlaneData(0), refs, this.poc);
        var partPreds = [p0, p0, p0, p0];
        this.predictChromaInter(refs, x, mbX << 3, mbY << 3, 1, mb, partPreds);
        this.predictChromaInter(refs, x, mbX << 3, mbY << 3, 2, mb, partPreds);
        this.residualInter(mBlock, refs, leftAvailable, topAvailable, mbX, mbY, x, partPreds, this.mapper.getAddress(mBlock.mbIdx));
        MBlockDecoderUtils.mergeResidual(mb, mBlock.ac, mBlock.transform8x8Used ? H264Const.COMP_BLOCK_8x8_LUT : H264Const.COMP_BLOCK_4x4_LUT, mBlock.transform8x8Used ? H264Const.COMP_POS_8x8_LUT : H264Const.COMP_POS_4x4_LUT);
        MBlockDecoderUtils.collectPredictors(this.s, mb, mbX);
        this.di.mbTypes[address] = mBlock.curMbType;
    };
    prototype.predictInter8x16 = function(mBlock, mb, references, mbX, mbY, leftAvailable, topAvailable, tlAvailable, trAvailable, x, list, p0, p1) {
        var xx = mbX << 2;
        var mvX1 = 0, mvY1 = 0, r1 = -1, mvX2 = 0, mvY2 = 0, r2 = -1;
        if (H264Const.usesList(p0, list)) {
            var mvpX1 = this.calcMVPrediction8x16Left(this.s.mvLeft[list][0], this.s.mvTop[list][mbX << 2], this.s.mvTop[list][(mbX << 2) + 2], this.s.mvTopLeft[list], leftAvailable, topAvailable, topAvailable, tlAvailable, mBlock.pb168x168.refIdx1[list], 0);
            var mvpY1 = this.calcMVPrediction8x16Left(this.s.mvLeft[list][0], this.s.mvTop[list][mbX << 2], this.s.mvTop[list][(mbX << 2) + 2], this.s.mvTopLeft[list], leftAvailable, topAvailable, topAvailable, tlAvailable, mBlock.pb168x168.refIdx1[list], 1);
            mvX1 = mBlock.pb168x168.mvdX1[list] + mvpX1;
            mvY1 = mBlock.pb168x168.mvdY1[list] + mvpY1;
            MBlockDecoderUtils.debugPrint("MVP: (%d, %d), MVD: (%d, %d), MV: (%d,%d,%d)", mvpX1, mvpY1, mBlock.pb168x168.mvdX1[list], mBlock.pb168x168.mvdY1[list], mvX1, mvY1, mBlock.pb168x168.refIdx1[list]);
            this.interpolator.getBlockLuma(references[list][mBlock.pb168x168.refIdx1[list]], mb, 0, (mbX << 6) + mvX1, (mbY << 6) + mvY1, 8, 16);
            r1 = mBlock.pb168x168.refIdx1[list];
        }
        var v1 = new Int32Array([mvX1, mvY1, r1]);
        if (H264Const.usesList(p1, list)) {
            var mvpX2 = this.calcMVPrediction8x16Right(v1, this.s.mvTop[list][(mbX << 2) + 2], this.s.mvTop[list][(mbX << 2) + 4], this.s.mvTop[list][(mbX << 2) + 1], true, topAvailable, trAvailable, topAvailable, mBlock.pb168x168.refIdx2[list], 0);
            var mvpY2 = this.calcMVPrediction8x16Right(v1, this.s.mvTop[list][(mbX << 2) + 2], this.s.mvTop[list][(mbX << 2) + 4], this.s.mvTop[list][(mbX << 2) + 1], true, topAvailable, trAvailable, topAvailable, mBlock.pb168x168.refIdx2[list], 1);
            mvX2 = mBlock.pb168x168.mvdX2[list] + mvpX2;
            mvY2 = mBlock.pb168x168.mvdY2[list] + mvpY2;
            MBlockDecoderUtils.debugPrint("MVP: (" + mvpX2 + ", " + mvpY2 + "), MVD: (" + mBlock.pb168x168.mvdX2[list] + ", " + mBlock.pb168x168.mvdY2[list] + "), MV: (" + mvX2 + "," + mvY2 + "," + mBlock.pb168x168.refIdx2[list] + ")");
            this.interpolator.getBlockLuma(references[list][mBlock.pb168x168.refIdx2[list]], mb, 8, (mbX << 6) + 32 + mvX2, (mbY << 6) + mvY2, 8, 16);
            r2 = mBlock.pb168x168.refIdx2[list];
        }
        var v2 = new Int32Array([mvX2, mvY2, r2]);
        MBlockDecoderUtils.copyVect(this.s.mvTopLeft[list], this.s.mvTop[list][xx + 3]);
        MBlockDecoderUtils.saveVect(this.s.mvTop[list], xx, xx + 2, mvX1, mvY1, r1);
        MBlockDecoderUtils.saveVect(this.s.mvTop[list], xx + 2, xx + 4, mvX2, mvY2, r2);
        MBlockDecoderUtils.saveVect(this.s.mvLeft[list], 0, 4, mvX2, mvY2, r2);
        x[list] = [v1, v1, v2, v2, v1, v1, v2, v2, v1, v1, v2, v2, v1, v1, v2, v2];
    };
    prototype.predictInter16x8 = function(mBlock, mb, references, mbX, mbY, leftAvailable, topAvailable, tlAvailable, trAvailable, xx, x, p0, p1, list) {
        var mvX1 = 0, mvY1 = 0, mvX2 = 0, mvY2 = 0, r1 = -1, r2 = -1;
        if (H264Const.usesList(p0, list)) {
            var mvpX1 = this.calcMVPrediction16x8Top(this.s.mvLeft[list][0], this.s.mvTop[list][mbX << 2], this.s.mvTop[list][(mbX << 2) + 4], this.s.mvTopLeft[list], leftAvailable, topAvailable, trAvailable, tlAvailable, mBlock.pb168x168.refIdx1[list], 0);
            var mvpY1 = this.calcMVPrediction16x8Top(this.s.mvLeft[list][0], this.s.mvTop[list][mbX << 2], this.s.mvTop[list][(mbX << 2) + 4], this.s.mvTopLeft[list], leftAvailable, topAvailable, trAvailable, tlAvailable, mBlock.pb168x168.refIdx1[list], 1);
            mvX1 = mBlock.pb168x168.mvdX1[list] + mvpX1;
            mvY1 = mBlock.pb168x168.mvdY1[list] + mvpY1;
            MBlockDecoderUtils.debugPrint("MVP: (%d, %d), MVD: (%d, %d), MV: (%d,%d,%d)", mvpX1, mvpY1, mBlock.pb168x168.mvdX1[list], mBlock.pb168x168.mvdY1[list], mvX1, mvY1, mBlock.pb168x168.refIdx1[list]);
            this.interpolator.getBlockLuma(references[list][mBlock.pb168x168.refIdx1[list]], mb, 0, (mbX << 6) + mvX1, (mbY << 6) + mvY1, 16, 8);
            r1 = mBlock.pb168x168.refIdx1[list];
        }
        var v1 = new Int32Array([mvX1, mvY1, r1]);
        if (H264Const.usesList(p1, list)) {
            var mvpX2 = this.calcMVPrediction16x8Bottom(this.s.mvLeft[list][2], v1, null, this.s.mvLeft[list][1], leftAvailable, true, false, leftAvailable, mBlock.pb168x168.refIdx2[list], 0);
            var mvpY2 = this.calcMVPrediction16x8Bottom(this.s.mvLeft[list][2], v1, null, this.s.mvLeft[list][1], leftAvailable, true, false, leftAvailable, mBlock.pb168x168.refIdx2[list], 1);
            mvX2 = mBlock.pb168x168.mvdX2[list] + mvpX2;
            mvY2 = mBlock.pb168x168.mvdY2[list] + mvpY2;
            MBlockDecoderUtils.debugPrint("MVP: (%d, %d), MVD: (%d, %d), MV: (%d,%d,%d)", mvpX2, mvpY2, mBlock.pb168x168.mvdX2[list], mBlock.pb168x168.mvdY2[list], mvX2, mvY2, mBlock.pb168x168.refIdx2[list]);
            this.interpolator.getBlockLuma(references[list][mBlock.pb168x168.refIdx2[list]], mb, 128, (mbX << 6) + mvX2, (mbY << 6) + 32 + mvY2, 16, 8);
            r2 = mBlock.pb168x168.refIdx2[list];
        }
        var v2 = new Int32Array([mvX2, mvY2, r2]);
        MBlockDecoderUtils.copyVect(this.s.mvTopLeft[list], this.s.mvTop[list][xx + 3]);
        MBlockDecoderUtils.saveVect(this.s.mvLeft[list], 0, 2, mvX1, mvY1, r1);
        MBlockDecoderUtils.saveVect(this.s.mvLeft[list], 2, 4, mvX2, mvY2, r2);
        MBlockDecoderUtils.saveVect(this.s.mvTop[list], xx, xx + 4, mvX2, mvY2, r2);
        x[list] = [v1, v1, v1, v1, v1, v1, v1, v1, v2, v2, v2, v2, v2, v2, v2, v2];
    };
    prototype.decode16x8 = function(mBlock, mb, refs, p0, p1) {
        var mbX = this.mapper.getMbX(mBlock.mbIdx);
        var mbY = this.mapper.getMbY(mBlock.mbIdx);
        var leftAvailable = this.mapper.leftAvailable(mBlock.mbIdx);
        var topAvailable = this.mapper.topAvailable(mBlock.mbIdx);
        var topLeftAvailable = this.mapper.topLeftAvailable(mBlock.mbIdx);
        var topRightAvailable = this.mapper.topRightAvailable(mBlock.mbIdx);
        var address = this.mapper.getAddress(mBlock.mbIdx);
        var x = Array(2);
        var xx = mbX << 2;
        for (var list = 0; list < 2; list++) {
            this.predictInter16x8(mBlock, this.mbb[list], refs, mbX, mbY, leftAvailable, topAvailable, topLeftAvailable, topRightAvailable, xx, x, p0, p1, list);
        }
        PredictionMerger.mergePrediction(this.sh, x[0][0][2], x[1][0][2], p0, 0, this.mbb[0].getPlaneData(0), this.mbb[1].getPlaneData(0), 0, 16, 16, 8, mb.getPlaneData(0), refs, this.poc);
        PredictionMerger.mergePrediction(this.sh, x[0][8][2], x[1][8][2], p1, 0, this.mbb[0].getPlaneData(0), this.mbb[1].getPlaneData(0), 128, 16, 16, 8, mb.getPlaneData(0), refs, this.poc);
        var partPreds = [p0, p0, p1, p1];
        this.predictChromaInter(refs, x, mbX << 3, mbY << 3, 1, mb, partPreds);
        this.predictChromaInter(refs, x, mbX << 3, mbY << 3, 2, mb, partPreds);
        this.residualInter(mBlock, refs, leftAvailable, topAvailable, mbX, mbY, x, partPreds, this.mapper.getAddress(mBlock.mbIdx));
        MBlockDecoderUtils.mergeResidual(mb, mBlock.ac, mBlock.transform8x8Used ? H264Const.COMP_BLOCK_8x8_LUT : H264Const.COMP_BLOCK_4x4_LUT, mBlock.transform8x8Used ? H264Const.COMP_POS_8x8_LUT : H264Const.COMP_POS_4x4_LUT);
        MBlockDecoderUtils.collectPredictors(this.s, mb, mbX);
        this.di.mbTypes[address] = mBlock.curMbType;
    };
    prototype.decode8x16 = function(mBlock, mb, refs, p0, p1) {
        var mbX = this.mapper.getMbX(mBlock.mbIdx);
        var mbY = this.mapper.getMbY(mBlock.mbIdx);
        var leftAvailable = this.mapper.leftAvailable(mBlock.mbIdx);
        var topAvailable = this.mapper.topAvailable(mBlock.mbIdx);
        var topLeftAvailable = this.mapper.topLeftAvailable(mBlock.mbIdx);
        var topRightAvailable = this.mapper.topRightAvailable(mBlock.mbIdx);
        var address = this.mapper.getAddress(mBlock.mbIdx);
        var x = Array(2);
        for (var list = 0; list < 2; list++) {
            this.predictInter8x16(mBlock, this.mbb[list], refs, mbX, mbY, leftAvailable, topAvailable, topLeftAvailable, topRightAvailable, x, list, p0, p1);
        }
        PredictionMerger.mergePrediction(this.sh, x[0][0][2], x[1][0][2], p0, 0, this.mbb[0].getPlaneData(0), this.mbb[1].getPlaneData(0), 0, 16, 8, 16, mb.getPlaneData(0), refs, this.poc);
        PredictionMerger.mergePrediction(this.sh, x[0][2][2], x[1][2][2], p1, 0, this.mbb[0].getPlaneData(0), this.mbb[1].getPlaneData(0), 8, 16, 8, 16, mb.getPlaneData(0), refs, this.poc);
        var predType = [p0, p1, p0, p1];
        this.predictChromaInter(refs, x, mbX << 3, mbY << 3, 1, mb, predType);
        this.predictChromaInter(refs, x, mbX << 3, mbY << 3, 2, mb, predType);
        this.residualInter(mBlock, refs, leftAvailable, topAvailable, mbX, mbY, x, predType, this.mapper.getAddress(mBlock.mbIdx));
        MBlockDecoderUtils.mergeResidual(mb, mBlock.ac, mBlock.transform8x8Used ? H264Const.COMP_BLOCK_8x8_LUT : H264Const.COMP_BLOCK_4x4_LUT, mBlock.transform8x8Used ? H264Const.COMP_POS_8x8_LUT : H264Const.COMP_POS_4x4_LUT);
        MBlockDecoderUtils.collectPredictors(this.s, mb, mbX);
        this.di.mbTypes[address] = mBlock.curMbType;
    };
    prototype.predictInter16x16 = function(mBlock, mb, references, mbX, mbY, leftAvailable, topAvailable, tlAvailable, trAvailable, x, xx, list, curPred) {
        var mvX = 0, mvY = 0, r = -1;
        if (H264Const.usesList(curPred, list)) {
            var mvpX = MBlockDecoderUtils.calcMVPredictionMedian(this.s.mvLeft[list][0], this.s.mvTop[list][mbX << 2], this.s.mvTop[list][(mbX << 2) + 4], this.s.mvTopLeft[list], leftAvailable, topAvailable, trAvailable, tlAvailable, mBlock.pb16x16.refIdx[list], 0);
            var mvpY = MBlockDecoderUtils.calcMVPredictionMedian(this.s.mvLeft[list][0], this.s.mvTop[list][mbX << 2], this.s.mvTop[list][(mbX << 2) + 4], this.s.mvTopLeft[list], leftAvailable, topAvailable, trAvailable, tlAvailable, mBlock.pb16x16.refIdx[list], 1);
            mvX = mBlock.pb16x16.mvdX[list] + mvpX;
            mvY = mBlock.pb16x16.mvdY[list] + mvpY;
            MBlockDecoderUtils.debugPrint("MVP: (%d, %d), MVD: (%d, %d), MV: (%d,%d,%d)", mvpX, mvpY, mBlock.pb16x16.mvdX[list], mBlock.pb16x16.mvdY[list], mvX, mvY, mBlock.pb16x16.refIdx[list]);
            r = mBlock.pb16x16.refIdx[list];
            this.interpolator.getBlockLuma(references[list][r], mb, 0, (mbX << 6) + mvX, (mbY << 6) + mvY, 16, 16);
        }
        MBlockDecoderUtils.copyVect(this.s.mvTopLeft[list], this.s.mvTop[list][xx + 3]);
        MBlockDecoderUtils.saveVect(this.s.mvTop[list], xx, xx + 4, mvX, mvY, r);
        MBlockDecoderUtils.saveVect(this.s.mvLeft[list], 0, 4, mvX, mvY, r);
        var v = new Int32Array([mvX, mvY, r]);
        x[list] = [v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v];
    };
    prototype.residualInter = function(mBlock, refs, leftAvailable, topAvailable, mbX, mbY, x, pp, mbAddr) {
        if (mBlock.cbpLuma() > 0 || mBlock.cbpChroma() > 0) {
            this.s.qp = (this.s.qp + mBlock.mbQPDelta + 52) % 52;
        }
        this.di.mbQps[0][mbAddr] = this.s.qp;
        this.residualLuma(mBlock, leftAvailable, topAvailable, mbX, mbY);
        MBlockDecoderUtils.saveMvs(this.di, x, mbX, mbY);
        if (this.s.chromaFormat != ColorSpace.MONO) {
            var qp1 = this.calcQpChroma(this.s.qp, this.s.chromaQpOffset[0]);
            var qp2 = this.calcQpChroma(this.s.qp, this.s.chromaQpOffset[1]);
            this.decodeChromaResidual(mBlock, leftAvailable, topAvailable, mbX, mbY, qp1, qp2);
            this.di.mbQps[1][mbAddr] = qp1;
            this.di.mbQps[2][mbAddr] = qp2;
        }
        this.di.tr8x8Used[mbAddr] = mBlock.transform8x8Used;
    };
    prototype.calcMVPrediction16x8Top = function(a, b, c, d, aAvb, bAvb, cAvb, dAvb, refIdx, comp) {
        if (bAvb && b[2] == refIdx) 
            return b[comp];
         else 
            return MBlockDecoderUtils.calcMVPredictionMedian(a, b, c, d, aAvb, bAvb, cAvb, dAvb, refIdx, comp);
    };
    prototype.calcMVPrediction16x8Bottom = function(a, b, c, d, aAvb, bAvb, cAvb, dAvb, refIdx, comp) {
        if (aAvb && a[2] == refIdx) 
            return a[comp];
         else 
            return MBlockDecoderUtils.calcMVPredictionMedian(a, b, c, d, aAvb, bAvb, cAvb, dAvb, refIdx, comp);
    };
    prototype.calcMVPrediction8x16Left = function(a, b, c, d, aAvb, bAvb, cAvb, dAvb, refIdx, comp) {
        if (aAvb && a[2] == refIdx) 
            return a[comp];
         else 
            return MBlockDecoderUtils.calcMVPredictionMedian(a, b, c, d, aAvb, bAvb, cAvb, dAvb, refIdx, comp);
    };
    prototype.calcMVPrediction8x16Right = function(a, b, c, d, aAvb, bAvb, cAvb, dAvb, refIdx, comp) {
        var lc = cAvb ? c : (dAvb ? d : MBlockDecoderUtils.NULL_VECTOR);
        if (lc[2] == refIdx) 
            return lc[comp];
         else 
            return MBlockDecoderUtils.calcMVPredictionMedian(a, b, c, d, aAvb, bAvb, cAvb, dAvb, refIdx, comp);
    };
}, {mapper: "Mapper", s: "DecoderState", sh: "SliceHeader", di: "DeblockerInput", interpolator: "BlockInterpolator", mbb: "Array"}, {});
/**
 *  A decoder for Inter 16x16, 16x8 and 8x16 macroblocks
 *  
 *  @author The JCodec project
 */
var MBlockDecoderInter8x8 = function(mapper, bDirectDecoder, sh, di, poc, decoderState) {
    MBlockDecoderBase.call(this, sh, di, poc, decoderState);
    this.mapper = mapper;
    this.bDirectDecoder = bDirectDecoder;
};
MBlockDecoderInter8x8 = stjs.extend(MBlockDecoderInter8x8, MBlockDecoderBase, [], function(constructor, prototype) {
    prototype.mapper = null;
    prototype.bDirectDecoder = null;
    prototype.decode = function(mBlock, references, mb, sliceType, ref0) {
        var mbX = this.mapper.getMbX(mBlock.mbIdx);
        var mbY = this.mapper.getMbY(mBlock.mbIdx);
        var leftAvailable = this.mapper.leftAvailable(mBlock.mbIdx);
        var topAvailable = this.mapper.topAvailable(mBlock.mbIdx);
        var mbAddr = this.mapper.getAddress(mBlock.mbIdx);
        var topLeftAvailable = this.mapper.topLeftAvailable(mBlock.mbIdx);
        var topRightAvailable = this.mapper.topRightAvailable(mBlock.mbIdx);
        var x = Array.apply(null, Array(2)).map(function() {
            return Array.apply(null, Array(16)).map(function() {
                return new Int32Array(3);
            });
        });
        var pp = Array(4);
        for (var i = 0; i < 16; i++) 
            x[0][i][2] = x[1][i][2] = -1;
        if (sliceType == SliceType.P) {
            this.predict8x8P(mBlock, references[0], mb, ref0, mbX, mbY, leftAvailable, topAvailable, topLeftAvailable, topRightAvailable, x, pp);
        } else {
            this.predict8x8B(mBlock, references, mb, ref0, mbX, mbY, leftAvailable, topAvailable, topLeftAvailable, topRightAvailable, x, pp);
        }
        this.predictChromaInter(references, x, mbX << 3, mbY << 3, 1, mb, pp);
        this.predictChromaInter(references, x, mbX << 3, mbY << 3, 2, mb, pp);
        if (mBlock.cbpLuma() > 0 || mBlock.cbpChroma() > 0) {
            this.s.qp = (this.s.qp + mBlock.mbQPDelta + 52) % 52;
        }
        this.di.mbQps[0][mbAddr] = this.s.qp;
        this.residualLuma(mBlock, leftAvailable, topAvailable, mbX, mbY);
        MBlockDecoderUtils.saveMvs(this.di, x, mbX, mbY);
        var qp1 = this.calcQpChroma(this.s.qp, this.s.chromaQpOffset[0]);
        var qp2 = this.calcQpChroma(this.s.qp, this.s.chromaQpOffset[1]);
        this.decodeChromaResidual(mBlock, leftAvailable, topAvailable, mbX, mbY, qp1, qp2);
        this.di.mbQps[1][mbAddr] = qp1;
        this.di.mbQps[2][mbAddr] = qp2;
        MBlockDecoderUtils.mergeResidual(mb, mBlock.ac, mBlock.transform8x8Used ? H264Const.COMP_BLOCK_8x8_LUT : H264Const.COMP_BLOCK_4x4_LUT, mBlock.transform8x8Used ? H264Const.COMP_POS_8x8_LUT : H264Const.COMP_POS_4x4_LUT);
        MBlockDecoderUtils.collectPredictors(this.s, mb, mbX);
        this.di.mbTypes[mbAddr] = mBlock.curMbType;
        this.di.tr8x8Used[mbAddr] = mBlock.transform8x8Used;
    };
    prototype.predict8x8P = function(mBlock, references, mb, ref0, mbX, mbY, leftAvailable, topAvailable, tlAvailable, topRightAvailable, x, pp) {
        this.decodeSubMb8x8(mBlock, 0, mBlock.pb8x8.subMbTypes[0], references, mbX << 6, mbY << 6, x[0], this.s.mvTopLeft[0], this.s.mvTop[0][mbX << 2], this.s.mvTop[0][(mbX << 2) + 1], this.s.mvTop[0][(mbX << 2) + 2], this.s.mvLeft[0][0], this.s.mvLeft[0][1], tlAvailable, topAvailable, topAvailable, leftAvailable, x[0][0], x[0][1], x[0][4], x[0][5], mBlock.pb8x8.refIdx[0][0], mb, 0, 0);
        this.decodeSubMb8x8(mBlock, 1, mBlock.pb8x8.subMbTypes[1], references, (mbX << 6) + 32, mbY << 6, x[0], this.s.mvTop[0][(mbX << 2) + 1], this.s.mvTop[0][(mbX << 2) + 2], this.s.mvTop[0][(mbX << 2) + 3], this.s.mvTop[0][(mbX << 2) + 4], x[0][1], x[0][5], topAvailable, topAvailable, topRightAvailable, true, x[0][2], x[0][3], x[0][6], x[0][7], mBlock.pb8x8.refIdx[0][1], mb, 8, 0);
        this.decodeSubMb8x8(mBlock, 2, mBlock.pb8x8.subMbTypes[2], references, mbX << 6, (mbY << 6) + 32, x[0], this.s.mvLeft[0][1], x[0][4], x[0][5], x[0][6], this.s.mvLeft[0][2], this.s.mvLeft[0][3], leftAvailable, true, true, leftAvailable, x[0][8], x[0][9], x[0][12], x[0][13], mBlock.pb8x8.refIdx[0][2], mb, 128, 0);
        this.decodeSubMb8x8(mBlock, 3, mBlock.pb8x8.subMbTypes[3], references, (mbX << 6) + 32, (mbY << 6) + 32, x[0], x[0][5], x[0][6], x[0][7], null, x[0][9], x[0][13], true, true, false, true, x[0][10], x[0][11], x[0][14], x[0][15], mBlock.pb8x8.refIdx[0][3], mb, 136, 0);
        MBlockDecoderUtils.savePrediction8x8(this.s, mbX, x[0], 0);
        Arrays.fill(pp, H264Const.PartPred.L0);
    };
    prototype.predict8x8B = function(mBlock, refs, mb, ref0, mbX, mbY, leftAvailable, topAvailable, tlAvailable, topRightAvailable, x, p) {
        for (var i = 0; i < 4; i++) {
            p[i] = H264Const.bPartPredModes[mBlock.pb8x8.subMbTypes[i]];
        }
        var blk8x8X = mbX << 1;
        var _pp = Array(4);
        for (var i = 0; i < 4; i++) {
            if (p[i] == H264Const.PartPred.Direct) 
                this.bDirectDecoder.predictBDirect(refs, mbX, mbY, leftAvailable, topAvailable, tlAvailable, topRightAvailable, x, _pp, mb, H264Const.ARRAY[i]);
        }
        for (var list = 0; list < 2; list++) {
            if (H264Const.usesList(p[0], list)) {
                this.decodeSubMb8x8(mBlock, 0, H264Const.bSubMbTypes[mBlock.pb8x8.subMbTypes[0]], refs[list], mbX << 6, mbY << 6, x[list], this.s.mvTopLeft[list], this.s.mvTop[list][mbX << 2], this.s.mvTop[list][(mbX << 2) + 1], this.s.mvTop[list][(mbX << 2) + 2], this.s.mvLeft[list][0], this.s.mvLeft[list][1], tlAvailable, topAvailable, topAvailable, leftAvailable, x[list][0], x[list][1], x[list][4], x[list][5], mBlock.pb8x8.refIdx[list][0], this.mbb[list], 0, list);
            }
            if (H264Const.usesList(p[1], list)) {
                this.decodeSubMb8x8(mBlock, 1, H264Const.bSubMbTypes[mBlock.pb8x8.subMbTypes[1]], refs[list], (mbX << 6) + 32, mbY << 6, x[list], this.s.mvTop[list][(mbX << 2) + 1], this.s.mvTop[list][(mbX << 2) + 2], this.s.mvTop[list][(mbX << 2) + 3], this.s.mvTop[list][(mbX << 2) + 4], x[list][1], x[list][5], topAvailable, topAvailable, topRightAvailable, true, x[list][2], x[list][3], x[list][6], x[list][7], mBlock.pb8x8.refIdx[list][1], this.mbb[list], 8, list);
            }
            if (H264Const.usesList(p[2], list)) {
                this.decodeSubMb8x8(mBlock, 2, H264Const.bSubMbTypes[mBlock.pb8x8.subMbTypes[2]], refs[list], mbX << 6, (mbY << 6) + 32, x[list], this.s.mvLeft[list][1], x[list][4], x[list][5], x[list][6], this.s.mvLeft[list][2], this.s.mvLeft[list][3], leftAvailable, true, true, leftAvailable, x[list][8], x[list][9], x[list][12], x[list][13], mBlock.pb8x8.refIdx[list][2], this.mbb[list], 128, list);
            }
            if (H264Const.usesList(p[3], list)) {
                this.decodeSubMb8x8(mBlock, 3, H264Const.bSubMbTypes[mBlock.pb8x8.subMbTypes[3]], refs[list], (mbX << 6) + 32, (mbY << 6) + 32, x[list], x[list][5], x[list][6], x[list][7], null, x[list][9], x[list][13], true, true, false, true, x[list][10], x[list][11], x[list][14], x[list][15], mBlock.pb8x8.refIdx[list][3], this.mbb[list], 136, list);
            }
        }
        for (var i = 0; i < 4; i++) {
            var blk4x4 = H264Const.BLK8x8_BLOCKS[i][0];
            PredictionMerger.mergePrediction(this.sh, x[0][blk4x4][2], x[1][blk4x4][2], p[i], 0, this.mbb[0].getPlaneData(0), this.mbb[1].getPlaneData(0), H264Const.BLK_8x8_MB_OFF_LUMA[i], 16, 8, 8, mb.getPlaneData(0), refs, this.poc);
        }
        MBlockDecoderUtils.savePrediction8x8(this.s, mbX, x[0], 0);
        MBlockDecoderUtils.savePrediction8x8(this.s, mbX, x[1], 1);
        for (var i = 0; i < 4; i++) 
            if (p[i] == H264Const.PartPred.Direct) 
                p[i] = _pp[i];
    };
    prototype.decodeSubMb8x8 = function(mBlock, partNo, subMbType, references, offX, offY, x, tl, t0, t1, tr, l0, l1, tlAvb, tAvb, trAvb, lAvb, x00, x01, x10, x11, refIdx, mb, off, list) {
        x00[2] = x01[2] = x10[2] = x11[2] = refIdx;
        switch (subMbType) {
            case 3:
                this.decodeSub4x4(mBlock, partNo, references, offX, offY, tl, t0, t1, tr, l0, l1, tlAvb, tAvb, trAvb, lAvb, x00, x01, x10, x11, refIdx, mb, off, list);
                break;
            case 2:
                this.decodeSub4x8(mBlock, partNo, references, offX, offY, tl, t0, t1, tr, l0, tlAvb, tAvb, trAvb, lAvb, x00, x01, x10, x11, refIdx, mb, off, list);
                break;
            case 1:
                this.decodeSub8x4(mBlock, partNo, references, offX, offY, tl, t0, tr, l0, l1, tlAvb, tAvb, trAvb, lAvb, x00, x01, x10, x11, refIdx, mb, off, list);
                break;
            case 0:
                this.decodeSub8x8(mBlock, partNo, references, offX, offY, tl, t0, tr, l0, tlAvb, tAvb, trAvb, lAvb, x00, x01, x10, x11, refIdx, mb, off, list);
        }
    };
    prototype.decodeSub8x8 = function(mBlock, partNo, references, offX, offY, tl, t0, tr, l0, tlAvb, tAvb, trAvb, lAvb, x00, x01, x10, x11, refIdx, mb, off, list) {
        var mvpX = MBlockDecoderUtils.calcMVPredictionMedian(l0, t0, tr, tl, lAvb, tAvb, trAvb, tlAvb, refIdx, 0);
        var mvpY = MBlockDecoderUtils.calcMVPredictionMedian(l0, t0, tr, tl, lAvb, tAvb, trAvb, tlAvb, refIdx, 1);
        x00[0] = x01[0] = x10[0] = x11[0] = mBlock.pb8x8.mvdX1[list][partNo] + mvpX;
        x00[1] = x01[1] = x10[1] = x11[1] = mBlock.pb8x8.mvdY1[list][partNo] + mvpY;
        MBlockDecoderUtils.debugPrint("MVP: (%d, %d), MVD: (%d, %d), MV: (%d,%d,%d)", mvpX, mvpY, mBlock.pb8x8.mvdX1[list][partNo], mBlock.pb8x8.mvdY1[list][partNo], x00[0], x00[1], refIdx);
        this.interpolator.getBlockLuma(references[refIdx], mb, off, offX + x00[0], offY + x00[1], 8, 8);
    };
    prototype.decodeSub8x4 = function(mBlock, partNo, references, offX, offY, tl, t0, tr, l0, l1, tlAvb, tAvb, trAvb, lAvb, x00, x01, x10, x11, refIdx, mb, off, list) {
        var mvpX1 = MBlockDecoderUtils.calcMVPredictionMedian(l0, t0, tr, tl, lAvb, tAvb, trAvb, tlAvb, refIdx, 0);
        var mvpY1 = MBlockDecoderUtils.calcMVPredictionMedian(l0, t0, tr, tl, lAvb, tAvb, trAvb, tlAvb, refIdx, 1);
        x00[0] = x01[0] = mBlock.pb8x8.mvdX1[list][partNo] + mvpX1;
        x00[1] = x01[1] = mBlock.pb8x8.mvdY1[list][partNo] + mvpY1;
        MBlockDecoderUtils.debugPrint("MVP: (%d, %d), MVD: (%d, %d), MV: (%d,%d,%d)", mvpX1, mvpY1, mBlock.pb8x8.mvdX1[list][partNo], mBlock.pb8x8.mvdY1[list][partNo], x00[0], x00[1], refIdx);
        var mvpX2 = MBlockDecoderUtils.calcMVPredictionMedian(l1, x00, MBlockDecoderUtils.NULL_VECTOR, l0, lAvb, true, false, lAvb, refIdx, 0);
        var mvpY2 = MBlockDecoderUtils.calcMVPredictionMedian(l1, x00, MBlockDecoderUtils.NULL_VECTOR, l0, lAvb, true, false, lAvb, refIdx, 1);
        x10[0] = x11[0] = mBlock.pb8x8.mvdX2[list][partNo] + mvpX2;
        x10[1] = x11[1] = mBlock.pb8x8.mvdY2[list][partNo] + mvpY2;
        MBlockDecoderUtils.debugPrint("MVP: (%d, %d), MVD: (%d, %d), MV: (%d,%d,%d)", mvpX2, mvpY2, mBlock.pb8x8.mvdX2[list][partNo], mBlock.pb8x8.mvdY2[list][partNo], x10[0], x10[1], refIdx);
        this.interpolator.getBlockLuma(references[refIdx], mb, off, offX + x00[0], offY + x00[1], 8, 4);
        this.interpolator.getBlockLuma(references[refIdx], mb, off + mb.getWidth() * 4, offX + x10[0], offY + x10[1] + 16, 8, 4);
    };
    prototype.decodeSub4x8 = function(mBlock, partNo, references, offX, offY, tl, t0, t1, tr, l0, tlAvb, tAvb, trAvb, lAvb, x00, x01, x10, x11, refIdx, mb, off, list) {
        var mvpX1 = MBlockDecoderUtils.calcMVPredictionMedian(l0, t0, t1, tl, lAvb, tAvb, tAvb, tlAvb, refIdx, 0);
        var mvpY1 = MBlockDecoderUtils.calcMVPredictionMedian(l0, t0, t1, tl, lAvb, tAvb, tAvb, tlAvb, refIdx, 1);
        x00[0] = x10[0] = mBlock.pb8x8.mvdX1[list][partNo] + mvpX1;
        x00[1] = x10[1] = mBlock.pb8x8.mvdY1[list][partNo] + mvpY1;
        MBlockDecoderUtils.debugPrint("MVP: (%d, %d), MVD: (%d, %d), MV: (%d,%d,%d)", mvpX1, mvpY1, mBlock.pb8x8.mvdX1[list][partNo], mBlock.pb8x8.mvdY1[list][partNo], x00[0], x00[1], refIdx);
        var mvpX2 = MBlockDecoderUtils.calcMVPredictionMedian(x00, t1, tr, t0, true, tAvb, trAvb, tAvb, refIdx, 0);
        var mvpY2 = MBlockDecoderUtils.calcMVPredictionMedian(x00, t1, tr, t0, true, tAvb, trAvb, tAvb, refIdx, 1);
        x01[0] = x11[0] = mBlock.pb8x8.mvdX2[list][partNo] + mvpX2;
        x01[1] = x11[1] = mBlock.pb8x8.mvdY2[list][partNo] + mvpY2;
        MBlockDecoderUtils.debugPrint("MVP: (%d, %d), MVD: (%d, %d), MV: (%d,%d,%d)", mvpX2, mvpY2, mBlock.pb8x8.mvdX2[list][partNo], mBlock.pb8x8.mvdY2[list][partNo], x01[0], x01[1], refIdx);
        this.interpolator.getBlockLuma(references[refIdx], mb, off, offX + x00[0], offY + x00[1], 4, 8);
        this.interpolator.getBlockLuma(references[refIdx], mb, off + 4, offX + x01[0] + 16, offY + x01[1], 4, 8);
    };
    prototype.decodeSub4x4 = function(mBlock, partNo, references, offX, offY, tl, t0, t1, tr, l0, l1, tlAvb, tAvb, trAvb, lAvb, x00, x01, x10, x11, refIdx, mb, off, list) {
        var mvpX1 = MBlockDecoderUtils.calcMVPredictionMedian(l0, t0, t1, tl, lAvb, tAvb, tAvb, tlAvb, refIdx, 0);
        var mvpY1 = MBlockDecoderUtils.calcMVPredictionMedian(l0, t0, t1, tl, lAvb, tAvb, tAvb, tlAvb, refIdx, 1);
        x00[0] = mBlock.pb8x8.mvdX1[list][partNo] + mvpX1;
        x00[1] = mBlock.pb8x8.mvdY1[list][partNo] + mvpY1;
        MBlockDecoderUtils.debugPrint("MVP: (%d, %d), MVD: (%d, %d), MV: (%d,%d,%d)", mvpX1, mvpY1, mBlock.pb8x8.mvdX1[list][partNo], mBlock.pb8x8.mvdY1[list][partNo], x00[0], x00[1], refIdx);
        var mvpX2 = MBlockDecoderUtils.calcMVPredictionMedian(x00, t1, tr, t0, true, tAvb, trAvb, tAvb, refIdx, 0);
        var mvpY2 = MBlockDecoderUtils.calcMVPredictionMedian(x00, t1, tr, t0, true, tAvb, trAvb, tAvb, refIdx, 1);
        x01[0] = mBlock.pb8x8.mvdX2[list][partNo] + mvpX2;
        x01[1] = mBlock.pb8x8.mvdY2[list][partNo] + mvpY2;
        MBlockDecoderUtils.debugPrint("MVP: (%d, %d), MVD: (%d, %d), MV: (%d,%d,%d)", mvpX2, mvpY2, mBlock.pb8x8.mvdX2[list][partNo], mBlock.pb8x8.mvdY2[list][partNo], x01[0], x01[1], refIdx);
        var mvpX3 = MBlockDecoderUtils.calcMVPredictionMedian(l1, x00, x01, l0, lAvb, true, true, lAvb, refIdx, 0);
        var mvpY3 = MBlockDecoderUtils.calcMVPredictionMedian(l1, x00, x01, l0, lAvb, true, true, lAvb, refIdx, 1);
        x10[0] = mBlock.pb8x8.mvdX3[list][partNo] + mvpX3;
        x10[1] = mBlock.pb8x8.mvdY3[list][partNo] + mvpY3;
        MBlockDecoderUtils.debugPrint("MVP: (%d, %d), MVD: (%d, %d), MV: (%d,%d,%d)", mvpX3, mvpY3, mBlock.pb8x8.mvdX3[list][partNo], mBlock.pb8x8.mvdY3[list][partNo], x10[0], x10[1], refIdx);
        var mvpX4 = MBlockDecoderUtils.calcMVPredictionMedian(x10, x01, MBlockDecoderUtils.NULL_VECTOR, x00, true, true, false, true, refIdx, 0);
        var mvpY4 = MBlockDecoderUtils.calcMVPredictionMedian(x10, x01, MBlockDecoderUtils.NULL_VECTOR, x00, true, true, false, true, refIdx, 1);
        x11[0] = mBlock.pb8x8.mvdX4[list][partNo] + mvpX4;
        x11[1] = mBlock.pb8x8.mvdY4[list][partNo] + mvpY4;
        MBlockDecoderUtils.debugPrint("MVP: (%d, %d), MVD: (%d, %d), MV: (%d,%d,%d)", mvpX4, mvpY4, mBlock.pb8x8.mvdX4[list][partNo], mBlock.pb8x8.mvdY4[list][partNo], x11[0], x11[1], refIdx);
        this.interpolator.getBlockLuma(references[refIdx], mb, off, offX + x00[0], offY + x00[1], 4, 4);
        this.interpolator.getBlockLuma(references[refIdx], mb, off + 4, offX + x01[0] + 16, offY + x01[1], 4, 4);
        this.interpolator.getBlockLuma(references[refIdx], mb, off + mb.getWidth() * 4, offX + x10[0], offY + x10[1] + 16, 4, 4);
        this.interpolator.getBlockLuma(references[refIdx], mb, off + mb.getWidth() * 4 + 4, offX + x11[0] + 16, offY + x11[1] + 16, 4, 4);
    };
}, {mapper: "Mapper", bDirectDecoder: "MBlockDecoderBDirect", s: "DecoderState", sh: "SliceHeader", di: "DeblockerInput", interpolator: "BlockInterpolator", mbb: "Array"}, {});
/**
 *  A decoder for I16x16 macroblocks
 *  
 *  @author The JCodec project
 */
var MBlockDecoderIntraNxN = function(mapper, sh, di, poc, decoderState) {
    MBlockDecoderBase.call(this, sh, di, poc, decoderState);
    this.mapper = mapper;
    this.prediction8x8Builder = new Intra8x8PredictionBuilder();
};
MBlockDecoderIntraNxN = stjs.extend(MBlockDecoderIntraNxN, MBlockDecoderBase, [], function(constructor, prototype) {
    prototype.mapper = null;
    prototype.prediction8x8Builder = null;
    prototype.decode = function(mBlock, mb) {
        var mbX = this.mapper.getMbX(mBlock.mbIdx);
        var mbY = this.mapper.getMbY(mBlock.mbIdx);
        var mbAddr = this.mapper.getAddress(mBlock.mbIdx);
        var leftAvailable = this.mapper.leftAvailable(mBlock.mbIdx);
        var topAvailable = this.mapper.topAvailable(mBlock.mbIdx);
        var topLeftAvailable = this.mapper.topLeftAvailable(mBlock.mbIdx);
        var topRightAvailable = this.mapper.topRightAvailable(mBlock.mbIdx);
        if (mBlock.cbpLuma() > 0 || mBlock.cbpChroma() > 0) {
            this.s.qp = (this.s.qp + mBlock.mbQPDelta + 52) % 52;
        }
        this.di.mbQps[0][mbAddr] = this.s.qp;
        this.residualLuma(mBlock, leftAvailable, topAvailable, mbX, mbY);
        if (!mBlock.transform8x8Used) {
            for (var i = 0; i < 16; i++) {
                var blkX = (i & 3) << 2;
                var blkY = i & ~3;
                var bi = H264Const.BLK_INV_MAP[i];
                var trAvailable = ((bi == 0 || bi == 1 || bi == 4) && topAvailable) || (bi == 5 && topRightAvailable) || bi == 2 || bi == 6 || bi == 8 || bi == 9 || bi == 10 || bi == 12 || bi == 14;
                Intra4x4PredictionBuilder.predictWithMode(mBlock.lumaModes[bi], mBlock.ac[0][bi], blkX == 0 ? leftAvailable : true, blkY == 0 ? topAvailable : true, trAvailable, this.s.leftRow[0], this.s.topLine[0], this.s.topLeft[0], (mbX << 4), blkX, blkY, mb.getPlaneData(0));
            }
        } else {
            for (var i = 0; i < 4; i++) {
                var blkX = (i & 1) << 1;
                var blkY = i & 2;
                var trAvailable = (i == 0 && topAvailable) || (i == 1 && topRightAvailable) || i == 2;
                var tlAvailable = i == 0 ? topLeftAvailable : (i == 1 ? topAvailable : (i == 2 ? leftAvailable : true));
                this.prediction8x8Builder.predictWithMode(mBlock.lumaModes[i], mBlock.ac[0][i], blkX == 0 ? leftAvailable : true, blkY == 0 ? topAvailable : true, tlAvailable, trAvailable, this.s.leftRow[0], this.s.topLine[0], this.s.topLeft[0], (mbX << 4), blkX << 2, blkY << 2, mb.getPlaneData(0));
            }
        }
        this.decodeChroma(mBlock, mbX, mbY, leftAvailable, topAvailable, mb, this.s.qp);
        this.di.mbTypes[mbAddr] = mBlock.curMbType;
        this.di.tr8x8Used[mbAddr] = mBlock.transform8x8Used;
        MBlockDecoderUtils.collectChromaPredictors(this.s, mb, mbX);
        MBlockDecoderUtils.saveMvsIntra(this.di, mbX, mbY);
        MBlockDecoderUtils.saveVectIntra(this.s, this.mapper.getMbX(mbAddr));
    };
}, {mapper: "Mapper", prediction8x8Builder: "Intra8x8PredictionBuilder", s: "DecoderState", sh: "SliceHeader", di: "DeblockerInput", interpolator: "BlockInterpolator", mbb: "Array"}, {});
/**
 *  A decoder for B direct macroblocks
 *  
 *  @author The JCodec project
 */
var MBlockDecoderBDirect = function(mapper, sh, di, poc, decoderState) {
    MBlockDecoderBase.call(this, sh, di, poc, decoderState);
    this.mapper = mapper;
};
MBlockDecoderBDirect = stjs.extend(MBlockDecoderBDirect, MBlockDecoderBase, [], function(constructor, prototype) {
    prototype.mapper = null;
    prototype.decode = function(mBlock, mb, references) {
        var mbX = this.mapper.getMbX(mBlock.mbIdx);
        var mbY = this.mapper.getMbY(mBlock.mbIdx);
        var lAvb = this.mapper.leftAvailable(mBlock.mbIdx);
        var tAvb = this.mapper.topAvailable(mBlock.mbIdx);
        var mbAddr = this.mapper.getAddress(mBlock.mbIdx);
        var tlAvb = this.mapper.topLeftAvailable(mBlock.mbIdx);
        var trAvb = this.mapper.topRightAvailable(mBlock.mbIdx);
        var x = Array.apply(null, Array(2)).map(function() {
            return Array.apply(null, Array(16)).map(function() {
                return new Int32Array(3);
            });
        });
        for (var i = 0; i < 16; i++) 
            x[0][i][2] = x[1][i][2] = -1;
        var pp = Array(4);
        this.predictBDirect(references, mbX, mbY, lAvb, tAvb, tlAvb, trAvb, x, pp, mb, H264Const.identityMapping4);
        this.predictChromaInter(references, x, mbX << 3, mbY << 3, 1, mb, pp);
        this.predictChromaInter(references, x, mbX << 3, mbY << 3, 2, mb, pp);
        if (mBlock.cbpLuma() > 0 || mBlock.cbpChroma() > 0) {
            this.s.qp = (this.s.qp + mBlock.mbQPDelta + 52) % 52;
        }
        this.di.mbQps[0][mbAddr] = this.s.qp;
        this.residualLuma(mBlock, lAvb, tAvb, mbX, mbY);
        MBlockDecoderUtils.savePrediction8x8(this.s, mbX, x[0], 0);
        MBlockDecoderUtils.savePrediction8x8(this.s, mbX, x[1], 1);
        MBlockDecoderUtils.saveMvs(this.di, x, mbX, mbY);
        var qp1 = this.calcQpChroma(this.s.qp, this.s.chromaQpOffset[0]);
        var qp2 = this.calcQpChroma(this.s.qp, this.s.chromaQpOffset[1]);
        this.decodeChromaResidual(mBlock, lAvb, tAvb, mbX, mbY, qp1, qp2);
        this.di.mbQps[1][mbAddr] = qp1;
        this.di.mbQps[2][mbAddr] = qp2;
        MBlockDecoderUtils.mergeResidual(mb, mBlock.ac, mBlock.transform8x8Used ? H264Const.COMP_BLOCK_8x8_LUT : H264Const.COMP_BLOCK_4x4_LUT, mBlock.transform8x8Used ? H264Const.COMP_POS_8x8_LUT : H264Const.COMP_POS_4x4_LUT);
        MBlockDecoderUtils.collectPredictors(this.s, mb, mbX);
        this.di.mbTypes[mbAddr] = mBlock.curMbType;
        this.di.tr8x8Used[mbAddr] = mBlock.transform8x8Used;
    };
    prototype.predictBDirect = function(refs, mbX, mbY, lAvb, tAvb, tlAvb, trAvb, x, pp, mb, blocks) {
        if (this.sh.direct_spatial_mv_pred_flag) 
            this.predictBSpatialDirect(refs, mbX, mbY, lAvb, tAvb, tlAvb, trAvb, x, pp, mb, blocks);
         else 
            this.predictBTemporalDirect(refs, mbX, mbY, lAvb, tAvb, tlAvb, trAvb, x, pp, mb, blocks);
    };
    prototype.predictBTemporalDirect = function(refs, mbX, mbY, lAvb, tAvb, tlAvb, trAvb, x, pp, mb, blocks8x8) {
        for (var i = 0; i < blocks8x8.length; i++) {
            var blk8x8 = blocks8x8[i];
            var blk4x4_0 = H264Const.BLK8x8_BLOCKS[blk8x8][0];
            pp[blk8x8] = H264Const.PartPred.Bi;
            if (!this.sh.sps.direct_8x8_inference_flag) {
                var js = H264Const.BLK8x8_BLOCKS[blk8x8];
                for (var j = 0; j < js.length; j++) {
                    var blk4x4 = js[j];
                    this.predTemp4x4(refs, mbX, mbY, x, blk4x4);
                    var blkIndX = blk4x4 & 3;
                    var blkIndY = blk4x4 >> 2;
                    MBlockDecoderUtils.debugPrint("DIRECT_4x4 [%d, %d]: (%d,%d,%d), (%d,%d,%d)", blkIndY, blkIndX, x[0][blk4x4][0], x[0][blk4x4][1], x[0][blk4x4][2], x[1][blk4x4][0], x[1][blk4x4][1], x[1][blk4x4][2]);
                    var blkPredX = (mbX << 6) + (blkIndX << 4);
                    var blkPredY = (mbY << 6) + (blkIndY << 4);
                    this.interpolator.getBlockLuma(refs[0][x[0][blk4x4][2]], this.mbb[0], H264Const.BLK_4x4_MB_OFF_LUMA[blk4x4], blkPredX + x[0][blk4x4][0], blkPredY + x[0][blk4x4][1], 4, 4);
                    this.interpolator.getBlockLuma(refs[1][0], this.mbb[1], H264Const.BLK_4x4_MB_OFF_LUMA[blk4x4], blkPredX + x[1][blk4x4][0], blkPredY + x[1][blk4x4][1], 4, 4);
                }
            } else {
                var blk4x4Pred = H264Const.BLK_INV_MAP[blk8x8 * 5];
                this.predTemp4x4(refs, mbX, mbY, x, blk4x4Pred);
                this.propagatePred(x, blk8x8, blk4x4Pred);
                var blkIndX = blk4x4_0 & 3;
                var blkIndY = blk4x4_0 >> 2;
                MBlockDecoderUtils.debugPrint("DIRECT_8x8 [%d, %d]: (%d,%d,%d), (%d,%d)", blkIndY, blkIndX, x[0][blk4x4_0][0], x[0][blk4x4_0][1], x[0][blk4x4_0][2], x[1][blk4x4_0][0], x[1][blk4x4_0][1], x[0][blk4x4_0][2]);
                var blkPredX = (mbX << 6) + (blkIndX << 4);
                var blkPredY = (mbY << 6) + (blkIndY << 4);
                this.interpolator.getBlockLuma(refs[0][x[0][blk4x4_0][2]], this.mbb[0], H264Const.BLK_4x4_MB_OFF_LUMA[blk4x4_0], blkPredX + x[0][blk4x4_0][0], blkPredY + x[0][blk4x4_0][1], 8, 8);
                this.interpolator.getBlockLuma(refs[1][0], this.mbb[1], H264Const.BLK_4x4_MB_OFF_LUMA[blk4x4_0], blkPredX + x[1][blk4x4_0][0], blkPredY + x[1][blk4x4_0][1], 8, 8);
            }
            PredictionMerger.mergePrediction(this.sh, x[0][blk4x4_0][2], x[1][blk4x4_0][2], H264Const.PartPred.Bi, 0, this.mbb[0].getPlaneData(0), this.mbb[1].getPlaneData(0), H264Const.BLK_4x4_MB_OFF_LUMA[blk4x4_0], 16, 8, 8, mb.getPlaneData(0), refs, this.poc);
        }
    };
    prototype.predTemp4x4 = function(refs, mbX, mbY, x, blk4x4) {
        var mbWidth = this.sh.sps.pic_width_in_mbs_minus1 + 1;
        var picCol = refs[1][0];
        var blkIndX = blk4x4 & 3;
        var blkIndY = blk4x4 >> 2;
        var blkPosX = (mbX << 2) + blkIndX;
        var blkPosY = (mbY << 2) + blkIndY;
        var mvCol = picCol.getMvs()[0][blkPosY][blkPosX];
        var refL0;
        var refIdxL0;
        if (mvCol[2] == -1) {
            mvCol = picCol.getMvs()[1][blkPosY][blkPosX];
            if (mvCol[2] == -1) {
                refIdxL0 = 0;
                refL0 = refs[0][0];
            } else {
                refL0 = picCol.getRefsUsed()[mbY * mbWidth + mbX][1][mvCol[2]];
                refIdxL0 = this.findPic(refs[0], refL0);
            }
        } else {
            refL0 = picCol.getRefsUsed()[mbY * mbWidth + mbX][0][mvCol[2]];
            refIdxL0 = this.findPic(refs[0], refL0);
        }
        x[0][blk4x4][2] = refIdxL0;
        x[1][blk4x4][2] = 0;
        var td = MathUtil.clip(picCol.getPOC() - refL0.getPOC(), -128, 127);
        if (!refL0.isShortTerm() || td == 0) {
            x[0][blk4x4][0] = mvCol[0];
            x[0][blk4x4][1] = mvCol[1];
            x[1][blk4x4][0] = 0;
            x[1][blk4x4][1] = 0;
        } else {
            var tb = MathUtil.clip(this.poc - refL0.getPOC(), -128, 127);
            var tx = stjs.trunc((16384 + Math.abs(stjs.trunc(td / 2))) / td);
            var dsf = MathUtil.clip((tb * tx + 32) >> 6, -1024, 1023);
            x[0][blk4x4][0] = (dsf * mvCol[0] + 128) >> 8;
            x[0][blk4x4][1] = (dsf * mvCol[1] + 128) >> 8;
            x[1][blk4x4][0] = (x[0][blk4x4][0] - mvCol[0]);
            x[1][blk4x4][1] = (x[0][blk4x4][1] - mvCol[1]);
        }
    };
    prototype.findPic = function(frames, refL0) {
        for (var i = 0; i < frames.length; i++) 
            if (frames[i] == refL0) 
                return i;
        jcodec.Logger.error("RefPicList0 shall contain refPicCol");
        return 0;
    };
    prototype.predictBSpatialDirect = function(refs, mbX, mbY, lAvb, tAvb, tlAvb, trAvb, x, pp, mb, blocks8x8) {
        var a0 = this.s.mvLeft[0][0], a1 = this.s.mvLeft[1][0];
        var b0 = this.s.mvTop[0][mbX << 2], b1 = this.s.mvTop[1][mbX << 2];
        var c0 = this.s.mvTop[0][(mbX << 2) + 4], c1 = this.s.mvTop[1][(mbX << 2) + 4];
        var d0 = this.s.mvTopLeft[0];
        var d1 = this.s.mvTopLeft[1];
        var refIdxL0 = this.calcRef(a0, b0, c0, d0, lAvb, tAvb, tlAvb, trAvb, mbX);
        var refIdxL1 = this.calcRef(a1, b1, c1, d1, lAvb, tAvb, tlAvb, trAvb, mbX);
        if (refIdxL0 < 0 && refIdxL1 < 0) {
            for (var i = 0; i < blocks8x8.length; i++) {
                var blk8x8 = blocks8x8[i];
                var js = H264Const.BLK8x8_BLOCKS[blk8x8];
                for (var j = 0; j < js.length; j++) {
                    var blk4x4 = js[j];
                    x[0][blk4x4][0] = x[0][blk4x4][1] = x[0][blk4x4][2] = x[1][blk4x4][0] = x[1][blk4x4][1] = x[1][blk4x4][2] = 0;
                }
                pp[blk8x8] = H264Const.PartPred.Bi;
                var blkOffX = (blk8x8 & 1) << 5;
                var blkOffY = (blk8x8 >> 1) << 5;
                this.interpolator.getBlockLuma(refs[0][0], this.mbb[0], H264Const.BLK_8x8_MB_OFF_LUMA[blk8x8], (mbX << 6) + blkOffX, (mbY << 6) + blkOffY, 8, 8);
                this.interpolator.getBlockLuma(refs[1][0], this.mbb[1], H264Const.BLK_8x8_MB_OFF_LUMA[blk8x8], (mbX << 6) + blkOffX, (mbY << 6) + blkOffY, 8, 8);
                PredictionMerger.mergePrediction(this.sh, 0, 0, H264Const.PartPred.Bi, 0, this.mbb[0].getPlaneData(0), this.mbb[1].getPlaneData(0), H264Const.BLK_8x8_MB_OFF_LUMA[blk8x8], 16, 8, 8, mb.getPlaneData(0), refs, this.poc);
                MBlockDecoderUtils.debugPrint("DIRECT_8x8 [%d, %d]: (0,0,0), (0,0,0)", (blk8x8 & 2), ((blk8x8 << 1) & 2));
            }
            return;
        }
        var mvX0 = MBlockDecoderUtils.calcMVPredictionMedian(a0, b0, c0, d0, lAvb, tAvb, trAvb, tlAvb, refIdxL0, 0);
        var mvY0 = MBlockDecoderUtils.calcMVPredictionMedian(a0, b0, c0, d0, lAvb, tAvb, trAvb, tlAvb, refIdxL0, 1);
        var mvX1 = MBlockDecoderUtils.calcMVPredictionMedian(a1, b1, c1, d1, lAvb, tAvb, trAvb, tlAvb, refIdxL1, 0);
        var mvY1 = MBlockDecoderUtils.calcMVPredictionMedian(a1, b1, c1, d1, lAvb, tAvb, trAvb, tlAvb, refIdxL1, 1);
        var col = refs[1][0];
        var partPred = refIdxL0 >= 0 && refIdxL1 >= 0 ? H264Const.PartPred.Bi : (refIdxL0 >= 0 ? H264Const.PartPred.L0 : H264Const.PartPred.L1);
        for (var i = 0; i < blocks8x8.length; i++) {
            var blk8x8 = blocks8x8[i];
            var blk4x4_0 = H264Const.BLK8x8_BLOCKS[blk8x8][0];
            if (!this.sh.sps.direct_8x8_inference_flag) {
                var js = H264Const.BLK8x8_BLOCKS[blk8x8];
                for (var j = 0; j < js.length; j++) {
                    var blk4x4 = js[j];
                    this.pred4x4(mbX, mbY, x, pp, refIdxL0, refIdxL1, mvX0, mvY0, mvX1, mvY1, col, partPred, blk4x4);
                    var blkIndX = blk4x4 & 3;
                    var blkIndY = blk4x4 >> 2;
                    MBlockDecoderUtils.debugPrint("DIRECT_4x4 [%d, %d]: (%d,%d,%d), (%d,%d," + refIdxL1 + ")", blkIndY, blkIndX, x[0][blk4x4][0], x[0][blk4x4][1], refIdxL0, x[1][blk4x4][0], x[1][blk4x4][1]);
                    var blkPredX = (mbX << 6) + (blkIndX << 4);
                    var blkPredY = (mbY << 6) + (blkIndY << 4);
                    if (refIdxL0 >= 0) 
                        this.interpolator.getBlockLuma(refs[0][refIdxL0], this.mbb[0], H264Const.BLK_4x4_MB_OFF_LUMA[blk4x4], blkPredX + x[0][blk4x4][0], blkPredY + x[0][blk4x4][1], 4, 4);
                    if (refIdxL1 >= 0) 
                        this.interpolator.getBlockLuma(refs[1][refIdxL1], this.mbb[1], H264Const.BLK_4x4_MB_OFF_LUMA[blk4x4], blkPredX + x[1][blk4x4][0], blkPredY + x[1][blk4x4][1], 4, 4);
                }
            } else {
                var blk4x4Pred = H264Const.BLK_INV_MAP[blk8x8 * 5];
                this.pred4x4(mbX, mbY, x, pp, refIdxL0, refIdxL1, mvX0, mvY0, mvX1, mvY1, col, partPred, blk4x4Pred);
                this.propagatePred(x, blk8x8, blk4x4Pred);
                var blkIndX = blk4x4_0 & 3;
                var blkIndY = blk4x4_0 >> 2;
                MBlockDecoderUtils.debugPrint("DIRECT_8x8 [%d, %d]: (%d,%d,%d), (%d,%d,%d)", blkIndY, blkIndX, x[0][blk4x4_0][0], x[0][blk4x4_0][1], refIdxL0, x[1][blk4x4_0][0], x[1][blk4x4_0][1], refIdxL1);
                var blkPredX = (mbX << 6) + (blkIndX << 4);
                var blkPredY = (mbY << 6) + (blkIndY << 4);
                if (refIdxL0 >= 0) 
                    this.interpolator.getBlockLuma(refs[0][refIdxL0], this.mbb[0], H264Const.BLK_4x4_MB_OFF_LUMA[blk4x4_0], blkPredX + x[0][blk4x4_0][0], blkPredY + x[0][blk4x4_0][1], 8, 8);
                if (refIdxL1 >= 0) 
                    this.interpolator.getBlockLuma(refs[1][refIdxL1], this.mbb[1], H264Const.BLK_4x4_MB_OFF_LUMA[blk4x4_0], blkPredX + x[1][blk4x4_0][0], blkPredY + x[1][blk4x4_0][1], 8, 8);
            }
            PredictionMerger.mergePrediction(this.sh, x[0][blk4x4_0][2], x[1][blk4x4_0][2], refIdxL0 >= 0 ? (refIdxL1 >= 0 ? H264Const.PartPred.Bi : H264Const.PartPred.L0) : H264Const.PartPred.L1, 0, this.mbb[0].getPlaneData(0), this.mbb[1].getPlaneData(0), H264Const.BLK_4x4_MB_OFF_LUMA[blk4x4_0], 16, 8, 8, mb.getPlaneData(0), refs, this.poc);
        }
    };
    prototype.calcRef = function(a0, b0, c0, d0, lAvb, tAvb, tlAvb, trAvb, mbX) {
        return this.minPos(this.minPos(lAvb ? a0[2] : -1, tAvb ? b0[2] : -1), trAvb ? c0[2] : (tlAvb ? d0[2] : -1));
    };
    prototype.propagatePred = function(x, blk8x8, blk4x4Pred) {
        var b0 = H264Const.BLK8x8_BLOCKS[blk8x8][0];
        var b1 = H264Const.BLK8x8_BLOCKS[blk8x8][1];
        var b2 = H264Const.BLK8x8_BLOCKS[blk8x8][2];
        var b3 = H264Const.BLK8x8_BLOCKS[blk8x8][3];
        x[0][b0][0] = x[0][b1][0] = x[0][b2][0] = x[0][b3][0] = x[0][blk4x4Pred][0];
        x[0][b0][1] = x[0][b1][1] = x[0][b2][1] = x[0][b3][1] = x[0][blk4x4Pred][1];
        x[0][b0][2] = x[0][b1][2] = x[0][b2][2] = x[0][b3][2] = x[0][blk4x4Pred][2];
        x[1][b0][0] = x[1][b1][0] = x[1][b2][0] = x[1][b3][0] = x[1][blk4x4Pred][0];
        x[1][b0][1] = x[1][b1][1] = x[1][b2][1] = x[1][b3][1] = x[1][blk4x4Pred][1];
        x[1][b0][2] = x[1][b1][2] = x[1][b2][2] = x[1][b3][2] = x[1][blk4x4Pred][2];
    };
    prototype.pred4x4 = function(mbX, mbY, x, pp, refL0, refL1, mvX0, mvY0, mvX1, mvY1, col, partPred, blk4x4) {
        var blkIndX = blk4x4 & 3;
        var blkIndY = blk4x4 >> 2;
        var blkPosX = (mbX << 2) + blkIndX;
        var blkPosY = (mbY << 2) + blkIndY;
        x[0][blk4x4][2] = refL0;
        x[1][blk4x4][2] = refL1;
        var mvCol = col.getMvs()[0][blkPosY][blkPosX];
        if (mvCol[2] == -1) 
            mvCol = col.getMvs()[1][blkPosY][blkPosX];
        var colZero = col.isShortTerm() && mvCol[2] == 0 && (MathUtil.abs(mvCol[0]) >> 1) == 0 && (MathUtil.abs(mvCol[1]) >> 1) == 0;
        if (refL0 > 0 || !colZero) {
            x[0][blk4x4][0] = mvX0;
            x[0][blk4x4][1] = mvY0;
        }
        if (refL1 > 0 || !colZero) {
            x[1][blk4x4][0] = mvX1;
            x[1][blk4x4][1] = mvY1;
        }
        pp[H264Const.BLK_8x8_IND[blk4x4]] = partPred;
    };
    prototype.minPos = function(a, b) {
        return a >= 0 && b >= 0 ? Math.min(a, b) : Math.max(a, b);
    };
}, {mapper: "Mapper", s: "DecoderState", sh: "SliceHeader", di: "DeblockerInput", interpolator: "BlockInterpolator", mbb: "Array"}, {});
/**
 *  A decoder for I16x16 macroblocks
 *  
 *  @author The JCodec project
 */
var MBlockDecoderIntra16x16 = function(mapper, sh, di, poc, decoderState) {
    MBlockDecoderBase.call(this, sh, di, poc, decoderState);
    this.mapper = mapper;
};
MBlockDecoderIntra16x16 = stjs.extend(MBlockDecoderIntra16x16, MBlockDecoderBase, [], function(constructor, prototype) {
    prototype.mapper = null;
    prototype.decode = function(mBlock, mb) {
        var mbX = this.mapper.getMbX(mBlock.mbIdx);
        var mbY = this.mapper.getMbY(mBlock.mbIdx);
        var address = this.mapper.getAddress(mBlock.mbIdx);
        var leftAvailable = this.mapper.leftAvailable(mBlock.mbIdx);
        var topAvailable = this.mapper.topAvailable(mBlock.mbIdx);
        this.s.qp = (this.s.qp + mBlock.mbQPDelta + 52) % 52;
        this.di.mbQps[0][address] = this.s.qp;
        this.residualLumaI16x16(mBlock, leftAvailable, topAvailable, mbX, mbY);
        Intra16x16PredictionBuilder.predictWithMode(mBlock.luma16x16Mode, mBlock.ac[0], leftAvailable, topAvailable, this.s.leftRow[0], this.s.topLine[0], this.s.topLeft[0], mbX << 4, mb.getPlaneData(0));
        this.decodeChroma(mBlock, mbX, mbY, leftAvailable, topAvailable, mb, this.s.qp);
        this.di.mbTypes[address] = mBlock.curMbType;
        MBlockDecoderUtils.collectPredictors(this.s, mb, mbX);
        MBlockDecoderUtils.saveMvsIntra(this.di, mbX, mbY);
        MBlockDecoderUtils.saveVectIntra(this.s, this.mapper.getMbX(mBlock.mbIdx));
    };
    prototype.residualLumaI16x16 = function(mBlock, leftAvailable, topAvailable, mbX, mbY) {
        CoeffTransformer.invDC4x4(mBlock.dc);
        CoeffTransformer.dequantizeDC4x4(mBlock.dc, this.s.qp);
        CoeffTransformer.reorderDC4x4(mBlock.dc);
        for (var i = 0; i < 16; i++) {
            if ((mBlock.cbpLuma() & (1 << (i >> 2))) != 0) {
                CoeffTransformer.dequantizeAC(mBlock.ac[0][i], this.s.qp);
            }
            mBlock.ac[0][i][0] = mBlock.dc[i];
            CoeffTransformer.idct4x4(mBlock.ac[0][i]);
        }
    };
}, {mapper: "Mapper", s: "DecoderState", sh: "SliceHeader", di: "DeblockerInput", interpolator: "BlockInterpolator", mbb: "Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  @author in-somnia
 */
var ADIFHeader = function() {
    this.copyrightID = new Int8Array(9);
};
ADIFHeader = stjs.extend(ADIFHeader, null, [], function(constructor, prototype) {
    constructor.ADIF_ID = 1094994246;
    prototype.id = 0;
    prototype.copyrightIDPresent = false;
    prototype.copyrightID = null;
    prototype.originalCopy = false;
    prototype.home = false;
    prototype.bitstreamType = false;
    prototype.bitrate = 0;
    prototype.pceCount = 0;
    prototype.adifBufferFullness = null;
    prototype.pces = null;
    constructor.isPresent = function(_in) {
        return _in.peekBits(32) == ADIFHeader.ADIF_ID;
    };
    constructor.readHeader = function(_in) {
        var h = new ADIFHeader();
        h.decode(_in);
        return h;
    };
    prototype.decode = function(_in) {
        var i;
        this.id = _in.readBits(32);
        this.copyrightIDPresent = _in.readBool();
        if (this.copyrightIDPresent) {
            for (i = 0; i < 9; i++) {
                this.copyrightID[i] = (_in.readBits(8) << 24 >> 24);
            }
        }
        this.originalCopy = _in.readBool();
        this.home = _in.readBool();
        this.bitstreamType = _in.readBool();
        this.bitrate = _in.readBits(23);
        this.pceCount = _in.readBits(4) + 1;
        this.pces = Array(this.pceCount);
        this.adifBufferFullness = new Int32Array(this.pceCount);
        for (i = 0; i < this.pceCount; i++) {
            if (this.bitstreamType) 
                this.adifBufferFullness[i] = -1;
             else 
                this.adifBufferFullness[i] = _in.readBits(20);
            this.pces[i] = new PCE();
            this.pces[i].decode(_in);
        }
    };
    prototype.getFirstPCE = function() {
        return this.pces[0];
    };
}, {copyrightID: "Int8Array", adifBufferFullness: "Int32Array", pces: "Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  DecoderConfig that must be passed to the
 *  <code>Decoder</code> constructor. Typically it is created via one of the
 *  static parsing methods.
 * 
 *  @author in-somnia
 */
var AACDecoderConfig = function() {
    this.profile = Profile.AAC_MAIN;
    this.extProfile = Profile.UNKNOWN;
    this.sampleFrequency = SampleFrequency.SAMPLE_FREQUENCY_NONE;
    this.channelConfiguration = ChannelConfiguration.CHANNEL_CONFIG_UNSUPPORTED;
    this.frameLengthFlag = false;
    this.sbrPresent = false;
    this.downSampledSBR = false;
    this.sbrEnabled = true;
    this.sectionDataResilience = false;
    this.scalefactorResilience = false;
    this.spectralDataResilience = false;
};
AACDecoderConfig = stjs.extend(AACDecoderConfig, null, [SyntaxConstants], function(constructor, prototype) {
    prototype.profile = null;
    prototype.extProfile = null;
    prototype.sampleFrequency = null;
    prototype.channelConfiguration = null;
    prototype.frameLengthFlag = false;
    prototype.dependsOnCoreCoder = false;
    prototype.coreCoderDelay = 0;
    prototype.extensionFlag = false;
    prototype.sbrPresent = false;
    prototype.downSampledSBR = false;
    prototype.sbrEnabled = false;
    prototype.sectionDataResilience = false;
    prototype.scalefactorResilience = false;
    prototype.spectralDataResilience = false;
    prototype.getChannelConfiguration = function() {
        return this.channelConfiguration;
    };
    prototype.setChannelConfiguration = function(channelConfiguration) {
        this.channelConfiguration = channelConfiguration;
    };
    prototype.getCoreCoderDelay = function() {
        return this.coreCoderDelay;
    };
    prototype.setCoreCoderDelay = function(coreCoderDelay) {
        this.coreCoderDelay = coreCoderDelay;
    };
    prototype.isDependsOnCoreCoder = function() {
        return this.dependsOnCoreCoder;
    };
    prototype.setDependsOnCoreCoder = function(dependsOnCoreCoder) {
        this.dependsOnCoreCoder = dependsOnCoreCoder;
    };
    prototype.getExtObjectType = function() {
        return this.extProfile;
    };
    prototype.setExtObjectType = function(extObjectType) {
        this.extProfile = extObjectType;
    };
    prototype.getFrameLength = function() {
        return this.frameLengthFlag ? SyntaxConstants.WINDOW_SMALL_LEN_LONG : SyntaxConstants.WINDOW_LEN_LONG;
    };
    prototype.isSmallFrameUsed = function() {
        return this.frameLengthFlag;
    };
    prototype.setSmallFrameUsed = function(shortFrame) {
        this.frameLengthFlag = shortFrame;
    };
    prototype.getProfile = function() {
        return this.profile;
    };
    prototype.setProfile = function(profile) {
        this.profile = profile;
    };
    prototype.getSampleFrequency = function() {
        return this.sampleFrequency;
    };
    prototype.setSampleFrequency = function(sampleFrequency) {
        this.sampleFrequency = sampleFrequency;
    };
    prototype.isSBRPresent = function() {
        return this.sbrPresent;
    };
    prototype.isSBRDownSampled = function() {
        return this.downSampledSBR;
    };
    prototype.isSBREnabled = function() {
        return this.sbrEnabled;
    };
    prototype.setSBREnabled = function(enabled) {
        this.sbrEnabled = enabled;
    };
    prototype.isScalefactorResilienceUsed = function() {
        return this.scalefactorResilience;
    };
    prototype.isSectionDataResilienceUsed = function() {
        return this.sectionDataResilience;
    };
    prototype.isSpectralDataResilienceUsed = function() {
        return this.spectralDataResilience;
    };
    /**
     *  Parses the input arrays as a DecoderSpecificInfo, as used in MP4
     *  containers.
     *  
     *  @return a DecoderConfig
     */
    constructor.parseMP4DecoderSpecificInfo = function(data) {
        var _in = BitStream.createBitStream(data);
        var config = new AACDecoderConfig();
        try {
            config.profile = AACDecoderConfig.readProfile(_in);
            var sf = _in.readBits(4);
            if (sf == 15) 
                config.sampleFrequency = SampleFrequency.forFrequency(_in.readBits(24));
             else 
                config.sampleFrequency = SampleFrequency.forInt(sf);
            config.channelConfiguration = ChannelConfiguration.forInt(_in.readBits(4));
            var cp = config.profile;
            if (Profile.AAC_SBR == cp) {
                config.extProfile = cp;
                config.sbrPresent = true;
                sf = _in.readBits(4);
                config.downSampledSBR = config.sampleFrequency.getIndex() == sf;
                config.sampleFrequency = SampleFrequency.forInt(sf);
                config.profile = AACDecoderConfig.readProfile(_in);
            } else if (Profile.AAC_MAIN == cp || Profile.AAC_LC == cp || Profile.AAC_SSR == cp || Profile.AAC_LTP == cp || Profile.ER_AAC_LC == cp || Profile.ER_AAC_LTP == cp || Profile.ER_AAC_LD == cp) {
                config.frameLengthFlag = _in.readBool();
                if (config.frameLengthFlag) 
                     throw new AACException("config uses 960-sample frames, not yet supported");
                config.dependsOnCoreCoder = _in.readBool();
                if (config.dependsOnCoreCoder) 
                    config.coreCoderDelay = _in.readBits(14);
                 else 
                    config.coreCoderDelay = 0;
                config.extensionFlag = _in.readBool();
                if (config.extensionFlag) {
                    if (cp.isErrorResilientProfile()) {
                        config.sectionDataResilience = _in.readBool();
                        config.scalefactorResilience = _in.readBool();
                        config.spectralDataResilience = _in.readBool();
                    }
                    _in.skipBit();
                }
                if (config.channelConfiguration == ChannelConfiguration.CHANNEL_CONFIG_NONE) {
                    _in.skipBits(3);
                    var pce = new PCE();
                    pce.decode(_in);
                    config.profile = pce.getProfile();
                    config.sampleFrequency = pce.getSampleFrequency();
                    config.channelConfiguration = ChannelConfiguration.forInt(pce.getChannelCount());
                }
                if (_in.getBitsLeft() > 10) 
                    AACDecoderConfig.readSyncExtension(_in, config);
            } else {
                 throw new AACException("profile not supported: " + cp.getIndex());
            }
            return config;
        } finally {
            _in.destroy();
        }
    };
    constructor.readProfile = function(_in) {
        var i = _in.readBits(5);
        if (i == 31) 
            i = 32 + _in.readBits(6);
        return Profile.forInt(i);
    };
    constructor.readSyncExtension = function(_in, config) {
        var type = _in.readBits(11);
        switch (type) {
            case 695:
                var profile = Profile.forInt(_in.readBits(5));
                if (profile.equals(Profile.AAC_SBR)) {
                    config.sbrPresent = _in.readBool();
                    if (config.sbrPresent) {
                        config.profile = profile;
                        var tmp = _in.readBits(4);
                        if (tmp == config.sampleFrequency.getIndex()) 
                            config.downSampledSBR = true;
                        if (tmp == 15) {
                             throw new AACException("sample rate specified explicitly, not supported yet!");
                        }
                    }
                }
                break;
        }
    };
}, {profile: "Profile", extProfile: "Profile", sampleFrequency: "SampleFrequency", channelConfiguration: "ChannelConfiguration", LOGGER: "Logger"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  MPEG TS demuxer
 *  
 *  @author The JCodec project
 *  
 */
var MTSDemuxer = function(src, filterGuid) {
    this.tsChannel = (new MTSDemuxer.TSChannel(src, filterGuid));
    this.psDemuxer = new MPSDemuxer(this.tsChannel);
};
MTSDemuxer = stjs.extend(MTSDemuxer, null, [MPEGDemuxer], function(constructor, prototype) {
    prototype.psDemuxer = null;
    prototype.tsChannel = null;
    constructor.getProgramsFromChannel = function(src) {
        var rem = src.position();
        var guids = new HashSet();
        for (var i = 0; guids.size() == 0 || i < guids.size() * 500; i++) {
            var pkt = MTSDemuxer.readPacket(src);
            if (pkt == null) 
                break;
            if (pkt.payload == null) 
                continue;
            var payload = pkt.payload;
            if (!guids.contains(pkt.pid) && (payload.duplicate().getInt() & ~255) == 256) {
                guids.add(pkt.pid);
            }
        }
        src.setPosition(rem);
        return guids;
    };
    constructor.getPrograms = function(file) {
        var fc = null;
        try {
            fc = NIOUtils.readableChannel(file);
            return MTSDemuxer.getProgramsFromChannel(fc);
        } finally {
            NIOUtils.closeQuietly(fc);
        }
    };
    prototype.getTracks = function() {
        return this.psDemuxer.getTracks();
    };
    prototype.getVideoTracks = function() {
        return this.psDemuxer.getVideoTracks();
    };
    prototype.getAudioTracks = function() {
        return this.psDemuxer.getAudioTracks();
    };
    constructor.TSChannel = function(source, filterGuid) {
        this.src = source;
        this.filterGuid = filterGuid;
    };
    constructor.TSChannel = stjs.extend(constructor.TSChannel, null, [SeekableByteChannel], function(constructor, prototype) {
        prototype.src = null;
        prototype.data = null;
        prototype.filterGuid = 0;
        prototype.isOpen = function() {
            return this.src.isOpen();
        };
        prototype.close = function() {
            this.src.close();
        };
        prototype.read = function(dst) {
             while (this.data == null || !this.data.hasRemaining()){
                var packet = this.getPacket(this.src);
                if (packet == null) 
                    return -1;
                this.data = packet.payload;
            }
            var toRead = Math.min(dst.remaining(), this.data.remaining());
            dst.putBuf(NIOUtils.read(this.data, toRead));
            return toRead;
        };
        prototype.write = function(src) {
             throw new NotSupportedException();
        };
        prototype.position = function() {
            return this.src.position();
        };
        prototype.setPosition = function(newPosition) {
            this.src.setPosition(newPosition);
            this.data = null;
            return this;
        };
        prototype.size = function() {
            return this.src.size();
        };
        prototype.truncate = function(size) {
            return this.src.truncate(size);
        };
        prototype.getPacket = function(channel) {
            var pkt;
            do {
                pkt = MTSDemuxer.readPacket(channel);
                if (pkt == null) 
                    return null;
            } while (pkt.pid <= 15 || pkt.pid == 8191 || pkt.payload == null);
             while (pkt.pid != this.filterGuid){
                pkt = MTSDemuxer.readPacket(channel);
                if (pkt == null) 
                    return null;
            }
            return pkt;
        };
    }, {src: "SeekableByteChannel", data: "ByteBuffer"}, {});
    constructor.MTSPacket = function(guid, payloadStart, payload) {
        this.pid = guid;
        this.payloadStart = payloadStart;
        this.payload = payload;
    };
    constructor.MTSPacket = stjs.extend(constructor.MTSPacket, null, [], function(constructor, prototype) {
        prototype.payload = null;
        prototype.payloadStart = false;
        prototype.pid = 0;
    }, {payload: "ByteBuffer"}, {});
    constructor.readPacket = function(channel) {
        var buffer = ByteBuffer.allocate(188);
        if (NIOUtils.readFromChannel(channel, buffer) != 188) 
            return null;
        buffer.flip();
        return MTSDemuxer.parsePacket(buffer);
    };
    constructor.parsePacket = function(buffer) {
        var marker = buffer.get() & 255;
        Assert.assertEquals(71, marker);
        var guidFlags = buffer.getShort();
        var guid = stjs.trunc(guidFlags) & 8191;
        var payloadStart = (guidFlags >> 14) & 1;
        var b0 = buffer.get() & 255;
        var counter = b0 & 15;
        if ((b0 & 32) != 0) {
            var taken = 0;
            taken = (buffer.get() & 255) + 1;
            NIOUtils.skip(buffer, taken - 1);
        }
        return new MTSDemuxer.MTSPacket(guid, payloadStart == 1, ((b0 & 16) != 0) ? buffer : null);
    };
    constructor.probe = function(b) {
        var streams = new IntObjectMap();
         while (true){
            try {
                var sub = NIOUtils.read(b, 188);
                if (sub.remaining() < 188) 
                    break;
                var tsPkt = MTSDemuxer.parsePacket(sub);
                if (tsPkt == null) 
                    break;
                var data = streams.get(tsPkt.pid);
                if (data == null) {
                    data = new ArrayList();
                    streams.put(tsPkt.pid, data);
                }
                if (tsPkt.payload != null) 
                    data.add(tsPkt.payload);
            }catch (t) {
                break;
            }
        }
        var maxScore = 0;
        var keys = streams.keys();
        for (var i in keys) {
            var packets = streams.get(i);
            var score = MPSDemuxer.probe(NIOUtils.combineBuffers(packets));
            if (score > maxScore) {
                maxScore = score + (packets.size() > 20 ? 50 : 0);
            }
        }
        return maxScore;
    };
    prototype.seekByte = function(offset) {
        this.tsChannel.setPosition(offset - (offset % 188));
        this.psDemuxer.reset();
    };
}, {psDemuxer: "MPSDemuxer", tsChannel: "SeekableByteChannel"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var DescriptorFactory = function() {};
DescriptorFactory = stjs.extend(DescriptorFactory, null, [IDescriptorFactory], function(constructor, prototype) {
    constructor.map = new HashMap();
    constructor.factory = new DescriptorFactory();
    prototype.byTag = function(tag) {
        return DescriptorFactory.map.get(tag);
    };
    constructor.getInstance = function() {
        return DescriptorFactory.factory;
    };
}, {map: {name: "Map", arguments: [null, {name: "Class", arguments: ["Object"]}]}, factory: "DescriptorFactory"}, {});
(function() {
    DescriptorFactory.map.put(ES.tag(), ES);
    DescriptorFactory.map.put(SL.tag(), SL);
    DescriptorFactory.map.put(DecoderConfig.tag(), DecoderConfig);
    DescriptorFactory.map.put(DecoderSpecific.tag(), DecoderSpecific);
})();
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var HLSFixPMT = function() {};
HLSFixPMT = stjs.extend(HLSFixPMT, null, [], function(constructor, prototype) {
    prototype.fix = function(file) {
        var ra = null;
        try {
            ra = new RandomAccessFile(file, "rw");
            var tsPkt = new Int8Array(188);
             while (ra.read(tsPkt) == 188){
                Assert.assertEquals(71, tsPkt[0] & 255);
                var guidFlags = ((tsPkt[1] & 255) << 8) | (tsPkt[2] & 255);
                var guid = stjs.trunc(guidFlags) & 8191;
                var payloadStart = (guidFlags >> 14) & 1;
                var b0 = tsPkt[3] & 255;
                var counter = b0 & 15;
                var payloadOff = 0;
                if ((b0 & 32) != 0) {
                    payloadOff = (tsPkt[4 + payloadOff] & 255) + 1;
                }
                if (payloadStart == 1) {
                    payloadOff += (tsPkt[4 + payloadOff] & 255) + 1;
                }
                if (guid == 0) {
                    if (payloadStart == 0) 
                         throw new RuntimeException("PAT spans multiple TS packets, not supported!!!!!!");
                    var bb = ByteBuffer.wrap(tsPkt, 4 + payloadOff, 184 - payloadOff);
                    HLSFixPMT.fixPAT(bb);
                    ra.seek(ra.getFilePointer() - 188);
                    ra.write(tsPkt);
                }
            }
        } finally {
            if (ra != null) 
                ra.close();
        }
    };
    constructor.fixPAT = function(data) {
        var table = data.duplicate();
        MTSUtils.parseSection(data);
        var newPmt = data.duplicate();
         while (data.remaining() > 4){
            var num = data.getShort();
            var pid = data.getShort();
            if (num != 0) {
                newPmt.putShort(num);
                newPmt.putShort(pid);
            }
        }
        if (newPmt.position() != data.position()) {
            var section = table.duplicate();
            section.get();
            var sectionLen = newPmt.position() - table.position() + 1;
            section.putShort(((((sectionLen & 4095) | 45056)) << 16 >> 16));
            var crc32 = new CRC32();
            table.setLimit(newPmt.position());
            crc32.update(NIOUtils.toArray(table));
            newPmt.putInt(((crc32.getValue()) | 0));
             while (newPmt.hasRemaining())
                newPmt.put((255 << 24 >> 24));
        }
    };
    constructor.main1 = function(args) {
        if (args.length < 1) 
            HLSFixPMT.exit("Please specify package location");
        var hlsPkg = new File(args[0]);
        if (!hlsPkg.isDirectory()) 
            HLSFixPMT.exit("Not an HLS package, expected a folder");
        var listFiles = hlsPkg.listFiles(new (stjs.extend(function HLSFixPMT$1() {}, null, [FilenameFilter], function(constructor, prototype) {
            prototype.accept = function(dir, name) {
                return name.endsWith(".ts");
            };
        }, {}, {}))());
        var fix = new HLSFixPMT();
        for (var i = 0; i < listFiles.length; i++) {
            var file = listFiles[i];
            System.err.println("Processing: " + file.getName());
            fix.fix(file);
        }
    };
    constructor.exit = function(message) {
        System.err.println("Syntax: hls_fixpmt <hls package location>");
        System.err.println(message);
        System.exit(-1);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var FixTimestamp = function() {};
FixTimestamp = stjs.extend(FixTimestamp, null, [], function(constructor, prototype) {
    prototype.fix = function(file) {
        var ra = null;
        try {
            ra = new RandomAccessFile(file, "rw");
            var ch = new FileChannelWrapper(ra.getChannel());
            var self = this;
            new (stjs.extend(function FixTimestamp$1(x0) {
                MTSUtils.TSReader.call(this, x0);
            }, MTSUtils.TSReader, [], function(constructor, prototype) {
                prototype.onPkt = function(guid, payloadStart, bb, filePos, sectionSyntax, fullPkt) {
                    return self.processPacket(payloadStart, bb, sectionSyntax, fullPkt);
                };
            }, {}, {}))(true).readTsFile(ch);
        } finally {
            if (ra != null) 
                ra.close();
        }
    };
    prototype.processPacket = function(payloadStart, bb, sectionSyntax, fullPkt) {
        if (!payloadStart || sectionSyntax) 
            return true;
        var streamId = bb.getInt();
        if (streamId == 445 || streamId >= 448 && streamId < 495) {
            var len = bb.getShort();
            var b0 = bb.get() & 255;
            bb.setPosition(bb.position() - 1);
            if ((b0 & 192) == 128) 
                this.fixMpeg2(streamId & 255, bb);
             else 
                this.fixMpeg1(streamId & 255, bb);
        }
        return true;
    };
    prototype.fixMpeg1 = function(streamId, is) {
        var c = is.getInt() & 255;
         while (c == 255){
            c = is.get() & 255;
        }
        if ((c & 192) == 64) {
            is.get();
            c = is.get() & 255;
        }
        if ((c & 240) == 32) {
            is.setPosition(is.position() - 1);
            this.fixTs(streamId, is, true);
        } else if ((c & 240) == 48) {
            is.setPosition(is.position() - 1);
            this.fixTs(streamId, is, true);
            this.fixTs(streamId, is, false);
        } else {
            if (c != 15) 
                 throw new RuntimeException("Invalid data");
        }
    };
    prototype.fixTs = function(streamId, is, isPts) {
        var b0 = is.get();
        var b1 = is.get();
        var b2 = is.get();
        var b3 = is.get();
        var b4 = is.get();
        var pts = ((stjs.trunc(b0) & 14) << 29) | ((b1 & 255) << 22) | (((b2 & 255) >> 1) << 15) | ((b3 & 255) << 7) | ((b4 & 255) >> 1);
        pts = this.doWithTimestamp(streamId, pts, isPts);
        is.setPosition(is.position() - 5);
        is.put((((b0 & 240) | (pts >>> 29) | 1) << 24 >> 24));
        is.put(((pts >>> 22) << 24 >> 24));
        is.put((((pts >>> 14) | 1) << 24 >> 24));
        is.put(((pts >>> 7) << 24 >> 24));
        is.put((((pts << 1) | 1) << 24 >> 24));
        return pts;
    };
    prototype.fixMpeg2 = function(streamId, is) {
        var flags1 = is.get() & 255;
        var flags2 = is.get() & 255;
        var header_len = is.get() & 255;
        if ((flags2 & 192) == 128) {
            this.fixTs(streamId, is, true);
        } else if ((flags2 & 192) == 192) {
            this.fixTs(streamId, is, true);
            this.fixTs(streamId, is, false);
        }
    };
    prototype.isVideo = function(streamId) {
        return streamId >= 224 && streamId <= 239;
    };
    prototype.isAudio = function(streamId) {
        return streamId >= 191 && streamId <= 223;
    };
    prototype.doWithTimestamp = function(streamId, pts, isPts) {};
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Gets media info from MPEG TS file
 *  
 *  @author The JCodec project
 *  
 */
var MTSMediaInfo = function() {};
MTSMediaInfo = stjs.extend(MTSMediaInfo, null, [], function(constructor, prototype) {
    prototype.getMediaInfo = function(f) {
        var ch = null;
        var pmtSections = new ArrayList();
        var pids = new HashMap();
        var result = new ArrayList();
        try {
            ch = NIOUtils.readableChannel(f);
            new (stjs.extend(function MTSMediaInfo$1(x0) {
                MTSUtils.TSReader.call(this, x0);
            }, MTSUtils.TSReader, [], function(constructor, prototype) {
                prototype.pmtBuffer = null;
                prototype.pmtPid = -1;
                prototype.pmtDone = false;
                prototype.onPkt = function(guid, payloadStart, tsBuf, filePos, sectionSyntax, fullPkt) {
                    if (guid == 0) {
                        this.pmtPid = MTSUtils.parsePAT(tsBuf);
                    } else if (guid == this.pmtPid && !this.pmtDone) {
                        if (this.pmtBuffer == null) {
                            this.pmtBuffer = ByteBuffer.allocate(((tsBuf.duplicate().getInt() >> 8) & 1023) + 3);
                        } else if (this.pmtBuffer.hasRemaining()) {
                            NIOUtils.writeL(this.pmtBuffer, tsBuf, Math.min(this.pmtBuffer.remaining(), tsBuf.remaining()));
                        }
                        if (!this.pmtBuffer.hasRemaining()) {
                            this.pmtBuffer.flip();
                            var pmt = MTSUtils.parsePMT(this.pmtBuffer);
                            pmtSections.add(pmt);
                            var streams = pmt.getStreams();
                            for (var i = 0; i < streams.length; i++) {
                                var stream = streams[i];
                                if (!pids.containsKey(stream.getPid())) 
                                    pids.put(stream.getPid(), new MPSMediaInfo());
                            }
                            this.pmtDone = pmt.getSectionNumber() == pmt.getLastSectionNumber();
                            this.pmtBuffer = null;
                        }
                    } else if (pids.containsKey(guid)) {
                        try {
                            pids.get(guid).analyseBuffer(tsBuf, filePos);
                        }catch (e) {
                            result.addAll(pids.get(guid).getInfos());
                            pids.remove(guid);
                            if (pids.size() == 0) 
                                return false;
                        }
                    }
                    return true;
                };
            }, {pmtBuffer: "ByteBuffer"}, {}))(false).readTsFile(ch);
        } finally {
            NIOUtils.closeQuietly(ch);
        }
        return result;
    };
    constructor.main1 = function(args) {
        var info = new MTSMediaInfo().getMediaInfo(new File(args[0]));
        for (var iterator$stream = info.iterator(); iterator$stream.hasNext(); ) {
            var stream = iterator$stream.next();
            System.out.println(stream.codec);
        }
    };
    constructor.extract = function(input) {
        return null;
    };
    prototype.getVideoTrack = function() {
        return null;
    };
    prototype.getAudioTracks = function() {
        return null;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Replaces pid of a stream with a different value
 *  
 *  @author Stan Vitvitskyy
 *  
 */
var MTSReplacePid = function(replaceSpec) {
    MTSUtils.TSReader.call(this, true);
    this.pmtPids = new HashSet();
    this.replaceSpec = replaceSpec;
};
MTSReplacePid = stjs.extend(MTSReplacePid, MTSUtils.TSReader, [], function(constructor, prototype) {
    prototype.pmtPids = null;
    prototype.replaceSpec = null;
    prototype.onPkt = function(guid, payloadStart, tsBuf, filePos, sectionSyntax, fullPkt) {
        if (sectionSyntax) {
            this.replaceRefs(this.replaceSpec, guid, tsBuf, this.pmtPids);
        } else {
            System.out.print("TS ");
            var buf = fullPkt.duplicate();
            var tsFlags = buf.getShortAt(buf.position() + 1);
            buf.putShort(buf.position() + 1, (((this.replacePid(this.replaceSpec, tsFlags & 8191) | (tsFlags & ~8191))) << 16 >> 16));
        }
        return true;
    };
    constructor.parseReplaceSpec = function(spec) {
        var map = new IntIntMap();
        for (var pidPair in spec.split(",")) {
            var pidPairParsed = pidPair.split(":");
            map.put(Integer.parseInt(pidPairParsed[0]), Integer.parseInt(pidPairParsed[1]));
        }
        return map;
    };
    prototype.replaceRefs = function(replaceSpec, guid, buf, pmtPids) {
        if (guid == 0) {
            var pat = PATSection.parsePAT(buf);
            for (var pids in pat.getPrograms().values()) {
                pmtPids.add(pids);
            }
        } else if (pmtPids.contains(guid)) {
            System.out.println(MainUtils.bold("PMT"));
            PSISection.parsePSI(buf);
            buf.getShort();
            NIOUtils.skip(buf, buf.getShort() & 4095);
             while (buf.remaining() > 4){
                var streamType = buf.get();
                var fromTag = MTSStreamType.fromTag(streamType);
                System.out.print((fromTag == null ? "UNKNOWN" : fromTag) + "(" + String.format("0x%02x", streamType) + "):\t");
                var wn = buf.getShort() & 65535;
                var wasPid = wn & 8191;
                var elementaryPid = this.replacePid(replaceSpec, wasPid);
                buf.putShort(buf.position() - 2, ((((elementaryPid & 8191) | (wn & ~8191))) << 16 >> 16));
                NIOUtils.skip(buf, buf.getShort() & 4095);
            }
        }
    };
    prototype.replacePid = function(replaceSpec, pid) {
        var newPid = pid;
        if (replaceSpec.contains(pid)) {
            newPid = replaceSpec.get(pid);
        }
        System.out.println("[" + pid + "->" + newPid + "]");
        return newPid;
    };
    constructor.main1 = function(args) {
        var cmd = MainUtils.parseArguments(args);
        if (cmd.args.length < 2) {
            MainUtils.printHelpNoFlags("pid_from:pid_to,[pid_from:pid_to...]", "file");
            return;
        }
        var replaceSpec = MTSReplacePid.parseReplaceSpec(cmd.getArg(0));
        var ch = null;
        try {
            ch = NIOUtils.rwChannel(new File(cmd.getArg(1)));
            new MTSReplacePid(replaceSpec).readTsFile(ch);
        } finally {
            NIOUtils.closeQuietly(ch);
        }
    };
}, {pmtPids: {name: "Set", arguments: [null]}, replaceSpec: "IntIntMap"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MTSRandomAccessDemuxer = function(ch, index) {
    this.programs = index.getPrograms();
    this.ch = ch;
};
MTSRandomAccessDemuxer = stjs.extend(MTSRandomAccessDemuxer, null, [], function(constructor, prototype) {
    prototype.programs = null;
    prototype.ch = null;
    prototype.getGuids = function() {
        var guids = new Int32Array(this.programs.length);
        for (var i = 0; i < this.programs.length; i++) 
            guids[i] = this.programs[i].getTargetGuid();
        return guids;
    };
    prototype.getProgramDemuxer = function(tgtGuid) {
        var index = this.getProgram(tgtGuid);
        return new (stjs.extend(function MTSRandomAccessDemuxer$1(x0, x1) {
            MPSRandomAccessDemuxer.call(this, x0, x1);
        }, MPSRandomAccessDemuxer, [], function(constructor, prototype) {
            prototype.newStream = function(ch, streamIndex) {
                return new (stjs.extend(function MTSRandomAccessDemuxer$1$1(x0, x1, x2) {
                    MPSRandomAccessDemuxer.Stream.call(this, x0, x1, x2);
                }, MPSRandomAccessDemuxer.Stream, [], function(constructor, prototype) {
                    prototype.fetch = function(pesLen) {
                        var bb = ByteBuffer.allocate(pesLen * 188);
                        for (var i = 0; i < pesLen; i++) {
                            var tsBuf = NIOUtils.fetchFromChannel(this.source, 188);
                            Assert.assertEquals(71, tsBuf.get() & 255);
                            var guidFlags = ((tsBuf.get() & 255) << 8) | (tsBuf.get() & 255);
                            var guid = stjs.trunc(guidFlags) & 8191;
                            if (guid != tgtGuid) 
                                continue;
                            var payloadStart = (guidFlags >> 14) & 1;
                            var b0 = tsBuf.get() & 255;
                            var counter = b0 & 15;
                            if ((b0 & 32) != 0) {
                                NIOUtils.skip(tsBuf, tsBuf.get() & 255);
                            }
                            bb.putBuf(tsBuf);
                        }
                        bb.flip();
                        return bb;
                    };
                    prototype.skip = function(leadingSize) {
                        this.source.setPosition(this.source.position() + leadingSize * 188);
                    };
                    prototype.reset = function() {
                        this.source.setPosition(0);
                    };
                }, {pesBuf: "ByteBuffer", source: "SeekableByteChannel", foffs: "Array", demuxer: "MPSRandomAccessDemuxer", fsizes: "Int32Array", fpts: "Int32Array", fdur: "Int32Array", sync: "Int32Array"}, {}))(this, streamIndex, ch);
            };
        }, {streams: "Array", pesTokens: "Array", pesStreamIds: "Int32Array"}, {}))(this.ch, index);
    };
    prototype.getProgram = function(guid) {
        for (var mtsProgram in this.programs) {
            if (mtsProgram.getTargetGuid() == guid) 
                return mtsProgram;
        }
        return null;
    };
}, {programs: "Array", ch: "SeekableByteChannel"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Indexes MPEG PS file for the purpose of quick random access in the future
 *  
 *  @author The JCodec project
 *  
 */
var MPSIndexer = function() {
    BaseIndexer.call(this);
};
MPSIndexer = stjs.extend(MPSIndexer, BaseIndexer, [], function(constructor, prototype) {
    prototype.predFileStart = 0;
    prototype.index = function(source, listener) {
        this.newReader().readFile(source, 65536, listener);
    };
    prototype.indexChannel = function(source, listener) {
        this.newReader().readChannel(source, 65536, listener);
    };
    prototype.newReader = function() {
        return new (stjs.extend(function MPSIndexer$1() {
            NIOUtils.FileReader.call(this);
        }, NIOUtils.FileReader, [], function(constructor, prototype) {
            prototype.data = function(data, filePos) {
                this.analyseBuffer(data, filePos);
            };
            prototype.done = function() {
                this.finishAnalyse();
            };
        }, {}, {}))();
    };
    prototype.pes = function(pesBuffer, start, pesLen, stream) {
        if (!MPSUtils.mediaStream(stream)) 
            return;
        var pesHeader = MPSUtils.readPESHeader(pesBuffer, start);
        var leading = 0;
        if (this.predFileStart != start) {
            leading += (((start - this.predFileStart)) | 0);
        }
        this.predFileStart = start + pesLen;
        this.savePESMeta(stream, MPSIndex.makePESToken(leading, pesLen, pesBuffer.remaining()));
        this.getAnalyser(stream).pkt(pesBuffer, pesHeader);
    };
    constructor.main1 = function(args) {
        var indexer = new MPSIndexer();
        indexer.index(new File(args[0]), new (stjs.extend(function MPSIndexer$2() {}, null, [NIOUtils.FileReaderListener], function(constructor, prototype) {
            prototype.progress = function(percentDone) {
                System.out.println(percentDone);
            };
        }, {}, {}))());
        var index = ByteBuffer.allocate(65536);
        indexer.serialize().serializeTo(index);
        NIOUtils.writeTo(index, new File(args[1]));
    };
}, {analyzers: {name: "Map", arguments: [null, "BaseIndexer.BaseAnalyser"]}, tokens: "LongArrayList", streams: "RunLength.Integer", pesBuffer: "ByteBuffer"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Indexes MPEG TS file for the purpose of quick random access in the future
 *  
 *  @author The JCodec project
 *  
 */
var MTSIndexer = function() {};
MTSIndexer = stjs.extend(MTSIndexer, null, [], function(constructor, prototype) {
    constructor.BUFFER_SIZE = 188 << 9;
    prototype.indexers = null;
    prototype.index = function(source, listener) {
        this.indexReader(listener, MTSUtils.getMediaPids(source)).readFile(source, MTSIndexer.BUFFER_SIZE, listener);
    };
    prototype.indexChannel = function(source, listener) {
        this.indexReader(listener, MTSUtils.getMediaPidsFromChannel(source)).readChannel(source, MTSIndexer.BUFFER_SIZE, listener);
    };
    prototype.indexReader = function(listener, targetGuids) {
        this.indexers = Array(targetGuids.length);
        for (var i = 0; i < targetGuids.length; i++) {
            this.indexers[i] = new MTSIndexer.MTSAnalyser(targetGuids[i]);
        }
        return new MTSIndexer.MTSFileReader(this);
    };
    prototype.serialize = function() {
        var programs = Array(this.indexers.length);
        for (var i = 0; i < this.indexers.length; i++) 
            programs[i] = this.indexers[i].serializeTo();
        return new MTSIndex(programs);
    };
    constructor.MTSFileReader = function(indexer) {
        NIOUtils.FileReader.call(this);
        this.indexer = indexer;
    };
    constructor.MTSFileReader = stjs.extend(constructor.MTSFileReader, NIOUtils.FileReader, [], function(constructor, prototype) {
        prototype.indexer = null;
        prototype.data = function(data, filePos) {
            this.analyseBuffer(data, filePos);
        };
        prototype.analyseBuffer = function(buf, pos) {
             while (buf.hasRemaining()){
                var tsBuf = NIOUtils.read(buf, 188);
                pos += 188;
                Assert.assertEquals(71, tsBuf.get() & 255);
                var guidFlags = ((tsBuf.get() & 255) << 8) | (tsBuf.get() & 255);
                var guid = stjs.trunc(guidFlags) & 8191;
                for (var i = 0; i < this.indexer.indexers.length; i++) {
                    if (guid == this.indexer.indexers[i].targetGuid) {
                        var payloadStart = (guidFlags >> 14) & 1;
                        var b0 = tsBuf.get() & 255;
                        var counter = b0 & 15;
                        if ((b0 & 32) != 0) {
                            NIOUtils.skip(tsBuf, tsBuf.get() & 255);
                        }
                        this.indexer.indexers[i].analyseBuffer(tsBuf, pos - tsBuf.remaining());
                    }
                }
            }
        };
        prototype.done = function() {
            for (var mtsAnalyser in this.indexer.indexers) {
                mtsAnalyser.finishAnalyse();
            }
        };
    }, {indexer: "MTSIndexer"}, {});
    constructor.MTSAnalyser = function(targetGuid) {
        BaseIndexer.call(this);
        this.targetGuid = targetGuid;
    };
    constructor.MTSAnalyser = stjs.extend(constructor.MTSAnalyser, BaseIndexer, [], function(constructor, prototype) {
        prototype.targetGuid = 0;
        prototype.predFileStartInTsPkt = 0;
        prototype.serializeTo = function() {
            return MTSIndex.createMTSProgram(BaseIndexer.prototype.serialize.call(this), this.targetGuid);
        };
        prototype.pes = function(pesBuffer, start, pesLen, stream) {
            if (!MPSUtils.mediaStream(stream)) 
                return;
            jcodec.Logger.debug(String.format("PES: %08x, %d", start, pesLen));
            var pesHeader = MPSUtils.readPESHeader(pesBuffer, start);
            var leadingTsPkt = 0;
            if (this.predFileStartInTsPkt != start) {
                leadingTsPkt = (((stjs.trunc(start / 188) - this.predFileStartInTsPkt)) | 0);
            }
            this.predFileStartInTsPkt = stjs.trunc((start + pesLen) / 188);
            var tsPktInPes = (((this.predFileStartInTsPkt - stjs.trunc(start / 188))) | 0);
            this.savePESMeta(stream, MPSIndex.makePESToken(leadingTsPkt, tsPktInPes, pesBuffer.remaining()));
            this.getAnalyser(stream).pkt(pesBuffer, pesHeader);
        };
    }, {analyzers: {name: "Map", arguments: [null, "BaseIndexer.BaseAnalyser"]}, tokens: "LongArrayList", streams: "RunLength.Integer", pesBuffer: "ByteBuffer"}, {});
    constructor.main1 = function(args) {
        var src = new File(args[0]);
        var indexer = new MTSIndexer();
        indexer.index(src, new (stjs.extend(function MTSIndexer$1() {}, null, [NIOUtils.FileReaderListener], function(constructor, prototype) {
            prototype.progress = function(percentDone) {
                System.out.println(percentDone);
            };
        }, {}, {}))());
        var index = indexer.serialize();
        NIOUtils.writeTo(index.serialize(), new File(args[1]));
    };
}, {indexers: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var FileDescriptor = function(ul) {
    GenericDescriptor.call(this, ul);
};
FileDescriptor = stjs.extend(FileDescriptor, GenericDescriptor, [], function(constructor, prototype) {
    prototype.linkedTrackId = 0;
    prototype.sampleRate = null;
    prototype.containerDuration = 0;
    prototype.essenceContainer = null;
    prototype.codec = null;
    prototype.read = function(tags) {
        GenericDescriptor.prototype.read.call(this, tags);
        for (var it = tags.entrySet().iterator(); it.hasNext(); ) {
            var entry = it.next();
            var _bb = entry.getValue();
            switch (entry.getKey()) {
                case 12294:
                    this.linkedTrackId = _bb.getInt();
                    break;
                case 12289:
                    this.sampleRate = new Rational(_bb.getInt(), _bb.getInt());
                    break;
                case 12290:
                    this.containerDuration = _bb.getLong();
                    break;
                case 12292:
                    this.essenceContainer = UL.read(_bb);
                    break;
                case 12293:
                    this.codec = UL.read(_bb);
                    break;
                default:
                    jcodec.Logger.warn(String.format("Unknown tag [ " + this.ul + "]: %04x", entry.getKey()));
                    continue;
            }
            it.remove();
        }
    };
    prototype.getLinkedTrackId = function() {
        return this.linkedTrackId;
    };
    prototype.getSampleRate = function() {
        return this.sampleRate;
    };
    prototype.getContainerDuration = function() {
        return this.containerDuration;
    };
    prototype.getEssenceContainer = function() {
        return this.essenceContainer;
    };
    prototype.getCodec = function() {
        return this.codec;
    };
}, {sampleRate: "Rational", essenceContainer: "UL", codec: "UL", locators: "Array", subDescriptors: "Array", generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MaterialPackage = function(ul) {
    GenericPackage.call(this, ul);
};
MaterialPackage = stjs.extend(MaterialPackage, GenericPackage, [], null, {tracks: "Array", packageUID: "UL", packageModifiedDate: "jsutil.Date", packageCreationDate: "jsutil.Date", generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var SourcePackage = function(ul) {
    GenericPackage.call(this, ul);
};
SourcePackage = stjs.extend(SourcePackage, GenericPackage, [], function(constructor, prototype) {
    prototype.trackRefs = null;
    prototype.descriptorRef = null;
    prototype.read = function(tags) {
        GenericPackage.prototype.read.call(this, tags);
        for (var it = tags.entrySet().iterator(); it.hasNext(); ) {
            var entry = it.next();
            var _bb = entry.getValue();
            switch (entry.getKey()) {
                case 18177:
                    this.descriptorRef = UL.read(_bb);
                    break;
                default:
                    jcodec.Logger.warn(String.format("Unknown tag [ " + this.ul + "]: %04x", entry.getKey()));
                    continue;
            }
            it.remove();
        }
    };
    prototype.getTrackRefs = function() {
        return this.trackRefs;
    };
    prototype.getDescriptorRef = function() {
        return this.descriptorRef;
    };
}, {trackRefs: "Array", descriptorRef: "UL", tracks: "Array", packageUID: "UL", packageModifiedDate: "jsutil.Date", packageCreationDate: "jsutil.Date", generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Sequence = function(ul) {
    MXFStructuralComponent.call(this, ul);
};
Sequence = stjs.extend(Sequence, MXFStructuralComponent, [], function(constructor, prototype) {
    prototype.structuralComponentsRefs = null;
    prototype.read = function(tags) {
        MXFStructuralComponent.prototype.read.call(this, tags);
        for (var it = tags.entrySet().iterator(); it.hasNext(); ) {
            var entry = it.next();
            switch (entry.getKey()) {
                case 4097:
                    this.structuralComponentsRefs = MXFMetadata.readULBatch(entry.getValue());
                    break;
                default:
                    jcodec.Logger.warn(String.format("Unknown tag [ " + this.ul + "]: %04x", entry.getKey()));
                    continue;
            }
            it.remove();
        }
    };
    prototype.getStructuralComponentsRefs = function() {
        return this.structuralComponentsRefs;
    };
}, {structuralComponentsRefs: "Array", dataDefinitionUL: "UL", generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var SourceClip = function(ul) {
    MXFStructuralComponent.call(this, ul);
};
SourceClip = stjs.extend(SourceClip, MXFStructuralComponent, [], function(constructor, prototype) {
    prototype.startPosition = 0;
    prototype.sourceTrackId = 0;
    prototype.sourcePackageUid = null;
    prototype.read = function(tags) {
        MXFStructuralComponent.prototype.read.call(this, tags);
        for (var it = tags.entrySet().iterator(); it.hasNext(); ) {
            var entry = it.next();
            var _bb = entry.getValue();
            switch (entry.getKey()) {
                case 4609:
                    this.startPosition = _bb.getLong();
                    break;
                case 4353:
                    this.sourcePackageUid = UL.read(_bb);
                    break;
                case 4354:
                    this.sourceTrackId = _bb.getInt();
                    break;
                default:
                    jcodec.Logger.warn(String.format("Unknown tag [ " + this.ul + "]: %04x", entry.getKey()));
                    continue;
            }
            it.remove();
        }
    };
    prototype.getSourcePackageUid = function() {
        return this.sourcePackageUid;
    };
    prototype.getStartPosition = function() {
        return this.startPosition;
    };
    prototype.getSourceTrackId = function() {
        return this.sourceTrackId;
    };
}, {sourcePackageUid: "UL", dataDefinitionUL: "UL", generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var TimecodeComponent = function(ul) {
    MXFStructuralComponent.call(this, ul);
};
TimecodeComponent = stjs.extend(TimecodeComponent, MXFStructuralComponent, [], function(constructor, prototype) {
    prototype.start = 0;
    prototype.base = 0;
    prototype.dropFrame = 0;
    prototype.read = function(tags) {
        MXFStructuralComponent.prototype.read.call(this, tags);
        for (var it = tags.entrySet().iterator(); it.hasNext(); ) {
            var entry = it.next();
            var _bb = entry.getValue();
            switch (entry.getKey()) {
                case 5377:
                    this.start = _bb.getLong();
                    break;
                case 5378:
                    this.base = _bb.getShort();
                    break;
                case 5379:
                    this.dropFrame = _bb.get();
                    break;
                default:
                    jcodec.Logger.warn(String.format("Unknown tag [ " + this.ul + "]: %04x", entry.getKey()));
                    continue;
            }
            it.remove();
        }
    };
    prototype.getStart = function() {
        return this.start;
    };
    prototype.getBase = function() {
        return this.base;
    };
    prototype.getDropFrame = function() {
        return this.dropFrame;
    };
}, {dataDefinitionUL: "UL", generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var TimelineTrack = function(ul) {
    GenericTrack.call(this, ul);
};
TimelineTrack = stjs.extend(TimelineTrack, GenericTrack, [], function(constructor, prototype) {
    prototype.editRate = null;
    prototype.origin = 0;
    prototype.read = function(tags) {
        GenericTrack.prototype.read.call(this, tags);
        for (var it = tags.entrySet().iterator(); it.hasNext(); ) {
            var entry = it.next();
            var _bb = entry.getValue();
            switch (entry.getKey()) {
                case 19201:
                    this.editRate = new Rational(_bb.getInt(), _bb.getInt());
                    break;
                case 19202:
                    this.origin = _bb.getLong();
                    break;
                default:
                    jcodec.Logger.warn(String.format("Unknown tag [ " + this.ul + "]: %04x", entry.getKey()));
                    continue;
            }
            it.remove();
        }
    };
    prototype.getEditRate = function() {
        return this.editRate;
    };
    prototype.getOrigin = function() {
        return this.origin;
    };
}, {editRate: "Rational", sequenceRef: "UL", generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed under FreeBSD License
 *  
 *  EBML IO implementation
 *  
 *  @author The JCodec project
 *  
 */
var MKVParser = function(channel) {
    this.channel = channel;
    this.trace = new LinkedList();
};
MKVParser = stjs.extend(MKVParser, null, [], function(constructor, prototype) {
    prototype.channel = null;
    prototype.trace = null;
    prototype.parse = function() {
        var tree = new ArrayList();
        var e = null;
         while ((e = this.nextElement()) != null){
            if (!this.isKnownType(e.id)) 
                System.err.println("Unspecified header: " + EbmlUtil.toHexString(e.id) + " at " + e.offset);
             while (!this.possibleChild(this.trace.peekFirst(), e))
                this.closeElem(this.trace.removeFirst(), tree);
            this.openElem(e);
            if (stjs.isInstanceOf(e.constructor, EbmlMaster)) {
                this.trace.push(e);
            } else if (stjs.isInstanceOf(e.constructor, EbmlBin)) {
                var bin = e;
                var traceTop = this.trace.peekFirst();
                if ((traceTop.dataOffset + traceTop.dataLen) < (e.dataOffset + e.dataLen)) {
                    this.channel.setPosition((traceTop.dataOffset + traceTop.dataLen));
                } else 
                    try {
                        bin.readChannel(this.channel);
                    }catch (oome) {
                         throw new RuntimeException(e.type + " 0x" + EbmlUtil.toHexString(bin.id) + " size: " + Long.toHexString(bin.dataLen) + " offset: 0x" + Long.toHexString(e.offset), oome);
                    }
                this.trace.peekFirst().add(e);
            } else if (stjs.isInstanceOf(e.constructor, EbmlVoid)) {
                (e).skip(this.channel);
            } else {
                 throw new RuntimeException("Currently there are no elements that are neither Master nor Binary, should never actually get here");
            }
        }
         while (this.trace.peekFirst() != null)
            this.closeElem(this.trace.removeFirst(), tree);
        return tree;
    };
    prototype.possibleChild = function(parent, child) {
        if (parent != null && MKVType.Cluster.equals(parent.type) && child != null && !MKVType.Cluster.equals(child.type) && !MKVType.Info.equals(child.type) && !MKVType.SeekHead.equals(child.type) && !MKVType.Tracks.equals(child.type) && !MKVType.Cues.equals(child.type) && !MKVType.Attachments.equals(child.type) && !MKVType.Tags.equals(child.type) && !MKVType.Chapters.equals(child.type)) 
            return true;
        return MKVType.possibleChild(parent, child);
    };
    prototype.openElem = function(e) {};
    prototype.closeElem = function(e, tree) {
        if (this.trace.peekFirst() == null) {
            tree.add(e);
        } else {
            this.trace.peekFirst().add(e);
        }
    };
    prototype.nextElement = function() {
        var offset = this.channel.position();
        if (offset >= this.channel.size()) 
            return null;
        var typeId = MKVParser.readEbmlId(this.channel);
         while ((typeId == null && !this.isKnownType(typeId)) && offset < this.channel.size()){
            offset++;
            this.channel.setPosition(offset);
            typeId = MKVParser.readEbmlId(this.channel);
        }
        var dataLen = MKVParser.readEbmlInt(this.channel);
        var elem = MKVType.createById(typeId, offset);
        elem.offset = offset;
        elem.typeSizeLength = (((this.channel.position() - offset)) | 0);
        elem.dataOffset = this.channel.position();
        elem.dataLen = ((dataLen) | 0);
        return elem;
    };
    prototype.isKnownType = function(b) {
        if (!this.trace.isEmpty() && MKVType.Cluster.equals(this.trace.peekFirst().type)) 
            return true;
        return MKVType.isSpecifiedHeader(b);
    };
    /**
     *  Reads an EBML id from the channel. EBML ids have length encoded inside of them For instance, all one-byte ids have first byte set to '1', like 0xA3 or 0xE7, whereas the two-byte ids have first
     *  byte set to '0' and second byte set to '1', thus: 0x42 0x86  or 0x42 0xF7
     *  
     *  @return byte array filled with the ebml id
     *  @throws IOException
     */
    constructor.readEbmlId = function(source) {
        if (source.position() == source.size()) 
            return null;
        var buffer = ByteBuffer.allocate(8);
        buffer.setLimit(1);
        source.read(buffer);
        buffer.flip();
        var firstByte = buffer.get();
        var numBytes = EbmlUtil.computeLength(firstByte);
        if (numBytes == 0) 
            return null;
        if (numBytes > 1) {
            buffer.setLimit(numBytes);
            source.read(buffer);
        }
        buffer.flip();
        var val = ByteBuffer.allocate(buffer.remaining());
        val.putBuf(buffer);
        return val.array();
    };
    constructor.readEbmlInt = function(source) {
        var buffer = ByteBuffer.allocate(8);
        buffer.setLimit(1);
        source.read(buffer);
        buffer.flip();
        var firstByte = stjs.trunc(buffer.get());
        var length = EbmlUtil.computeLength(firstByte);
        if (length == 0) 
             throw new RuntimeException("Invalid ebml integer size.");
        buffer.setLimit(length);
        source.read(buffer);
        buffer.setPosition(1);
        var value = firstByte & (255 >>> length);
        length--;
         while (length > 0){
            value = (value << 8) | (buffer.get() & 255);
            length--;
        }
        return value;
    };
}, {channel: "SeekableByteChannel", trace: {name: "LinkedList", arguments: ["EbmlMaster"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed under FreeBSD License
 *  
 *  EBML IO implementation
 *  
 *  @author The JCodec project
 *  
 */
var SeekHeadFactory = function() {
    this.a = new ArrayList();
};
SeekHeadFactory = stjs.extend(SeekHeadFactory, null, [], function(constructor, prototype) {
    prototype.a = null;
    prototype.currentDataOffset = 0;
    prototype.add = function(e) {
        var z = SeekHeadFactory.SeekMock.make(e);
        z.dataOffset = this.currentDataOffset;
        z.seekPointerSize = EbmlUint.calculatePayloadSize(z.dataOffset);
        this.currentDataOffset += z.size;
        this.a.add(z);
    };
    prototype.indexSeekHead = function() {
        var seekHeadSize = this.computeSeekHeadSize();
        var seekHead = MKVType.createByType(MKVType.SeekHead);
        for (var iterator$z = this.a.iterator(); iterator$z.hasNext(); ) {
            var z = iterator$z.next();
            var seek = MKVType.createByType(MKVType.Seek);
            var seekId = MKVType.createByType(MKVType.SeekID);
            seekId.setBuf(ByteBuffer.wrap(z.id));
            seek.add(seekId);
            var seekPosition = MKVType.createByType(MKVType.SeekPosition);
            seekPosition.setUint(z.dataOffset + seekHeadSize);
            if (seekPosition.data.limit() != z.seekPointerSize) 
                System.err.println("estimated size of seekPosition differs from the one actually used. ElementId: " + EbmlUtil.toHexString(z.id) + " " + seekPosition.getData().limit() + " vs " + z.seekPointerSize);
            seek.add(seekPosition);
            seekHead.add(seek);
        }
        var mux = seekHead.getData();
        if (mux.limit() != seekHeadSize) 
            System.err.println("estimated size of seekHead differs from the one actually used. " + mux.limit() + " vs " + seekHeadSize);
        return seekHead;
    };
    prototype.computeSeekHeadSize = function() {
        var seekHeadSize = this.estimateSize();
        var reindex = false;
        do {
            reindex = false;
            for (var iterator$z = this.a.iterator(); iterator$z.hasNext(); ) {
                var z = iterator$z.next();
                var minSize = EbmlUint.calculatePayloadSize(z.dataOffset + seekHeadSize);
                if (minSize > z.seekPointerSize) {
                    System.out.println("Size " + seekHeadSize + " seems too small for element " + EbmlUtil.toHexString(z.id) + " increasing size by one.");
                    z.seekPointerSize += 1;
                    seekHeadSize += 1;
                    reindex = true;
                    break;
                } else if (minSize < z.seekPointerSize) {
                     throw new RuntimeException("Downsizing the index is not well thought through.");
                }
            }
        } while (reindex);
        return seekHeadSize;
    };
    prototype.estimateSize = function() {
        var s = MKVType.SeekHead.id.length + 1;
        s += SeekHeadFactory.estimeteSeekSize(this.a.get(0).id.length, 1);
        for (var i = 1; i < this.a.size(); i++) {
            s += SeekHeadFactory.estimeteSeekSize(this.a.get(i).id.length, this.a.get(i).seekPointerSize);
        }
        return s;
    };
    constructor.estimeteSeekSize = function(idLength, offsetSizeInBytes) {
        var seekIdSize = MKVType.SeekID.id.length + EbmlUtil.ebmlLength(idLength) + idLength;
        var seekPositionSize = MKVType.SeekPosition.id.length + EbmlUtil.ebmlLength(offsetSizeInBytes) + offsetSizeInBytes;
        var seekSize = MKVType.Seek.id.length + EbmlUtil.ebmlLength(seekIdSize + seekPositionSize) + seekIdSize + seekPositionSize;
        return seekSize;
    };
    constructor.SeekMock = function() {};
    constructor.SeekMock = stjs.extend(constructor.SeekMock, null, [], function(constructor, prototype) {
        prototype.dataOffset = 0;
        prototype.id = null;
        prototype.size = 0;
        prototype.seekPointerSize = 0;
        constructor.make = function(e) {
            var z = new SeekHeadFactory.SeekMock();
            z.id = e.id;
            z.size = ((e.size()) | 0);
            return z;
        };
    }, {id: "Int8Array"}, {});
}, {a: {name: "List", arguments: ["SeekHeadFactory.SeekMock"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed under FreeBSD License
 *  
 *  EBML IO implementation
 *  
 *  @author The JCodec project
 *  
 */
var CuesFactory = function(offset, videoTrack) {
    this.a = new ArrayList();
    this.offsetBase = offset;
    this.videoTrackNr = videoTrack;
    this.currentDataOffset += this.offsetBase;
};
CuesFactory = stjs.extend(CuesFactory, null, [], function(constructor, prototype) {
    prototype.a = null;
    prototype.offsetBase = 0;
    prototype.currentDataOffset = 0;
    prototype.videoTrackNr = 0;
    prototype.addFixedSize = function(z) {
        z.elementOffset = this.currentDataOffset;
        z.cueClusterPositionSize = 8;
        this.currentDataOffset += z.size;
        this.a.add(z);
    };
    prototype.add = function(z) {
        z.elementOffset = this.currentDataOffset;
        z.cueClusterPositionSize = EbmlUint.calculatePayloadSize(z.elementOffset);
        this.currentDataOffset += z.size;
        this.a.add(z);
    };
    prototype.createCues = function() {
        var estimatedSize = this.computeCuesSize();
        var cues = MKVType.createByType(MKVType.Cues);
        for (var iterator$cpm = this.a.iterator(); iterator$cpm.hasNext(); ) {
            var cpm = iterator$cpm.next();
            var cuePoint = MKVType.createByType(MKVType.CuePoint);
            var cueTime = MKVType.createByType(MKVType.CueTime);
            cueTime.setUint(cpm.timecode);
            cuePoint.add(cueTime);
            var cueTrackPositions = MKVType.createByType(MKVType.CueTrackPositions);
            var cueTrack = MKVType.createByType(MKVType.CueTrack);
            cueTrack.setUint(this.videoTrackNr);
            cueTrackPositions.add(cueTrack);
            var cueClusterPosition = MKVType.createByType(MKVType.CueClusterPosition);
            cueClusterPosition.setUint(cpm.elementOffset + estimatedSize);
            if (cueClusterPosition.data.limit() != cpm.cueClusterPositionSize) 
                System.err.println("estimated size of CueClusterPosition differs from the one actually used. ElementId: " + EbmlUtil.toHexString(cpm.id) + " " + cueClusterPosition.getData().limit() + " vs " + cpm.cueClusterPositionSize);
            cueTrackPositions.add(cueClusterPosition);
            cuePoint.add(cueTrackPositions);
            cues.add(cuePoint);
        }
        return cues;
    };
    prototype.computeCuesSize = function() {
        var cuesSize = this.estimateSize();
        var reindex = false;
        do {
            reindex = false;
            for (var iterator$z = this.a.iterator(); iterator$z.hasNext(); ) {
                var z = iterator$z.next();
                var minByteSize = EbmlUint.calculatePayloadSize(z.elementOffset + cuesSize);
                if (minByteSize > z.cueClusterPositionSize) {
                    System.err.println("Size " + cuesSize + " seems too small for element " + EbmlUtil.toHexString(z.id) + " increasing size by one.");
                    z.cueClusterPositionSize += 1;
                    cuesSize += 1;
                    reindex = true;
                    break;
                } else if (minByteSize < z.cueClusterPositionSize) {
                     throw new RuntimeException("Downsizing the index is not well thought through");
                }
            }
        } while (reindex);
        return cuesSize;
    };
    prototype.estimateFixedSize = function(numberOfClusters) {
        var s = 34 * numberOfClusters;
        s += MKVType.Cues.id.length + EbmlUtil.ebmlLength(s);
        return s;
    };
    prototype.estimateSize = function() {
        var s = 0;
        for (var iterator$cpm = this.a.iterator(); iterator$cpm.hasNext(); ) {
            var cpm = iterator$cpm.next();
            s += CuesFactory.estimateCuePointSize(EbmlUint.calculatePayloadSize(cpm.timecode), EbmlUint.calculatePayloadSize(this.videoTrackNr), EbmlUint.calculatePayloadSize(cpm.elementOffset));
        }
        s += MKVType.Cues.id.length + EbmlUtil.ebmlLength(s);
        return s;
    };
    constructor.estimateCuePointSize = function(timecodeSizeInBytes, trackNrSizeInBytes, clusterPositionSizeInBytes) {
        var cueTimeSize = MKVType.CueTime.id.length + EbmlUtil.ebmlLength(timecodeSizeInBytes) + timecodeSizeInBytes;
        var cueTrackPositionSize = MKVType.CueTrack.id.length + EbmlUtil.ebmlLength(trackNrSizeInBytes) + trackNrSizeInBytes + MKVType.CueClusterPosition.id.length + EbmlUtil.ebmlLength(clusterPositionSizeInBytes) + clusterPositionSizeInBytes;
        cueTrackPositionSize += MKVType.CueTrackPositions.id.length + EbmlUtil.ebmlLength(cueTrackPositionSize);
        var cuePointSize = MKVType.CuePoint.id.length + EbmlUtil.ebmlLength(cueTimeSize + cueTrackPositionSize) + cueTimeSize + cueTrackPositionSize;
        return cuePointSize;
    };
    constructor.CuePointMock = function() {};
    constructor.CuePointMock = stjs.extend(constructor.CuePointMock, null, [], function(constructor, prototype) {
        prototype.cueClusterPositionSize = 0;
        prototype.elementOffset = 0;
        prototype.timecode = 0;
        prototype.size = 0;
        prototype.id = null;
        constructor.make = function(c) {
            var path = [MKVType.Cluster, MKVType.Timecode];
            var tc = MKVType.findFirst(c, path);
            return CuesFactory.CuePointMock.doMake(c.id, tc.getUint(), c.size());
        };
        constructor.doMake = function(id, timecode, size) {
            var mock = new CuesFactory.CuePointMock();
            mock.id = id;
            mock.timecode = timecode;
            mock.size = size;
            return mock;
        };
    }, {id: "Int8Array"}, {});
}, {a: {name: "List", arguments: ["CuesFactory.CuePointMock"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Coupling_channel_element; reference: table 4.8.
 *  
 *  @author The JCodec project
 *  
 */
var BlockCCE = function(bandType) {
    Block.call(this);
    this.bandType = bandType;
};
BlockCCE = stjs.extend(BlockCCE, Block, [], function(constructor, prototype) {
    prototype.coupling_point = 0;
    prototype.num_coupled = 0;
    prototype.type = null;
    prototype.id_select = null;
    prototype.ch_select = null;
    prototype.sign = 0;
    prototype.scale = null;
    prototype.cce_scale = null;
    prototype.blockICS = null;
    prototype.bandType = null;
    constructor.vlc = null;
    prototype.parse = function(_in) {
        var num_gain = 0;
        this.coupling_point = 2 * _in.read1Bit();
        this.num_coupled = _in.readNBit(3);
        for (var c = 0; c <= this.num_coupled; c++) {
            num_gain++;
            this.type[c] = _in.read1Bit() != 0 ? BlockType.TYPE_CPE : BlockType.TYPE_SCE;
            this.id_select[c] = _in.readNBit(4);
            if (this.type[c] == BlockType.TYPE_CPE) {
                this.ch_select[c] = _in.readNBit(2);
                if (this.ch_select[c] == 3) 
                    num_gain++;
            } else 
                this.ch_select[c] = 2;
        }
        this.coupling_point += _in.read1Bit() | (this.coupling_point >> 1);
        this.sign = _in.read1Bit();
        this.scale = this.cce_scale[_in.readNBit(2)];
        this.blockICS = new BlockICS();
        this.blockICS.parse(_in);
        for (var c = 0; c < num_gain; c++) {
            var idx = 0;
            var cge = 1;
            var gain = 0;
            if (c != 0) {
                cge = this.coupling_point == BlockCCE.CouplingPoint.AFTER_IMDCT.ordinal() ? 1 : _in.read1Bit();
                gain = cge != 0 ? BlockCCE.vlc.readVLC(_in) - 60 : 0;
            }
            if (this.coupling_point != BlockCCE.CouplingPoint.AFTER_IMDCT.ordinal()) {
                for (var g = 0; g < this.blockICS.num_window_groups; g++) {
                    for (var sfb = 0; sfb < this.blockICS.maxSfb; sfb++ , idx++) {
                        if (this.bandType[idx] != BlockICS.BandType.ZERO_BT) {
                            if (cge == 0) {
                                var t = BlockCCE.vlc.readVLC(_in) - 60;
                            }
                        }
                    }
                }
            }
        }
    };
    constructor.CouplingPoint = stjs.enumeration("BEFORE_TNS", "BETWEEN_TNS_AND_IMDCT", "UNDEF", "AFTER_IMDCT");
}, {type: "Array", id_select: "Int32Array", ch_select: "Int32Array", scale: "Object", cce_scale: "Array", blockICS: "BlockICS", bandType: "Array", vlc: "VLC", type: {name: "Enum", arguments: ["BlockType"]}}, {});
(function() {
    BlockCCE.vlc = new VLC(AACTab.ff_aac_scalefactor_code, AACTab.ff_aac_scalefactor_bits);
})();
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Channel pair element; reference: table 4.4.
 *  
 *  @author The JCodec project
 *  
 */
var BlockCPE = function() {
    BlockICS.call(this);
};
BlockCPE = stjs.extend(BlockCPE, BlockICS, [], function(constructor, prototype) {
    prototype.ms_mask = null;
    prototype.parse = function(_in) {
        var common_window = _in.read1Bit();
        if (common_window != 0) {
            this.parseICSInfo(_in);
            var ms_present = _in.readNBit(2);
            if (ms_present == 3) {
                 throw new RuntimeException("ms_present = 3 is reserved.");
            } else if (ms_present != 0) 
                this.decodeMidSideStereo(_in, ms_present, 0, 0);
        }
        var ics1 = new BlockICS();
        ics1.parse(_in);
        var ics2 = new BlockICS();
        ics2.parse(_in);
    };
    prototype.decodeMidSideStereo = function(_in, ms_present, numWindowGroups, maxSfb) {
        if (ms_present == 1) {
            for (var idx = 0; idx < numWindowGroups * maxSfb; idx++) 
                this.ms_mask[idx] = _in.read1Bit();
        }
    };
}, {ms_mask: "Int32Array", profile: {name: "Enum", arguments: ["Profile"]}, spectral: "Array", vlc: "VLC", ff_aac_codebook_vector_vals: "Array", group_len: "Int32Array", band_type: "Int32Array", band_type_run_end: "Int32Array", ff_aac_pow2sf_tab: "Float32Array", sfs: "Float64Array", swbOffset: "Int32Array", type: {name: "Enum", arguments: ["BlockType"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Prores2VP8Track = function(proresTrack, frameDim) {
    TranscodeTrack.call(this, proresTrack, frameDim);
};
Prores2VP8Track = stjs.extend(Prores2VP8Track, TranscodeTrack, [], function(constructor, prototype) {
    prototype.getDecoder = function(scaleFactor) {
        return scaleFactor == 2 ? new ProresToThumb2x2() : new ProresToThumb4x4();
    };
    prototype.getEncoder = function(rate) {
        return new VP8Encoder(new NopRateControl(12));
    };
    prototype.getFrameSize = function(mbCount, rate) {
        return 278528;
    };
    prototype.getCodecPrivate = function(buf, dim) {};
}, {src: "VirtualTrack", se: "CodecMeta", transcoders: {name: "ThreadLocal", arguments: ["TranscodeTrack.Transcoder"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var ClipRegionBox = function(atom) {
    Box.call(this, atom);
};
ClipRegionBox = stjs.extend(ClipRegionBox, Box, [], function(constructor, prototype) {
    prototype.rgnSize = 0;
    prototype.y = 0;
    prototype.x = 0;
    prototype.height = 0;
    prototype.width = 0;
    constructor.fourcc = function() {
        return "crgn";
    };
    constructor.createClipRegionBox = function(x, y, width, height) {
        var b = new ClipRegionBox(new Header(ClipRegionBox.fourcc()));
        b.rgnSize = 10;
        b.x = x;
        b.y = y;
        b.width = width;
        b.height = height;
        return b;
    };
    prototype.parse = function(input) {
        this.rgnSize = input.getShort();
        this.y = input.getShort();
        this.x = input.getShort();
        this.height = input.getShort();
        this.width = input.getShort();
    };
    prototype.doWrite = function(out) {
        out.putShort(this.rgnSize);
        out.putShort(this.y);
        out.putShort(this.x);
        out.putShort(this.height);
        out.putShort(this.width);
    };
    prototype.getRgnSize = function() {
        return this.rgnSize;
    };
    prototype.getY = function() {
        return this.y;
    };
    prototype.getX = function() {
        return this.x;
    };
    prototype.getHeight = function() {
        return this.height;
    };
    prototype.getWidth = function() {
        return this.width;
    };
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var NameBox = function(header) {
    Box.call(this, header);
};
NameBox = stjs.extend(NameBox, Box, [], function(constructor, prototype) {
    prototype.name = null;
    constructor.fourcc = function() {
        return "name";
    };
    constructor.createNameBox = function(name) {
        var box = new NameBox(new Header(NameBox.fourcc()));
        box.name = name;
        return box;
    };
    prototype.parse = function(input) {
        this.name = NIOUtils.readNullTermString(input);
    };
    prototype.doWrite = function(out) {
        out.putArr(JCodecUtil2.asciiString(this.name));
        out.putInt(0);
    };
    prototype.getName = function() {
        return this.name;
    };
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Default box factory
 *  
 *  @author The JCodec project
 *  
 */
var ColorExtension = function(header) {
    Box.call(this, header);
};
ColorExtension = stjs.extend(ColorExtension, Box, [], function(constructor, prototype) {
    prototype.primariesIndex = 0;
    prototype.transferFunctionIndex = 0;
    prototype.matrixIndex = 0;
    prototype.type = "nclc";
    constructor.RANGE_UNSPECIFIED = 0;
    constructor.AVCOL_RANGE_MPEG = 1;
    constructor.AVCOL_RANGE_JPEG = 2;
    prototype.colorRange = null;
    prototype.setColorRange = function(colorRange) {
        this.colorRange = colorRange;
    };
    prototype.parse = function(input) {
        var dst = new Int8Array(4);
        input.getBuf(dst);
        this.type = Platform.stringFromBytes(dst);
        this.primariesIndex = input.getShort();
        this.transferFunctionIndex = input.getShort();
        this.matrixIndex = input.getShort();
        if (input.hasRemaining()) {
            this.colorRange = input.get();
        }
    };
    prototype.doWrite = function(out) {
        out.putArr(JCodecUtil2.asciiString(this.type));
        out.putShort(this.primariesIndex);
        out.putShort(this.transferFunctionIndex);
        out.putShort(this.matrixIndex);
        if (this.colorRange != null) {
            out.put(this.colorRange);
        }
    };
    constructor.fourcc = function() {
        return "colr";
    };
    constructor.createColorExtension = function(primariesIndex, transferFunctionIndex, matrixIndex) {
        var c = new ColorExtension(new Header(ColorExtension.fourcc()));
        c.primariesIndex = primariesIndex;
        c.transferFunctionIndex = transferFunctionIndex;
        c.matrixIndex = matrixIndex;
        return c;
    };
    constructor.createColr = function() {
        return new ColorExtension(new Header(ColorExtension.fourcc()));
    };
    prototype.getPrimariesIndex = function() {
        return this.primariesIndex;
    };
    prototype.getTransferFunctionIndex = function() {
        return this.transferFunctionIndex;
    };
    prototype.getMatrixIndex = function() {
        return this.matrixIndex;
    };
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  File type box
 *  
 *  
 *  @author The JCodec project
 *  
 */
var FileTypeBox = function(header) {
    Box.call(this, header);
    this.compBrands = new LinkedList();
};
FileTypeBox = stjs.extend(FileTypeBox, Box, [], function(constructor, prototype) {
    prototype.majorBrand = null;
    prototype.minorVersion = 0;
    prototype.compBrands = null;
    constructor.fourcc = function() {
        return "ftyp";
    };
    constructor.createFileTypeBox = function(majorBrand, minorVersion, compBrands) {
        var ftyp = new FileTypeBox(new Header(FileTypeBox.fourcc()));
        ftyp.majorBrand = majorBrand;
        ftyp.minorVersion = minorVersion;
        ftyp.compBrands = compBrands;
        return ftyp;
    };
    prototype.parse = function(input) {
        this.majorBrand = NIOUtils.readString(input, 4);
        this.minorVersion = input.getInt();
        var brand;
         while (input.hasRemaining() && (brand = NIOUtils.readString(input, 4)) != null){
            this.compBrands.add(brand);
        }
    };
    prototype.getMajorBrand = function() {
        return this.majorBrand;
    };
    prototype.getCompBrands = function() {
        return this.compBrands;
    };
    prototype.doWrite = function(out) {
        out.putArr(JCodecUtil2.asciiString(this.majorBrand));
        out.putInt(this.minorVersion);
        for (var iterator$string = this.compBrands.iterator(); iterator$string.hasNext(); ) {
            var string = iterator$string.next();
            out.putArr(JCodecUtil2.asciiString(string));
        }
    };
}, {compBrands: {name: "Collection", arguments: [null]}, header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  
 *  @author The JCodec project
 *  
 */
var GamaExtension = function(header) {
    Box.call(this, header);
};
GamaExtension = stjs.extend(GamaExtension, Box, [], function(constructor, prototype) {
    prototype.gamma = 0.0;
    constructor.createGamaExtension = function(gamma) {
        var gamaExtension = new GamaExtension(new Header(GamaExtension.fourcc()));
        gamaExtension.gamma = gamma;
        return gamaExtension;
    };
    prototype.parse = function(input) {
        var g = input.getInt();
        this.gamma = g / 65536.0;
    };
    prototype.doWrite = function(out) {
        out.putInt(stjs.trunc((this.gamma * 65536)));
    };
    prototype.getGamma = function() {
        return this.gamma;
    };
    constructor.fourcc = function() {
        return "gama";
    };
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var FielExtension = function(header) {
    Box.call(this, header);
};
FielExtension = stjs.extend(FielExtension, Box, [], function(constructor, prototype) {
    prototype.type = 0;
    prototype.order = 0;
    constructor.fourcc = function() {
        return "fiel";
    };
    prototype.isInterlaced = function() {
        return this.type == 2;
    };
    prototype.topFieldFirst = function() {
        return this.order == 1 || this.order == 6;
    };
    prototype.getOrderInterpretation = function() {
        if (this.isInterlaced()) 
            switch (this.order) {
                case 1:
                    return "top";
                case 6:
                    return "bottom";
                case 9:
                    return "bottomtop";
                case 14:
                    return "topbottom";
            }
        return "";
    };
    prototype.parse = function(input) {
        this.type = input.get() & 255;
        if (this.isInterlaced()) {
            this.order = input.get() & 255;
        }
    };
    prototype.doWrite = function(out) {
        out.put((this.type << 24 >> 24));
        out.put((this.order << 24 >> 24));
    };
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var FullBox = function(atom) {
    Box.call(this, atom);
};
FullBox = stjs.extend(FullBox, Box, [], function(constructor, prototype) {
    prototype.version = 0;
    prototype.flags = 0;
    prototype.parse = function(input) {
        var vf = input.getInt();
        this.version = (((vf >> 24) & 255) << 24 >> 24);
        this.flags = vf & 16777215;
    };
    prototype.doWrite = function(out) {
        out.putInt((this.version << 24) | (this.flags & 16777215));
    };
    prototype.getVersion = function() {
        return this.version;
    };
    prototype.getFlags = function() {
        return this.flags;
    };
    prototype.setVersion = function(version) {
        this.version = version;
    };
    prototype.setFlags = function(flags) {
        this.flags = flags;
    };
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A node box
 *  
 *  A box containing children, no data
 *  
 *  @author The JCodec project
 *  
 */
var NodeBox = function(atom) {
    Box.call(this, atom);
    this.boxes = new LinkedList();
};
NodeBox = stjs.extend(NodeBox, Box, [], function(constructor, prototype) {
    prototype.boxes = null;
    prototype.factory = null;
    prototype.setFactory = function(factory) {
        this.factory = factory;
    };
    prototype.parse = function(input) {
         while (input.remaining() >= 8){
            var child = NodeBox.parseChildBox(input, this.factory);
            if (child != null) 
                this.add(child);
        }
    };
    constructor.parseChildBox = function(input, factory) {
        var fork = input.duplicate();
         while (input.remaining() >= 4 && fork.getInt() == 0)
            input.getInt();
        if (input.remaining() < 4) 
            return null;
        var childAtom = Header.read(input);
        if (childAtom != null && input.remaining() >= childAtom.getBodySize()) 
            return Box.parseBox(NIOUtils.read(input, ((childAtom.getBodySize()) | 0)), childAtom, factory);
         else 
            return null;
    };
    prototype.getBoxes = function() {
        return this.boxes;
    };
    prototype.add = function(box) {
        this.boxes.add(box);
        return this;
    };
    prototype.doWrite = function(out) {
        for (var iterator$box = this.boxes.iterator(); iterator$box.hasNext(); ) {
            var box = iterator$box.next();
            box.write(out);
        }
    };
    prototype.addFirst = function(box) {
        this.boxes.add(0, box);
    };
    prototype.replace = function(fourcc, box) {
        this.removeChildren(fourcc);
        this.add(box);
    };
    prototype.replaceBox = function(box) {
        console.log("replaceBox", box.header.getFourcc());
        this.removeChildren(box.getFourcc());
        this.add(box);
    };
    prototype.dump = function(sb) {
        sb.append("{\"tag\":\"" + this.header.getFourcc() + "\",");
        var fields = new ArrayList(0);
        this.collectModel(this.getClass(), fields);
        ToJSON.fieldsToJSON(this, sb, fields.toArray(Array(0)));
        sb.append("\"boxes\": [");
        this.dumpBoxes(sb);
        sb.append("]");
        sb.append("}");
    };
    prototype.getModelFields = function(model) {};
    prototype.dumpBoxes = function(sb) {
        for (var i = 0; i < this.boxes.size(); i++) {
            this.boxes.get(i).dump(sb);
            if (i < this.boxes.size() - 1) 
                sb.append(",");
        }
    };
    prototype.removeChildren = function(_arguments) {
        for (var it = this.boxes.iterator(); it.hasNext(); ) {
            var box = it.next();
            var fcc = box.getFourcc();
            for (var i = 0; i < arguments.length; i++) {
                var cand = arguments[i];
                if (cand.equals(fcc)) {
                    it.remove();
                    break;
                }
            }
        }
    };
    constructor.doCloneBox = function(box, approxSize, bf) {
        var buf = ByteBuffer.allocate(approxSize);
        box.write(buf);
        buf.flip();
        return NodeBox.parseChildBox(buf, bf);
    };
    constructor.cloneBox = function(box, approxSize, bf) {
        return NodeBox.doCloneBox(box, approxSize, bf);
    };
    constructor.findAll = function(box, class1, path) {
        return NodeBox.findAllPath(box, class1, [path]);
    };
    constructor.findFirst = function(box, clazz, path) {
        return NodeBox.findFirstPath(box, clazz, [path]);
    };
    constructor.findFirstPath = function(box, clazz, path) {
        var result = NodeBox.findAllPath(box, clazz, path);
        return result.length > 0 ? result[0] : null;
    };
    constructor.findAllPath = function(box, class1, path) {
        var result = new LinkedList();
        var tlist = new LinkedList();
        for (var i = 0; i < path.length; i++) {
            var type = path[i];
            tlist.add(type);
        }
        NodeBox.findBox(box, tlist, result);
        for (var it = result.listIterator(); it.hasNext(); ) {
            var next = it.next();
            if (next == null) {
                it.remove();
            } else if (!Platform.isAssignableFrom(class1, next.getClass())) {
                try {
                    it.set(Box.asBox(class1, next));
                }catch (e) {
                    jcodec.Logger.warn("Failed to reinterpret box: " + next.getFourcc() + " as: " + class1.getName() + "." + e.getMessage());
                    it.remove();
                }
            }
        }
        return result.toArray(jslang.reflect.Array.newInstance(class1, 0));
    };
    constructor.findBox = function(root, path, result) {
        if (path.size() > 0) {
            var head = path.remove(0);
            if (stjs.isInstanceOf(root.constructor, NodeBox)) {
                var nb = root;
                for (var iterator$candidate = nb.getBoxes().iterator(); iterator$candidate.hasNext(); ) {
                    var candidate = iterator$candidate.next();
                    if (head == null || head.equals(candidate.header.getFourcc())) {
                        NodeBox.findBox(candidate, path, result);
                    }
                }
            }
            path.add(0, head);
        } else {
            result.add(root);
        }
    };
}, {boxes: {name: "List", arguments: ["Box"]}, factory: "IBoxFactory", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  Pixel aspect ratio video sample entry extension
 *  
 *  @author The JCodec project
 */
var PixelAspectExt = function(header) {
    Box.call(this, header);
};
PixelAspectExt = stjs.extend(PixelAspectExt, Box, [], function(constructor, prototype) {
    prototype.hSpacing = 0;
    prototype.vSpacing = 0;
    constructor.createPixelAspectExt = function(par) {
        var pasp = new PixelAspectExt(new Header(PixelAspectExt.fourcc()));
        pasp.hSpacing = par.getNum();
        pasp.vSpacing = par.getDen();
        return pasp;
    };
    prototype.parse = function(input) {
        this.hSpacing = input.getInt();
        this.vSpacing = input.getInt();
    };
    prototype.doWrite = function(out) {
        out.putInt(this.hSpacing);
        out.putInt(this.vSpacing);
    };
    prototype.gethSpacing = function() {
        return this.hSpacing;
    };
    prototype.getvSpacing = function() {
        return this.vSpacing;
    };
    prototype.getRational = function() {
        return new Rational(this.hSpacing, this.vSpacing);
    };
    constructor.fourcc = function() {
        return "pasp";
    };
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var CleanApertureExtension = function(header) {
    Box.call(this, header);
};
CleanApertureExtension = stjs.extend(CleanApertureExtension, Box, [], function(constructor, prototype) {
    prototype.vertOffsetDenominator = 0;
    prototype.vertOffsetNumerator = 0;
    prototype.horizOffsetDenominator = 0;
    prototype.horizOffsetNumerator = 0;
    prototype.apertureHeightDenominator = 0;
    prototype.apertureHeightNumerator = 0;
    prototype.apertureWidthDenominator = 0;
    prototype.apertureWidthNumerator = 0;
    constructor.createCleanApertureExtension = function(apertureWidthN, apertureWidthD, apertureHeightN, apertureHeightD, horizOffN, horizOffD, vertOffN, vertOffD) {
        var clap = new CleanApertureExtension(new Header(CleanApertureExtension.fourcc()));
        clap.apertureWidthNumerator = apertureWidthN;
        clap.apertureWidthDenominator = apertureWidthD;
        clap.apertureHeightNumerator = apertureHeightN;
        clap.apertureHeightDenominator = apertureHeightD;
        clap.horizOffsetNumerator = horizOffN;
        clap.horizOffsetDenominator = horizOffD;
        clap.vertOffsetNumerator = vertOffN;
        clap.vertOffsetDenominator = vertOffD;
        return clap;
    };
    prototype.parse = function(is) {
        this.apertureWidthNumerator = is.getInt();
        this.apertureWidthDenominator = is.getInt();
        this.apertureHeightNumerator = is.getInt();
        this.apertureHeightDenominator = is.getInt();
        this.horizOffsetNumerator = is.getInt();
        this.horizOffsetDenominator = is.getInt();
        this.vertOffsetNumerator = is.getInt();
        this.vertOffsetDenominator = is.getInt();
    };
    constructor.fourcc = function() {
        return "clap";
    };
    prototype.doWrite = function(out) {
        out.putInt(stjs.trunc(this.apertureWidthNumerator));
        out.putInt(stjs.trunc(this.apertureWidthDenominator));
        out.putInt(stjs.trunc(this.apertureHeightNumerator));
        out.putInt(stjs.trunc(this.apertureHeightDenominator));
        out.putInt(stjs.trunc(this.horizOffsetNumerator));
        out.putInt(stjs.trunc(this.horizOffsetDenominator));
        out.putInt(stjs.trunc(this.vertOffsetNumerator));
        out.putInt(stjs.trunc(this.vertOffsetDenominator));
    };
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Load setting atom
 *  
 *  @author The JCodec project
 *  
 */
var LoadSettingsBox = function(header) {
    Box.call(this, header);
};
LoadSettingsBox = stjs.extend(LoadSettingsBox, Box, [], function(constructor, prototype) {
    prototype.preloadStartTime = 0;
    prototype.preloadDuration = 0;
    prototype.preloadFlags = 0;
    prototype.defaultHints = 0;
    constructor.fourcc = function() {
        return "load";
    };
    prototype.parse = function(input) {
        this.preloadStartTime = input.getInt();
        this.preloadDuration = input.getInt();
        this.preloadFlags = input.getInt();
        this.defaultHints = input.getInt();
    };
    prototype.doWrite = function(out) {
        out.putInt(this.preloadStartTime);
        out.putInt(this.preloadDuration);
        out.putInt(this.preloadFlags);
        out.putInt(this.defaultHints);
    };
    prototype.getPreloadStartTime = function() {
        return this.preloadStartTime;
    };
    prototype.getPreloadDuration = function() {
        return this.preloadDuration;
    };
    prototype.getPreloadFlags = function() {
        return this.preloadFlags;
    };
    prototype.getDefaultHints = function() {
        return this.defaultHints;
    };
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Creates MP4 file out of a set of samples
 *  
 *  @author The JCodec project
 *  
 */
var AvcCBox = function(header) {
    Box.call(this, header);
    this.spsList = new ArrayList();
    this.ppsList = new ArrayList();
};
AvcCBox = stjs.extend(AvcCBox, Box, [], function(constructor, prototype) {
    prototype.profile = 0;
    prototype.profileCompat = 0;
    prototype.level = 0;
    prototype.nalLengthSize = 0;
    prototype.spsList = null;
    prototype.ppsList = null;
    constructor.fourcc = function() {
        return "avcC";
    };
    constructor.parseAvcCBox = function(buf) {
        var avcCBox = new AvcCBox(new Header(AvcCBox.fourcc()));
        avcCBox.parse(buf);
        return avcCBox;
    };
    constructor.createEmpty = function() {
        return new AvcCBox(new Header(AvcCBox.fourcc()));
    };
    constructor.createAvcCBox = function(profile, profileCompat, level, nalLengthSize, spsList, ppsList) {
        var avcc = new AvcCBox(new Header(AvcCBox.fourcc()));
        avcc.profile = profile;
        avcc.profileCompat = profileCompat;
        avcc.level = level;
        avcc.nalLengthSize = nalLengthSize;
        avcc.spsList = spsList;
        avcc.ppsList = ppsList;
        return avcc;
    };
    prototype.parse = function(input) {
        NIOUtils.skip(input, 1);
        this.profile = input.get() & 255;
        this.profileCompat = input.get() & 255;
        this.level = input.get() & 255;
        var flags = input.get() & 255;
        this.nalLengthSize = (flags & 3) + 1;
        var nSPS = input.get() & 31;
        for (var i = 0; i < nSPS; i++) {
            var spsSize = input.getShort();
            Assert.assertEquals(39, input.get() & 63);
            this.spsList.add(NIOUtils.read(input, spsSize - 1));
        }
        var nPPS = input.get() & 255;
        for (var i = 0; i < nPPS; i++) {
            var ppsSize = input.getShort();
            Assert.assertEquals(40, input.get() & 63);
            this.ppsList.add(NIOUtils.read(input, ppsSize - 1));
        }
    };
    prototype.doWrite = function(out) {
        out.put((1 << 24 >> 24));
        out.put((this.profile << 24 >> 24));
        out.put((this.profileCompat << 24 >> 24));
        out.put((this.level << 24 >> 24));
        out.put((255 << 24 >> 24));
        out.put(((this.spsList.size() | 224) << 24 >> 24));
        for (var iterator$sps = this.spsList.iterator(); iterator$sps.hasNext(); ) {
            var sps = iterator$sps.next();
            out.putShort((((sps.remaining() + 1)) << 16 >> 16));
            out.put((103 << 24 >> 24));
            NIOUtils.write(out, sps);
        }
        out.put((this.ppsList.size() << 24 >> 24));
        for (var iterator$pps = this.ppsList.iterator(); iterator$pps.hasNext(); ) {
            var pps = iterator$pps.next();
            out.putShort(((pps.remaining() + 1) << 24 >> 24));
            out.put((104 << 24 >> 24));
            NIOUtils.write(out, pps);
        }
    };
    prototype.getProfile = function() {
        return this.profile;
    };
    prototype.getProfileCompat = function() {
        return this.profileCompat;
    };
    prototype.getLevel = function() {
        return this.level;
    };
    prototype.getSpsList = function() {
        return this.spsList;
    };
    prototype.getPpsList = function() {
        return this.ppsList;
    };
    prototype.getNalLengthSize = function() {
        return this.nalLengthSize;
    };
}, {spsList: {name: "List", arguments: ["ByteBuffer"]}, ppsList: {name: "List", arguments: ["ByteBuffer"]}, header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var FormatBox = function(header) {
    Box.call(this, header);
};
FormatBox = stjs.extend(FormatBox, Box, [], function(constructor, prototype) {
    prototype.fmt = null;
    constructor.fourcc = function() {
        return "frma";
    };
    constructor.createFormatBox = function(fmt) {
        var frma = new FormatBox(new Header(FormatBox.fourcc()));
        frma.fmt = fmt;
        return frma;
    };
    prototype.parse = function(input) {
        this.fmt = NIOUtils.readString(input, 4);
    };
    prototype.doWrite = function(out) {
        out.putArr(JCodecUtil2.asciiString(this.fmt));
    };
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  File type box
 *  
 *  
 *  @author The JCodec project
 *  
 */
var SegmentTypeBox = function(header) {
    Box.call(this, header);
    this.compBrands = new LinkedList();
};
SegmentTypeBox = stjs.extend(SegmentTypeBox, Box, [], function(constructor, prototype) {
    constructor.createSegmentTypeBox = function(majorBrand, minorVersion, compBrands) {
        var styp = new SegmentTypeBox(new Header(SegmentTypeBox.fourcc()));
        styp.majorBrand = majorBrand;
        styp.minorVersion = minorVersion;
        styp.compBrands = compBrands;
        return styp;
    };
    prototype.majorBrand = null;
    prototype.minorVersion = 0;
    prototype.compBrands = null;
    constructor.fourcc = function() {
        return "styp";
    };
    prototype.parse = function(input) {
        this.majorBrand = NIOUtils.readString(input, 4);
        this.minorVersion = input.getInt();
        var brand;
         while (input.hasRemaining() && (brand = NIOUtils.readString(input, 4)) != null){
            this.compBrands.add(brand);
        }
    };
    prototype.getMajorBrand = function() {
        return this.majorBrand;
    };
    prototype.getCompBrands = function() {
        return this.compBrands;
    };
    prototype.doWrite = function(out) {
        out.putArr(JCodecUtil2.asciiString(this.majorBrand));
        out.putInt(this.minorVersion);
        for (var iterator$string = this.compBrands.iterator(); iterator$string.hasNext(); ) {
            var string = iterator$string.next();
            out.putArr(JCodecUtil2.asciiString(string));
        }
    };
}, {compBrands: {name: "Collection", arguments: [null]}, header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MP4ABox = function(header) {
    Box.call(this, header);
};
MP4ABox = stjs.extend(MP4ABox, Box, [], function(constructor, prototype) {
    prototype.val = 0;
    prototype.doWrite = function(out) {
        out.putInt(this.val);
    };
    prototype.parse = function(input) {
        this.val = input.getInt();
    };
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var EndianBox = function(header) {
    Box.call(this, header);
};
EndianBox = stjs.extend(EndianBox, Box, [], function(constructor, prototype) {
    prototype.endian = null;
    constructor.fourcc = function() {
        return "enda";
    };
    constructor.createEndianBox = function(endian) {
        var endianBox = new EndianBox(new Header(EndianBox.fourcc()));
        endianBox.endian = endian;
        return endianBox;
    };
    prototype.parse = function(input) {
        var end = input.getShort();
        if (end == 1) {
            this.endian = ByteOrder.LITTLE_ENDIAN;
        } else {
            this.endian = ByteOrder.BIG_ENDIAN;
        }
    };
    prototype.doWrite = function(out) {
        out.putShort((((this.endian == ByteOrder.LITTLE_ENDIAN ? 1 : 0)) << 16 >> 16));
    };
    prototype.getEndian = function() {
        return this.endian;
    };
    prototype.calcSize = function() {
        return 2;
    };
}, {endian: "ByteOrder", header: "Header"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license. 
 * 
 *  @author in-somnia
 */
var FIL = function(downSampledSBR) {
    Element.call(this);
    this.downSampledSBR = downSampledSBR;
};
FIL = stjs.extend(FIL, Element, [SyntaxConstants], function(constructor, prototype) {
    constructor.DynamicRangeInfo = function() {
        this.excludeMask = new Int8Array(FIL.DynamicRangeInfo.MAX_NBR_BANDS);
        this.additionalExcludedChannels = new Int8Array(FIL.DynamicRangeInfo.MAX_NBR_BANDS);
    };
    constructor.DynamicRangeInfo = stjs.extend(constructor.DynamicRangeInfo, null, [], function(constructor, prototype) {
        constructor.MAX_NBR_BANDS = 7;
        prototype.excludeMask = null;
        prototype.additionalExcludedChannels = null;
        prototype.pceTagPresent = false;
        prototype.pceInstanceTag = 0;
        prototype.tagReservedBits = 0;
        prototype.excludedChannelsPresent = false;
        prototype.bandsPresent = false;
        prototype.bandsIncrement = 0;
        prototype.interpolationScheme = 0;
        prototype.bandTop = null;
        prototype.progRefLevelPresent = false;
        prototype.progRefLevel = 0;
        prototype.progRefLevelReservedBits = 0;
        prototype.dynRngSgn = null;
        prototype.dynRngCtl = null;
    }, {excludeMask: "Int8Array", additionalExcludedChannels: "Int8Array", bandTop: "Int32Array", dynRngSgn: "Int8Array", dynRngCtl: "Int32Array"}, {});
    constructor.TYPE_FILL = 0;
    constructor.TYPE_FILL_DATA = 1;
    constructor.TYPE_EXT_DATA_ELEMENT = 2;
    constructor.TYPE_DYNAMIC_RANGE = 11;
    constructor.TYPE_SBR_DATA = 13;
    constructor.TYPE_SBR_DATA_CRC = 14;
    prototype.downSampledSBR = false;
    prototype.dri = null;
    prototype.decode = function(_in, prev, sf, sbrEnabled, smallFrames) {
        var count = _in.readBits(4);
        if (count == 15) 
            count += _in.readBits(8) - 1;
        count *= 8;
        var cpy = count;
        var pos = _in.getPosition();
         while (count > 0){
            count = this.decodeExtensionPayload(_in, count, prev, sf, sbrEnabled, smallFrames);
        }
        var pos2 = _in.getPosition() - pos;
        var bitsLeft = cpy - pos2;
        if (bitsLeft > 0) 
            _in.skipBits(pos2);
         else if (bitsLeft < 0) 
             throw new AACException("FIL element overread: " + bitsLeft);
    };
    prototype.decodeExtensionPayload = function(_in, count, prev, sf, sbrEnabled, smallFrames) {
        var type = _in.readBits(4);
        var ret = count - 4;
        switch (type) {
            case FIL.TYPE_DYNAMIC_RANGE:
                ret = this.decodeDynamicRangeInfo(_in, ret);
                break;
            case FIL.TYPE_SBR_DATA:
            case FIL.TYPE_SBR_DATA_CRC:
                if (sbrEnabled) {
                    if (stjs.isInstanceOf(prev.constructor, SCE_LFE) || stjs.isInstanceOf(prev.constructor, CPE) || stjs.isInstanceOf(prev.constructor, CCE)) {
                        prev.decodeSBR(_in, sf, ret, (stjs.isInstanceOf(prev.constructor, CPE)), (type == FIL.TYPE_SBR_DATA_CRC), this.downSampledSBR, smallFrames);
                        ret = 0;
                        break;
                    } else 
                         throw new AACException("SBR applied on unexpected element: " + prev);
                } else {
                    _in.skipBits(ret);
                    ret = 0;
                }
            case FIL.TYPE_FILL:
            case FIL.TYPE_FILL_DATA:
            case FIL.TYPE_EXT_DATA_ELEMENT:
            default:
                _in.skipBits(ret);
                ret = 0;
                break;
        }
        return ret;
    };
    prototype.decodeDynamicRangeInfo = function(_in, count) {
        if (this.dri == null) 
            this.dri = new FIL.DynamicRangeInfo();
        var ret = count;
        var bandCount = 1;
        if (this.dri.pceTagPresent = _in.readBool()) {
            this.dri.pceInstanceTag = _in.readBits(4);
            this.dri.tagReservedBits = _in.readBits(4);
        }
        if (this.dri.excludedChannelsPresent = _in.readBool()) {
            ret -= this.decodeExcludedChannels(_in);
        }
        if (this.dri.bandsPresent = _in.readBool()) {
            this.dri.bandsIncrement = _in.readBits(4);
            this.dri.interpolationScheme = _in.readBits(4);
            ret -= 8;
            bandCount += this.dri.bandsIncrement;
            this.dri.bandTop = new Int32Array(bandCount);
            for (var i = 0; i < bandCount; i++) {
                this.dri.bandTop[i] = _in.readBits(8);
                ret -= 8;
            }
        }
        if (this.dri.progRefLevelPresent = _in.readBool()) {
            this.dri.progRefLevel = _in.readBits(7);
            this.dri.progRefLevelReservedBits = _in.readBits(1);
            ret -= 8;
        }
        this.dri.dynRngSgn = new Int8Array(bandCount);
        this.dri.dynRngCtl = new Int32Array(bandCount);
        for (var i = 0; i < bandCount; i++) {
            this.dri.dynRngSgn[i] = _in.readBool();
            this.dri.dynRngCtl[i] = _in.readBits(7);
            ret -= 8;
        }
        return ret;
    };
    prototype.decodeExcludedChannels = function(_in) {
        var i;
        var exclChs = 0;
        do {
            for (i = 0; i < 7; i++) {
                this.dri.excludeMask[exclChs] = _in.readBool();
                exclChs++;
            }
        } while (exclChs < 57 && _in.readBool());
        return (stjs.trunc(exclChs / 7)) * 8;
    };
}, {dri: "FIL.DynamicRangeInfo", sbr: "SBR", LOGGER: "Logger"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var MTSDump = function(ch, targetGuid) {
    MPSDump.call(this, ch);
    this.buf = ByteBuffer.allocate(188 * 1024);
    this.tsBuf = ByteBuffer.allocate(188);
    this.guid = targetGuid;
    this.buf.setPosition(this.buf.limit());
    this.tsBuf.setPosition(this.tsBuf.limit());
};
MTSDump = stjs.extend(MTSDump, MPSDump, [], function(constructor, prototype) {
    constructor.DUMP_FROM = "dump-from";
    constructor.STOP_AT = "stop-at";
    prototype.guid = 0;
    prototype.buf = null;
    prototype.tsBuf = null;
    prototype.tsNo = 0;
    prototype.globalPayload = 0;
    prototype.payloads = null;
    prototype.nums = null;
    prototype.prevPayloads = null;
    prototype.prevNums = null;
    constructor.main2 = function(args) {
        var ch = null;
        try {
            var cmd = MainUtils.parseArguments(args);
            if (cmd.args.length < 1) {
                var map = new HashMap();
                map.put(MTSDump.STOP_AT, "Stop reading at timestamp");
                map.put(MTSDump.DUMP_FROM, "Start dumping from timestamp");
                MainUtils.printHelp(map, Arrays.asList("file name", "guid"));
                return;
            } else if (cmd.args.length == 1) {
                System.out.println("MTS programs:");
                MTSDump.dumpProgramPids(NIOUtils.readableChannel(new File(cmd.args[0])));
                return;
            }
            ch = NIOUtils.readableChannel(new File(cmd.args[0]));
            var dumpAfterPts = cmd.getLongFlag(MTSDump.DUMP_FROM);
            var stopPts = cmd.getLongFlag(MTSDump.STOP_AT);
            new MTSDump(ch, Integer.parseInt(cmd.args[1])).dump(dumpAfterPts, stopPts);
        } finally {
            NIOUtils.closeQuietly(ch);
        }
    };
    constructor.dumpProgramPids = function(readableFileChannel) {
        var pids = new HashSet();
        var buf = ByteBuffer.allocate(188 * 10240);
        readableFileChannel.read(buf);
        buf.flip();
        buf.setLimit(buf.limit() - (buf.limit() % 188));
        var pmtPid = -1;
         while (buf.hasRemaining()){
            var tsBuf = NIOUtils.read(buf, 188);
            Assert.assertEquals(71, tsBuf.get() & 255);
            var guidFlags = ((tsBuf.get() & 255) << 8) | (tsBuf.get() & 255);
            var guid = guidFlags & 8191;
            System.out.println(guid);
            if (guid != 0) 
                pids.add(guid);
            if (guid == 0 || guid == pmtPid) {
                var payloadStart = (guidFlags >> 14) & 1;
                var b0 = tsBuf.get() & 255;
                var counter = b0 & 15;
                var payloadOff = 0;
                if ((b0 & 32) != 0) {
                    NIOUtils.skip(tsBuf, (tsBuf.get() & 255));
                }
                if (payloadStart == 1) {
                    NIOUtils.skip(tsBuf, (tsBuf.get() & 255));
                }
                if (guid == 0) {
                    var pat = PATSection.parsePAT(tsBuf);
                    var programs = pat.getPrograms();
                    pmtPid = programs.values()[0];
                    MTSDump.printPat(pat);
                } else if (guid == pmtPid) {
                    var pmt = PMTSection.parsePMT(tsBuf);
                    MTSDump.printPmt(pmt);
                    return;
                }
            }
        }
        for (var iterator$pid = pids.iterator(); iterator$pid.hasNext(); ) {
            var pid = iterator$pid.next();
            System.out.println(pid);
        }
    };
    constructor.printPat = function(pat) {
        var programs = pat.getPrograms();
        System.out.print("PAT: ");
        var keys = programs.keys();
        for (var i in keys) {
            System.out.print(i + ":" + programs.get(i) + ", ");
        }
        System.out.println();
    };
    constructor.printPmt = function(pmt) {
        System.out.print("PMT: ");
        for (var pmtStream in pmt.getStreams()) {
            System.out.print(pmtStream.getPid() + ":" + pmtStream.getStreamTypeTag() + ", ");
            for (var iterator$descriptor = pmtStream.getDesctiptors().iterator(); iterator$descriptor.hasNext(); ) {
                var descriptor = iterator$descriptor.next();
                System.out.println(ToJSON.toJSON(descriptor));
            }
        }
        System.out.println();
    };
    prototype.logPes = function(pkt, hdrSize, payload) {
        System.out.println(pkt.streamId + "(" + (pkt.streamId >= 224 ? "video" : "audio") + ") [ts#" + this.mapPos(pkt.pos) + ", " + (payload.remaining() + hdrSize) + "b], pts: " + pkt.pts + ", dts: " + pkt.dts);
    };
    prototype.mapPos = function(pos) {
        var left = this.globalPayload;
        for (var i = this.payloads.length - 1; i >= 0; --i) {
            left -= this.payloads[i];
            if (left <= pos) {
                return this.nums[i];
            }
        }
        if (this.prevPayloads != null) {
            for (var i = this.prevPayloads.length - 1; i >= 0; --i) {
                left -= this.prevPayloads[i];
                if (left <= pos) {
                    return this.prevNums[i];
                }
            }
        }
        return -1;
    };
    prototype.fillBuffer = function(dst) {
        var payloads = IntArrayList.createIntArrayList();
        var nums = IntArrayList.createIntArrayList();
        var remaining = dst.remaining();
        try {
            dst.putBuf(NIOUtils.read(this.tsBuf, Math.min(dst.remaining(), this.tsBuf.remaining())));
             while (dst.hasRemaining()){
                if (!this.buf.hasRemaining()) {
                    var dub = this.buf.duplicate();
                    dub.clear();
                    var read = this.ch.read(dub);
                    if (read == -1) 
                        return dst.remaining() != remaining ? remaining - dst.remaining() : -1;
                    dub.flip();
                    dub.setLimit(dub.limit() - (dub.limit() % 188));
                    this.buf = dub;
                }
                this.tsBuf = NIOUtils.read(this.buf, 188);
                Assert.assertEquals(71, this.tsBuf.get() & 255);
                ++this.tsNo;
                var guidFlags = ((this.tsBuf.get() & 255) << 8) | (this.tsBuf.get() & 255);
                var guid = stjs.trunc(guidFlags) & 8191;
                if (guid != this.guid) 
                    continue;
                var payloadStart = (guidFlags >> 14) & 1;
                var b0 = this.tsBuf.get() & 255;
                var counter = b0 & 15;
                if ((b0 & 32) != 0) {
                    NIOUtils.skip(this.tsBuf, this.tsBuf.get() & 255);
                }
                this.globalPayload += this.tsBuf.remaining();
                payloads.add(this.tsBuf.remaining());
                nums.add(this.tsNo - 1);
                dst.putBuf(NIOUtils.read(this.tsBuf, Math.min(dst.remaining(), this.tsBuf.remaining())));
            }
        } finally {
            this.prevPayloads = this.payloads;
            this.payloads = payloads.toArray();
            this.prevNums = this.nums;
            this.nums = nums.toArray();
        }
        return remaining - dst.remaining();
    };
}, {buf: "ByteBuffer", tsBuf: "ByteBuffer", payloads: "Int32Array", nums: "Int32Array", prevPayloads: "Int32Array", prevNums: "Int32Array", ch: "ReadableByteChannel"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  MPEG 1/2 Decoder, downscaled 4x4
 *  
 *  @author The JCodec project
 *  
 */
var Mpeg2Thumb4x4 = function() {
    MPEGDecoder.call(this);
};
Mpeg2Thumb4x4 = stjs.extend(Mpeg2Thumb4x4, MPEGDecoder, [], function(constructor, prototype) {
    prototype.localPred = null;
    prototype.oldPred = null;
    prototype.blockIntra = function(bits, vlcCoeff, block, intra_dc_predictor, blkIdx, scan, escSize, intra_dc_mult, qScale, qmat) {
        var cc = MPEGConst.BLOCK_TO_CC[blkIdx];
        var size = (cc == 0 ? MPEGConst.vlcDCSizeLuma : MPEGConst.vlcDCSizeChroma).readVLC(bits);
        var delta = (size != 0) ? MPEGDecoder.mpegSigned(bits, size) : 0;
        intra_dc_predictor[cc] = intra_dc_predictor[cc] + delta;
        Arrays.fill(block, 1, 16, 0);
        block[0] = intra_dc_predictor[cc] * intra_dc_mult;
        var idx, readVLC = 0;
        for (idx = 0; idx < 19 + (scan == Mpeg2Thumb4x4.scan4x4[1] ? 7 : 0); ) {
            readVLC = vlcCoeff.readVLC(bits);
            var level;
            if (readVLC == MPEGConst.CODE_END) {
                break;
            } else if (readVLC == MPEGConst.CODE_ESCAPE) {
                idx += bits.readNBit(6) + 1;
                level = MPEGDecoder.twosSigned(bits, escSize) * qScale * qmat[idx];
                level = level >= 0 ? (level >> 4) : -(-level >> 4);
            } else {
                idx += (readVLC >> 6) + 1;
                level = MPEGDecoder.toSigned(((readVLC & 63) * qScale * qmat[idx]) >> 4, bits.read1Bit());
            }
            block[scan[idx]] = level;
        }
        if (readVLC != MPEGConst.CODE_END) 
            this.finishOff(bits, idx, vlcCoeff, escSize);
        IDCT4x4.idct(block, 0);
    };
    prototype.finishOff = function(bits, idx, vlcCoeff, escSize) {
        for (; idx < 64; ) {
            var readVLC = vlcCoeff.readVLC(bits);
            if (readVLC == MPEGConst.CODE_END) {
                break;
            } else if (readVLC == MPEGConst.CODE_ESCAPE) {
                idx += bits.readNBit(6) + 1;
                bits.readNBit(escSize);
            } else {
                bits.read1Bit();
            }
        }
    };
    prototype.blockInter = function(bits, vlcCoeff, block, scan, escSize, qScale, qmat) {
        Arrays.fill(block, 1, 16, 0);
        var idx = -1;
        if (vlcCoeff == MPEGConst.vlcCoeff0 && bits.checkNBit(1) == 1) {
            bits.read1Bit();
            block[0] = MPEGDecoder.toSigned(MPEGDecoder.quantInter(1, qScale * qmat[0]), bits.read1Bit());
            idx++;
        } else {
            block[0] = 0;
        }
        var readVLC = 0;
        for (; idx < 19 + (scan == Mpeg2Thumb4x4.scan4x4[1] ? 7 : 0); ) {
            readVLC = vlcCoeff.readVLC(bits);
            var ac;
            if (readVLC == MPEGConst.CODE_END) {
                break;
            } else if (readVLC == MPEGConst.CODE_ESCAPE) {
                idx += bits.readNBit(6) + 1;
                ac = MPEGDecoder.quantInterSigned(MPEGDecoder.twosSigned(bits, escSize), qScale * qmat[idx]);
            } else {
                idx += (readVLC >> 6) + 1;
                ac = MPEGDecoder.toSigned(MPEGDecoder.quantInter(readVLC & 63, qScale * qmat[idx]), bits.read1Bit());
            }
            block[scan[idx]] = ac;
        }
        if (readVLC != MPEGConst.CODE_END) 
            this.finishOff(bits, idx, vlcCoeff, escSize);
        IDCT4x4.idct(block, 0);
    };
    prototype.decodeMacroblock = function(ph, context, prevAddr, qScaleCode, buf, stride, bits, vertOff, vertStep, pred) {
        if (this.localPred == null || this.oldPred != pred) {
            this.localPred = new MPEGPredDbl(pred);
            this.oldPred = pred;
        }
        return MPEGDecoder.prototype.decodeMacroblock.call(this, ph, context, prevAddr, qScaleCode, buf, stride, bits, vertOff, vertStep, this.localPred);
    };
    constructor.BLOCK_POS_X = new Int32Array([0, 4, 0, 4, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 4, 0, 4, 0, 0, 0, 0, 4, 4, 4, 4]);
    constructor.BLOCK_POS_Y = new Int32Array([0, 0, 4, 4, 0, 0, 4, 4, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1]);
    prototype.mapBlock = function(block, out, blkIdx, dctType, chromaFormat) {
        var stepVert = chromaFormat == SequenceExtension.Chroma420 && (blkIdx == 4 || blkIdx == 5) ? 0 : dctType;
        var log2stride = blkIdx < 4 ? 3 : 3 - MPEGConst.SQUEEZE_X[chromaFormat];
        var blkIdxExt = blkIdx + (dctType << 4);
        var x = Mpeg2Thumb4x4.BLOCK_POS_X[blkIdxExt];
        var y = Mpeg2Thumb4x4.BLOCK_POS_Y[blkIdxExt];
        var off = (y << log2stride) + x, stride = 1 << (log2stride + stepVert);
        for (var i = 0; i < 16; i += 4 , off += stride) {
            out[off] += block[i];
            out[off + 1] += block[i + 1];
            out[off + 2] += block[i + 2];
            out[off + 3] += block[i + 3];
        }
    };
    prototype.put = function(mbPix, buf, stride, chromaFormat, mbX, mbY, width, height, vertOff, vertStep) {
        var chromaStride = (stride + (1 << MPEGConst.SQUEEZE_X[chromaFormat]) - 1) >> MPEGConst.SQUEEZE_X[chromaFormat];
        var chromaMBW = 3 - MPEGConst.SQUEEZE_X[chromaFormat];
        var chromaMBH = 3 - MPEGConst.SQUEEZE_Y[chromaFormat];
        this.putSub(buf[0], (mbY << 3) * (stride << vertStep) + vertOff * stride + (mbX << 3), stride << vertStep, mbPix[0], 3, 3);
        this.putSub(buf[1], (mbY << chromaMBH) * (chromaStride << vertStep) + vertOff * chromaStride + (mbX << chromaMBW), chromaStride << vertStep, mbPix[1], chromaMBW, chromaMBH);
        this.putSub(buf[2], (mbY << chromaMBH) * (chromaStride << vertStep) + vertOff * chromaStride + (mbX << chromaMBW), chromaStride << vertStep, mbPix[2], chromaMBW, chromaMBH);
    };
    prototype.putSub = function(big, off, stride, block, mbW, mbH) {
        var blOff = 0;
        if (mbW == 2) {
            for (var i = 0; i < (1 << mbH); i++) {
                big[off] = MPEGDecoder.clipTo8Bit(block[blOff]);
                big[off + 1] = MPEGDecoder.clipTo8Bit(block[blOff + 1]);
                big[off + 2] = MPEGDecoder.clipTo8Bit(block[blOff + 2]);
                big[off + 3] = MPEGDecoder.clipTo8Bit(block[blOff + 3]);
                blOff += 4;
                off += stride;
            }
        } else {
            for (var i = 0; i < (1 << mbH); i++) {
                big[off] = MPEGDecoder.clipTo8Bit(block[blOff]);
                big[off + 1] = MPEGDecoder.clipTo8Bit(block[blOff + 1]);
                big[off + 2] = MPEGDecoder.clipTo8Bit(block[blOff + 2]);
                big[off + 3] = MPEGDecoder.clipTo8Bit(block[blOff + 3]);
                big[off + 4] = MPEGDecoder.clipTo8Bit(block[blOff + 4]);
                big[off + 5] = MPEGDecoder.clipTo8Bit(block[blOff + 5]);
                big[off + 6] = MPEGDecoder.clipTo8Bit(block[blOff + 6]);
                big[off + 7] = MPEGDecoder.clipTo8Bit(block[blOff + 7]);
                blOff += 8;
                off += stride;
            }
        }
    };
    constructor.scan4x4 = [new Int32Array([0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 16, 13, 10, 7, 16, 16, 16, 11, 14, 16, 16, 16, 16, 16, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16]), new Int32Array([0, 4, 8, 12, 1, 5, 2, 6, 9, 13, 16, 16, 16, 16, 16, 16, 16, 16, 14, 10, 3, 7, 16, 16, 11, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16])];
    prototype.initContext = function(sh, ph) {
        var context = MPEGDecoder.prototype.initContext.call(this, sh, ph);
        context.codedWidth >>= 1;
        context.codedHeight >>= 1;
        context.picWidth >>= 1;
        context.picHeight >>= 1;
        context.scan = Mpeg2Thumb4x4.scan4x4[ph.pictureCodingExtension == null ? 0 : ph.pictureCodingExtension.alternate_scan];
        return context;
    };
}, {localPred: "MPEGPred", oldPred: "MPEGPred", BLOCK_POS_X: "Int32Array", BLOCK_POS_Y: "Int32Array", scan4x4: "Array", sh: "SequenceHeader", gh: "GOPHeader", refFrames: "Array", refFields: "Array", byteBuffer: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  MPEG 1/2 Decoder, downscaled 2x2
 *  
 *  @author The JCodec project
 *  
 */
var Mpeg2Thumb2x2 = function() {
    MPEGDecoder.call(this);
};
Mpeg2Thumb2x2 = stjs.extend(Mpeg2Thumb2x2, MPEGDecoder, [], function(constructor, prototype) {
    prototype.localPred = null;
    prototype.oldPred = null;
    prototype.blockIntra = function(bits, vlcCoeff, block, intra_dc_predictor, blkIdx, scan, escSize, intra_dc_mult, qScale, qmat) {
        var cc = MPEGConst.BLOCK_TO_CC[blkIdx];
        var size = (cc == 0 ? MPEGConst.vlcDCSizeLuma : MPEGConst.vlcDCSizeChroma).readVLC(bits);
        var delta = (size != 0) ? MPEGDecoder.mpegSigned(bits, size) : 0;
        intra_dc_predictor[cc] = intra_dc_predictor[cc] + delta;
        block[0] = intra_dc_predictor[cc] * intra_dc_mult;
        block[1] = block[2] = block[3] = 0;
        var idx, readVLC = 0;
        for (idx = 0; idx < 6; ) {
            readVLC = vlcCoeff.readVLC(bits);
            var level;
            if (readVLC == MPEGConst.CODE_END) {
                break;
            } else if (readVLC == MPEGConst.CODE_ESCAPE) {
                idx += bits.readNBit(6) + 1;
                level = MPEGDecoder.twosSigned(bits, escSize) * qScale * qmat[idx];
                level = level >= 0 ? (level >> 4) : -(-level >> 4);
            } else {
                idx += (readVLC >> 6) + 1;
                level = MPEGDecoder.toSigned(((readVLC & 63) * qScale * qmat[idx]) >> 4, bits.read1Bit());
            }
            block[scan[idx]] = level;
        }
        if (readVLC != MPEGConst.CODE_END) 
            this.finishOff(bits, idx, vlcCoeff, escSize);
        IDCT2x2.idct(block, 0);
    };
    prototype.finishOff = function(bits, idx, vlcCoeff, escSize) {
        for (; idx < 64; ) {
            var readVLC = vlcCoeff.readVLC(bits);
            if (readVLC == MPEGConst.CODE_END) {
                break;
            } else if (readVLC == MPEGConst.CODE_ESCAPE) {
                idx += bits.readNBit(6) + 1;
                bits.readNBit(escSize);
            } else {
                bits.read1Bit();
            }
        }
    };
    prototype.blockInter = function(bits, vlcCoeff, block, scan, escSize, qScale, qmat) {
        block[1] = block[2] = block[3] = 0;
        var idx = -1;
        if (vlcCoeff == MPEGConst.vlcCoeff0 && bits.checkNBit(1) == 1) {
            bits.read1Bit();
            block[0] = MPEGDecoder.toSigned(MPEGDecoder.quantInter(1, qScale * qmat[0]), bits.read1Bit());
            idx++;
        } else {
            block[0] = 0;
        }
        var readVLC = 0;
        for (; idx < 6; ) {
            readVLC = vlcCoeff.readVLC(bits);
            var ac;
            if (readVLC == MPEGConst.CODE_END) {
                break;
            } else if (readVLC == MPEGConst.CODE_ESCAPE) {
                idx += bits.readNBit(6) + 1;
                ac = MPEGDecoder.quantInterSigned(MPEGDecoder.twosSigned(bits, escSize), qScale * qmat[idx]);
            } else {
                idx += (readVLC >> 6) + 1;
                ac = MPEGDecoder.toSigned(MPEGDecoder.quantInter(readVLC & 63, qScale * qmat[idx]), bits.read1Bit());
            }
            block[scan[idx]] = ac;
        }
        if (readVLC != MPEGConst.CODE_END) 
            this.finishOff(bits, idx, vlcCoeff, escSize);
        IDCT2x2.idct(block, 0);
    };
    prototype.decodeMacroblock = function(ph, context, prevAddr, qScaleCode, buf, stride, bits, vertOff, vertStep, pred) {
        if (this.localPred == null || this.oldPred != pred) {
            this.localPred = new MPEGPredQuad(pred);
            this.oldPred = pred;
        }
        return MPEGDecoder.prototype.decodeMacroblock.call(this, ph, context, prevAddr, qScaleCode, buf, stride, bits, vertOff, vertStep, this.localPred);
    };
    constructor.BLOCK_POS_X = new Int32Array([0, 2, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2]);
    constructor.BLOCK_POS_Y = new Int32Array([0, 0, 2, 2, 0, 0, 2, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1]);
    prototype.mapBlock = function(block, out, blkIdx, dctType, chromaFormat) {
        var stepVert = chromaFormat == SequenceExtension.Chroma420 && (blkIdx == 4 || blkIdx == 5) ? 0 : dctType;
        var log2stride = blkIdx < 4 ? 2 : 2 - MPEGConst.SQUEEZE_X[chromaFormat];
        var blkIdxExt = blkIdx + (dctType << 4);
        var x = Mpeg2Thumb2x2.BLOCK_POS_X[blkIdxExt];
        var y = Mpeg2Thumb2x2.BLOCK_POS_Y[blkIdxExt];
        var off = (y << log2stride) + x, stride = 1 << (log2stride + stepVert);
        out[off] += block[0];
        out[off + 1] += block[1];
        out[off + stride] += block[2];
        out[off + stride + 1] += block[3];
    };
    prototype.put = function(mbPix, buf, stride, chromaFormat, mbX, mbY, width, height, vertOff, vertStep) {
        var chromaStride = (stride + (1 << MPEGConst.SQUEEZE_X[chromaFormat]) - 1) >> MPEGConst.SQUEEZE_X[chromaFormat];
        var chromaMBW = 2 - MPEGConst.SQUEEZE_X[chromaFormat];
        var chromaMBH = 2 - MPEGConst.SQUEEZE_Y[chromaFormat];
        this.putSub(buf[0], (mbY << 2) * (stride << vertStep) + vertOff * stride + (mbX << 2), stride << vertStep, mbPix[0], 2, 2);
        this.putSub(buf[1], (mbY << chromaMBH) * (chromaStride << vertStep) + vertOff * chromaStride + (mbX << chromaMBW), chromaStride << vertStep, mbPix[1], chromaMBW, chromaMBH);
        this.putSub(buf[2], (mbY << chromaMBH) * (chromaStride << vertStep) + vertOff * chromaStride + (mbX << chromaMBW), chromaStride << vertStep, mbPix[2], chromaMBW, chromaMBH);
    };
    prototype.putSub = function(big, off, stride, block, mbW, mbH) {
        var blOff = 0;
        if (mbW == 1) {
            big[off] = MPEGDecoder.clipTo8Bit(block[blOff]);
            big[off + 1] = MPEGDecoder.clipTo8Bit(block[blOff + 1]);
            big[off + stride] = MPEGDecoder.clipTo8Bit(block[blOff + 2]);
            big[off + stride + 1] = MPEGDecoder.clipTo8Bit(block[blOff + 3]);
            if (mbH == 2) {
                off += stride << 1;
                big[off] = MPEGDecoder.clipTo8Bit(block[blOff + 4]);
                big[off + 1] = MPEGDecoder.clipTo8Bit(block[blOff + 5]);
                big[off + stride] = MPEGDecoder.clipTo8Bit(block[blOff + 6]);
                big[off + stride + 1] = MPEGDecoder.clipTo8Bit(block[blOff + 7]);
            }
        } else {
            for (var i = 0; i < 4; i++) {
                big[off] = MPEGDecoder.clipTo8Bit(block[blOff]);
                big[off + 1] = MPEGDecoder.clipTo8Bit(block[blOff + 1]);
                big[off + 2] = MPEGDecoder.clipTo8Bit(block[blOff + 2]);
                big[off + 3] = MPEGDecoder.clipTo8Bit(block[blOff + 3]);
                off += stride;
                blOff += 4;
            }
        }
    };
    constructor.scan2x2 = [new Int32Array([0, 1, 2, 4, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4]), new Int32Array([0, 2, 4, 4, 1, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4])];
    prototype.initContext = function(sh, ph) {
        var context = MPEGDecoder.prototype.initContext.call(this, sh, ph);
        context.codedWidth >>= 2;
        context.codedHeight >>= 2;
        context.picWidth >>= 2;
        context.picHeight >>= 2;
        context.scan = Mpeg2Thumb2x2.scan2x2[ph.pictureCodingExtension == null ? 0 : ph.pictureCodingExtension.alternate_scan];
        return context;
    };
}, {localPred: "MPEGPred", oldPred: "MPEGPred", BLOCK_POS_X: "Int32Array", BLOCK_POS_Y: "Int32Array", scan2x2: "Array", sh: "SequenceHeader", gh: "GOPHeader", refFrames: "Array", refFields: "Array", byteBuffer: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A decoder for an individual slice
 *  
 *  @author The JCodec project
 *  
 */
var SliceDecoder = function(activeSps, sRefs, lRefs, di, result) {
    this.di = di;
    this.activeSps = activeSps;
    this.frameOut = result;
    this.sRefs = sRefs;
    this.lRefs = lRefs;
};
SliceDecoder = stjs.extend(SliceDecoder, null, [], function(constructor, prototype) {
    prototype.mapper = null;
    prototype.decoderIntra16x16 = null;
    prototype.decoderIntraNxN = null;
    prototype.decoderInter = null;
    prototype.decoderInter8x8 = null;
    prototype.skipDecoder = null;
    prototype.decoderBDirect = null;
    prototype.refListManager = null;
    prototype.decoderIPCM = null;
    prototype.parser = null;
    prototype.activeSps = null;
    prototype.frameOut = null;
    prototype.decoderState = null;
    prototype.di = null;
    prototype.lRefs = null;
    prototype.sRefs = null;
    prototype.decodeFromReader = function(sliceReader) {
        this.parser = sliceReader;
        this.initContext();
        MBlockDecoderUtils.debugPrint("============%d============= ", this.frameOut.getPOC());
        var refList = this.refListManager.getRefList();
        this.decodeMacroblocks(refList);
    };
    prototype.initContext = function() {
        var sh = this.parser.getSliceHeader();
        this.decoderState = new DecoderState(sh);
        this.mapper = new MapManager(sh.sps, sh.pps).getMapper(sh);
        this.decoderIntra16x16 = new MBlockDecoderIntra16x16(this.mapper, sh, this.di, this.frameOut.getPOC(), this.decoderState);
        this.decoderIntraNxN = new MBlockDecoderIntraNxN(this.mapper, sh, this.di, this.frameOut.getPOC(), this.decoderState);
        this.decoderInter = new MBlockDecoderInter(this.mapper, sh, this.di, this.frameOut.getPOC(), this.decoderState);
        this.decoderBDirect = new MBlockDecoderBDirect(this.mapper, sh, this.di, this.frameOut.getPOC(), this.decoderState);
        this.decoderInter8x8 = new MBlockDecoderInter8x8(this.mapper, this.decoderBDirect, sh, this.di, this.frameOut.getPOC(), this.decoderState);
        this.skipDecoder = new MBlockSkipDecoder(this.mapper, this.decoderBDirect, sh, this.di, this.frameOut.getPOC(), this.decoderState);
        this.decoderIPCM = new MBlockDecoderIPCM(this.mapper, this.decoderState);
        this.refListManager = new RefListManager(sh, this.sRefs, this.lRefs, this.frameOut);
    };
    prototype.decodeMacroblocks = function(refList) {
        var mb = Picture8Bit.create(16, 16, this.activeSps.chroma_format_idc);
        var mbWidth = this.activeSps.pic_width_in_mbs_minus1 + 1;
        var mBlock = new MBlock(this.activeSps.chroma_format_idc);
         while (this.parser.readMacroblock(mBlock)){
            this.decode(mBlock, this.parser.getSliceHeader().slice_type, mb, refList);
            var mbAddr = this.mapper.getAddress(mBlock.mbIdx);
            var mbX = mbAddr % mbWidth;
            var mbY = stjs.trunc(mbAddr / mbWidth);
            this.putMacroblock(this.frameOut, mb, mbX, mbY);
            this.di.shs[mbAddr] = this.parser.getSliceHeader();
            this.di.refsUsed[mbAddr] = refList;
            this.fillCoeff(mBlock, mbX, mbY);
            mb.fill(0);
            mBlock.clear();
        }
    };
    prototype.fillCoeff = function(mBlock, mbX, mbY) {
        for (var i = 0; i < 16; i++) {
            var blkOffLeft = H264Const.MB_BLK_OFF_LEFT[i];
            var blkOffTop = H264Const.MB_BLK_OFF_TOP[i];
            var blkX = (mbX << 2) + blkOffLeft;
            var blkY = (mbY << 2) + blkOffTop;
            this.di.nCoeff[blkY][blkX] = mBlock.nCoeff[i];
        }
    };
    prototype.decode = function(mBlock, sliceType, mb, references) {
        if (mBlock.skipped) {
            this.skipDecoder.decodeSkip(mBlock, references, mb, sliceType);
        } else if (sliceType == SliceType.I) {
            this.decodeMBlockI(mBlock, mb);
        } else if (sliceType == SliceType.P) {
            this.decodeMBlockP(mBlock, mb, references);
        } else {
            this.decodeMBlockB(mBlock, mb, references);
        }
    };
    prototype.decodeMBlockI = function(mBlock, mb) {
        this.decodeMBlockIInt(mBlock, mb);
    };
    prototype.decodeMBlockIInt = function(mBlock, mb) {
        if (mBlock.curMbType == MBType.I_NxN) {
            this.decoderIntraNxN.decode(mBlock, mb);
        } else if (mBlock.curMbType == MBType.I_16x16) {
            this.decoderIntra16x16.decode(mBlock, mb);
        } else {
            jcodec.Logger.warn("IPCM macroblock found. Not tested, may cause unpredictable behavior.");
            this.decoderIPCM.decode(mBlock, mb);
        }
    };
    prototype.decodeMBlockP = function(mBlock, mb, references) {
        if (MBType.P_16x16 == mBlock.curMbType) {
            this.decoderInter.decode16x16(mBlock, mb, references, H264Const.PartPred.L0);
        } else if (MBType.P_16x8 == mBlock.curMbType) {
            this.decoderInter.decode16x8(mBlock, mb, references, H264Const.PartPred.L0, H264Const.PartPred.L0);
        } else if (MBType.P_8x16 == mBlock.curMbType) {
            this.decoderInter.decode8x16(mBlock, mb, references, H264Const.PartPred.L0, H264Const.PartPred.L0);
        } else if (MBType.P_8x8 == mBlock.curMbType) {
            this.decoderInter8x8.decode(mBlock, references, mb, SliceType.P, false);
        } else if (MBType.P_8x8ref0 == mBlock.curMbType) {
            this.decoderInter8x8.decode(mBlock, references, mb, SliceType.P, true);
        } else {
            this.decodeMBlockIInt(mBlock, mb);
        }
    };
    prototype.decodeMBlockB = function(mBlock, mb, references) {
        if (mBlock.curMbType.isIntra()) {
            this.decodeMBlockIInt(mBlock, mb);
        } else {
            if (mBlock.curMbType == MBType.B_Direct_16x16) {
                this.decoderBDirect.decode(mBlock, mb, references);
            } else if (mBlock.mbType <= 3) {
                this.decoderInter.decode16x16(mBlock, mb, references, H264Const.bPredModes[mBlock.mbType][0]);
            } else if (mBlock.mbType == 22) {
                this.decoderInter8x8.decode(mBlock, references, mb, SliceType.B, false);
            } else if ((mBlock.mbType & 1) == 0) {
                this.decoderInter.decode16x8(mBlock, mb, references, H264Const.bPredModes[mBlock.mbType][0], H264Const.bPredModes[mBlock.mbType][1]);
            } else {
                this.decoderInter.decode8x16(mBlock, mb, references, H264Const.bPredModes[mBlock.mbType][0], H264Const.bPredModes[mBlock.mbType][1]);
            }
        }
    };
    prototype.putMacroblock = function(tgt, decoded, mbX, mbY) {
        var luma = tgt.getPlaneData(0);
        var stride = tgt.getPlaneWidth(0);
        var cb = tgt.getPlaneData(1);
        var cr = tgt.getPlaneData(2);
        var strideChroma = tgt.getPlaneWidth(1);
        var dOff = 0;
        for (var i = 0; i < 16; i++) {
            System.arraycopy(decoded.getPlaneData(0), dOff, luma, (mbY * 16 + i) * stride + mbX * 16, 16);
            dOff += 16;
        }
        for (var i = 0; i < 8; i++) {
            System.arraycopy(decoded.getPlaneData(1), i * 8, cb, (mbY * 8 + i) * strideChroma + mbX * 8, 8);
        }
        for (var i = 0; i < 8; i++) {
            System.arraycopy(decoded.getPlaneData(2), i * 8, cr, (mbY * 8 + i) * strideChroma + mbX * 8, 8);
        }
    };
}, {mapper: "Mapper", decoderIntra16x16: "MBlockDecoderIntra16x16", decoderIntraNxN: "MBlockDecoderIntraNxN", decoderInter: "MBlockDecoderInter", decoderInter8x8: "MBlockDecoderInter8x8", skipDecoder: "MBlockSkipDecoder", decoderBDirect: "MBlockDecoderBDirect", refListManager: "RefListManager", decoderIPCM: "MBlockDecoderIPCM", parser: "SliceReader", activeSps: "SeqParameterSet", frameOut: "Frame", decoderState: "DecoderState", di: "DeblockerInput", lRefs: {name: "IntObjectMap", arguments: ["Frame"]}, sRefs: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var FixHLSTimestamps = function() {
    FixTimestamp.call(this);
    this.lastPts = Array(256);
};
FixHLSTimestamps = stjs.extend(FixHLSTimestamps, FixTimestamp, [], function(constructor, prototype) {
    prototype.lastPts = null;
    constructor.main1 = function(args) {
        var wildCard = args[0];
        var startIdx = Integer.parseInt(args[1]);
        new FixHLSTimestamps().doIt(wildCard, startIdx);
    };
    prototype.doIt = function(wildCard, startIdx) {
        Arrays.fill(this.lastPts, -1);
        for (var i = startIdx; ; i++) {
            var file = new File(String.format(wildCard, i));
            System.out.println(file.getAbsolutePath());
            if (!file.exists()) 
                break;
            this.fix(file);
        }
    };
    prototype.doWithTimestamp = function(streamId, pts, isPts) {
        if (!isPts) 
            return pts;
        if (this.lastPts[streamId] == -1) {
            this.lastPts[streamId] = pts;
            return pts;
        }
        if (this.isVideo(streamId)) {
            this.lastPts[streamId] += 3003;
            return this.lastPts[streamId];
        } else if (this.isAudio(streamId)) {
            this.lastPts[streamId] += 1920;
            return this.lastPts[streamId];
        }
         throw new RuntimeException("Unexpected!!!");
    };
}, {lastPts: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A utility for manipulation MPEG TS timestamps
 *  
 *  @author The JCodec project
 *  
 */
var TimestampUtil = function() {};
TimestampUtil = stjs.extend(TimestampUtil, null, [], function(constructor, prototype) {
    constructor.STREAM_ALL = "all";
    constructor.STREAM_AUDIO = "audio";
    constructor.STRAM_VIDEO = "video";
    constructor.FLAG_STREAM = "stream";
    constructor.COMMAND_SHIFT = "shift";
    constructor.COMMAND_SCALE = "scale";
    constructor.COMMAND_ROUND = "round";
    constructor.main1 = function(args) {
        var cmd = MainUtils.parseArguments(args);
        if (cmd.args.length < 3) {
            System.out.println("A utility to tweak MPEG TS timestamps.");
            var map = new HashMap();
            map.put(TimestampUtil.FLAG_STREAM, "A stream to shift, i.e. '" + TimestampUtil.STRAM_VIDEO + "' or '" + TimestampUtil.STREAM_AUDIO + "' or '" + TimestampUtil.STREAM_ALL + "' [default]");
            MainUtils.printHelp(map, Arrays.asList("command", "arg", "in name", "?out file"));
            System.out.println("Where command is:\n\t" + TimestampUtil.COMMAND_SHIFT + "\tShift timestamps of selected stream by arg.\n\t" + TimestampUtil.COMMAND_SCALE + "\tScale timestams of selected stream by arg [num:den].\n\t" + TimestampUtil.COMMAND_ROUND + "\tRound timestamps of selected stream to multiples of arg.");
            return;
        }
        var src = new File(cmd.getArg(2));
        if (cmd.argsLength() > 3) {
            var dst = new File(cmd.getArg(3));
            IOUtils.copyFile(src, dst);
            src = dst;
        }
        var command = cmd.getArg(0);
        var stream = cmd.getStringFlagD(TimestampUtil.FLAG_STREAM, TimestampUtil.STREAM_ALL);
        if (TimestampUtil.COMMAND_SHIFT.equalsIgnoreCase(command)) {
            var shift = Long.parseLong(cmd.getArg(1));
            new (stjs.extend(function TimestampUtil$1(stream) {
                TimestampUtil.BaseCommand.call(this, stream);
            }, TimestampUtil.BaseCommand, [], function(constructor, prototype) {
                prototype.withTimestamp = function(pts, isPts) {
                    return Math.max(pts + shift, 0);
                };
            }, {}, {}))(stream).fix(src);
        } else if (TimestampUtil.COMMAND_SCALE.equalsIgnoreCase(command)) {
            var scale = RationalLarge.parse(cmd.getArg(1));
            new (stjs.extend(function TimestampUtil$2(stream) {
                TimestampUtil.BaseCommand.call(this, stream);
            }, TimestampUtil.BaseCommand, [], function(constructor, prototype) {
                prototype.withTimestamp = function(pts, isPts) {
                    return scale.multiplyS(pts);
                };
            }, {}, {}))(stream).fix(src);
        } else if (TimestampUtil.COMMAND_ROUND.equalsIgnoreCase(command)) {
            var precision = Integer.parseInt(cmd.getArg(1));
            new (stjs.extend(function TimestampUtil$3(stream) {
                TimestampUtil.BaseCommand.call(this, stream);
            }, TimestampUtil.BaseCommand, [], function(constructor, prototype) {
                prototype.withTimestamp = function(pts, isPts) {
                    return Math.round(pts / precision) * precision;
                };
            }, {}, {}))(stream).fix(src);
        }
    };
    constructor.BaseCommand = function(stream) {
        FixTimestamp.call(this);
        this.streamSelector = stream;
    };
    constructor.BaseCommand = stjs.extend(constructor.BaseCommand, FixTimestamp, [], function(constructor, prototype) {
        prototype.streamSelector = null;
        prototype.doWithTimestamp = function(streamId, pts, isPts) {
            if (TimestampUtil.STREAM_ALL.equals(this.streamSelector) || TimestampUtil.STRAM_VIDEO.equals(this.streamSelector) && this.isVideo(streamId) || TimestampUtil.STREAM_AUDIO.equals(this.streamSelector) && this.isAudio(streamId)) {
                return this.withTimestamp(pts, isPts);
            } else {
                return pts;
            }
        };
        prototype.withTimestamp = function(pts, isPts) {};
    }, {}, {});
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var SetBaseTimestamp = function(video, baseTs) {
    FixTimestamp.call(this);
    this.video = video;
    this.baseTs = baseTs;
};
SetBaseTimestamp = stjs.extend(SetBaseTimestamp, FixTimestamp, [], function(constructor, prototype) {
    prototype.baseTs = 0;
    prototype.firstPts = -1;
    prototype.video = false;
    constructor.main1 = function(args) {
        var file = new File(args[0]);
        new SetBaseTimestamp("video".equalsIgnoreCase(args[1]), Integer.parseInt(args[2])).fix(file);
    };
    prototype.doWithTimestamp = function(streamId, pts, isPts) {
        if (this.video && this.isVideo(streamId) || !this.video && this.isAudio(streamId)) {
            if (this.firstPts == -1) 
                this.firstPts = pts;
            return pts - this.firstPts + this.baseTs;
        } else 
            return pts;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var GenericSoundEssenceDescriptor = function(ul) {
    FileDescriptor.call(this, ul);
};
GenericSoundEssenceDescriptor = stjs.extend(GenericSoundEssenceDescriptor, FileDescriptor, [], function(constructor, prototype) {
    prototype.audioSamplingRate = null;
    prototype.locked = 0;
    prototype.audioRefLevel = 0;
    prototype.electroSpatialFormulation = 0;
    prototype.channelCount = 0;
    prototype.quantizationBits = 0;
    prototype.dialNorm = 0;
    prototype.soundEssenceCompression = null;
    prototype.read = function(tags) {
        FileDescriptor.prototype.read.call(this, tags);
        for (var it = tags.entrySet().iterator(); it.hasNext(); ) {
            var entry = it.next();
            var _bb = entry.getValue();
            switch (entry.getKey()) {
                case 15619:
                    this.audioSamplingRate = new Rational(_bb.getInt(), _bb.getInt());
                    break;
                case 15618:
                    this.locked = _bb.get();
                    break;
                case 15620:
                    this.audioRefLevel = _bb.get();
                    break;
                case 15621:
                    this.electroSpatialFormulation = _bb.get();
                    break;
                case 15623:
                    this.channelCount = _bb.getInt();
                    break;
                case 15617:
                    this.quantizationBits = _bb.getInt();
                    break;
                case 15628:
                    this.dialNorm = _bb.get();
                    break;
                case 15622:
                    this.soundEssenceCompression = UL.read(_bb);
                    break;
                default:
                    jcodec.Logger.warn(String.format("Unknown tag [ " + this.ul + "]: %04x", entry.getKey()));
                    continue;
            }
            it.remove();
        }
    };
    prototype.getAudioSamplingRate = function() {
        return this.audioSamplingRate;
    };
    prototype.getLocked = function() {
        return this.locked;
    };
    prototype.getAudioRefLevel = function() {
        return this.audioRefLevel;
    };
    prototype.getElectroSpatialFormulation = function() {
        return this.electroSpatialFormulation;
    };
    prototype.getChannelCount = function() {
        return this.channelCount;
    };
    prototype.getQuantizationBits = function() {
        return this.quantizationBits;
    };
    prototype.getDialNorm = function() {
        return this.dialNorm;
    };
    prototype.getSoundEssenceCompression = function() {
        return this.soundEssenceCompression;
    };
}, {audioSamplingRate: "Rational", soundEssenceCompression: "UL", sampleRate: "Rational", essenceContainer: "UL", codec: "UL", locators: "Array", subDescriptors: "Array", generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var GenericDataEssenceDescriptor = function(ul) {
    FileDescriptor.call(this, ul);
};
GenericDataEssenceDescriptor = stjs.extend(GenericDataEssenceDescriptor, FileDescriptor, [], function(constructor, prototype) {
    prototype.dataEssenceCoding = null;
    prototype.read = function(tags) {
        FileDescriptor.prototype.read.call(this, tags);
        for (var it = tags.entrySet().iterator(); it.hasNext(); ) {
            var entry = it.next();
            var _bb = entry.getValue();
            switch (entry.getKey()) {
                case 15873:
                    this.dataEssenceCoding = UL.read(_bb);
                    break;
                default:
                    jcodec.Logger.warn(String.format("Unknown tag [ FileDescriptor: " + this.ul + "]: %04x", entry.getKey()));
                    continue;
            }
            it.remove();
        }
    };
    prototype.getDataEssenceCoding = function() {
        return this.dataEssenceCoding;
    };
}, {dataEssenceCoding: "UL", sampleRate: "Rational", essenceContainer: "UL", codec: "UL", locators: "Array", subDescriptors: "Array", generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var GenericPictureEssenceDescriptor = function(ul) {
    FileDescriptor.call(this, ul);
};
GenericPictureEssenceDescriptor = stjs.extend(GenericPictureEssenceDescriptor, FileDescriptor, [], function(constructor, prototype) {
    constructor.LayoutType = stjs.enumeration("FullFrame", "SeparateFields", "OneField", "MixedFields", "SegmentedFrame");
    prototype.signalStandard = 0;
    prototype.frameLayout = null;
    prototype.storedWidth = 0;
    prototype.storedHeight = 0;
    prototype.storedF2Offset = 0;
    prototype.sampledWidth = 0;
    prototype.sampledHeight = 0;
    prototype.sampledXOffset = 0;
    prototype.sampledYOffset = 0;
    prototype.displayHeight = 0;
    prototype.displayWidth = 0;
    prototype.displayXOffset = 0;
    prototype.displayYOffset = 0;
    prototype.displayF2Offset = 0;
    prototype.aspectRatio = null;
    prototype.activeFormatDescriptor = 0;
    prototype.videoLineMap = null;
    prototype.alphaTransparency = 0;
    prototype.transferCharacteristic = null;
    prototype.imageAlignmentOffset = 0;
    prototype.imageStartOffset = 0;
    prototype.imageEndOffset = 0;
    prototype.fieldDominance = 0;
    prototype.pictureEssenceCoding = null;
    prototype.codingEquations = null;
    prototype.colorPrimaries = null;
    prototype.read = function(tags) {
        FileDescriptor.prototype.read.call(this, tags);
        for (var it = tags.entrySet().iterator(); it.hasNext(); ) {
            var entry = it.next();
            var _bb = entry.getValue();
            switch (entry.getKey()) {
                case 12821:
                    this.signalStandard = _bb.get();
                    break;
                case 12812:
                    this.frameLayout = GenericPictureEssenceDescriptor.LayoutType.values()[_bb.get()];
                    break;
                case 12803:
                    this.storedWidth = _bb.getInt();
                    break;
                case 12802:
                    this.storedHeight = _bb.getInt();
                    break;
                case 12822:
                    this.storedF2Offset = _bb.getInt();
                    break;
                case 12805:
                    this.sampledWidth = _bb.getInt();
                    break;
                case 12804:
                    this.sampledHeight = _bb.getInt();
                    break;
                case 12806:
                    this.sampledXOffset = _bb.getInt();
                    break;
                case 12807:
                    this.sampledYOffset = _bb.getInt();
                    break;
                case 12808:
                    this.displayHeight = _bb.getInt();
                    break;
                case 12809:
                    this.displayWidth = _bb.getInt();
                    break;
                case 12810:
                    this.displayXOffset = _bb.getInt();
                    break;
                case 12811:
                    this.displayYOffset = _bb.getInt();
                    break;
                case 12823:
                    this.displayF2Offset = _bb.getInt();
                    break;
                case 12814:
                    this.aspectRatio = new Rational(_bb.getInt(), _bb.getInt());
                    break;
                case 12824:
                    this.activeFormatDescriptor = _bb.get();
                    break;
                case 12813:
                    this.videoLineMap = MXFMetadata.readInt32Batch(_bb);
                    break;
                case 12815:
                    this.alphaTransparency = _bb.get();
                    break;
                case 12816:
                    this.transferCharacteristic = UL.read(_bb);
                    break;
                case 12817:
                    this.imageAlignmentOffset = _bb.getInt();
                    break;
                case 12819:
                    this.imageStartOffset = _bb.getInt();
                    break;
                case 12820:
                    this.imageEndOffset = _bb.getInt();
                    break;
                case 12818:
                    this.fieldDominance = _bb.get();
                    break;
                case 12801:
                    this.pictureEssenceCoding = UL.read(_bb);
                    break;
                case 12826:
                    this.codingEquations = UL.read(_bb);
                    break;
                case 12825:
                    this.colorPrimaries = UL.read(_bb);
                    break;
                default:
                    jcodec.Logger.warn(String.format("Unknown tag [ " + this.ul + "]: %04x", entry.getKey()));
                    continue;
            }
            it.remove();
        }
    };
    prototype.getSignalStandard = function() {
        return this.signalStandard;
    };
    prototype.getFrameLayout = function() {
        return this.frameLayout;
    };
    prototype.getStoredWidth = function() {
        return this.storedWidth;
    };
    prototype.getStoredHeight = function() {
        return this.storedHeight;
    };
    prototype.getStoredF2Offset = function() {
        return this.storedF2Offset;
    };
    prototype.getSampledWidth = function() {
        return this.sampledWidth;
    };
    prototype.getSampledHeight = function() {
        return this.sampledHeight;
    };
    prototype.getSampledXOffset = function() {
        return this.sampledXOffset;
    };
    prototype.getSampledYOffset = function() {
        return this.sampledYOffset;
    };
    prototype.getDisplayHeight = function() {
        return this.displayHeight;
    };
    prototype.getDisplayWidth = function() {
        return this.displayWidth;
    };
    prototype.getDisplayXOffset = function() {
        return this.displayXOffset;
    };
    prototype.getDisplayYOffset = function() {
        return this.displayYOffset;
    };
    prototype.getDisplayF2Offset = function() {
        return this.displayF2Offset;
    };
    prototype.getAspectRatio = function() {
        return this.aspectRatio;
    };
    prototype.getActiveFormatDescriptor = function() {
        return this.activeFormatDescriptor;
    };
    prototype.getVideoLineMap = function() {
        return this.videoLineMap;
    };
    prototype.getAlphaTransparency = function() {
        return this.alphaTransparency;
    };
    prototype.getTransferCharacteristic = function() {
        return this.transferCharacteristic;
    };
    prototype.getImageAlignmentOffset = function() {
        return this.imageAlignmentOffset;
    };
    prototype.getImageStartOffset = function() {
        return this.imageStartOffset;
    };
    prototype.getImageEndOffset = function() {
        return this.imageEndOffset;
    };
    prototype.getFieldDominance = function() {
        return this.fieldDominance;
    };
    prototype.getPictureEssenceCoding = function() {
        return this.pictureEssenceCoding;
    };
    prototype.getCodingEquations = function() {
        return this.codingEquations;
    };
    prototype.getColorPrimaries = function() {
        return this.colorPrimaries;
    };
}, {frameLayout: {name: "Enum", arguments: ["GenericPictureEssenceDescriptor.LayoutType"]}, aspectRatio: "Rational", videoLineMap: "Int32Array", transferCharacteristic: "UL", pictureEssenceCoding: "UL", codingEquations: "UL", colorPrimaries: "UL", sampleRate: "Rational", essenceContainer: "UL", codec: "UL", locators: "Array", subDescriptors: "Array", generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MKVDemuxer = function(t, fileChannelWrapper) {
    this.aTracks = new ArrayList();
    this.t = t;
    this.channel = fileChannelWrapper;
    this.demux();
};
MKVDemuxer = stjs.extend(MKVDemuxer, null, [], function(constructor, prototype) {
    prototype.vTrack = null;
    prototype.aTracks = null;
    prototype.t = null;
    prototype.channel = null;
    prototype.timescale = 1;
    prototype.pictureWidth = 0;
    prototype.pictureHeight = 0;
    prototype.demux = function() {
        var path = [MKVType.Segment, MKVType.Info, MKVType.TimecodeScale];
        var ts = MKVType.findFirstTree(this.t, path);
        if (ts != null) 
            this.timescale = ts.getUint();
        var path9 = [MKVType.Segment, MKVType.Tracks, MKVType.TrackEntry];
        for (var iterator$aTrack = MKVType.findList(this.t, EbmlMaster, path9).iterator(); iterator$aTrack.hasNext(); ) {
            var aTrack = iterator$aTrack.next();
            var path1 = [MKVType.TrackEntry, MKVType.TrackType];
            var type = (MKVType.findFirst(aTrack, path1)).getUint();
            var path2 = [MKVType.TrackEntry, MKVType.TrackNumber];
            var id = (MKVType.findFirst(aTrack, path2)).getUint();
            if (type == 1) {
                if (this.vTrack != null) 
                     throw new RuntimeException("More then 1 video track, can not compute...");
                var path3 = [MKVType.TrackEntry, MKVType.CodecPrivate];
                var videoCodecState = MKVType.findFirst(aTrack, path3);
                var state = null;
                if (videoCodecState != null) 
                    state = videoCodecState.data;
                var path4 = [MKVType.TrackEntry, MKVType.Video, MKVType.PixelWidth];
                var width = MKVType.findFirst(aTrack, path4);
                var path5 = [MKVType.TrackEntry, MKVType.Video, MKVType.PixelHeight];
                var height = MKVType.findFirst(aTrack, path5);
                var path6 = [MKVType.TrackEntry, MKVType.Video, MKVType.DisplayWidth];
                var dwidth = MKVType.findFirst(aTrack, path6);
                var path7 = [MKVType.TrackEntry, MKVType.Video, MKVType.DisplayHeight];
                var dheight = MKVType.findFirst(aTrack, path7);
                var path8 = [MKVType.TrackEntry, MKVType.Video, MKVType.DisplayUnit];
                var unit = MKVType.findFirst(aTrack, path8);
                if (width != null && height != null) {
                    this.pictureWidth = ((width.getUint()) | 0);
                    this.pictureHeight = ((height.getUint()) | 0);
                } else if (dwidth != null && dheight != null) {
                    if (unit == null || unit.getUint() == 0) {
                        this.pictureHeight = ((dheight.getUint()) | 0);
                        this.pictureWidth = ((dwidth.getUint()) | 0);
                    } else {
                         throw new RuntimeException("DisplayUnits other then 0 are not implemented yet");
                    }
                }
                this.vTrack = new MKVDemuxer.VideoTrack(this, ((id) | 0), state);
            } else if (type == 2) {
                var audioTrack = new MKVDemuxer.AudioTrack(((id) | 0), this);
                var path3 = [MKVType.TrackEntry, MKVType.Audio, MKVType.SamplingFrequency];
                var sf = MKVType.findFirst(aTrack, path3);
                if (sf != null) 
                    audioTrack.samplingFrequency = sf.getDouble();
                this.aTracks.add(audioTrack);
            }
        }
        var path2 = [MKVType.Segment, MKVType.Cluster];
        for (var iterator$aCluster = MKVType.findList(this.t, EbmlMaster, path2).iterator(); iterator$aCluster.hasNext(); ) {
            var aCluster = iterator$aCluster.next();
            var path1 = [MKVType.Cluster, MKVType.Timecode];
            var baseTimecode = (MKVType.findFirst(aCluster, path1)).getUint();
            for (var iterator$child = aCluster.children.iterator(); iterator$child.hasNext(); ) {
                var child = iterator$child.next();
                if (MKVType.SimpleBlock.equals(child.type)) {
                    var b = child;
                    b.absoluteTimecode = b.timecode + baseTimecode;
                    this.putIntoRightBasket(b);
                } else if (MKVType.BlockGroup.equals(child.type)) {
                    var group = child;
                    for (var iterator$grandChild = group.children.iterator(); iterator$grandChild.hasNext(); ) {
                        var grandChild = iterator$grandChild.next();
                        if (grandChild.type == MKVType.Block) {
                            var b = child;
                            b.absoluteTimecode = b.timecode + baseTimecode;
                            this.putIntoRightBasket(b);
                        }
                    }
                }
            }
        }
    };
    prototype.putIntoRightBasket = function(b) {
        if (b.trackNumber == this.vTrack.trackNo) {
            this.vTrack.blocks.add(b);
        } else {
            for (var i = 0; i < this.aTracks.size(); i++) {
                var audio = this.aTracks.get(i);
                if (b.trackNumber == audio.trackNo) {
                    audio.blocks.add(MKVDemuxer.IndexedBlock.make(audio.framesCount, b));
                    audio.framesCount += b.frameSizes.length;
                }
            }
        }
    };
    constructor.getDemuxer = function(channel) {
        var parser = new MKVParser(channel);
        return new MKVDemuxer(parser.parse(), channel);
    };
    prototype.getVideoTrack = function() {
        return this.vTrack;
    };
    constructor.ZERO_TAPE_TIMECODE = new TapeTimecode(((0) << 16 >> 16), (0 << 24 >> 24), (0 << 24 >> 24), (0 << 24 >> 24), false);
    constructor.VideoTrack = function(demuxer, trackNo, state) {
        this.blocks = new ArrayList();
        this.demuxer = demuxer;
        this.trackNo = trackNo;
        this.state = state;
    };
    constructor.VideoTrack = stjs.extend(constructor.VideoTrack, null, [SeekableDemuxerTrack], function(constructor, prototype) {
        prototype.state = null;
        prototype.trackNo = 0;
        prototype.frameIdx = 0;
        prototype.blocks = null;
        prototype.demuxer = null;
        prototype.nextFrame = function() {
            if (this.frameIdx >= this.blocks.size()) 
                return null;
            var b = this.blocks.get(this.frameIdx);
            if (b == null) 
                 throw new RuntimeException("Something somewhere went wrong.");
            this.frameIdx++;
            this.demuxer.channel.setPosition(b.dataOffset);
            var data = ByteBuffer.allocate(b.dataLen);
            this.demuxer.channel.read(data);
            data.flip();
            b.readFrames(data.duplicate());
            var duration = 1;
            if (this.frameIdx < this.blocks.size()) 
                duration = this.blocks.get(this.frameIdx).absoluteTimecode - b.absoluteTimecode;
            return Packet.createPacket(b.frames[0].duplicate(), b.absoluteTimecode, this.demuxer.timescale, duration, this.frameIdx - 1, b._keyFrame, MKVDemuxer.ZERO_TAPE_TIMECODE);
        };
        prototype.gotoFrame = function(i) {
            if (i > Integer.MAX_VALUE) 
                return false;
            if (i > this.blocks.size()) 
                return false;
            this.frameIdx = ((i) | 0);
            return true;
        };
        prototype.getCurFrame = function() {
            return this.frameIdx;
        };
        prototype.seek = function(second) {
             throw new RuntimeException("Not implemented yet");
        };
        prototype.getFrameCount = function() {
            return this.blocks.size();
        };
        prototype.getCodecState = function() {
            return this.state;
        };
        prototype.getMeta = function() {
             throw new RuntimeException("Unsupported");
        };
        prototype.gotoSyncFrame = function(i) {
             throw new RuntimeException("Unsupported");
        };
    }, {state: "ByteBuffer", blocks: {name: "List", arguments: ["MkvBlock"]}, demuxer: "MKVDemuxer"}, {});
    constructor.IndexedBlock = function() {};
    constructor.IndexedBlock = stjs.extend(constructor.IndexedBlock, null, [], function(constructor, prototype) {
        prototype.firstFrameNo = 0;
        prototype.block = null;
        constructor.make = function(no, b) {
            var ib = new MKVDemuxer.IndexedBlock();
            ib.firstFrameNo = no;
            ib.block = b;
            return ib;
        };
    }, {block: "MkvBlock"}, {});
    constructor.AudioTrack = function(trackNo, demuxer) {
        this.blocks = new ArrayList();
        this.trackNo = trackNo;
        this.demuxer = demuxer;
    };
    constructor.AudioTrack = stjs.extend(constructor.AudioTrack, null, [SeekableDemuxerTrack], function(constructor, prototype) {
        prototype.samplingFrequency = 0.0;
        prototype.trackNo = 0;
        prototype.blocks = null;
        prototype.framesCount = 0;
        prototype.frameIdx = 0;
        prototype.blockIdx = 0;
        prototype.frameInBlockIdx = 0;
        prototype.demuxer = null;
        prototype.nextFrame = function() {
            if (this.frameIdx > this.blocks.size()) 
                return null;
            var b = this.blocks.get(this.blockIdx).block;
            if (b == null) 
                 throw new RuntimeException("Something somewhere went wrong.");
            if (b.frames == null || b.frames.length == 0) {
                this.demuxer.channel.setPosition(b.dataOffset);
                var data = ByteBuffer.allocate(b.dataLen);
                this.demuxer.channel.read(data);
                b.readFrames(data);
            }
            var data = b.frames[this.frameInBlockIdx].duplicate();
            this.frameInBlockIdx++;
            this.frameIdx++;
            if (this.frameInBlockIdx >= b.frames.length) {
                this.blockIdx++;
                this.frameInBlockIdx = 0;
            }
            return Packet.createPacket(data, b.absoluteTimecode, Math.round(this.samplingFrequency), 1, 0, false, MKVDemuxer.ZERO_TAPE_TIMECODE);
        };
        prototype.gotoFrame = function(i) {
            if (i > Integer.MAX_VALUE) 
                return false;
            if (i > this.framesCount) 
                return false;
            var frameBlockIdx = this.findBlockIndex(i);
            if (frameBlockIdx == -1) 
                return false;
            this.frameIdx = ((i) | 0);
            this.blockIdx = frameBlockIdx;
            this.frameInBlockIdx = ((i) | 0) - this.blocks.get(this.blockIdx).firstFrameNo;
            return true;
        };
        prototype.findBlockIndex = function(i) {
            for (var blockIndex = 0; blockIndex < this.blocks.size(); blockIndex++) {
                if (i < this.blocks.get(blockIndex).block.frameSizes.length) 
                    return blockIndex;
                i -= this.blocks.get(blockIndex).block.frameSizes.length;
            }
            return -1;
        };
        prototype.getCurFrame = function() {
            return this.frameIdx;
        };
        prototype.seek = function(second) {
             throw new RuntimeException("Not implemented yet");
        };
        /**
         *  Get multiple frames
         *  
         *  @param count
         *  @return
         */
        prototype.getFrames = function(count) {
            if (count + this.frameIdx >= this.framesCount) 
                return null;
            var packetFrames = new ArrayList();
            var firstBlockInAPacket = this.blocks.get(this.blockIdx).block;
             while (count > 0){
                var b = this.blocks.get(this.blockIdx).block;
                if (b.frames == null || b.frames.length == 0) {
                    try {
                        this.demuxer.channel.setPosition(b.dataOffset);
                        var data = ByteBuffer.allocate(b.dataLen);
                        this.demuxer.channel.read(data);
                        b.readFrames(data);
                    }catch (ioe) {
                         throw new RuntimeException("while reading frames of a Block at offset 0x" + Long.toHexString(b.dataOffset).toUpperCase() + ")", ioe);
                    }
                }
                packetFrames.add(b.frames[this.frameInBlockIdx].duplicate());
                this.frameIdx++;
                this.frameInBlockIdx++;
                if (this.frameInBlockIdx >= b.frames.length) {
                    this.frameInBlockIdx = 0;
                    this.blockIdx++;
                }
                count--;
            }
            var size = 0;
            for (var iterator$aFrame = packetFrames.iterator(); iterator$aFrame.hasNext(); ) {
                var aFrame = iterator$aFrame.next();
                size += aFrame.limit();
            }
            var data = ByteBuffer.allocate(size);
            for (var iterator$aFrame = packetFrames.iterator(); iterator$aFrame.hasNext(); ) {
                var aFrame = iterator$aFrame.next();
                data.putBuf(aFrame);
            }
            return Packet.createPacket(data, firstBlockInAPacket.absoluteTimecode, Math.round(this.samplingFrequency), packetFrames.size(), 0, false, MKVDemuxer.ZERO_TAPE_TIMECODE);
        };
        prototype.getMeta = function() {
             throw new RuntimeException("Unsupported");
        };
        prototype.gotoSyncFrame = function(frame) {
            return this.gotoFrame(frame);
        };
    }, {blocks: {name: "List", arguments: ["MKVDemuxer.IndexedBlock"]}, demuxer: "MKVDemuxer"}, {});
    prototype.getPictureWidth = function() {
        return this.pictureWidth;
    };
    prototype.getPictureHeight = function() {
        return this.pictureHeight;
    };
    prototype.getAudioTracks = function() {
        return this.aTracks;
    };
}, {vTrack: "MKVDemuxer.VideoTrack", aTracks: {name: "List", arguments: ["DemuxerTrack"]}, t: {name: "List", arguments: ["EbmlMaster"]}, channel: "SeekableByteChannel", ZERO_TAPE_TIMECODE: "TapeTimecode"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MKVMuxer = function() {
    this.tracks = new ArrayList();
    this.clusterList = new LinkedList();
};
MKVMuxer = stjs.extend(MKVMuxer, null, [], function(constructor, prototype) {
    prototype.tracks = null;
    prototype.videoTrack = null;
    prototype.mkvInfo = null;
    prototype.mkvTracks = null;
    prototype.mkvCues = null;
    prototype.mkvSeekHead = null;
    prototype.clusterList = null;
    prototype.createVideoTrack = function(dimentions, codecId) {
        if (this.videoTrack == null) {
            this.videoTrack = new MKVMuxerTrack();
            this.tracks.add(this.videoTrack);
            this.videoTrack.codecId = codecId;
            this.videoTrack.frameDimentions = dimentions;
            this.videoTrack.trackNo = this.tracks.size();
        }
        return this.videoTrack;
    };
    prototype.mux = function(s) {
        var mkvFile = new ArrayList();
        var ebmlHeader = this.defaultEbmlHeader();
        mkvFile.add(ebmlHeader);
        var segmentElem = MKVType.createByType(MKVType.Segment);
        this.mkvInfo = this.muxInfo();
        this.mkvTracks = this.muxTracks();
        this.mkvCues = MKVType.createByType(MKVType.Cues);
        this.mkvSeekHead = this.muxSeekHead();
        this.muxCues();
        segmentElem.add(this.mkvSeekHead);
        segmentElem.add(this.mkvInfo);
        segmentElem.add(this.mkvTracks);
        segmentElem.add(this.mkvCues);
        for (var iterator$aCluster = this.clusterList.iterator(); iterator$aCluster.hasNext(); ) {
            var aCluster = iterator$aCluster.next();
            segmentElem.add(aCluster);
        }
        mkvFile.add(segmentElem);
        for (var iterator$el = mkvFile.iterator(); iterator$el.hasNext(); ) {
            var el = iterator$el.next();
            el.mux(s);
        }
    };
    prototype.defaultEbmlHeader = function() {
        var master = MKVType.createByType(MKVType.EBML);
        MKVMuxer.createLong(master, MKVType.EBMLVersion, 1);
        MKVMuxer.createLong(master, MKVType.EBMLReadVersion, 1);
        MKVMuxer.createLong(master, MKVType.EBMLMaxIDLength, 4);
        MKVMuxer.createLong(master, MKVType.EBMLMaxSizeLength, 8);
        MKVMuxer.createString(master, MKVType.DocType, "webm");
        MKVMuxer.createLong(master, MKVType.DocTypeVersion, 2);
        MKVMuxer.createLong(master, MKVType.DocTypeReadVersion, 2);
        return master;
    };
    prototype.muxInfo = function() {
        var master = MKVType.createByType(MKVType.Info);
        var frameDurationInNanoseconds = MKVMuxerTrack.NANOSECONDS_IN_A_MILISECOND * 40;
        MKVMuxer.createLong(master, MKVType.TimecodeScale, frameDurationInNanoseconds);
        MKVMuxer.createString(master, MKVType.WritingApp, "JCodec v0.1.7");
        MKVMuxer.createString(master, MKVType.MuxingApp, "JCodec MKVStreamingMuxer v0.1.7");
        var lastBlock = this.videoTrack.trackBlocks.get(this.videoTrack.trackBlocks.size() - 1);
        MKVMuxer.createDouble(master, MKVType.Duration, (lastBlock.absoluteTimecode + 1) * frameDurationInNanoseconds * 1.0);
        MKVMuxer.createDate(master, MKVType.DateUTC, new jsutil.Date());
        return master;
    };
    prototype.muxTracks = function() {
        var master = MKVType.createByType(MKVType.Tracks);
        for (var i = 0; i < this.tracks.size(); i++) {
            var track = this.tracks.get(i);
            var trackEntryElem = MKVType.createByType(MKVType.TrackEntry);
            MKVMuxer.createLong(trackEntryElem, MKVType.TrackNumber, track.trackNo);
            MKVMuxer.createLong(trackEntryElem, MKVType.TrackUID, track.trackNo);
            if (MKVMuxerTrack.MKVMuxerTrackType.VIDEO.equals(track.type)) {
                MKVMuxer.createLong(trackEntryElem, MKVType.TrackType, (1 << 24 >> 24));
                MKVMuxer.createString(trackEntryElem, MKVType.Name, "Track " + (i + 1) + " Video");
                MKVMuxer.createString(trackEntryElem, MKVType.CodecID, track.codecId);
                var trackVideoElem = MKVType.createByType(MKVType.Video);
                MKVMuxer.createLong(trackVideoElem, MKVType.PixelWidth, track.frameDimentions.getWidth());
                MKVMuxer.createLong(trackVideoElem, MKVType.PixelHeight, track.frameDimentions.getHeight());
                trackEntryElem.add(trackVideoElem);
            } else {
                MKVMuxer.createLong(trackEntryElem, MKVType.TrackType, (2 << 24 >> 24));
                MKVMuxer.createString(trackEntryElem, MKVType.Name, "Track " + (i + 1) + " Audio");
                MKVMuxer.createString(trackEntryElem, MKVType.CodecID, track.codecId);
            }
            master.add(trackEntryElem);
        }
        return master;
    };
    prototype.muxCues = function() {
        var cf = new CuesFactory(this.mkvSeekHead.size() + this.mkvInfo.size() + this.mkvTracks.size(), this.videoTrack.trackNo - 1);
        for (var iterator$aBlock = this.videoTrack.trackBlocks.iterator(); iterator$aBlock.hasNext(); ) {
            var aBlock = iterator$aBlock.next();
            var mkvCluster = this.singleBlockedCluster(aBlock);
            this.clusterList.add(mkvCluster);
            cf.add(CuesFactory.CuePointMock.make(mkvCluster));
        }
        var indexedCues = cf.createCues();
        for (var iterator$aCuePoint = indexedCues.children.iterator(); iterator$aCuePoint.hasNext(); ) {
            var aCuePoint = iterator$aCuePoint.next();
            this.mkvCues.add(aCuePoint);
        }
    };
    prototype.singleBlockedCluster = function(aBlock) {
        var mkvCluster = MKVType.createByType(MKVType.Cluster);
        MKVMuxer.createLong(mkvCluster, MKVType.Timecode, aBlock.absoluteTimecode - aBlock.timecode);
        mkvCluster.add(aBlock);
        return mkvCluster;
    };
    prototype.muxSeekHead = function() {
        var shi = new SeekHeadFactory();
        shi.add(this.mkvInfo);
        shi.add(this.mkvTracks);
        shi.add(this.mkvCues);
        return shi.indexSeekHead();
    };
    constructor.createLong = function(parent, type, value) {
        var se = MKVType.createByType(type);
        se.setUint(value);
        parent.add(se);
    };
    constructor.createString = function(parent, type, value) {
        var se = MKVType.createByType(type);
        se.setString(value);
        parent.add(se);
    };
    constructor.createDate = function(parent, type, value) {
        var se = MKVType.createByType(type);
        se.setDate(value);
        parent.add(se);
    };
    constructor.createBuffer = function(parent, type, value) {
        var se = MKVType.createByType(type);
        se.setBuf(value);
        parent.add(se);
    };
    constructor.createDouble = function(parent, type, value) {
        try {
            var se = MKVType.createByType(type);
            se.setDouble(value);
            parent.add(se);
        }catch (cce) {
             throw new RuntimeException("Element of type " + type + " can't be cast to EbmlFloat", cce);
        }
    };
}, {tracks: {name: "List", arguments: ["MKVMuxerTrack"]}, videoTrack: "MKVMuxerTrack", mkvInfo: "EbmlMaster", mkvTracks: "EbmlMaster", mkvCues: "EbmlMaster", mkvSeekHead: "EbmlMaster", clusterList: {name: "List", arguments: ["EbmlMaster"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var Brand = function(majorBrand, version, compatible) {
    this.ftyp = FileTypeBox.createFileTypeBox(majorBrand, version, Arrays.asList(compatible));
};
Brand = stjs.extend(Brand, null, [], function(constructor, prototype) {
    constructor.MOV = new Brand("qt  ", 512, ["qt  "]);
    constructor.MP4 = new Brand("isom", 512, ["isom", "iso2", "avc1", "mp41"]);
    prototype.ftyp = null;
    prototype.getFileTypeBox = function() {
        return this.ftyp;
    };
}, {MOV: "Brand", MP4: "Brand", ftyp: "FileTypeBox"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A handler description box
 *  
 *  @author The JCodec project
 *  
 */
var HandlerBox = function(atom) {
    FullBox.call(this, atom);
};
HandlerBox = stjs.extend(HandlerBox, FullBox, [], function(constructor, prototype) {
    prototype.componentType = null;
    prototype.componentSubType = null;
    prototype.componentManufacturer = null;
    prototype.componentFlags = 0;
    prototype.componentFlagsMask = 0;
    prototype.componentName = null;
    constructor.fourcc = function() {
        return "hdlr";
    };
    constructor.createHandlerBox = function(componentType, componentSubType, componentManufacturer, componentFlags, componentFlagsMask) {
        var hdlr = new HandlerBox(new Header(HandlerBox.fourcc()));
        hdlr.componentType = componentType;
        hdlr.componentSubType = componentSubType;
        hdlr.componentManufacturer = componentManufacturer;
        hdlr.componentFlags = componentFlags;
        hdlr.componentFlagsMask = componentFlagsMask;
        hdlr.componentName = "";
        return hdlr;
    };
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        this.componentType = NIOUtils.readString(input, 4);
        this.componentSubType = NIOUtils.readString(input, 4);
        this.componentManufacturer = NIOUtils.readString(input, 4);
        this.componentFlags = input.getInt();
        this.componentFlagsMask = input.getInt();
        this.componentName = NIOUtils.readString(input, input.remaining());
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        out.putArr(JCodecUtil2.asciiString(this.componentType));
        out.putArr(JCodecUtil2.asciiString(this.componentSubType));
        out.putArr(JCodecUtil2.asciiString(this.componentManufacturer));
        out.putInt(this.componentFlags);
        out.putInt(this.componentFlagsMask);
        if (this.componentName != null) {
            out.putArr(JCodecUtil2.asciiString(this.componentName));
        }
    };
    prototype.getComponentType = function() {
        return this.componentType;
    };
    prototype.getComponentSubType = function() {
        return this.componentSubType;
    };
    prototype.getComponentManufacturer = function() {
        return this.componentManufacturer;
    };
    prototype.getComponentFlags = function() {
        return this.componentFlags;
    };
    prototype.getComponentFlagsMask = function() {
        return this.componentFlagsMask;
    };
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  Box type
 *  
 *  @author The JCodec project
 *  
 */
var ChunkOffsets64Box = function(atom) {
    FullBox.call(this, atom);
};
ChunkOffsets64Box = stjs.extend(ChunkOffsets64Box, FullBox, [], function(constructor, prototype) {
    prototype.chunkOffsets = null;
    constructor.fourcc = function() {
        return "co64";
    };
    constructor.createChunkOffsets64Box = function(offsets) {
        var co64 = new ChunkOffsets64Box(Header.createHeader(ChunkOffsets64Box.fourcc(), 0));
        co64.chunkOffsets = offsets;
        return co64;
    };
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        var length = input.getInt();
        this.chunkOffsets = Array(length);
        for (var i = 0; i < length; i++) {
            this.chunkOffsets[i] = input.getLong();
        }
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        out.putInt(this.chunkOffsets.length);
        for (var i = 0; i < this.chunkOffsets.length; i++) {
            var offset = this.chunkOffsets[i];
            out.putLong(offset);
        }
    };
    prototype.getChunkOffsets = function() {
        return this.chunkOffsets;
    };
    prototype.setChunkOffsets = function(chunkOffsets) {
        this.chunkOffsets = chunkOffsets;
    };
}, {chunkOffsets: "Array", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var SegmentIndexBox = function(atom) {
    FullBox.call(this, atom);
};
SegmentIndexBox = stjs.extend(SegmentIndexBox, FullBox, [], function(constructor, prototype) {
    constructor.createSegmentIndexBox = function() {
        return new SegmentIndexBox(new Header(SegmentIndexBox.fourcc()));
    };
    prototype.reference_ID = 0;
    prototype.timescale = 0;
    prototype.earliest_presentation_time = 0;
    prototype.first_offset = 0;
    prototype.reserved = 0;
    prototype.reference_count = 0;
    prototype.references = null;
    constructor.Reference = function() {};
    constructor.Reference = stjs.extend(constructor.Reference, null, [], function(constructor, prototype) {
        prototype.reference_type = false;
        prototype.referenced_size = 0;
        prototype.subsegment_duration = 0;
        prototype.starts_with_SAP = false;
        prototype.SAP_type = 0;
        prototype.SAP_delta_time = 0;
        prototype.toString = function() {
            return "Reference [reference_type=" + this.reference_type + ", referenced_size=" + this.referenced_size + ", subsegment_duration=" + this.subsegment_duration + ", starts_with_SAP=" + this.starts_with_SAP + ", SAP_type=" + this.SAP_type + ", SAP_delta_time=" + this.SAP_delta_time + "]";
        };
    }, {}, {});
    constructor.fourcc = function() {
        return "sidx";
    };
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        this.reference_ID = input.getInt() & 4294967295;
        this.timescale = input.getInt() & 4294967295;
        if (this.version == 0) {
            this.earliest_presentation_time = input.getInt() & 4294967295;
            this.first_offset = input.getInt() & 4294967295;
        } else {
            this.earliest_presentation_time = input.getLong();
            this.first_offset = input.getLong();
        }
        this.reserved = input.getShort();
        this.reference_count = input.getShort() & 65535;
        this.references = Array(this.reference_count);
        for (var i = 0; i < this.reference_count; i++) {
            var i0 = input.getInt() & 4294967295;
            var i1 = input.getInt() & 4294967295;
            var i2 = input.getInt() & 4294967295;
            var ref = new SegmentIndexBox.Reference();
            ref.reference_type = (i0 >> 31) == 1;
            ref.referenced_size = i0 & 2147483647;
            ref.subsegment_duration = i1;
            ref.starts_with_SAP = (i2 >> 31) == 1;
            ref.SAP_type = ((((i2 >> 28) & 7)) | 0);
            ref.SAP_delta_time = i2 & 268435455;
            this.references[i] = ref;
        }
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        out.putInt(((this.reference_ID) | 0));
        out.putInt(((this.timescale) | 0));
        if (this.version == 0) {
            out.putInt(((this.earliest_presentation_time) | 0));
            out.putInt(((this.first_offset) | 0));
        } else {
            out.putLong(this.earliest_presentation_time);
            out.putLong(this.first_offset);
        }
        out.putShort(((this.reserved) << 16 >> 16));
        out.putShort(((this.reference_count) << 16 >> 16));
        for (var i = 0; i < this.reference_count; i++) {
            var ref = this.references[i];
            var i0 = (((((ref.reference_type ? 1 : 0) << 31) | ref.referenced_size)) | 0);
            var i1 = ((ref.subsegment_duration) | 0);
            var i2 = 0;
            if (ref.starts_with_SAP) {
                i2 |= (1 << 31);
            }
            i2 |= ((ref.SAP_type & 7) << 28);
            i2 |= (ref.SAP_delta_time & 268435455);
            out.putInt(i0);
            out.putInt(i1);
            out.putInt(i2);
        }
    };
    prototype.toString = function() {
        return "SegmentIndexBox [reference_ID=" + this.reference_ID + ", timescale=" + this.timescale + ", earliest_presentation_time=" + this.earliest_presentation_time + ", first_offset=" + this.first_offset + ", reserved=" + this.reserved + ", reference_count=" + this.reference_count + ", references=" + Platform.arrayToString(this.references) + ", version=" + this.version + ", flags=" + this.flags + ", header=" + this.header + "]";
    };
}, {references: "Array", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var TrackHeaderBox = function(header) {
    FullBox.call(this, header);
};
TrackHeaderBox = stjs.extend(TrackHeaderBox, FullBox, [], function(constructor, prototype) {
    prototype.trackId = 0;
    prototype.duration = 0;
    prototype.width = 0.0;
    prototype.height = 0.0;
    prototype.created = 0;
    prototype.modified = 0;
    prototype.volume = 0.0;
    prototype.layer = 0;
    prototype.altGroup = 0;
    prototype.matrix = null;
    constructor.fourcc = function() {
        return "tkhd";
    };
    constructor.createTrackHeaderBox = function(trackId, duration, width, height, created, modified, volume, layer, altGroup, matrix) {
        var box = new TrackHeaderBox(new Header(TrackHeaderBox.fourcc()));
        box.trackId = trackId;
        box.duration = duration;
        box.width = width;
        box.height = height;
        box.created = created;
        box.modified = modified;
        box.volume = volume;
        box.layer = layer;
        box.altGroup = altGroup;
        box.matrix = matrix;
        return box;
    };
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        if (this.version == 0) {
            this.created = TimeUtil.fromMovTime(input.getInt());
            this.modified = TimeUtil.fromMovTime(input.getInt());
        } else {
            this.created = TimeUtil.fromMovTime(((input.getLong()) | 0));
            this.modified = TimeUtil.fromMovTime(((input.getLong()) | 0));
        }
        this.trackId = input.getInt();
        input.getInt();
        if (this.version == 0) {
            this.duration = input.getInt();
        } else {
            this.duration = input.getLong();
        }
        input.getInt();
        input.getInt();
        this.layer = input.getShort();
        this.altGroup = input.getShort();
        this.volume = this.readVolume(input);
        input.getShort();
        this.readMatrix(input);
        this.width = input.getInt() / 65536.0;
        this.height = input.getInt() / 65536.0;
    };
    prototype.readMatrix = function(input) {
        this.matrix = new Int32Array(9);
        for (var i = 0; i < 9; i++) 
            this.matrix[i] = input.getInt();
    };
    prototype.readVolume = function(input) {
        return (input.getShort() / 256.0);
    };
    prototype.getNo = function() {
        return this.trackId;
    };
    prototype.getDuration = function() {
        return this.duration;
    };
    prototype.getWidth = function() {
        return this.width;
    };
    prototype.getHeight = function() {
        return this.height;
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        out.putInt(TimeUtil.toMovTime(this.created));
        out.putInt(TimeUtil.toMovTime(this.modified));
        out.putInt(this.trackId);
        out.putInt(0);
        out.putInt(((this.duration) | 0));
        out.putInt(0);
        out.putInt(0);
        out.putShort(stjs.trunc(this.layer));
        out.putShort(((this.altGroup) << 16 >> 16));
        this.writeVolume(out);
        out.putShort(((0) << 16 >> 16));
        this.writeMatrix(out);
        out.putInt(stjs.trunc((this.width * 65536)));
        out.putInt(stjs.trunc((this.height * 65536)));
    };
    prototype.writeMatrix = function(out) {
        for (var i = 0; i < 9; i++) 
            out.putInt(this.matrix[i]);
    };
    prototype.writeVolume = function(out) {
        out.putShort(stjs.trunc((this.volume * 256.0)));
    };
    prototype.getTrackId = function() {
        return this.trackId;
    };
    prototype.getCreated = function() {
        return this.created;
    };
    prototype.getModified = function() {
        return this.modified;
    };
    prototype.getVolume = function() {
        return this.volume;
    };
    prototype.getLayer = function() {
        return this.layer;
    };
    prototype.getAltGroup = function() {
        return this.altGroup;
    };
    prototype.getMatrix = function() {
        return this.matrix;
    };
    prototype.setWidth = function(width) {
        this.width = width;
    };
    prototype.setHeight = function(height) {
        this.height = height;
    };
    prototype.setDuration = function(duration) {
        this.duration = duration;
    };
    prototype.setNo = function(no) {
        this.trackId = no;
    };
}, {matrix: "Int32Array", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A box containing sample presentation time information
 *  
 *  @author The JCodec project
 *  
 */
var TimeToSampleBox = function(atom) {
    FullBox.call(this, atom);
};
TimeToSampleBox = stjs.extend(TimeToSampleBox, FullBox, [], function(constructor, prototype) {
    constructor.TimeToSampleEntry = function(sampleCount, sampleDuration) {
        this.sampleCount = sampleCount;
        this.sampleDuration = sampleDuration;
    };
    constructor.TimeToSampleEntry = stjs.extend(constructor.TimeToSampleEntry, null, [], function(constructor, prototype) {
        prototype.sampleCount = 0;
        prototype.sampleDuration = 0;
        prototype.getSampleCount = function() {
            return this.sampleCount;
        };
        prototype.getSampleDuration = function() {
            return this.sampleDuration;
        };
        prototype.setSampleDuration = function(sampleDuration) {
            this.sampleDuration = sampleDuration;
        };
        prototype.setSampleCount = function(sampleCount) {
            this.sampleCount = sampleCount;
        };
        prototype.getSegmentDuration = function() {
            return this.sampleCount * this.sampleDuration;
        };
    }, {}, {});
    constructor.fourcc = function() {
        return "stts";
    };
    constructor.createTimeToSampleBox = function(timeToSamples) {
        var box = new TimeToSampleBox(new Header(TimeToSampleBox.fourcc()));
        box.entries = timeToSamples;
        return box;
    };
    prototype.entries = null;
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        var foo = input.getInt();
        this.entries = Array(foo);
        for (var i = 0; i < foo; i++) {
            this.entries[i] = new TimeToSampleBox.TimeToSampleEntry(input.getInt(), input.getInt());
        }
    };
    prototype.getEntries = function() {
        return this.entries;
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        out.putInt(this.entries.length);
        for (var i = 0; i < this.entries.length; i++) {
            var timeToSampleEntry = this.entries[i];
            out.putInt(timeToSampleEntry.getSampleCount());
            out.putInt(timeToSampleEntry.getSampleDuration());
        }
    };
    prototype.setEntries = function(entries) {
        this.entries = entries;
    };
}, {entries: "Array", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A movie header box
 *  
 *  @author The JCodec project
 *  
 */
var MovieHeaderBox = function(header) {
    FullBox.call(this, header);
};
MovieHeaderBox = stjs.extend(MovieHeaderBox, FullBox, [], function(constructor, prototype) {
    prototype.timescale = 0;
    prototype.duration = 0;
    prototype.rate = 0.0;
    prototype.volume = 0.0;
    prototype.created = 0;
    prototype.modified = 0;
    prototype.matrix = null;
    prototype.nextTrackId = 0;
    constructor.fourcc = function() {
        return "mvhd";
    };
    constructor.createMovieHeaderBox = function(timescale, duration, rate, volume, created, modified, matrix, nextTrackId) {
        var mvhd = new MovieHeaderBox(new Header(MovieHeaderBox.fourcc()));
        mvhd.timescale = timescale;
        mvhd.duration = duration;
        mvhd.rate = rate;
        mvhd.volume = volume;
        mvhd.created = created;
        mvhd.modified = modified;
        mvhd.matrix = matrix;
        mvhd.nextTrackId = nextTrackId;
        return mvhd;
    };
    prototype.getTimescale = function() {
        return this.timescale;
    };
    prototype.getDuration = function() {
        return this.duration;
    };
    prototype.getNextTrackId = function() {
        return this.nextTrackId;
    };
    prototype.getRate = function() {
        return this.rate;
    };
    prototype.getVolume = function() {
        return this.volume;
    };
    prototype.getCreated = function() {
        return this.created;
    };
    prototype.getModified = function() {
        return this.modified;
    };
    prototype.getMatrix = function() {
        return this.matrix;
    };
    prototype.setTimescale = function(newTs) {
        this.timescale = newTs;
    };
    prototype.setDuration = function(duration) {
        this.duration = duration;
    };
    prototype.setNextTrackId = function(nextTrackId) {
        this.nextTrackId = nextTrackId;
    };
    prototype.readMatrix = function(input) {
        var matrix = new Int32Array(9);
        for (var i = 0; i < 9; i++) 
            matrix[i] = input.getInt();
        return matrix;
    };
    prototype.readVolume = function(input) {
        return input.getShort() / 256.0;
    };
    prototype.readRate = function(input) {
        return input.getInt() / 65536.0;
    };
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        if (this.version == 0) {
            this.created = TimeUtil.fromMovTime(input.getInt());
            this.modified = TimeUtil.fromMovTime(input.getInt());
            this.timescale = input.getInt();
            this.duration = input.getInt();
        } else if (this.version == 1) {
            this.created = TimeUtil.fromMovTime(((input.getLong()) | 0));
            this.modified = TimeUtil.fromMovTime(((input.getLong()) | 0));
            this.timescale = input.getInt();
            this.duration = input.getLong();
        } else {
             throw new RuntimeException("Unsupported version");
        }
        this.rate = this.readRate(input);
        this.volume = this.readVolume(input);
        NIOUtils.skip(input, 10);
        this.matrix = this.readMatrix(input);
        NIOUtils.skip(input, 24);
        this.nextTrackId = input.getInt();
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        out.putInt(TimeUtil.toMovTime(this.created));
        out.putInt(TimeUtil.toMovTime(this.modified));
        out.putInt(this.timescale);
        out.putInt(((this.duration) | 0));
        this.writeFixed1616(out, this.rate);
        this.writeFixed88(out, this.volume);
        out.putArr(new Int8Array(10));
        this.writeMatrix(out);
        out.putArr(new Int8Array(24));
        out.putInt(this.nextTrackId);
    };
    prototype.writeMatrix = function(out) {
        for (var i = 0; i < Math.min(9, this.matrix.length); i++) 
            out.putInt(this.matrix[i]);
        for (var i = Math.min(9, this.matrix.length); i < 9; i++) 
            out.putInt(0);
    };
    prototype.writeFixed88 = function(out, volume) {
        out.putShort(stjs.trunc((volume * 256.0)));
    };
    prototype.writeFixed1616 = function(out, rate) {
        out.putInt(stjs.trunc((rate * 65536.0)));
    };
}, {matrix: "Int32Array", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var VideoMediaHeaderBox = function(header) {
    FullBox.call(this, header);
};
VideoMediaHeaderBox = stjs.extend(VideoMediaHeaderBox, FullBox, [], function(constructor, prototype) {
    prototype.graphicsMode = 0;
    prototype.rOpColor = 0;
    prototype.gOpColor = 0;
    prototype.bOpColor = 0;
    constructor.fourcc = function() {
        return "vmhd";
    };
    constructor.createVideoMediaHeaderBox = function(graphicsMode, rOpColor, gOpColor, bOpColor) {
        var vmhd = new VideoMediaHeaderBox(new Header(VideoMediaHeaderBox.fourcc()));
        vmhd.graphicsMode = graphicsMode;
        vmhd.rOpColor = rOpColor;
        vmhd.gOpColor = gOpColor;
        vmhd.bOpColor = bOpColor;
        return vmhd;
    };
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        this.graphicsMode = input.getShort();
        this.rOpColor = input.getShort();
        this.gOpColor = input.getShort();
        this.bOpColor = input.getShort();
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        out.putShort(((this.graphicsMode) << 16 >> 16));
        out.putShort(((this.rOpColor) << 16 >> 16));
        out.putShort(((this.gOpColor) << 16 >> 16));
        out.putShort(((this.bOpColor) << 16 >> 16));
    };
    prototype.getGraphicsMode = function() {
        return this.graphicsMode;
    };
    prototype.getrOpColor = function() {
        return this.rOpColor;
    };
    prototype.getgOpColor = function() {
        return this.gOpColor;
    };
    prototype.getbOpColor = function() {
        return this.bOpColor;
    };
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var UrlBox = function(atom) {
    FullBox.call(this, atom);
};
UrlBox = stjs.extend(UrlBox, FullBox, [], function(constructor, prototype) {
    prototype.url = null;
    constructor.fourcc = function() {
        return "url ";
    };
    constructor.createUrlBox = function(url) {
        var urlBox = new UrlBox(new Header(UrlBox.fourcc()));
        urlBox.url = url;
        return urlBox;
    };
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        if ((this.flags & 1) != 0) 
            return;
        var utf8 = Charset.forName("utf-8");
        this.url = NIOUtils.readNullTermStringCharset(input, utf8);
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        var utf8 = Charset.forName("utf-8");
        if (this.url != null) {
            NIOUtils.write(out, ByteBuffer.wrap(Platform.getBytesForCharset(this.url, utf8)));
            out.put((0 << 24 >> 24));
        }
    };
    prototype.getUrl = function() {
        return this.url;
    };
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  @author The JCodec project
 */
var SampleSizesBox = function(atom) {
    FullBox.call(this, atom);
};
SampleSizesBox = stjs.extend(SampleSizesBox, FullBox, [], function(constructor, prototype) {
    prototype.defaultSize = 0;
    prototype.count = 0;
    prototype.sizes = null;
    constructor.fourcc = function() {
        return "stsz";
    };
    constructor.createSampleSizesBox = function(defaultSize, count) {
        var stsz = new SampleSizesBox(new Header(SampleSizesBox.fourcc()));
        stsz.defaultSize = defaultSize;
        stsz.count = count;
        return stsz;
    };
    constructor.createSampleSizesBox2 = function(sizes) {
        var stsz = new SampleSizesBox(new Header(SampleSizesBox.fourcc()));
        stsz.sizes = sizes;
        stsz.count = sizes.length;
        return stsz;
    };
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        this.defaultSize = input.getInt();
        this.count = input.getInt();
        if (this.defaultSize == 0) {
            this.sizes = new Int32Array(this.count);
            for (var i = 0; i < this.count; i++) {
                this.sizes[i] = input.getInt();
            }
        }
    };
    prototype.getDefaultSize = function() {
        return this.defaultSize;
    };
    prototype.getSizes = function() {
        return this.sizes;
    };
    prototype.getCount = function() {
        return this.count;
    };
    prototype.setCount = function(count) {
        this.count = count;
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        out.putInt(stjs.trunc(this.defaultSize));
        if (this.defaultSize == 0) {
            out.putInt(this.count);
            for (var i = 0; i < this.sizes.length; i++) {
                var size = this.sizes[i];
                out.putInt(((size) | 0));
            }
        } else {
            out.putInt(stjs.trunc(this.count));
        }
    };
    prototype.setSizes = function(sizes) {
        this.sizes = sizes;
        this.count = sizes.length;
    };
}, {sizes: "Int32Array", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var EditListBox = function(atom) {
    FullBox.call(this, atom);
};
EditListBox = stjs.extend(EditListBox, FullBox, [], function(constructor, prototype) {
    prototype.edits = null;
    constructor.fourcc = function() {
        return "elst";
    };
    constructor.createEditListBox = function(edits) {
        var elst = new EditListBox(new Header(EditListBox.fourcc()));
        elst.edits = edits;
        return elst;
    };
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        this.edits = new ArrayList();
        var num = input.getInt();
        for (var i = 0; i < num; i++) {
            var duration = input.getInt();
            var mediaTime = input.getInt();
            var rate = input.getInt() / 65536.0;
            this.edits.add(new Edit(duration, mediaTime, rate));
        }
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        out.putInt(this.edits.size());
        for (var iterator$edit = this.edits.iterator(); iterator$edit.hasNext(); ) {
            var edit = iterator$edit.next();
            out.putInt(((edit.getDuration()) | 0));
            out.putInt(((edit.getMediaTime()) | 0));
            out.putInt(stjs.trunc((edit.getRate() * 65536)));
        }
    };
    prototype.getEdits = function() {
        return this.edits;
    };
}, {edits: {name: "List", arguments: ["Edit"]}, header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  The Track Fragment Base Media Decode Time Box provides the absolute decode
 *  time, measured on the media timeline, of the first sample in decode order in
 *  the track fragment. This can be useful, for example, when performing random
 *  access in a file; it is not necessary to sum the sample durations of all
 *  preceding samples in previous fragments to find this value (where the sample
 *  durations are the deltas in the Decoding Time to Sample Box and the
 *  sample_durations in the preceding track runs). The Track Fragment Base Media
 *  Decode Time Box, if present, shall be positioned after the Track Fragment
 *  Header Box and before the first Track Fragment Run box.
 *  
 *  @author The JCodec project
 *  
 */
var TrackFragmentBaseMediaDecodeTimeBox = function(atom) {
    FullBox.call(this, atom);
};
TrackFragmentBaseMediaDecodeTimeBox = stjs.extend(TrackFragmentBaseMediaDecodeTimeBox, FullBox, [], function(constructor, prototype) {
    prototype.baseMediaDecodeTime = 0;
    constructor.createTrackFragmentBaseMediaDecodeTimeBox = function(baseMediaDecodeTime) {
        var box = new TrackFragmentBaseMediaDecodeTimeBox(new Header(TrackFragmentBaseMediaDecodeTimeBox.fourcc()));
        box.baseMediaDecodeTime = baseMediaDecodeTime;
        if (box.baseMediaDecodeTime > Integer.MAX_VALUE) {
            box.version = 1;
        }
        return box;
    };
    constructor.fourcc = function() {
        return "tfdt";
    };
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        if (this.version == 0) {
            this.baseMediaDecodeTime = input.getInt();
        } else if (this.version == 1) {
            this.baseMediaDecodeTime = input.getLong();
        } else 
             throw new RuntimeException("Unsupported tfdt version");
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        if (this.version == 0) {
            out.putInt(((this.baseMediaDecodeTime) | 0));
        } else if (this.version == 1) {
            out.putLong(this.baseMediaDecodeTime);
        } else 
             throw new RuntimeException("Unsupported tfdt version");
    };
    prototype.getBaseMediaDecodeTime = function() {
        return this.baseMediaDecodeTime;
    };
    prototype.setBaseMediaDecodeTime = function(baseMediaDecodeTime) {
        this.baseMediaDecodeTime = baseMediaDecodeTime;
    };
    constructor.copy = function(other) {
        return new TrackFragmentBaseMediaDecodeTimeBox.Factory(other);
    };
    constructor.Factory = function(other) {
        this.box = TrackFragmentBaseMediaDecodeTimeBox.createTrackFragmentBaseMediaDecodeTimeBox(other.baseMediaDecodeTime);
        this.box.version = other.version;
        this.box.flags = other.flags;
    };
    constructor.Factory = stjs.extend(constructor.Factory, null, [], function(constructor, prototype) {
        prototype.box = null;
        prototype.baseMediaDecodeTime = function(val) {
            this.box.baseMediaDecodeTime = val;
            return this;
        };
        prototype.create = function() {
            try {
                return this.box;
            } finally {
                this.box = null;
            }
        };
    }, {box: "TrackFragmentBaseMediaDecodeTimeBox"}, {});
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A box storing a list of synch samples
 *  
 *  @author The JCodec project
 *  
 */
var SyncSamplesBox = function(header) {
    FullBox.call(this, header);
};
SyncSamplesBox = stjs.extend(SyncSamplesBox, FullBox, [], function(constructor, prototype) {
    constructor.STSS = "stss";
    prototype.syncSamples = null;
    constructor.createSyncSamplesBox = function(array) {
        var stss = new SyncSamplesBox(new Header(SyncSamplesBox.STSS));
        stss.syncSamples = array;
        return stss;
    };
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        var len = input.getInt();
        this.syncSamples = new Int32Array(len);
        for (var i = 0; i < len; i++) {
            this.syncSamples[i] = input.getInt();
        }
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        out.putInt(this.syncSamples.length);
        for (var i = 0; i < this.syncSamples.length; i++) 
            out.putInt(stjs.trunc(this.syncSamples[i]));
    };
    prototype.getSyncSamples = function() {
        return this.syncSamples;
    };
}, {syncSamples: "Int32Array", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var TimecodeMediaInfoBox = function(atom) {
    FullBox.call(this, atom);
    this.color = new Int16Array(3);
    this.bgcolor = new Int16Array(3);
};
TimecodeMediaInfoBox = stjs.extend(TimecodeMediaInfoBox, FullBox, [], function(constructor, prototype) {
    prototype.font = 0;
    prototype.face = 0;
    prototype.size = 0;
    prototype.color = null;
    prototype.bgcolor = null;
    prototype.name = null;
    constructor.fourcc = function() {
        return "tcmi";
    };
    constructor.createTimecodeMediaInfoBox = function(font, face, size, color, bgcolor, name) {
        var box = new TimecodeMediaInfoBox(new Header(TimecodeMediaInfoBox.fourcc()));
        box.font = font;
        box.face = face;
        box.size = size;
        box.color = color;
        box.bgcolor = bgcolor;
        box.name = name;
        return box;
    };
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        this.font = input.getShort();
        this.face = input.getShort();
        this.size = input.getShort();
        input.getShort();
        this.color[0] = input.getShort();
        this.color[1] = input.getShort();
        this.color[2] = input.getShort();
        this.bgcolor[0] = input.getShort();
        this.bgcolor[1] = input.getShort();
        this.bgcolor[2] = input.getShort();
        this.name = NIOUtils.readPascalString(input);
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        out.putShort(this.font);
        out.putShort(this.face);
        out.putShort(this.size);
        out.putShort(((0) << 16 >> 16));
        out.putShort(this.color[0]);
        out.putShort(this.color[1]);
        out.putShort(this.color[2]);
        out.putShort(this.bgcolor[0]);
        out.putShort(this.bgcolor[1]);
        out.putShort(this.bgcolor[2]);
        NIOUtils.writePascalString(out, this.name);
    };
}, {color: "Int16Array", bgcolor: "Int16Array", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Track fragment header box
 *  
 *  @author The JCodec project
 *  
 */
var TrackFragmentHeaderBox = function(atom) {
    FullBox.call(this, atom);
};
TrackFragmentHeaderBox = stjs.extend(TrackFragmentHeaderBox, FullBox, [], function(constructor, prototype) {
    constructor.FLAG_BASE_DATA_OFFSET = 1;
    constructor.FLAG_SAMPLE_DESCRIPTION_INDEX = 2;
    constructor.FLAG_DEFAILT_SAMPLE_DURATION = 8;
    constructor.FLAG_DEFAULT_SAMPLE_SIZE = 16;
    constructor.FLAG_DEFAILT_SAMPLE_FLAGS = 32;
    prototype.trackId = 0;
    prototype.baseDataOffset = 0;
    prototype.sampleDescriptionIndex = 0;
    prototype.defaultSampleDuration = 0;
    prototype.defaultSampleSize = 0;
    prototype.defaultSampleFlags = 0;
    constructor.fourcc = function() {
        return "tfhd";
    };
    constructor.createTrackFragmentHeaderBox = function(trackId, baseDataOffset, sampleDescriptionIndex, defaultSampleDuration, defaultSampleSize, defaultSampleFlags) {
        var box = new TrackFragmentHeaderBox(new Header(TrackFragmentHeaderBox.fourcc()));
        box.trackId = trackId;
        box.baseDataOffset = baseDataOffset;
        box.sampleDescriptionIndex = sampleDescriptionIndex;
        box.defaultSampleDuration = defaultSampleDuration;
        box.defaultSampleSize = defaultSampleSize;
        box.defaultSampleFlags = defaultSampleFlags;
        return box;
    };
    constructor.create = function(trackId) {
        return new TrackFragmentHeaderBox.Factory(TrackFragmentHeaderBox.createTrackFragmentHeaderBoxWithId(trackId));
    };
    constructor.copy = function(other) {
        var box = TrackFragmentHeaderBox.createTrackFragmentHeaderBox(other.trackId, other.baseDataOffset, other.sampleDescriptionIndex, other.defaultSampleDuration, other.defaultSampleSize, other.defaultSampleFlags);
        box.setFlags(other.getFlags());
        box.setVersion(other.getVersion());
        return new TrackFragmentHeaderBox.Factory(box);
    };
    constructor.createTrackFragmentHeaderBoxWithId = function(trackId) {
        var box = new TrackFragmentHeaderBox(new Header(TrackFragmentHeaderBox.fourcc()));
        box.trackId = trackId;
        return box;
    };
    constructor.Factory = function(box) {
        this.box = box;
    };
    constructor.Factory = stjs.extend(constructor.Factory, null, [], function(constructor, prototype) {
        prototype.box = null;
        prototype.baseDataOffset = function(baseDataOffset) {
            this.box.flags |= TrackFragmentHeaderBox.FLAG_BASE_DATA_OFFSET;
            this.box.baseDataOffset = ((baseDataOffset) | 0);
            return this;
        };
        prototype.sampleDescriptionIndex = function(sampleDescriptionIndex) {
            this.box.flags |= TrackFragmentHeaderBox.FLAG_SAMPLE_DESCRIPTION_INDEX;
            this.box.sampleDescriptionIndex = ((sampleDescriptionIndex) | 0);
            return this;
        };
        prototype.defaultSampleDuration = function(defaultSampleDuration) {
            this.box.flags |= TrackFragmentHeaderBox.FLAG_DEFAILT_SAMPLE_DURATION;
            this.box.defaultSampleDuration = ((defaultSampleDuration) | 0);
            return this;
        };
        prototype.defaultSampleSize = function(defaultSampleSize) {
            this.box.flags |= TrackFragmentHeaderBox.FLAG_DEFAULT_SAMPLE_SIZE;
            this.box.defaultSampleSize = ((defaultSampleSize) | 0);
            return this;
        };
        prototype.defaultSampleFlags = function(defaultSampleFlags) {
            this.box.flags |= TrackFragmentHeaderBox.FLAG_DEFAILT_SAMPLE_FLAGS;
            this.box.defaultSampleFlags = ((defaultSampleFlags) | 0);
            return this;
        };
        prototype.create = function() {
            try {
                return this.box;
            } finally {
                this.box = null;
            }
        };
    }, {box: "TrackFragmentHeaderBox"}, {});
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        this.trackId = input.getInt();
        if (this.isBaseDataOffsetAvailable()) 
            this.baseDataOffset = input.getLong();
        if (this.isSampleDescriptionIndexAvailable()) 
            this.sampleDescriptionIndex = input.getInt();
        if (this.isDefaultSampleDurationAvailable()) 
            this.defaultSampleDuration = input.getInt();
        if (this.isDefaultSampleSizeAvailable()) 
            this.defaultSampleSize = input.getInt();
        if (this.isDefaultSampleFlagsAvailable()) 
            this.defaultSampleFlags = input.getInt();
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        out.putInt(this.trackId);
        if (this.isBaseDataOffsetAvailable()) 
            out.putLong(this.baseDataOffset);
        if (this.isSampleDescriptionIndexAvailable()) 
            out.putInt(this.sampleDescriptionIndex);
        if (this.isDefaultSampleDurationAvailable()) 
            out.putInt(this.defaultSampleDuration);
        if (this.isDefaultSampleSizeAvailable()) 
            out.putInt(this.defaultSampleSize);
        if (this.isDefaultSampleFlagsAvailable()) 
            out.putInt(this.defaultSampleFlags);
    };
    prototype.getTrackId = function() {
        return this.trackId;
    };
    prototype.getBaseDataOffset = function() {
        return this.baseDataOffset;
    };
    prototype.getSampleDescriptionIndex = function() {
        return this.sampleDescriptionIndex;
    };
    prototype.getDefaultSampleDuration = function() {
        return this.defaultSampleDuration;
    };
    prototype.getDefaultSampleSize = function() {
        return this.defaultSampleSize;
    };
    prototype.getDefaultSampleFlags = function() {
        return this.defaultSampleFlags;
    };
    prototype.isBaseDataOffsetAvailable = function() {
        return (this.flags & TrackFragmentHeaderBox.FLAG_BASE_DATA_OFFSET) != 0;
    };
    prototype.isSampleDescriptionIndexAvailable = function() {
        return (this.flags & TrackFragmentHeaderBox.FLAG_SAMPLE_DESCRIPTION_INDEX) != 0;
    };
    prototype.isDefaultSampleDurationAvailable = function() {
        return (this.flags & TrackFragmentHeaderBox.FLAG_DEFAILT_SAMPLE_DURATION) != 0;
    };
    prototype.isDefaultSampleSizeAvailable = function() {
        return (this.flags & TrackFragmentHeaderBox.FLAG_DEFAULT_SAMPLE_SIZE) != 0;
    };
    prototype.isDefaultSampleFlagsAvailable = function() {
        return (this.flags & TrackFragmentHeaderBox.FLAG_DEFAILT_SAMPLE_FLAGS) != 0;
    };
    prototype.setTrackId = function(trackId) {
        this.trackId = trackId;
    };
    prototype.setDefaultSampleFlags = function(defaultSampleFlags) {
        this.defaultSampleFlags = defaultSampleFlags;
    };
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Movie fragment header box
 *  
 *  
 *  @author The JCodec project
 *  
 */
var MovieFragmentHeaderBox = function(atom) {
    FullBox.call(this, atom);
};
MovieFragmentHeaderBox = stjs.extend(MovieFragmentHeaderBox, FullBox, [], function(constructor, prototype) {
    prototype.sequenceNumber = 0;
    constructor.fourcc = function() {
        return "mfhd";
    };
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        this.sequenceNumber = input.getInt();
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        out.putInt(this.sequenceNumber);
    };
    prototype.getSequenceNumber = function() {
        return this.sequenceNumber;
    };
    prototype.setSequenceNumber = function(sequenceNumber) {
        this.sequenceNumber = sequenceNumber;
    };
    constructor.createMovieFragmentHeaderBox = function(sequenceNumber) {
        var mfhd = new MovieFragmentHeaderBox(new Header(MovieFragmentHeaderBox.fourcc()));
        mfhd.setSequenceNumber(sequenceNumber);
        return mfhd;
    };
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var AliasBox = function(atom) {
    FullBox.call(this, atom);
};
AliasBox = stjs.extend(AliasBox, FullBox, [], function(constructor, prototype) {
    constructor.DirectoryName = 0;
    constructor.DirectoryIDs = 1;
    constructor.AbsolutePath = 2;
    constructor.AppleShareZoneName = 3;
    constructor.AppleShareServerName = 4;
    constructor.AppleShareUserName = 5;
    constructor.DriverName = 6;
    constructor.RevisedAppleShare = 9;
    constructor.AppleRemoteAccessDialup = 10;
    constructor.UNIXAbsolutePath = 18;
    constructor.UTF16AbsolutePath = 14;
    constructor.UFT16VolumeName = 15;
    constructor.VolumeMountPoint = 19;
    prototype.type = null;
    prototype.recordSize = 0;
    prototype.version = 0;
    prototype.kind = 0;
    prototype.volumeName = null;
    prototype.volumeCreateDate = 0;
    prototype.volumeSignature = 0;
    prototype.volumeType = 0;
    prototype.parentDirId = 0;
    prototype.fileName = null;
    prototype.fileNumber = 0;
    prototype.createdLocalDate = 0;
    prototype.fileTypeName = null;
    prototype.creatorName = null;
    prototype.nlvlFrom = 0;
    prototype.nlvlTo = 0;
    prototype.volumeAttributes = 0;
    prototype.fsId = 0;
    prototype.extra = null;
    constructor.fourcc = function() {
        return "alis";
    };
    constructor.utf16 = new HashSet();
    constructor.ExtraField = function(type, len, bs) {
        this.type = type;
        this.len = len;
        this.data = bs;
    };
    constructor.ExtraField = stjs.extend(constructor.ExtraField, null, [], function(constructor, prototype) {
        prototype.type = 0;
        prototype.len = 0;
        prototype.data = null;
        prototype.toString = function() {
            return Platform.stringFromCharset4(this.data, 0, this.len, AliasBox.utf16.contains(this.type) ? Charset.forName("UTF-16") : Charset.forName("UTF-8"));
        };
    }, {data: "Int8Array"}, {});
    prototype.parse = function(is) {
        FullBox.prototype.parse.call(this, is);
        if ((this.flags & 1) != 0) 
            return;
        this.type = NIOUtils.readString(is, 4);
        this.recordSize = is.getShort();
        this.version = is.getShort();
        this.kind = is.getShort();
        this.volumeName = NIOUtils.readPascalStringL(is, 27);
        this.volumeCreateDate = is.getInt();
        this.volumeSignature = is.getShort();
        this.volumeType = is.getShort();
        this.parentDirId = is.getInt();
        this.fileName = NIOUtils.readPascalStringL(is, 63);
        this.fileNumber = is.getInt();
        this.createdLocalDate = is.getInt();
        this.fileTypeName = NIOUtils.readString(is, 4);
        this.creatorName = NIOUtils.readString(is, 4);
        this.nlvlFrom = is.getShort();
        this.nlvlTo = is.getShort();
        this.volumeAttributes = is.getInt();
        this.fsId = is.getShort();
        NIOUtils.skip(is, 10);
        this.extra = new ArrayList();
         while (true){
            var type = is.getShort();
            if (type == -1) 
                break;
            var len = is.getShort();
            var bs = NIOUtils.toArray(NIOUtils.read(is, (len + 1) & -2));
            if (bs == null) 
                break;
            this.extra.add(new AliasBox.ExtraField(type, len, bs));
        }
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        if ((this.flags & 1) != 0) 
            return;
        out.put3(JCodecUtil2.asciiString(this.type), 0, 4);
        out.putShort(this.recordSize);
        out.putShort(this.version);
        out.putShort(this.kind);
        NIOUtils.writePascalStringL(out, this.volumeName, 27);
        out.putInt(this.volumeCreateDate);
        out.putShort(this.volumeSignature);
        out.putShort(this.volumeType);
        out.putInt(this.parentDirId);
        NIOUtils.writePascalStringL(out, this.fileName, 63);
        out.putInt(this.fileNumber);
        out.putInt(this.createdLocalDate);
        out.put3(JCodecUtil2.asciiString(this.fileTypeName), 0, 4);
        out.put3(JCodecUtil2.asciiString(this.creatorName), 0, 4);
        out.putShort(this.nlvlFrom);
        out.putShort(this.nlvlTo);
        out.putInt(this.volumeAttributes);
        out.putShort(this.fsId);
        out.putArr(new Int8Array(10));
        for (var iterator$extraField = this.extra.iterator(); iterator$extraField.hasNext(); ) {
            var extraField = iterator$extraField.next();
            out.putShort(extraField.type);
            out.putShort(((extraField.len) << 16 >> 16));
            out.putArr(extraField.data);
        }
        out.putShort(((-1) << 16 >> 16));
        out.putShort(((0) << 16 >> 16));
    };
    prototype.getRecordSize = function() {
        return this.recordSize;
    };
    prototype.getFileName = function() {
        return this.fileName;
    };
    prototype.getExtras = function() {
        return this.extra;
    };
    prototype.getExtra = function(type) {
        for (var iterator$extraField = this.extra.iterator(); iterator$extraField.hasNext(); ) {
            var extraField = iterator$extraField.next();
            if (extraField.type == type) 
                return extraField;
        }
        return null;
    };
    prototype.isSelfRef = function() {
        return (this.flags & 1) != 0;
    };
    constructor.createSelfRef = function() {
        var alis = new AliasBox(new Header(AliasBox.fourcc()));
        alis.setFlags(1);
        return alis;
    };
    prototype.getUnixPath = function() {
        var extraField = this.getExtra(AliasBox.UNIXAbsolutePath);
        return extraField == null ? null : "/" + extraField.toString();
    };
}, {extra: {name: "List", arguments: ["AliasBox.ExtraField"]}, utf16: {name: "Set", arguments: [null]}, header: "Header"}, {});
(function() {
    AliasBox.utf16.add(14);
    AliasBox.utf16.add(15);
})();
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  MPEG 4 elementary stream descriptor
 *  
 *  @author The JCodec project
 *  
 */
var EsdsBox = function(atom) {
    FullBox.call(this, atom);
};
EsdsBox = stjs.extend(EsdsBox, FullBox, [], function(constructor, prototype) {
    prototype.streamInfo = null;
    prototype.objectType = 0;
    prototype.bufSize = 0;
    prototype.maxBitrate = 0;
    prototype.avgBitrate = 0;
    prototype.trackId = 0;
    constructor.fourcc = function() {
        return "esds";
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        if (this.streamInfo != null && this.streamInfo.remaining() > 0) 
            new ES(this.trackId, [new DecoderConfig(this.objectType, this.bufSize, this.maxBitrate, this.avgBitrate, [new DecoderSpecific(this.streamInfo)]), new SL()]).write(out);
         else 
            new ES(this.trackId, [new DecoderConfig(this.objectType, this.bufSize, this.maxBitrate, this.avgBitrate, Array(0)), new SL()]).write(out);
    };
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        var es = Descriptor.read(input, DescriptorFactory.getInstance());
        this.trackId = es.getTrackId();
        var decoderConfig = NodeDescriptor.find(es, DecoderConfig, DecoderConfig.tag());
        this.objectType = decoderConfig.getObjectType();
        this.bufSize = decoderConfig.getBufSize();
        this.maxBitrate = decoderConfig.getMaxBitrate();
        this.avgBitrate = decoderConfig.getAvgBitrate();
        var decoderSpecific = NodeDescriptor.find(decoderConfig, DecoderSpecific, DecoderSpecific.tag());
        this.streamInfo = decoderSpecific.getData();
    };
    prototype.getStreamInfo = function() {
        return this.streamInfo;
    };
    prototype.getObjectType = function() {
        return this.objectType;
    };
    prototype.getBufSize = function() {
        return this.bufSize;
    };
    prototype.getMaxBitrate = function() {
        return this.maxBitrate;
    };
    prototype.getAvgBitrate = function() {
        return this.avgBitrate;
    };
    prototype.getTrackId = function() {
        return this.trackId;
    };
    constructor.fromADTS = function(hdr) {
        var si = ByteBuffer.allocate(2);
        var wr = new BitWriter(si);
        wr.writeNBit(hdr.getObjectType(), 5);
        wr.writeNBit(hdr.getSamplingIndex(), 4);
        wr.writeNBit(hdr.getChanConfig(), 4);
        wr.flush();
        si.clear();
        return EsdsBox.createEsdsBox(si, hdr.getObjectType() << 5, 0, 210750, 133350, 2);
    };
    constructor.createEsdsBox = function(streamInfo, objectType, bufSize, maxBitrate, avgBitrate, trackId) {
        var esds = new EsdsBox(new Header(EsdsBox.fourcc()));
        esds.objectType = objectType;
        esds.bufSize = bufSize;
        esds.maxBitrate = maxBitrate;
        esds.avgBitrate = avgBitrate;
        esds.trackId = trackId;
        esds.streamInfo = streamInfo;
        return esds;
    };
    constructor.newEsdsBox = function() {
        return new EsdsBox(new Header(EsdsBox.fourcc()));
    };
}, {streamInfo: "ByteBuffer", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Default box factory
 *  
 *  @author The JCodec project
 *  
 */
var CompositionOffsetsBox = function(header) {
    FullBox.call(this, header);
};
CompositionOffsetsBox = stjs.extend(CompositionOffsetsBox, FullBox, [], function(constructor, prototype) {
    prototype.entries = null;
    constructor.Entry = function(count, offset) {
        this.count = count;
        this.offset = offset;
    };
    constructor.Entry = stjs.extend(constructor.Entry, null, [], function(constructor, prototype) {
        prototype.count = 0;
        prototype.offset = 0;
        prototype.getCount = function() {
            return this.count;
        };
        prototype.getOffset = function() {
            return this.offset;
        };
    }, {}, {});
    constructor.fourcc = function() {
        return "ctts";
    };
    constructor.createCompositionOffsetsBox = function(entries) {
        var ctts = new CompositionOffsetsBox(new Header(CompositionOffsetsBox.fourcc()));
        ctts.entries = entries;
        return ctts;
    };
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        var num = input.getInt();
        this.entries = Array(num);
        for (var i = 0; i < num; i++) {
            this.entries[i] = new CompositionOffsetsBox.Entry(input.getInt(), input.getInt());
        }
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        out.putInt(this.entries.length);
        for (var i = 0; i < this.entries.length; i++) {
            out.putInt(this.entries[i].count);
            out.putInt(this.entries[i].offset);
        }
    };
    prototype.getEntries = function() {
        return this.entries;
    };
}, {entries: "Array", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var ChannelBox = function(atom) {
    FullBox.call(this, atom);
};
ChannelBox = stjs.extend(ChannelBox, FullBox, [], function(constructor, prototype) {
    prototype.channelLayout = 0;
    prototype.channelBitmap = 0;
    prototype.descriptions = null;
    constructor.ChannelDescription = function(channelLabel, channelFlags, coordinates) {
        this.coordinates = new Float32Array(3);
        this.channelLabel = channelLabel;
        this.channelFlags = channelFlags;
        this.coordinates = coordinates;
    };
    constructor.ChannelDescription = stjs.extend(constructor.ChannelDescription, null, [], function(constructor, prototype) {
        prototype.channelLabel = 0;
        prototype.channelFlags = 0;
        prototype.coordinates = null;
        prototype.getChannelLabel = function() {
            return this.channelLabel;
        };
        prototype.getChannelFlags = function() {
            return this.channelFlags;
        };
        prototype.getCoordinates = function() {
            return this.coordinates;
        };
        prototype.getLabel = function() {
            return Label.getByVal(this.channelLabel);
        };
    }, {coordinates: "Float32Array"}, {});
    constructor.fourcc = function() {
        return "chan";
    };
    constructor.createChannelBox = function() {
        return new ChannelBox(new Header(ChannelBox.fourcc()));
    };
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        this.channelLayout = input.getInt();
        this.channelBitmap = input.getInt();
        var numDescriptions = input.getInt();
        this.descriptions = Array(numDescriptions);
        for (var i = 0; i < numDescriptions; i++) {
            this.descriptions[i] = new ChannelBox.ChannelDescription(input.getInt(), input.getInt(), new Float32Array([Float.intBitsToFloat(input.getInt()), Float.intBitsToFloat(input.getInt()), Float.intBitsToFloat(input.getInt())]));
        }
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        out.putInt(this.channelLayout);
        out.putInt(this.channelBitmap);
        out.putInt(this.descriptions.length);
        for (var i = 0; i < this.descriptions.length; i++) {
            var channelDescription = this.descriptions[i];
            out.putInt(channelDescription.getChannelLabel());
            out.putInt(channelDescription.getChannelFlags());
            out.putFloat(channelDescription.getCoordinates()[0]);
            out.putFloat(channelDescription.getCoordinates()[1]);
            out.putFloat(channelDescription.getCoordinates()[2]);
        }
    };
    prototype.getChannelLayout = function() {
        return this.channelLayout;
    };
    prototype.getChannelBitmap = function() {
        return this.channelBitmap;
    };
    prototype.getDescriptions = function() {
        return this.descriptions;
    };
    prototype.setChannelLayout = function(channelLayout) {
        this.channelLayout = channelLayout;
    };
    prototype.setDescriptions = function(descriptions) {
        this.descriptions = descriptions;
    };
}, {descriptions: "Array", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Sample to chunk mapping box
 *  
 *  @author The JCodec project
 *  
 */
var SampleToChunkBox = function(atom) {
    FullBox.call(this, atom);
};
SampleToChunkBox = stjs.extend(SampleToChunkBox, FullBox, [], function(constructor, prototype) {
    constructor.SampleToChunkEntry = function(first, count, entry) {
        this.first = first;
        this.count = count;
        this.entry = entry;
    };
    constructor.SampleToChunkEntry = stjs.extend(constructor.SampleToChunkEntry, null, [], function(constructor, prototype) {
        prototype.first = 0;
        prototype.count = 0;
        prototype.entry = 0;
        prototype.getFirst = function() {
            return this.first;
        };
        prototype.setFirst = function(first) {
            this.first = first;
        };
        prototype.getCount = function() {
            return this.count;
        };
        prototype.getEntry = function() {
            return this.entry;
        };
        prototype.setEntry = function(entry) {
            this.entry = entry;
        };
        prototype.setCount = function(count) {
            this.count = count;
        };
    }, {}, {});
    constructor.fourcc = function() {
        return "stsc";
    };
    constructor.createSampleToChunkBox = function(sampleToChunk) {
        var box = new SampleToChunkBox(new Header(SampleToChunkBox.fourcc()));
        box.sampleToChunk = sampleToChunk;
        return box;
    };
    prototype.sampleToChunk = null;
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        var size = input.getInt();
        this.sampleToChunk = Array(size);
        for (var i = 0; i < size; i++) {
            this.sampleToChunk[i] = new SampleToChunkBox.SampleToChunkEntry(input.getInt(), input.getInt(), input.getInt());
        }
    };
    prototype.getSampleToChunk = function() {
        return this.sampleToChunk;
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        out.putInt(this.sampleToChunk.length);
        for (var i = 0; i < this.sampleToChunk.length; i++) {
            var stc = this.sampleToChunk[i];
            out.putInt(((stc.getFirst()) | 0));
            out.putInt(stjs.trunc(stc.getCount()));
            out.putInt(stjs.trunc(stc.getEntry()));
        }
    };
    prototype.setSampleToChunk = function(sampleToChunk) {
        this.sampleToChunk = sampleToChunk;
    };
}, {sampleToChunk: "Array", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Track fragment run
 *  
 *  To crate new box:
 *  
 *  <pre>
 *  
 *  Box box = TrunBox
 *          .create(2)
 *          .dataOffset(20)
 *          .sampleCompositionOffset(new int[] { 11, 12 })
 *          .sampleDuration(new int[] { 15, 16 })
 *          .sampleFlags(new int[] { 100, 200 })
 *          .sampleSize(new int[] { 30, 40 })
 *          .create();
 *  
 *  </pre>
 *  
 *  @author The JCodec project
 *  
 */
var TrunBox = function(header) {
    FullBox.call(this, header);
};
TrunBox = stjs.extend(TrunBox, FullBox, [], function(constructor, prototype) {
    constructor.DATA_OFFSET_AVAILABLE = 1;
    constructor.FIRST_SAMPLE_FLAGS_AVAILABLE = 4;
    constructor.SAMPLE_DURATION_AVAILABLE = 256;
    constructor.SAMPLE_SIZE_AVAILABLE = 512;
    constructor.SAMPLE_FLAGS_AVAILABLE = 1024;
    constructor.SAMPLE_COMPOSITION_OFFSET_AVAILABLE = 2048;
    prototype.sampleCount = 0;
    prototype.dataOffset = 0;
    prototype.firstSampleFlags = 0;
    prototype.sampleDuration = null;
    prototype.sampleSize = null;
    prototype.sampleFlags = null;
    prototype.sampleCompositionOffset = null;
    constructor.fourcc = function() {
        return "trun";
    };
    prototype.setDataOffset = function(dataOffset) {
        this.dataOffset = dataOffset;
    };
    constructor.create = function(sampleCount) {
        return new TrunBox.Factory(TrunBox.createTrunBox1(sampleCount));
    };
    constructor.copy = function(other) {
        var box = TrunBox.createTrunBox2(other.sampleCount, other.dataOffset, other.firstSampleFlags, other.sampleDuration, other.sampleSize, other.sampleFlags, other.sampleCompositionOffset);
        box.setFlags(other.getFlags());
        box.setVersion(other.getVersion());
        return new TrunBox.Factory(box);
    };
    constructor.createTrunBox1 = function(sampleCount) {
        var trun = new TrunBox(new Header(TrunBox.fourcc()));
        trun.sampleCount = sampleCount;
        return trun;
    };
    constructor.createTrunBox2 = function(sampleCount, dataOffset, firstSampleFlags, sampleDuration, sampleSize, sampleFlags, sampleCompositionOffset) {
        var trun = new TrunBox(new Header(TrunBox.fourcc()));
        trun.sampleCount = sampleCount;
        trun.dataOffset = dataOffset;
        trun.firstSampleFlags = firstSampleFlags;
        trun.sampleDuration = sampleDuration;
        trun.sampleSize = sampleSize;
        trun.sampleFlags = sampleFlags;
        trun.sampleCompositionOffset = sampleCompositionOffset;
        return trun;
    };
    constructor.Factory = function(box) {
        this.box = box;
    };
    constructor.Factory = stjs.extend(constructor.Factory, null, [], function(constructor, prototype) {
        prototype.box = null;
        prototype.dataOffset = function(dataOffset) {
            this.box.flags |= TrunBox.DATA_OFFSET_AVAILABLE;
            this.box.dataOffset = ((dataOffset) | 0);
            return this;
        };
        prototype.firstSampleFlags = function(firstSampleFlags) {
            if (this.box.isSampleFlagsAvailable()) 
                 throw new IllegalStateException("Sample flags already set on this object");
            this.box.flags |= TrunBox.FIRST_SAMPLE_FLAGS_AVAILABLE;
            this.box.firstSampleFlags = firstSampleFlags;
            return this;
        };
        prototype.sampleDuration = function(sampleDuration) {
            if (sampleDuration.length != this.box.sampleCount) 
                 throw new IllegalArgumentException("Argument array length not equal to sampleCount");
            this.box.flags |= TrunBox.SAMPLE_DURATION_AVAILABLE;
            this.box.sampleDuration = sampleDuration;
            return this;
        };
        prototype.sampleSize = function(sampleSize) {
            if (sampleSize.length != this.box.sampleCount) 
                 throw new IllegalArgumentException("Argument array length not equal to sampleCount");
            this.box.flags |= TrunBox.SAMPLE_SIZE_AVAILABLE;
            this.box.sampleSize = sampleSize;
            return this;
        };
        prototype.sampleFlags = function(sampleFlags) {
            if (sampleFlags.length != this.box.sampleCount) 
                 throw new IllegalArgumentException("Argument array length not equal to sampleCount");
            if (this.box.isFirstSampleFlagsAvailable()) 
                 throw new IllegalStateException("First sample flags already set on this object");
            this.box.flags |= TrunBox.SAMPLE_FLAGS_AVAILABLE;
            this.box.sampleFlags = sampleFlags;
            return this;
        };
        prototype.sampleCompositionOffset = function(sampleCompositionOffset) {
            if (sampleCompositionOffset.length != this.box.sampleCount) 
                 throw new IllegalArgumentException("Argument array length not equal to sampleCount");
            this.box.flags |= TrunBox.SAMPLE_COMPOSITION_OFFSET_AVAILABLE;
            this.box.sampleCompositionOffset = sampleCompositionOffset;
            return this;
        };
        prototype.create = function() {
            try {
                return this.box;
            } finally {
                this.box = null;
            }
        };
    }, {box: "TrunBox"}, {});
    prototype.getSampleCount = function() {
        return this.sampleCount & 4294967295;
    };
    prototype.getDataOffset = function() {
        return this.dataOffset;
    };
    prototype.getFirstSampleFlags = function() {
        return this.firstSampleFlags;
    };
    prototype.getSampleDurations = function() {
        return this.sampleDuration;
    };
    prototype.getSampleSizes = function() {
        return this.sampleSize;
    };
    prototype.getSamplesFlags = function() {
        return this.sampleFlags;
    };
    prototype.getSampleCompositionOffsets = function() {
        return this.sampleCompositionOffset;
    };
    prototype.getSampleDuration = function(i) {
        return this.sampleDuration[i] & 4294967295;
    };
    prototype.getSampleSize = function(i) {
        return this.sampleSize[i] & 4294967295;
    };
    prototype.getSampleFlags = function(i) {
        return this.sampleFlags[i];
    };
    prototype.getSampleCompositionOffset = function(i) {
        return this.sampleCompositionOffset[i] & 4294967295;
    };
    prototype.isDataOffsetAvailable = function() {
        return (this.flags & TrunBox.DATA_OFFSET_AVAILABLE) != 0;
    };
    prototype.isSampleCompositionOffsetAvailable = function() {
        return (this.flags & TrunBox.SAMPLE_COMPOSITION_OFFSET_AVAILABLE) != 0;
    };
    prototype.isSampleFlagsAvailable = function() {
        return (this.flags & TrunBox.SAMPLE_FLAGS_AVAILABLE) != 0;
    };
    prototype.isSampleSizeAvailable = function() {
        return (this.flags & TrunBox.SAMPLE_SIZE_AVAILABLE) != 0;
    };
    prototype.isSampleDurationAvailable = function() {
        return (this.flags & TrunBox.SAMPLE_DURATION_AVAILABLE) != 0;
    };
    prototype.isFirstSampleFlagsAvailable = function() {
        return (this.flags & TrunBox.FIRST_SAMPLE_FLAGS_AVAILABLE) != 0;
    };
    constructor.flagsGetSampleDependsOn = function(flags) {
        return (flags >> 6) & 3;
    };
    constructor.flagsGetSampleIsDependedOn = function(flags) {
        return (flags >> 8) & 3;
    };
    constructor.flagsGetSampleHasRedundancy = function(flags) {
        return (flags >> 10) & 3;
    };
    constructor.flagsGetSamplePaddingValue = function(flags) {
        return (flags >> 12) & 7;
    };
    constructor.flagsGetSampleIsDifferentSample = function(flags) {
        return (flags >> 15) & 1;
    };
    constructor.flagsGetSampleDegradationPriority = function(flags) {
        return (flags >> 16) & 65535;
    };
    constructor.createTrunBox = function() {
        return new TrunBox(new Header(TrunBox.fourcc()));
    };
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        if (this.isSampleFlagsAvailable() && this.isFirstSampleFlagsAvailable()) 
             throw new RuntimeException("Broken stream");
        this.sampleCount = input.getInt();
        if (this.isDataOffsetAvailable()) 
            this.dataOffset = input.getInt();
        if (this.isFirstSampleFlagsAvailable()) 
            this.firstSampleFlags = input.getInt();
        if (this.isSampleDurationAvailable()) 
            this.sampleDuration = new Int32Array(this.sampleCount);
        if (this.isSampleSizeAvailable()) 
            this.sampleSize = new Int32Array(this.sampleCount);
        if (this.isSampleFlagsAvailable()) 
            this.sampleFlags = new Int32Array(this.sampleCount);
        if (this.isSampleCompositionOffsetAvailable()) 
            this.sampleCompositionOffset = new Int32Array(this.sampleCount);
        for (var i = 0; i < this.sampleCount; i++) {
            if (this.isSampleDurationAvailable()) 
                this.sampleDuration[i] = input.getInt();
            if (this.isSampleSizeAvailable()) 
                this.sampleSize[i] = input.getInt();
            if (this.isSampleFlagsAvailable()) 
                this.sampleFlags[i] = input.getInt();
            if (this.isSampleCompositionOffsetAvailable()) 
                this.sampleCompositionOffset[i] = input.getInt();
        }
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        out.putInt(this.sampleCount);
        if (this.isDataOffsetAvailable()) 
            out.putInt(this.dataOffset);
        if (this.isFirstSampleFlagsAvailable()) 
            out.putInt(this.firstSampleFlags);
        for (var i = 0; i < this.sampleCount; i++) {
            if (this.isSampleDurationAvailable()) 
                out.putInt(this.sampleDuration[i]);
            if (this.isSampleSizeAvailable()) 
                out.putInt(this.sampleSize[i]);
            if (this.isSampleFlagsAvailable()) 
                out.putInt(this.sampleFlags[i]);
            if (this.isSampleCompositionOffsetAvailable()) 
                out.putInt(this.sampleCompositionOffset[i]);
        }
    };
    prototype.getModelFields = function(model) {
        model.add("sampleCount");
        if (this.isDataOffsetAvailable()) 
            model.add("dataOffset");
        if (this.isFirstSampleFlagsAvailable()) 
            model.add("firstSampleFlags");
        if (this.isSampleDurationAvailable()) 
            model.add("sampleDuration");
        if (this.isSampleSizeAvailable()) 
            model.add("sampleSize");
        if (this.isSampleFlagsAvailable()) 
            model.add("sampleFlags");
        if (this.isSampleCompositionOffsetAvailable()) 
            model.add("sampleCompositionOffset");
    };
}, {sampleDuration: "Int32Array", sampleSize: "Int32Array", sampleFlags: "Int32Array", sampleCompositionOffset: "Int32Array", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Movie fragment header box
 *  
 *  
 *  @author The JCodec project
 *  
 */
var TrackExtendsBox = function(atom) {
    FullBox.call(this, atom);
};
TrackExtendsBox = stjs.extend(TrackExtendsBox, FullBox, [], function(constructor, prototype) {
    prototype.trackId = 0;
    prototype.defaultSampleDescriptionIndex = 0;
    prototype.defaultSampleDuration = 0;
    prototype.defaultSampleBytes = 0;
    prototype.defaultSampleFlags = 0;
    constructor.fourcc = function() {
        return "trex";
    };
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        this.trackId = input.getInt();
        this.defaultSampleDescriptionIndex = input.getInt();
        this.defaultSampleDuration = input.getInt();
        this.defaultSampleBytes = input.getInt();
        this.defaultSampleFlags = input.getInt();
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        out.putInt(this.trackId);
        out.putInt(this.defaultSampleDescriptionIndex);
        out.putInt(this.defaultSampleDuration);
        out.putInt(this.defaultSampleBytes);
        out.putInt(this.defaultSampleFlags);
    };
    prototype.getTrackId = function() {
        return this.trackId;
    };
    prototype.setTrackId = function(trackId) {
        this.trackId = trackId;
    };
    prototype.getDefaultSampleDescriptionIndex = function() {
        return this.defaultSampleDescriptionIndex;
    };
    prototype.setDefaultSampleDescriptionIndex = function(defaultSampleDescriptionIndex) {
        this.defaultSampleDescriptionIndex = defaultSampleDescriptionIndex;
    };
    prototype.getDefaultSampleDuration = function() {
        return this.defaultSampleDuration;
    };
    prototype.setDefaultSampleDuration = function(defaultSampleDuration) {
        this.defaultSampleDuration = defaultSampleDuration;
    };
    prototype.getDefaultSampleBytes = function() {
        return this.defaultSampleBytes;
    };
    prototype.setDefaultSampleBytes = function(defaultSampleBytes) {
        this.defaultSampleBytes = defaultSampleBytes;
    };
    prototype.getDefaultSampleFlags = function() {
        return this.defaultSampleFlags;
    };
    prototype.setDefaultSampleFlags = function(defaultSampleFlags) {
        this.defaultSampleFlags = defaultSampleFlags;
    };
    constructor.createTrackExtendsBox = function(trackId, sampleDescIndex, sampleFlags) {
        var trex = new TrackExtendsBox(new Header(TrackExtendsBox.fourcc()));
        trex.setTrackId(sampleDescIndex);
        trex.setDefaultSampleDescriptionIndex(sampleDescIndex);
        trex.setDefaultSampleFlags(sampleFlags);
        return trex;
    };
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A media header atom
 *  
 *  @author The JCodec project
 *  
 */
var MediaHeaderBox = function(atom) {
    FullBox.call(this, atom);
};
MediaHeaderBox = stjs.extend(MediaHeaderBox, FullBox, [], function(constructor, prototype) {
    prototype.created = 0;
    prototype.modified = 0;
    prototype.timescale = 0;
    prototype.duration = 0;
    prototype.language = 0;
    prototype.quality = 0;
    constructor.fourcc = function() {
        return "mdhd";
    };
    constructor.createMediaHeaderBox = function(timescale, duration, language, created, modified, quality) {
        var mdhd = new MediaHeaderBox(new Header(MediaHeaderBox.fourcc()));
        mdhd.timescale = timescale;
        mdhd.duration = duration;
        mdhd.language = language;
        mdhd.created = created;
        mdhd.modified = modified;
        mdhd.quality = quality;
        return mdhd;
    };
    prototype.getTimescale = function() {
        return this.timescale;
    };
    prototype.getDuration = function() {
        return this.duration;
    };
    prototype.getCreated = function() {
        return this.created;
    };
    prototype.getModified = function() {
        return this.modified;
    };
    prototype.getLanguage = function() {
        return this.language;
    };
    prototype.getQuality = function() {
        return this.quality;
    };
    prototype.setDuration = function(duration) {
        this.duration = duration;
    };
    prototype.setTimescale = function(timescale) {
        this.timescale = timescale;
    };
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        if (this.version == 0) {
            this.created = TimeUtil.fromMovTime(input.getInt());
            this.modified = TimeUtil.fromMovTime(input.getInt());
            this.timescale = input.getInt();
            this.duration = input.getInt();
        } else if (this.version == 1) {
            this.created = TimeUtil.fromMovTime(((input.getLong()) | 0));
            this.modified = TimeUtil.fromMovTime(((input.getLong()) | 0));
            this.timescale = input.getInt();
            this.duration = input.getLong();
        } else {
             throw new RuntimeException("Unsupported version");
        }
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        out.putInt(TimeUtil.toMovTime(this.created));
        out.putInt(TimeUtil.toMovTime(this.modified));
        out.putInt(this.timescale);
        out.putInt(((this.duration) | 0));
        out.putShort(((this.language) << 16 >> 16));
        out.putShort(((this.quality) << 16 >> 16));
    };
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var GenericMediaInfoBox = function(atom) {
    FullBox.call(this, atom);
};
GenericMediaInfoBox = stjs.extend(GenericMediaInfoBox, FullBox, [], function(constructor, prototype) {
    prototype.graphicsMode = 0;
    prototype.rOpColor = 0;
    prototype.gOpColor = 0;
    prototype.bOpColor = 0;
    prototype.balance = 0;
    constructor.fourcc = function() {
        return "gmin";
    };
    constructor.createGenericMediaInfoBox = function() {
        return new GenericMediaInfoBox(new Header(GenericMediaInfoBox.fourcc()));
    };
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        this.graphicsMode = input.getShort();
        this.rOpColor = input.getShort();
        this.gOpColor = input.getShort();
        this.bOpColor = input.getShort();
        this.balance = input.getShort();
        input.getShort();
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        out.putShort(this.graphicsMode);
        out.putShort(this.rOpColor);
        out.putShort(this.gOpColor);
        out.putShort(this.bOpColor);
        out.putShort(this.balance);
        out.putShort(((0) << 16 >> 16));
    };
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Sound media header
 *  
 *  @author The JCodec project
 *  
 */
var SoundMediaHeaderBox = function(atom) {
    FullBox.call(this, atom);
};
SoundMediaHeaderBox = stjs.extend(SoundMediaHeaderBox, FullBox, [], function(constructor, prototype) {
    prototype.balance = 0;
    constructor.fourcc = function() {
        return "smhd";
    };
    constructor.createSoundMediaHeaderBox = function() {
        return new SoundMediaHeaderBox(new Header(SoundMediaHeaderBox.fourcc()));
    };
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        this.balance = input.getShort();
        input.getShort();
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        out.putShort(this.balance);
        out.putShort(((0) << 16 >> 16));
    };
    prototype.getBalance = function() {
        return this.balance;
    };
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var ClearApertureBox = function(atom) {
    FullBox.call(this, atom);
};
ClearApertureBox = stjs.extend(ClearApertureBox, FullBox, [], function(constructor, prototype) {
    constructor.CLEF = "clef";
    prototype.width = 0.0;
    prototype.height = 0.0;
    constructor.createClearApertureBox = function(width, height) {
        var clef = new ClearApertureBox(new Header(ClearApertureBox.CLEF));
        clef.width = width;
        clef.height = height;
        return clef;
    };
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        this.width = input.getInt() / 65536.0;
        this.height = input.getInt() / 65536.0;
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        out.putInt(stjs.trunc((this.width * 65536.0)));
        out.putInt(stjs.trunc((this.height * 65536.0)));
    };
    prototype.getWidth = function() {
        return this.width;
    };
    prototype.getHeight = function() {
        return this.height;
    };
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Movie fragment header box
 *  
 *  @author The JCodec project
 *  
 */
var MovieExtendsHeaderBox = function(atom) {
    FullBox.call(this, atom);
};
MovieExtendsHeaderBox = stjs.extend(MovieExtendsHeaderBox, FullBox, [], function(constructor, prototype) {
    prototype.fragmentDuration = 0;
    constructor.fourcc = function() {
        return "mehd";
    };
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        this.fragmentDuration = input.getInt();
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        out.putInt(this.fragmentDuration);
    };
    prototype.getFragmentDuration = function() {
        return this.fragmentDuration;
    };
    prototype.setFragmentDuration = function(fragmentDuration) {
        this.fragmentDuration = fragmentDuration;
    };
    constructor.createMovieExtendsHeaderBox = function() {
        return new MovieExtendsHeaderBox(new Header(MovieExtendsHeaderBox.fourcc()));
    };
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  A box to hold chunk offsets
 *  
 *  @author The JCodec project
 *  
 */
var ChunkOffsetsBox = function(atom) {
    FullBox.call(this, atom);
};
ChunkOffsetsBox = stjs.extend(ChunkOffsetsBox, FullBox, [], function(constructor, prototype) {
    prototype.chunkOffsets = null;
    constructor.fourcc = function() {
        return "stco";
    };
    constructor.createChunkOffsetsBox = function(chunkOffsets) {
        var stco = new ChunkOffsetsBox(new Header(ChunkOffsetsBox.fourcc()));
        stco.chunkOffsets = chunkOffsets;
        return stco;
    };
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        var length = input.getInt();
        this.chunkOffsets = Array(length);
        for (var i = 0; i < length; i++) {
            this.chunkOffsets[i] = input.getInt() & 4294967295;
        }
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        out.putInt(this.chunkOffsets.length);
        for (var i = 0; i < this.chunkOffsets.length; i++) {
            var offset = this.chunkOffsets[i];
            out.putInt(((offset) | 0));
        }
    };
    prototype.getChunkOffsets = function() {
        return this.chunkOffsets;
    };
    prototype.setChunkOffsets = function(chunkOffsets) {
        this.chunkOffsets = chunkOffsets;
    };
}, {chunkOffsets: "Array", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  @author The JCodec project
 */
var DataRefBox = function(atom) {
    NodeBox.call(this, atom);
};
DataRefBox = stjs.extend(DataRefBox, NodeBox, [], function(constructor, prototype) {
    constructor.fourcc = function() {
        return "dref";
    };
    constructor.createDataRefBox = function() {
        return new DataRefBox(new Header(DataRefBox.fourcc()));
    };
    prototype.parse = function(input) {
        input.getInt();
        input.getInt();
        NodeBox.prototype.parse.call(this, input);
    };
    prototype.doWrite = function(out) {
        out.putInt(0);
        out.putInt(this.boxes.size());
        NodeBox.prototype.doWrite.call(this, out);
    };
}, {boxes: {name: "List", arguments: ["Box"]}, factory: "IBoxFactory", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Creates MP4 file out of a set of samples
 *  
 *  @author The JCodec project
 *  
 */
var SampleEntry = function(header) {
    NodeBox.call(this, header);
};
SampleEntry = stjs.extend(SampleEntry, NodeBox, [], function(constructor, prototype) {
    prototype.drefInd = 0;
    prototype.parse = function(input) {
        input.getInt();
        input.getShort();
        this.drefInd = input.getShort();
    };
    prototype.parseExtensions = function(input) {
        NodeBox.prototype.parse.call(this, input);
    };
    prototype.doWrite = function(out) {
        out.putArr(new Int8Array([0, 0, 0, 0, 0, 0]));
        out.putShort(this.drefInd);
    };
    prototype.writeExtensions = function(out) {
        NodeBox.prototype.doWrite.call(this, out);
    };
    prototype.getDrefInd = function() {
        return this.drefInd;
    };
    prototype.setDrefInd = function(ind) {
        this.drefInd = ind;
    };
    prototype.setMediaType = function(mediaType) {
        this.header = new Header(mediaType);
    };
}, {boxes: {name: "List", arguments: ["Box"]}, factory: "IBoxFactory", header: "Header"}, {});
var BoxUtil = function() {};
BoxUtil = stjs.extend(BoxUtil, null, [], function(constructor, prototype) {
    constructor.parseBox = function(input, childAtom, factory) {
        var box = factory.newBox(childAtom);
        if (childAtom.getBodySize() < Box.MAX_BOX_SIZE) {
            box.parse(input);
            return box;
        } else {
            return new Box.LeafBox(Header.createHeader("free", 8));
        }
    };
    constructor.parseChildBox = function(input, factory) {
        var fork = input.duplicate();
         while (input.remaining() >= 4 && fork.getInt() == 0)
            input.getInt();
        if (input.remaining() < 4) 
            return null;
        var childAtom = Header.read(input);
        if (childAtom != null && input.remaining() >= childAtom.getBodySize()) 
            return BoxUtil.parseBox(NIOUtils.read(input, ((childAtom.getBodySize()) | 0)), childAtom, factory);
         else 
            return null;
    };
    constructor.as = function(class1, box) {
        try {
            var res = class1.getConstructor(Header).newInstance(box.getHeader());
            res.parse(box.getData().duplicate());
            return res;
        }catch (e) {
             throw new RuntimeException(e);
        }
    };
    constructor.containsBox = function(box, path) {
        var b = NodeBox.findFirstPath(box, Box, [path]);
        return b != null;
    };
    constructor.containsBox2 = function(box, path1, path2) {
        var b = NodeBox.findFirstPath(box, Box, [path1, path2]);
        return b != null;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Wave extension to audio sample entry
 *  
 *  @author The JCodec project
 *  
 */
var WaveExtension = function(atom) {
    NodeBox.call(this, atom);
};
WaveExtension = stjs.extend(WaveExtension, NodeBox, [], function(constructor, prototype) {
    constructor.fourcc = function() {
        return "wave";
    };
}, {boxes: {name: "List", arguments: ["Box"]}, factory: "IBoxFactory", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 * 
 *  @author The JCodec project
 */
var SampleDescriptionBox = function(header) {
    NodeBox.call(this, header);
};
SampleDescriptionBox = stjs.extend(SampleDescriptionBox, NodeBox, [], function(constructor, prototype) {
    constructor.fourcc = function() {
        return "stsd";
    };
    constructor.createSampleDescriptionBox = function(sampleEntries) {
        var box = new SampleDescriptionBox(new Header(SampleDescriptionBox.fourcc()));
        for (var i = 0; i < sampleEntries.length; i++) {
            var e = sampleEntries[i];
            box.boxes.add(e);
        }
        return box;
    };
    prototype.parse = function(input) {
        input.getInt();
        input.getInt();
        NodeBox.prototype.parse.call(this, input);
    };
    prototype.doWrite = function(out) {
        out.putInt(0);
        out.putInt(this.boxes.size());
        NodeBox.prototype.doWrite.call(this, out);
    };
}, {boxes: {name: "List", arguments: ["Box"]}, factory: "IBoxFactory", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MovieExtendsBox = function(atom) {
    NodeBox.call(this, atom);
};
MovieExtendsBox = stjs.extend(MovieExtendsBox, NodeBox, [], function(constructor, prototype) {
    constructor.fourcc = function() {
        return "mvex";
    };
    constructor.createMovieExtendsBox = function() {
        return new MovieExtendsBox(new Header(MovieExtendsBox.fourcc()));
    };
}, {boxes: {name: "List", arguments: ["Box"]}, factory: "IBoxFactory", header: "Header"}, {});
var VideoBoxes = function() {
    Boxes.call(this);
    this.mappings.put(PixelAspectExt.fourcc(), PixelAspectExt);
    this.mappings.put(AvcCBox.fourcc(), AvcCBox);
    this.mappings.put(ColorExtension.fourcc(), ColorExtension);
    this.mappings.put(GamaExtension.fourcc(), GamaExtension);
    this.mappings.put(CleanApertureExtension.fourcc(), CleanApertureExtension);
    this.mappings.put(FielExtension.fourcc(), FielExtension);
};
VideoBoxes = stjs.extend(VideoBoxes, Boxes, [], null, {mappings: {name: "Map", arguments: [null, {name: "Class", arguments: ["Object"]}]}}, {});
var WaveExtBoxes = function() {
    Boxes.call(this);
    this.mappings.put(FormatBox.fourcc(), FormatBox);
    this.mappings.put(EndianBox.fourcc(), EndianBox);
};
WaveExtBoxes = stjs.extend(WaveExtBoxes, Boxes, [], null, {mappings: {name: "Map", arguments: [null, {name: "Class", arguments: ["Object"]}]}}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license. 
 *  
 *  @author in-somnia
 */
var SyntacticElements = function(config) {
    this.config = config;
    this.pce = new PCE();
    this.elements = Array(4 * SyntaxConstants.MAX_ELEMENTS);
    this.cces = Array(SyntaxConstants.MAX_ELEMENTS);
    this.dses = Array(SyntaxConstants.MAX_ELEMENTS);
    this.fils = Array(SyntaxConstants.MAX_ELEMENTS);
    this.startNewFrame();
};
SyntacticElements = stjs.extend(SyntacticElements, null, [SyntaxConstants], function(constructor, prototype) {
    prototype.config = null;
    prototype.sbrPresent = false;
    prototype.psPresent = false;
    prototype.bitsRead = 0;
    prototype.pce = null;
    prototype.elements = null;
    prototype.cces = null;
    prototype.dses = null;
    prototype.fils = null;
    prototype.curElem = 0;
    prototype.curCCE = 0;
    prototype.curDSE = 0;
    prototype.curFIL = 0;
    prototype.data = null;
    prototype.startNewFrame = function() {
        this.curElem = 0;
        this.curCCE = 0;
        this.curDSE = 0;
        this.curFIL = 0;
        this.sbrPresent = false;
        this.psPresent = false;
        this.bitsRead = 0;
    };
    prototype.decode = function(_in) {
        var start = _in.getPosition();
        var type;
        var prev = null;
        var content = true;
        if (!this.config.getProfile().isErrorResilientProfile()) {
             while (content && (type = _in.readBits(3)) != SyntaxConstants.ELEMENT_END){
                switch (type) {
                    case SyntaxConstants.ELEMENT_SCE:
                    case SyntaxConstants.ELEMENT_LFE:
                        SyntaxConstants.LOGGER.finest("SCE");
                        prev = this.decodeSCE_LFE(_in);
                        break;
                    case SyntaxConstants.ELEMENT_CPE:
                        SyntaxConstants.LOGGER.finest("CPE");
                        prev = this.decodeCPE(_in);
                        break;
                    case SyntaxConstants.ELEMENT_CCE:
                        SyntaxConstants.LOGGER.finest("CCE");
                        this.decodeCCE(_in);
                        prev = null;
                        break;
                    case SyntaxConstants.ELEMENT_DSE:
                        SyntaxConstants.LOGGER.finest("DSE");
                        this.decodeDSE(_in);
                        prev = null;
                        break;
                    case SyntaxConstants.ELEMENT_PCE:
                        SyntaxConstants.LOGGER.finest("PCE");
                        this.decodePCE(_in);
                        prev = null;
                        break;
                    case SyntaxConstants.ELEMENT_FIL:
                        SyntaxConstants.LOGGER.finest("FIL");
                        this.decodeFIL(_in, prev);
                        prev = null;
                        break;
                }
            }
            SyntaxConstants.LOGGER.finest("END");
            content = false;
            prev = null;
        } else {
            var cc = this.config.getChannelConfiguration();
            if (ChannelConfiguration.CHANNEL_CONFIG_MONO == cc) {
                this.decodeSCE_LFE(_in);
            } else if (ChannelConfiguration.CHANNEL_CONFIG_STEREO == cc) {
                this.decodeCPE(_in);
            } else if (ChannelConfiguration.CHANNEL_CONFIG_STEREO_PLUS_CENTER == cc) {
                this.decodeSCE_LFE(_in);
                this.decodeCPE(_in);
            } else if (ChannelConfiguration.CHANNEL_CONFIG_STEREO_PLUS_CENTER_PLUS_REAR_MONO == cc) {
                this.decodeSCE_LFE(_in);
                this.decodeCPE(_in);
                this.decodeSCE_LFE(_in);
            } else if (ChannelConfiguration.CHANNEL_CONFIG_FIVE == cc) {
                this.decodeSCE_LFE(_in);
                this.decodeCPE(_in);
                this.decodeCPE(_in);
            } else if (ChannelConfiguration.CHANNEL_CONFIG_FIVE_PLUS_ONE == cc) {
                this.decodeSCE_LFE(_in);
                this.decodeCPE(_in);
                this.decodeCPE(_in);
                this.decodeSCE_LFE(_in);
            } else if (ChannelConfiguration.CHANNEL_CONFIG_SEVEN_PLUS_ONE == cc) {
                this.decodeSCE_LFE(_in);
                this.decodeCPE(_in);
                this.decodeCPE(_in);
                this.decodeCPE(_in);
                this.decodeSCE_LFE(_in);
            } else {
                 throw new AACException("unsupported channel configuration for error resilience: " + cc);
            }
        }
        _in.byteAlign();
        this.bitsRead = _in.getPosition() - start;
    };
    prototype.decodeSCE_LFE = function(_in) {
        if (this.elements[this.curElem] == null) 
            this.elements[this.curElem] = new SCE_LFE(this.config.getFrameLength());
        (this.elements[this.curElem]).decode(_in, this.config);
        this.curElem++;
        return this.elements[this.curElem - 1];
    };
    prototype.decodeCPE = function(_in) {
        if (this.elements[this.curElem] == null) 
            this.elements[this.curElem] = new CPE(this.config.getFrameLength());
        (this.elements[this.curElem]).decode(_in, this.config);
        this.curElem++;
        return this.elements[this.curElem - 1];
    };
    prototype.decodeCCE = function(_in) {
        if (this.curCCE == SyntaxConstants.MAX_ELEMENTS) 
             throw new AACException("too much CCE elements");
        if (this.cces[this.curCCE] == null) 
            this.cces[this.curCCE] = new CCE(this.config.getFrameLength());
        this.cces[this.curCCE].decode(_in, this.config);
        this.curCCE++;
    };
    prototype.decodeDSE = function(_in) {
        if (this.curDSE == SyntaxConstants.MAX_ELEMENTS) 
             throw new AACException("too much CCE elements");
        if (this.dses[this.curDSE] == null) 
            this.dses[this.curDSE] = new DSE();
        this.dses[this.curDSE].decode(_in);
        this.curDSE++;
    };
    prototype.decodePCE = function(_in) {
        this.pce.decode(_in);
        this.config.setProfile(this.pce.getProfile());
        this.config.setSampleFrequency(this.pce.getSampleFrequency());
        this.config.setChannelConfiguration(ChannelConfiguration.forInt(this.pce.getChannelCount()));
    };
    prototype.decodeFIL = function(_in, prev) {
        if (this.curFIL == SyntaxConstants.MAX_ELEMENTS) 
             throw new AACException("too much FIL elements");
        if (this.fils[this.curFIL] == null) 
            this.fils[this.curFIL] = new FIL(this.config.isSBRDownSampled());
        this.fils[this.curFIL].decode(_in, prev, this.config.getSampleFrequency(), this.config.isSBREnabled(), this.config.isSmallFrameUsed());
        this.curFIL++;
        if (prev != null && prev.isSBRPresent()) {
            this.sbrPresent = true;
            if (!this.psPresent && prev.getSBR().isPSUsed()) 
                this.psPresent = true;
        }
    };
    prototype.process = function(filterBank) {
        var profile = this.config.getProfile();
        var sf = this.config.getSampleFrequency();
        var chs = this.config.getChannelConfiguration().getChannelCount();
        if (chs == 1 && this.psPresent) 
            chs++;
        var mult = this.sbrPresent ? 2 : 1;
        if (this.data == null || chs != this.data.length || (mult * this.config.getFrameLength()) != this.data[0].length) 
            this.data = Array.apply(null, Array(chs)).map(function() {
                return new Float32Array(mult * this.config.getFrameLength());
            });
        var channel = 0;
        var e;
        var scelfe;
        var cpe;
        for (var i = 0; i < this.elements.length && channel < chs; i++) {
            e = this.elements[i];
            if (e == null) 
                continue;
            if (stjs.isInstanceOf(e.constructor, SCE_LFE)) {
                scelfe = e;
                channel += this.processSingle(scelfe, filterBank, channel, profile, sf);
            } else if (stjs.isInstanceOf(e.constructor, CPE)) {
                cpe = e;
                this.processPair(cpe, filterBank, channel, profile, sf);
                channel += 2;
            } else if (stjs.isInstanceOf(e.constructor, CCE)) {
                (e).process();
                channel++;
            }
        }
    };
    prototype.processSingle = function(scelfe, filterBank, channel, profile, sf) {
        var ics = scelfe.getICStream();
        var info = ics.getInfo();
        var ltp = info.getLTPrediction1();
        var elementID = scelfe.getElementInstanceTag();
        var iqData = ics.getInvQuantData();
        if (profile.equals(Profile.AAC_MAIN) && info.isICPredictionPresent()) 
            info.getICPrediction().process(ics, iqData, sf);
        if (ICSInfo.LTPrediction.isLTPProfile(profile) && info.isLTPrediction1Present()) 
            ltp.process(ics, iqData, filterBank, sf);
        this.processDependentCoupling(false, elementID, CCE.BEFORE_TNS, iqData, null);
        if (ics.isTNSDataPresent()) 
            ics.getTNS().process(ics, iqData, sf, false);
        this.processDependentCoupling(false, elementID, CCE.AFTER_TNS, iqData, null);
        filterBank.process(info.getWindowSequence(), info.getWindowShape(ICSInfo.CURRENT), info.getWindowShape(ICSInfo.PREVIOUS), iqData, this.data[channel], channel);
        if (ICSInfo.LTPrediction.isLTPProfile(profile)) 
            ltp.updateState(this.data[channel], filterBank.getOverlap(channel), profile);
        this.processIndependentCoupling(false, elementID, this.data[channel], null);
        if (ics.isGainControlPresent()) 
            ics.getGainControl().process(iqData, info.getWindowShape(ICSInfo.CURRENT), info.getWindowShape(ICSInfo.PREVIOUS), info.getWindowSequence());
        var chs = 1;
        if (this.sbrPresent && this.config.isSBREnabled()) {
            if (this.data[channel].length == this.config.getFrameLength()) 
                SyntaxConstants.LOGGER.log(Level.WARNING, "SBR data present, but buffer has normal size!");
            var sbr = scelfe.getSBR();
            if (sbr.isPSUsed()) {
                chs = 2;
                scelfe.getSBR()._process(this.data[channel], this.data[channel + 1], false);
            } else 
                scelfe.getSBR().process(this.data[channel], false);
        }
        return chs;
    };
    prototype.processPair = function(cpe, filterBank, channel, profile, sf) {
        var ics1 = cpe.getLeftChannel();
        var ics2 = cpe.getRightChannel();
        var info1 = ics1.getInfo();
        var info2 = ics2.getInfo();
        var ltp1 = info1.getLTPrediction1();
        var ltp2 = cpe.isCommonWindow() ? info1.getLTPrediction2() : info2.getLTPrediction1();
        var elementID = cpe.getElementInstanceTag();
        var iqData1 = ics1.getInvQuantData();
        var iqData2 = ics2.getInvQuantData();
        if (cpe.isCommonWindow() && cpe.isMSMaskPresent()) 
            MS.process(cpe, iqData1, iqData2);
        if (profile.equals(Profile.AAC_MAIN)) {
            if (info1.isICPredictionPresent()) 
                info1.getICPrediction().process(ics1, iqData1, sf);
            if (info2.isICPredictionPresent()) 
                info2.getICPrediction().process(ics2, iqData2, sf);
        }
        IS.process(cpe, iqData1, iqData2);
        if (ICSInfo.LTPrediction.isLTPProfile(profile)) {
            if (info1.isLTPrediction1Present()) 
                ltp1.process(ics1, iqData1, filterBank, sf);
            if (cpe.isCommonWindow() && info1.isLTPrediction2Present()) 
                ltp2.process(ics2, iqData2, filterBank, sf);
             else if (info2.isLTPrediction1Present()) 
                ltp2.process(ics2, iqData2, filterBank, sf);
        }
        this.processDependentCoupling(true, elementID, CCE.BEFORE_TNS, iqData1, iqData2);
        if (ics1.isTNSDataPresent()) 
            ics1.getTNS().process(ics1, iqData1, sf, false);
        if (ics2.isTNSDataPresent()) 
            ics2.getTNS().process(ics2, iqData2, sf, false);
        this.processDependentCoupling(true, elementID, CCE.AFTER_TNS, iqData1, iqData2);
        filterBank.process(info1.getWindowSequence(), info1.getWindowShape(ICSInfo.CURRENT), info1.getWindowShape(ICSInfo.PREVIOUS), iqData1, this.data[channel], channel);
        filterBank.process(info2.getWindowSequence(), info2.getWindowShape(ICSInfo.CURRENT), info2.getWindowShape(ICSInfo.PREVIOUS), iqData2, this.data[channel + 1], channel + 1);
        if (ICSInfo.LTPrediction.isLTPProfile(profile)) {
            ltp1.updateState(this.data[channel], filterBank.getOverlap(channel), profile);
            ltp2.updateState(this.data[channel + 1], filterBank.getOverlap(channel + 1), profile);
        }
        this.processIndependentCoupling(true, elementID, this.data[channel], this.data[channel + 1]);
        if (ics1.isGainControlPresent()) 
            ics1.getGainControl().process(iqData1, info1.getWindowShape(ICSInfo.CURRENT), info1.getWindowShape(ICSInfo.PREVIOUS), info1.getWindowSequence());
        if (ics2.isGainControlPresent()) 
            ics2.getGainControl().process(iqData2, info2.getWindowShape(ICSInfo.CURRENT), info2.getWindowShape(ICSInfo.PREVIOUS), info2.getWindowSequence());
        if (this.sbrPresent && this.config.isSBREnabled()) {
            if (this.data[channel].length == this.config.getFrameLength()) 
                SyntaxConstants.LOGGER.log(Level.WARNING, "SBR data present, but buffer has normal size!");
            cpe.getSBR()._process(this.data[channel], this.data[channel + 1], false);
        }
    };
    prototype.processIndependentCoupling = function(channelPair, elementID, data1, data2) {
        var index, c, chSelect;
        var cce;
        for (var i = 0; i < this.cces.length; i++) {
            cce = this.cces[i];
            index = 0;
            if (cce != null && cce.getCouplingPoint() == CCE.AFTER_IMDCT) {
                for (c = 0; c <= cce.getCoupledCount(); c++) {
                    chSelect = cce.getCHSelect(c);
                    if (cce.isChannelPair(c) == channelPair && cce.getIDSelect(c) == elementID) {
                        if (chSelect != 1) {
                            cce.applyIndependentCoupling(index, data1);
                            if (chSelect != 0) 
                                index++;
                        }
                        if (chSelect != 2) {
                            cce.applyIndependentCoupling(index, data2);
                            index++;
                        }
                    } else 
                        index += 1 + ((chSelect == 3) ? 1 : 0);
                }
            }
        }
    };
    prototype.processDependentCoupling = function(channelPair, elementID, couplingPoint, data1, data2) {
        var index, c, chSelect;
        var cce;
        for (var i = 0; i < this.cces.length; i++) {
            cce = this.cces[i];
            index = 0;
            if (cce != null && cce.getCouplingPoint() == couplingPoint) {
                for (c = 0; c <= cce.getCoupledCount(); c++) {
                    chSelect = cce.getCHSelect(c);
                    if (cce.isChannelPair(c) == channelPair && cce.getIDSelect(c) == elementID) {
                        if (chSelect != 1) {
                            cce.applyDependentCoupling(index, data1);
                            if (chSelect != 0) 
                                index++;
                        }
                        if (chSelect != 2) {
                            cce.applyDependentCoupling(index, data2);
                            index++;
                        }
                    } else 
                        index += 1 + ((chSelect == 3) ? 1 : 0);
                }
            }
        }
    };
    prototype.sendToOutput = function(buffer) {
        var be = buffer.isBigEndian();
        var chs = this.data.length;
        var mult = (this.sbrPresent && this.config.isSBREnabled()) ? 2 : 1;
        var length = mult * this.config.getFrameLength();
        var freq = mult * this.config.getSampleFrequency().getFrequency();
        var b = buffer.getData();
        if (b.length != chs * length * 2) 
            b = new Int8Array(chs * length * 2);
        var cur;
        var i, j, off;
        var s;
        for (i = 0; i < chs; i++) {
            cur = this.data[i];
            for (j = 0; j < length; j++) {
                s = ((Math.max(Math.min(Math.round(cur[j]), Short.MAX_VALUE), Short.MIN_VALUE)) << 16 >> 16);
                off = (j * chs + i) * 2;
                if (be) {
                    b[off] = (((s >> 8) & SyntaxConstants.BYTE_MASK) << 24 >> 24);
                    b[off + 1] = ((s & SyntaxConstants.BYTE_MASK) << 24 >> 24);
                } else {
                    b[off + 1] = (((s >> 8) & SyntaxConstants.BYTE_MASK) << 24 >> 24);
                    b[off] = ((s & SyntaxConstants.BYTE_MASK) << 24 >> 24);
                }
            }
        }
        buffer.setData(b, freq, chs, 16, this.bitsRead);
    };
}, {config: "AACDecoderConfig", pce: "PCE", elements: "Array", cces: "Array", dses: "Array", fils: "Array", data: "Array", LOGGER: "Logger"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var WaveAudioDescriptor = function(ul) {
    GenericSoundEssenceDescriptor.call(this, ul);
};
WaveAudioDescriptor = stjs.extend(WaveAudioDescriptor, GenericSoundEssenceDescriptor, [], function(constructor, prototype) {
    prototype.blockAlign = 0;
    prototype.sequenceOffset = 0;
    prototype.avgBps = 0;
    prototype.channelAssignment = null;
    prototype.peakEnvelopeVersion = 0;
    prototype.peakEnvelopeFormat = 0;
    prototype.pointsPerPeakValue = 0;
    prototype.peakEnvelopeBlockSize = 0;
    prototype.peakChannels = 0;
    prototype.peakFrames = 0;
    prototype.peakOfPeaksPosition = null;
    prototype.peakEnvelopeTimestamp = null;
    prototype.peakEnvelopeData = null;
    prototype.read = function(tags) {
        GenericSoundEssenceDescriptor.prototype.read.call(this, tags);
        for (var it = tags.entrySet().iterator(); it.hasNext(); ) {
            var entry = it.next();
            var _bb = entry.getValue();
            switch (entry.getKey()) {
                case 15626:
                    this.blockAlign = _bb.getShort();
                    break;
                case 15627:
                    this.sequenceOffset = _bb.get();
                    break;
                case 15625:
                    this.avgBps = _bb.getInt();
                    break;
                case 15666:
                    this.channelAssignment = UL.read(_bb);
                    break;
                case 15657:
                    this.peakEnvelopeVersion = _bb.getInt();
                    break;
                case 15658:
                    this.peakEnvelopeFormat = _bb.getInt();
                    break;
                case 15659:
                    this.pointsPerPeakValue = _bb.getInt();
                    break;
                case 15660:
                    this.peakEnvelopeBlockSize = _bb.getInt();
                    break;
                case 15661:
                    this.peakChannels = _bb.getInt();
                    break;
                case 15662:
                    this.peakFrames = _bb.getInt();
                    break;
                case 15663:
                    this.peakOfPeaksPosition = _bb;
                    break;
                case 15664:
                    this.peakEnvelopeTimestamp = _bb;
                    break;
                case 15665:
                    this.peakEnvelopeData = _bb;
                    break;
                default:
                    System.out.println(String.format("Unknown tag [ " + this.ul + "]: %04x", entry.getKey()));
                    continue;
            }
            it.remove();
        }
    };
    prototype.getBlockAlign = function() {
        return this.blockAlign;
    };
    prototype.getSequenceOffset = function() {
        return this.sequenceOffset;
    };
    prototype.getAvgBps = function() {
        return this.avgBps;
    };
    prototype.getChannelAssignment = function() {
        return this.channelAssignment;
    };
    prototype.getPeakEnvelopeVersion = function() {
        return this.peakEnvelopeVersion;
    };
    prototype.getPeakEnvelopeFormat = function() {
        return this.peakEnvelopeFormat;
    };
    prototype.getPointsPerPeakValue = function() {
        return this.pointsPerPeakValue;
    };
    prototype.getPeakEnvelopeBlockSize = function() {
        return this.peakEnvelopeBlockSize;
    };
    prototype.getPeakChannels = function() {
        return this.peakChannels;
    };
    prototype.getPeakFrames = function() {
        return this.peakFrames;
    };
    prototype.getPeakOfPeaksPosition = function() {
        return this.peakOfPeaksPosition;
    };
    prototype.getPeakEnvelopeTimestamp = function() {
        return this.peakEnvelopeTimestamp;
    };
    prototype.getPeakEnvelopeData = function() {
        return this.peakEnvelopeData;
    };
}, {channelAssignment: "UL", peakOfPeaksPosition: "ByteBuffer", peakEnvelopeTimestamp: "ByteBuffer", peakEnvelopeData: "ByteBuffer", audioSamplingRate: "Rational", soundEssenceCompression: "UL", sampleRate: "Rational", essenceContainer: "UL", codec: "UL", locators: "Array", subDescriptors: "Array", generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var CDCIEssenceDescriptor = function(ul) {
    GenericPictureEssenceDescriptor.call(this, ul);
};
CDCIEssenceDescriptor = stjs.extend(CDCIEssenceDescriptor, GenericPictureEssenceDescriptor, [], function(constructor, prototype) {
    prototype.componentDepth = 0;
    prototype.horizontalSubsampling = 0;
    prototype.verticalSubsampling = 0;
    prototype.colorSiting = 0;
    prototype.reversedByteOrder = 0;
    prototype.paddingBits = 0;
    prototype.alphaSampleDepth = 0;
    prototype.blackRefLevel = 0;
    prototype.whiteReflevel = 0;
    prototype.colorRange = 0;
    prototype.read = function(tags) {
        GenericPictureEssenceDescriptor.prototype.read.call(this, tags);
        for (var it = tags.entrySet().iterator(); it.hasNext(); ) {
            var entry = it.next();
            var _bb = entry.getValue();
            switch (entry.getKey()) {
                case 13057:
                    this.componentDepth = _bb.getInt();
                    break;
                case 13058:
                    this.horizontalSubsampling = _bb.getInt();
                    break;
                case 13064:
                    this.verticalSubsampling = _bb.getInt();
                    break;
                case 13059:
                    this.colorSiting = _bb.get();
                    break;
                case 13067:
                    this.reversedByteOrder = _bb.get();
                    break;
                case 13063:
                    this.paddingBits = _bb.getShort();
                    break;
                case 13065:
                    this.alphaSampleDepth = _bb.getInt();
                    break;
                case 13060:
                    this.blackRefLevel = _bb.getInt();
                    break;
                case 13061:
                    this.whiteReflevel = _bb.getInt();
                    break;
                case 13062:
                    this.colorRange = _bb.getInt();
                    break;
                default:
                    jcodec.Logger.warn(String.format("Unknown tag [ " + this.ul + "]: %04x", entry.getKey()));
                    continue;
            }
            it.remove();
        }
    };
    prototype.getComponentDepth = function() {
        return this.componentDepth;
    };
    prototype.getHorizontalSubsampling = function() {
        return this.horizontalSubsampling;
    };
    prototype.getVerticalSubsampling = function() {
        return this.verticalSubsampling;
    };
    prototype.getColorSiting = function() {
        return this.colorSiting;
    };
    prototype.getReversedByteOrder = function() {
        return this.reversedByteOrder;
    };
    prototype.getPaddingBits = function() {
        return this.paddingBits;
    };
    prototype.getAlphaSampleDepth = function() {
        return this.alphaSampleDepth;
    };
    prototype.getBlackRefLevel = function() {
        return this.blackRefLevel;
    };
    prototype.getWhiteReflevel = function() {
        return this.whiteReflevel;
    };
    prototype.getColorRange = function() {
        return this.colorRange;
    };
}, {frameLayout: {name: "Enum", arguments: ["GenericPictureEssenceDescriptor.LayoutType"]}, aspectRatio: "Rational", videoLineMap: "Int32Array", transferCharacteristic: "UL", pictureEssenceCoding: "UL", codingEquations: "UL", colorPrimaries: "UL", sampleRate: "Rational", essenceContainer: "UL", codec: "UL", locators: "Array", subDescriptors: "Array", generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var RGBAEssenceDescriptor = function(ul) {
    GenericPictureEssenceDescriptor.call(this, ul);
};
RGBAEssenceDescriptor = stjs.extend(RGBAEssenceDescriptor, GenericPictureEssenceDescriptor, [], function(constructor, prototype) {
    prototype.componentMaxRef = 0;
    prototype.componentMinRef = 0;
    prototype.alphaMaxRef = 0;
    prototype.alphaMinRef = 0;
    prototype.scanningDirection = 0;
    prototype.pixelLayout = null;
    prototype.palette = null;
    prototype.paletteLayout = null;
    prototype.read = function(tags) {
        GenericPictureEssenceDescriptor.prototype.read.call(this, tags);
        for (var it = tags.entrySet().iterator(); it.hasNext(); ) {
            var entry = it.next();
            var _bb = entry.getValue();
            switch (entry.getKey()) {
                case 13318:
                    this.componentMaxRef = _bb.getInt();
                    break;
                case 13319:
                    this.componentMinRef = _bb.getInt();
                    break;
                case 13320:
                    this.alphaMaxRef = _bb.getInt();
                    break;
                case 13321:
                    this.alphaMinRef = _bb.getInt();
                    break;
                case 13317:
                    this.scanningDirection = _bb.get();
                    break;
                case 13313:
                    this.pixelLayout = _bb;
                    break;
                case 13315:
                    this.palette = _bb;
                    break;
                case 13316:
                    this.paletteLayout = _bb;
                    break;
                default:
                    jcodec.Logger.warn(String.format("Unknown tag [ " + this.ul + "]: %04x", entry.getKey()));
                    continue;
            }
            it.remove();
        }
    };
    prototype.getComponentMaxRef = function() {
        return this.componentMaxRef;
    };
    prototype.getComponentMinRef = function() {
        return this.componentMinRef;
    };
    prototype.getAlphaMaxRef = function() {
        return this.alphaMaxRef;
    };
    prototype.getAlphaMinRef = function() {
        return this.alphaMinRef;
    };
    prototype.getScanningDirection = function() {
        return this.scanningDirection;
    };
    prototype.getPixelLayout = function() {
        return this.pixelLayout;
    };
    prototype.getPalette = function() {
        return this.palette;
    };
    prototype.getPaletteLayout = function() {
        return this.paletteLayout;
    };
}, {pixelLayout: "ByteBuffer", palette: "ByteBuffer", paletteLayout: "ByteBuffer", frameLayout: {name: "Enum", arguments: ["GenericPictureEssenceDescriptor.LayoutType"]}, aspectRatio: "Rational", videoLineMap: "Int32Array", transferCharacteristic: "UL", pictureEssenceCoding: "UL", codingEquations: "UL", colorPrimaries: "UL", sampleRate: "Rational", essenceContainer: "UL", codec: "UL", locators: "Array", subDescriptors: "Array", generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed under FreeBSD License
 *  
 *  WebM specific muxing
 *  
 *  @author The JCodec project
 *  
 */
var MKVStreamingMuxer = function() {};
MKVStreamingMuxer = stjs.extend(MKVStreamingMuxer, null, [], function(constructor, prototype) {
    constructor.DEFAULT_TIMESCALE = 1000000000;
    constructor.TIMESCALE = 1000000;
    constructor.MULTIPLIER = stjs.trunc(MKVStreamingMuxer.DEFAULT_TIMESCALE / MKVStreamingMuxer.TIMESCALE);
    constructor.VP80_FOURCC = "avc1";
    prototype.mkvInfo = null;
    prototype.mkvTracks = null;
    prototype.mkvCues = null;
    prototype.mkvSeekHead = null;
    prototype.segmentElem = null;
    prototype.headerChunk = null;
    prototype.webmClusters = null;
    prototype.preparePacket = function(track, pkt, chunkNo, trackNo, previousClustersSize) {
        var wmc = new MKVStreamingMuxer.WebmCluster(this, track, pkt, chunkNo, trackNo, previousClustersSize);
        if (this.webmClusters == null) 
            this.webmClusters = new LinkedList();
        this.webmClusters.add(wmc);
        return wmc;
    };
    prototype.prepareHeader = function(chunks, tracks) {
        var ebmlHeader = this.muxEbmlHeader();
        this.segmentElem = MKVType.createByType(MKVType.Segment);
        this.mkvInfo = this.muxInfo(tracks);
        this.mkvTracks = this.muxTracks(tracks);
        this.mkvCues = MKVType.createByType(MKVType.Cues);
        this.mkvSeekHead = this.muxSeekHead();
        this.muxCues(tracks);
        this.segmentElem.add(this.mkvSeekHead);
        this.segmentElem.add(this.mkvInfo);
        this.segmentElem.add(this.mkvTracks);
        this.segmentElem.add(this.mkvCues);
        for (var iterator$wc = this.webmClusters.iterator(); iterator$wc.hasNext(); ) {
            var wc = iterator$wc.next();
            this.segmentElem.add(wc.c);
        }
        var header = new ArrayList();
        header.add(ebmlHeader);
        header.add(this.segmentElem);
        this.headerChunk = new MKVStreamingMuxer.HeaderSegment(header);
        return this.headerChunk;
    };
    prototype.muxEbmlHeader = function() {
        var master = MKVType.createByType(MKVType.EBML);
        MKVMuxer.createLong(master, MKVType.EBMLVersion, 1);
        MKVMuxer.createLong(master, MKVType.EBMLReadVersion, 1);
        MKVMuxer.createLong(master, MKVType.EBMLMaxIDLength, 4);
        MKVMuxer.createLong(master, MKVType.EBMLMaxSizeLength, 8);
        MKVMuxer.createString(master, MKVType.DocType, "webm");
        MKVMuxer.createLong(master, MKVType.DocTypeVersion, 2);
        MKVMuxer.createLong(master, MKVType.DocTypeReadVersion, 2);
        return master;
    };
    prototype.muxInfo = function(tracks) {
        var master = MKVType.createByType(MKVType.Info);
        MKVMuxer.createLong(master, MKVType.TimecodeScale, MKVStreamingMuxer.TIMESCALE);
        MKVMuxer.createString(master, MKVType.WritingApp, "JCodec v0.1.7");
        MKVMuxer.createString(master, MKVType.MuxingApp, "JCodec MKVStreamingMuxer v0.1.7");
        var lastCluster = this.webmClusters.get(this.webmClusters.size() - 1);
        MKVMuxer.createDouble(master, MKVType.Duration, (lastCluster.pkt.getPts() + lastCluster.pkt.getDuration()) * MKVStreamingMuxer.MULTIPLIER);
        MKVMuxer.createDate(master, MKVType.DateUTC, new jsutil.Date());
        return master;
    };
    prototype.muxTracks = function(tracks) {
        var master = MKVType.createByType(MKVType.Tracks);
        for (var i = 0; i < tracks.length; i++) {
            var track = tracks[i];
            var trackEntryElem = MKVType.createByType(MKVType.TrackEntry);
            MKVMuxer.createLong(trackEntryElem, MKVType.TrackNumber, i + 1);
            MKVMuxer.createLong(trackEntryElem, MKVType.TrackUID, i + 1);
            var codecMeta = track.getCodecMeta();
            if (MKVStreamingMuxer.VP80_FOURCC.equalsIgnoreCase(track.getCodecMeta().getFourcc())) {
                MKVMuxer.createLong(trackEntryElem, MKVType.TrackType, (1 << 24 >> 24));
                MKVMuxer.createString(trackEntryElem, MKVType.Name, "Track " + (i + 1) + " Video");
                MKVMuxer.createString(trackEntryElem, MKVType.CodecID, "V_VP8");
                MKVMuxer.createBuffer(trackEntryElem, MKVType.CodecPrivate, codecMeta.getCodecPrivate());
                if (stjs.isInstanceOf(codecMeta.constructor, VideoCodecMeta)) {
                    var vcm = codecMeta;
                    var trackVideoElem = MKVType.createByType(MKVType.Video);
                    MKVMuxer.createLong(trackVideoElem, MKVType.PixelWidth, vcm.getSize().getWidth());
                    MKVMuxer.createLong(trackVideoElem, MKVType.PixelHeight, vcm.getSize().getHeight());
                    trackEntryElem.add(trackVideoElem);
                }
            } else if ("vrbs".equalsIgnoreCase(track.getCodecMeta().getFourcc())) {
                MKVMuxer.createLong(trackEntryElem, MKVType.TrackType, (2 << 24 >> 24));
                MKVMuxer.createString(trackEntryElem, MKVType.Name, "Track " + (i + 1) + " Audio");
                MKVMuxer.createString(trackEntryElem, MKVType.CodecID, "A_VORBIS");
                MKVMuxer.createBuffer(trackEntryElem, MKVType.CodecPrivate, codecMeta.getCodecPrivate());
                if (stjs.isInstanceOf(codecMeta.constructor, AudioCodecMeta)) {
                    var acm = codecMeta;
                    var trackAudioElem = MKVType.createByType(MKVType.Audio);
                    MKVMuxer.createLong(trackAudioElem, MKVType.Channels, acm.getChannelCount());
                    MKVMuxer.createLong(trackAudioElem, MKVType.BitDepth, acm.getSampleSize());
                    MKVMuxer.createLong(trackAudioElem, MKVType.SamplingFrequency, acm.getSampleRate());
                    trackEntryElem.add(trackAudioElem);
                }
            }
            master.add(trackEntryElem);
        }
        return master;
    };
    prototype.muxSeekHead = function() {
        var shi = new SeekHeadFactory();
        shi.add(this.mkvInfo);
        shi.add(this.mkvTracks);
        shi.add(this.mkvCues);
        return shi.indexSeekHead();
    };
    prototype.muxCues = function(tracks) {
        var trackIndex = MKVStreamingMuxer.findFirstVP8TrackIndex(tracks);
        trackIndex += 1;
        var ci = new CuesFactory(this.mkvSeekHead.size() + this.mkvInfo.size() + this.mkvTracks.size(), trackIndex);
        for (var iterator$aCluster = this.webmClusters.iterator(); iterator$aCluster.hasNext(); ) {
            var aCluster = iterator$aCluster.next();
            ci.add(CuesFactory.CuePointMock.make(aCluster.c));
        }
        var indexedCues = ci.createCues();
        for (var iterator$aCuePoint = indexedCues.children.iterator(); iterator$aCuePoint.hasNext(); ) {
            var aCuePoint = iterator$aCuePoint.next();
            this.mkvCues.add(aCuePoint);
        }
    };
    constructor.findFirstVP8TrackIndex = function(tracks) {
        for (var i = 0; i < tracks.length; i++) 
            if (MKVStreamingMuxer.VP80_FOURCC.equalsIgnoreCase(tracks[i].getCodecMeta().getFourcc())) 
                return i;
        return -1;
    };
    constructor.WebmCluster = function(muxer, track, pkt, chunkNo, trackNo, previousClustersSize) {
        this.be = MKVType.createByType(MKVType.SimpleBlock);
        this.c = MKVType.createByType(MKVType.Cluster);
        this.muxer = muxer;
        this.pkt = pkt;
        this.chunkNo = chunkNo;
        this.trackNo = trackNo + 1;
        this.previousClustersSize = previousClustersSize;
        var timecode = stjs.trunc((pkt.getPts() * MKVStreamingMuxer.MULTIPLIER));
        MKVMuxer.createLong(this.c, MKVType.Timecode, timecode);
        try {
            this.be.frameSizes = new Int32Array([this.pkt.getDataLen()]);
        }catch (ioe) {
             throw new RuntimeException("Failed to read size of the frame", ioe);
        }
        this.be.timecode = 0;
        this.be.trackNumber = this.trackNo;
        this.be.discardable = false;
        this.be.lacingPresent = false;
        this.be.dataLen = this.be.getDataSize();
        this.c.add(this.be);
    };
    constructor.WebmCluster = stjs.extend(constructor.WebmCluster, null, [MovieSegment], function(constructor, prototype) {
        prototype.be = null;
        prototype.c = null;
        prototype.pkt = null;
        prototype.chunkNo = 0;
        prototype.trackNo = 0;
        prototype.previousClustersSize = 0;
        prototype.muxer = null;
        prototype.getData = function() {
            this.be.frames = Array(1);
            this.be.frames[0] = this.pkt.getData().duplicate();
            var data = this.c.getData();
            Assert.assertEquals("computed and actuall cluster sizes MUST match", ((this.c.size()) | 0), data.remaining());
            return data;
        };
        prototype.getNo = function() {
            return this.chunkNo;
        };
        prototype.getPos = function() {
            try {
                return this.previousClustersSize + this.muxer.headerChunk.getDataLen();
            }catch (e) {
                 throw new RuntimeException("Couldn't compute header length", e);
            }
        };
        prototype.getDataLen = function() {
            return ((this.c.size()) | 0);
        };
    }, {be: "MkvBlock", c: "EbmlMaster", pkt: "VirtualPacket", muxer: "MKVStreamingMuxer"}, {});
    constructor.HeaderSegment = function(header) {
        this.header = header;
    };
    constructor.HeaderSegment = stjs.extend(constructor.HeaderSegment, null, [MovieSegment], function(constructor, prototype) {
        prototype.header = null;
        prototype.getPos = function() {
            return 0;
        };
        prototype.getNo = function() {
            return 0;
        };
        prototype.getDataLen = function() {
            var size = 0;
            for (var iterator$m = this.header.iterator(); iterator$m.hasNext(); ) {
                var m = iterator$m.next();
                if (MKVType.Segment.equals(m.type)) {
                    size += (m).getHeaderSize();
                } else {
                    size += m.size();
                }
            }
            return size;
        };
        prototype.getData = function() {
            var data = ByteBuffer.allocate(this.getDataLen());
            for (var iterator$m = this.header.iterator(); iterator$m.hasNext(); ) {
                var m = iterator$m.next();
                if (MKVType.Segment.equals(m.type)) {
                    data.putBuf((m).getHeader());
                } else {
                    data.putBuf(m.getData());
                }
            }
            data.flip();
            return data;
        };
    }, {header: {name: "List", arguments: ["EbmlMaster"]}}, {});
}, {mkvInfo: "EbmlMaster", mkvTracks: "EbmlMaster", mkvCues: "EbmlMaster", mkvSeekHead: "EbmlMaster", segmentElem: "EbmlMaster", headerChunk: "MovieSegment", webmClusters: {name: "LinkedList", arguments: ["MKVStreamingMuxer.WebmCluster"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A box storing a list of synch samples
 *  
 *  @author The JCodec project
 *  
 */
var PartialSyncSamplesBox = function(header) {
    SyncSamplesBox.call(this, header);
};
PartialSyncSamplesBox = stjs.extend(PartialSyncSamplesBox, SyncSamplesBox, [], function(constructor, prototype) {
    constructor.STPS = "stps";
}, {syncSamples: "Int32Array", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Track fragment box
 *  
 *  Contains routines dedicated to simplify working with track fragments
 *  
 *  @author The JCodec project
 *  
 */
var TrackFragmentBox = function(atom) {
    NodeBox.call(this, atom);
};
TrackFragmentBox = stjs.extend(TrackFragmentBox, NodeBox, [], function(constructor, prototype) {
    constructor.fourcc = function() {
        return "traf";
    };
    prototype.getModelFields = function(model) {};
    prototype.getTrackId = function() {
        var tfhd = NodeBox.findFirst(this, TrackFragmentHeaderBox, TrackFragmentHeaderBox.fourcc());
        if (tfhd == null) 
             throw new RuntimeException("Corrupt track fragment, no header atom found");
        return tfhd.getTrackId();
    };
    constructor.createTrackFragmentBox = function() {
        return new TrackFragmentBox(new Header(TrackFragmentBox.fourcc()));
    };
}, {boxes: {name: "List", arguments: ["Box"]}, factory: "IBoxFactory", header: "Header"}, {});
var DataBoxes = function() {
    Boxes.call(this);
    this.mappings.put(UrlBox.fourcc(), UrlBox);
    this.mappings.put(AliasBox.fourcc(), AliasBox);
    this.mappings.put("cios", AliasBox);
};
DataBoxes = stjs.extend(DataBoxes, Boxes, [], null, {mappings: {name: "Map", arguments: [null, {name: "Class", arguments: ["Object"]}]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var AACUtils = function() {};
AACUtils = stjs.extend(AACUtils, null, [], function(constructor, prototype) {
    constructor.AudioInfo = function(format, labels) {
        this.format = format;
        this.labels = labels;
    };
    constructor.AudioInfo = stjs.extend(constructor.AudioInfo, null, [], function(constructor, prototype) {
        prototype.format = null;
        prototype.labels = null;
        prototype.getFormat = function() {
            return this.format;
        };
        prototype.getLabels = function() {
            return this.labels;
        };
    }, {format: "AudioFormat", labels: "Array"}, {});
    constructor.getObjectType = function(reader) {
        var objectType = reader.readNBit(5);
        if (objectType == ObjectType.AOT_ESCAPE.ordinal()) 
            objectType = 32 + reader.readNBit(6);
        return objectType;
    };
    constructor.AAC_DEFAULT_CONFIGS = [null, [ChannelLabel.MONO], [ChannelLabel.STEREO_LEFT, ChannelLabel.STEREO_RIGHT], [ChannelLabel.CENTER, ChannelLabel.FRONT_LEFT, ChannelLabel.FRONT_RIGHT], [ChannelLabel.CENTER, ChannelLabel.FRONT_LEFT, ChannelLabel.FRONT_RIGHT, ChannelLabel.REAR_CENTER], [ChannelLabel.CENTER, ChannelLabel.FRONT_LEFT, ChannelLabel.FRONT_RIGHT, ChannelLabel.REAR_LEFT, ChannelLabel.REAR_RIGHT], [ChannelLabel.CENTER, ChannelLabel.FRONT_LEFT, ChannelLabel.FRONT_RIGHT, ChannelLabel.REAR_LEFT, ChannelLabel.REAR_RIGHT, ChannelLabel.LFE], [ChannelLabel.CENTER, ChannelLabel.FRONT_LEFT, ChannelLabel.FRONT_RIGHT, ChannelLabel.SIDE_LEFT, ChannelLabel.SIDE_RIGHT, ChannelLabel.REAR_LEFT, ChannelLabel.REAR_RIGHT, ChannelLabel.LFE]];
    constructor.parseAudioInfo = function(privData) {
        var reader = BitReader.createBitReader(privData);
        var objectType = AACUtils.getObjectType(reader);
        var index = reader.readNBit(4);
        var sampleRate = index == 15 ? reader.readNBit(24) : AACConts.AAC_SAMPLE_RATES[index];
        var channelConfig = reader.readNBit(4);
        if (channelConfig == 0 || channelConfig >= AACUtils.AAC_DEFAULT_CONFIGS.length) 
            return null;
        var channels = AACUtils.AAC_DEFAULT_CONFIGS[channelConfig];
        return new AACUtils.AudioInfo(new AudioFormat(sampleRate, 16, channels.length, true, false), channels);
    };
    constructor.getChannels = function(mp4a) {
        if (!"mp4a".equals(mp4a.getFourcc())) 
             throw new IllegalArgumentException("Not mp4a sample entry");
        var b = NodeBox.findFirst(mp4a, Box.LeafBox, "esds");
        if (b == null) {
            b = NodeBox.findFirstPath(mp4a, Box.LeafBox, [null, "esds"]);
        }
        if (b == null) 
            return null;
        var esds = EsdsBox.newEsdsBox();
        esds.parse(b.getData());
        return AACUtils.parseAudioInfo(esds.getStreamInfo());
    };
}, {AAC_DEFAULT_CONFIGS: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var EncodedPixelBox = function(atom) {
    ClearApertureBox.call(this, atom);
};
EncodedPixelBox = stjs.extend(EncodedPixelBox, ClearApertureBox, [], function(constructor, prototype) {
    constructor.ENOF = "enof";
    constructor.createEncodedPixelBox = function(width, height) {
        var enof = new EncodedPixelBox(new Header(EncodedPixelBox.ENOF));
        enof.width = width;
        enof.height = height;
        return enof;
    };
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var ProductionApertureBox = function(atom) {
    ClearApertureBox.call(this, atom);
};
ProductionApertureBox = stjs.extend(ProductionApertureBox, ClearApertureBox, [], function(constructor, prototype) {
    constructor.PROF = "prof";
    constructor.createProductionApertureBox = function(width, height) {
        var prof = new ProductionApertureBox(new Header(ProductionApertureBox.PROF));
        prof.width = width;
        prof.height = height;
        return prof;
    };
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Creates MP4 file out of a set of samples
 *  
 *  @author The JCodec project
 */
var DataInfoBox = function(atom) {
    NodeBox.call(this, atom);
};
DataInfoBox = stjs.extend(DataInfoBox, NodeBox, [], function(constructor, prototype) {
    constructor.fourcc = function() {
        return "dinf";
    };
    constructor.createDataInfoBox = function() {
        return new DataInfoBox(new Header(DataInfoBox.fourcc()));
    };
    prototype.getDref = function() {
        return NodeBox.findFirst(this, DataRefBox, "dref");
    };
}, {boxes: {name: "List", arguments: ["Box"]}, factory: "IBoxFactory", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Describes timecode payload sample
 *  
 *  @author The JCodec project
 *  
 */
var TimecodeSampleEntry = function(header) {
    SampleEntry.call(this, header);
};
TimecodeSampleEntry = stjs.extend(TimecodeSampleEntry, SampleEntry, [], function(constructor, prototype) {
    constructor.TMCD = "tmcd";
    constructor.FLAG_DROPFRAME = 1;
    constructor.FLAG_24HOURMAX = 2;
    constructor.FLAG_NEGATIVETIMEOK = 4;
    constructor.FLAG_COUNTER = 8;
    constructor.createTimecodeSampleEntry = function(flags, timescale, frameDuration, numFrames) {
        var tmcd = new TimecodeSampleEntry(new Header(TimecodeSampleEntry.TMCD));
        tmcd.flags = flags;
        tmcd.timescale = timescale;
        tmcd.frameDuration = frameDuration;
        tmcd.numFrames = (numFrames << 24 >> 24);
        return tmcd;
    };
    prototype.flags = 0;
    prototype.timescale = 0;
    prototype.frameDuration = 0;
    prototype.numFrames = 0;
    prototype.parse = function(input) {
        SampleEntry.prototype.parse.call(this, input);
        NIOUtils.skip(input, 4);
        this.flags = input.getInt();
        this.timescale = input.getInt();
        this.frameDuration = input.getInt();
        this.numFrames = input.get();
        NIOUtils.skip(input, 1);
    };
    prototype.doWrite = function(out) {
        SampleEntry.prototype.doWrite.call(this, out);
        out.putInt(0);
        out.putInt(this.flags);
        out.putInt(this.timescale);
        out.putInt(this.frameDuration);
        out.put(this.numFrames);
        out.put((207 << 24 >> 24));
    };
    prototype.getFlags = function() {
        return this.flags;
    };
    prototype.getTimescale = function() {
        return this.timescale;
    };
    prototype.getFrameDuration = function() {
        return this.frameDuration;
    };
    prototype.getNumFrames = function() {
        return this.numFrames;
    };
    prototype.isDropFrame = function() {
        return (this.flags & TimecodeSampleEntry.FLAG_DROPFRAME) != 0;
    };
}, {boxes: {name: "List", arguments: ["Box"]}, factory: "IBoxFactory", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Describes video payload sample
 *  
 *  @author The JCodec project
 *  
 */
var VideoSampleEntry = function(atom) {
    SampleEntry.call(this, atom);
};
VideoSampleEntry = stjs.extend(VideoSampleEntry, SampleEntry, [], function(constructor, prototype) {
    constructor.createVideoSampleEntry = function(atom, version, revision, vendor, temporalQual, spacialQual, width, height, hRes, vRes, frameCount, compressorName, depth, drefInd, clrTbl) {
        var e = new VideoSampleEntry(atom);
        e.drefInd = drefInd;
        e.version = version;
        e.revision = revision;
        e.vendor = vendor;
        e.temporalQual = temporalQual;
        e.spacialQual = spacialQual;
        e.width = width;
        e.height = height;
        e.hRes = hRes;
        e.vRes = vRes;
        e.frameCount = frameCount;
        e.compressorName = compressorName;
        e.depth = depth;
        e.clrTbl = clrTbl;
        return e;
    };
    prototype.version = 0;
    prototype.revision = 0;
    prototype.vendor = null;
    prototype.temporalQual = 0;
    prototype.spacialQual = 0;
    prototype.width = 0;
    prototype.height = 0;
    prototype.hRes = 0.0;
    prototype.vRes = 0.0;
    prototype.frameCount = 0;
    prototype.compressorName = null;
    prototype.depth = 0;
    prototype.clrTbl = 0;
    prototype.parse = function(input) {
        SampleEntry.prototype.parse.call(this, input);
        this.version = input.getShort();
        this.revision = input.getShort();
        this.vendor = NIOUtils.readString(input, 4);
        this.temporalQual = input.getInt();
        this.spacialQual = input.getInt();
        this.width = input.getShort();
        this.height = input.getShort();
        this.hRes = input.getInt() / 65536.0;
        this.vRes = input.getInt() / 65536.0;
        input.getInt();
        this.frameCount = input.getShort();
        this.compressorName = NIOUtils.readPascalStringL(input, 31);
        this.depth = input.getShort();
        this.clrTbl = input.getShort();
        this.parseExtensions(input);
    };
    prototype.doWrite = function(out) {
        SampleEntry.prototype.doWrite.call(this, out);
        out.putShort(this.version);
        out.putShort(this.revision);
        out.put3(JCodecUtil2.asciiString(this.vendor), 0, 4);
        out.putInt(this.temporalQual);
        out.putInt(this.spacialQual);
        out.putShort(stjs.trunc(this.width));
        out.putShort(stjs.trunc(this.height));
        out.putInt(stjs.trunc((this.hRes * 65536)));
        out.putInt(stjs.trunc((this.vRes * 65536)));
        out.putInt(0);
        out.putShort(this.frameCount);
        NIOUtils.writePascalStringL(out, this.compressorName, 31);
        out.putShort(this.depth);
        out.putShort(this.clrTbl);
        this.writeExtensions(out);
    };
    prototype.getWidth = function() {
        return this.width;
    };
    prototype.getHeight = function() {
        return this.height;
    };
    prototype.gethRes = function() {
        return this.hRes;
    };
    prototype.getvRes = function() {
        return this.vRes;
    };
    prototype.getFrameCount = function() {
        return this.frameCount;
    };
    prototype.getCompressorName = function() {
        return this.compressorName;
    };
    prototype.getDepth = function() {
        return this.depth;
    };
    prototype.getVendor = function() {
        return this.vendor;
    };
    prototype.getVersion = function() {
        return this.version;
    };
    prototype.getRevision = function() {
        return this.revision;
    };
    prototype.getTemporalQual = function() {
        return this.temporalQual;
    };
    prototype.getSpacialQual = function() {
        return this.spacialQual;
    };
    prototype.getClrTbl = function() {
        return this.clrTbl;
    };
}, {boxes: {name: "List", arguments: ["Box"]}, factory: "IBoxFactory", header: "Header"}, {});
var AudioBoxes = function() {
    Boxes.call(this);
    this.mappings.put(WaveExtension.fourcc(), WaveExtension);
    this.mappings.put(ChannelBox.fourcc(), ChannelBox);
    this.mappings.put("esds", Box.LeafBox);
};
AudioBoxes = stjs.extend(AudioBoxes, Boxes, [], null, {mappings: {name: "Map", arguments: [null, {name: "Class", arguments: ["Object"]}]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Describes audio payload sample
 *  
 *  @author The JCodec project
 *  
 */
var AudioSampleEntry = function(atom) {
    SampleEntry.call(this, atom);
};
AudioSampleEntry = stjs.extend(AudioSampleEntry, SampleEntry, [], function(constructor, prototype) {
    constructor.kAudioFormatFlagIsFloat = 1;
    constructor.kAudioFormatFlagIsBigEndian = 2;
    constructor.kAudioFormatFlagIsSignedInteger = 4;
    constructor.kAudioFormatFlagIsPacked = 8;
    constructor.kAudioFormatFlagIsAlignedHigh = 16;
    constructor.kAudioFormatFlagIsNonInterleaved = 32;
    constructor.kAudioFormatFlagIsNonMixable = 64;
    constructor.createAudioSampleEntry = function(header, drefInd, channelCount, sampleSize, sampleRate, revision, vendor, compressionId, pktSize, samplesPerPkt, bytesPerPkt, bytesPerFrame, bytesPerSample, version) {
        var audio = new AudioSampleEntry(header);
        audio.drefInd = drefInd;
        audio.channelCount = channelCount;
        audio.sampleSize = sampleSize;
        audio.sampleRate = sampleRate;
        audio.revision = revision;
        audio.vendor = vendor;
        audio.compressionId = compressionId;
        audio.pktSize = pktSize;
        audio.samplesPerPkt = samplesPerPkt;
        audio.bytesPerPkt = bytesPerPkt;
        audio.bytesPerFrame = bytesPerFrame;
        audio.bytesPerSample = bytesPerSample;
        audio.version = version;
        return audio;
    };
    prototype.channelCount = 0;
    prototype.sampleSize = 0;
    prototype.sampleRate = 0.0;
    prototype.revision = 0;
    prototype.vendor = 0;
    prototype.compressionId = 0;
    prototype.pktSize = 0;
    prototype.samplesPerPkt = 0;
    prototype.bytesPerPkt = 0;
    prototype.bytesPerFrame = 0;
    prototype.bytesPerSample = 0;
    prototype.version = 0;
    prototype.lpcmFlags = 0;
    constructor.MONO = Arrays.asList(Label.Mono);
    constructor.STEREO = Arrays.asList(Label.Left, Label.Right);
    constructor.MATRIX_STEREO = Arrays.asList(Label.LeftTotal, Label.RightTotal);
    constructor.EMPTY = Array(0);
    prototype.parse = function(input) {
        SampleEntry.prototype.parse.call(this, input);
        this.version = input.getShort();
        this.revision = input.getShort();
        this.vendor = input.getInt();
        this.channelCount = input.getShort();
        this.sampleSize = input.getShort();
        this.compressionId = input.getShort();
        this.pktSize = input.getShort();
        var sr = input.getInt() & 4294967295;
        this.sampleRate = sr / 65536.0;
        if (this.version == 1) {
            this.samplesPerPkt = input.getInt();
            this.bytesPerPkt = input.getInt();
            this.bytesPerFrame = input.getInt();
            this.bytesPerSample = input.getInt();
        } else if (this.version == 2) {
            input.getInt();
            this.sampleRate = Double.longBitsToDouble(input.getLong());
            this.channelCount = ((input.getInt()) << 16 >> 16);
            input.getInt();
            this.sampleSize = ((input.getInt()) << 16 >> 16);
            this.lpcmFlags = stjs.trunc(input.getInt());
            this.bytesPerFrame = stjs.trunc(input.getInt());
            this.samplesPerPkt = stjs.trunc(input.getInt());
        }
        this.parseExtensions(input);
    };
    prototype.doWrite = function(out) {
        SampleEntry.prototype.doWrite.call(this, out);
        out.putShort(this.version);
        out.putShort(this.revision);
        out.putInt(this.vendor);
        if (this.version < 2) {
            out.putShort(this.channelCount);
            if (this.version == 0) 
                out.putShort(this.sampleSize);
             else 
                out.putShort(((16) << 16 >> 16));
            out.putShort(((this.compressionId) << 16 >> 16));
            out.putShort(((this.pktSize) << 16 >> 16));
            out.putInt(((Math.round(this.sampleRate * 65536.0)) | 0));
            if (this.version == 1) {
                out.putInt(this.samplesPerPkt);
                out.putInt(this.bytesPerPkt);
                out.putInt(this.bytesPerFrame);
                out.putInt(this.bytesPerSample);
            }
        } else if (this.version == 2) {
            out.putShort(((3) << 16 >> 16));
            out.putShort(((16) << 16 >> 16));
            out.putShort(((-2) << 16 >> 16));
            out.putShort(((0) << 16 >> 16));
            out.putInt(65536);
            out.putInt(72);
            out.putLong(Double.doubleToLongBits(this.sampleRate));
            out.putInt(this.channelCount);
            out.putInt(2130706432);
            out.putInt(this.sampleSize);
            out.putInt(this.lpcmFlags);
            out.putInt(this.bytesPerFrame);
            out.putInt(this.samplesPerPkt);
        }
        this.writeExtensions(out);
    };
    prototype.getChannelCount = function() {
        return this.channelCount;
    };
    prototype.calcFrameSize = function() {
        if (this.version == 0 || this.bytesPerFrame == 0) 
            return (this.sampleSize >> 3) * this.channelCount;
         else 
            return this.bytesPerFrame;
    };
    prototype.calcSampleSize = function() {
        return stjs.trunc(this.calcFrameSize() / this.channelCount);
    };
    prototype.getSampleSize = function() {
        return this.sampleSize;
    };
    prototype.getSampleRate = function() {
        return this.sampleRate;
    };
    prototype.getBytesPerFrame = function() {
        return this.bytesPerFrame;
    };
    prototype.getBytesPerSample = function() {
        return this.bytesPerSample;
    };
    prototype.getVersion = function() {
        return this.version;
    };
    prototype.getEndian = function() {
        var endianBox = NodeBox.findFirstPath(this, EndianBox, [WaveExtension.fourcc(), EndianBox.fourcc()]);
        if (endianBox == null) {
            if ("twos".equals(this.header.getFourcc())) 
                return ByteOrder.BIG_ENDIAN;
             else if ("lpcm".equals(this.header.getFourcc())) 
                return (this.lpcmFlags & AudioSampleEntry.kAudioFormatFlagIsBigEndian) != 0 ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN;
             else if ("sowt".equals(this.header.getFourcc())) 
                return ByteOrder.LITTLE_ENDIAN;
             else 
                return ByteOrder.BIG_ENDIAN;
        }
        return endianBox.getEndian();
    };
    prototype.isFloat = function() {
        return "fl32".equals(this.header.getFourcc()) || "fl64".equals(this.header.getFourcc()) || ("lpcm".equals(this.header.getFourcc()) && (this.lpcmFlags & AudioSampleEntry.kAudioFormatFlagIsFloat) != 0);
    };
    constructor.pcms = new HashSet();
    prototype.isPCM = function() {
        return AudioSampleEntry.pcms.contains(this.header.getFourcc());
    };
    prototype.getFormat = function() {
        return new AudioFormat(stjs.trunc(this.sampleRate), this.calcSampleSize() << 3, this.channelCount, true, this.getEndian() == ByteOrder.BIG_ENDIAN);
    };
    prototype.getLabels = function() {
        var channelBox = NodeBox.findFirst(this, ChannelBox, "chan");
        if (channelBox != null) {
            var labels = AudioSampleEntry.getLabelsFromChan(channelBox);
            if (this.channelCount == 2) 
                return this.translate(AudioSampleEntry.translationStereo, labels);
             else 
                return this.translate(AudioSampleEntry.translationSurround, labels);
        } else {
            switch (this.channelCount) {
                case 1:
                    return [ChannelLabel.MONO];
                case 2:
                    return [ChannelLabel.STEREO_LEFT, ChannelLabel.STEREO_RIGHT];
                case 6:
                    return [ChannelLabel.FRONT_LEFT, ChannelLabel.FRONT_RIGHT, ChannelLabel.CENTER, ChannelLabel.LFE, ChannelLabel.REAR_LEFT, ChannelLabel.REAR_RIGHT];
                default:
                    var lbl = Array(this.channelCount);
                    Arrays.fill(lbl, ChannelLabel.MONO);
                    return lbl;
            }
        }
    };
    prototype.translate = function(translation, labels) {
        var result = Array(labels.length);
        var i = 0;
        for (var j = 0; j < labels.length; j++) {
            var label = labels[j];
            result[i++] = translation.get(label);
        }
        return result;
    };
    constructor.translationStereo = new HashMap();
    constructor.translationSurround = new HashMap();
    prototype.getModelFields = function(list) {
        ToJSON.allFieldsExcept(this.getClass(), ["endian", "float", "format", "labels"]);
    };
    constructor.getLabelsFromSampleEntry = function(se) {
        var channel = NodeBox.findFirst(se, ChannelBox, "chan");
        if (channel != null) 
            return AudioSampleEntry.getLabelsFromChan(channel);
         else {
            var channelCount = se.getChannelCount();
            switch (channelCount) {
                case 1:
                    return [Label.Mono];
                case 2:
                    return [Label.Left, Label.Right];
                case 3:
                    return [Label.Left, Label.Right, Label.Center];
                case 4:
                    return [Label.Left, Label.Right, Label.LeftSurround, Label.RightSurround];
                case 5:
                    return [Label.Left, Label.Right, Label.Center, Label.LeftSurround, Label.RightSurround];
                case 6:
                    return [Label.Left, Label.Right, Label.Center, Label.LFEScreen, Label.LeftSurround, Label.RightSurround];
                default:
                    var res = Array(channelCount);
                    Arrays.fill(res, Label.Mono);
                    return res;
            }
        }
    };
    constructor.getLabelsFromTrack = function(trakBox) {
        return AudioSampleEntry.getLabelsFromSampleEntry(trakBox.getSampleEntries()[0]);
    };
    constructor.setLabel = function(trakBox, channel, label) {
        var labels = AudioSampleEntry.getLabelsFromTrack(trakBox);
        labels[channel] = label;
        AudioSampleEntry._setLabels(trakBox, labels);
    };
    constructor._setLabels = function(trakBox, labels) {
        var channel = NodeBox.findFirstPath(trakBox, ChannelBox, ["mdia", "minf", "stbl", "stsd", null, "chan"]);
        if (channel == null) {
            channel = ChannelBox.createChannelBox();
            NodeBox.findFirstPath(trakBox, SampleEntry, ["mdia", "minf", "stbl", "stsd", null]).add(channel);
        }
        AudioSampleEntry.setLabels(labels, channel);
    };
    constructor.setLabels = function(labels, channel) {
        channel.setChannelLayout(ChannelLayout.kCAFChannelLayoutTag_UseChannelDescriptions.getCode());
        var list = Array(labels.length);
        for (var i = 0; i < labels.length; i++) 
            list[i] = new ChannelBox.ChannelDescription(labels[i].getVal(), 0, new Float32Array([0, 0, 0]));
        channel.setDescriptions(list);
    };
    /**
     *  <code>
     *         enum
     *         {
     *             kCAFChannelBit_Left                 = (1<<0),
     *             kCAFChannelBit_Right                = (1<<1),
     *             kCAFChannelBit_Center               = (1<<2),
     *             kCAFChannelBit_LFEScreen            = (1<<3),
     *             kCAFChannelBit_LeftSurround         = (1<<4),   // WAVE: "Back Left"
     *             kCAFChannelBit_RightSurround        = (1<<5),   // WAVE: "Back Right"
     *             kCAFChannelBit_LeftCenter           = (1<<6),
     *             kCAFChannelBit_RightCenter          = (1<<7),
     *             kCAFChannelBit_CenterSurround       = (1<<8),   // WAVE: "Back Center"
     *             kCAFChannelBit_LeftSurroundDirect   = (1<<9),   // WAVE: "Side Left"
     *             kCAFChannelBit_RightSurroundDirect  = (1<<10), // WAVE: "Side Right"
     *             kCAFChannelBit_TopCenterSurround    = (1<<11),
     *             kCAFChannelBit_VerticalHeightLeft   = (1<<12), // WAVE: "Top Front Left"
     *             kCAFChannelBit_VerticalHeightCenter = (1<<13), // WAVE: "Top Front Center"
     *             kCAFChannelBit_VerticalHeightRight  = (1<<14), // WAVE: "Top Front Right"
     *             kCAFChannelBit_TopBackLeft          = (1<<15),
     *             kCAFChannelBit_TopBackCenter        = (1<<16),
     *             kCAFChannelBit_TopBackRight         = (1<<17)
     *         };
     *         </code>
     *  
     *  @param channelBitmap
     *  @return
     */
    constructor.getLabelsByBitmap = function(channelBitmap) {
        var result = new ArrayList();
        var values = Label.values();
        for (var i = 0; i < values.length; i++) {
            var label = values[i];
            if ((label.bitmapVal & channelBitmap) != 0) 
                result.add(label);
        }
        return result.toArray(Array(0));
    };
    constructor.extractLabels = function(descriptions) {
        var result = Array(descriptions.length);
        for (var i = 0; i < descriptions.length; i++) 
            result[i] = descriptions[i].getLabel();
        return result;
    };
    constructor.getLabelsFromChan = function(box) {
        var tag = box.getChannelLayout();
        if ((tag >> 16) == 147) {
            var n = ((tag) | 0) & 65535;
            var res = Array(n);
            for (var i = 0; i < n; i++) 
                res[i] = Label.getByVal((1 << 16) | i);
            return res;
        }
        var values = ChannelLayout.values();
        for (var i = 0; i < values.length; i++) {
            var layout = values[i];
            if (layout.getCode() == tag) {
                if (layout == ChannelLayout.kCAFChannelLayoutTag_UseChannelDescriptions) {
                    return AudioSampleEntry.extractLabels(box.getDescriptions());
                } else if (layout == ChannelLayout.kCAFChannelLayoutTag_UseChannelBitmap) {
                    return AudioSampleEntry.getLabelsByBitmap(box.getChannelBitmap());
                } else {
                    return layout.getLabels();
                }
            }
        }
        return AudioSampleEntry.EMPTY;
    };
}, {MONO: {name: "List", arguments: ["Label"]}, STEREO: {name: "List", arguments: ["Label"]}, MATRIX_STEREO: {name: "List", arguments: ["Label"]}, EMPTY: "Array", pcms: {name: "Set", arguments: [null]}, translationStereo: {name: "Map", arguments: ["Label", {name: "Enum", arguments: ["ChannelLabel"]}]}, translationSurround: {name: "Map", arguments: ["Label", {name: "Enum", arguments: ["ChannelLabel"]}]}, boxes: {name: "List", arguments: ["Box"]}, factory: "IBoxFactory", header: "Header"}, {});
(function() {
    AudioSampleEntry.pcms.add("raw ");
    AudioSampleEntry.pcms.add("twos");
    AudioSampleEntry.pcms.add("sowt");
    AudioSampleEntry.pcms.add("fl32");
    AudioSampleEntry.pcms.add("fl64");
    AudioSampleEntry.pcms.add("in24");
    AudioSampleEntry.pcms.add("in32");
    AudioSampleEntry.pcms.add("lpcm");
})();
(function() {
    AudioSampleEntry.translationStereo.put(Label.Left, ChannelLabel.STEREO_LEFT);
    AudioSampleEntry.translationStereo.put(Label.Right, ChannelLabel.STEREO_RIGHT);
    AudioSampleEntry.translationStereo.put(Label.HeadphonesLeft, ChannelLabel.STEREO_LEFT);
    AudioSampleEntry.translationStereo.put(Label.HeadphonesRight, ChannelLabel.STEREO_RIGHT);
    AudioSampleEntry.translationStereo.put(Label.LeftTotal, ChannelLabel.STEREO_LEFT);
    AudioSampleEntry.translationStereo.put(Label.RightTotal, ChannelLabel.STEREO_RIGHT);
    AudioSampleEntry.translationStereo.put(Label.LeftWide, ChannelLabel.STEREO_LEFT);
    AudioSampleEntry.translationStereo.put(Label.RightWide, ChannelLabel.STEREO_RIGHT);
    AudioSampleEntry.translationSurround.put(Label.Left, ChannelLabel.FRONT_LEFT);
    AudioSampleEntry.translationSurround.put(Label.Right, ChannelLabel.FRONT_RIGHT);
    AudioSampleEntry.translationSurround.put(Label.LeftCenter, ChannelLabel.FRONT_CENTER_LEFT);
    AudioSampleEntry.translationSurround.put(Label.RightCenter, ChannelLabel.FRONT_CENTER_RIGHT);
    AudioSampleEntry.translationSurround.put(Label.Center, ChannelLabel.CENTER);
    AudioSampleEntry.translationSurround.put(Label.CenterSurround, ChannelLabel.REAR_CENTER);
    AudioSampleEntry.translationSurround.put(Label.CenterSurroundDirect, ChannelLabel.REAR_CENTER);
    AudioSampleEntry.translationSurround.put(Label.LeftSurround, ChannelLabel.REAR_LEFT);
    AudioSampleEntry.translationSurround.put(Label.LeftSurroundDirect, ChannelLabel.REAR_LEFT);
    AudioSampleEntry.translationSurround.put(Label.RightSurround, ChannelLabel.REAR_RIGHT);
    AudioSampleEntry.translationSurround.put(Label.RightSurroundDirect, ChannelLabel.REAR_RIGHT);
    AudioSampleEntry.translationSurround.put(Label.RearSurroundLeft, ChannelLabel.SIDE_LEFT);
    AudioSampleEntry.translationSurround.put(Label.RearSurroundRight, ChannelLabel.SIDE_RIGHT);
    AudioSampleEntry.translationSurround.put(Label.LFE2, ChannelLabel.LFE);
    AudioSampleEntry.translationSurround.put(Label.LFEScreen, ChannelLabel.LFE);
    AudioSampleEntry.translationSurround.put(Label.LeftTotal, ChannelLabel.STEREO_LEFT);
    AudioSampleEntry.translationSurround.put(Label.RightTotal, ChannelLabel.STEREO_RIGHT);
    AudioSampleEntry.translationSurround.put(Label.LeftWide, ChannelLabel.STEREO_LEFT);
    AudioSampleEntry.translationSurround.put(Label.RightWide, ChannelLabel.STEREO_RIGHT);
})();
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Cut on ref movies
 *  
 *  @author The JCodec project
 *  
 */
var Util = function() {};
Util = stjs.extend(Util, null, [], function(constructor, prototype) {
    constructor.Pair = function(a, b) {
        this.a = a;
        this.b = b;
    };
    constructor.Pair = stjs.extend(constructor.Pair, null, [], function(constructor, prototype) {
        prototype.a = null;
        prototype.b = null;
        prototype.getA = function() {
            return this.a;
        };
        prototype.getB = function() {
            return this.b;
        };
    }, {}, {});
    constructor.splitEdits = function(edits, trackByMv, tvMv) {
        var total = 0;
        var l = new ArrayList();
        var r = new ArrayList();
        var lit = edits.listIterator();
         while (lit.hasNext()){
            var edit = lit.next();
            if (total + edit.getDuration() > tvMv) {
                var leftDurMV = (((tvMv - total)) | 0);
                var leftDurMedia = trackByMv.multiplyS(leftDurMV);
                var left = new Edit(leftDurMV, edit.getMediaTime(), 1.0);
                var right = new Edit(edit.getDuration() - leftDurMV, leftDurMedia + edit.getMediaTime(), 1.0);
                lit.remove();
                if (left.getDuration() > 0) {
                    lit.add(left);
                    l.add(left);
                }
                if (right.getDuration() > 0) {
                    lit.add(right);
                    r.add(right);
                }
                break;
            } else {
                l.add(edit);
            }
            total += edit.getDuration();
        }
         while (lit.hasNext()){
            r.add(lit.next());
        }
        return new Util.Pair(l, r);
    };
    /**
     *  Splits track on the timevalue specified
     *  
     *  @param movie
     *  @param track
     *  @param tvMv
     *  @return
     */
    constructor.split = function(movie, track, tvMv) {
        return Util.splitEdits(track.getEdits(), new Rational(track.getTimescale(), movie.getTimescale()), tvMv);
    };
    constructor.spread = function(movie, track, tvMv, durationMv) {
        var split = Util.split(movie, track, tvMv);
        track.getEdits().add(split.getA().size(), new Edit(durationMv, -1, 1.0));
    };
    constructor.shift = function(movie, track, tvMv) {
        track.getEdits().add(0, new Edit(tvMv, -1, 1.0));
    };
    constructor.getTimevalues = function(track) {
        var stts = track.getStts();
        var count = 0;
        var tts = stts.getEntries();
        for (var i = 0; i < tts.length; i++) 
            count += tts[i].getSampleCount();
        var tv = Array(count + 1);
        var k = 0;
        for (var i = 0; i < tts.length; i++) {
            for (var j = 0; j < tts[i].getSampleCount(); j++ , k++) {
                tv[k + 1] = tv[k] + tts[i].getSampleDuration();
            }
        }
        return tv;
    };
    constructor.appendToInternal = function(movie, dest, src) {
        var off = Util.appendEntries(dest, src);
        Util.appendChunkOffsets(dest, src);
        Util.appendTimeToSamples(dest, src);
        Util.appendSampleToChunk(dest, src, off);
        Util.appendSampleSizes(dest, src);
    };
    constructor.updateDuration = function(dest, src) {
        var mdhd1 = NodeBox.findFirstPath(dest, MediaHeaderBox, Box.path("mdia.mdhd"));
        var mdhd2 = NodeBox.findFirstPath(src, MediaHeaderBox, Box.path("mdia.mdhd"));
        mdhd1.setDuration(mdhd1.getDuration() + mdhd2.getDuration());
    };
    constructor.appendTo = function(movie, dest, src) {
        Util.appendToInternal(movie, dest, src);
        Util.appendEdits(dest, src, dest.getEdits().size());
        Util.updateDuration(dest, src);
    };
    constructor.insertTo = function(movie, dest, src, tvMv) {
        Util.appendToInternal(movie, dest, src);
        Util.insertEdits(movie, dest, src, tvMv);
        Util.updateDuration(dest, src);
    };
    constructor.insertEdits = function(movie, dest, src, tvMv) {
        var split = Util.split(movie, dest, tvMv);
        Util.appendEdits(dest, src, split.getA().size());
    };
    constructor.appendEdits = function(dest, src, ind) {
        for (var iterator$edit = src.getEdits().iterator(); iterator$edit.hasNext(); ) {
            var edit = iterator$edit.next();
            edit.shift(dest.getMediaDuration());
        }
        dest.getEdits().addAllAt(ind, src.getEdits());
        dest.setEdits(dest.getEdits());
    };
    constructor.appendSampleSizes = function(trakBox1, trakBox2) {
        var stsz1 = trakBox1.getStsz();
        var stsz2 = trakBox2.getStsz();
        if (stsz1.getDefaultSize() != stsz2.getDefaultSize()) 
             throw new IllegalArgumentException("Can't append to track that has different default sample size");
        var stszr;
        if (stsz1.getDefaultSize() > 0) {
            stszr = SampleSizesBox.createSampleSizesBox(stsz1.getDefaultSize(), stsz1.getCount() + stsz2.getCount());
        } else {
            stszr = SampleSizesBox.createSampleSizesBox2(ArrayUtil.addAllInt(stsz1.getSizes(), stsz2.getSizes()));
        }
        NodeBox.findFirstPath(trakBox1, NodeBox, Box.path("mdia.minf.stbl")).replace("stsz", stszr);
    };
    constructor.appendSampleToChunk = function(trakBox1, trakBox2, off) {
        var stsc1 = trakBox1.getStsc();
        var stsc2 = trakBox2.getStsc();
        var orig = stsc2.getSampleToChunk();
        var shifted = Array(orig.length);
        for (var i = 0; i < orig.length; i++) {
            shifted[i] = new SampleToChunkBox.SampleToChunkEntry(orig[i].getFirst() + stsc1.getSampleToChunk().length, orig[i].getCount(), orig[i].getEntry() + off);
        }
        NodeBox.findFirstPath(trakBox1, NodeBox, Box.path("mdia.minf.stbl")).replace("stsc", SampleToChunkBox.createSampleToChunkBox(ArrayUtil.addAllObj(stsc1.getSampleToChunk(), shifted)));
    };
    constructor.appendEntries = function(trakBox1, trakBox2) {
        Util.appendDrefs(trakBox1, trakBox2);
        var ent1 = trakBox1.getSampleEntries();
        var ent2 = trakBox2.getSampleEntries();
        var stsd = SampleDescriptionBox.createSampleDescriptionBox(ent1);
        for (var i = 0; i < ent2.length; i++) {
            var se = ent2[i];
            se.setDrefInd((((se.getDrefInd() + ent1.length)) << 16 >> 16));
            stsd.add(se);
        }
        NodeBox.findFirstPath(trakBox1, NodeBox, Box.path("mdia.minf.stbl")).replace("stsd", stsd);
        return ent1.length;
    };
    constructor.appendDrefs = function(trakBox1, trakBox2) {
        var dref1 = NodeBox.findFirstPath(trakBox1, DataRefBox, Box.path("mdia.minf.dinf.dref"));
        var dref2 = NodeBox.findFirstPath(trakBox2, DataRefBox, Box.path("mdia.minf.dinf.dref"));
        dref1.getBoxes().addAll(dref2.getBoxes());
    };
    constructor.appendTimeToSamples = function(trakBox1, trakBox2) {
        var stts1 = trakBox1.getStts();
        var stts2 = trakBox2.getStts();
        var sttsNew = TimeToSampleBox.createTimeToSampleBox(ArrayUtil.addAllObj(stts1.getEntries(), stts2.getEntries()));
        NodeBox.findFirstPath(trakBox1, NodeBox, Box.path("mdia.minf.stbl")).replace("stts", sttsNew);
    };
    constructor.appendChunkOffsets = function(trakBox1, trakBox2) {
        var stco1 = trakBox1.getStco();
        var co641 = trakBox1.getCo64();
        var stco2 = trakBox2.getStco();
        var co642 = trakBox2.getCo64();
        var off1 = stco1 == null ? co641.getChunkOffsets() : stco1.getChunkOffsets();
        var off2 = stco2 == null ? co642.getChunkOffsets() : stco2.getChunkOffsets();
        var stbl1 = NodeBox.findFirstPath(trakBox1, NodeBox, Box.path("mdia.minf.stbl"));
        stbl1.removeChildren("stco", "co64");
        stbl1.add(co641 == null && co642 == null ? ChunkOffsetsBox.createChunkOffsetsBox(ArrayUtil.addAllLong(off1, off2)) : ChunkOffsets64Box.createChunkOffsets64Box(ArrayUtil.addAllLong(off1, off2)));
    };
    constructor.forceEditList = function(movie, trakBox) {
        var edits = trakBox.getEdits();
        if (edits == null || edits.size() == 0) {
            var mvhd = NodeBox.findFirst(movie, MovieHeaderBox, "mvhd");
            edits = new ArrayList();
            trakBox.setEdits(edits);
            edits.add(new Edit(((mvhd.getDuration()) | 0), 0, 1.0));
            trakBox.setEdits(edits);
        }
    };
    constructor.forceEditListMov = function(movie) {
        var tracks = movie.getTracks();
        for (var i = 0; i < tracks.length; i++) {
            var trakBox = tracks[i];
            Util.forceEditList(movie, trakBox);
        }
    };
    constructor.editsOnEdits = function(mvByTrack, lower, higher) {
        var result = new ArrayList();
        var next = new ArrayList(lower);
        for (var iterator$edit = higher.iterator(); iterator$edit.hasNext(); ) {
            var edit = iterator$edit.next();
            var startMv = mvByTrack.multiplyLong(edit.getMediaTime());
            var split = Util.splitEdits(next, mvByTrack.flip(), startMv);
            var split2 = Util.splitEdits(split.getB(), mvByTrack.flip(), startMv + edit.getDuration());
            result.addAll(split2.getA());
            next = split2.getB();
        }
        return result;
    };
}, {}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  Main AAC decoder class
 *  
 *  @author in-somnia
 */
var Decoder = /**
 *  Initializes the decoder with a MP4 decoder specific info.
 * 
 *  After this the MP4 frames can be passed to the
 *  <code>decodeFrame(byte[], SampleBuffer)</code> method to decode them.
 *  
 *  @param decoderSpecificInfo
 *             a byte array containing the decoder specific info from an MP4
 *             container
 *  @throws AACException
 *              if the specified profile is not supported
 */
function(decoderSpecificInfo) {
    this.config = AACDecoderConfig.parseMP4DecoderSpecificInfo(decoderSpecificInfo);
    if (this.config == null) 
         throw new IllegalArgumentException("illegal MP4 decoder specific info");
    if (!Decoder.canDecode(this.config.getProfile())) 
         throw new AACException("unsupported profile: " + this.config.getProfile().getDescription());
    this.syntacticElements = new SyntacticElements(this.config);
    this.filterBank = new FilterBank(this.config.isSmallFrameUsed(), this.config.getChannelConfiguration().getChannelCount());
    this._in = new BitStream();
    SyntaxConstants.LOGGER.log(Level.FINE, "profile: {0}", this.config.getProfile());
    SyntaxConstants.LOGGER.log(Level.FINE, "sf: {0}", this.config.getSampleFrequency().getFrequency());
    SyntaxConstants.LOGGER.log(Level.FINE, "channels: {0}", this.config.getChannelConfiguration().getDescription());
};
Decoder = stjs.extend(Decoder, null, [SyntaxConstants], function(constructor, prototype) {
    prototype.config = null;
    prototype.syntacticElements = null;
    prototype.filterBank = null;
    prototype._in = null;
    prototype.adifHeader = null;
    /**
     *  The methods returns true, if a profile is supported by the decoder.
     *  
     *  @param profile
     *             an AAC profile
     *  @return true if the specified profile can be decoded
     *  @see Profile#isDecodingSupported()
     */
    constructor.canDecode = function(profile) {
        return profile.isDecodingSupported();
    };
    prototype.getConfig = function() {
        return this.config;
    };
    /**
     *  Decodes one frame of AAC data in frame mode and returns the raw PCM data.
     *  
     *  @param frame
     *             the AAC frame
     *  @param buffer
     *             a buffer to hold the decoded PCM data
     *  @throws AACException
     *              if decoding fails
     */
    prototype.decodeFrame = function(frame, buffer) {
        if (frame != null) 
            this._in.setData(frame);
        SyntaxConstants.LOGGER.finest("bits left " + this._in.getBitsLeft());
        try {
            this.decode(buffer);
        }catch (e) {
            if (!e.isEndOfStream()) 
                 throw e;
             else 
                SyntaxConstants.LOGGER.warning("unexpected end of frame");
        }
    };
    prototype.decode = function(buffer) {
        if (ADIFHeader.isPresent(this._in)) {
            this.adifHeader = ADIFHeader.readHeader(this._in);
            var pce = this.adifHeader.getFirstPCE();
            this.config.setProfile(pce.getProfile());
            this.config.setSampleFrequency(pce.getSampleFrequency());
            this.config.setChannelConfiguration(ChannelConfiguration.forInt(pce.getChannelCount()));
        }
        if (!Decoder.canDecode(this.config.getProfile())) 
             throw new AACException("unsupported profile: " + this.config.getProfile().getDescription());
        this.syntacticElements.startNewFrame();
        try {
            this.syntacticElements.decode(this._in);
            this.syntacticElements.process(this.filterBank);
            this.syntacticElements.sendToOutput(buffer);
        }catch (e) {
            buffer.setData(new Int8Array(0), 0, 0, 0, 0);
             throw AACException.wrap(e);
        }
    };
}, {config: "AACDecoderConfig", syntacticElements: "SyntacticElements", filterBank: "FilterBank", _in: "IBitStream", adifHeader: "ADIFHeader", LOGGER: "Logger"}, {});
(function() {
    for (var iterator$h = SyntaxConstants.LOGGER.getHandlers().iterator(); iterator$h.hasNext(); ) {
        var h = iterator$h.next();
        SyntaxConstants.LOGGER.removeHandler(h);
    }
    SyntaxConstants.LOGGER.setLevel(Level.ALL);
    var h = new ConsoleHandler();
    h.setLevel(Level.ALL);
    SyntaxConstants.LOGGER.addHandler(h);
})();
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var AES3PCMDescriptor = function(ul) {
    WaveAudioDescriptor.call(this, ul);
};
AES3PCMDescriptor = stjs.extend(AES3PCMDescriptor, WaveAudioDescriptor, [], function(constructor, prototype) {
    prototype.emphasis = 0;
    prototype.blockStartOffset = 0;
    prototype.auxBitsMode = 0;
    prototype.channelStatusMode = null;
    prototype.fixedChannelStatusData = null;
    prototype.userDataMode = null;
    prototype.fixedUserData = null;
    prototype.read = function(tags) {
        WaveAudioDescriptor.prototype.read.call(this, tags);
        for (var it = tags.entrySet().iterator(); it.hasNext(); ) {
            var entry = it.next();
            var _bb = entry.getValue();
            switch (entry.getKey()) {
                case 15629:
                    this.emphasis = _bb.get();
                    break;
                case 15631:
                    this.blockStartOffset = _bb.getShort();
                    break;
                case 15624:
                    this.auxBitsMode = _bb.get();
                    break;
                case 15632:
                    this.channelStatusMode = _bb;
                    break;
                case 15633:
                    this.fixedChannelStatusData = _bb;
                    break;
                case 15634:
                    this.userDataMode = _bb;
                    break;
                case 15635:
                    this.fixedUserData = _bb;
                    break;
                default:
                    jcodec.Logger.warn(String.format("Unknown tag [ " + this.ul + "]: %04x", entry.getKey()));
                    continue;
            }
            it.remove();
        }
    };
    prototype.getEmphasis = function() {
        return this.emphasis;
    };
    prototype.getBlockStartOffset = function() {
        return this.blockStartOffset;
    };
    prototype.getAuxBitsMode = function() {
        return this.auxBitsMode;
    };
    prototype.getChannelStatusMode = function() {
        return this.channelStatusMode;
    };
    prototype.getFixedChannelStatusData = function() {
        return this.fixedChannelStatusData;
    };
    prototype.getUserDataMode = function() {
        return this.userDataMode;
    };
    prototype.getFixedUserData = function() {
        return this.fixedUserData;
    };
}, {channelStatusMode: "ByteBuffer", fixedChannelStatusData: "ByteBuffer", userDataMode: "ByteBuffer", fixedUserData: "ByteBuffer", channelAssignment: "UL", peakOfPeaksPosition: "ByteBuffer", peakEnvelopeTimestamp: "ByteBuffer", peakEnvelopeData: "ByteBuffer", audioSamplingRate: "Rational", soundEssenceCompression: "UL", sampleRate: "Rational", essenceContainer: "UL", codec: "UL", locators: "Array", subDescriptors: "Array", generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MPEG2VideoDescriptor = function(ul) {
    CDCIEssenceDescriptor.call(this, ul);
};
MPEG2VideoDescriptor = stjs.extend(MPEG2VideoDescriptor, CDCIEssenceDescriptor, [], function(constructor, prototype) {
    prototype.singleSequence = 0;
    prototype.constantBFrames = 0;
    prototype.codedContentType = 0;
    prototype.lowDelay = 0;
    prototype.closedGOP = 0;
    prototype.identicalGOP = 0;
    prototype.maxGOP = 0;
    prototype.bPictureCount = 0;
    prototype.bitRate = 0;
    prototype.profileAndLevel = 0;
    prototype.read = function(tags) {
        CDCIEssenceDescriptor.prototype.read.call(this, tags);
        for (var it = tags.entrySet().iterator(); it.hasNext(); ) {
            var entry = it.next();
            var _bb = entry.getValue();
            switch (entry.getKey()) {
                case 32768:
                    this.singleSequence = _bb.get();
                    break;
                case 32769:
                    this.constantBFrames = _bb.get();
                    break;
                case 32770:
                    this.codedContentType = _bb.get();
                    break;
                case 32771:
                    this.lowDelay = _bb.get();
                    break;
                case 32772:
                    this.closedGOP = _bb.get();
                    break;
                case 32773:
                    this.identicalGOP = _bb.get();
                    break;
                case 32774:
                    this.maxGOP = _bb.getShort();
                    break;
                case 32775:
                    this.bPictureCount = (((_bb.get() & 255)) << 16 >> 16);
                    break;
                case 32776:
                    this.bitRate = _bb.getInt();
                    break;
                case 32777:
                    this.profileAndLevel = _bb.get();
                    break;
                default:
                    jcodec.Logger.warn(String.format("Unknown tag [ " + this.ul + "]: %04x + (" + _bb.remaining() + ")", entry.getKey()));
                    continue;
            }
            it.remove();
        }
    };
    prototype.getSingleSequence = function() {
        return this.singleSequence;
    };
    prototype.getConstantBFrames = function() {
        return this.constantBFrames;
    };
    prototype.getCodedContentType = function() {
        return this.codedContentType;
    };
    prototype.getLowDelay = function() {
        return this.lowDelay;
    };
    prototype.getClosedGOP = function() {
        return this.closedGOP;
    };
    prototype.getIdenticalGOP = function() {
        return this.identicalGOP;
    };
    prototype.getMaxGOP = function() {
        return this.maxGOP;
    };
    prototype.getbPictureCount = function() {
        return this.bPictureCount;
    };
    prototype.getBitRate = function() {
        return this.bitRate;
    };
    prototype.getProfileAndLevel = function() {
        return this.profileAndLevel;
    };
}, {frameLayout: {name: "Enum", arguments: ["GenericPictureEssenceDescriptor.LayoutType"]}, aspectRatio: "Rational", videoLineMap: "Int32Array", transferCharacteristic: "UL", pictureEssenceCoding: "UL", codingEquations: "UL", colorPrimaries: "UL", sampleRate: "Rational", essenceContainer: "UL", codec: "UL", locators: "Array", subDescriptors: "Array", generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed under FreeBSD License
 *  
 *  WebM specific muxing
 *  
 *  @author The JCodec project
 *  
 */
var VirtualWebmMovie = function(_arguments) {
    VirtualMovie.call(this, arguments);
    this.muxer = new MKVStreamingMuxer();
    this.muxTracks();
};
VirtualWebmMovie = stjs.extend(VirtualWebmMovie, VirtualMovie, [], function(constructor, prototype) {
    prototype.muxer = null;
    prototype.muxTracks = function() {
        var chch = new ArrayList();
        var heads = Array(this.tracks.length), tails = Array(this.tracks.length);
        var currentlyAddedContentSize = 0;
        for (var curChunk = 1; ; curChunk++) {
            var min = -1;
            for (var i = 0; i < heads.length; i++) {
                if (heads[i] == null) {
                    heads[i] = this.tracks[i].nextPacket();
                    if (heads[i] == null) 
                        continue;
                }
                min = min == -1 || heads[i].getPts() < heads[min].getPts() ? i : min;
            }
            if (min == -1) 
                break;
            var packetChunk = this.packetChunk(this.tracks[min], heads[min], curChunk, min, currentlyAddedContentSize);
            chch.add(packetChunk);
            currentlyAddedContentSize += packetChunk.getDataLen();
            tails[min] = heads[min];
            heads[min] = this.tracks[min].nextPacket();
        }
        this._headerChunk = this.headerChunk(chch, this.tracks, this._size);
        this._size += this._headerChunk.getDataLen() + currentlyAddedContentSize;
        this.chunks = chch.toArray(Array(0));
    };
    prototype.packetChunk = function(track, pkt, chunkNo, trackNo, previousClustersSize) {
        return this.muxer.preparePacket(track, pkt, chunkNo, trackNo, previousClustersSize);
    };
    prototype.headerChunk = function(chunks, tracks, dataSize) {
        return this.muxer.prepareHeader(chunks, tracks);
    };
}, {muxer: "MKVStreamingMuxer", chunks: "Array", _headerChunk: "MovieSegment", tracks: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Movie fragment box and dedicated routines
 *  
 *  @author The JCodec project
 *  
 */
var MovieFragmentBox = function(atom) {
    NodeBox.call(this, atom);
};
MovieFragmentBox = stjs.extend(MovieFragmentBox, NodeBox, [], function(constructor, prototype) {
    prototype.moov = null;
    constructor.fourcc = function() {
        return "moof";
    };
    prototype.getMovie = function() {
        return this.moov;
    };
    prototype.setMovie = function(moov) {
        this.moov = moov;
    };
    prototype.getModelFields = function(model) {};
    prototype.getTracks = function() {
        return NodeBox.findAll(this, TrackFragmentBox, TrackFragmentBox.fourcc());
    };
    prototype.getSequenceNumber = function() {
        var mfhd = NodeBox.findFirst(this, MovieFragmentHeaderBox, MovieFragmentHeaderBox.fourcc());
        if (mfhd == null) 
             throw new RuntimeException("Corrupt movie fragment, no header atom found");
        return mfhd.getSequenceNumber();
    };
    constructor.createMovieFragmentBox = function() {
        return new MovieFragmentBox(new Header(MovieFragmentBox.fourcc()));
    };
}, {moov: "MovieBox", boxes: {name: "List", arguments: ["Box"]}, factory: "IBoxFactory", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var ChunkWriter = function(trak, inputs, out) {
    this.buf = new Int8Array(8092);
    this.entries = trak.getSampleEntries();
    var stco = trak.getStco();
    var co64 = trak.getCo64();
    var size;
    if (stco != null) 
        size = stco.getChunkOffsets().length;
     else 
        size = co64.getChunkOffsets().length;
    this.inputs = inputs;
    this.offsets = Array(size);
    this.out = out;
    this.trak = trak;
};
ChunkWriter = stjs.extend(ChunkWriter, null, [], function(constructor, prototype) {
    prototype.offsets = null;
    prototype.entries = null;
    prototype.inputs = null;
    prototype.curChunk = 0;
    prototype.out = null;
    prototype.buf = null;
    prototype.trak = null;
    prototype.apply = function() {
        var stbl = NodeBox.findFirstPath(this.trak, NodeBox, Box.path("mdia.minf.stbl"));
        stbl.removeChildren("stco", "co64");
        stbl.add(ChunkOffsets64Box.createChunkOffsets64Box(this.offsets));
        this.cleanDrefs(this.trak);
    };
    prototype.cleanDrefs = function(trak) {
        var minf = trak.getMdia().getMinf();
        var dinf = trak.getMdia().getMinf().getDinf();
        if (dinf == null) {
            dinf = DataInfoBox.createDataInfoBox();
            minf.add(dinf);
        }
        var dref = dinf.getDref();
        if (dref == null) {
            dref = DataRefBox.createDataRefBox();
            dinf.add(dref);
        }
        dref.getBoxes().clear();
        dref.add(AliasBox.createSelfRef());
        var sampleEntries = trak.getSampleEntries();
        for (var i = 0; i < sampleEntries.length; i++) {
            var entry = sampleEntries[i];
            entry.setDrefInd(((1) << 16 >> 16));
        }
    };
    prototype.getInput = function(chunk) {
        var se = this.entries[chunk.getEntry() - 1];
        return this.inputs[se.getDrefInd() - 1];
    };
    prototype.write = function(chunk) {
        var input = this.getInput(chunk);
        input.setPosition(chunk.getOffset());
        var pos = this.out.position();
        this.out.write(NIOUtils.fetchFromChannel(input, ((chunk.getSize()) | 0)));
        this.offsets[this.curChunk++] = pos;
    };
}, {offsets: "Array", entries: "Array", inputs: "Array", out: "SeekableByteChannel", buf: "Int8Array", trak: "TrakBox"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Creates MP4 file out of a set of samples
 *  
 *  @author The JCodec project
 *  
 */
var MediaInfoBox = function(atom) {
    NodeBox.call(this, atom);
};
MediaInfoBox = stjs.extend(MediaInfoBox, NodeBox, [], function(constructor, prototype) {
    constructor.fourcc = function() {
        return "minf";
    };
    constructor.createMediaInfoBox = function() {
        return new MediaInfoBox(new Header(MediaInfoBox.fourcc()));
    };
    prototype.getDinf = function() {
        return NodeBox.findFirst(this, DataInfoBox, "dinf");
    };
    prototype.getStbl = function() {
        return NodeBox.findFirst(this, NodeBox, "stbl");
    };
}, {boxes: {name: "List", arguments: ["Box"]}, factory: "IBoxFactory", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Quicktime time conversion utilities
 *  
 *  @author The JCodec project
 *  
 */
var QTTimeUtil = function() {};
QTTimeUtil = stjs.extend(QTTimeUtil, null, [], function(constructor, prototype) {
    /**
     *  Calculates track duration considering edits
     *  
     *  @param track
     *  @return
     */
    constructor.getEditedDuration = function(track) {
        var edits = track.getEdits();
        if (edits == null) 
            return track.getDuration();
        var duration = 0;
        for (var iterator$edit = edits.iterator(); iterator$edit.hasNext(); ) {
            var edit = iterator$edit.next();
            duration += edit.getDuration();
        }
        return duration;
    };
    /**
     *  Finds timevalue of a frame number
     *  
     *  might be an expensive operation sinse it traverses compressed time to
     *  sample table
     *  
     *  @param frameNumber
     *  @return
     */
    constructor.frameToTimevalue = function(trak, frameNumber) {
        var stts = NodeBox.findFirstPath(trak, TimeToSampleBox, Box.path("mdia.minf.stbl.stts"));
        var timeToSamples = stts.getEntries();
        var pts = 0;
        var sttsInd = 0, sttsSubInd = frameNumber;
         while (sttsSubInd >= timeToSamples[sttsInd].getSampleCount()){
            sttsSubInd -= timeToSamples[sttsInd].getSampleCount();
            pts += timeToSamples[sttsInd].getSampleCount() * timeToSamples[sttsInd].getSampleDuration();
            sttsInd++;
        }
        return pts + timeToSamples[sttsInd].getSampleDuration() * sttsSubInd;
    };
    /**
     *  Finds frame by timevalue
     *  
     *  @param tv
     *  @return
     */
    constructor.timevalueToFrame = function(trak, tv) {
        var tts = NodeBox.findFirstPath(trak, TimeToSampleBox, Box.path("mdia.minf.stbl.stts")).getEntries();
        var frame = 0;
        for (var i = 0; tv > 0 && i < tts.length; i++) {
            var rem = stjs.trunc(tv / tts[i].getSampleDuration());
            tv -= tts[i].getSampleCount() * tts[i].getSampleDuration();
            frame += tv > 0 ? tts[i].getSampleCount() : rem;
        }
        return frame;
    };
    /**
     *  Converts media timevalue to edited timevalue
     *  
     *  @param trak
     *  @param mediaTv
     *  @param movieTimescale
     *  @return
     */
    constructor.mediaToEdited = function(trak, mediaTv, movieTimescale) {
        if (trak.getEdits() == null) 
            return mediaTv;
        var accum = 0;
        for (var iterator$edit = trak.getEdits().iterator(); iterator$edit.hasNext(); ) {
            var edit = iterator$edit.next();
            if (mediaTv < edit.getMediaTime()) 
                return accum;
            var duration = trak.rescale(edit.getDuration(), movieTimescale);
            if (edit.getMediaTime() != -1 && (mediaTv >= edit.getMediaTime() && mediaTv < edit.getMediaTime() + duration)) {
                accum += mediaTv - edit.getMediaTime();
                break;
            }
            accum += duration;
        }
        return accum;
    };
    /**
     *  Converts edited timevalue to media timevalue
     *  
     *  @param trak
     *  @param mediaTv
     *  @param movieTimescale
     *  @return
     */
    constructor.editedToMedia = function(trak, editedTv, movieTimescale) {
        if (trak.getEdits() == null) 
            return editedTv;
        var accum = 0;
        for (var iterator$edit = trak.getEdits().iterator(); iterator$edit.hasNext(); ) {
            var edit = iterator$edit.next();
            var duration = trak.rescale(edit.getDuration(), movieTimescale);
            if (accum + duration > editedTv) {
                return edit.getMediaTime() + editedTv - accum;
            }
            accum += duration;
        }
        return accum;
    };
    /**
     *  Calculates frame number as it shows in quicktime player
     *  
     *  @param movie
     *  @param mediaFrameNo
     *  @return
     */
    constructor.qtPlayerFrameNo = function(movie, mediaFrameNo) {
        var videoTrack = movie.getVideoTrack();
        var editedTv = QTTimeUtil.mediaToEdited(videoTrack, QTTimeUtil.frameToTimevalue(videoTrack, mediaFrameNo), movie.getTimescale());
        return QTTimeUtil.tv2QTFrameNo(movie, editedTv);
    };
    constructor.tv2QTFrameNo = function(movie, tv) {
        var videoTrack = movie.getVideoTrack();
        var timecodeTrack = movie.getTimecodeTrack();
        if (timecodeTrack != null && BoxUtil.containsBox2(videoTrack, "tref", "tmcd")) {
            return QTTimeUtil.timevalueToTimecodeFrame(timecodeTrack, new RationalLarge(tv, videoTrack.getTimescale()), movie.getTimescale());
        } else {
            return QTTimeUtil.timevalueToFrame(videoTrack, tv);
        }
    };
    /**
     *  Calculates and formats standard time as in Quicktime player
     *  
     *  @param movie
     *  @param mediaFrameNo
     *  @return
     */
    constructor.qtPlayerTime = function(movie, mediaFrameNo) {
        var videoTrack = movie.getVideoTrack();
        var editedTv = QTTimeUtil.mediaToEdited(videoTrack, QTTimeUtil.frameToTimevalue(videoTrack, mediaFrameNo), movie.getTimescale());
        var sec = (((stjs.trunc(editedTv / videoTrack.getTimescale()))) | 0);
        return String.format("%02d", stjs.trunc(sec / 3600)) + "_" + String.format("%02d", stjs.trunc((sec % 3600) / 60)) + "_" + String.format("%02d", sec % 60);
    };
    /**
     *  Calculates and formats tape timecode as in Quicktime player
     *  
     *  @param timecodeTrack
     *  @param tv
     *  @param startCounter
     *  @return
     *  @throws IOException
     */
    constructor.qtPlayerTimecodeFromMovie = function(movie, timecodeTrack, mediaFrameNo) {
        var videoTrack = movie.getVideoTrack();
        var editedTv = QTTimeUtil.mediaToEdited(videoTrack, QTTimeUtil.frameToTimevalue(videoTrack, mediaFrameNo), movie.getTimescale());
        var tt = timecodeTrack.getBox();
        var ttTimescale = tt.getTimescale();
        var ttTv = QTTimeUtil.editedToMedia(tt, stjs.trunc(editedTv * ttTimescale / videoTrack.getTimescale()), movie.getTimescale());
        return QTTimeUtil.formatTimecode(timecodeTrack.getBox(), timecodeTrack.getStartTimecode() + QTTimeUtil.timevalueToTimecodeFrame(timecodeTrack.getBox(), new RationalLarge(ttTv, ttTimescale), movie.getTimescale()));
    };
    /**
     *  Calculates and formats tape timecode as in Quicktime player
     *  
     *  @param timecodeTrack
     *  @param tv
     *  @param startCounter
     *  @return
     *  @throws IOException
     */
    constructor.qtPlayerTimecode = function(timecodeTrack, tv, movieTimescale) {
        var tt = timecodeTrack.getBox();
        var ttTimescale = tt.getTimescale();
        var ttTv = QTTimeUtil.editedToMedia(tt, tv.multiplyS(ttTimescale), movieTimescale);
        return QTTimeUtil.formatTimecode(timecodeTrack.getBox(), timecodeTrack.getStartTimecode() + QTTimeUtil.timevalueToTimecodeFrame(timecodeTrack.getBox(), new RationalLarge(ttTv, ttTimescale), movieTimescale));
    };
    /**
     *  Converts timevalue to frame number based on timecode track
     *  
     *  @param timecodeTrack
     *  @param tv
     *  @return
     */
    constructor.timevalueToTimecodeFrame = function(timecodeTrack, tv, movieTimescale) {
        var se = timecodeTrack.getSampleEntries()[0];
        return stjs.trunc(((((stjs.trunc(2 * tv.multiplyS(se.getTimescale()) / se.getFrameDuration())) + 1)) | 0) / 2);
    };
    /**
     *  Formats tape timecode based on frame counter
     *  
     *  @param timecodeTrack
     *  @param counter
     *  @return
     */
    constructor.formatTimecode = function(timecodeTrack, counter) {
        var tmcd = NodeBox.findFirstPath(timecodeTrack, TimecodeSampleEntry, Box.path("mdia.minf.stbl.stsd.tmcd"));
        var nf = tmcd.getNumFrames();
        var tc = String.format("%02d", counter % nf);
        counter = stjs.trunc(counter / (nf));
        tc = String.format("%02d", counter % 60) + ":" + tc;
        counter = stjs.trunc(counter / (60));
        tc = String.format("%02d", counter % 60) + ":" + tc;
        counter = stjs.trunc(counter / (60));
        tc = String.format("%02d", counter) + ":" + tc;
        return tc;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var AbstractMP4MuxerTrack = function(trackId, type, timescale) {
    this.curChunk = new ArrayList();
    this.samplesInChunks = new ArrayList();
    this.sampleEntries = new ArrayList();
    this.trackId = trackId;
    this.type = type;
    this.timescale = timescale;
};
AbstractMP4MuxerTrack = stjs.extend(AbstractMP4MuxerTrack, null, [], function(constructor, prototype) {
    prototype.trackId = 0;
    prototype.type = null;
    prototype.timescale = 0;
    prototype.tgtChunkDuration = null;
    prototype.tgtChunkDurationUnit = null;
    prototype.chunkDuration = 0;
    prototype.curChunk = null;
    prototype.samplesInChunks = null;
    prototype.samplesInLastChunk = -1;
    prototype.chunkNo = 0;
    prototype.finished = false;
    prototype.sampleEntries = null;
    prototype.edits = null;
    prototype.name = null;
    prototype.setTgtChunkDuration = function(duration, unit) {
        this.tgtChunkDuration = duration;
        this.tgtChunkDurationUnit = unit;
    };
    prototype.getTrackTotalDuration = function() {};
    prototype.getTimescale = function() {
        return this.timescale;
    };
    prototype.finish = function(mvhd) {};
    prototype.isVideo = function() {
        return this.type == TrackType.VIDEO;
    };
    prototype.isTimecode = function() {
        return this.type == TrackType.TIMECODE;
    };
    prototype.isAudio = function() {
        return this.type == TrackType.SOUND;
    };
    prototype.getDisplayDimensions = function() {
        var width = 0, height = 0;
        if (stjs.isInstanceOf(this.sampleEntries.get(0).constructor, VideoSampleEntry)) {
            var vse = this.sampleEntries.get(0);
            var paspBox = NodeBox.findFirst(vse, PixelAspectExt, PixelAspectExt.fourcc());
            var pasp = paspBox != null ? paspBox.getRational() : new Rational(1, 1);
            width = stjs.trunc(stjs.trunc((pasp.getNum() * vse.getWidth())) / pasp.getDen());
            height = stjs.trunc(vse.getHeight());
        }
        return new Size(width, height);
    };
    prototype.tapt = function(trak) {
        var dd = this.getDisplayDimensions();
        if (this.type == TrackType.VIDEO) {
            var tapt = new NodeBox(new Header("tapt"));
            tapt.add(ClearApertureBox.createClearApertureBox(dd.getWidth(), dd.getHeight()));
            tapt.add(ProductionApertureBox.createProductionApertureBox(dd.getWidth(), dd.getHeight()));
            tapt.add(EncodedPixelBox.createEncodedPixelBox(dd.getWidth(), dd.getHeight()));
            trak.add(tapt);
        }
    };
    prototype.addSampleEntry = function(se) {
        if (this.finished) 
             throw new IllegalStateException("The muxer track has finished muxing");
        this.sampleEntries.add(se);
    };
    prototype.getEntries = function() {
        return this.sampleEntries;
    };
    prototype.setEdits = function(edits) {
        this.edits = edits;
    };
    prototype.putEdits = function(trak) {
        if (this.edits != null) {
            var edts = new NodeBox(new Header("edts"));
            edts.add(EditListBox.createEditListBox(this.edits));
            trak.add(edts);
        }
    };
    prototype.setName = function(name) {
        this.name = name;
    };
    prototype.putName = function(trak) {
        if (this.name != null) {
            var udta = new NodeBox(new Header("udta"));
            udta.add(NameBox.createNameBox(this.name));
            trak.add(udta);
        }
    };
    prototype.mediaHeader = function(minf, type) {
        if (TrackType.VIDEO == type) {
            var vmhd = VideoMediaHeaderBox.createVideoMediaHeaderBox(0, 0, 0, 0);
            vmhd.setFlags(1);
            minf.add(vmhd);
        } else if (TrackType.SOUND == type) {
            var smhd = SoundMediaHeaderBox.createSoundMediaHeaderBox();
            smhd.setFlags(1);
            minf.add(smhd);
        } else if (TrackType.TIMECODE == type) {
            var gmhd = new NodeBox(new Header("gmhd"));
            gmhd.add(GenericMediaInfoBox.createGenericMediaInfoBox());
            var tmcd = new NodeBox(new Header("tmcd"));
            gmhd.add(tmcd);
            tmcd.add(TimecodeMediaInfoBox.createTimecodeMediaInfoBox(((0) << 16 >> 16), ((0) << 16 >> 16), ((12) << 16 >> 16), new Int16Array([0, 0, 0]), new Int16Array([255, 255, 255]), "Lucida Grande"));
            minf.add(gmhd);
        } else {
             throw new UnhandledStateException("Handler " + type.getHandler() + " not supported");
        }
    };
    prototype.addDref = function(minf) {
        var dinf = DataInfoBox.createDataInfoBox();
        minf.add(dinf);
        var dref = DataRefBox.createDataRefBox();
        dinf.add(dref);
        dref.add(Box.LeafBox.createLeafBox(Header.createHeader("alis", 0), ByteBuffer.wrap(new Int8Array([0, 0, 0, 1]))));
    };
}, {type: "TrackType", tgtChunkDuration: "Rational", tgtChunkDurationUnit: {name: "Enum", arguments: ["Unit"]}, curChunk: {name: "List", arguments: ["ByteBuffer"]}, samplesInChunks: {name: "List", arguments: ["SampleToChunkBox.SampleToChunkEntry"]}, sampleEntries: {name: "List", arguments: ["SampleEntry"]}, edits: {name: "List", arguments: ["Edit"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  @author The JCodec project
 */
var AVC1Box = function() {
    VideoSampleEntry.call(this, new Header("avc1"));
};
AVC1Box = stjs.extend(AVC1Box, VideoSampleEntry, [], null, {boxes: {name: "List", arguments: ["Box"]}, factory: "IBoxFactory", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var ChunkReader = function(trakBox) {
    var stts = trakBox.getStts();
    this.tts = stts.getEntries();
    var stco = trakBox.getStco();
    var co64 = trakBox.getCo64();
    this.stsz = trakBox.getStsz();
    var stsc = trakBox.getStsc();
    if (stco != null) 
        this.chunkOffsets = stco.getChunkOffsets();
     else 
        this.chunkOffsets = co64.getChunkOffsets();
    this.sampleToChunk = stsc.getSampleToChunk();
    this.stsd = trakBox.getStsd();
};
ChunkReader = stjs.extend(ChunkReader, null, [], function(constructor, prototype) {
    prototype.curChunk = 0;
    prototype.sampleNo = 0;
    prototype.s2cIndex = 0;
    prototype.ttsInd = 0;
    prototype.ttsSubInd = 0;
    prototype.chunkTv = 0;
    prototype.chunkOffsets = null;
    prototype.sampleToChunk = null;
    prototype.stsz = null;
    prototype.tts = null;
    prototype.stsd = null;
    prototype.hasNext = function() {
        return this.curChunk < this.chunkOffsets.length;
    };
    prototype.next = function() {
        if (this.curChunk >= this.chunkOffsets.length) 
            return null;
        if (this.s2cIndex + 1 < this.sampleToChunk.length && this.curChunk + 1 == this.sampleToChunk[this.s2cIndex + 1].getFirst()) 
            this.s2cIndex++;
        var sampleCount = this.sampleToChunk[this.s2cIndex].getCount();
        var samplesDur = null;
        var sampleDur = 0;
        if (this.ttsSubInd + sampleCount <= this.tts[this.ttsInd].getSampleCount()) {
            sampleDur = this.tts[this.ttsInd].getSampleDuration();
            this.ttsSubInd += sampleCount;
        } else {
            samplesDur = new Int32Array(sampleCount);
            for (var i = 0; i < sampleCount; i++) {
                if (this.ttsSubInd >= this.tts[this.ttsInd].getSampleCount() && this.ttsInd < this.tts.length - 1) {
                    this.ttsSubInd = 0;
                    ++this.ttsInd;
                }
                samplesDur[i] = this.tts[this.ttsInd].getSampleDuration();
                ++this.ttsSubInd;
            }
        }
        var size = 0;
        var sizes = null;
        if (this.stsz.getDefaultSize() > 0) {
            size = this.getFrameSize();
        } else {
            sizes = Platform.copyOfRangeI(this.stsz.getSizes(), this.sampleNo, this.sampleNo + sampleCount);
        }
        var dref = this.sampleToChunk[this.s2cIndex].getEntry();
        var chunk = new Chunk(this.chunkOffsets[this.curChunk], this.chunkTv, sampleCount, size, sizes, sampleDur, samplesDur, dref);
        this.chunkTv += chunk.getDuration();
        this.sampleNo += sampleCount;
        ++this.curChunk;
        return chunk;
    };
    prototype.getFrameSize = function() {
        var size = this.stsz.getDefaultSize();
        var box = this.stsd.getBoxes().get(this.sampleToChunk[this.s2cIndex].getEntry() - 1);
        if (stjs.isInstanceOf(box.constructor, AudioSampleEntry)) {
            return (box).calcFrameSize();
        }
        return size;
    };
    prototype.size = function() {
        return this.chunkOffsets.length;
    };
}, {chunkOffsets: "Array", sampleToChunk: "Array", stsz: "SampleSizesBox", tts: "Array", stsd: "SampleDescriptionBox"}, {});
var SampleBoxes = function() {
    Boxes.call(this);
    this.clear();
    this.override("ap4h", VideoSampleEntry);
    this.override("apch", VideoSampleEntry);
    this.override("apcn", VideoSampleEntry);
    this.override("apcs", VideoSampleEntry);
    this.override("apco", VideoSampleEntry);
    this.override("avc1", VideoSampleEntry);
    this.override("cvid", VideoSampleEntry);
    this.override("jpeg", VideoSampleEntry);
    this.override("smc ", VideoSampleEntry);
    this.override("rle ", VideoSampleEntry);
    this.override("rpza", VideoSampleEntry);
    this.override("kpcd", VideoSampleEntry);
    this.override("png ", VideoSampleEntry);
    this.override("mjpa", VideoSampleEntry);
    this.override("mjpb", VideoSampleEntry);
    this.override("SVQ1", VideoSampleEntry);
    this.override("SVQ3", VideoSampleEntry);
    this.override("mp4v", VideoSampleEntry);
    this.override("dvc ", VideoSampleEntry);
    this.override("dvcp", VideoSampleEntry);
    this.override("gif ", VideoSampleEntry);
    this.override("h263", VideoSampleEntry);
    this.override("tiff", VideoSampleEntry);
    this.override("raw ", VideoSampleEntry);
    this.override("2vuY", VideoSampleEntry);
    this.override("yuv2", VideoSampleEntry);
    this.override("v308", VideoSampleEntry);
    this.override("v408", VideoSampleEntry);
    this.override("v216", VideoSampleEntry);
    this.override("v410", VideoSampleEntry);
    this.override("v210", VideoSampleEntry);
    this.override("m2v1", VideoSampleEntry);
    this.override("m1v1", VideoSampleEntry);
    this.override("xd5b", VideoSampleEntry);
    this.override("dv5n", VideoSampleEntry);
    this.override("jp2h", VideoSampleEntry);
    this.override("mjp2", VideoSampleEntry);
    this.override("ac-3", AudioSampleEntry);
    this.override("cac3", AudioSampleEntry);
    this.override("ima4", AudioSampleEntry);
    this.override("aac ", AudioSampleEntry);
    this.override("celp", AudioSampleEntry);
    this.override("hvxc", AudioSampleEntry);
    this.override("twvq", AudioSampleEntry);
    this.override(".mp1", AudioSampleEntry);
    this.override(".mp2", AudioSampleEntry);
    this.override("midi", AudioSampleEntry);
    this.override("apvs", AudioSampleEntry);
    this.override("alac", AudioSampleEntry);
    this.override("aach", AudioSampleEntry);
    this.override("aacl", AudioSampleEntry);
    this.override("aace", AudioSampleEntry);
    this.override("aacf", AudioSampleEntry);
    this.override("aacp", AudioSampleEntry);
    this.override("aacs", AudioSampleEntry);
    this.override("samr", AudioSampleEntry);
    this.override("AUDB", AudioSampleEntry);
    this.override("ilbc", AudioSampleEntry);
    this.override(Platform.stringFromBytes(new Int8Array([109, 115, 0, 17])), AudioSampleEntry);
    this.override(Platform.stringFromBytes(new Int8Array([109, 115, 0, 49])), AudioSampleEntry);
    this.override("aes3", AudioSampleEntry);
    this.override("NONE", AudioSampleEntry);
    this.override("raw ", AudioSampleEntry);
    this.override("twos", AudioSampleEntry);
    this.override("sowt", AudioSampleEntry);
    this.override("MAC3 ", AudioSampleEntry);
    this.override("MAC6 ", AudioSampleEntry);
    this.override("ima4", AudioSampleEntry);
    this.override("fl32", AudioSampleEntry);
    this.override("fl64", AudioSampleEntry);
    this.override("in24", AudioSampleEntry);
    this.override("in32", AudioSampleEntry);
    this.override("ulaw", AudioSampleEntry);
    this.override("alaw", AudioSampleEntry);
    this.override("dvca", AudioSampleEntry);
    this.override("QDMC", AudioSampleEntry);
    this.override("QDM2", AudioSampleEntry);
    this.override("Qclp", AudioSampleEntry);
    this.override(".mp3", AudioSampleEntry);
    this.override("mp4a", AudioSampleEntry);
    this.override("lpcm", AudioSampleEntry);
    this.override("tmcd", TimecodeSampleEntry);
    this.override("time", TimecodeSampleEntry);
    this.override("c608", SampleEntry);
    this.override("c708", SampleEntry);
    this.override("text", SampleEntry);
};
SampleBoxes = stjs.extend(SampleBoxes, Boxes, [], null, {mappings: {name: "Map", arguments: [null, {name: "Class", arguments: ["Object"]}]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MXFConst = function() {};
MXFConst = stjs.extend(MXFConst, null, [], function(constructor, prototype) {
    constructor.HEADER_PARTITION_KLV = UL.newUL(6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2);
    constructor.INDEX_KLV = UL.newUL(6, 14, 43, 52, 2, 83, 1, 1, 13, 1, 2, 1, 1, 16, 1, 0);
    constructor.GENERIC_DESCRIPTOR_KLV = UL.newUL(6, 14, 43, 52, 2, 83, 1, 1, 13, 1, 1, 1, 1, 1);
    constructor.MXFCodecMapping = function(ul, codec) {
        this.ul = ul;
        this.codec = codec;
        MXFConst.MXFCodecMapping._values.add(this);
    };
    constructor.MXFCodecMapping = stjs.extend(constructor.MXFCodecMapping, null, [], function(constructor, prototype) {
        constructor._values = new ArrayList();
        constructor.MPEG2_XDCAM = new MXFConst.MXFCodecMapping(UL.newUL(6, 14, 43, 52, 4, 1, 1, 3, 4, 1, 2, 2, 1, 4, 3, 0), Codec.MPEG2);
        constructor.MPEG2_ML = new MXFConst.MXFCodecMapping(UL.newUL(6, 14, 43, 52, 4, 1, 1, 3, 4, 1, 2, 2, 1, 1, 17, 0), Codec.MPEG2);
        constructor.MPEG2_D10_PAL = new MXFConst.MXFCodecMapping(UL.newUL(6, 14, 43, 52, 4, 1, 1, 1, 4, 1, 2, 2, 1, 2, 1, 1), Codec.MPEG2);
        constructor.MPEG2_HL = new MXFConst.MXFCodecMapping(UL.newUL(6, 14, 43, 52, 4, 1, 1, 3, 4, 1, 2, 2, 1, 3, 3, 0), Codec.MPEG2);
        constructor.MPEG2_HL_422_I = new MXFConst.MXFCodecMapping(UL.newUL(6, 14, 43, 52, 4, 1, 1, 3, 4, 1, 2, 2, 1, 4, 2, 0), Codec.MPEG2);
        constructor.MPEG4_XDCAM_PROXY = new MXFConst.MXFCodecMapping(UL.newUL(6, 14, 43, 52, 4, 1, 1, 3, 4, 1, 2, 2, 1, 32, 2, 3), Codec.MPEG4);
        constructor.DV_25_PAL = new MXFConst.MXFCodecMapping(UL.newUL(6, 14, 43, 52, 4, 1, 1, 1, 4, 1, 2, 2, 2, 1, 2, 0), Codec.DV);
        constructor.JPEG2000 = new MXFConst.MXFCodecMapping(UL.newUL(6, 14, 43, 52, 4, 1, 1, 7, 4, 1, 2, 2, 3, 1, 1, 0), Codec.J2K);
        constructor.RAW = new MXFConst.MXFCodecMapping(UL.newUL(6, 14, 43, 52, 4, 1, 1, 1, 4, 1, 2, 1, 127, 0, 0, 0), null);
        constructor.VC3_DNXD = new MXFConst.MXFCodecMapping(UL.newUL(6, 14, 43, 52, 4, 1, 1, 1, 4, 1, 2, 2, 3, 2, 0, 0), Codec.VC3);
        constructor.AVC_INTRA = new MXFConst.MXFCodecMapping(UL.newUL(6, 14, 43, 52, 4, 1, 1, 10, 4, 1, 2, 2, 1, 50, 0, 0), Codec.H264);
        constructor.V210 = new MXFConst.MXFCodecMapping(UL.newUL(6, 14, 43, 52, 4, 1, 1, 10, 4, 1, 2, 1, 1, 2, 2, 0), Codec.V210);
        constructor.PCM_S16LE_1 = new MXFConst.MXFCodecMapping(UL.newUL(6, 14, 43, 52, 4, 1, 1, 1, 4, 2, 2, 1, 0), null);
        constructor.PCM_S16LE_3 = new MXFConst.MXFCodecMapping(UL.newUL(6, 14, 43, 52, 4, 1, 1, 1, 4, 2, 2, 1, 1), null);
        constructor.PCM_S16LE_2 = new MXFConst.MXFCodecMapping(UL.newUL(6, 14, 43, 52, 4, 1, 1, 1, 4, 2, 2, 1, 127), null);
        constructor.PCM_S16BE = new MXFConst.MXFCodecMapping(UL.newUL(6, 14, 43, 52, 4, 1, 1, 7, 4, 2, 2, 1, 126), null);
        constructor.PCM_ALAW = new MXFConst.MXFCodecMapping(UL.newUL(6, 14, 43, 52, 4, 1, 1, 4, 4, 2, 2, 2, 3, 1, 1, 0), Codec.ALAW);
        constructor.AC3 = new MXFConst.MXFCodecMapping(UL.newUL(6, 14, 43, 52, 4, 1, 1, 1, 4, 2, 2, 2, 3, 2, 1, 0), Codec.AC3);
        constructor.MP2 = new MXFConst.MXFCodecMapping(UL.newUL(6, 14, 43, 52, 4, 1, 1, 1, 4, 2, 2, 2, 3, 2, 5, 0), Codec.MP3);
        prototype.ul = null;
        prototype.codec = null;
        prototype.getUl = function() {
            return this.ul;
        };
        prototype.getCodec = function() {
            return this.codec;
        };
        constructor.values = function() {
            return MXFConst.MXFCodecMapping._values.toArray(Array(0));
        };
    }, {_values: {name: "List", arguments: ["MXFConst.MXFCodecMapping"]}, MPEG2_XDCAM: "MXFConst.MXFCodecMapping", MPEG2_ML: "MXFConst.MXFCodecMapping", MPEG2_D10_PAL: "MXFConst.MXFCodecMapping", MPEG2_HL: "MXFConst.MXFCodecMapping", MPEG2_HL_422_I: "MXFConst.MXFCodecMapping", MPEG4_XDCAM_PROXY: "MXFConst.MXFCodecMapping", DV_25_PAL: "MXFConst.MXFCodecMapping", JPEG2000: "MXFConst.MXFCodecMapping", RAW: "MXFConst.MXFCodecMapping", VC3_DNXD: "MXFConst.MXFCodecMapping", AVC_INTRA: "MXFConst.MXFCodecMapping", V210: "MXFConst.MXFCodecMapping", PCM_S16LE_1: "MXFConst.MXFCodecMapping", PCM_S16LE_3: "MXFConst.MXFCodecMapping", PCM_S16LE_2: "MXFConst.MXFCodecMapping", PCM_S16BE: "MXFConst.MXFCodecMapping", PCM_ALAW: "MXFConst.MXFCodecMapping", AC3: "MXFConst.MXFCodecMapping", MP2: "MXFConst.MXFCodecMapping", ul: "UL", codec: {name: "Enum", arguments: ["Codec"]}}, {});
    constructor.klMetadataMapping = new HashMap();
    constructor.KLVFill = function(ul) {
        MXFMetadata.call(this, ul);
    };
    constructor.KLVFill = stjs.extend(constructor.KLVFill, MXFMetadata, [], function(constructor, prototype) {
        prototype.readBuf = function(bb) {};
    }, {ul: "UL", uid: "UL"}, {});
}, {HEADER_PARTITION_KLV: "UL", INDEX_KLV: "UL", GENERIC_DESCRIPTOR_KLV: "UL", klMetadataMapping: {name: "Map", arguments: ["UL", {name: "Class", arguments: ["Object"]}]}}, {});
(function() {
    MXFConst.klMetadataMapping.put(UL.newUL(6, 14, 43, 52, 2, 83, 1, 1, 13, 1, 1, 1, 1, 1, 24, 0), ContentStorage);
    MXFConst.klMetadataMapping.put(UL.newUL(6, 14, 43, 52, 2, 83, 1, 1, 13, 1, 1, 1, 1, 1, 55, 0), SourcePackage);
    MXFConst.klMetadataMapping.put(UL.newUL(6, 14, 43, 52, 2, 83, 1, 1, 13, 1, 1, 1, 1, 1, 15, 0), Sequence);
    MXFConst.klMetadataMapping.put(UL.newUL(6, 14, 43, 52, 2, 83, 1, 1, 13, 1, 1, 1, 1, 1, 47, 0), Preface);
    MXFConst.klMetadataMapping.put(UL.newUL(6, 14, 43, 52, 2, 83, 1, 1, 13, 1, 1, 1, 1, 1, 48, 0), Identification);
    MXFConst.klMetadataMapping.put(UL.newUL(6, 14, 43, 52, 2, 83, 1, 1, 13, 1, 1, 1, 1, 1, 17, 0), SourceClip);
    MXFConst.klMetadataMapping.put(UL.newUL(6, 14, 43, 52, 2, 83, 1, 1, 13, 1, 1, 1, 1, 1, 35, 0), EssenceContainerData);
    MXFConst.klMetadataMapping.put(UL.newUL(6, 14, 43, 52, 2, 83, 1, 1, 13, 1, 1, 1, 1, 1, 58, 0), TimelineTrack);
    MXFConst.klMetadataMapping.put(UL.newUL(6, 14, 43, 52, 2, 83, 1, 1, 13, 1, 1, 1, 1, 1, 59, 0), TimelineTrack);
    MXFConst.klMetadataMapping.put(UL.newUL(6, 14, 43, 52, 2, 83, 1, 1, 13, 1, 1, 1, 1, 1, 54, 0), MaterialPackage);
    MXFConst.klMetadataMapping.put(UL.newUL(6, 14, 43, 52, 2, 83, 1, 1, 13, 1, 2, 1, 1, 16, 1, 0), IndexSegment);
    MXFConst.klMetadataMapping.put(UL.newUL(6, 14, 43, 52, 2, 83, 1, 1, 13, 1, 1, 1, 1, 1, 68, 0), GenericDescriptor);
    MXFConst.klMetadataMapping.put(UL.newUL(6, 14, 43, 52, 2, 83, 1, 1, 13, 1, 1, 1, 1, 1, 91, 0), GenericDataEssenceDescriptor);
    MXFConst.klMetadataMapping.put(UL.newUL(6, 14, 43, 52, 2, 83, 1, 1, 13, 1, 1, 1, 1, 1, 91, 0), GenericDataEssenceDescriptor);
    MXFConst.klMetadataMapping.put(UL.newUL(6, 14, 43, 52, 2, 83, 1, 1, 13, 1, 1, 1, 1, 1, 92, 0), GenericDataEssenceDescriptor);
    MXFConst.klMetadataMapping.put(UL.newUL(6, 14, 43, 52, 2, 83, 1, 1, 13, 1, 1, 1, 1, 1, 67, 0), GenericDataEssenceDescriptor);
    MXFConst.klMetadataMapping.put(UL.newUL(6, 14, 43, 52, 2, 83, 1, 1, 13, 1, 1, 1, 1, 1, 66, 0), GenericSoundEssenceDescriptor);
    MXFConst.klMetadataMapping.put(UL.newUL(6, 14, 43, 52, 2, 83, 1, 1, 13, 1, 1, 1, 1, 1, 40, 0), CDCIEssenceDescriptor);
    MXFConst.klMetadataMapping.put(UL.newUL(6, 14, 43, 52, 2, 83, 1, 1, 13, 1, 1, 1, 1, 1, 41, 0), RGBAEssenceDescriptor);
    MXFConst.klMetadataMapping.put(UL.newUL(6, 14, 43, 52, 2, 83, 1, 1, 13, 1, 1, 1, 1, 1, 81, 0), MPEG2VideoDescriptor);
    MXFConst.klMetadataMapping.put(UL.newUL(6, 14, 43, 52, 2, 83, 1, 1, 13, 1, 1, 1, 1, 1, 72, 0), WaveAudioDescriptor);
    MXFConst.klMetadataMapping.put(UL.newUL(6, 14, 43, 52, 2, 83, 1, 1, 13, 1, 1, 1, 1, 1, 37, 0), FileDescriptor);
    MXFConst.klMetadataMapping.put(UL.newUL(6, 14, 43, 52, 2, 83, 1, 1, 13, 1, 1, 1, 1, 1, 39, 0), GenericPictureEssenceDescriptor);
    MXFConst.klMetadataMapping.put(UL.newUL(6, 14, 43, 52, 2, 83, 1, 1, 13, 1, 1, 1, 1, 1, 71, 0), AES3PCMDescriptor);
    MXFConst.klMetadataMapping.put(UL.newUL(6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 5, 1, 0), MXFPartitionPack);
    MXFConst.klMetadataMapping.put(UL.newUL(6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2, 1, 0), MXFPartitionPack);
    MXFConst.klMetadataMapping.put(UL.newUL(6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2, 2, 0), MXFPartitionPack);
    MXFConst.klMetadataMapping.put(UL.newUL(6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2, 3, 0), MXFPartitionPack);
    MXFConst.klMetadataMapping.put(UL.newUL(6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2, 4, 0), MXFPartitionPack);
    MXFConst.klMetadataMapping.put(UL.newUL(6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 3, 1, 0), MXFPartitionPack);
    MXFConst.klMetadataMapping.put(UL.newUL(6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 3, 2, 0), MXFPartitionPack);
    MXFConst.klMetadataMapping.put(UL.newUL(6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 3, 3, 0), MXFPartitionPack);
    MXFConst.klMetadataMapping.put(UL.newUL(6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 3, 4, 0), MXFPartitionPack);
    MXFConst.klMetadataMapping.put(UL.newUL(6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 4, 2, 0), MXFPartitionPack);
    MXFConst.klMetadataMapping.put(UL.newUL(6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 4, 4, 0), MXFPartitionPack);
    MXFConst.klMetadataMapping.put(UL.newUL(6, 14, 43, 52, 2, 83, 1, 1, 13, 1, 1, 1, 1, 1, 20, 0), TimecodeComponent);
    MXFConst.klMetadataMapping.put(UL.newUL(6, 14, 43, 52, 1, 1, 1, 2, 3, 1, 2, 16, 1, 0, 0, 0), MXFConst.KLVFill);
    MXFConst.klMetadataMapping.put(UL.newUL(6, 14, 43, 52, 2, 83, 1, 1, 13, 1, 1, 1, 1, 1, 90, 0), J2KPictureDescriptor);
})();
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MediaBox = function(atom) {
    NodeBox.call(this, atom);
};
MediaBox = stjs.extend(MediaBox, NodeBox, [], function(constructor, prototype) {
    constructor.fourcc = function() {
        return "mdia";
    };
    constructor.createMediaBox = function() {
        return new MediaBox(new Header(MediaBox.fourcc()));
    };
    prototype.getMinf = function() {
        return NodeBox.findFirst(this, MediaInfoBox, "minf");
    };
}, {boxes: {name: "List", arguments: ["Box"]}, factory: "IBoxFactory", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Timecode track, provides timecode information for video track
 *  
 *  @author The JCodec project
 *  
 */
var TimecodeMP4DemuxerTrack = function(movie, trak, input) {
    this.box = trak;
    this.input = input;
    this.movie = movie;
    var stbl = trak.getMdia().getMinf().getStbl();
    var stts = NodeBox.findFirst(stbl, TimeToSampleBox, "stts");
    var stsc = NodeBox.findFirst(stbl, SampleToChunkBox, "stsc");
    var stco = NodeBox.findFirst(stbl, ChunkOffsetsBox, "stco");
    var co64 = NodeBox.findFirst(stbl, ChunkOffsets64Box, "co64");
    this.timeToSamples = stts.getEntries();
    this.chunkOffsets = stco != null ? stco.getChunkOffsets() : co64.getChunkOffsets();
    this.sampleToChunks = stsc.getSampleToChunk();
    if (this.chunkOffsets.length == 1) {
        this.cacheSamples(this.sampleToChunks, this.chunkOffsets);
    }
    this.tse = this.box.getSampleEntries()[0];
};
TimecodeMP4DemuxerTrack = stjs.extend(TimecodeMP4DemuxerTrack, null, [], function(constructor, prototype) {
    prototype.box = null;
    prototype.timeToSamples = null;
    prototype.sampleCache = null;
    prototype.tse = null;
    prototype.input = null;
    prototype.movie = null;
    prototype.chunkOffsets = null;
    prototype.sampleToChunks = null;
    prototype.getTimecode = function(pkt) {
        var tv = QTTimeUtil.editedToMedia(this.box, this.box.rescale(pkt.getPts(), pkt.getTimescale()), this.movie.getTimescale());
        var sample;
        var ttsInd = 0, ttsSubInd = 0;
        for (sample = 0; sample < this.sampleCache.length - 1; sample++) {
            var dur = this.timeToSamples[ttsInd].getSampleDuration();
            if (tv < dur) 
                break;
            tv -= dur;
            ttsSubInd++;
            if (ttsInd < this.timeToSamples.length - 1 && ttsSubInd >= this.timeToSamples[ttsInd].getSampleCount()) 
                ttsInd++;
        }
        var frameNo = stjs.trunc(((((stjs.trunc((stjs.trunc((2 * tv * this.tse.getTimescale()) / this.box.getTimescale())) / this.tse.getFrameDuration())) + 1)) | 0) / 2);
        return MP4Packet.createMP4PacketWithTimecode(pkt, this._getTimecode(this.getTimecodeSample(sample), frameNo, this.tse));
    };
    prototype.getTimecodeSample = function(sample) {
        if (this.sampleCache != null) 
            return this.sampleCache[sample];
         else {
            {
                var stscInd, stscSubInd;
                for (stscInd = 0 , stscSubInd = sample; stscInd < this.sampleToChunks.length && stscSubInd >= this.sampleToChunks[stscInd].getCount(); stscSubInd -= this.sampleToChunks[stscInd].getCount() , stscInd++) 
                    ;
                var offset = this.chunkOffsets[stscInd] + (Math.min(stscSubInd, this.sampleToChunks[stscInd].getCount() - 1) << 2);
                if (this.input.position() != offset) 
                    this.input.setPosition(offset);
                var buf = NIOUtils.fetchFromChannel(this.input, 4);
                return buf.getInt();
            }}
    };
    prototype._getTimecode = function(startCounter, frameNo, entry) {
        var frame = this.dropFrameAdjust(frameNo + startCounter, entry);
        var sec = stjs.trunc(frame / entry.getNumFrames());
        return new TapeTimecode((((stjs.trunc(sec / 3600))) << 16 >> 16), (((stjs.trunc(sec / 60)) % 60) << 24 >> 24), ((sec % 60) << 24 >> 24), ((frame % entry.getNumFrames()) << 24 >> 24), entry.isDropFrame());
    };
    prototype.dropFrameAdjust = function(frame, entry) {
        if (entry.isDropFrame()) {
            var D = stjs.trunc(frame / 17982);
            var M = frame % 17982;
            frame += 18 * D + 2 * (stjs.trunc((M - 2) / 1798));
        }
        return frame;
    };
    prototype.cacheSamples = function(sampleToChunks, chunkOffsets) {
        {
            var stscInd = 0;
            var ss = IntArrayList.createIntArrayList();
            for (var chunkNo = 0; chunkNo < chunkOffsets.length; chunkNo++) {
                var nSamples = sampleToChunks[stscInd].getCount();
                if (stscInd < sampleToChunks.length - 1 && chunkNo + 1 >= sampleToChunks[stscInd + 1].getFirst()) 
                    stscInd++;
                var offset = chunkOffsets[chunkNo];
                this.input.setPosition(offset);
                var buf = NIOUtils.fetchFromChannel(this.input, nSamples * 4);
                for (var i = 0; i < nSamples; i++) {
                    ss.add(buf.getInt());
                }
            }
            this.sampleCache = ss.toArray();
        }};
    /**
     *  
     *  @return
     *  @throws IOException 
     *  @deprecated Use getTimecode to automatically populate tape timecode for
     *              each frame
     */
    prototype.getStartTimecode = function() {
        return this.getTimecodeSample(0);
    };
    prototype.getBox = function() {
        return this.box;
    };
    prototype.parseTimecode = function(tc) {
        var split = tc.split(":");
        var tmcd = NodeBox.findFirstPath(this.box, TimecodeSampleEntry, Box.path("mdia.minf.stbl.stsd.tmcd"));
        var nf = tmcd.getNumFrames();
        return Integer.parseInt(split[3]) + Integer.parseInt(split[2]) * nf + Integer.parseInt(split[1]) * 60 * nf + Integer.parseInt(split[0]) * 3600 * nf;
    };
    prototype.timeCodeToFrameNo = function(timeCode) {
        if (TimecodeMP4DemuxerTrack.isValidTimeCode(timeCode)) {
            var movieFrame = this.parseTimecode(timeCode.trim()) - this.sampleCache[0];
            var frameRate = this.tse.getNumFrames();
            var framesInTimescale = movieFrame * this.tse.getTimescale();
            var mediaToEdited = QTTimeUtil.mediaToEdited(this.box, stjs.trunc(framesInTimescale / frameRate), this.movie.getTimescale()) * frameRate;
            return (((stjs.trunc(mediaToEdited / this.box.getTimescale()))) | 0);
        }
        return -1;
    };
    constructor.isValidTimeCode = function(input) {
        var p = Pattern.compile("[0-9][0-9]:[0-5][0-9]:[0-5][0-9]:[0-2][0-9]");
        var m = p.matcher(input);
        if (input != null && !input.trim().equals("") && m.matches()) {
            return true;
        }
        return false;
    };
}, {box: "TrakBox", timeToSamples: "Array", sampleCache: "Int32Array", tse: "TimecodeSampleEntry", input: "SeekableByteChannel", movie: "MovieBox", chunkOffsets: "Array", sampleToChunks: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  MXF demuxer
 *  
 *  @author The JCodec project
 *  
 */
var MXFDemuxer = function(ch) {
    this.ch = ch;
    ch.setPosition(0);
    this.parseHeader(ch);
    this.findIndex();
    this.tracks = this.findTracks();
    this.timecode = MXFUtil.findMeta(this.metadata, TimecodeComponent);
};
MXFDemuxer = stjs.extend(MXFDemuxer, null, [], function(constructor, prototype) {
    prototype.metadata = null;
    prototype.header = null;
    prototype.partitions = null;
    prototype.indexSegments = null;
    prototype.ch = null;
    prototype.tracks = null;
    prototype.totalFrames = 0;
    prototype.duration = 0.0;
    prototype.timecode = null;
    constructor.OP = function(major, minor) {
        this.major = major;
        this.minor = minor;
    };
    constructor.OP = stjs.extend(constructor.OP, null, [], function(constructor, prototype) {
        constructor.OP1a = new MXFDemuxer.OP(1, 1);
        constructor.OP1b = new MXFDemuxer.OP(1, 2);
        constructor.OP1c = new MXFDemuxer.OP(1, 3);
        constructor.OP2a = new MXFDemuxer.OP(2, 1);
        constructor.OP2b = new MXFDemuxer.OP(2, 2);
        constructor.OP2c = new MXFDemuxer.OP(2, 3);
        constructor.OP3a = new MXFDemuxer.OP(3, 1);
        constructor.OP3b = new MXFDemuxer.OP(3, 2);
        constructor.OP3c = new MXFDemuxer.OP(3, 3);
        constructor.OPAtom = new MXFDemuxer.OP(16, 0);
        constructor._values = [MXFDemuxer.OP.OP1a, MXFDemuxer.OP.OP1b, MXFDemuxer.OP.OP1c, MXFDemuxer.OP.OP2a, MXFDemuxer.OP.OP2b, MXFDemuxer.OP.OP2c, MXFDemuxer.OP.OP3a, MXFDemuxer.OP.OP3b, MXFDemuxer.OP.OP3c, MXFDemuxer.OP.OPAtom];
        prototype.major = 0;
        prototype.minor = 0;
        constructor.values = function() {
            return MXFDemuxer.OP._values;
        };
    }, {OP1a: "MXFDemuxer.OP", OP1b: "MXFDemuxer.OP", OP1c: "MXFDemuxer.OP", OP2a: "MXFDemuxer.OP", OP2b: "MXFDemuxer.OP", OP2c: "MXFDemuxer.OP", OP3a: "MXFDemuxer.OP", OP3b: "MXFDemuxer.OP", OP3c: "MXFDemuxer.OP", OPAtom: "MXFDemuxer.OP", _values: "Array"}, {});
    prototype.getOp = function() {
        var op = this.header.getPack().getOp();
        var values = MXFDemuxer.OP.values();
        for (var i = 0; i < values.length; i++) {
            var op2 = values[i];
            if (op.get(12) == op2.major && op.get(13) == op2.minor) 
                return op2;
        }
        return MXFDemuxer.OP.OPAtom;
    };
    prototype.findTracks = function() {
        var rt = new ArrayList();
        var tracks = MXFUtil.findAllMeta(this.metadata, TimelineTrack);
        var descriptors = MXFUtil.findAllMeta(this.metadata, FileDescriptor);
        for (var iterator$track = tracks.iterator(); iterator$track.hasNext(); ) {
            var track = iterator$track.next();
            if (track.getTrackNumber() != 0) {
                var trackNumber = track.getTrackNumber();
                var descriptor = MXFDemuxer.findDescriptor(descriptors, track.getTrackId());
                if (descriptor == null) {
                    jcodec.Logger.warn("No generic descriptor for track: " + track.getTrackId());
                    if (descriptors.size() == 1 && descriptors.get(0).getLinkedTrackId() == 0) {
                        descriptor = descriptors.get(0);
                    }
                }
                if (descriptor == null) {
                    jcodec.Logger.warn("Track without descriptor: " + track.getTrackId());
                    continue;
                }
                var dt = this.createTrack(UL.newUL(6, 14, 43, 52, 1, 2, 1, 1, 13, 1, 3, 1, (trackNumber >>> 24) & 255, (trackNumber >>> 16) & 255, (trackNumber >>> 8) & 255, trackNumber & 255), track, descriptor);
                if (dt.getCodec() != null || (stjs.isInstanceOf(descriptor.constructor, WaveAudioDescriptor))) 
                    rt.add(dt);
            }
        }
        return rt.toArray(Array(0));
    };
    constructor.findDescriptor = function(descriptors, trackId) {
        for (var iterator$descriptor = descriptors.iterator(); iterator$descriptor.hasNext(); ) {
            var descriptor = iterator$descriptor.next();
            if (descriptor.getLinkedTrackId() == trackId) {
                return descriptor;
            }
        }
        return null;
    };
    prototype.createTrack = function(ul, track, descriptor) {
        return new MXFDemuxer.MXFDemuxerTrack(this, ul, track, descriptor);
    };
    prototype.getIndexes = function() {
        return this.indexSegments;
    };
    prototype.getEssencePartitions = function() {
        return this.partitions;
    };
    prototype.getTimecode = function() {
        return this.timecode;
    };
    prototype.parseHeader = function(ff) {
        var kl;
        this.header = MXFDemuxer.readHeaderPartition(ff);
        this.metadata = new ArrayList();
        this.partitions = new ArrayList();
        var nextPartition = ff.size();
        ff.setPosition(this.header.getPack().getFooterPartition());
        do {
            var thisPartition = ff.position();
            kl = KLV.readKL(ff);
            var fetchFrom = NIOUtils.fetchFromChannel(ff, ((kl.len) | 0));
            this.header = MXFPartition.read(kl.key, fetchFrom, ff.position() - kl.offset, nextPartition);
            if (this.header.getPack().getNbEssenceContainers() > 0) 
                this.partitions.add(0, this.header);
            this.metadata.addAllAt(0, MXFDemuxer.readPartitionMeta(ff, this.header));
            ff.setPosition(this.header.getPack().getPrevPartition());
            nextPartition = thisPartition;
        } while (this.header.getPack().getThisPartition() != 0);
    };
    constructor.readPartitionMeta = function(ff, header) {
        var kl;
        var basePos = ff.position();
        var local = new ArrayList();
        var metaBuffer = NIOUtils.fetchFromChannel(ff, ((Math.max(0, header.getEssenceFilePos() - basePos)) | 0));
         while (metaBuffer.hasRemaining() && (kl = KLV.readKLFromBuffer(metaBuffer, basePos)) != null){
            var meta = MXFDemuxer.parseMeta(kl.key, NIOUtils.read(metaBuffer, ((kl.len) | 0)));
            if (meta != null) 
                local.add(meta);
        }
        return local;
    };
    constructor.readHeaderPartition = function(ff) {
        var kl;
        var header = null;
         while ((kl = KLV.readKL(ff)) != null){
            if (MXFConst.HEADER_PARTITION_KLV.equals(kl.key)) {
                var data = NIOUtils.fetchFromChannel(ff, ((kl.len) | 0));
                header = MXFPartition.read(kl.key, data, ff.position() - kl.offset, 0);
                break;
            } else {
                ff.setPosition(ff.position() + kl.len);
            }
        }
        return header;
    };
    constructor.parseMeta = function(ul, _bb) {
        var class1 = MXFConst.klMetadataMapping.get(ul);
        if (class1 == null) {
            jcodec.Logger.warn("Unknown metadata piece: " + ul);
            return null;
        }
        try {
            var meta = class1.getConstructor(UL).newInstance(ul);
            meta.readBuf(_bb);
            return meta;
        }catch (e) {}
        jcodec.Logger.warn("Unknown metadata piece: " + ul);
        return null;
    };
    prototype.findIndex = function() {
        this.indexSegments = new ArrayList();
        for (var iterator$meta = this.metadata.iterator(); iterator$meta.hasNext(); ) {
            var meta = iterator$meta.next();
            if (stjs.isInstanceOf(meta.constructor, IndexSegment)) {
                var is = meta;
                this.indexSegments.add(is);
                this.totalFrames += is.getIndexDuration();
                this.duration += (is.getIndexEditRateDen() * is.getIndexDuration()) / is.getIndexEditRateNum();
            }
        }
    };
    prototype.getTracks = function() {
        return this.tracks;
    };
    prototype.getVideoTrack = function() {
        for (var track in this.tracks) {
            if (track.isVideo()) 
                return track;
        }
        return null;
    };
    prototype.getAudioTracks = function() {
        var audio = new ArrayList();
        for (var track in this.tracks) {
            if (track.isAudio()) 
                audio.add(track);
        }
        return audio.toArray(Array(0));
    };
    constructor.MXFDemuxerTrack = function(demuxer, essenceUL, track, descriptor) {
        this.demuxer = demuxer;
        this.essenceUL = essenceUL;
        this.track = track;
        this.descriptor = descriptor;
        if (stjs.isInstanceOf(descriptor.constructor, GenericPictureEssenceDescriptor)) 
            this.video = true;
         else if (stjs.isInstanceOf(descriptor.constructor, GenericSoundEssenceDescriptor)) 
            this.audio = true;
        this.codec = this.resolveCodec();
        if (this.codec != null || (stjs.isInstanceOf(descriptor.constructor, WaveAudioDescriptor))) {
            jcodec.Logger.warn("Track type: " + this.video + ", " + this.audio);
            if (this.audio && (stjs.isInstanceOf(descriptor.constructor, WaveAudioDescriptor))) {
                var wave = descriptor;
                this.cacheAudioFrameSizes(demuxer.ch);
                this.audioFrameDuration = stjs.trunc(this.dataLen / ((wave.getQuantizationBits() >> 3) * wave.getChannelCount()));
                this.audioTimescale = stjs.trunc(wave.getAudioSamplingRate().scalar());
            }
        }
    };
    constructor.MXFDemuxerTrack = stjs.extend(constructor.MXFDemuxerTrack, null, [SeekableDemuxerTrack], function(constructor, prototype) {
        prototype.essenceUL = null;
        prototype.dataLen = 0;
        prototype.indexSegmentIdx = 0;
        prototype.indexSegmentSubIdx = 0;
        prototype.frameNo = 0;
        prototype.pts = 0;
        prototype.partIdx = 0;
        prototype.partEssenceOffset = 0;
        prototype.descriptor = null;
        prototype.track = null;
        prototype.video = false;
        prototype.audio = false;
        prototype.codec = null;
        prototype.audioFrameDuration = 0;
        prototype.audioTimescale = 0;
        prototype.demuxer = null;
        prototype.isAudio = function() {
            return this.audio;
        };
        prototype.isVideo = function() {
            return this.video;
        };
        prototype.getDuration = function() {
            return this.demuxer.duration;
        };
        prototype.getNumFrames = function() {
            return this.demuxer.totalFrames;
        };
        prototype.getName = function() {
            return this.track.getName();
        };
        prototype.cacheAudioFrameSizes = function(ch) {
            for (var iterator$mxfPartition = this.demuxer.partitions.iterator(); iterator$mxfPartition.hasNext(); ) {
                var mxfPartition = iterator$mxfPartition.next();
                if (mxfPartition.getEssenceLength() > 0) {
                    ch.setPosition(mxfPartition.getEssenceFilePos());
                    var kl;
                    do {
                        kl = KLV.readKL(ch);
                        if (kl == null) 
                            break;
                        ch.setPosition(ch.position() + kl.len);
                    } while (!this.essenceUL.equals(kl.key));
                    if (kl != null && this.essenceUL.equals(kl.key)) {
                        this.dataLen = ((kl.len) | 0);
                        break;
                    }
                }
            }
        };
        prototype.nextFrame = function() {
            if (this.indexSegmentIdx >= this.demuxer.indexSegments.size()) 
                return null;
            var seg = this.demuxer.indexSegments.get(this.indexSegmentIdx);
            var off = seg.getIe().getFileOff();
            var erDen = seg.getIndexEditRateNum();
            var erNum = seg.getIndexEditRateDen();
            var frameEssenceOffset = off[this.indexSegmentSubIdx];
            var toff = seg.getIe().getDisplayOff()[this.indexSegmentSubIdx];
            var kf = seg.getIe().getKeyFrameOff()[this.indexSegmentSubIdx] == 0;
             while (frameEssenceOffset >= this.partEssenceOffset + this.demuxer.partitions.get(this.partIdx).getEssenceLength() && this.partIdx < this.demuxer.partitions.size() - 1){
                this.partEssenceOffset += this.demuxer.partitions.get(this.partIdx).getEssenceLength();
                this.partIdx++;
            }
            var frameFileOffset = frameEssenceOffset - this.partEssenceOffset + this.demuxer.partitions.get(this.partIdx).getEssenceFilePos();
            var result;
            if (!this.audio) {
                result = this.readPacket(frameFileOffset, this.dataLen, this.pts + erNum * toff, erDen, erNum, this.frameNo++, kf);
                this.pts += erNum;
            } else {
                result = this.readPacket(frameFileOffset, this.dataLen, this.pts, this.audioTimescale, this.audioFrameDuration, this.frameNo++, kf);
                this.pts += this.audioFrameDuration;
            }
            this.indexSegmentSubIdx++;
            if (this.indexSegmentSubIdx >= off.length) {
                this.indexSegmentIdx++;
                this.indexSegmentSubIdx = 0;
                if (this.dataLen == 0 && this.indexSegmentIdx < this.demuxer.indexSegments.size()) {
                    var nseg = this.demuxer.indexSegments.get(this.indexSegmentIdx);
                    this.pts = stjs.trunc(this.pts * nseg.getIndexEditRateNum() / erDen);
                }
            }
            return result;
        };
        prototype.readPacket = function(off, len, pts, timescale, duration, frameNo, kf) {
            var ch = this.demuxer.ch;
            {
                ch.setPosition(off);
                var kl = KLV.readKL(ch);
                 while (kl != null && !this.essenceUL.equals(kl.key)){
                    ch.setPosition(ch.position() + kl.len);
                    kl = KLV.readKL(ch);
                }
                return kl != null && this.essenceUL.equals(kl.key) ? new MXFDemuxer.MXFPacket(NIOUtils.fetchFromChannel(ch, ((kl.len) | 0)), pts, timescale, duration, frameNo, kf, null, off, len) : null;
            }};
        prototype.gotoFrame = function(frameNo) {
            if (frameNo == this.frameNo) 
                return true;
            this.indexSegmentSubIdx = ((frameNo) | 0);
            for (this.indexSegmentIdx = 0; this.indexSegmentIdx < this.demuxer.indexSegments.size() && this.indexSegmentSubIdx >= this.demuxer.indexSegments.get(this.indexSegmentIdx).getIndexDuration(); this.indexSegmentIdx++) {
                this.indexSegmentSubIdx -= this.demuxer.indexSegments.get(this.indexSegmentIdx).getIndexDuration();
            }
            this.indexSegmentSubIdx = Math.min(this.indexSegmentSubIdx, ((this.demuxer.indexSegments.get(this.indexSegmentIdx).getIndexDuration()) | 0));
            return true;
        };
        prototype.gotoSyncFrame = function(frameNo) {
            if (!this.gotoFrame(frameNo)) 
                return false;
            var seg = this.demuxer.indexSegments.get(this.indexSegmentIdx);
            var kfOff = seg.getIe().getKeyFrameOff()[this.indexSegmentSubIdx];
            return this.gotoFrame(frameNo + kfOff);
        };
        prototype.getCurFrame = function() {
            return this.frameNo;
        };
        prototype.seek = function(second) {
             throw new NotSupportedException();
        };
        prototype.getEssenceUL = function() {
            return this.essenceUL;
        };
        prototype.getDescriptor = function() {
            return this.descriptor;
        };
        prototype.getCodec = function() {
            return this.codec;
        };
        prototype.resolveCodec = function() {
            var codecUL;
            if (this.video) 
                codecUL = (this.descriptor).getPictureEssenceCoding();
             else if (this.audio) 
                codecUL = (this.descriptor).getSoundEssenceCompression();
             else 
                return null;
            var values = MXFConst.MXFCodecMapping.values();
            for (var i = 0; i < values.length; i++) {
                var codec = values[i];
                if (codec.getUl().maskEquals(codecUL, 65407)) 
                    return codec;
            }
            jcodec.Logger.warn("Unknown codec: " + codecUL);
            return null;
        };
        prototype.getTrackId = function() {
            return this.track.getTrackId();
        };
        prototype.getMeta = function() {
            var size = null;
            if (this.video) {
                var pd = this.descriptor;
                size = new Size(pd.getStoredWidth(), pd.getStoredHeight());
            }
            var t = this.video ? DemuxerTrackMeta.Type.VIDEO : (this.audio ? DemuxerTrackMeta.Type.AUDIO : DemuxerTrackMeta.Type.OTHER);
            return new DemuxerTrackMeta(t, this.getCodec().getCodec(), null, this.demuxer.totalFrames, this.demuxer.duration, size, null);
        };
    }, {essenceUL: "UL", descriptor: "GenericDescriptor", track: "TimelineTrack", codec: "MXFConst.MXFCodecMapping", demuxer: "MXFDemuxer"}, {});
    constructor.MXFPacket = function(data, pts, timescale, duration, frameNo, keyFrame, tapeTimecode, offset, len) {
        Packet.call(this, data, pts, timescale, duration, frameNo, keyFrame, tapeTimecode, 0);
        this.offset = offset;
        this.len = len;
    };
    constructor.MXFPacket = stjs.extend(constructor.MXFPacket, Packet, [], function(constructor, prototype) {
        prototype.offset = 0;
        prototype.len = 0;
        prototype.getOffset = function() {
            return this.offset;
        };
        prototype.getLen = function() {
            return this.len;
        };
    }, {data: "ByteBuffer", tapeTimecode: "TapeTimecode", FRAME_ASC: {name: "Comparator", arguments: ["Packet"]}}, {});
    /**
     *  Fast loading version of demuxer, doesn't search for metadata in ALL the
     *  partitions, only the header and footer are being inspected
     */
    constructor.Fast = function(ch) {
        MXFDemuxer.call(this, ch);
    };
    constructor.Fast = stjs.extend(constructor.Fast, MXFDemuxer, [], function(constructor, prototype) {
        prototype.parseHeader = function(ff) {
            this.partitions = new ArrayList();
            this.metadata = new ArrayList();
            this.header = MXFDemuxer.readHeaderPartition(ff);
            this.metadata.addAll(MXFDemuxer.readPartitionMeta(ff, this.header));
            this.partitions.add(this.header);
            ff.setPosition(this.header.getPack().getFooterPartition());
            var kl = KLV.readKL(ff);
            var fetchFrom = NIOUtils.fetchFromChannel(ff, ((kl.len) | 0));
            var footer = MXFPartition.read(kl.key, fetchFrom, ff.position() - kl.offset, ff.size());
            this.metadata.addAll(MXFDemuxer.readPartitionMeta(ff, footer));
        };
    }, {metadata: {name: "List", arguments: ["MXFMetadata"]}, header: "MXFPartition", partitions: {name: "List", arguments: ["MXFPartition"]}, indexSegments: {name: "List", arguments: ["IndexSegment"]}, ch: "SeekableByteChannel", tracks: "Array", timecode: "TimecodeComponent"}, {});
}, {metadata: {name: "List", arguments: ["MXFMetadata"]}, header: "MXFPartition", partitions: {name: "List", arguments: ["MXFPartition"]}, indexSegments: {name: "List", arguments: ["IndexSegment"]}, ch: "SeekableByteChannel", tracks: "Array", timecode: "TimecodeComponent"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Creates MP4 file out of a set of samples
 *  
 *  @author The JCodec project
 *  
 */
var TrakBox = function(atom) {
    NodeBox.call(this, atom);
};
TrakBox = stjs.extend(TrakBox, NodeBox, [], function(constructor, prototype) {
    constructor.fourcc = function() {
        return "trak";
    };
    constructor.createTrakBox = function() {
        return new TrakBox(new Header(TrakBox.fourcc()));
    };
    prototype.setDataRef = function(url) {
        var minf = this.getMdia().getMinf();
        var dinf = minf.getDinf();
        if (dinf == null) {
            dinf = DataInfoBox.createDataInfoBox();
            minf.add(dinf);
        }
        var dref = dinf.getDref();
        var urlBox = UrlBox.createUrlBox(url);
        if (dref == null) {
            dref = DataRefBox.createDataRefBox();
            dinf.add(dref);
            dref.add(urlBox);
        } else {
            var lit = dref.boxes.listIterator();
             while (lit.hasNext()){
                var box = lit.next();
                if ((box.getFlags() & 1) != 0) 
                    lit.set(urlBox);
            }
        }
    };
    prototype.getMdia = function() {
        return NodeBox.findFirst(this, MediaBox, "mdia");
    };
    prototype.getTrackHeader = function() {
        return NodeBox.findFirst(this, TrackHeaderBox, "tkhd");
    };
    prototype.getEdits = function() {
        var elst = NodeBox.findFirstPath(this, EditListBox, Box.path("edts.elst"));
        if (elst == null) 
            return null;
        return elst.getEdits();
    };
    prototype.setEdits = function(edits) {
        var edts = NodeBox.findFirst(this, NodeBox, "edts");
        if (edts == null) {
            edts = new NodeBox(new Header("edts"));
            this.add(edts);
        }
        edts.removeChildren("elst");
        edts.add(EditListBox.createEditListBox(edits));
        this.getTrackHeader().setDuration(TrakBox.getEditedDuration(this));
        return this;
    };
    prototype.isVideo = function() {
        return "vide".equals(this.getHandlerType());
    };
    prototype.isTimecode = function() {
        return "tmcd".equals(this.getHandlerType());
    };
    prototype.getHandlerType = function() {
        var handlerBox = NodeBox.findFirstPath(this, HandlerBox, Box.path("mdia.hdlr"));
        if (handlerBox == null) 
            return null;
        var type = handlerBox.getComponentSubType();
        return type;
    };
    prototype.isAudio = function() {
        return "soun".equals(this.getHandlerType());
    };
    /**
     *  Gets 'media timescale' of this track. This is the timescale used to
     *  represent the durations of samples inside mdia/minf/stbl/stts box.
     *  
     *  @return 'media timescale' of the track.
     */
    prototype.getTimescale = function() {
        return NodeBox.findFirstPath(this, MediaHeaderBox, Box.path("mdia.mdhd")).getTimescale();
    };
    /**
     *  Sets the 'media timescale' of this track. This is the time timescale used
     *  to represent sample durations.
     *  
     *  @param timescale
     *             A new 'media timescale' of this track.
     */
    prototype.setTimescale = function(timescale) {
        NodeBox.findFirstPath(this, MediaHeaderBox, Box.path("mdia.mdhd")).setTimescale(timescale);
    };
    prototype.rescale = function(tv, ts) {
        return stjs.trunc((tv * this.getTimescale()) / ts);
    };
    prototype.setDuration = function(duration) {
        this.getTrackHeader().setDuration(duration);
    };
    prototype.getDuration = function() {
        return this.getTrackHeader().getDuration();
    };
    prototype.getMediaDuration = function() {
        return NodeBox.findFirstPath(this, MediaHeaderBox, Box.path("mdia.mdhd")).getDuration();
    };
    prototype.isPureRef = function() {
        var minf = this.getMdia().getMinf();
        var dinf = minf.getDinf();
        if (dinf == null) {
            return false;
        }
        var dref = dinf.getDref();
        if (dref == null) 
            return false;
        for (var iterator$box = dref.boxes.iterator(); iterator$box.hasNext(); ) {
            var box = iterator$box.next();
            if (((box).getFlags() & 1) != 0) 
                return false;
        }
        return true;
    };
    prototype.hasDataRef = function() {
        var dinf = this.getMdia().getMinf().getDinf();
        if (dinf == null) {
            return false;
        }
        var dref = dinf.getDref();
        if (dref == null) 
            return false;
        var result = false;
        for (var iterator$box = dref.boxes.iterator(); iterator$box.hasNext(); ) {
            var box = iterator$box.next();
            result |= ((box).getFlags() & 1) != 1;
        }
        return result;
    };
    prototype.getPAR = function() {
        var pasp = NodeBox.findFirstPath(this, PixelAspectExt, ["mdia", "minf", "stbl", "stsd", null, "pasp"]);
        return pasp == null ? new Rational(1, 1) : pasp.getRational();
    };
    prototype.setPAR = function(par) {
        var sampleEntries = this.getSampleEntries();
        for (var i = 0; i < sampleEntries.length; i++) {
            var sampleEntry = sampleEntries[i];
            sampleEntry.removeChildren("pasp");
            sampleEntry.add(PixelAspectExt.createPixelAspectExt(par));
        }
    };
    prototype.getSampleEntries = function() {
        return NodeBox.findAllPath(this, SampleEntry, ["mdia", "minf", "stbl", "stsd", null]);
    };
    prototype.setClipRect = function(x, y, width, height) {
        var clip = NodeBox.findFirst(this, NodeBox, "clip");
        if (clip == null) {
            clip = new NodeBox(new Header("clip"));
            this.add(clip);
        }
        clip.replace("crgn", ClipRegionBox.createClipRegionBox(x, y, width, height));
    };
    prototype.getSampleCount = function() {
        return NodeBox.findFirstPath(this, SampleSizesBox, Box.path("mdia.minf.stbl.stsz")).getCount();
    };
    prototype.setAperture = function(sar, dar) {
        this.removeChildren("tapt");
        var tapt = new NodeBox(new Header("tapt"));
        tapt.add(ClearApertureBox.createClearApertureBox(dar.getWidth(), dar.getHeight()));
        tapt.add(ProductionApertureBox.createProductionApertureBox(dar.getWidth(), dar.getHeight()));
        tapt.add(EncodedPixelBox.createEncodedPixelBox(sar.getWidth(), sar.getHeight()));
        this.add(tapt);
    };
    prototype.setDimensions = function(dd) {
        this.getTrackHeader().setWidth(dd.getWidth());
        this.getTrackHeader().setHeight(dd.getHeight());
    };
    prototype.getFrameCount = function() {
        var stsz = NodeBox.findFirstPath(this, SampleSizesBox, Box.path("mdia.minf.stbl.stsz"));
        return stsz.getDefaultSize() != 0 ? stsz.getCount() : stsz.getSizes().length;
    };
    prototype.getName = function() {
        var nb = NodeBox.findFirstPath(this, NameBox, Box.path("udta.name"));
        return nb == null ? null : nb.getName();
    };
    prototype.fixMediaTimescale = function(ts) {
        var mdhd = NodeBox.findFirstPath(this, MediaHeaderBox, Box.path("mdia.mdhd"));
        var oldTs = mdhd.getTimescale();
        mdhd.setTimescale(ts);
        mdhd.setDuration(stjs.trunc((ts * mdhd.getDuration()) / oldTs));
        var edits = this.getEdits();
        if (edits != null) {
            for (var iterator$edit = edits.iterator(); iterator$edit.hasNext(); ) {
                var edit = iterator$edit.next();
                edit.setMediaTime(stjs.trunc((ts * edit.getMediaTime()) / oldTs));
            }
        }
        var tts = NodeBox.findFirstPath(this, TimeToSampleBox, Box.path("mdia.minf.stbl.stts"));
        var entries = tts.getEntries();
        for (var i = 0; i < entries.length; i++) {
            var tte = entries[i];
            tte.setSampleDuration(stjs.trunc((ts * tte.getSampleDuration()) / oldTs));
        }
    };
    prototype.setName = function(string) {
        var udta = NodeBox.findFirst(this, NodeBox, "udta");
        if (udta == null) {
            udta = new NodeBox(new Header("udta"));
            this.add(udta);
        }
        udta.removeChildren("name");
        udta.add(NameBox.createNameBox(string));
    };
    /**
     *  Retrieves coded size of this video track.
     *  
     *  Note: May be different from video display dimension.
     *  
     *  @return
     */
    prototype.getCodedSize = function() {
        var se = this.getSampleEntries()[0];
        if (!(stjs.isInstanceOf(se.constructor, VideoSampleEntry))) 
             throw new IllegalArgumentException("Not a video track");
        var vse = se;
        return new Size(vse.getWidth(), vse.getHeight());
    };
    prototype.getModelFields = function(model) {};
    prototype.getStts = function() {
        return NodeBox.findFirstPath(this, TimeToSampleBox, Box.path("mdia.minf.stbl.stts"));
    };
    prototype.getStco = function() {
        return NodeBox.findFirstPath(this, ChunkOffsetsBox, Box.path("mdia.minf.stbl.stco"));
    };
    prototype.getCo64 = function() {
        return NodeBox.findFirstPath(this, ChunkOffsets64Box, Box.path("mdia.minf.stbl.co64"));
    };
    prototype.getStsz = function() {
        return NodeBox.findFirstPath(this, SampleSizesBox, Box.path("mdia.minf.stbl.stsz"));
    };
    prototype.getStsc = function() {
        return NodeBox.findFirstPath(this, SampleToChunkBox, Box.path("mdia.minf.stbl.stsc"));
    };
    prototype.getStsd = function() {
        return NodeBox.findFirstPath(this, SampleDescriptionBox, Box.path("mdia.minf.stbl.stsd"));
    };
    prototype.getStss = function() {
        return NodeBox.findFirstPath(this, SyncSamplesBox, Box.path("mdia.minf.stbl.stss"));
    };
    prototype.getCtts = function() {
        return NodeBox.findFirstPath(this, CompositionOffsetsBox, Box.path("mdia.minf.stbl.ctts"));
    };
    constructor.getTrackType = function(trak) {
        var handler = NodeBox.findFirstPath(trak, HandlerBox, Box.path("mdia.hdlr"));
        return TrackType.fromHandler(handler.getComponentSubType());
    };
    /**
     *  Calculates track duration considering edits
     *  
     *  @param track
     *  @return
     */
    constructor.getEditedDuration = function(track) {
        var edits = track.getEdits();
        if (edits == null) 
            return track.getDuration();
        var duration = 0;
        for (var iterator$edit = edits.iterator(); iterator$edit.hasNext(); ) {
            var edit = iterator$edit.next();
            duration += edit.getDuration();
        }
        return duration;
    };
}, {boxes: {name: "List", arguments: ["Box"]}, factory: "IBoxFactory", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var PCMMP4MuxerTrack = function(out, trackId, type, timescale, frameDuration, frameSize, se) {
    AbstractMP4MuxerTrack.call(this, trackId, type, timescale);
    this.chunkOffsets = LongArrayList.createLongArrayList();
    this.out = out;
    this.frameDuration = frameDuration;
    this.frameSize = frameSize;
    this.addSampleEntry(se);
    this.setTgtChunkDuration(new Rational(1, 2), Unit.SEC);
};
PCMMP4MuxerTrack = stjs.extend(PCMMP4MuxerTrack, AbstractMP4MuxerTrack, [], function(constructor, prototype) {
    prototype.frameDuration = 0;
    prototype.frameSize = 0;
    prototype.framesInCurChunk = 0;
    prototype.chunkOffsets = null;
    prototype.totalFrames = 0;
    prototype.out = null;
    prototype.addSamples = function(buffer) {
        this.curChunk.add(buffer);
        var frames = stjs.trunc(buffer.remaining() / this.frameSize);
        this.totalFrames += frames;
        this.framesInCurChunk += frames;
        this.chunkDuration += frames * this.frameDuration;
        this.outChunkIfNeeded();
    };
    prototype.outChunkIfNeeded = function() {
        Assert.assertTrue(this.tgtChunkDurationUnit == Unit.FRAME || this.tgtChunkDurationUnit == Unit.SEC);
        if (this.tgtChunkDurationUnit == Unit.FRAME && this.framesInCurChunk * this.tgtChunkDuration.getDen() == this.tgtChunkDuration.getNum()) {
            this.outChunk();
        } else if (this.tgtChunkDurationUnit == Unit.SEC && this.chunkDuration > 0 && this.chunkDuration * this.tgtChunkDuration.getDen() >= this.tgtChunkDuration.getNum() * this.timescale) {
            this.outChunk();
        }
    };
    prototype.outChunk = function() {
        if (this.framesInCurChunk == 0) 
            return;
        this.chunkOffsets.add(this.out.position());
        for (var iterator$b = this.curChunk.iterator(); iterator$b.hasNext(); ) {
            var b = iterator$b.next();
            this.out.write(b);
        }
        this.curChunk.clear();
        if (this.samplesInLastChunk == -1 || this.framesInCurChunk != this.samplesInLastChunk) {
            this.samplesInChunks.add(new SampleToChunkBox.SampleToChunkEntry(this.chunkNo + 1, this.framesInCurChunk, 1));
        }
        this.samplesInLastChunk = this.framesInCurChunk;
        this.chunkNo++;
        this.framesInCurChunk = 0;
        this.chunkDuration = 0;
    };
    prototype.finish = function(mvhd) {
        if (this.finished) 
             throw new IllegalStateException("The muxer track has finished muxing");
        this.outChunk();
        this.finished = true;
        var trak = TrakBox.createTrakBox();
        var dd = this.getDisplayDimensions();
        var tkhd = TrackHeaderBox.createTrackHeaderBox(this.trackId, stjs.trunc((stjs.trunc(mvhd.getTimescale()) * this.totalFrames * this.frameDuration) / this.timescale), dd.getWidth(), dd.getHeight(), new jsutil.Date().getTime(), new jsutil.Date().getTime(), 1.0, ((0) << 16 >> 16), 0, new Int32Array([65536, 0, 0, 0, 65536, 0, 0, 0, 1073741824]));
        tkhd.setFlags(15);
        trak.add(tkhd);
        this.tapt(trak);
        var media = MediaBox.createMediaBox();
        trak.add(media);
        media.add(MediaHeaderBox.createMediaHeaderBox(this.timescale, this.totalFrames * this.frameDuration, 0, new jsutil.Date().getTime(), new jsutil.Date().getTime(), 0));
        var hdlr = HandlerBox.createHandlerBox("mhlr", this.type.getHandler(), "appl", 0, 0);
        media.add(hdlr);
        var minf = MediaInfoBox.createMediaInfoBox();
        media.add(minf);
        this.mediaHeader(minf, this.type);
        minf.add(HandlerBox.createHandlerBox("dhlr", "url ", "appl", 0, 0));
        this.addDref(minf);
        var stbl = new NodeBox(new Header("stbl"));
        minf.add(stbl);
        this.putEdits(trak);
        this.putName(trak);
        stbl.add(SampleDescriptionBox.createSampleDescriptionBox(this.sampleEntries.toArray(Array(0))));
        stbl.add(SampleToChunkBox.createSampleToChunkBox(this.samplesInChunks.toArray(Array(0))));
        stbl.add(SampleSizesBox.createSampleSizesBox(this.frameSize, this.totalFrames));
        stbl.add(TimeToSampleBox.createTimeToSampleBox([new TimeToSampleBox.TimeToSampleEntry(this.totalFrames, this.frameDuration)]));
        stbl.add(ChunkOffsets64Box.createChunkOffsets64Box(this.chunkOffsets.toArray()));
        return trak;
    };
    prototype.getTrackTotalDuration = function() {
        return this.totalFrames * this.frameDuration;
    };
}, {chunkOffsets: "LongArrayList", out: "SeekableByteChannel", type: "TrackType", tgtChunkDuration: "Rational", tgtChunkDurationUnit: {name: "Enum", arguments: ["Unit"]}, curChunk: {name: "List", arguments: ["ByteBuffer"]}, samplesInChunks: {name: "List", arguments: ["SampleToChunkBox.SampleToChunkEntry"]}, sampleEntries: {name: "List", arguments: ["SampleEntry"]}, edits: {name: "List", arguments: ["Edit"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var FramesMP4MuxerTrack = function(out, trackId, type, timescale) {
    AbstractMP4MuxerTrack.call(this, trackId, type, timescale);
    this.sampleDurations = new ArrayList();
    this.chunkOffsets = LongArrayList.createLongArrayList();
    this.sampleSizes = IntArrayList.createIntArrayList();
    this.iframes = IntArrayList.createIntArrayList();
    this.compositionOffsets = new ArrayList();
    this.out = out;
    this.setTgtChunkDuration(new Rational(1, 1), Unit.FRAME);
};
FramesMP4MuxerTrack = stjs.extend(FramesMP4MuxerTrack, AbstractMP4MuxerTrack, [], function(constructor, prototype) {
    prototype.sampleDurations = null;
    prototype.sameDurCount = 0;
    prototype.curDuration = -1;
    prototype.chunkOffsets = null;
    prototype.sampleSizes = null;
    prototype.iframes = null;
    prototype.compositionOffsets = null;
    prototype.lastCompositionOffset = 0;
    prototype.lastCompositionSamples = 0;
    prototype.ptsEstimate = 0;
    prototype.lastEntry = -1;
    prototype.trackTotalDuration = 0;
    prototype.curFrame = 0;
    prototype.allIframes = true;
    prototype.timecodeTrack = null;
    prototype.out = null;
    prototype.addFrame = function(pkt) {
        if (this.finished) 
             throw new IllegalStateException("The muxer track has finished muxing");
        var entryNo = pkt.getEntryNo() + 1;
        var compositionOffset = (((pkt.getPts() - this.ptsEstimate)) | 0);
        if (compositionOffset != this.lastCompositionOffset) {
            if (this.lastCompositionSamples > 0) 
                this.compositionOffsets.add(new CompositionOffsetsBox.Entry(this.lastCompositionSamples, this.lastCompositionOffset));
            this.lastCompositionOffset = compositionOffset;
            this.lastCompositionSamples = 0;
        }
        this.lastCompositionSamples++;
        this.ptsEstimate += pkt.getDuration();
        if (this.lastEntry != -1 && this.lastEntry != entryNo) {
            this.outChunk(this.lastEntry);
            this.samplesInLastChunk = -1;
        }
        this.curChunk.add(pkt.getData());
        if (pkt.isKeyFrame()) 
            this.iframes.add(this.curFrame + 1);
         else 
            this.allIframes = false;
        this.curFrame++;
        this.chunkDuration += pkt.getDuration();
        if (this.curDuration != -1 && pkt.getDuration() != this.curDuration) {
            this.sampleDurations.add(new TimeToSampleBox.TimeToSampleEntry(((this.sameDurCount) | 0), ((this.curDuration) | 0)));
            this.sameDurCount = 0;
        }
        this.curDuration = pkt.getDuration();
        this.sameDurCount++;
        this.trackTotalDuration += pkt.getDuration();
        this.outChunkIfNeeded(entryNo);
        this.processTimecode(pkt);
        this.lastEntry = entryNo;
    };
    prototype.processTimecode = function(pkt) {
        if (this.timecodeTrack != null) 
            this.timecodeTrack.addTimecode(pkt);
    };
    prototype.outChunkIfNeeded = function(entryNo) {
        Assert.assertTrue(this.tgtChunkDurationUnit == Unit.FRAME || this.tgtChunkDurationUnit == Unit.SEC);
        if (this.tgtChunkDurationUnit == Unit.FRAME && this.curChunk.size() * this.tgtChunkDuration.getDen() == this.tgtChunkDuration.getNum()) {
            this.outChunk(entryNo);
        } else if (this.tgtChunkDurationUnit == Unit.SEC && this.chunkDuration > 0 && this.chunkDuration * this.tgtChunkDuration.getDen() >= this.tgtChunkDuration.getNum() * this.timescale) {
            this.outChunk(entryNo);
        }
    };
    prototype.outChunk = function(entryNo) {
        if (this.curChunk.size() == 0) 
            return;
        this.chunkOffsets.add(this.out.position());
        for (var iterator$bs = this.curChunk.iterator(); iterator$bs.hasNext(); ) {
            var bs = iterator$bs.next();
            this.sampleSizes.add(bs.remaining());
            this.out.write(bs);
        }
        if (this.samplesInLastChunk == -1 || this.samplesInLastChunk != this.curChunk.size()) {
            this.samplesInChunks.add(new SampleToChunkBox.SampleToChunkEntry(this.chunkNo + 1, this.curChunk.size(), entryNo));
        }
        this.samplesInLastChunk = this.curChunk.size();
        this.chunkNo++;
        this.chunkDuration = 0;
        this.curChunk.clear();
    };
    prototype.finish = function(mvhd) {
        if (this.finished) 
             throw new IllegalStateException("The muxer track has finished muxing");
        this.outChunk(this.lastEntry);
        if (this.sameDurCount > 0) {
            this.sampleDurations.add(new TimeToSampleBox.TimeToSampleEntry(((this.sameDurCount) | 0), ((this.curDuration) | 0)));
        }
        this.finished = true;
        var trak = TrakBox.createTrakBox();
        var dd = this.getDisplayDimensions();
        var tkhd = TrackHeaderBox.createTrackHeaderBox(this.trackId, stjs.trunc((stjs.trunc(mvhd.getTimescale()) * this.trackTotalDuration) / this.timescale), dd.getWidth(), dd.getHeight(), new jsutil.Date().getTime(), new jsutil.Date().getTime(), 1.0, ((0) << 16 >> 16), 0, new Int32Array([65536, 0, 0, 0, 65536, 0, 0, 0, 1073741824]));
        tkhd.setFlags(15);
        trak.add(tkhd);
        this.tapt(trak);
        var media = MediaBox.createMediaBox();
        trak.add(media);
        media.add(MediaHeaderBox.createMediaHeaderBox(this.timescale, this.trackTotalDuration, 0, new jsutil.Date().getTime(), new jsutil.Date().getTime(), 0));
        var hdlr = HandlerBox.createHandlerBox("mhlr", this.type.getHandler(), "appl", 0, 0);
        media.add(hdlr);
        var minf = MediaInfoBox.createMediaInfoBox();
        media.add(minf);
        this.mediaHeader(minf, this.type);
        minf.add(HandlerBox.createHandlerBox("dhlr", "url ", "appl", 0, 0));
        this.addDref(minf);
        var stbl = new NodeBox(new Header("stbl"));
        minf.add(stbl);
        this.putCompositionOffsets(stbl);
        this.putEdits(trak);
        this.putName(trak);
        stbl.add(SampleDescriptionBox.createSampleDescriptionBox(this.sampleEntries.toArray(Array(0))));
        stbl.add(SampleToChunkBox.createSampleToChunkBox(this.samplesInChunks.toArray(Array(0))));
        stbl.add(SampleSizesBox.createSampleSizesBox2(this.sampleSizes.toArray()));
        stbl.add(TimeToSampleBox.createTimeToSampleBox(this.sampleDurations.toArray([])));
        stbl.add(ChunkOffsets64Box.createChunkOffsets64Box(this.chunkOffsets.toArray()));
        if (!this.allIframes && this.iframes.size() > 0) 
            stbl.add(SyncSamplesBox.createSyncSamplesBox(this.iframes.toArray()));
        return trak;
    };
    prototype.putCompositionOffsets = function(stbl) {
        if (this.compositionOffsets.size() > 0) {
            this.compositionOffsets.add(new CompositionOffsetsBox.Entry(this.lastCompositionSamples, this.lastCompositionOffset));
            var min = FramesMP4MuxerTrack.minOffset(this.compositionOffsets);
            if (min > 0) {
                for (var iterator$entry = this.compositionOffsets.iterator(); iterator$entry.hasNext(); ) {
                    var entry = iterator$entry.next();
                    entry.offset -= min;
                }
            }
            var first = this.compositionOffsets.get(0);
            if (first.getOffset() > 0) {
                if (this.edits == null) {
                    this.edits = new ArrayList();
                    this.edits.add(new Edit(this.trackTotalDuration, first.getOffset(), 1.0));
                } else {
                    for (var iterator$edit = this.edits.iterator(); iterator$edit.hasNext(); ) {
                        var edit = iterator$edit.next();
                        edit.setMediaTime(edit.getMediaTime() + first.getOffset());
                    }
                }
            }
            stbl.add(CompositionOffsetsBox.createCompositionOffsetsBox(this.compositionOffsets.toArray(Array(0))));
        }
    };
    constructor.minOffset = function(offs) {
        var min = Integer.MAX_VALUE;
        for (var iterator$entry = offs.iterator(); iterator$entry.hasNext(); ) {
            var entry = iterator$entry.next();
            if (entry.getOffset() < min) 
                min = entry.getOffset();
        }
        return min;
    };
    prototype.getTrackTotalDuration = function() {
        return this.trackTotalDuration;
    };
    prototype.addSampleEntries = function(sampleEntries) {
        for (var i = 0; i < sampleEntries.length; i++) {
            var se = sampleEntries[i];
            this.addSampleEntry(se);
        }
    };
    prototype.getTimecodeTrack = function() {
        return this.timecodeTrack;
    };
    prototype.setTimecode = function(timecodeTrack) {
        this.timecodeTrack = timecodeTrack;
    };
}, {sampleDurations: {name: "List", arguments: ["TimeToSampleBox.TimeToSampleEntry"]}, chunkOffsets: "LongArrayList", sampleSizes: "IntArrayList", iframes: "IntArrayList", compositionOffsets: {name: "List", arguments: ["CompositionOffsetsBox.Entry"]}, timecodeTrack: "TimecodeMP4MuxerTrack", out: "SeekableByteChannel", type: "TrackType", tgtChunkDuration: "Rational", tgtChunkDurationUnit: {name: "Enum", arguments: ["Unit"]}, curChunk: {name: "List", arguments: ["ByteBuffer"]}, samplesInChunks: {name: "List", arguments: ["SampleToChunkBox.SampleToChunkEntry"]}, sampleEntries: {name: "List", arguments: ["SampleEntry"]}, edits: {name: "List", arguments: ["Edit"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Creates MP4 file out of a set of samples
 *  
 *  @author The JCodec project
 *  
 */
var MovieBox = function(atom) {
    NodeBox.call(this, atom);
};
MovieBox = stjs.extend(MovieBox, NodeBox, [], function(constructor, prototype) {
    constructor.fourcc = function() {
        return "moov";
    };
    constructor.createMovieBox = function() {
        return new MovieBox(new Header(MovieBox.fourcc()));
    };
    prototype.getTracks = function() {
        return NodeBox.findAll(this, TrakBox, "trak");
    };
    prototype.getVideoTrack = function() {
        var tracks = this.getTracks();
        for (var i = 0; i < tracks.length; i++) {
            var trakBox = tracks[i];
            if (trakBox.isVideo()) 
                return trakBox;
        }
        return null;
    };
    prototype.getTimecodeTrack = function() {
        var tracks = this.getTracks();
        for (var i = 0; i < tracks.length; i++) {
            var trakBox = tracks[i];
            if (trakBox.isTimecode()) 
                return trakBox;
        }
        return null;
    };
    prototype.getTimescale = function() {
        return this.getMovieHeader().getTimescale();
    };
    prototype.rescale = function(tv, ts) {
        return stjs.trunc((tv * this.getTimescale()) / ts);
    };
    prototype.fixTimescale = function(newTs) {
        var oldTs = this.getTimescale();
        this.setTimescale(newTs);
        var tracks = this.getTracks();
        for (var i = 0; i < tracks.length; i++) {
            var trakBox = tracks[i];
            trakBox.setDuration(this.rescale(trakBox.getDuration(), oldTs));
            var edits = trakBox.getEdits();
            if (edits == null) 
                continue;
            var lit = edits.listIterator();
             while (lit.hasNext()){
                var edit = lit.next();
                lit.set(new Edit(this.rescale(edit.getDuration(), oldTs), edit.getMediaTime(), edit.getRate()));
            }
        }
        this.setDuration(this.rescale(this.getDuration(), oldTs));
    };
    prototype.setTimescale = function(newTs) {
        NodeBox.findFirst(this, MovieHeaderBox, "mvhd").setTimescale(newTs);
    };
    prototype.setDuration = function(movDuration) {
        this.getMovieHeader().setDuration(movDuration);
    };
    prototype.getMovieHeader = function() {
        return NodeBox.findFirst(this, MovieHeaderBox, "mvhd");
    };
    prototype.getAudioTracks = function() {
        var result = new ArrayList();
        var tracks = this.getTracks();
        for (var i = 0; i < tracks.length; i++) {
            var trakBox = tracks[i];
            if (trakBox.isAudio()) 
                result.add(trakBox);
        }
        return result;
    };
    prototype.getDuration = function() {
        return this.getMovieHeader().getDuration();
    };
    prototype.importTrack = function(movie, track) {
        var newTrack = NodeBox.cloneBox(track, 1024 * 1024, this.factory);
        var edits = newTrack.getEdits();
        var result = new ArrayList();
        if (edits != null) {
            for (var iterator$edit = edits.iterator(); iterator$edit.hasNext(); ) {
                var edit = iterator$edit.next();
                result.add(new Edit(this.rescale(edit.getDuration(), movie.getTimescale()), edit.getMediaTime(), edit.getRate()));
            }
        }
        newTrack.setEdits(result);
        return newTrack;
    };
    prototype.appendTrack = function(newTrack) {
        newTrack.getTrackHeader().setNo(this.getMovieHeader().getNextTrackId());
        this.getMovieHeader().setNextTrackId(this.getMovieHeader().getNextTrackId() + 1);
        this.boxes.add(newTrack);
    };
    prototype.isPureRefMovie = function(movie) {
        var pureRef = true;
        var tracks = movie.getTracks();
        for (var i = 0; i < tracks.length; i++) {
            var trakBox = tracks[i];
            pureRef &= trakBox.isPureRef();
        }
        return pureRef;
    };
    prototype.updateDuration = function() {
        var tracks = this.getTracks();
        var min = Integer.MAX_VALUE;
        for (var i = 0; i < tracks.length; i++) {
            var trakBox = tracks[i];
            if (trakBox.getDuration() < min) 
                min = trakBox.getDuration();
        }
        this.getMovieHeader().setDuration(min);
    };
    prototype.getDisplaySize = function() {
        var videoTrack = this.getVideoTrack();
        if (videoTrack == null) 
            return null;
        var clef = NodeBox.findFirstPath(videoTrack, ClearApertureBox, Box.path("tapt.clef"));
        if (clef != null) {
            return this.applyMatrix(videoTrack, new Size(stjs.trunc(clef.getWidth()), stjs.trunc(clef.getHeight())));
        }
        var box = NodeBox.findFirstPath(videoTrack, SampleDescriptionBox, Box.path("mdia.minf.stbl.stsd")).getBoxes().get(0);
        if (box == null || !(stjs.isInstanceOf(box.constructor, VideoSampleEntry))) 
            return null;
        var vs = box;
        var par = videoTrack.getPAR();
        return this.applyMatrix(videoTrack, new Size(stjs.trunc((stjs.trunc((vs.getWidth() * par.getNum()) / par.getDen()))), stjs.trunc(vs.getHeight())));
    };
    prototype.applyMatrix = function(videoTrack, size) {
        var matrix = videoTrack.getTrackHeader().getMatrix();
        return new Size(stjs.trunc((size.getWidth() * matrix[0] / 65536)), stjs.trunc((size.getHeight() * matrix[4] / 65536)));
    };
    prototype.getStoredSize = function() {
        var videoTrack = this.getVideoTrack();
        if (videoTrack == null) 
            return null;
        var enof = NodeBox.findFirstPath(videoTrack, EncodedPixelBox, Box.path("tapt.enof"));
        if (enof != null) {
            return new Size(stjs.trunc(enof.getWidth()), stjs.trunc(enof.getHeight()));
        }
        var box = NodeBox.findFirstPath(videoTrack, SampleDescriptionBox, Box.path("mdia.minf.stbl.stsd")).getBoxes().get(0);
        if (box == null || !(stjs.isInstanceOf(box.constructor, VideoSampleEntry))) 
            return null;
        var vs = box;
        return new Size(stjs.trunc(vs.getWidth()), stjs.trunc(vs.getHeight()));
    };
    prototype.getModelFields = function(model) {};
}, {boxes: {name: "List", arguments: ["Box"]}, factory: "IBoxFactory", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Timecode MP4 muxer track
 *  
 *  @author The JCodec project
 *  
 */
var TimecodeMP4MuxerTrack = function(out, trackId, timescale) {
    FramesMP4MuxerTrack.call(this, out, trackId, TrackType.TIMECODE, timescale);
    this.lower = new ArrayList();
    this.gop = new ArrayList();
};
TimecodeMP4MuxerTrack = stjs.extend(TimecodeMP4MuxerTrack, FramesMP4MuxerTrack, [], function(constructor, prototype) {
    prototype.prevTimecode = null;
    prototype.firstTimecode = null;
    prototype.fpsEstimate = 0;
    prototype.sampleDuration = 0;
    prototype.samplePts = 0;
    prototype.tcFrames = 0;
    prototype.lower = null;
    prototype.gop = null;
    prototype.addTimecode = function(packet) {
        if (packet.isKeyFrame()) 
            this.processGop();
        this.gop.add(Packet.createPacketWithData(packet, null));
    };
    prototype.processGop = function() {
        if (this.gop.size() > 0) {
            for (var iterator$pkt = this.sortByDisplay(this.gop).iterator(); iterator$pkt.hasNext(); ) {
                var pkt = iterator$pkt.next();
                this.addTimecodeInt(pkt);
            }
            this.gop.clear();
        }
    };
    prototype.sortByDisplay = function(gop) {
        var result = new ArrayList(gop);
        Collections.sort(result, new (stjs.extend(function TimecodeMP4MuxerTrack$1() {}, null, [Comparator], function(constructor, prototype) {
            prototype.compare = function(o1, o2) {
                if (o1 == null && o2 == null) 
                    return 0;
                 else if (o1 == null) 
                    return -1;
                 else if (o2 == null) 
                    return 1;
                 else 
                    return o1.getDisplayOrder() > o2.getDisplayOrder() ? 1 : (o1.getDisplayOrder() == o2.getDisplayOrder() ? 0 : -1);
            };
        }, {}, {}))());
        return result;
    };
    prototype.finish = function(mvhd) {
        this.processGop();
        this.outTimecodeSample();
        if (this.sampleEntries.size() == 0) 
            return null;
        if (this.edits != null) {
            this.edits = Util.editsOnEdits(new Rational(1, 1), this.lower, this.edits);
        } else 
            this.edits = this.lower;
        return FramesMP4MuxerTrack.prototype.finish.call(this, mvhd);
    };
    prototype.addTimecodeInt = function(packet) {
        var tapeTimecode = packet.getTapeTimecode();
        var gap = this.isGap(this.prevTimecode, tapeTimecode);
        this.prevTimecode = tapeTimecode;
        if (gap) {
            this.outTimecodeSample();
            this.firstTimecode = tapeTimecode;
            this.fpsEstimate = tapeTimecode.isDropFrame() ? 30 : -1;
            this.samplePts += this.sampleDuration;
            this.sampleDuration = 0;
            this.tcFrames = 0;
        }
        this.sampleDuration += packet.getDuration();
        this.tcFrames++;
    };
    prototype.isGap = function(prevTimecode, tapeTimecode) {
        var gap = false;
        if (prevTimecode == null && tapeTimecode != null) {
            gap = true;
        } else if (prevTimecode != null) {
            if (tapeTimecode == null) 
                gap = true;
             else {
                if (prevTimecode.isDropFrame() != tapeTimecode.isDropFrame()) {
                    gap = true;
                } else {
                    gap = this.isTimeGap(prevTimecode, tapeTimecode);
                }
            }
        }
        return gap;
    };
    prototype.isTimeGap = function(prevTimecode, tapeTimecode) {
        var gap = false;
        var sec = this.toSec(tapeTimecode);
        var secDiff = sec - this.toSec(prevTimecode);
        if (secDiff == 0) {
            var frameDiff = tapeTimecode.getFrame() - prevTimecode.getFrame();
            if (this.fpsEstimate != -1) 
                frameDiff = (frameDiff + this.fpsEstimate) % this.fpsEstimate;
            gap = frameDiff != 1;
        } else if (secDiff == 1) {
            if (this.fpsEstimate == -1) {
                if (tapeTimecode.getFrame() == 0) 
                    this.fpsEstimate = prevTimecode.getFrame() + 1;
                 else 
                    gap = true;
            } else {
                var firstFrame = tapeTimecode.isDropFrame() && (sec % 60) == 0 && (sec % 600) != 0 ? 2 : 0;
                if (tapeTimecode.getFrame() != firstFrame || prevTimecode.getFrame() != this.fpsEstimate - 1) 
                    gap = true;
            }
        } else {
            gap = true;
        }
        return gap;
    };
    prototype.outTimecodeSample = function() {
        if (this.sampleDuration > 0) {
            if (this.firstTimecode != null) {
                if (this.fpsEstimate == -1) 
                    this.fpsEstimate = this.prevTimecode.getFrame() + 1;
                var tmcd = TimecodeSampleEntry.createTimecodeSampleEntry((this.firstTimecode.isDropFrame() ? 1 : 0), this.timescale, (((stjs.trunc(this.sampleDuration / this.tcFrames))) | 0), this.fpsEstimate);
                this.sampleEntries.add(tmcd);
                var sample = ByteBuffer.allocate(4);
                sample.putInt(this.toCounter(this.firstTimecode, this.fpsEstimate));
                sample.flip();
                this.addFrame(MP4Packet.createMP4Packet(sample, this.samplePts, this.timescale, this.sampleDuration, 0, true, null, 0, this.samplePts, this.sampleEntries.size() - 1));
                this.lower.add(new Edit(this.sampleDuration, this.samplePts, 1.0));
            } else {
                this.lower.add(new Edit(this.sampleDuration, -1, 1.0));
            }
        }
    };
    prototype.toCounter = function(tc, fps) {
        var frames = this.toSec(tc) * fps + tc.getFrame();
        if (tc.isDropFrame()) {
            var D = stjs.trunc(frames / 18000);
            var M = frames % 18000;
            frames -= 18 * D + 2 * (stjs.trunc((M - 2) / 1800));
        }
        return frames;
    };
    prototype.toSec = function(tc) {
        return tc.getHour() * 3600 + tc.getMinute() * 60 + tc.getSecond();
    };
}, {prevTimecode: "TapeTimecode", firstTimecode: "TapeTimecode", lower: {name: "List", arguments: ["Edit"]}, gop: {name: "List", arguments: ["Packet"]}, sampleDurations: {name: "List", arguments: ["TimeToSampleBox.TimeToSampleEntry"]}, chunkOffsets: "LongArrayList", sampleSizes: "IntArrayList", iframes: "IntArrayList", compositionOffsets: {name: "List", arguments: ["CompositionOffsetsBox.Entry"]}, timecodeTrack: "TimecodeMP4MuxerTrack", out: "SeekableByteChannel", type: "TrackType", tgtChunkDuration: "Rational", tgtChunkDurationUnit: {name: "Enum", arguments: ["Unit"]}, curChunk: {name: "List", arguments: ["ByteBuffer"]}, samplesInChunks: {name: "List", arguments: ["SampleToChunkBox.SampleToChunkEntry"]}, sampleEntries: {name: "List", arguments: ["SampleEntry"]}, edits: {name: "List", arguments: ["Edit"]}}, {});
var DefaultBoxes = function() {
    Boxes.call(this);
    this.mappings.put(MovieExtendsBox.fourcc(), MovieExtendsBox);
    this.mappings.put(MovieExtendsHeaderBox.fourcc(), MovieExtendsHeaderBox);
    this.mappings.put(SegmentIndexBox.fourcc(), SegmentIndexBox);
    this.mappings.put(SegmentTypeBox.fourcc(), SegmentTypeBox);
    this.mappings.put(TrackExtendsBox.fourcc(), TrackExtendsBox);
    this.mappings.put(VideoMediaHeaderBox.fourcc(), VideoMediaHeaderBox);
    this.mappings.put(FileTypeBox.fourcc(), FileTypeBox);
    this.mappings.put(MovieBox.fourcc(), MovieBox);
    this.mappings.put(MovieHeaderBox.fourcc(), MovieHeaderBox);
    this.mappings.put(TrakBox.fourcc(), TrakBox);
    this.mappings.put(TrackHeaderBox.fourcc(), TrackHeaderBox);
    this.mappings.put("edts", NodeBox);
    this.mappings.put(EditListBox.fourcc(), EditListBox);
    this.mappings.put(MediaBox.fourcc(), MediaBox);
    this.mappings.put(MediaHeaderBox.fourcc(), MediaHeaderBox);
    this.mappings.put(MediaInfoBox.fourcc(), MediaInfoBox);
    this.mappings.put(HandlerBox.fourcc(), HandlerBox);
    this.mappings.put(DataInfoBox.fourcc(), DataInfoBox);
    this.mappings.put("stbl", NodeBox);
    this.mappings.put(SampleDescriptionBox.fourcc(), SampleDescriptionBox);
    this.mappings.put(TimeToSampleBox.fourcc(), TimeToSampleBox);
    this.mappings.put(SyncSamplesBox.STSS, SyncSamplesBox);
    this.mappings.put(PartialSyncSamplesBox.STPS, PartialSyncSamplesBox);
    this.mappings.put(SampleToChunkBox.fourcc(), SampleToChunkBox);
    this.mappings.put(SampleSizesBox.fourcc(), SampleSizesBox);
    this.mappings.put(ChunkOffsetsBox.fourcc(), ChunkOffsetsBox);
    this.mappings.put("mvex", NodeBox);
    this.mappings.put("moof", NodeBox);
    this.mappings.put("traf", NodeBox);
    this.mappings.put("mfra", NodeBox);
    this.mappings.put("skip", NodeBox);
    this.mappings.put("meta", Box.LeafBox);
    this.mappings.put(DataRefBox.fourcc(), DataRefBox);
    this.mappings.put("ipro", NodeBox);
    this.mappings.put("sinf", NodeBox);
    this.mappings.put(ChunkOffsets64Box.fourcc(), ChunkOffsets64Box);
    this.mappings.put(SoundMediaHeaderBox.fourcc(), SoundMediaHeaderBox);
    this.mappings.put("clip", NodeBox);
    this.mappings.put(ClipRegionBox.fourcc(), ClipRegionBox);
    this.mappings.put(LoadSettingsBox.fourcc(), LoadSettingsBox);
    this.mappings.put("tapt", NodeBox);
    this.mappings.put("gmhd", NodeBox);
    this.mappings.put("tmcd", Box.LeafBox);
    this.mappings.put("tref", NodeBox);
    this.mappings.put(ClearApertureBox.CLEF, ClearApertureBox);
    this.mappings.put(ProductionApertureBox.PROF, ProductionApertureBox);
    this.mappings.put(EncodedPixelBox.ENOF, EncodedPixelBox);
    this.mappings.put(GenericMediaInfoBox.fourcc(), GenericMediaInfoBox);
    this.mappings.put(TimecodeMediaInfoBox.fourcc(), TimecodeMediaInfoBox);
    this.mappings.put("udta", NodeBox);
    this.mappings.put(CompositionOffsetsBox.fourcc(), CompositionOffsetsBox);
    this.mappings.put(NameBox.fourcc(), NameBox);
    this.mappings.put(MovieFragmentHeaderBox.fourcc(), MovieFragmentHeaderBox);
    this.mappings.put(TrackFragmentHeaderBox.fourcc(), TrackFragmentHeaderBox);
    this.mappings.put(MovieFragmentBox.fourcc(), MovieFragmentBox);
    this.mappings.put(TrackFragmentBox.fourcc(), TrackFragmentBox);
    this.mappings.put(TrackFragmentBaseMediaDecodeTimeBox.fourcc(), TrackFragmentBaseMediaDecodeTimeBox);
    this.mappings.put(TrunBox.fourcc(), TrunBox);
};
DefaultBoxes = stjs.extend(DefaultBoxes, Boxes, [], null, {mappings: {name: "Map", arguments: [null, {name: "Class", arguments: ["Object"]}]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Default box factory
 *  
 *  @author The JCodec project
 *  
 */
var BoxFactory = function(boxes) {
    this.boxes = boxes;
};
BoxFactory = stjs.extend(BoxFactory, null, [IBoxFactory], function(constructor, prototype) {
    constructor.instance = new BoxFactory(new DefaultBoxes());
    constructor.audio = new BoxFactory(new AudioBoxes());
    constructor.data = new BoxFactory(new DataBoxes());
    constructor.sample = new BoxFactory(new SampleBoxes());
    constructor.timecode = new BoxFactory(new TimecodeBoxes());
    constructor.video = new BoxFactory(new VideoBoxes());
    constructor.waveext = new BoxFactory(new WaveExtBoxes());
    prototype.boxes = null;
    constructor.getDefault = function() {
        return BoxFactory.instance;
    };
    prototype.newBox = function(header) {
        var claz = this.boxes.toClass(header.getFourcc());
        var fourcc = header.getFourcc();
        if (claz == null) 
            return new Box.LeafBox(header);
        var box = Platform.newInstance(claz, [header]);
        if (stjs.isInstanceOf(box.constructor, NodeBox)) {
            var nodebox = box;
            if (stjs.isInstanceOf(nodebox.constructor, SampleDescriptionBox)) {
                nodebox.setFactory(BoxFactory.sample);
            } else if (stjs.isInstanceOf(nodebox.constructor, VideoSampleEntry)) {
                nodebox.setFactory(BoxFactory.video);
            } else if (stjs.isInstanceOf(nodebox.constructor, AudioSampleEntry)) {
                nodebox.setFactory(BoxFactory.audio);
            } else if (stjs.isInstanceOf(nodebox.constructor, TimecodeSampleEntry)) {
                nodebox.setFactory(BoxFactory.timecode);
            } else if (stjs.isInstanceOf(nodebox.constructor, DataRefBox)) {
                nodebox.setFactory(BoxFactory.data);
            } else if (stjs.isInstanceOf(nodebox.constructor, WaveExtension)) {
                nodebox.setFactory(BoxFactory.waveext);
            } else {
                nodebox.setFactory(this);
            }
        }
        return box;
    };
}, {instance: "IBoxFactory", audio: "IBoxFactory", data: "IBoxFactory", sample: "IBoxFactory", timecode: "IBoxFactory", video: "IBoxFactory", waveext: "IBoxFactory", boxes: "Boxes"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MP4Util = function() {};
MP4Util = stjs.extend(MP4Util, null, [], function(constructor, prototype) {
    constructor.codecMapping = new HashMap();
    constructor.createRefMovie = function(input, url) {
        var movie = MP4Util.parseMovieChannel(input);
        var tracks = movie.getTracks();
        for (var i = 0; i < tracks.length; i++) {
            var trakBox = tracks[i];
            trakBox.setDataRef(url);
        }
        return movie;
    };
    constructor.parseMovieChannel = function(input) {
        for (var iterator$atom = MP4Util.getRootAtoms(input).iterator(); iterator$atom.hasNext(); ) {
            var atom = iterator$atom.next();
            if ("moov".equals(atom.getHeader().getFourcc())) {
                return atom.parseBox(input);
            }
        }
        return null;
    };
    constructor.parseMovieFragments = function(input) {
        var moov = null;
        var fragments = new LinkedList();
        for (var iterator$atom = MP4Util.getRootAtoms(input).iterator(); iterator$atom.hasNext(); ) {
            var atom = iterator$atom.next();
            if ("moov".equals(atom.getHeader().getFourcc())) {
                moov = atom.parseBox(input);
            } else if ("moof".equalsIgnoreCase(atom.getHeader().getFourcc())) {
                fragments.add(atom.parseBox(input));
            }
        }
        for (var iterator$fragment = fragments.iterator(); iterator$fragment.hasNext(); ) {
            var fragment = iterator$fragment.next();
            fragment.setMovie(moov);
        }
        return fragments;
    };
    constructor.getRootAtoms = function(input) {
        input.setPosition(0);
        var result = new ArrayList();
        var off = 0;
        var atom;
         while (off < input.size()){
            input.setPosition(off);
            atom = Header.read(NIOUtils.fetchFromChannel(input, 16));
            if (atom == null) 
                break;
            result.add(new MP4Util.Atom(atom, off));
            off += atom.getSize();
        }
        return result;
    };
    constructor.findFirstAtomInFile = function(fourcc, input) {
        var c = new AutoFileChannelWrapper(input);
        try {
            return MP4Util.findFirstAtom(fourcc, c);
        } finally {
            IOUtils.closeQuietly(c);
        }
    };
    constructor.findFirstAtom = function(fourcc, input) {
        var rootAtoms = MP4Util.getRootAtoms(input);
        for (var iterator$atom = rootAtoms.iterator(); iterator$atom.hasNext(); ) {
            var atom = iterator$atom.next();
            if (fourcc.equals(atom.getHeader().getFourcc())) 
                return atom;
        }
        return null;
    };
    constructor.atom = function(input) {
        var off = input.position();
        var atom = Header.read(NIOUtils.fetchFromChannel(input, 16));
        return atom == null ? null : new MP4Util.Atom(atom, off);
    };
    constructor.Atom = function(header, offset) {
        this.header = header;
        this.offset = offset;
    };
    constructor.Atom = stjs.extend(constructor.Atom, null, [], function(constructor, prototype) {
        prototype.offset = 0;
        prototype.header = null;
        prototype.getOffset = function() {
            return this.offset;
        };
        prototype.getHeader = function() {
            return this.header;
        };
        prototype.parseBox = function(input) {
            input.setPosition(this.offset + this.header.headerSize());
            return BoxUtil.parseBox(NIOUtils.fetchFromChannel(input, ((this.header.getBodySize()) | 0)), this.header, BoxFactory.getDefault());
        };
        prototype.copy = function(input, out) {
            input.setPosition(this.offset);
            NIOUtils.copy(input, out, this.header.getSize());
        };
    }, {header: "Header"}, {});
    constructor.parseMovie = function(source) {
        var input = null;
        try {
            input = NIOUtils.readableChannel(source);
            return MP4Util.parseMovieChannel(input);
        } finally {
            if (input != null) 
                input.close();
        }
    };
    constructor.createRefMovieFromFile = function(source) {
        var input = null;
        try {
            input = NIOUtils.readableChannel(source);
            return MP4Util.createRefMovie(input, "file://" + source.getCanonicalPath());
        } finally {
            if (input != null) 
                input.close();
        }
    };
    constructor.writeMovieToFile = function(f, movie) {
        var out = null;
        try {
            out = NIOUtils.writableChannel(f);
            MP4Util.writeMovie(out, movie);
        } finally {
            out.close();
        }
    };
    constructor.writeMovie = function(out, movie) {
        MP4Util.doWriteMovieToChannel(out, movie, 0);
    };
    constructor.doWriteMovieToChannel = function(out, movie, additionalSize) {
        var sizeHint = MP4Util.estimateMoovBoxSize(movie) + additionalSize;
        jcodec.Logger.debug("Using " + sizeHint + " bytes for MOOV box");
        var buf = ByteBuffer.allocate(sizeHint);
        movie.write(buf);
        buf.flip();
        out.write(buf);
    };
    /**
     *  Estimate buffer size needed to write MOOV box based on the amount of
     *  stuff in there
     *  
     *  @param movie
     *  @return
     */
    constructor.estimateMoovBoxSize = function(movie) {
        var sizeHint = 4 << 10;
        var tracks = movie.getTracks();
        for (var i = 0; i < tracks.length; i++) {
            var trak = tracks[i];
            sizeHint += 4 << 10;
            var edits = trak.getEdits();
            sizeHint += edits != null ? (edits.size() << 3) + (edits.size() << 2) : 0;
            var stco = trak.getStco();
            sizeHint += stco != null ? (stco.getChunkOffsets().length << 2) : 0;
            var co64 = trak.getCo64();
            sizeHint += co64 != null ? (co64.getChunkOffsets().length << 3) : 0;
            var stsz = trak.getStsz();
            sizeHint += stsz != null ? (stsz.getDefaultSize() != 0 ? 0 : (stsz.getCount() << 2)) : 0;
            var stts = trak.getStts();
            sizeHint += stts != null ? (stts.getEntries().length << 3) : 0;
            var stss = trak.getStss();
            sizeHint += stss != null ? (stss.getSyncSamples().length << 2) : 0;
            var ctts = trak.getCtts();
            sizeHint += ctts != null ? (ctts.getEntries().length << 3) : 0;
            var stsc = trak.getStsc();
            sizeHint += stsc != null ? (stsc.getSampleToChunk().length << 3) + (stsc.getSampleToChunk().length << 2) : 0;
        }
        return sizeHint;
    };
    constructor.getFourcc = function(codec) {
        return MP4Util.codecMapping.get(codec);
    };
    constructor.writeBox = function(box, approxSize) {
        var buf = ByteBuffer.allocate(approxSize);
        box.write(buf);
        buf.flip();
        return buf;
    };
}, {codecMapping: {name: "Map", arguments: [{name: "Enum", arguments: ["Codec"]}, null]}}, {});
(function() {
    MP4Util.codecMapping.put(Codec.MPEG2, "m2v1");
    MP4Util.codecMapping.put(Codec.H264, "avc1");
    MP4Util.codecMapping.put(Codec.J2K, "mjp2");
})();
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Parses MP4 header and allows custom MP4Editor to modify it, then tries to put
 *  the resulting header into the same place relatively to a file.
 *  
 *  This might not work out, for example if the resulting header is bigger then
 *  the original.
 *  
 *  Use this class to make blazing fast changes to MP4 files when you know your
 *  are not adding anything new to the header, perhaps only patching some values
 *  or removing stuff from the header.
 *  
 *  @author The JCodec project
 *  
 */
var InplaceMP4Editor = function() {};
InplaceMP4Editor = stjs.extend(InplaceMP4Editor, null, [], function(constructor, prototype) {
    /**
     *  Tries to modify movie header in place according to what's implemented in
     *  the edit, the file gets pysically modified if the operation is
     *  successful. No temporary file is created.
     *  
     *  @param file
     *             A file to be modified
     *  @param edit
     *             An edit to be carried out on a movie header
     *  @return Whether or not edit was successful, i.e. was there enough place
     *          to put the new header
     *  @throws IOException
     *  @throws Exception
     */
    prototype.modify = function(file, edit) {
        var fi = null;
        try {
            fi = NIOUtils.rwChannel(file);
            var fragments = this.doTheFix(fi, edit);
            if (fragments == null) 
                return false;
            for (var iterator$fragment = fragments.iterator(); iterator$fragment.hasNext(); ) {
                var fragment = iterator$fragment.next();
                this.replaceBox(fi, fragment.v0, fragment.v1);
            }
            return true;
        } finally {
            NIOUtils.closeQuietly(fi);
        }
    };
    /**
     *  Tries to modify movie header in place according to what's implemented in
     *  the edit. Copies modified contents to a new file.
     *  
     *  Note: The header is still edited in-place, so the new file will have
     *  all-the-same sample offsets.
     *  
     *  Note: Still subject to the same limitations as 'modify', i.e. the new
     *  header must 'fit' into an old place.
     *  
     *  This method is useful when you can't write to the original file, for ex.
     *  you don't have permission.
     *  
     *  @param src
     *             An original file
     *  @param dst
     *             A file to store the modified copy
     *  @param edit
     *             An edit logic to apply
     *  @return
     *  @throws IOException
     */
    prototype.copy = function(src, dst, edit) {
        var fi = null;
        var fo = null;
        try {
            fi = NIOUtils.readableChannel(src);
            fo = NIOUtils.writableChannel(dst);
            var fragments = this.doTheFix(fi, edit);
            if (fragments == null) 
                return false;
            var fragOffsets = Tuple._2map0(fragments, new (stjs.extend(function InplaceMP4Editor$1() {}, null, [Tuple.Mapper], function(constructor, prototype) {
                prototype.map = function(t) {
                    return t.getOffset();
                };
            }, {}, {}))());
            var rewrite = Tuple.asMap(fragOffsets);
            for (var iterator$atom = MP4Util.getRootAtoms(fi).iterator(); iterator$atom.hasNext(); ) {
                var atom = iterator$atom.next();
                var byteBuffer = rewrite.get(atom.getOffset());
                if (byteBuffer != null) 
                    fo.write(byteBuffer);
                 else 
                    atom.copy(fi, fo);
            }
            return true;
        } finally {
            NIOUtils.closeQuietly(fi);
            NIOUtils.closeQuietly(fo);
        }
    };
    /**
     *  Tries to modify movie header in place according to what's implemented in
     *  the edit. Copies modified contents to a new file with the same name
     *  erasing the original file if successful.
     *  
     *  This is a shortcut for 'copy' when you want the new file to have the same
     *  name but for some reason can not modify the original file in place. Maybe
     *  modifications of files are expensive or not supported on your filesystem.
     *  
     *  @param src
     *             A source and destination file
     *  @param edit
     *             An edit to be applied
     *  @return
     *  @throws IOException
     */
    prototype.replace = function(src, edit) {
        var tmp = new File(src.getParentFile(), "." + src.getName());
        if (this.copy(src, tmp, edit)) {
            tmp.renameTo(src);
            return true;
        }
        return false;
    };
    prototype.doTheFix = function(fi, edit) {
        var moovAtom = this.getMoov(fi);
        Assert.assertNotNull(moovAtom);
        var moovBuffer = this.fetchBox(fi, moovAtom);
        var moovBox = this.parseBox(moovBuffer);
        var fragments = new LinkedList();
        if (BoxUtil.containsBox(moovBox, "mvex")) {
            var temp = new LinkedList();
            for (var iterator$fragAtom = this.getFragments(fi).iterator(); iterator$fragAtom.hasNext(); ) {
                var fragAtom = iterator$fragAtom.next();
                var fragBuffer = this.fetchBox(fi, fragAtom);
                fragments.add(Tuple._2(fragAtom, fragBuffer));
                var fragBox = this.parseBox(fragBuffer);
                fragBox.setMovie(moovBox);
                temp.add(Tuple._2(fragBuffer, fragBox));
            }
            edit.applyToFragment(moovBox, Tuple._2_project1(temp).toArray(Array(0)));
            for (var iterator$frag = temp.iterator(); iterator$frag.hasNext(); ) {
                var frag = iterator$frag.next();
                if (!this.rewriteBox(frag.v0, frag.v1)) 
                    return null;
            }
        } else 
            edit.apply(moovBox);
        if (!this.rewriteBox(moovBuffer, moovBox)) 
            return null;
        fragments.add(Tuple._2(moovAtom, moovBuffer));
        return fragments;
    };
    prototype.replaceBox = function(fi, atom, buffer) {
        fi.setPosition(atom.getOffset());
        fi.write(buffer);
    };
    prototype.rewriteBox = function(buffer, box) {
        try {
            buffer.clear();
            box.write(buffer);
            if (buffer.hasRemaining()) {
                if (buffer.remaining() < 8) 
                    return false;
                buffer.putInt(buffer.remaining());
                buffer.putArr(new Int8Array(['f', 'r', 'e', 'e']));
            }
            buffer.flip();
            return true;
        }catch (e) {
            return false;
        }
    };
    prototype.fetchBox = function(fi, moov) {
        fi.setPosition(moov.getOffset());
        var oldMov = NIOUtils.fetchFromChannel(fi, ((moov.getHeader().getSize()) | 0));
        return oldMov;
    };
    prototype.parseBox = function(oldMov) {
        var header = Header.read(oldMov);
        var box = BoxUtil.parseBox(oldMov, header, BoxFactory.getDefault());
        return box;
    };
    prototype.getMoov = function(f) {
        for (var iterator$atom = MP4Util.getRootAtoms(f).iterator(); iterator$atom.hasNext(); ) {
            var atom = iterator$atom.next();
            if ("moov".equals(atom.getHeader().getFourcc())) {
                return atom;
            }
        }
        return null;
    };
    prototype.getFragments = function(f) {
        var result = new LinkedList();
        for (var iterator$atom = MP4Util.getRootAtoms(f).iterator(); iterator$atom.hasNext(); ) {
            var atom = iterator$atom.next();
            if ("moof".equals(atom.getHeader().getFourcc())) {
                result.add(atom);
            }
        }
        return result;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Creates MP4 file out of a set of samples
 *  
 *  @author The JCodec project
 *  
 */
var MP4Muxer = function(output, ftyp) {
    this.tracks = new ArrayList();
    this.out = output;
    var buf = ByteBuffer.allocate(1024);
    ftyp.write(buf);
    Header.createHeader("wide", 8).write(buf);
    Header.createHeader("mdat", 1).write(buf);
    this.mdatOffset = buf.position();
    buf.putLong(0);
    buf.flip();
    output.write(buf);
};
MP4Muxer = stjs.extend(MP4Muxer, null, [], function(constructor, prototype) {
    prototype.tracks = null;
    prototype.mdatOffset = 0;
    prototype.nextTrackId = 1;
    prototype.out = null;
    constructor.createMP4MuxerToChannel = function(output) {
        return new MP4Muxer(output, Brand.MP4.getFileTypeBox());
    };
    constructor.createMP4Muxer = function(output, brand) {
        return new MP4Muxer(output, brand.getFileTypeBox());
    };
    prototype.addVideoTrackWithTimecode = function(fourcc, size, encoderName, timescale) {
        var timecode = this.addTimecodeTrack(timescale);
        var track = this.addTrack(TrackType.VIDEO, timescale);
        track.addSampleEntry(MP4Muxer.videoSampleEntry(fourcc, size, encoderName));
        track.setTimecode(timecode);
        return track;
    };
    prototype.addVideoTrack = function(fourcc, size, encoderName, timescale) {
        var track = this.addTrack(TrackType.VIDEO, timescale);
        track.addSampleEntry(MP4Muxer.videoSampleEntry(fourcc, size, encoderName));
        return track;
    };
    constructor.videoSampleEntry = function(fourcc, size, encoderName) {
        return VideoSampleEntry.createVideoSampleEntry(new Header(fourcc), ((0) << 16 >> 16), ((0) << 16 >> 16), "jcod", 0, 768, ((size.getWidth()) << 16 >> 16), ((size.getHeight()) << 16 >> 16), 72, 72, ((1) << 16 >> 16), encoderName != null ? encoderName : "jcodec", ((24) << 16 >> 16), ((1) << 16 >> 16), ((-1) << 16 >> 16));
    };
    constructor.audioSampleEntry = function(fourcc, drefId, sampleSize, channels, sampleRate, endian) {
        var ase = AudioSampleEntry.createAudioSampleEntry(Header.createHeader(fourcc, 0), ((drefId) << 16 >> 16), ((channels) << 16 >> 16), ((16) << 16 >> 16), sampleRate, ((0) << 16 >> 16), 0, 65535, 0, 1, sampleSize, channels * sampleSize, sampleSize, ((1) << 16 >> 16));
        var wave = new NodeBox(new Header("wave"));
        ase.add(wave);
        wave.add(FormatBox.createFormatBox(fourcc));
        wave.add(EndianBox.createEndianBox(endian));
        wave.add(MP4Muxer.terminatorAtom());
        return ase;
    };
    constructor.compressedAudioSampleEntry = function(fourcc, drefId, sampleSize, channels, sampleRate, samplesPerPacket, bytesPerPacket, bytesPerFrame) {
        var ase = AudioSampleEntry.createAudioSampleEntry(Header.createHeader(fourcc, 0), ((drefId) << 16 >> 16), ((channels) << 16 >> 16), ((16) << 16 >> 16), sampleRate, ((0) << 16 >> 16), 0, 65534, 0, samplesPerPacket, bytesPerPacket, bytesPerFrame, stjs.trunc(16 / 8), ((1) << 16 >> 16));
        return ase;
    };
    constructor.terminatorAtom = function() {
        return Box.LeafBox.createLeafBox(new Header(Platform.stringFromBytes(new Int8Array(4))), ByteBuffer.allocate(0));
    };
    prototype.addTimecodeTrack = function(timescale) {
        var track = new TimecodeMP4MuxerTrack(this.out, this.nextTrackId++, timescale);
        this.tracks.add(track);
        return track;
    };
    prototype.addTrack = function(type, timescale) {
        var track = new FramesMP4MuxerTrack(this.out, this.nextTrackId++, type, timescale);
        this.tracks.add(track);
        return track;
    };
    prototype.addPCMTrack = function(timescale, sampleDuration, sampleSize, se) {
        var track = new PCMMP4MuxerTrack(this.out, this.nextTrackId++, TrackType.SOUND, timescale, sampleDuration, sampleSize, se);
        this.tracks.add(track);
        return track;
    };
    prototype.getTracks = function() {
        return this.tracks;
    };
    prototype.writeHeader = function() {
        var movie = this.finalizeHeader();
        this.storeHeader(movie);
    };
    prototype.storeHeader = function(movie) {
        var mdatSize = this.out.position() - this.mdatOffset + 8;
        MP4Util.writeMovie(this.out, movie);
        this.out.setPosition(this.mdatOffset);
        NIOUtils.writeLong(this.out, mdatSize);
    };
    prototype.finalizeHeader = function() {
        var movie = MovieBox.createMovieBox();
        var mvhd = this.movieHeader(movie);
        movie.addFirst(mvhd);
        for (var iterator$track = this.tracks.iterator(); iterator$track.hasNext(); ) {
            var track = iterator$track.next();
            var trak = track.finish(mvhd);
            if (trak != null) 
                movie.add(trak);
        }
        return movie;
    };
    prototype.getVideoTrack = function() {
        for (var iterator$frameMuxer = this.tracks.iterator(); iterator$frameMuxer.hasNext(); ) {
            var frameMuxer = iterator$frameMuxer.next();
            if (frameMuxer.isVideo()) {
                return frameMuxer;
            }
        }
        return null;
    };
    prototype.getTimecodeTrack = function() {
        for (var iterator$frameMuxer = this.tracks.iterator(); iterator$frameMuxer.hasNext(); ) {
            var frameMuxer = iterator$frameMuxer.next();
            if (frameMuxer.isTimecode()) {
                return frameMuxer;
            }
        }
        return null;
    };
    prototype.getAudioTracks = function() {
        var result = new ArrayList();
        for (var iterator$frameMuxer = this.tracks.iterator(); iterator$frameMuxer.hasNext(); ) {
            var frameMuxer = iterator$frameMuxer.next();
            if (frameMuxer.isAudio()) {
                result.add(frameMuxer);
            }
        }
        return result;
    };
    prototype.movieHeader = function(movie) {
        var timescale = this.tracks.get(0).getTimescale();
        var duration = this.tracks.get(0).getTrackTotalDuration();
        var videoTrack = this.getVideoTrack();
        if (videoTrack != null) {
            timescale = videoTrack.getTimescale();
            duration = videoTrack.getTrackTotalDuration();
        }
        return MovieHeaderBox.createMovieHeaderBox(timescale, duration, 1.0, 1.0, new jsutil.Date().getTime(), new jsutil.Date().getTime(), new Int32Array([65536, 0, 0, 0, 65536, 0, 0, 0, 1073741824]), this.nextTrackId);
    };
    constructor.lookupFourcc = function(format) {
        if (format.getSampleSizeInBits() == 16 && !format.isBigEndian()) 
            return "sowt";
         else if (format.getSampleSizeInBits() == 24) 
            return "in24";
         else 
             throw new NotSupportedException("Audio format " + format + " is not supported.");
    };
    prototype.addPCMAudioTrack = function(format) {
        return this.addPCMTrack(stjs.trunc(format.getSampleRate()), 1, (format.getSampleSizeInBits() >> 3) * format.getChannels(), MP4Muxer._audioSampleEntry(format));
    };
    constructor._audioSampleEntry = function(format) {
        return MP4Muxer.audioSampleEntry(MP4Muxer.lookupFourcc(format), 1, format.getSampleSizeInBits() >> 3, format.getChannels(), stjs.trunc(format.getSampleRate()), format.isBigEndian() ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN);
    };
    prototype.addCompressedAudioTrack = function(fourcc, timescale, channels, sampleRate, samplesPerPkt, extra) {
        var track = this.addTrack(TrackType.SOUND, timescale);
        var ase = AudioSampleEntry.createAudioSampleEntry(Header.createHeader(fourcc, 0), ((1) << 16 >> 16), ((channels) << 16 >> 16), ((16) << 16 >> 16), sampleRate, ((0) << 16 >> 16), 0, 65534, 0, samplesPerPkt, 0, 0, 2, ((1) << 16 >> 16));
        var wave = new NodeBox(new Header("wave"));
        ase.add(wave);
        wave.add(FormatBox.createFormatBox(fourcc));
        for (var i = 0; i < extra.length; i++) {
            var box = extra[i];
            wave.add(box);
        }
        wave.add(MP4Muxer.terminatorAtom());
        track.addSampleEntry(ase);
        return track;
    };
}, {tracks: {name: "List", arguments: ["AbstractMP4MuxerTrack"]}, out: "SeekableByteChannel"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Uses QuickTime feature to undo the recent changes
 *  
 *  @author The JCodec project
 *  
 */
var Undo = function() {};
Undo = stjs.extend(Undo, null, [], function(constructor, prototype) {
    constructor.main1 = function(args) {
        if (args.length < 1) {
            System.err.println("Syntax: qt-undo [-l] <movie>");
            System.err.println("\t-l\t\tList all the previous versions of this movie.");
            System.exit(-1);
        }
        var undo = new Undo();
        if ("-l".equals(args[0])) {
            var list = undo.list(args[1]);
            System.out.println((list.size() - 1) + " versions.");
        } else {
            undo.undo(args[0]);
        }
    };
    prototype.undo = function(fineName) {
        var versions = this.list(fineName);
        if (versions.size() < 2) {
            System.err.println("Nowhere to rollback.");
            return;
        }
        var raf = null;
        try {
            raf = new RandomAccessFile(new File(fineName), "rw");
            raf.seek(versions.get(versions.size() - 2).getOffset() + 4);
            raf.write(new Int8Array(['m', 'o', 'o', 'v']));
            raf.seek(versions.get(versions.size() - 1).getOffset() + 4);
            raf.write(new Int8Array(['f', 'r', 'e', 'e']));
        } finally {
            raf.close();
        }
    };
    prototype.list = function(fileName) {
        var result = new ArrayList();
        var is = null;
        try {
            is = NIOUtils.readableChannel(new File(fileName));
            var version = 0;
            for (var iterator$atom = MP4Util.getRootAtoms(is).iterator(); iterator$atom.hasNext(); ) {
                var atom = iterator$atom.next();
                if ("free".equals(atom.getHeader().getFourcc()) && this.isMoov(is, atom)) {
                    result.add(atom);
                }
                if ("moov".equals(atom.getHeader().getFourcc())) {
                    result.add(atom);
                    break;
                }
            }
        } finally {
            is.close();
        }
        return result;
    };
    prototype.isMoov = function(is, atom) {
        is.setPosition(atom.getOffset() + atom.getHeader().headerSize());
        try {
            var mov = BoxUtil.parseBox(NIOUtils.fetchFromChannel(is, ((atom.getHeader().getSize()) | 0)), Header.createHeader("moov", atom.getHeader().getSize()), BoxFactory.getDefault());
            return (stjs.isInstanceOf(mov.constructor, MovieBox)) && BoxUtil.containsBox(mov, "mvhd");
        }catch (t) {
            return false;
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var QTRefEdit = function(_arguments) {
    this.factories = arguments;
};
QTRefEdit = stjs.extend(QTRefEdit, null, [], function(constructor, prototype) {
    prototype.factories = null;
    prototype.execute = function(args) {
        var aa = new LinkedList(Arrays.asList(args));
        var edits = new LinkedList();
         while (aa.size() > 0){
            var i;
            for (i = 0; i < this.factories.length; i++) {
                if (aa.get(0).equals(this.factories[i].getName())) {
                    aa.remove(0);
                    try {
                        edits.add(this.factories[i].parseArgs(aa));
                    }catch (e) {
                        System.err.println("ERROR: " + e.getMessage());
                        return;
                    }
                    break;
                }
            }
            if (i == this.factories.length) 
                break;
        }
        if (aa.size() == 0) {
            System.err.println("ERROR: A movie file should be specified");
            this.help();
        }
        if (edits.size() == 0) {
            System.err.println("ERROR: At least one command should be specified");
            this.help();
        }
        var input = new File(aa.remove(0));
        if (aa.size() == 0) {
            System.err.println("ERROR: A movie output file should be specified");
            this.help();
        }
        var output = new File(aa.remove(0));
        if (!input.exists()) {
            System.err.println("ERROR: Input file '" + input.getAbsolutePath() + "' doesn't exist");
            this.help();
        }
        if (output.exists()) {
            System.err.println("WARNING: Output file '" + output.getAbsolutePath() + "' exist, overwritting");
        }
        var ref = MP4Util.createRefMovieFromFile(input);
        new CompoundMP4Edit(edits).apply(ref);
        MP4Util.writeMovieToFile(output, ref);
        System.out.println("INFO: Created reference file: " + output.getAbsolutePath());
    };
    prototype.help = function() {
        System.out.println("Quicktime movie editor");
        System.out.println("Syntax: qtedit <command1> <options> ... <commandN> <options> <movie> <output>");
        System.out.println("Where options:");
        for (var commandFactory in this.factories) {
            System.out.println("\t" + commandFactory.getHelp());
        }
        System.exit(-1);
    };
}, {factories: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Strips movie to editlist
 *  
 *  @author The JCodec project
 *  
 */
var Strip = function() {};
Strip = stjs.extend(Strip, null, [], function(constructor, prototype) {
    constructor.main1 = function(args) {
        if (args.length < 2) {
            System.out.println("Syntax: strip <ref movie> <out movie>");
            System.exit(-1);
        }
        var input = null;
        var out = null;
        try {
            input = NIOUtils.readableChannel(new File(args[0]));
            var file = new File(args[1]);
            Platform.deleteFile(file);
            out = NIOUtils.writableChannel(file);
            var movie = MP4Util.createRefMovie(input, "file://" + new File(args[0]).getAbsolutePath());
            new Strip().strip(movie);
            MP4Util.writeMovie(out, movie);
        } finally {
            if (input != null) 
                input.close();
            if (out != null) 
                out.close();
        }
    };
    prototype.strip = function(movie) {
        var tracks = movie.getTracks();
        for (var i = 0; i < tracks.length; i++) {
            var track = tracks[i];
            this.stripTrack(movie, track);
        }
    };
    prototype.stripTrack = function(movie, track) {
        var chunks = new ChunkReader(track);
        var edits = track.getEdits();
        var oldEdits = this.deepCopy(edits);
        var result = new ArrayList();
        var chunk;
         while ((chunk = chunks.next()) != null){
            var intersects = false;
            for (var iterator$edit = oldEdits.iterator(); iterator$edit.hasNext(); ) {
                var edit = iterator$edit.next();
                if (edit.getMediaTime() == -1) 
                    continue;
                var editS = edit.getMediaTime();
                var editE = edit.getMediaTime() + track.rescale(edit.getDuration(), movie.getTimescale());
                var chunkS = chunk.getStartTv();
                var chunkE = chunk.getStartTv() + chunk.getDuration();
                intersects = this.intersects(editS, editE, chunkS, chunkE);
                if (intersects) 
                    break;
            }
            if (!intersects) {
                for (var i = 0; i < oldEdits.size(); i++) {
                    if (oldEdits.get(i).getMediaTime() >= chunk.getStartTv() + chunk.getDuration()) 
                        edits.get(i).shift(-chunk.getDuration());
                }
            } else 
                result.add(chunk);
        }
        var stbl = NodeBox.findFirstPath(track, NodeBox, Box.path("mdia.minf.stbl"));
        stbl.replace("stts", this.getTimeToSamples(result));
        stbl.replace("stsz", this.getSampleSizes(result));
        stbl.replace("stsc", this.getSamplesToChunk(result));
        stbl.removeChildren("stco", "co64");
        stbl.add(this.getChunkOffsets(result));
        NodeBox.findFirstPath(track, MediaHeaderBox, Box.path("mdia.mdhd")).setDuration(this.totalDuration(result));
    };
    prototype.totalDuration = function(result) {
        var duration = 0;
        for (var iterator$chunk = result.iterator(); iterator$chunk.hasNext(); ) {
            var chunk = iterator$chunk.next();
            duration += chunk.getDuration();
        }
        return duration;
    };
    prototype.deepCopy = function(edits) {
        var newList = new ArrayList();
        for (var iterator$edit = edits.iterator(); iterator$edit.hasNext(); ) {
            var edit = iterator$edit.next();
            newList.add(Edit.createEdit(edit));
        }
        return newList;
    };
    prototype.getChunkOffsets = function(chunks) {
        var result = Array(chunks.size());
        var longBox = false;
        var i = 0;
        for (var iterator$chunk = chunks.iterator(); iterator$chunk.hasNext(); ) {
            var chunk = iterator$chunk.next();
            if (chunk.getOffset() >= 4294967296) 
                longBox = true;
            result[i++] = chunk.getOffset();
        }
        return longBox ? ChunkOffsets64Box.createChunkOffsets64Box(result) : ChunkOffsetsBox.createChunkOffsetsBox(result);
    };
    prototype.getTimeToSamples = function(chunks) {
        var tts = new ArrayList();
        var curTts = -1, cnt = 0;
        for (var iterator$chunk = chunks.iterator(); iterator$chunk.hasNext(); ) {
            var chunk = iterator$chunk.next();
            if (chunk.getSampleDur() > 0) {
                if (curTts == -1 || curTts != chunk.getSampleDur()) {
                    if (curTts != -1) 
                        tts.add(new TimeToSampleBox.TimeToSampleEntry(cnt, curTts));
                    cnt = 0;
                    curTts = chunk.getSampleDur();
                }
                cnt += chunk.getSampleCount();
            } else {
                for (var dur in chunk.getSampleDurs()) {
                    if (curTts == -1 || curTts != dur) {
                        if (curTts != -1) 
                            tts.add(new TimeToSampleBox.TimeToSampleEntry(cnt, curTts));
                        cnt = 0;
                        curTts = dur;
                    }
                    ++cnt;
                }
            }
        }
        if (cnt > 0) 
            tts.add(new TimeToSampleBox.TimeToSampleEntry(cnt, curTts));
        return TimeToSampleBox.createTimeToSampleBox(tts.toArray(Array(0)));
    };
    prototype.getSampleSizes = function(chunks) {
        var nSamples = 0, prevSize = chunks.get(0).getSampleSize();
        for (var iterator$chunk = chunks.iterator(); iterator$chunk.hasNext(); ) {
            var chunk = iterator$chunk.next();
            nSamples += chunk.getSampleCount();
            if (prevSize == 0 && chunk.getSampleSize() != 0) 
                 throw new RuntimeException("Mixed sample sizes not supported");
        }
        if (prevSize > 0) 
            return SampleSizesBox.createSampleSizesBox(prevSize, nSamples);
        var sizes = new Int32Array(nSamples);
        var startSample = 0;
        for (var iterator$chunk = chunks.iterator(); iterator$chunk.hasNext(); ) {
            var chunk = iterator$chunk.next();
            System.arraycopy(chunk.getSampleSizes(), 0, sizes, startSample, chunk.getSampleCount());
            startSample += chunk.getSampleCount();
        }
        return SampleSizesBox.createSampleSizesBox2(sizes);
    };
    prototype.getSamplesToChunk = function(chunks) {
        var result = new ArrayList();
        var it = chunks.iterator();
        var chunk = it.next();
        var curSz = chunk.getSampleCount();
        var curEntry = chunk.getEntry();
        var first = 1, cnt = 1;
         while (it.hasNext()){
            chunk = it.next();
            var newSz = chunk.getSampleCount();
            var newEntry = chunk.getEntry();
            if (curSz != newSz || curEntry != newEntry) {
                result.add(new SampleToChunkBox.SampleToChunkEntry(first, curSz, curEntry));
                curSz = newSz;
                curEntry = newEntry;
                first += cnt;
                cnt = 0;
            }
            ++cnt;
        }
        if (cnt > 0) 
            result.add(new SampleToChunkBox.SampleToChunkEntry(first, curSz, curEntry));
        return SampleToChunkBox.createSampleToChunkBox(result.toArray(Array(0)));
    };
    prototype.intersects = function(a, b, c, d) {
        return (a >= c && a < d) || (b >= c && b < d) || (c >= a && c < b) || (d >= a && d < b);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A virtual track that extracts frames from MXF as it those were from MP4
 *  
 *  @author The JCodec project
 *  
 */
var MXFVirtualTrack = function(track, fp) {
    this.fp = fp;
    this.track = track;
    this.essenceUL = track.getEssenceUL();
};
MXFVirtualTrack = stjs.extend(MXFVirtualTrack, null, [VirtualTrack], function(constructor, prototype) {
    prototype.track = null;
    prototype.fp = null;
    prototype.essenceUL = null;
    constructor.createDemuxer = function(channel) {
        return new MXFVirtualTrack.PatchedMXFDemuxer(channel);
    };
    prototype.nextPacket = function() {
        var nextFrame = this.track.nextFrame();
        if (nextFrame == null) 
            return null;
        return new MXFVirtualTrack.MXFVirtualPacket(this, nextFrame);
    };
    constructor.MXFVirtualPacket = function(track, pkt) {
        this.track = track;
        this.pkt = pkt;
    };
    constructor.MXFVirtualPacket = stjs.extend(constructor.MXFVirtualPacket, null, [VirtualPacket], function(constructor, prototype) {
        prototype.pkt = null;
        prototype.track = null;
        prototype.getData = function() {
            var ch = null;
            try {
                ch = this.track.fp.getChannel();
                ch.setPosition(this.pkt.getOffset());
                var kl = KLV.readKL(ch);
                 while (kl != null && !this.track.essenceUL.equals(kl.key)){
                    ch.setPosition(ch.position() + kl.len);
                    kl = KLV.readKL(ch);
                }
                return kl != null && this.track.essenceUL.equals(kl.key) ? NIOUtils.fetchFromChannel(ch, ((kl.len) | 0)) : null;
            } finally {
                NIOUtils.closeQuietly(ch);
            }
        };
        prototype.getDataLen = function() {
            return this.pkt.getLen();
        };
        prototype.getPts = function() {
            return this.pkt.getPtsD();
        };
        prototype.getDuration = function() {
            return this.pkt.getDurationD();
        };
        prototype.isKeyframe = function() {
            return this.pkt.isKeyFrame();
        };
        prototype.getFrameNo = function() {
            return ((this.pkt.getFrameNo()) | 0);
        };
    }, {pkt: "MXFDemuxer.MXFPacket", track: "MXFVirtualTrack", byPts: {name: "Comparator", arguments: ["Object"]}}, {});
    prototype.getCodecMeta = function() {
        return this.toSampleEntry(this.track.getDescriptor());
    };
    prototype.toSampleEntry = function(d) {
        if (this.track.isVideo()) {
            var ped = d;
            var ar = ped.getAspectRatio();
            var se = VideoCodecMeta.createVideoCodecMeta(MP4Util.getFourcc(this.track.getCodec().getCodec()), null, new Size(ped.getDisplayWidth(), ped.getDisplayHeight()), new Rational(stjs.trunc((stjs.trunc((1000 * ar.getNum() * ped.getDisplayHeight()) / (ar.getDen() * ped.getDisplayWidth())))), 1000));
            return se;
        } else if (this.track.isAudio()) {
            var sed = d;
            var sampleSize = sed.getQuantizationBits() >> 3;
            var codec = this.track.getCodec();
            var labels = Array(sed.getChannelCount());
            Arrays.fill(labels, Label.Mono);
            return AudioCodecMeta.createAudioCodecMeta(sampleSize == 3 ? "in24" : "sowt", sampleSize, sed.getChannelCount(), stjs.trunc(sed.getAudioSamplingRate().scalar()), codec == MXFConst.MXFCodecMapping.PCM_S16BE ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN, true, labels, null);
        }
         throw new RuntimeException("Can't get sample entry");
    };
    prototype.getEdits = function() {
        return null;
    };
    prototype.getPreferredTimescale = function() {
        return -1;
    };
    prototype.close = function() {
        this.fp.close();
    };
    constructor.PatchedMXFDemuxer = function(ch) {
        MXFDemuxer.call(this, ch);
    };
    constructor.PatchedMXFDemuxer = stjs.extend(constructor.PatchedMXFDemuxer, MXFDemuxer, [], function(constructor, prototype) {
        prototype.createTrack = function(ul, track, descriptor) {
            return new (stjs.extend(function MXFVirtualTrack$PatchedMXFDemuxer$1(x0, x1, x2, x3) {
                MXFDemuxer.MXFDemuxerTrack.call(this, x0, x1, x2, x3);
            }, MXFDemuxer.MXFDemuxerTrack, [], function(constructor, prototype) {
                prototype.readPacket = function(off, len, pts, timescale, duration, frameNo, kf) {
                    return new MXFDemuxer.MXFPacket(null, pts, timescale, duration, frameNo, kf, null, off, len);
                };
            }, {essenceUL: "UL", descriptor: "GenericDescriptor", track: "TimelineTrack", codec: "MXFConst.MXFCodecMapping", demuxer: "MXFDemuxer"}, {}))(this, ul, track, descriptor);
        };
    }, {metadata: {name: "List", arguments: ["MXFMetadata"]}, header: "MXFPartition", partitions: {name: "List", arguments: ["MXFPartition"]}, indexSegments: {name: "List", arguments: ["IndexSegment"]}, ch: "SeekableByteChannel", tracks: "Array", timecode: "TimecodeComponent"}, {});
    prototype.getTrackId = function() {
        return this.track.getTrackId();
    };
}, {track: "MXFDemuxer.MXFDemuxerTrack", fp: "ByteChannelPool", essenceUL: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var SampleOffsetUtils = function() {};
SampleOffsetUtils = stjs.extend(SampleOffsetUtils, null, [], function(constructor, prototype) {
    constructor.getSampleData = function(sample, file) {
        var moov = MP4Util.parseMovie(file);
        var minf = moov.getAudioTracks().get(0).getMdia().getMinf();
        var stco = NodeBox.findFirstPath(minf, ChunkOffsetsBox, Box.path("stbl.stco"));
        var stsc = NodeBox.findFirstPath(minf, SampleToChunkBox, Box.path("stbl.stsc"));
        var stsz = NodeBox.findFirstPath(minf, SampleSizesBox, Box.path("stbl.stsz"));
        var sampleOffset = SampleOffsetUtils.getSampleOffset(sample, stsc, stco, stsz);
        var map = NIOUtils.mapFile(file);
        map.setPosition(((sampleOffset) | 0));
        map.setLimit(map.position() + stsz.getSizes()[sample]);
        return map;
    };
    constructor.getSampleOffset = function(sample, stsc, stco, stsz) {
        var chunkBySample = SampleOffsetUtils.getChunkBySample(sample, stco, stsc);
        var firstSampleAtChunk = SampleOffsetUtils.getFirstSampleAtChunk(chunkBySample, stsc, stco);
        var offset = stco.getChunkOffsets()[chunkBySample - 1];
        var sizes = stsz.getSizes();
        for (var i = firstSampleAtChunk; i < sample; i++) {
            offset += sizes[i];
        }
        return offset;
    };
    constructor.getFirstSampleAtChunk = function(chunk, stsc, stco) {
        var chunks = stco.getChunkOffsets().length;
        var samples = 0;
        for (var i = 1; i <= chunks; i++) {
            if (i == chunk) {
                break;
            }
            var samplesInChunk = SampleOffsetUtils.getSamplesInChunk(i, stsc);
            samples += samplesInChunk;
        }
        return samples;
    };
    constructor.getChunkBySample = function(sampleOfInterest, stco, stsc) {
        var chunks = stco.getChunkOffsets().length;
        var startSample = 0;
        var endSample = 0;
        for (var i = 1; i <= chunks; i++) {
            var samplesInChunk = SampleOffsetUtils.getSamplesInChunk(i, stsc);
            endSample = startSample + samplesInChunk;
            if (sampleOfInterest >= startSample && sampleOfInterest < endSample) {
                return i;
            }
            startSample = endSample;
        }
        return -1;
    };
    constructor.getSamplesInChunk = function(chunk, stsc) {
        var sampleToChunk = stsc.getSampleToChunk();
        var sampleCount = 0;
        for (var sampleToChunkEntry in sampleToChunk) {
            if (sampleToChunkEntry.getFirst() > chunk) {
                return sampleCount;
            }
            sampleCount = sampleToChunkEntry.getCount();
        }
        return sampleCount;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MovDump = function() {};
MovDump = stjs.extend(MovDump, null, [], function(constructor, prototype) {
    constructor.main1 = function(args) {
        if (args.length < 1) {
            System.out.println("Syntax: movdump [options] <filename>");
            System.out.println("Options: \n\t-f <filename> save header to a file\n\t-a <atom name> dump only a specific atom\n");
            return;
        }
        var idx = 0;
        var headerFile = null;
        var atom = null;
         while (idx < args.length){
            if ("-f".equals(args[idx])) {
                ++idx;
                headerFile = new File(args[idx++]);
            } else if ("-a".equals(args[idx])) {
                ++idx;
                atom = args[idx++];
            } else 
                break;
        }
        var source = new File(args[idx]);
        if (headerFile != null) {
            MovDump.dumpHeader(headerFile, source);
        }
        if (atom == null) 
            System.out.println(MovDump.print(source));
         else {
            var dump = MovDump.printAtom(source, atom);
            if (dump != null) 
                System.out.println(dump);
        }
    };
    constructor.dumpHeader = function(headerFile, source) {
        var raf = null;
        var daos = null;
        try {
            raf = NIOUtils.readableChannel(source);
            daos = NIOUtils.writableChannel(headerFile);
            for (var iterator$atom = MP4Util.getRootAtoms(raf).iterator(); iterator$atom.hasNext(); ) {
                var atom = iterator$atom.next();
                var fourcc = atom.getHeader().getFourcc();
                if ("moov".equals(fourcc) || "ftyp".equals(fourcc)) {
                    atom.copy(raf, daos);
                }
            }
        } finally {
            raf.close();
            daos.close();
        }
    };
    constructor.print = function(file) {
        return MP4Util.parseMovie(file).toString();
    };
    constructor.findDeep = function(root, atom) {
        for (var iterator$b = root.getBoxes().iterator(); iterator$b.hasNext(); ) {
            var b = iterator$b.next();
            if (atom.equalsIgnoreCase(b.getFourcc())) {
                return b;
            } else if (stjs.isInstanceOf(b.constructor, NodeBox)) {
                var res = MovDump.findDeep(b, atom);
                if (res != null) 
                    return res;
            }
        }
        return null;
    };
    constructor.printAtom = function(file, atom) {
        var mov = MP4Util.parseMovie(file);
        var found = MovDump.findDeep(mov, atom);
        if (found == null) {
            System.out.println("Atom " + atom + " not found.");
            return null;
        }
        return found.toString();
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Self contained movie creator
 *  
 *  @author The JCodec project
 *  
 */
var Flattern = function() {
    this.listeners = new ArrayList();
};
Flattern = stjs.extend(Flattern, null, [], function(constructor, prototype) {
    constructor.main1 = function(args) {
        if (args.length < 2) {
            System.out.println("Syntax: self <ref movie> <out movie>");
            System.exit(-1);
        }
        var outFile = new File(args[1]);
        Platform.deleteFile(outFile);
        var input = null;
        try {
            input = NIOUtils.readableChannel(new File(args[0]));
            var movie = MP4Util.parseMovieChannel(input);
            new Flattern().flattern(movie, outFile);
        } finally {
            if (input != null) 
                input.close();
        }
    };
    prototype.listeners = null;
    constructor.ProgressListener = function() {};
    constructor.ProgressListener = stjs.extend(constructor.ProgressListener, null, [], function(constructor, prototype) {
        prototype.trigger = function(progress) {};
    }, {}, {});
    prototype.addProgressListener = function(listener) {
        this.listeners.add(listener);
    };
    prototype.flatternChannel = function(movie, out) {
        if (!movie.isPureRefMovie(movie)) 
             throw new IllegalArgumentException("movie should be reference");
        var buf = ByteBuffer.allocate(16 * 1024 * 1024);
        var ftyp = FileTypeBox.createFileTypeBox("qt  ", 537199360, Arrays.asList(["qt  "]));
        ftyp.write(buf);
        var movieOff = buf.position();
        movie.write(buf);
        var extraSpace = this.calcSpaceReq(movie);
        Header.createHeader("free", 8 + extraSpace).write(buf);
        NIOUtils.skip(buf, extraSpace);
        var mdatOff = buf.position();
        Header.createHeader("mdat", 4294967297).write(buf);
        buf.flip();
        out.write(buf);
        var inputs = this.getInputs(movie);
        var tracks = movie.getTracks();
        var readers = Array(tracks.length);
        var writers = Array(tracks.length);
        var head = Array(tracks.length);
        var totalChunks = 0, writtenChunks = 0, lastProgress = 0;
        var off = Array(tracks.length);
        for (var i = 0; i < tracks.length; i++) {
            readers[i] = new ChunkReader(tracks[i]);
            totalChunks += readers[i].size();
            writers[i] = new ChunkWriter(tracks[i], inputs[i], out);
            head[i] = readers[i].next();
            if (tracks[i].isVideo()) 
                off[i] = 2 * movie.getTimescale();
        }
         while (true){
            var min = -1;
            for (var i = 0; i < readers.length; i++) {
                if (head[i] == null) 
                    continue;
                if (min == -1) 
                    min = i;
                 else {
                    var iTv = movie.rescale(head[i].getStartTv(), tracks[i].getTimescale()) + off[i];
                    var minTv = movie.rescale(head[min].getStartTv(), tracks[min].getTimescale()) + off[min];
                    if (iTv < minTv) 
                        min = i;
                }
            }
            if (min == -1) 
                break;
            writers[min].write(head[min]);
            head[min] = readers[min].next();
            writtenChunks++;
            lastProgress = this.calcProgress(totalChunks, writtenChunks, lastProgress);
        }
        var mdatSize = out.position() - mdatOff;
        for (var i = 0; i < tracks.length; i++) {
            writers[i].apply();
        }
        out.setPosition(movieOff);
        MP4Util.writeMovie(out, movie);
        var extra = mdatOff - out.position();
        if (extra < 0) 
             throw new RuntimeException("Not enough space to write the header");
        out.write(ByteBuffer.allocate(8).putInt(((extra) | 0)).putArr(new Int8Array(['f', 'r', 'e', 'e'])).flip());
        out.setPosition(mdatOff + 8);
        out.write(ByteBuffer.allocate(8).putLong(mdatSize));
    };
    prototype.calcProgress = function(totalChunks, writtenChunks, lastProgress) {
        var curProgress = stjs.trunc(100 * writtenChunks / totalChunks);
        if (lastProgress < curProgress) {
            lastProgress = curProgress;
            for (var iterator$pl = this.listeners.iterator(); iterator$pl.hasNext(); ) {
                var pl = iterator$pl.next();
                pl.trigger(lastProgress);
            }
        }
        return lastProgress;
    };
    prototype.getInputs = function(movie) {
        var tracks = movie.getTracks();
        var result = Array(tracks.length);
        for (var i = 0; i < tracks.length; i++) {
            var drefs = NodeBox.findFirstPath(tracks[i], DataRefBox, Box.path("mdia.minf.dinf.dref"));
            if (drefs == null) {
                 throw new RuntimeException("No data references");
            }
            var entries = drefs.getBoxes();
            var e = Array(entries.size());
            var inputs = Array(entries.size());
            for (var j = 0; j < e.length; j++) {
                inputs[j] = this.resolveDataRef(entries.get(j));
            }
            result[i] = inputs;
        }
        return result;
    };
    prototype.calcSpaceReq = function(movie) {
        var sum = 0;
        var tracks = movie.getTracks();
        for (var i = 0; i < tracks.length; i++) {
            var trakBox = tracks[i];
            var stco = trakBox.getStco();
            if (stco != null) 
                sum += stco.getChunkOffsets().length * 4;
        }
        return sum;
    };
    prototype.resolveDataRef = function(box) {
        if (stjs.isInstanceOf(box.constructor, UrlBox)) {
            var url = (box).getUrl();
            if (!url.startsWith("file://")) 
                 throw new RuntimeException("Only file:// urls are supported in data reference");
            return NIOUtils.readableChannel(new File(url.substring(7)));
        } else if (stjs.isInstanceOf(box.constructor, AliasBox)) {
            var uxPath = (box).getUnixPath();
            if (uxPath == null) 
                 throw new RuntimeException("Could not resolve alias");
            return NIOUtils.readableChannel(new File(uxPath));
        } else {
             throw new RuntimeException(box.getHeader().getFourcc() + " dataref type is not supported");
        }
    };
    prototype.flattern = function(movie, video) {
        Platform.deleteFile(video);
        var out = null;
        try {
            out = NIOUtils.writableChannel(video);
            this.flatternChannel(movie, out);
        } finally {
            if (out != null) 
                out.close();
        }
    };
}, {listeners: {name: "List", arguments: ["Flattern.ProgressListener"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var ChangeTimescale = function() {};
ChangeTimescale = stjs.extend(ChangeTimescale, null, [], function(constructor, prototype) {
    constructor.main1 = function(args) {
        if (args.length < 2) {
            System.out.println("Syntax: chts <movie> <timescale>");
            System.exit(-1);
        }
        var ts = Integer.parseInt(args[1]);
        if (ts < 600) {
            System.out.println("Could not set timescale < 600");
            System.exit(-1);
        }
        new InplaceMP4Editor().modify(new File(args[0]), new (stjs.extend(function ChangeTimescale$1() {}, null, [MP4Edit], function(constructor, prototype) {
            prototype.apply = function(mov) {
                var vt = mov.getVideoTrack();
                var mdhd = NodeBox.findFirstPath(vt, MediaHeaderBox, Box.path("mdia.mdhd"));
                var oldTs = mdhd.getTimescale();
                if (oldTs > ts) {
                     throw new RuntimeException("Old timescale (" + oldTs + ") is greater then new timescale (" + ts + "), not touching.");
                }
                vt.fixMediaTimescale(ts);
                mov.fixTimescale(ts);
            };
            prototype.applyToFragment = function(mov, fragmentBox) {
                 throw new RuntimeException("Unsupported");
            };
        }, {}, {}))());
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var SetPAR = function() {};
SetPAR = stjs.extend(SetPAR, null, [], function(constructor, prototype) {
    constructor.main1 = function(args) {
        if (args.length < 2) {
            System.out.println("Syntax: setpasp <movie> <num:den>");
            System.exit(-1);
        }
        var newPAR = Rational.parse(args[1]);
        new InplaceMP4Editor().modify(new File(args[0]), new (stjs.extend(function SetPAR$1() {}, null, [MP4Edit], function(constructor, prototype) {
            prototype.apply = function(mov) {
                var vt = mov.getVideoTrack();
                vt.setPAR(newPAR);
                var box = NodeBox.findFirstPath(vt, SampleDescriptionBox, Box.path("mdia.minf.stbl.stsd")).getBoxes().get(0);
                if (box != null && (stjs.isInstanceOf(box.constructor, VideoSampleEntry))) {
                    var vs = box;
                    var codedWidth = stjs.trunc(vs.getWidth());
                    var codedHeight = stjs.trunc(vs.getHeight());
                    var displayWidth = stjs.trunc(codedWidth * newPAR.getNum() / newPAR.getDen());
                    vt.getTrackHeader().setWidth(displayWidth);
                    if (BoxUtil.containsBox(vt, "tapt")) {
                        vt.setAperture(new Size(codedWidth, codedHeight), new Size(displayWidth, codedHeight));
                    }
                }
            };
            prototype.applyToFragment = function(mov, fragmentBox) {
                 throw new RuntimeException("Unsupported");
            };
        }, {}, {}))());
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 * 
 *  Changes FPS on an MP4 file.
 * 
 *  @author Stan Vitvitskyy
 */
var SetFPS = function() {};
SetFPS = stjs.extend(SetFPS, null, [], function(constructor, prototype) {
    constructor.MIN_TIMESCALE_ALLOWED = 25;
    constructor.main1 = function(args) {
        var cmd = MainUtils.parseArguments(args);
        if (cmd.argsLength() < 2) {
            MainUtils.printHelpNoFlags("movie", "num:den");
            System.exit(-1);
        }
        var newFPS = RationalLarge.parse(cmd.getArg(1));
        new InplaceMP4Editor().modify(new File(cmd.getArg(0)), new (stjs.extend(function SetFPS$1() {}, null, [MP4Edit], function(constructor, prototype) {
            prototype.apply = function(mov) {
                var vt = mov.getVideoTrack();
                var stts = vt.getStts();
                var entries = stts.getEntries();
                var nSamples = 0;
                var totalDuration = 0;
                for (var e in entries) {
                    nSamples += e.getSampleCount();
                    totalDuration += e.getSampleCount() * e.getSampleDuration();
                }
                var newTimescale = ((newFPS.multiply(new RationalLarge(totalDuration, nSamples)).scalarClip()) | 0);
                if (newTimescale >= SetFPS.MIN_TIMESCALE_ALLOWED) {
                    vt.setTimescale(newTimescale);
                } else {
                    var mul = new RationalLarge(vt.getTimescale() * totalDuration, nSamples).divideBy(newFPS).scalar();
                    jcodec.Logger.info("Applying multiplier to sample durations: " + mul);
                    for (var e in entries) {
                        e.setSampleDuration(stjs.trunc((e.getSampleDuration() * mul * 100)));
                    }
                    vt.setTimescale(vt.getTimescale() * 100);
                }
                if (newTimescale != vt.getTimescale()) {
                    jcodec.Logger.info("Changing timescale to: " + vt.getTimescale());
                    var newDuration = stjs.trunc(totalDuration * mov.getTimescale() / vt.getTimescale());
                    mov.setDuration(newDuration);
                    vt.setDuration(newDuration);
                } else {
                    jcodec.Logger.info("Already at " + newFPS.toString() + "fps, not changing.");
                }
            };
            prototype.applyToFragment = function(mov, fragmentBox) {
                 throw new RuntimeException("Unsupported");
            };
        }, {}, {}))());
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var WebOptimizedMP4Muxer = function(output, brand, headerSize) {
    MP4Muxer.call(this, output, brand.getFileTypeBox());
    this.headerPos = output.position() - 24;
    output.setPosition(this.headerPos);
    this.header = ByteBuffer.allocate(headerSize);
    output.write(this.header);
    this.header.clear();
    Header.createHeader("wide", 8).writeChannel(output);
    Header.createHeader("mdat", 1).writeChannel(output);
    this.mdatOffset = output.position();
    NIOUtils.writeLong(output, 0);
};
WebOptimizedMP4Muxer = stjs.extend(WebOptimizedMP4Muxer, MP4Muxer, [], function(constructor, prototype) {
    prototype.header = null;
    prototype.headerPos = 0;
    constructor.withOldHeader = function(output, brand, oldHeader) {
        var size = ((oldHeader.getHeader().getSize()) | 0);
        var vt = oldHeader.getVideoTrack();
        var stsc = vt.getStsc();
        size -= stsc.getSampleToChunk().length * 12;
        size += 12;
        var stco = vt.getStco();
        if (stco != null) {
            size -= stco.getChunkOffsets().length << 2;
            size += vt.getFrameCount() << 3;
        } else {
            var co64 = vt.getCo64();
            size -= co64.getChunkOffsets().length << 3;
            size += vt.getFrameCount() << 3;
        }
        return new WebOptimizedMP4Muxer(output, brand, size + (size >> 1));
    };
    prototype.storeHeader = function(movie) {
        var mdatEnd = this.out.position();
        var mdatSize = mdatEnd - this.mdatOffset + 8;
        this.out.setPosition(this.mdatOffset);
        NIOUtils.writeLong(this.out, mdatSize);
        this.out.setPosition(this.headerPos);
        try {
            movie.write(this.header);
            this.header.flip();
            var rem = this.header.capacity() - this.header.limit();
            if (rem < 8) {
                this.header.duplicate().putInt(this.header.capacity());
            }
            this.out.write(this.header);
            if (rem >= 8) 
                Header.createHeader("free", rem).writeChannel(this.out);
        }catch (e) {
            jcodec.Logger.warn("Could not web-optimize, header is bigger then allocated space.");
            Header.createHeader("free", this.header.remaining()).writeChannel(this.out);
            this.out.setPosition(mdatEnd);
            MP4Util.writeMovie(this.out, movie);
        }
    };
}, {header: "ByteBuffer", tracks: {name: "List", arguments: ["AbstractMP4MuxerTrack"]}, out: "SeekableByteChannel"}, {});
var MTSRandomAccessDemuxerMain = function() {};
MTSRandomAccessDemuxerMain = stjs.extend(MTSRandomAccessDemuxerMain, null, [], function(constructor, prototype) {
    constructor.main1 = function(args) {
        var indexer = new MTSIndexer();
        var source = new File(args[0]);
        var index;
        var indexFile = new File(source.getParentFile(), source.getName() + ".idx");
        if (!indexFile.exists()) {
            indexer.index(source, null);
            index = indexer.serialize();
            NIOUtils.writeTo(index.serialize(), indexFile);
        } else {
            System.out.println("Reading index from: " + indexFile.getName());
            index = MTSIndex.parse(NIOUtils.fetchFromFile(indexFile));
        }
        var demuxer = new MTSRandomAccessDemuxer(NIOUtils.readableChannel(source), index);
        var guids = demuxer.getGuids();
        var video = MTSRandomAccessDemuxerMain.getVideoStream(demuxer.getProgramDemuxer(guids[0]));
        var ch = NIOUtils.writableChannel(new File(args[1]));
        var mp4Muxer = MP4Muxer.createMP4Muxer(ch, Brand.MOV);
        var videoTrack = mp4Muxer.addVideoTrack("m2v1", new Size(1920, 1080), "jcod", 90000);
        video.gotoSyncFrame(175);
        var pkt = video.nextFrame();
        var firstPts = pkt.getPts();
        for (var i = 0; pkt != null && i < 150; i++) {
            videoTrack.addFrame(MP4Packet.createMP4Packet(pkt.getData(), pkt.getPts() - firstPts, pkt.getTimescale(), pkt.getDuration(), pkt.getFrameNo(), pkt.isKeyFrame(), pkt.getTapeTimecode(), 0, pkt.getPts() - firstPts, 0));
            pkt = video.nextFrame();
        }
        mp4Muxer.writeHeader();
        NIOUtils.closeQuietly(ch);
    };
    constructor.getVideoStream = function(demuxer) {
        var streams = demuxer.getStreams();
        for (var stream in streams) {
            if (stream.getStreamId() >= 224 && stream.getStreamId() <= 239) 
                return stream;
        }
        return null;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A decoding track for PCM DVD stream
 *  
 *  @author The JCodec project
 *  
 */
var PCMDVDTrack = function(src) {
    this.src = src;
    this.prevPkt = src.nextPacket();
    this.decoder = new PCMDVDDecoder();
    if (this.prevPkt != null) {
        var decodeFrame = this.decoder.decodeFrame(this.prevPkt.getData(), ByteBuffer.allocate(this.prevPkt.getData().remaining()));
        this.format = decodeFrame.getFormat();
        this.nFrames = decodeFrame.getNFrames();
    }
};
PCMDVDTrack = stjs.extend(PCMDVDTrack, null, [VirtualTrack], function(constructor, prototype) {
    prototype.src = null;
    prototype.format = null;
    prototype.prevPkt = null;
    prototype.decoder = null;
    prototype.nFrames = 0;
    prototype.nextPacket = function() {
        if (this.prevPkt == null) 
            return null;
        var ret = this.prevPkt;
        this.prevPkt = this.src.nextPacket();
        return new PCMDVDTrack.PCMDVDPkt(this, ret);
    };
    constructor.PCMDVDPkt = function(track, src) {
        VirtualPacketWrapper.call(this, src);
        this.track = track;
    };
    constructor.PCMDVDPkt = stjs.extend(constructor.PCMDVDPkt, VirtualPacketWrapper, [], function(constructor, prototype) {
        prototype.track = null;
        prototype.getData = function() {
            var data = VirtualPacketWrapper.prototype.getData.call(this);
            var decodeFrame = this.track.decoder.decodeFrame(data, data);
            return decodeFrame.getData();
        };
        prototype.getDataLen = function() {
            return (this.track.nFrames * this.track.format.getChannels()) << 1;
        };
    }, {track: "PCMDVDTrack", src: "VirtualPacket", byPts: {name: "Comparator", arguments: ["Object"]}}, {});
    prototype.getCodecMeta = function() {
        return AudioCodecMeta.createAudioCodecMeta3(MP4Muxer.lookupFourcc(this.format), ByteBuffer.allocate(0), this.format, true, [Label.Left, Label.Right]);
    };
    prototype.getEdits = function() {
        return null;
    };
    prototype.getPreferredTimescale = function() {
        return this.format.getSampleRate();
    };
    prototype.close = function() {
        this.src.close();
    };
}, {src: "VirtualTrack", format: "AudioFormat", prevPkt: "VirtualPacket", decoder: "PCMDVDDecoder"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var H264Utils = function() {};
H264Utils = stjs.extend(H264Utils, null, [], function(constructor, prototype) {
    constructor.shr = new SliceHeaderReader();
    constructor.shw = new SliceHeaderWriter();
    constructor.nextNALUnit = function(buf) {
        H264Utils.skipToNALUnit(buf);
        return H264Utils.gotoNALUnit(buf);
    };
    constructor.skipToNALUnit = function(buf) {
        if (!buf.hasRemaining()) 
            return;
        var val = -1;
         while (buf.hasRemaining()){
            val <<= 8;
            val |= (buf.get() & 255);
            if ((val & 16777215) == 1) {
                buf.setPosition(buf.position());
                break;
            }
        }
    };
    /**
     *  Finds next Nth H.264 bitstream NAL unit (0x00000001) and returns the data
     *  that preceeds it as a ByteBuffer slice
     *  
     *  Segment byte order is always little endian
     *  
     *  TODO: emulation prevention
     *  
     *  @param buf
     *  @return
     */
    constructor.gotoNALUnit = function(buf) {
        if (!buf.hasRemaining()) 
            return null;
        var from = buf.position();
        var result = buf.slice();
        result.order(ByteOrder.BIG_ENDIAN);
        var val = -1;
         while (buf.hasRemaining()){
            val <<= 8;
            val |= (buf.get() & 255);
            if ((val & 16777215) == 1) {
                buf.setPosition(buf.position() - (val == 1 ? 4 : 3));
                result.setLimit(buf.position() - from);
                break;
            }
        }
        return result;
    };
    constructor.unescapeNAL = function(_buf) {
        if (_buf.remaining() < 2) 
            return;
        var _in = _buf.duplicate();
        var out = _buf.duplicate();
        var p1 = _in.get();
        out.put(p1);
        var p2 = _in.get();
        out.put(p2);
         while (_in.hasRemaining()){
            var b = _in.get();
            if (p1 != 0 || p2 != 0 || b != 3) 
                out.put(b);
            p1 = p2;
            p2 = b;
        }
        _buf.setLimit(out.position());
    };
    constructor.escapeNALinplace = function(src) {
        var loc = H264Utils.searchEscapeLocations(src);
        var old = src.limit();
        src.setLimit(src.limit() + loc.length);
        for (var newPos = src.limit() - 1, oldPos = old - 1, locIdx = loc.length - 1; newPos >= src.position(); newPos-- , oldPos--) {
            src.putAt(newPos, src.getAt(oldPos));
            if (locIdx >= 0 && loc[locIdx] == oldPos) {
                newPos--;
                src.putAt(newPos, (3 << 24 >> 24));
                locIdx--;
            }
        }
    };
    constructor.searchEscapeLocations = function(src) {
        var points = IntArrayList.createIntArrayList();
        var search = src.duplicate();
        var p = search.getShort();
         while (search.hasRemaining()){
            var b = search.get();
            if (p == 0 && (b & ~3) == 0) {
                points.add(search.position() - 1);
                p = 3;
            }
            p <<= 8;
            p |= b & 255;
        }
        var array = points.toArray();
        return array;
    };
    constructor.escapeNAL = function(src, dst) {
        var p1 = src.get(), p2 = src.get();
        dst.put(p1);
        dst.put(p2);
         while (src.hasRemaining()){
            var b = src.get();
            if (p1 == 0 && p2 == 0 && (b & 255) <= 3) {
                dst.put((3 << 24 >> 24));
                p1 = p2;
                p2 = 3;
            }
            dst.put(b);
            p1 = p2;
            p2 = b;
        }
    };
    constructor.splitMOVPacket = function(buf, avcC) {
        var result = new ArrayList();
        var nls = avcC.getNalLengthSize();
        var dup = buf.duplicate();
         while (dup.remaining() >= nls){
            var len = H264Utils.readLen(dup, nls);
            if (len == 0) 
                break;
            result.add(NIOUtils.read(dup, len));
        }
        return result;
    };
    constructor.readLen = function(dup, nls) {
        switch (nls) {
            case 1:
                return dup.get() & 255;
            case 2:
                return dup.getShort() & 65535;
            case 3:
                return ((dup.getShort() & 65535) << 8) | (dup.get() & 255);
            case 4:
                return dup.getInt();
            default:
                 throw new IllegalArgumentException("NAL Unit length size can not be " + nls);
        }
    };
    /**
     *  Encodes AVC frame in ISO BMF format. Takes Annex B format.
     *  
     *  Scans the packet for each NAL Unit starting with 00 00 00 01 and replaces
     *  this 4 byte sequence with 4 byte integer representing this NAL unit
     *  length. Removes any leading SPS/PPS structures and collects them into a
     *  provided storaae.
     *  
     *  @param avcFrame
     *             AVC frame encoded in Annex B NAL unit format
     */
    constructor.encodeMOVPacket = function(avcFrame) {
        var dup = avcFrame.duplicate();
        var d1 = avcFrame.duplicate();
        for (var tot = d1.position(); ; ) {
            var buf = H264Utils.nextNALUnit(dup);
            if (buf == null) 
                break;
            d1.setPosition(tot);
            d1.putInt(buf.remaining());
            tot += buf.remaining() + 4;
        }
    };
    /**
     *  Decodes AVC packet in ISO BMF format into Annex B format.
     *  
     *  Replaces NAL unit size integers with 00 00 00 01 start codes. If the
     *  space allows the transformation is done inplace.
     *  
     *  @param result
     */
    constructor.decodeMOVPacket = function(result, avcC) {
        if (avcC.getNalLengthSize() == 4) {
            H264Utils.decodeMOVPacketInplace(result, avcC);
            return result;
        }
        return H264Utils.joinNALUnits(H264Utils.splitMOVPacket(result, avcC));
    };
    /**
     *  Decodes AVC packet in ISO BMF format into Annex B format.
     *  
     *  Inplace replaces NAL unit size integers with 00 00 00 01 start codes. 
     *  @param result
     */
    constructor.decodeMOVPacketInplace = function(result, avcC) {
        if (avcC.getNalLengthSize() != 4) 
             throw new IllegalArgumentException("Can only inplace decode AVC MOV packet with nal_length_size = 4.");
        var dup = result.duplicate();
         while (dup.remaining() >= 4){
            var size = dup.getInt();
            dup.setPosition(dup.position() - 4);
            dup.putInt(1);
            dup.setPosition(dup.position() + size);
        }
    };
    /**
     *  Wipes AVC parameter sets ( SPS/PPS ) from the packet
     *  
     *  @param in
     *             AVC frame encoded in Annex B NAL unit format
     *  @param out
     *             Buffer where packet without PS will be put
     *  @param spsList
     *             Storage for leading SPS structures ( can be null, then all
     *             leading SPSs are discarded ).
     *  @param ppsList
     *             Storage for leading PPS structures ( can be null, then all
     *             leading PPSs are discarded ).
     */
    constructor.wipePS = function(_in, out, spsList, ppsList) {
        var dup = _in.duplicate();
         while (dup.hasRemaining()){
            var buf = H264Utils.nextNALUnit(dup);
            if (buf == null) 
                break;
            var nu = NALUnit.read(buf.duplicate());
            if (nu.type == NALUnitType.PPS) {
                if (ppsList != null) 
                    ppsList.add(NIOUtils.duplicate(buf));
            } else if (nu.type == NALUnitType.SPS) {
                if (spsList != null) 
                    spsList.add(NIOUtils.duplicate(buf));
            } else {
                out.putInt(1);
                out.putBuf(buf);
            }
        }
        out.flip();
    };
    /**
     *  Wipes AVC parameter sets ( SPS/PPS ) from the packet ( inplace operation
     *  )
     *  
     *  @param in
     *             AVC frame encoded in Annex B NAL unit format
     *  @param spsList
     *             Storage for leading SPS structures ( can be null, then all
     *             leading SPSs are discarded ).
     *  @param ppsList
     *             Storage for leading PPS structures ( can be null, then all
     *             leading PPSs are discarded ).
     */
    constructor.wipePSinplace = function(_in, spsList, ppsList) {
        var dup = _in.duplicate();
         while (dup.hasRemaining()){
            var buf = H264Utils.nextNALUnit(dup);
            if (buf == null) 
                break;
            var nu = NALUnit.read(buf);
            if (nu.type == NALUnitType.PPS) {
                if (ppsList != null) 
                    ppsList.add(NIOUtils.duplicate(buf));
                _in.setPosition(dup.position());
            } else if (nu.type == NALUnitType.SPS) {
                if (spsList != null) 
                    spsList.add(NIOUtils.duplicate(buf));
                _in.setPosition(dup.position());
            } else if (nu.type == NALUnitType.IDR_SLICE || nu.type == NALUnitType.NON_IDR_SLICE) 
                break;
        }
    };
    constructor.createAvcC = function(sps, pps, nalLengthSize) {
        var serialSps = ByteBuffer.allocate(512);
        sps.write(serialSps);
        serialSps.flip();
        H264Utils.escapeNALinplace(serialSps);
        var serialPps = ByteBuffer.allocate(512);
        pps.write(serialPps);
        serialPps.flip();
        H264Utils.escapeNALinplace(serialPps);
        var avcC = AvcCBox.createAvcCBox(sps.profile_idc, 0, sps.level_idc, nalLengthSize, Arrays.asList(serialSps), Arrays.asList(serialPps));
        return avcC;
    };
    constructor.createAvcCFromList = function(initSPS, initPPS, nalLengthSize) {
        var serialSps = H264Utils.saveSPS(initSPS);
        var serialPps = H264Utils.savePPS(initPPS);
        var sps = initSPS.get(0);
        return AvcCBox.createAvcCBox(sps.profile_idc, 0, sps.level_idc, nalLengthSize, serialSps, serialPps);
    };
    /**
     *  @param initPPS
     *  @return
     */
    constructor.savePPS = function(initPPS) {
        var serialPps = new ArrayList();
        for (var iterator$pps = initPPS.iterator(); iterator$pps.hasNext(); ) {
            var pps = iterator$pps.next();
            var bb1 = ByteBuffer.allocate(512);
            pps.write(bb1);
            bb1.flip();
            H264Utils.escapeNALinplace(bb1);
            serialPps.add(bb1);
        }
        return serialPps;
    };
    /**
     *  @param initSPS
     *  @return
     */
    constructor.saveSPS = function(initSPS) {
        var serialSps = new ArrayList();
        for (var iterator$sps = initSPS.iterator(); iterator$sps.hasNext(); ) {
            var sps = iterator$sps.next();
            var bb1 = ByteBuffer.allocate(512);
            sps.write(bb1);
            bb1.flip();
            H264Utils.escapeNALinplace(bb1);
            serialSps.add(bb1);
        }
        return serialSps;
    };
    /**
     *  Creates a MP4 sample entry given AVC/H.264 codec private.
     *  @param codecPrivate Array containing AnnexB delimited (00 00 00 01) SPS/PPS NAL units.
     *  @return MP4 sample entry
     */
    constructor.createMOVSampleEntryFromBytes = function(codecPrivate) {
        var rawSPS = H264Utils.getRawSPS(ByteBuffer.wrap(codecPrivate));
        var rawPPS = H264Utils.getRawPPS(ByteBuffer.wrap(codecPrivate));
        return H264Utils.createMOVSampleEntryFromSpsPpsList(rawSPS, rawPPS, 4);
    };
    constructor.createMOVSampleEntryFromSpsPpsList = function(spsList, ppsList, nalLengthSize) {
        var sps = H264Utils.readSPS(NIOUtils.duplicate(spsList.get(0)));
        var avcC = AvcCBox.createAvcCBox(sps.profile_idc, 0, sps.level_idc, nalLengthSize, spsList, ppsList);
        return H264Utils.createMOVSampleEntryFromAvcC(avcC);
    };
    constructor.createMOVSampleEntryFromAvcC = function(avcC) {
        var sps = SeqParameterSet.read(avcC.getSpsList().get(0).duplicate());
        var codedWidth = (sps.pic_width_in_mbs_minus1 + 1) << 4;
        var codedHeight = SeqParameterSet.getPicHeightInMbs(sps) << 4;
        var width = sps.frame_cropping_flag ? codedWidth - ((sps.frame_crop_right_offset + sps.frame_crop_left_offset) << sps.chroma_format_idc.compWidth[1]) : codedWidth;
        var height = sps.frame_cropping_flag ? codedHeight - ((sps.frame_crop_bottom_offset + sps.frame_crop_top_offset) << sps.chroma_format_idc.compHeight[1]) : codedHeight;
        var size = new Size(width, height);
        var se = MP4Muxer.videoSampleEntry("avc1", size, "JCodec");
        se.add(avcC);
        return se;
    };
    constructor.createMOVSampleEntryFromSpsPps = function(initSPS, initPPS, nalLengthSize) {
        var bb1 = ByteBuffer.allocate(512), bb2 = ByteBuffer.allocate(512);
        initSPS.write(bb1);
        initPPS.write(bb2);
        bb1.flip();
        bb2.flip();
        return H264Utils.createMOVSampleEntryFromBuffer(bb1, bb2, nalLengthSize);
    };
    constructor.createMOVSampleEntryFromBuffer = function(sps, pps, nalLengthSize) {
        return H264Utils.createMOVSampleEntryFromSpsPpsList(Arrays.asList([sps]), Arrays.asList([pps]), nalLengthSize);
    };
    constructor.idrSliceFromBuffer = function(_data) {
        var data = _data.duplicate();
        var segment;
         while ((segment = H264Utils.nextNALUnit(data)) != null){
            if (NALUnit.read(segment).type == NALUnitType.IDR_SLICE) 
                return true;
        }
        return false;
    };
    constructor.idrSlice = function(_data) {
        for (var iterator$segment = _data.iterator(); iterator$segment.hasNext(); ) {
            var segment = iterator$segment.next();
            if (NALUnit.read(segment.duplicate()).type == NALUnitType.IDR_SLICE) 
                return true;
        }
        return false;
    };
    constructor.saveRawFrame = function(data, avcC, f) {
        var raw = NIOUtils.writableChannel(f);
        H264Utils.saveStreamParams(avcC, raw);
        raw.write(data.duplicate());
        raw.close();
    };
    constructor.saveStreamParams = function(avcC, raw) {
        var bb = ByteBuffer.allocate(1024);
        for (var iterator$byteBuffer = avcC.getSpsList().iterator(); iterator$byteBuffer.hasNext(); ) {
            var byteBuffer = iterator$byteBuffer.next();
            raw.write(ByteBuffer.wrap(new Int8Array([0, 0, 0, 1, 103])));
            H264Utils.escapeNAL(byteBuffer.duplicate(), bb);
            bb.flip();
            raw.write(bb);
            bb.clear();
        }
        for (var iterator$byteBuffer = avcC.getPpsList().iterator(); iterator$byteBuffer.hasNext(); ) {
            var byteBuffer = iterator$byteBuffer.next();
            raw.write(ByteBuffer.wrap(new Int8Array([0, 0, 0, 1, 104])));
            H264Utils.escapeNAL(byteBuffer.duplicate(), bb);
            bb.flip();
            raw.write(bb);
            bb.clear();
        }
    };
    constructor.splitFrame = function(frame) {
        var result = new ArrayList();
        var segment;
         while ((segment = H264Utils.nextNALUnit(frame)) != null){
            result.add(segment);
        }
        return result;
    };
    /**
     *  Joins buffers containing individual NAL units into a single AnnexB delimited buffer.
     *  Each NAL unit will be separated with 00 00 00 01 markers. Allocates a new byte buffer
     *  and writes data into it. 
     *  @param nalUnits
     *  @param out
     */
    constructor.joinNALUnits = function(nalUnits) {
        var size = 0;
        for (var iterator$nal = nalUnits.iterator(); iterator$nal.hasNext(); ) {
            var nal = iterator$nal.next();
            size += 4 + nal.remaining();
        }
        var allocate = ByteBuffer.allocate(size);
        H264Utils.joinNALUnitsToBuffer(nalUnits, allocate);
        return allocate;
    };
    /**
     *  Joins buffers containing individual NAL units into a single AnnexB delimited buffer.
     *  Each NAL unit will be separated with 00 00 00 01 markers. 
     *  @param nalUnits
     *  @param out
     */
    constructor.joinNALUnitsToBuffer = function(nalUnits, out) {
        for (var iterator$nal = nalUnits.iterator(); iterator$nal.hasNext(); ) {
            var nal = iterator$nal.next();
            out.putInt(1);
            out.putBuf(nal.duplicate());
        }
    };
    constructor.getAvcCData = function(avcC) {
        var bb = ByteBuffer.allocate(2048);
        avcC.doWrite(bb);
        bb.flip();
        return bb;
    };
    constructor.parseAVCC = function(vse) {
        var lb = NodeBox.findFirst(vse, Box, "avcC");
        if (stjs.isInstanceOf(lb.constructor, AvcCBox)) 
            return lb;
         else {
            return H264Utils.parseAVCCFromBuffer((lb).getData().duplicate());
        }
    };
    constructor.saveCodecPrivate = function(spsList, ppsList) {
        var totalCodecPrivateSize = 0;
        for (var iterator$byteBuffer = spsList.iterator(); iterator$byteBuffer.hasNext(); ) {
            var byteBuffer = iterator$byteBuffer.next();
            totalCodecPrivateSize += byteBuffer.remaining() + 5;
        }
        for (var iterator$byteBuffer = ppsList.iterator(); iterator$byteBuffer.hasNext(); ) {
            var byteBuffer = iterator$byteBuffer.next();
            totalCodecPrivateSize += byteBuffer.remaining() + 5;
        }
        var bb = ByteBuffer.allocate(totalCodecPrivateSize);
        for (var iterator$byteBuffer = spsList.iterator(); iterator$byteBuffer.hasNext(); ) {
            var byteBuffer = iterator$byteBuffer.next();
            bb.putInt(1);
            bb.put((103 << 24 >> 24));
            bb.putBuf(byteBuffer.duplicate());
        }
        for (var iterator$byteBuffer = ppsList.iterator(); iterator$byteBuffer.hasNext(); ) {
            var byteBuffer = iterator$byteBuffer.next();
            bb.putInt(1);
            bb.put((104 << 24 >> 24));
            bb.putBuf(byteBuffer.duplicate());
        }
        bb.flip();
        return NIOUtils.toArray(bb);
    };
    constructor.avcCToAnnexB = function(avcC) {
        return H264Utils.saveCodecPrivate(avcC.getSpsList(), avcC.getPpsList());
    };
    constructor.parseAVCCFromBuffer = function(bb) {
        return AvcCBox.parseAvcCBox(bb);
    };
    constructor.writeSPS = function(sps, approxSize) {
        var output = ByteBuffer.allocate(approxSize + 8);
        sps.write(output);
        output.flip();
        H264Utils.escapeNALinplace(output);
        return output;
    };
    constructor.readSPS = function(data) {
        var input = NIOUtils.duplicate(data);
        H264Utils.unescapeNAL(input);
        var sps = SeqParameterSet.read(input);
        return sps;
    };
    constructor.writePPS = function(pps, approxSize) {
        var output = ByteBuffer.allocate(approxSize + 8);
        pps.write(output);
        output.flip();
        H264Utils.escapeNALinplace(output);
        return output;
    };
    constructor.readPPS = function(data) {
        var input = NIOUtils.duplicate(data);
        H264Utils.unescapeNAL(input);
        var pps = PictureParameterSet.read(input);
        return pps;
    };
    constructor.findPPS = function(ppss, id) {
        for (var iterator$pps = ppss.iterator(); iterator$pps.hasNext(); ) {
            var pps = iterator$pps.next();
            if (pps.pic_parameter_set_id == id) 
                return pps;
        }
        return null;
    };
    constructor.findSPS = function(spss, id) {
        for (var iterator$sps = spss.iterator(); iterator$sps.hasNext(); ) {
            var sps = iterator$sps.next();
            if (sps.seq_parameter_set_id == id) 
                return sps;
        }
        return null;
    };
    constructor.SliceHeaderTweaker = function() {};
    constructor.SliceHeaderTweaker = stjs.extend(constructor.SliceHeaderTweaker, null, [], function(constructor, prototype) {
        prototype.sps = null;
        prototype.pps = null;
        prototype.tweak = function(sh) {};
        prototype.run = function(is, os, nu) {
            var nal = os.duplicate();
            H264Utils.unescapeNAL(is);
            var reader = BitReader.createBitReader(is);
            var sh = H264Utils.shr.readPart1(reader);
            var pp = H264Utils.findPPS(this.pps, sh.pic_parameter_set_id);
            return this.part2(is, os, nu, H264Utils.findSPS(this.sps, pp.pic_parameter_set_id), pp, nal, reader, sh);
        };
        prototype.runSpsPps = function(is, os, nu, sps, pps) {
            var nal = os.duplicate();
            H264Utils.unescapeNAL(is);
            var reader = BitReader.createBitReader(is);
            var sh = H264Utils.shr.readPart1(reader);
            return this.part2(is, os, nu, sps, pps, nal, reader, sh);
        };
        prototype.part2 = function(is, os, nu, sps, pps, nal, reader, sh) {
            var writer = new BitWriter(os);
            H264Utils.shr.readPart2(sh, nu, sps, pps, reader);
            this.tweak(sh);
            H264Utils.shw.write(sh, nu.type == NALUnitType.IDR_SLICE, nu.nal_ref_idc, writer);
            if (pps.entropy_coding_mode_flag) 
                this.copyDataCABAC(is, os, reader, writer);
             else 
                this.copyDataCAVLC(is, os, reader, writer);
            nal.setLimit(os.position());
            H264Utils.escapeNALinplace(nal);
            os.setPosition(nal.limit());
            return sh;
        };
        prototype.copyDataCAVLC = function(is, os, reader, writer) {
            var wLeft = 8 - writer.curBit();
            if (wLeft != 0) 
                writer.writeNBit(reader.readNBit(wLeft), wLeft);
            writer.flush();
            var shift = reader.curBit();
            if (shift != 0) {
                var mShift = 8 - shift;
                var inp = reader.readNBit(mShift);
                reader.stop();
                 while (is.hasRemaining()){
                    var out = inp << shift;
                    inp = is.get() & 255;
                    out |= inp >> mShift;
                    os.put((out << 24 >> 24));
                }
                os.put(((inp << shift) << 24 >> 24));
            } else {
                reader.stop();
                os.putBuf(is);
            }
        };
        prototype.copyDataCABAC = function(is, os, reader, writer) {
            var bp = reader.curBit();
            if (bp != 0) {
                var rem = reader.readNBit(8 - ((bp) | 0));
                if ((1 << (8 - bp)) - 1 != rem) 
                     throw new RuntimeException("Invalid CABAC padding");
            }
            if (writer.curBit() != 0) 
                writer.writeNBit(255, 8 - writer.curBit());
            writer.flush();
            reader.stop();
            os.putBuf(is);
        };
    }, {sps: {name: "List", arguments: ["SeqParameterSet"]}, pps: {name: "List", arguments: ["PictureParameterSet"]}}, {});
    constructor.getPicSize = function(sps) {
        var w = (sps.pic_width_in_mbs_minus1 + 1) << 4;
        var h = SeqParameterSet.getPicHeightInMbs(sps) << 4;
        if (sps.frame_cropping_flag) {
            w -= (sps.frame_crop_left_offset + sps.frame_crop_right_offset) << sps.chroma_format_idc.compWidth[1];
            h -= (sps.frame_crop_top_offset + sps.frame_crop_bottom_offset) << sps.chroma_format_idc.compHeight[1];
        }
        return new Size(w, h);
    };
    constructor.readSPSFromBufferList = function(spsList) {
        var result = new ArrayList();
        for (var iterator$byteBuffer = spsList.iterator(); iterator$byteBuffer.hasNext(); ) {
            var byteBuffer = iterator$byteBuffer.next();
            result.add(H264Utils.readSPS(NIOUtils.duplicate(byteBuffer)));
        }
        return result;
    };
    constructor.readPPSFromBufferList = function(ppsList) {
        var result = new ArrayList();
        for (var iterator$byteBuffer = ppsList.iterator(); iterator$byteBuffer.hasNext(); ) {
            var byteBuffer = iterator$byteBuffer.next();
            result.add(H264Utils.readPPS(NIOUtils.duplicate(byteBuffer)));
        }
        return result;
    };
    constructor.writePPSList = function(allPps) {
        var result = new ArrayList();
        for (var iterator$pps = allPps.iterator(); iterator$pps.hasNext(); ) {
            var pps = iterator$pps.next();
            result.add(H264Utils.writePPS(pps, 64));
        }
        return result;
    };
    constructor.writeSPSList = function(allSps) {
        var result = new ArrayList();
        for (var iterator$sps = allSps.iterator(); iterator$sps.hasNext(); ) {
            var sps = iterator$sps.next();
            result.add(H264Utils.writeSPS(sps, 256));
        }
        return result;
    };
    constructor.dumpFrame = function(ch, values, values2, nalUnits) {
        for (var i = 0; i < values.length; i++) {
            var sps = values[i];
            NIOUtils.writeInt(ch, 1);
            NIOUtils.writeByte(ch, (103 << 24 >> 24));
            ch.write(H264Utils.writeSPS(sps, 128));
        }
        for (var i = 0; i < values2.length; i++) {
            var pps = values2[i];
            NIOUtils.writeInt(ch, 1);
            NIOUtils.writeByte(ch, (104 << 24 >> 24));
            ch.write(H264Utils.writePPS(pps, 256));
        }
        for (var iterator$byteBuffer = nalUnits.iterator(); iterator$byteBuffer.hasNext(); ) {
            var byteBuffer = iterator$byteBuffer.next();
            NIOUtils.writeInt(ch, 1);
            ch.write(byteBuffer.duplicate());
        }
    };
    constructor.toNAL = function(codecPrivate, sps, pps) {
        var bb1 = ByteBuffer.allocate(512), bb2 = ByteBuffer.allocate(512);
        sps.write(bb1);
        pps.write(bb2);
        bb1.flip();
        bb2.flip();
        H264Utils.putNAL(codecPrivate, bb1, 103);
        H264Utils.putNAL(codecPrivate, bb2, 104);
    };
    constructor.toNALList = function(codecPrivate, spsList2, ppsList2) {
        for (var iterator$byteBuffer = spsList2.iterator(); iterator$byteBuffer.hasNext(); ) {
            var byteBuffer = iterator$byteBuffer.next();
            H264Utils.putNAL(codecPrivate, byteBuffer, 103);
        }
        for (var iterator$byteBuffer = ppsList2.iterator(); iterator$byteBuffer.hasNext(); ) {
            var byteBuffer = iterator$byteBuffer.next();
            H264Utils.putNAL(codecPrivate, byteBuffer, 104);
        }
    };
    constructor.putNAL = function(codecPrivate, byteBuffer, nalType) {
        var dst = ByteBuffer.allocate(byteBuffer.remaining() * 2);
        H264Utils.escapeNAL(byteBuffer, dst);
        dst.flip();
        codecPrivate.putInt(1);
        codecPrivate.put((nalType << 24 >> 24));
        codecPrivate.putBuf(dst);
    };
    /**
     *  Parses a list of SPS NAL units out of the codec private array.
     *  @param codecPrivate An AnnexB formatted set of SPS/PPS NAL units.
     *  @return A list of ByteBuffers containing PPS NAL units.
     */
    constructor.getRawPPS = function(codecPrivate) {
        return H264Utils.getRawNALUnitsOfType(codecPrivate, NALUnitType.PPS);
    };
    /**
     *  Parses a list of SPS NAL units out of the codec private array.
     *  @param codecPrivate An AnnexB formatted set of SPS/PPS NAL units.
     *  @return A list of ByteBuffers containing SPS NAL units.
     */
    constructor.getRawSPS = function(codecPrivate) {
        return H264Utils.getRawNALUnitsOfType(codecPrivate, NALUnitType.SPS);
    };
    constructor.getRawNALUnitsOfType = function(codecPrivate, type) {
        var result = new ArrayList();
        for (var iterator$bb = H264Utils.splitFrame(codecPrivate.duplicate()).iterator(); iterator$bb.hasNext(); ) {
            var bb = iterator$bb.next();
            var nu = NALUnit.read(bb);
            if (nu.type == type) {
                result.add(bb);
            }
        }
        return result;
    };
}, {shr: "SliceHeaderReader", shw: "SliceHeaderWriter"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Paste on ref movies
 *  
 *  @author The JCodec project
 *  
 */
var Paste = function() {};
Paste = stjs.extend(Paste, null, [], function(constructor, prototype) {
    constructor.main1 = function(args) {
        if (args.length < 2) {
            System.out.println("Syntax: paste <to movie> <from movie> [second]");
            System.exit(-1);
        }
        var toFile = new File(args[0]);
        var to = null;
        var from = null;
        var out = null;
        try {
            var outFile = new File(toFile.getParentFile(), toFile.getName().replaceAll("\\.mov$", "") + ".paste.mov");
            Platform.deleteFile(outFile);
            out = NIOUtils.writableChannel(outFile);
            to = NIOUtils.writableChannel(toFile);
            var fromFile = new File(args[1]);
            from = NIOUtils.readableChannel(fromFile);
            var toMov = MP4Util.createRefMovie(to, "file://" + toFile.getCanonicalPath());
            var fromMov = MP4Util.createRefMovie(from, "file://" + fromFile.getCanonicalPath());
            new Strip().strip(fromMov);
            if (args.length > 2) {
                new Paste().paste(toMov, fromMov, Double.parseDouble(args[2]));
            } else {
                new Paste().addToMovie(toMov, fromMov);
            }
            MP4Util.writeMovie(out, toMov);
        } finally {
            if (to != null) 
                to.close();
            if (from != null) 
                from.close();
            if (out != null) 
                out.close();
        }
    };
    prototype.paste = function(to, from, sec) {
        var videoTrack = to.getVideoTrack();
        if (videoTrack != null && videoTrack.getTimescale() != to.getTimescale()) 
            to.fixTimescale(videoTrack.getTimescale());
        var displayTv = stjs.trunc((to.getTimescale() * sec));
        Util.forceEditListMov(to);
        Util.forceEditListMov(from);
        var fromTracks = from.getTracks();
        var toTracks = to.getTracks();
        var matches = this.findMatches(fromTracks, toTracks);
        for (var i = 0; i < matches[0].length; i++) {
            var localTrack = to.importTrack(from, fromTracks[i]);
            if (matches[0][i] != -1) {
                Util.insertTo(to, toTracks[matches[0][i]], localTrack, displayTv);
            } else {
                to.appendTrack(localTrack);
                Util.shift(to, localTrack, displayTv);
            }
        }
        for (var i = 0; i < matches[1].length; i++) {
            if (matches[1][i] == -1) {
                Util.spread(to, toTracks[i], displayTv, to.rescale(from.getDuration(), from.getTimescale()));
            }
        }
        to.updateDuration();
    };
    prototype.addToMovie = function(to, from) {
        var tracks = from.getTracks();
        for (var i = 0; i < tracks.length; i++) {
            var track = tracks[i];
            to.appendTrack(to.importTrack(from, track));
        }
    };
    prototype.tv = null;
    prototype.getFrameTv = function(videoTrack, frame) {
        if (this.tv == null) {
            this.tv = Util.getTimevalues(videoTrack);
        }
        return this.tv[frame];
    };
    prototype.findMatches = function(fromTracks, toTracks) {
        var f2t = new Int32Array(fromTracks.length);
        var t2f = new Int32Array(toTracks.length);
        Arrays.fill(f2t, -1);
        Arrays.fill(t2f, -1);
        for (var i = 0; i < fromTracks.length; i++) {
            if (f2t[i] != -1) 
                continue;
            for (var j = 0; j < toTracks.length; j++) {
                if (t2f[j] != -1) 
                    continue;
                if (this.matches(fromTracks[i], toTracks[j])) {
                    f2t[i] = j;
                    t2f[j] = i;
                    break;
                }
            }
        }
        return [f2t, t2f];
    };
    prototype.matches = function(trakBox1, trakBox2) {
        return trakBox1.getHandlerType().equals(trakBox2.getHandlerType()) && this.matchHeaders(trakBox1, trakBox2) && this.matchSampleSizes(trakBox1, trakBox2) && this.matchMediaHeader(trakBox1, trakBox2) && this.matchClip(trakBox1, trakBox2) && this.matchLoad(trakBox1, trakBox2);
    };
    prototype.matchSampleSizes = function(trakBox1, trakBox2) {
        var stsz1 = NodeBox.findFirstPath(trakBox1, SampleSizesBox, Box.path("mdia.minf.stbl.stsz"));
        var stsz2 = NodeBox.findFirstPath(trakBox1, SampleSizesBox, Box.path("mdia.minf.stbl.stsz"));
        return stsz1.getDefaultSize() == stsz2.getDefaultSize();
    };
    prototype.matchMediaHeader = function(trakBox1, trakBox2) {
        var vmhd1 = NodeBox.findFirstPath(trakBox1, VideoMediaHeaderBox, Box.path("mdia.minf.vmhd"));
        var vmhd2 = NodeBox.findFirstPath(trakBox2, VideoMediaHeaderBox, Box.path("mdia.minf.vmhd"));
        if ((vmhd1 != null && vmhd2 == null) || (vmhd1 == null && vmhd2 != null)) 
            return false;
         else if (vmhd1 != null && vmhd2 != null) {
            return vmhd1.getGraphicsMode() == vmhd2.getGraphicsMode() && vmhd1.getbOpColor() == vmhd2.getbOpColor() && vmhd1.getgOpColor() == vmhd2.getgOpColor() && vmhd1.getrOpColor() == vmhd2.getrOpColor();
        } else {
            var smhd1 = NodeBox.findFirstPath(trakBox1, SoundMediaHeaderBox, Box.path("mdia.minf.smhd"));
            var smhd2 = NodeBox.findFirstPath(trakBox2, SoundMediaHeaderBox, Box.path("mdia.minf.smhd"));
            if ((smhd1 == null && smhd2 != null) || (smhd1 != null && smhd2 == null)) 
                return false;
             else if (smhd1 != null && smhd2 != null) 
                return smhd1.getBalance() == smhd1.getBalance();
        }
        return true;
    };
    prototype.matchHeaders = function(trakBox1, trakBox2) {
        var th1 = trakBox1.getTrackHeader();
        var th2 = trakBox2.getTrackHeader();
        return ("vide".equals(trakBox1.getHandlerType()) && Platform.arrayEqualsInt(th1.getMatrix(), th2.getMatrix()) && th1.getLayer() == th2.getLayer() && th1.getWidth() == th2.getWidth() && th1.getHeight() == th2.getHeight()) || ("soun".equals(trakBox1.getHandlerType()) && th1.getVolume() == th2.getVolume()) || "tmcd".equals(trakBox1.getHandlerType());
    };
    prototype.matchLoad = function(trakBox1, trakBox2) {
        var load1 = NodeBox.findFirst(trakBox1, LoadSettingsBox, "load");
        var load2 = NodeBox.findFirst(trakBox2, LoadSettingsBox, "load");
        if (load1 == null && load2 == null) 
            return true;
        if ((load1 == null && load2 != null) || (load1 != null && load2 == null)) 
            return false;
        return load1.getPreloadStartTime() == load2.getPreloadStartTime() && load1.getPreloadDuration() == load2.getPreloadDuration() && load1.getPreloadFlags() == load2.getPreloadFlags() && load1.getDefaultHints() == load2.getDefaultHints();
    };
    prototype.matchClip = function(trakBox1, trakBox2) {
        var crgn1 = NodeBox.findFirstPath(trakBox1, ClipRegionBox, Box.path("clip.crgn"));
        var crgn2 = NodeBox.findFirstPath(trakBox2, ClipRegionBox, Box.path("clip.crgn"));
        if ((crgn1 == null && crgn2 != null) || (crgn1 != null && crgn2 == null)) 
            return false;
        if (crgn1 == null && crgn2 == null) 
            return true;
        return crgn1.getRgnSize() == crgn2.getRgnSize() && crgn1.getX() == crgn2.getX() && crgn1.getY() == crgn2.getY() && crgn1.getWidth() == crgn2.getWidth() && crgn1.getHeight() == crgn2.getHeight();
    };
}, {tv: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Cut on ref movies
 *  
 *  @author The JCodec project
 *  
 */
var Cut = function() {};
Cut = stjs.extend(Cut, null, [], function(constructor, prototype) {
    constructor.main1 = function(args) {
        if (args.length < 1) {
            System.out.println("Syntax: cut [-command arg]...[-command arg] [-self] <movie file>\n\tCreates a reference movie out of the file and applies a set of changes specified by the commands to it.");
            System.exit(-1);
        }
        var slices = new ArrayList();
        var sliceNames = new ArrayList();
        var selfContained = false;
        var shift = 0;
         while (true){
            if ("-cut".equals(args[shift])) {
                var pt = StringUtils.splitS(args[shift + 1], ":");
                slices.add(new Cut.Slice(Integer.parseInt(pt[0]), Integer.parseInt(pt[1])));
                if (pt.length > 2) 
                    sliceNames.add(pt[2]);
                 else 
                    sliceNames.add(null);
                shift += 2;
            } else if ("-self".equals(args[shift])) {
                ++shift;
                selfContained = true;
            } else 
                break;
        }
        var source = new File(args[shift]);
        var input = null;
        var out = null;
        var outs = new ArrayList();
        try {
            input = NIOUtils.readableChannel(source);
            var movie = MP4Util.createRefMovie(input, "file://" + source.getCanonicalPath());
            var slicesMovs;
            if (!selfContained) {
                out = NIOUtils.writableChannel(new File(source.getParentFile(), JCodecUtil2.removeExtension(source.getName()) + ".ref.mov"));
                slicesMovs = new Cut().cut(movie, slices);
                MP4Util.writeMovie(out, movie);
            } else {
                out = NIOUtils.writableChannel(new File(source.getParentFile(), JCodecUtil2.removeExtension(source.getName()) + ".self.mov"));
                slicesMovs = new Cut().cut(movie, slices);
                new Strip().strip(movie);
                new Flattern().flatternChannel(movie, out);
            }
            Cut.saveSlices(slicesMovs, sliceNames, source.getParentFile());
        } finally {
            if (input != null) 
                input.close();
            if (out != null) 
                out.close();
            for (var iterator$o = outs.iterator(); iterator$o.hasNext(); ) {
                var o = iterator$o.next();
                o.close();
            }
        }
    };
    constructor.saveSlices = function(slices, names, parentFile) {
        for (var i = 0; i < slices.size(); i++) {
            if (names.get(i) == null) 
                continue;
            var out = null;
            try {
                out = NIOUtils.writableChannel(new File(parentFile, names.get(i)));
                MP4Util.writeMovie(out, slices.get(i));
            } finally {
                NIOUtils.closeQuietly(out);
            }
        }
    };
    constructor.Slice = function(_in, out) {
        this.inSec = _in;
        this.outSec = out;
    };
    constructor.Slice = stjs.extend(constructor.Slice, null, [], function(constructor, prototype) {
        prototype.inSec = 0.0;
        prototype.outSec = 0.0;
    }, {}, {});
    prototype.cut = function(movie, commands) {
        var videoTrack = movie.getVideoTrack();
        if (videoTrack != null && videoTrack.getTimescale() != movie.getTimescale()) 
            movie.fixTimescale(videoTrack.getTimescale());
        var tracks = movie.getTracks();
        for (var i = 0; i < tracks.length; i++) {
            var trakBox = tracks[i];
            Util.forceEditList(movie, trakBox);
            var edits = trakBox.getEdits();
            for (var iterator$cut = commands.iterator(); iterator$cut.hasNext(); ) {
                var cut = iterator$cut.next();
                this.split(edits, cut.inSec, movie, trakBox);
                this.split(edits, cut.outSec, movie, trakBox);
            }
        }
        var result = new ArrayList();
        for (var iterator$cut = commands.iterator(); iterator$cut.hasNext(); ) {
            var cut = iterator$cut.next();
            var clone = NodeBox.cloneBox(movie, 16 * 1024 * 1024, BoxFactory.getDefault());
            for (var trakBox in clone.getTracks()) {
                this.selectInner(trakBox.getEdits(), cut, movie, trakBox);
            }
            result.add(clone);
        }
        var movDuration = 0;
        for (var trakBox in movie.getTracks()) {
            this.selectOuter(trakBox.getEdits(), commands, movie, trakBox);
            trakBox.setEdits(trakBox.getEdits());
            movDuration = Math.max(movDuration, trakBox.getDuration());
        }
        movie.setDuration(movDuration);
        return result;
    };
    prototype.selectOuter = function(edits, commands, movie, trakBox) {
        var inMv = Array(commands.size());
        var outMv = Array(commands.size());
        for (var i = 0; i < commands.size(); i++) {
            inMv[i] = stjs.trunc((commands.get(i).inSec * movie.getTimescale()));
            outMv[i] = stjs.trunc((commands.get(i).outSec * movie.getTimescale()));
        }
        var editStartMv = 0;
        var lit = edits.listIterator();
         while (lit.hasNext()){
            var edit = lit.next();
            for (var i = 0; i < inMv.length; i++) {
                if (editStartMv + edit.getDuration() > inMv[i] && editStartMv < outMv[i]) 
                    lit.remove();
            }
            editStartMv += edit.getDuration();
        }
    };
    prototype.selectInner = function(edits, cut, movie, trakBox) {
        var inMv = stjs.trunc((movie.getTimescale() * cut.inSec));
        var outMv = stjs.trunc((movie.getTimescale() * cut.outSec));
        var editStart = 0;
        var lit = edits.listIterator();
         while (lit.hasNext()){
            var edit = lit.next();
            if (editStart + edit.getDuration() <= inMv || editStart >= outMv) 
                lit.remove();
            editStart += edit.getDuration();
        }
    };
    prototype.split = function(edits, sec, movie, trakBox) {
        Util.split(movie, trakBox, stjs.trunc((sec * movie.getTimescale())));
    };
}, {}, {});
/**
 *  A full fledged MP4 editor.
 *  
 *  Parses MP4 file, applies the edit and saves the result in a new file.
 *  
 *  Unlike InplaceMP4Edit any changes are allowed. This class will take care of
 *  adjusting all the sample offsets so the result file will be correct.
 *  
 *  @author The JCodec project
 *  
 */
var ReplaceMP4Editor = function() {};
ReplaceMP4Editor = stjs.extend(ReplaceMP4Editor, null, [], function(constructor, prototype) {
    prototype.modifyOrReplace = function(src, edit) {
        var modify = new InplaceMP4Editor().modify(src, edit);
        if (!modify) 
            this.replace(src, edit);
    };
    prototype.replace = function(src, edit) {
        var tmp = new File(src.getParentFile(), "." + src.getName());
        this.copy(src, tmp, edit);
        tmp.renameTo(src);
    };
    prototype.copy = function(src, dst, edit) {
        var movie = MP4Util.createRefMovieFromFile(src);
        edit.apply(movie);
        var fl = new Flattern();
        fl.flattern(movie, dst);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  MPEG 4 AVC ( H.264 ) Frame reader
 *  
 *  Conforms to H.264 ( ISO/IEC 14496-10 ) specifications
 *  
 *  @author The JCodec project
 *  
 */
var FrameReader = function() {
    this.sps = new IntObjectMap();
    this.pps = new IntObjectMap();
};
FrameReader = stjs.extend(FrameReader, null, [], function(constructor, prototype) {
    prototype.sps = null;
    prototype.pps = null;
    prototype.readFrame = function(nalUnits) {
        var result = new ArrayList();
        for (var iterator$nalData = nalUnits.iterator(); iterator$nalData.hasNext(); ) {
            var nalData = iterator$nalData.next();
            var nalUnit = NALUnit.read(nalData);
            H264Utils.unescapeNAL(nalData);
            if (NALUnitType.SPS == nalUnit.type) {
                var _sps = SeqParameterSet.read(nalData);
                this.sps.put(_sps.seq_parameter_set_id, _sps);
            } else if (NALUnitType.PPS == nalUnit.type) {
                var _pps = PictureParameterSet.read(nalData);
                this.pps.put(_pps.pic_parameter_set_id, _pps);
            } else if (NALUnitType.IDR_SLICE == nalUnit.type || NALUnitType.NON_IDR_SLICE == nalUnit.type) {
                if (this.sps.size() == 0 || this.pps.size() == 0) {
                    jcodec.Logger.warn("Skipping frame as no SPS/PPS have been seen so far...");
                    return null;
                }
                result.add(this.createSliceReader(nalData, nalUnit));
            }
        }
        return result;
    };
    prototype.createSliceReader = function(segment, nalUnit) {
        var _in = BitReader.createBitReader(segment);
        var shr = new SliceHeaderReader();
        var sh = shr.readPart1(_in);
        sh.pps = this.pps.get(sh.pic_parameter_set_id);
        sh.sps = this.sps.get(sh.pps.seq_parameter_set_id);
        shr.readPart2(sh, nalUnit, sh.sps, sh.pps, _in);
        var mapper = new MapManager(sh.sps, sh.pps).getMapper(sh);
        var cavlc = [new CAVLC(sh.sps, sh.pps, 2, 2), new CAVLC(sh.sps, sh.pps, 1, 1), new CAVLC(sh.sps, sh.pps, 1, 1)];
        var mbWidth = sh.sps.pic_width_in_mbs_minus1 + 1;
        var cabac = new CABAC(mbWidth);
        var mDecoder = null;
        if (sh.pps.entropy_coding_mode_flag) {
            _in.terminate();
            var cm = Array.apply(null, Array(2)).map(function() {
                return new Int32Array(1024);
            });
            var qp = sh.pps.pic_init_qp_minus26 + 26 + sh.slice_qp_delta;
            cabac.initModels(cm, sh.slice_type, sh.cabac_init_idc, qp);
            mDecoder = new MDecoder(segment, cm);
        }
        return new SliceReader(sh.pps, cabac, cavlc, mDecoder, _in, mapper, sh, nalUnit);
    };
    prototype.addSpsList = function(spsList) {
        for (var iterator$byteBuffer = spsList.iterator(); iterator$byteBuffer.hasNext(); ) {
            var byteBuffer = iterator$byteBuffer.next();
            this.addSps(byteBuffer);
        }
    };
    prototype.addSps = function(byteBuffer) {
        var dup = byteBuffer.duplicate();
        H264Utils.unescapeNAL(dup);
        var s = SeqParameterSet.read(dup);
        this.sps.put(s.seq_parameter_set_id, s);
    };
    prototype.addPpsList = function(ppsList) {
        for (var iterator$byteBuffer = ppsList.iterator(); iterator$byteBuffer.hasNext(); ) {
            var byteBuffer = iterator$byteBuffer.next();
            this.addPps(byteBuffer);
        }
    };
    prototype.addPps = function(byteBuffer) {
        var dup = byteBuffer.duplicate();
        H264Utils.unescapeNAL(dup);
        var p = PictureParameterSet.read(dup);
        this.pps.put(p.pic_parameter_set_id, p);
    };
}, {sps: {name: "IntObjectMap", arguments: ["SeqParameterSet"]}, pps: {name: "IntObjectMap", arguments: ["PictureParameterSet"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Contains methods to mux virtual movie tracks into real real MP4 movie header
 *  
 *  @author The JCodec project
 *  
 */
var MovieHelper = function() {};
MovieHelper = stjs.extend(MovieHelper, null, [], function(constructor, prototype) {
    constructor.MEBABYTE = 1024 * 1024;
    constructor.timescales = new Int32Array([10000, 12000, 15000, 24000, 25000, 30000, 50000, 41000, 48000, 96000]);
    constructor.produceHeader = function(chunks, tracks, dataSize, brand) {
        var defaultTimescale = 1000;
        var buf = ByteBuffer.allocate(6 * MovieHelper.MEBABYTE);
        var movie = MovieBox.createMovieBox();
        var trackDurations = MovieHelper.calcTrackDurations(chunks, tracks);
        var movieDur = MovieHelper.calcMovieDuration(tracks, defaultTimescale, trackDurations);
        movie.add(MovieHelper.movieHeader(movie, tracks.length, movieDur, defaultTimescale));
        for (var trackId = 0; trackId < tracks.length; trackId++) {
            var track = tracks[trackId];
            var codecMeta = track.getCodecMeta();
            var pcm = (stjs.isInstanceOf(codecMeta.constructor, AudioCodecMeta)) && (codecMeta).isPCM();
            var trackTimescale = track.getPreferredTimescale();
            if (trackTimescale <= 0) {
                if (pcm) 
                    trackTimescale = MovieHelper.getPCMTs(codecMeta, chunks, trackId);
                 else 
                    trackTimescale = MovieHelper.chooseTimescale(chunks, trackId);
            } else if (trackTimescale < 100) {
                trackTimescale *= 1000;
            } else if (trackTimescale < 1000) {
                trackTimescale *= 100;
            } else if (trackTimescale < 10000) {
                trackTimescale *= 10;
            }
            var totalDur = stjs.trunc((trackTimescale * trackDurations[trackId]));
            var trak = TrakBox.createTrakBox();
            var dd = new Size(0, 0), sd = new Size(0, 0);
            if (stjs.isInstanceOf(codecMeta.constructor, VideoCodecMeta)) {
                var meta = codecMeta;
                var pasp = meta.getPasp();
                if (pasp == null) 
                    sd = dd = meta.getSize();
                 else {
                    sd = meta.getSize();
                    dd = new Size(pasp.multiplyS(sd.getWidth()), sd.getHeight());
                }
            }
            var tkhd = TrackHeaderBox.createTrackHeaderBox(trackId + 1, movieDur, dd.getWidth(), dd.getHeight(), new jsutil.Date().getTime(), new jsutil.Date().getTime(), 1.0, ((0) << 16 >> 16), 0, new Int32Array([65536, 0, 0, 0, 65536, 0, 0, 0, 1073741824]));
            tkhd.setFlags(15);
            trak.add(tkhd);
            var media = MediaBox.createMediaBox();
            trak.add(media);
            media.add(MediaHeaderBox.createMediaHeaderBox(trackTimescale, totalDur, 0, new jsutil.Date().getTime(), new jsutil.Date().getTime(), 0));
            var tt = (stjs.isInstanceOf(codecMeta.constructor, AudioCodecMeta)) ? TrackType.SOUND : TrackType.VIDEO;
            if (tt == TrackType.VIDEO) {
                var tapt = new NodeBox(new Header("tapt"));
                tapt.add(ClearApertureBox.createClearApertureBox(dd.getWidth(), dd.getHeight()));
                tapt.add(ProductionApertureBox.createProductionApertureBox(dd.getWidth(), dd.getHeight()));
                tapt.add(EncodedPixelBox.createEncodedPixelBox(sd.getWidth(), sd.getHeight()));
                trak.add(tapt);
            }
            var hdlr = HandlerBox.createHandlerBox("mhlr", tt.getHandler(), "appl", 0, 0);
            media.add(hdlr);
            var minf = MediaInfoBox.createMediaInfoBox();
            media.add(minf);
            MovieHelper.mediaHeader(minf, tt);
            minf.add(HandlerBox.createHandlerBox("dhlr", "url ", "appl", 0, 0));
            MovieHelper.addDref(minf);
            var stbl = new NodeBox(new Header("stbl"));
            minf.add(stbl);
            stbl.add(SampleDescriptionBox.createSampleDescriptionBox([MovieHelper.toSampleEntry(codecMeta)]));
            if (pcm) {
                MovieHelper.populateStblPCM(stbl, chunks, trackId, codecMeta);
            } else {
                MovieHelper.populateStblGeneric(stbl, chunks, trackId, codecMeta, trackTimescale);
            }
            MovieHelper.addEdits(trak, track, defaultTimescale, trackTimescale);
            movie.add(trak);
        }
        brand.getFileTypeBox().write(buf);
        movie.write(buf);
        Header.createHeader("mdat", dataSize).write(buf);
        buf.flip();
        return buf;
    };
    constructor.toSampleEntry = function(se) {
        var pasp = null;
        var vse;
        if ("avc1".equals(se.getFourcc())) {
            vse = H264Utils.createMOVSampleEntryFromBytes(NIOUtils.toArray(se.getCodecPrivate()));
            pasp = (se).getPasp();
        } else if (stjs.isInstanceOf(se.constructor, VideoCodecMeta)) {
            var ss = se;
            pasp = ss.getPasp();
            vse = MP4Muxer.videoSampleEntry(se.getFourcc(), ss.getSize(), "JCodec");
        } else {
            var ss = se;
            if (ss.isPCM()) {
                vse = MP4Muxer.audioSampleEntry(se.getFourcc(), 1, ss.getSampleSize(), ss.getChannelCount(), ss.getSampleRate(), ss.getEndian());
            } else {
                vse = MP4Muxer.compressedAudioSampleEntry(se.getFourcc(), 1, ss.getSampleSize(), ss.getChannelCount(), ss.getSampleRate(), ss.getSamplesPerPacket(), ss.getBytesPerPacket(), ss.getBytesPerFrame());
            }
            var chan = ChannelBox.createChannelBox();
            AudioSampleEntry.setLabels(ss.getChannelLabels(), chan);
            vse.add(chan);
        }
        if (pasp != null) 
            vse.add(PixelAspectExt.createPixelAspectExt(pasp));
        return vse;
    };
    constructor.chooseTimescale = function(chunks, trackId) {
        for (var ch = 0; ch < chunks.length; ch++) {
            if (chunks[ch].getTrackNo() == trackId) {
                var dur = chunks[ch].getPacket().getDuration(), min = Double.MAX_VALUE;
                var minTs = -1;
                for (var ts = 0; ts < MovieHelper.timescales.length; ts++) {
                    var dd = MovieHelper.timescales[ts] * dur;
                    var diff = dd - stjs.trunc(dd);
                    if (diff < min) {
                        minTs = ts;
                        min = diff;
                    }
                }
                return MovieHelper.timescales[minTs];
            }
        }
        return 0;
    };
    constructor.addEdits = function(trak, track, defaultTimescale, trackTimescale) {
        var edits = track.getEdits();
        if (edits == null) 
            return;
        var result = new ArrayList();
        for (var virtualEdit in edits) {
            result.add(new Edit(stjs.trunc((virtualEdit.getDuration() * defaultTimescale)), stjs.trunc((virtualEdit.getIn() * trackTimescale)), 1.0));
        }
        trak.setEdits(result);
    };
    constructor.calcMovieDuration = function(tracks, defaultTimescale, dur) {
        var movieDur = 0;
        for (var trackId = 0; trackId < tracks.length; trackId++) {
            movieDur = Math.max(movieDur, stjs.trunc((defaultTimescale * dur[trackId])));
        }
        return movieDur;
    };
    constructor.calcTrackDurations = function(chunks, tracks) {
        var dur = new Float64Array(tracks.length);
        Arrays.fill(dur, -1);
        for (var chunkId = chunks.length - 1, n = 0; chunkId >= 0 && n < dur.length; chunkId--) {
            var chunk = chunks[chunkId];
            var track = chunk.getTrackNo();
            if (dur[track] == -1) {
                dur[track] = chunk.getPacket().getPts() + chunk.getPacket().getDuration();
                ++n;
            }
        }
        return dur;
    };
    constructor.populateStblGeneric = function(stbl, chunks, trackId, se, timescale) {
        var stco = new LongArrayList(250 << 10);
        var stsz = new IntArrayList(250 << 10);
        var stts = new ArrayList();
        var stss = new IntArrayList(4 << 10);
        var prevDur = 0;
        var prevCount = -1;
        var allKey = true;
        var compositionOffsets = new ArrayList();
        var ptsEstimate = 0;
        var lastCompositionSamples = 0, lastCompositionOffset = 0;
        for (var chunkNo = 0; chunkNo < chunks.length; chunkNo++) {
            var chunk = chunks[chunkNo];
            if (chunk.getTrackNo() == trackId) {
                stco.add(chunk.getPos());
                stsz.add(Math.max(0, chunk.getDataLen()));
                var dur = ((Math.round(chunk.getPacket().getDuration() * timescale)) | 0);
                if (dur != prevDur) {
                    if (prevCount != -1) 
                        stts.add(new TimeToSampleBox.TimeToSampleEntry(prevCount, prevDur));
                    prevDur = dur;
                    prevCount = 0;
                }
                ++prevCount;
                var key = chunk.getPacket().isKeyframe();
                allKey &= key;
                if (key) 
                    stss.add(chunk.getPacket().getFrameNo() + 1);
                var pts = Math.round(chunk.getPacket().getPts() * timescale);
                var compositionOffset = (((pts - ptsEstimate)) | 0);
                if (compositionOffset != lastCompositionOffset) {
                    if (lastCompositionSamples > 0) 
                        compositionOffsets.add(new CompositionOffsetsBox.Entry(lastCompositionSamples, lastCompositionOffset));
                    lastCompositionOffset = compositionOffset;
                    lastCompositionSamples = 0;
                }
                lastCompositionSamples++;
                ptsEstimate += dur;
            }
        }
        if (compositionOffsets.size() > 0) {
            compositionOffsets.add(new CompositionOffsetsBox.Entry(lastCompositionSamples, lastCompositionOffset));
        }
        if (prevCount > 0) 
            stts.add(new TimeToSampleBox.TimeToSampleEntry(prevCount, prevDur));
        if (!allKey) 
            stbl.add(SyncSamplesBox.createSyncSamplesBox(stss.toArray()));
        stbl.add(ChunkOffsets64Box.createChunkOffsets64Box(stco.toArray()));
        stbl.add(SampleToChunkBox.createSampleToChunkBox([new SampleToChunkBox.SampleToChunkEntry(1, 1, 1)]));
        stbl.add(SampleSizesBox.createSampleSizesBox2(stsz.toArray()));
        stbl.add(TimeToSampleBox.createTimeToSampleBox(stts.toArray(Array(0))));
        MovieHelper.compositionOffsets(compositionOffsets, stbl);
    };
    constructor.compositionOffsets = function(compositionOffsets, stbl) {
        if (compositionOffsets.size() > 0) {
            var min = FramesMP4MuxerTrack.minOffset(compositionOffsets);
            for (var iterator$entry = compositionOffsets.iterator(); iterator$entry.hasNext(); ) {
                var entry = iterator$entry.next();
                entry.offset -= min;
            }
            stbl.add(CompositionOffsetsBox.createCompositionOffsetsBox(compositionOffsets.toArray(Array(0))));
        }
    };
    constructor.populateStblPCM = function(stbl, chunks, trackId, se) {
        var ase = se;
        var frameSize = ase.getFrameSize();
        var stco = new LongArrayList(250 << 10);
        var stsc = new ArrayList();
        var stscCount = -1, stscFirstChunk = -1, totalFrames = 0;
        for (var chunkNo = 0, stscCurChunk = 1; chunkNo < chunks.length; chunkNo++) {
            var chunk = chunks[chunkNo];
            if (chunk.getTrackNo() == trackId) {
                stco.add(chunk.getPos());
                var framesPerChunk = stjs.trunc(chunk.getDataLen() / frameSize);
                if (framesPerChunk != stscCount) {
                    if (stscCount != -1) 
                        stsc.add(new SampleToChunkBox.SampleToChunkEntry(stscFirstChunk, stscCount, 1));
                    stscFirstChunk = stscCurChunk;
                    stscCount = framesPerChunk;
                }
                stscCurChunk++;
                totalFrames += framesPerChunk;
            }
        }
        if (stscCount != -1) 
            stsc.add(new SampleToChunkBox.SampleToChunkEntry(stscFirstChunk, stscCount, 1));
        stbl.add(ChunkOffsets64Box.createChunkOffsets64Box(stco.toArray()));
        stbl.add(SampleToChunkBox.createSampleToChunkBox(stsc.toArray(Array(0))));
        stbl.add(SampleSizesBox.createSampleSizesBox(ase.getFrameSize(), totalFrames));
        stbl.add(TimeToSampleBox.createTimeToSampleBox([new TimeToSampleBox.TimeToSampleEntry(totalFrames, 1)]));
    };
    constructor.getPCMTs = function(se, chunks, trackId) {
        for (var chunkNo = 0; chunkNo < chunks.length; chunkNo++) {
            if (chunks[chunkNo].getTrackNo() == trackId) {
                return ((Math.round(chunks[chunkNo].getDataLen() / (se.getFrameSize() * chunks[chunkNo].getPacket().getDuration()))) | 0);
            }
        }
         throw new RuntimeException("Crap");
    };
    constructor.mediaHeader = function(minf, type) {
        if (TrackType.VIDEO == type) {
            var vmhd = VideoMediaHeaderBox.createVideoMediaHeaderBox(0, 0, 0, 0);
            vmhd.setFlags(1);
            minf.add(vmhd);
        } else if (TrackType.SOUND == type) {
            var smhd = SoundMediaHeaderBox.createSoundMediaHeaderBox();
            smhd.setFlags(1);
            minf.add(smhd);
        } else if (TrackType.TIMECODE == type) {
            var gmhd = new NodeBox(new Header("gmhd"));
            gmhd.add(GenericMediaInfoBox.createGenericMediaInfoBox());
            var tmcd = new NodeBox(new Header("tmcd"));
            gmhd.add(tmcd);
            tmcd.add(TimecodeMediaInfoBox.createTimecodeMediaInfoBox(((0) << 16 >> 16), ((0) << 16 >> 16), ((12) << 16 >> 16), new Int16Array([0, 0, 0]), new Int16Array([255, 255, 255]), "Lucida Grande"));
            minf.add(gmhd);
        } else {
             throw new UnhandledStateException("Handler " + type.getHandler() + " not supported");
        }
    };
    constructor.addDref = function(minf) {
        var dinf = DataInfoBox.createDataInfoBox();
        minf.add(dinf);
        var dref = DataRefBox.createDataRefBox();
        dinf.add(dref);
        dref.add(Box.LeafBox.createLeafBox(Header.createHeader("alis", 0), ByteBuffer.wrap(new Int8Array([0, 0, 0, 1]))));
    };
    constructor.movieHeader = function(movie, nTracks, duration, timescale) {
        return MovieHeaderBox.createMovieHeaderBox(timescale, duration, 1.0, 1.0, new jsutil.Date().getTime(), new jsutil.Date().getTime(), new Int32Array([65536, 0, 0, 0, 65536, 0, 0, 0, 1073741824]), nTracks + 1);
    };
}, {timescales: "Int32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  MPEG 4 AVC ( H.264 ) Encoder
 *  
 *  Conforms to H.264 ( ISO/IEC 14496-10 ) specifications
 *  
 *  @author The JCodec project
 *  
 */
var H264Encoder = function(rc) {
    VideoEncoder.call(this);
    this.rc = rc;
    this.keyInterval = H264Encoder.KEY_INTERVAL_DEFAULT;
};
H264Encoder = stjs.extend(H264Encoder, VideoEncoder, [], function(constructor, prototype) {
    constructor.KEY_INTERVAL_DEFAULT = 25;
    constructor.createH264Encoder = function() {
        return new H264Encoder(new DumbRateControl());
    };
    prototype.cavlc = null;
    prototype.leftRow = null;
    prototype.topLine = null;
    prototype.rc = null;
    prototype.frameNumber = 0;
    prototype.keyInterval = 0;
    prototype.maxPOC = 0;
    prototype.maxFrameNumber = 0;
    prototype.sps = null;
    prototype.pps = null;
    prototype.mbEncoderI16x16 = null;
    prototype.mbEncoderP16x16 = null;
    prototype.ref = null;
    prototype.picOut = null;
    prototype.topEncoded = null;
    prototype.outMB = null;
    prototype.getKeyInterval = function() {
        return this.keyInterval;
    };
    prototype.setKeyInterval = function(keyInterval) {
        this.keyInterval = keyInterval;
    };
    /**
     *  Encode this picture into h.264 frame. Frame type will be selected by
     *  encoder.
     */
    prototype.encodeFrame8Bit = function(pic, _out) {
        if (this.frameNumber >= this.keyInterval) {
            this.frameNumber = 0;
        }
        var sliceType = this.frameNumber == 0 ? SliceType.I : SliceType.P;
        var idr = this.frameNumber == 0;
        return this.doEncodeFrame8Bit(pic, _out, idr, this.frameNumber++, sliceType);
    };
    /**
     *  Encode this picture as an IDR frame. IDR frame starts a new independently
     *  decodeable video sequence
     *  
     *  @param pic
     *  @param _out
     *  @return
     */
    prototype.encodeIDRFrame = function(pic, _out) {
        this.frameNumber = 0;
        return this.doEncodeFrame8Bit(pic, _out, true, this.frameNumber, SliceType.I);
    };
    /**
     *  Encode this picture as a P-frame. P-frame is an frame predicted from one
     *  or more of the previosly decoded frame and is usually 10x less in size
     *  then the IDR frame.
     *  
     *  @param pic
     *  @param _out
     *  @return
     */
    prototype.encodePFrame = function(pic, _out) {
        this.frameNumber++;
        return this.doEncodeFrame8Bit(pic, _out, true, this.frameNumber, SliceType.P);
    };
    prototype.doEncodeFrame8Bit = function(pic, _out, idr, frameNumber, frameType) {
        var dup = _out.duplicate();
        if (idr) {
            this.sps = this.initSPS(new Size(pic.getCroppedWidth(), pic.getCroppedHeight()));
            this.pps = this.initPPS();
            this.maxPOC = 1 << (this.sps.log2_max_pic_order_cnt_lsb_minus4 + 4);
            this.maxFrameNumber = 1 << (this.sps.log2_max_frame_num_minus4 + 4);
        }
        if (idr) {
            dup.putInt(1);
            new NALUnit(NALUnitType.SPS, 3).write(dup);
            this.writeSPS(dup, this.sps);
            dup.putInt(1);
            new NALUnit(NALUnitType.PPS, 3).write(dup);
            this.writePPS(dup, this.pps);
        }
        var mbWidth = this.sps.pic_width_in_mbs_minus1 + 1;
        var mbHeight = this.sps.pic_height_in_map_units_minus1 + 1;
        this.leftRow = [new Int8Array(16), new Int8Array(8), new Int8Array(8)];
        this.topLine = [new Int8Array(mbWidth << 4), new Int8Array(mbWidth << 3), new Int8Array(mbWidth << 3)];
        this.picOut = Picture8Bit.create(mbWidth << 4, mbHeight << 4, pic.getColor());
        this.outMB = new EncodedMB();
        this.topEncoded = Array(mbWidth);
        for (var i = 0; i < mbWidth; i++) 
            this.topEncoded[i] = new EncodedMB();
        this.encodeSlice(this.sps, this.pps, pic, dup, idr, frameNumber, frameType);
        this.putLastMBLine();
        this.ref = this.picOut;
        dup.flip();
        return dup;
    };
    prototype.writePPS = function(dup, pps) {
        var tmp = ByteBuffer.allocate(1024);
        pps.write(tmp);
        tmp.flip();
        H264Utils.escapeNAL(tmp, dup);
    };
    prototype.writeSPS = function(dup, sps) {
        var tmp = ByteBuffer.allocate(1024);
        sps.write(tmp);
        tmp.flip();
        H264Utils.escapeNAL(tmp, dup);
    };
    prototype.initPPS = function() {
        var pps = new PictureParameterSet();
        pps.pic_init_qp_minus26 = this.rc.getInitQp(SliceType.I) - 26;
        return pps;
    };
    prototype.initSPS = function(sz) {
        var sps = new SeqParameterSet();
        sps.pic_width_in_mbs_minus1 = ((sz.getWidth() + 15) >> 4) - 1;
        sps.pic_height_in_map_units_minus1 = ((sz.getHeight() + 15) >> 4) - 1;
        sps.chroma_format_idc = ColorSpace.YUV420J;
        sps.profile_idc = 66;
        sps.level_idc = 40;
        sps.frame_mbs_only_flag = true;
        sps.log2_max_frame_num_minus4 = Math.max(0, MathUtil.log2(this.keyInterval) - 3);
        var codedWidth = (sps.pic_width_in_mbs_minus1 + 1) << 4;
        var codedHeight = (sps.pic_height_in_map_units_minus1 + 1) << 4;
        sps.frame_cropping_flag = codedWidth != sz.getWidth() || codedHeight != sz.getHeight();
        sps.frame_crop_right_offset = (codedWidth - sz.getWidth() + 1) >> 1;
        sps.frame_crop_bottom_offset = (codedHeight - sz.getHeight() + 1) >> 1;
        return sps;
    };
    prototype.encodeSlice = function(sps, pps, pic, dup, idr, frameNum, sliceType) {
        if (idr && sliceType != SliceType.I) {
            idr = false;
            jcodec.Logger.warn("Illegal value of idr = true when sliceType != I");
        }
        this.cavlc = [new CAVLC(sps, pps, 2, 2), new CAVLC(sps, pps, 1, 1), new CAVLC(sps, pps, 1, 1)];
        this.mbEncoderI16x16 = new MBEncoderI16x16(this.cavlc, this.leftRow, this.topLine);
        this.mbEncoderP16x16 = new MBEncoderP16x16(sps, this.ref, this.cavlc, new MotionEstimator(16));
        this.rc.reset();
        var qp = this.rc.getInitQp(sliceType);
        dup.putInt(1);
        new NALUnit(idr ? NALUnitType.IDR_SLICE : NALUnitType.NON_IDR_SLICE, 3).write(dup);
        var sh = new SliceHeader();
        sh.slice_type = sliceType;
        if (idr) 
            sh.refPicMarkingIDR = new RefPicMarkingIDR(false, false);
        sh.pps = pps;
        sh.sps = sps;
        sh.pic_order_cnt_lsb = (frameNum << 1) % this.maxPOC;
        sh.frame_num = frameNum % this.maxFrameNumber;
        sh.slice_qp_delta = qp - (pps.pic_init_qp_minus26 + 26);
        var buf = ByteBuffer.allocate(pic.getWidth() * pic.getHeight());
        var sliceData = new BitWriter(buf);
        new SliceHeaderWriter().write(sh, idr, 2, sliceData);
        for (var mbY = 0; mbY < sps.pic_height_in_map_units_minus1 + 1; mbY++) {
            for (var mbX = 0; mbX < sps.pic_width_in_mbs_minus1 + 1; mbX++) {
                if (sliceType == SliceType.P) {
                    CAVLCWriter.writeUE(sliceData, 0);
                }
                var mbType = this.selectMBType(sliceType);
                if (mbType == MBType.I_16x16) {
                    var predMode = this.mbEncoderI16x16.getPredMode(pic, mbX, mbY);
                    var cbpChroma = this.mbEncoderI16x16.getCbpChroma(pic, mbX, mbY);
                    var cbpLuma = this.mbEncoderI16x16.getCbpLuma(pic, mbX, mbY);
                    var i16x16TypeOffset = (stjs.trunc(cbpLuma / 15)) * 12 + cbpChroma * 4 + predMode;
                    var mbTypeOffset = sliceType == SliceType.P ? 5 : 0;
                    CAVLCWriter.writeUE(sliceData, mbTypeOffset + mbType.code() + i16x16TypeOffset);
                } else {
                    CAVLCWriter.writeUE(sliceData, mbType.code());
                }
                var candidate;
                var qpDelta;
                do {
                    candidate = sliceData.fork();
                    qpDelta = this.rc.getQpDelta();
                    this.encodeMacroblock(mbType, pic, mbX, mbY, candidate, qp, qpDelta);
                } while (!this.rc.accept(candidate.position() - sliceData.position()));
                sliceData = candidate;
                qp += qpDelta;
                this.collectPredictors(this.outMB.getPixels(), mbX);
                this.addToReference(mbX, mbY);
            }
        }
        sliceData.write1Bit(1);
        sliceData.flush();
        buf = sliceData.getBuffer();
        buf.flip();
        H264Utils.escapeNAL(buf, dup);
    };
    prototype.encodeMacroblock = function(mbType, pic, mbX, mbY, candidate, qp, qpDelta) {
        if (mbType == MBType.I_16x16) 
            this.mbEncoderI16x16.encodeMacroblock(pic, mbX, mbY, candidate, this.outMB, mbX > 0 ? this.topEncoded[mbX - 1] : null, mbY > 0 ? this.topEncoded[mbX] : null, qp + qpDelta, qpDelta);
         else if (mbType == MBType.P_16x16) 
            this.mbEncoderP16x16.encodeMacroblock(pic, mbX, mbY, candidate, this.outMB, mbX > 0 ? this.topEncoded[mbX - 1] : null, mbY > 0 ? this.topEncoded[mbX] : null, qp + qpDelta, qpDelta);
         else 
             throw new RuntimeException("Macroblock of type " + mbType + " is not supported.");
    };
    prototype.selectMBType = function(sliceType) {
        if (sliceType == SliceType.I) 
            return MBType.I_16x16;
         else if (sliceType == SliceType.P) 
            return MBType.P_16x16;
         else 
             throw new RuntimeException("Unsupported slice type");
    };
    prototype.addToReference = function(mbX, mbY) {
        if (mbY > 0) 
            MBEncoderHelper.putBlkPic(this.picOut, this.topEncoded[mbX].getPixels(), mbX << 4, (mbY - 1) << 4);
        var tmp = this.topEncoded[mbX];
        this.topEncoded[mbX] = this.outMB;
        this.outMB = tmp;
    };
    prototype.putLastMBLine = function() {
        var mbWidth = this.sps.pic_width_in_mbs_minus1 + 1;
        var mbHeight = this.sps.pic_height_in_map_units_minus1 + 1;
        for (var mbX = 0; mbX < mbWidth; mbX++) 
            MBEncoderHelper.putBlkPic(this.picOut, this.topEncoded[mbX].getPixels(), mbX << 4, (mbHeight - 1) << 4);
    };
    prototype.collectPredictors = function(outMB, mbX) {
        System.arraycopy(outMB.getPlaneData(0), 240, this.topLine[0], mbX << 4, 16);
        System.arraycopy(outMB.getPlaneData(1), 56, this.topLine[1], mbX << 3, 8);
        System.arraycopy(outMB.getPlaneData(2), 56, this.topLine[2], mbX << 3, 8);
        this.copyCol(outMB.getPlaneData(0), 15, 16, this.leftRow[0]);
        this.copyCol(outMB.getPlaneData(1), 7, 8, this.leftRow[1]);
        this.copyCol(outMB.getPlaneData(2), 7, 8, this.leftRow[2]);
    };
    prototype.copyCol = function(planeData, off, stride, out) {
        for (var i = 0; i < out.length; i++) {
            out[i] = planeData[off];
            off += stride;
        }
    };
    prototype.getSupportedColorSpaces = function() {
        return [ColorSpace.YUV420J];
    };
}, {cavlc: "Array", leftRow: "Array", topLine: "Array", rc: "RateControl", sps: "SeqParameterSet", pps: "PictureParameterSet", mbEncoderI16x16: "MBEncoderI16x16", mbEncoderP16x16: "MBEncoderP16x16", ref: "Picture8Bit", picOut: "Picture8Bit", topEncoded: "Array", outMB: "EncodedMB"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Shared routines between PCM and Frames tracks
 *  
 *  @author The JCodec project
 *  
 */
var AbstractMP4DemuxerTrack = function(trak) {
    this.no = trak.getTrackHeader().getNo();
    this.type = TrakBox.getTrackType(trak);
    this.sampleEntries = NodeBox.findAllPath(trak, SampleEntry, ["mdia", "minf", "stbl", "stsd", null]);
    var stbl = trak.getMdia().getMinf().getStbl();
    var stts = NodeBox.findFirst(stbl, TimeToSampleBox, "stts");
    var stsc = NodeBox.findFirst(stbl, SampleToChunkBox, "stsc");
    var stco = NodeBox.findFirst(stbl, ChunkOffsetsBox, "stco");
    var co64 = NodeBox.findFirst(stbl, ChunkOffsets64Box, "co64");
    this.timeToSamples = stts.getEntries();
    this.sampleToChunks = stsc.getSampleToChunk();
    this.chunkOffsets = stco != null ? stco.getChunkOffsets() : co64.getChunkOffsets();
    for (var i = 0; i < this.timeToSamples.length; i++) {
        var ttse = this.timeToSamples[i];
        this.duration += ttse.getSampleCount() * ttse.getSampleDuration();
    }
    this.box = trak;
    this.timescale = trak.getTimescale();
};
AbstractMP4DemuxerTrack = stjs.extend(AbstractMP4DemuxerTrack, null, [SeekableDemuxerTrack], function(constructor, prototype) {
    prototype.box = null;
    prototype.type = null;
    prototype.no = 0;
    prototype.sampleEntries = null;
    prototype.timeToSamples = null;
    prototype.sampleToChunks = null;
    prototype.chunkOffsets = null;
    prototype.duration = 0;
    prototype.sttsInd = 0;
    prototype.sttsSubInd = 0;
    prototype.stcoInd = 0;
    prototype.stscInd = 0;
    prototype.pts = 0;
    prototype.curFrame = 0;
    prototype.timescale = 0;
    prototype.pts2Sample = function(_tv, _timescale) {
        var tv = stjs.trunc(_tv * this.timescale / _timescale);
        var ttsInd, sample = 0;
        for (ttsInd = 0; ttsInd < this.timeToSamples.length - 1; ttsInd++) {
            var a = this.timeToSamples[ttsInd].getSampleCount() * this.timeToSamples[ttsInd].getSampleDuration();
            if (tv < a) 
                break;
            tv -= a;
            sample += this.timeToSamples[ttsInd].getSampleCount();
        }
        return sample + (((stjs.trunc(tv / this.timeToSamples[ttsInd].getSampleDuration()))) | 0);
    };
    prototype.getType = function() {
        return this.type;
    };
    prototype.getNo = function() {
        return this.no;
    };
    prototype.getSampleEntries = function() {
        return this.sampleEntries;
    };
    prototype.getBox = function() {
        return this.box;
    };
    prototype.getTimescale = function() {
        return this.timescale;
    };
    prototype.seekPointer = function(frameNo) {};
    prototype.canSeek = function(pts) {
        return pts >= 0 && pts < this.duration;
    };
    prototype.seekPts = function(pts) {
        if (pts < 0) 
             throw new IllegalArgumentException("Seeking to negative pts");
        if (pts >= this.duration) 
            return false;
        var prevDur = 0;
        var frameNo = 0;
        for (this.sttsInd = 0; pts > prevDur + this.timeToSamples[this.sttsInd].getSampleCount() * this.timeToSamples[this.sttsInd].getSampleDuration() && this.sttsInd < this.timeToSamples.length - 1; this.sttsInd++) {
            prevDur += this.timeToSamples[this.sttsInd].getSampleCount() * this.timeToSamples[this.sttsInd].getSampleDuration();
            frameNo += this.timeToSamples[this.sttsInd].getSampleCount();
        }
        this.sttsSubInd = (((stjs.trunc((pts - prevDur) / this.timeToSamples[this.sttsInd].getSampleDuration()))) | 0);
        frameNo += this.sttsSubInd;
        this.pts = prevDur + this.timeToSamples[this.sttsInd].getSampleDuration() * this.sttsSubInd;
        this.seekPointer(frameNo);
        return true;
    };
    prototype.shiftPts = function(frames) {
        this.pts -= this.sttsSubInd * this.timeToSamples[this.sttsInd].getSampleDuration();
        this.sttsSubInd += frames;
         while (this.sttsInd < this.timeToSamples.length - 1 && this.sttsSubInd >= this.timeToSamples[this.sttsInd].getSampleCount()){
            this.pts += this.timeToSamples[this.sttsInd].getSegmentDuration();
            this.sttsSubInd -= this.timeToSamples[this.sttsInd].getSampleCount();
            this.sttsInd++;
        }
        this.pts += this.sttsSubInd * this.timeToSamples[this.sttsInd].getSampleDuration();
    };
    prototype.nextChunk = function() {
        if (this.stcoInd >= this.chunkOffsets.length) 
            return;
        this.stcoInd++;
        if ((this.stscInd + 1 < this.sampleToChunks.length) && this.stcoInd + 1 == this.sampleToChunks[this.stscInd + 1].getFirst()) {
            this.stscInd++;
        }
    };
    prototype.gotoFrame = function(frameNo) {
        if (frameNo < 0) 
             throw new IllegalArgumentException("negative frame number");
        if (frameNo >= this.getFrameCount()) 
            return false;
        if (frameNo == this.curFrame) 
            return true;
        this.seekPointer(frameNo);
        this.seekFrame(frameNo);
        return true;
    };
    prototype.seek = function(second) {
        this.seekPts(stjs.trunc((second * this.timescale)));
    };
    prototype.seekFrame = function(frameNo) {
        this.pts = this.sttsInd = this.sttsSubInd = 0;
        this.shiftPts(frameNo);
    };
    prototype.getDuration = function() {
        return new RationalLarge(this.box.getMediaDuration(), this.box.getTimescale());
    };
    prototype.getFrameCount = function() {};
    prototype.getCurFrame = function() {
        return this.curFrame;
    };
    prototype.getEdits = function() {
        var editListBox = NodeBox.findFirstPath(this.box, EditListBox, Box.path("edts.elst"));
        if (editListBox != null) 
            return editListBox.getEdits();
        return null;
    };
    prototype.getName = function() {
        var nameBox = NodeBox.findFirstPath(this.box, NameBox, Box.path("udta.name"));
        return nameBox != null ? nameBox.getName() : null;
    };
    prototype.getFourcc = function() {
        return this.getSampleEntries()[0].getFourcc();
    };
    prototype.readPacketData = function(input, buffer, offset, size) {
        var result = buffer.duplicate();
        {
            input.setPosition(offset);
            NIOUtils.readL(input, result, size);
        }result.flip();
        return result;
    };
    prototype.getNextFrame = function(storage) {};
    prototype.getCodec = function() {
        var se = this.getSampleEntries()[0];
        var fourcc = se.getHeader().getFourcc();
        if (fourcc.equals("avc1")) {
            return Codec.H264;
        } else if (fourcc.equals("m1v1") || fourcc.equals("m2v1")) {
            return Codec.MPEG2;
        } else if (fourcc.equals("apco") || fourcc.equals("apcs") || fourcc.equals("apcn") || fourcc.equals("apch") || fourcc.equals("ap4h")) {
            return Codec.PRORES;
        }
        return null;
    };
    prototype.getCodecPrivate = function() {
        var se = this.getSampleEntries()[0];
        if ("avc1".equals(se.getFourcc())) {
            var avcC = H264Utils.parseAVCC(se);
            return H264Utils.avcCToAnnexB(avcC);
        }
        return null;
    };
    prototype.convertPacket = function(_in) {
        return _in;
    };
}, {box: "TrakBox", type: "TrackType", sampleEntries: "Array", timeToSamples: "Array", sampleToChunks: "Array", chunkOffsets: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Extracts H.264 frames out H.264 Elementary stream ( according to Annex B )
 *  
 *  @author The JCodec project
 *  
 */
var MappedH264ES = function(bb) {
    this.pps = new IntObjectMap();
    this.sps = new IntObjectMap();
    this.bb = bb;
    this.shr = new SliceHeaderReader();
    this.frameNo = 0;
};
MappedH264ES = stjs.extend(MappedH264ES, null, [DemuxerTrack], function(constructor, prototype) {
    prototype.bb = null;
    prototype.shr = null;
    prototype.pps = null;
    prototype.sps = null;
    prototype.prevFrameNumOffset = 0;
    prototype.prevFrameNum = 0;
    prototype.prevPicOrderCntMsb = 0;
    prototype.prevPicOrderCntLsb = 0;
    prototype.frameNo = 0;
    prototype.nextFrame = function() {
        var result = this.bb.duplicate();
        var prevNu = null;
        var prevSh = null;
         while (true){
            this.bb.mark();
            var buf = H264Utils.nextNALUnit(this.bb);
            if (buf == null) 
                break;
            var nu = NALUnit.read(buf);
            if (nu.type == NALUnitType.IDR_SLICE || nu.type == NALUnitType.NON_IDR_SLICE) {
                var sh = this.readSliceHeader(buf, nu);
                if (prevNu != null && prevSh != null && !this.sameFrame(prevNu, nu, prevSh, sh)) {
                    this.bb.reset();
                    break;
                }
                prevSh = sh;
                prevNu = nu;
            } else if (nu.type == NALUnitType.PPS) {
                var read = PictureParameterSet.read(buf);
                this.pps.put(read.pic_parameter_set_id, read);
            } else if (nu.type == NALUnitType.SPS) {
                var read = SeqParameterSet.read(buf);
                this.sps.put(read.seq_parameter_set_id, read);
            }
        }
        result.setLimit(this.bb.position());
        return prevSh == null ? null : this.detectPoc(result, prevNu, prevSh);
    };
    prototype.readSliceHeader = function(buf, nu) {
        var br = BitReader.createBitReader(buf);
        var sh = this.shr.readPart1(br);
        var pp = this.pps.get(sh.pic_parameter_set_id);
        this.shr.readPart2(sh, nu, this.sps.get(pp.seq_parameter_set_id), pp, br);
        return sh;
    };
    prototype.sameFrame = function(nu1, nu2, sh1, sh2) {
        if (sh1.pic_parameter_set_id != sh2.pic_parameter_set_id) 
            return false;
        if (sh1.frame_num != sh2.frame_num) 
            return false;
        var sps = sh1.sps;
        if (sps.pic_order_cnt_type == 0 && sh1.pic_order_cnt_lsb != sh2.pic_order_cnt_lsb) 
            return false;
        if (sps.pic_order_cnt_type == 1 && (sh1.delta_pic_order_cnt[0] != sh2.delta_pic_order_cnt[0] || sh1.delta_pic_order_cnt[1] != sh2.delta_pic_order_cnt[1])) 
            return false;
        if ((nu1.nal_ref_idc == 0 || nu2.nal_ref_idc == 0) && nu1.nal_ref_idc != nu2.nal_ref_idc) 
            return false;
        if ((nu1.type == NALUnitType.IDR_SLICE) != (nu2.type == NALUnitType.IDR_SLICE)) 
            return false;
        if (sh1.idr_pic_id != sh2.idr_pic_id) 
            return false;
        return true;
    };
    prototype.detectPoc = function(result, nu, sh) {
        var maxFrameNum = 1 << (sh.sps.log2_max_frame_num_minus4 + 4);
        if (this.detectGap(sh, maxFrameNum)) {
            this.issueNonExistingPic(sh, maxFrameNum);
        }
        var absFrameNum = this.updateFrameNumber(sh.frame_num, maxFrameNum, this.detectMMCO5(sh.refPicMarkingNonIDR));
        var poc = 0;
        if (nu.type == NALUnitType.NON_IDR_SLICE) {
            poc = this.calcPoc(absFrameNum, nu, sh);
        }
        return new Packet(result, absFrameNum, 1, 1, this.frameNo++, nu.type == NALUnitType.IDR_SLICE, null, poc);
    };
    prototype.updateFrameNumber = function(frameNo, maxFrameNum, mmco5) {
        var frameNumOffset;
        if (this.prevFrameNum > frameNo) 
            frameNumOffset = this.prevFrameNumOffset + maxFrameNum;
         else 
            frameNumOffset = this.prevFrameNumOffset;
        var absFrameNum = frameNumOffset + frameNo;
        this.prevFrameNum = mmco5 ? 0 : frameNo;
        this.prevFrameNumOffset = frameNumOffset;
        return absFrameNum;
    };
    prototype.issueNonExistingPic = function(sh, maxFrameNum) {
        var nextFrameNum = (this.prevFrameNum + 1) % maxFrameNum;
        this.prevFrameNum = nextFrameNum;
    };
    prototype.detectGap = function(sh, maxFrameNum) {
        return sh.frame_num != this.prevFrameNum && sh.frame_num != ((this.prevFrameNum + 1) % maxFrameNum);
    };
    prototype.calcPoc = function(absFrameNum, nu, sh) {
        if (sh.sps.pic_order_cnt_type == 0) {
            return this.calcPOC0(nu, sh);
        } else if (sh.sps.pic_order_cnt_type == 1) {
            return this.calcPOC1(absFrameNum, nu, sh);
        } else {
            return this.calcPOC2(absFrameNum, nu, sh);
        }
    };
    prototype.calcPOC2 = function(absFrameNum, nu, sh) {
        if (nu.nal_ref_idc == 0) 
            return 2 * absFrameNum - 1;
         else 
            return 2 * absFrameNum;
    };
    prototype.calcPOC1 = function(absFrameNum, nu, sh) {
        if (sh.sps.num_ref_frames_in_pic_order_cnt_cycle == 0) 
            absFrameNum = 0;
        if (nu.nal_ref_idc == 0 && absFrameNum > 0) 
            absFrameNum = absFrameNum - 1;
        var expectedDeltaPerPicOrderCntCycle = 0;
        for (var i = 0; i < sh.sps.num_ref_frames_in_pic_order_cnt_cycle; i++) 
            expectedDeltaPerPicOrderCntCycle += sh.sps.offsetForRefFrame[i];
        var expectedPicOrderCnt;
        if (absFrameNum > 0) {
            var picOrderCntCycleCnt = stjs.trunc((absFrameNum - 1) / sh.sps.num_ref_frames_in_pic_order_cnt_cycle);
            var frameNumInPicOrderCntCycle = (absFrameNum - 1) % sh.sps.num_ref_frames_in_pic_order_cnt_cycle;
            expectedPicOrderCnt = picOrderCntCycleCnt * expectedDeltaPerPicOrderCntCycle;
            for (var i = 0; i <= frameNumInPicOrderCntCycle; i++) 
                expectedPicOrderCnt = expectedPicOrderCnt + sh.sps.offsetForRefFrame[i];
        } else {
            expectedPicOrderCnt = 0;
        }
        if (nu.nal_ref_idc == 0) 
            expectedPicOrderCnt = expectedPicOrderCnt + sh.sps.offset_for_non_ref_pic;
        return expectedPicOrderCnt + sh.delta_pic_order_cnt[0];
    };
    prototype.calcPOC0 = function(nu, sh) {
        var pocCntLsb = sh.pic_order_cnt_lsb;
        var maxPicOrderCntLsb = 1 << (sh.sps.log2_max_pic_order_cnt_lsb_minus4 + 4);
        var picOrderCntMsb;
        if ((pocCntLsb < this.prevPicOrderCntLsb) && ((this.prevPicOrderCntLsb - pocCntLsb) >= (stjs.trunc(maxPicOrderCntLsb / 2)))) 
            picOrderCntMsb = this.prevPicOrderCntMsb + maxPicOrderCntLsb;
         else if ((pocCntLsb > this.prevPicOrderCntLsb) && ((pocCntLsb - this.prevPicOrderCntLsb) > (stjs.trunc(maxPicOrderCntLsb / 2)))) 
            picOrderCntMsb = this.prevPicOrderCntMsb - maxPicOrderCntLsb;
         else 
            picOrderCntMsb = this.prevPicOrderCntMsb;
        if (nu.nal_ref_idc != 0) {
            this.prevPicOrderCntMsb = picOrderCntMsb;
            this.prevPicOrderCntLsb = pocCntLsb;
        }
        return picOrderCntMsb + pocCntLsb;
    };
    prototype.detectMMCO5 = function(refPicMarkingNonIDR) {
        if (refPicMarkingNonIDR == null) 
            return false;
        var instructions = refPicMarkingNonIDR.getInstructions();
        for (var i = 0; i < instructions.length; i++) {
            var instr = instructions[i];
            if (instr.getType() == RefPicMarking.InstrType.CLEAR) {
                return true;
            }
        }
        return false;
    };
    prototype.getSps = function() {
        return this.sps.values(Array(0));
    };
    prototype.getPps = function() {
        return this.pps.values(Array(0));
    };
    prototype.getMeta = function() {
         throw new NotSupportedException();
    };
}, {bb: "ByteBuffer", shr: "SliceHeaderReader", pps: {name: "IntObjectMap", arguments: ["PictureParameterSet"]}, sps: {name: "IntObjectMap", arguments: ["SeqParameterSet"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Concats AVC tracks, special logic to merge codec private is applied
 *  
 *  TODO: Check SPS/PPS for similarity TODO: Support multiple SPS/PPS per piece
 *  
 *  @author The JCodec project
 *  
 */
var AVCConcatTrack = function(_arguments) {
    this.tracks = arguments;
    var pasp = null;
    this.allPps = new ArrayList();
    this.allSps = new ArrayList();
    this.tweakers = Array(arguments.length);
    this.map = new HashMap();
    for (var i = 0; i < arguments.length; i++) {
        var se = arguments[i].getCodecMeta();
        if (!(stjs.isInstanceOf(se.constructor, VideoCodecMeta))) 
             throw new RuntimeException("Not a video track.");
        if (!"avc1".equals(se.getFourcc())) 
             throw new RuntimeException("Not an AVC track.");
        var vcm = se;
        var paspL = vcm.getPasp();
        if (pasp != null && paspL != null && !pasp.equalsRational(paspL)) 
             throw new RuntimeException("Can not concat video tracks with different Pixel Aspect Ratio.");
        pasp = paspL;
        var rawPPSs = H264Utils.getRawPPS(se.getCodecPrivate());
        for (var iterator$ppsBuffer = rawPPSs.iterator(); iterator$ppsBuffer.hasNext(); ) {
            var ppsBuffer = iterator$ppsBuffer.next();
            var pps = H264Utils.readPPS(NIOUtils.duplicate(ppsBuffer));
            pps.pic_parameter_set_id |= i << 8;
            pps.seq_parameter_set_id |= i << 8;
            this.allPps.add(pps);
        }
        var rawSPSs = H264Utils.getRawSPS(se.getCodecPrivate());
        for (var iterator$spsBuffer = rawSPSs.iterator(); iterator$spsBuffer.hasNext(); ) {
            var spsBuffer = iterator$spsBuffer.next();
            var sps = H264Utils.readSPS(NIOUtils.duplicate(spsBuffer));
            sps.seq_parameter_set_id |= i << 8;
            this.allSps.add(sps);
        }
        var idx2 = i;
        this.tweakers[i] = new AVCConcatTrack.AvccTweaker(rawSPSs, rawPPSs, idx2, this);
    }
    this.mergePS(this.allSps, this.allPps, this.map);
    var codecMeta = arguments[0].getCodecMeta();
    this.se = VideoCodecMeta.createVideoCodecMeta("avc1", ByteBuffer.wrap(H264Utils.saveCodecPrivate(H264Utils.saveSPS(this.allSps), H264Utils.savePPS(this.allPps))), codecMeta.getSize(), codecMeta.getPasp());
};
AVCConcatTrack = stjs.extend(AVCConcatTrack, null, [VirtualTrack], function(constructor, prototype) {
    prototype.tracks = null;
    prototype.idx = 0;
    prototype.lastPacket = null;
    prototype.offsetPts = 0;
    prototype.offsetFn = 0;
    prototype.se = null;
    prototype.map = null;
    prototype.allPps = null;
    prototype.allSps = null;
    prototype.tweakers = null;
    prototype.mergePS = function(allSps, allPps, map) {
        var spsRef = new ArrayList();
        for (var iterator$sps = allSps.iterator(); iterator$sps.hasNext(); ) {
            var sps = iterator$sps.next();
            var spsId = sps.seq_parameter_set_id;
            sps.seq_parameter_set_id = 0;
            var serial = H264Utils.writeSPS(sps, 32);
            var idx = NIOUtils.find(spsRef, serial);
            if (idx == -1) {
                idx = spsRef.size();
                spsRef.add(serial);
            }
            for (var iterator$pps = allPps.iterator(); iterator$pps.hasNext(); ) {
                var pps = iterator$pps.next();
                if (pps.seq_parameter_set_id == spsId) 
                    pps.seq_parameter_set_id = idx;
            }
        }
        var ppsRef = new ArrayList();
        for (var iterator$pps = allPps.iterator(); iterator$pps.hasNext(); ) {
            var pps = iterator$pps.next();
            var ppsId = pps.pic_parameter_set_id;
            pps.pic_parameter_set_id = 0;
            var serial = H264Utils.writePPS(pps, 128);
            var idx = NIOUtils.find(ppsRef, serial);
            if (idx == -1) {
                idx = ppsRef.size();
                ppsRef.add(serial);
            }
            map.put(ppsId, idx);
        }
        allSps.clear();
        for (var i = 0; i < spsRef.size(); i++) {
            var sps = H264Utils.readSPS(spsRef.get(i));
            sps.seq_parameter_set_id = i;
            allSps.add(sps);
        }
        allPps.clear();
        for (var i = 0; i < ppsRef.size(); i++) {
            var pps = H264Utils.readPPS(ppsRef.get(i));
            pps.pic_parameter_set_id = i;
            allPps.add(pps);
        }
    };
    prototype.nextPacket = function() {
         while (this.idx < this.tracks.length){
            var track = this.tracks[this.idx];
            var nextPacket = track.nextPacket();
            if (nextPacket == null) {
                this.idx++;
                this.offsetPts += this.lastPacket.getPts() + this.lastPacket.getDuration();
                this.offsetFn += this.lastPacket.getFrameNo() + 1;
            } else {
                this.lastPacket = nextPacket;
                return new AVCConcatTrack.AVCConcatPacket(this, nextPacket, this.offsetPts, this.offsetFn, this.idx);
            }
        }
        return null;
    };
    prototype.getCodecMeta = function() {
        return this.se;
    };
    prototype.getEdits = function() {
        return null;
    };
    prototype.getPreferredTimescale = function() {
        return this.tracks[0].getPreferredTimescale();
    };
    prototype.close = function() {
        for (var i = 0; i < this.tracks.length; i++) {
            this.tracks[i].close();
        }
    };
    prototype.patchPacket = function(idx2, data) {
        var out = ByteBuffer.allocate(data.remaining() + 8);
        for (var iterator$nal = H264Utils.splitFrame(data).iterator(); iterator$nal.hasNext(); ) {
            var nal = iterator$nal.next();
            var nu = NALUnit.read(nal);
            if (nu.type == NALUnitType.IDR_SLICE || nu.type == NALUnitType.NON_IDR_SLICE) {
                out.putInt(1);
                nu.write(out);
                this.tweakers[idx2].run(nal, out, nu);
            } else {
                jcodec.Logger.warn("Skipping NAL unit: " + nu.type);
            }
        }
        if (out.remaining() >= 5) {
            out.putInt(1);
            new NALUnit(NALUnitType.FILLER_DATA, 0).write(out);
        }
        out.clear();
        return out;
    };
    constructor.AvccTweaker = function(spsList, ppsList, idx2, track) {
        H264Utils.SliceHeaderTweaker.call(this);
        this.sps = H264Utils.readSPSFromBufferList(spsList);
        this.pps = H264Utils.readPPSFromBufferList(ppsList);
        this.idx2 = idx2;
        this.track = track;
    };
    constructor.AvccTweaker = stjs.extend(constructor.AvccTweaker, H264Utils.SliceHeaderTweaker, [], function(constructor, prototype) {
        prototype.idx2 = 0;
        prototype.track = null;
        prototype.tweak = function(sh) {
            sh.pic_parameter_set_id = this.track.map.get((this.idx2 << 8) | sh.pic_parameter_set_id);
        };
    }, {track: "AVCConcatTrack", sps: {name: "List", arguments: ["SeqParameterSet"]}, pps: {name: "List", arguments: ["PictureParameterSet"]}}, {});
    constructor.AVCConcatPacket = function(track, packet, ptsOffset, fnOffset, idx) {
        this.track = track;
        this.packet = packet;
        this.ptsOffset = ptsOffset;
        this.fnOffset = fnOffset;
        this.idx = idx;
    };
    constructor.AVCConcatPacket = stjs.extend(constructor.AVCConcatPacket, null, [VirtualPacket], function(constructor, prototype) {
        prototype.packet = null;
        prototype.ptsOffset = 0.0;
        prototype.fnOffset = 0;
        prototype.idx = 0;
        prototype.track = null;
        prototype.getData = function() {
            return this.track.patchPacket(this.idx, this.packet.getData());
        };
        prototype.getDataLen = function() {
            return this.packet.getDataLen() + 8;
        };
        prototype.getPts = function() {
            return this.ptsOffset + this.packet.getPts();
        };
        prototype.getDuration = function() {
            return this.packet.getDuration();
        };
        prototype.isKeyframe = function() {
            return this.packet.isKeyframe();
        };
        prototype.getFrameNo = function() {
            return this.fnOffset + this.packet.getFrameNo();
        };
    }, {packet: "VirtualPacket", track: "AVCConcatTrack", byPts: {name: "Comparator", arguments: ["Object"]}}, {});
}, {tracks: "Array", lastPacket: "VirtualPacket", se: "CodecMeta", map: {name: "Map", arguments: [null, null]}, allPps: {name: "List", arguments: ["PictureParameterSet"]}, allSps: {name: "List", arguments: ["SeqParameterSet"]}, tweakers: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Makes a clip out of an FLV
 *  
 *  @author Stanislav Vitvitskyy
 *  
 */
var FLVTool = function() {};
FLVTool = stjs.extend(FLVTool, null, [], function(constructor, prototype) {
    constructor.processors = new HashMap();
    constructor.main1 = function(args) {
        if (args.length < 1) {
            FLVTool.printGenericHelp();
            return;
        }
        var command = args[0];
        var cmd = MainUtils.parseArguments(Platform.copyOfRangeO(args, 1, args.length));
        if (cmd.args.length < 1) {
            MainUtils.printHelpCmd(command, FLVTool.processors.get(command).getFlags(), Arrays.asList("file _in", "?file out"));
            return;
        }
        var maxPackets = cmd.getIntegerFlagD("max-packets", Integer.MAX_VALUE);
        var processor = FLVTool.getProcessor(command, cmd);
        if (processor == null) {
            System.err.println("Unknown command: " + command);
            FLVTool.printGenericHelp();
            return;
        }
        var _in = null;
        var out = null;
        try {
            _in = NIOUtils.readableChannel(new File(cmd.getArg(0)));
            if (processor.hasOutput()) 
                out = NIOUtils.writableChannel(new File(cmd.getArg(1)));
            var demuxer = new FLVReader(_in);
            var muxer = new FLVWriter(out);
            var pkt = null;
            for (var i = 0; i < maxPackets && (pkt = demuxer.readNextPacket()) != null; i++) {
                if (!processor.processPacket(pkt, muxer)) 
                    break;
            }
            processor.finish(muxer);
            if (processor.hasOutput()) 
                muxer.finish();
        } finally {
            IOUtils.closeQuietly(_in);
            IOUtils.closeQuietly(out);
        }
    };
    constructor.printGenericHelp = function() {
        System.err.println("Syntax: <command> [flags] <file in> [file out]\nWhere command is: [" + StringUtils.joinS(FLVTool.processors.keySet().toArray(Array(0)), ", ") + "].");
    };
    constructor.getProcessor = function(command, cmd) {
        var factory = FLVTool.processors.get(command);
        if (factory == null) 
            return null;
        return factory.newPacketProcessor(cmd);
    };
    constructor.PacketProcessor = function() {};
    constructor.PacketProcessor = stjs.extend(constructor.PacketProcessor, null, [], function(constructor, prototype) {
        prototype.processPacket = function(pkt, writer) {};
        prototype.hasOutput = function() {};
        prototype.finish = function(muxer) {};
    }, {}, {});
    constructor.PacketProcessorFactory = function() {};
    constructor.PacketProcessorFactory = stjs.extend(constructor.PacketProcessorFactory, null, [], function(constructor, prototype) {
        prototype.newPacketProcessor = function(flags) {};
        prototype.getFlags = function() {};
    }, {}, {});
    /**
     *  A packet processor that clips the flv between the given timestamps
     *  
     */
    constructor.ClipPacketProcessor = function(from, to) {
        this.from = from;
        this.to = to;
    };
    constructor.ClipPacketProcessor = stjs.extend(constructor.ClipPacketProcessor, null, [FLVTool.PacketProcessor], function(constructor, prototype) {
        constructor.h264Config = null;
        prototype.copying = false;
        prototype.from = null;
        prototype.to = null;
        constructor.Factory = function() {};
        constructor.Factory = stjs.extend(constructor.Factory, null, [FLVTool.PacketProcessorFactory], function(constructor, prototype) {
            prototype.newPacketProcessor = function(flags) {
                return new FLVTool.ClipPacketProcessor(flags.getDoubleFlag("from"), flags.getDoubleFlag("to"));
            };
            prototype.getFlags = function() {
                var map = new HashMap();
                map.put("from", "From timestamp (in seconds, i.e 67.49)");
                map.put("from", "From timestamp (_in seconds, i.e 67.49)");
                map.put("to", "To timestamp");
                return map;
            };
        }, {}, {});
        prototype.processPacket = function(pkt, writer) {
            if (pkt.getType() == FLVTag.Type.VIDEO && pkt.getTagHeader().getCodec() == Codec.H264) {
                if ((pkt.getTagHeader()).getAvcPacketType() == 0) {
                    FLVTool.ClipPacketProcessor.h264Config = pkt;
                    System.out.println("GOT AVCC");
                }
            }
            if (!this.copying && (this.from == null || pkt.getPtsD() > this.from) && pkt.getType() == FLVTag.Type.VIDEO && pkt.isKeyFrame() && FLVTool.ClipPacketProcessor.h264Config != null) {
                System.out.println("Starting at packet: " + ToJSON.toJSON(pkt));
                this.copying = true;
                FLVTool.ClipPacketProcessor.h264Config.setPts(pkt.getPts());
                writer.addPacket(FLVTool.ClipPacketProcessor.h264Config);
            }
            if (this.to != null && pkt.getPtsD() >= this.to) {
                System.out.println("Stopping at packet: " + ToJSON.toJSON(pkt));
                return false;
            }
            if (this.copying) 
                writer.addPacket(pkt);
            return true;
        };
        prototype.finish = function(muxer) {};
        prototype.hasOutput = function() {
            return true;
        };
    }, {h264Config: "FLVTag"}, {});
    /**
     *  A packet processor that forces a certain FPS
     *  
     */
    constructor.FixPtsProcessor = function() {
        this.tags = new ArrayList();
    };
    constructor.FixPtsProcessor = stjs.extend(constructor.FixPtsProcessor, null, [FLVTool.PacketProcessor], function(constructor, prototype) {
        prototype.lastPtsAudio = 0;
        prototype.lastPtsVideo = 0;
        prototype.tags = null;
        prototype.audioTagsInQueue = 0;
        prototype.videoTagsInQueue = 0;
        constructor.CORRECTION_PACE = 0.33;
        constructor.Factory = function() {};
        constructor.Factory = stjs.extend(constructor.Factory, null, [FLVTool.PacketProcessorFactory], function(constructor, prototype) {
            prototype.newPacketProcessor = function(flags) {
                return new FLVTool.FixPtsProcessor();
            };
            prototype.getFlags = function() {
                return new HashMap();
            };
        }, {}, {});
        prototype.processPacket = function(pkt, writer) {
            this.tags.add(pkt);
            if (pkt.getType() == FLVTag.Type.AUDIO) {
                ++this.audioTagsInQueue;
            } else if (pkt.getType() == FLVTag.Type.VIDEO) {
                ++this.videoTagsInQueue;
            }
            if (this.tags.size() < 600) 
                return true;
            this.processOneTag(writer);
            return true;
        };
        prototype.processOneTag = function(writer) {
            var tag = this.tags.remove(0);
            if (tag.getType() == FLVTag.Type.AUDIO) {
                tag.setPts(((Math.round(this.lastPtsAudio * 1000)) | 0));
                this.lastPtsAudio += this.audioFrameDuration((tag.getTagHeader()));
                --this.audioTagsInQueue;
            } else if (tag.getType() == FLVTag.Type.VIDEO) {
                var duration = ((1024 * this.audioTagsInQueue) / (48000 * this.videoTagsInQueue));
                tag.setPts(((Math.round(this.lastPtsVideo * 1000)) | 0));
                this.lastPtsVideo += Math.min((1 + FLVTool.FixPtsProcessor.CORRECTION_PACE) * duration, Math.max((1 - FLVTool.FixPtsProcessor.CORRECTION_PACE) * duration, duration + Math.min(1, Math.abs(this.lastPtsAudio - this.lastPtsVideo)) * (this.lastPtsAudio - this.lastPtsVideo)));
                --this.videoTagsInQueue;
                System.out.println(this.lastPtsVideo + " - " + this.lastPtsAudio);
            } else {
                tag.setPts(((Math.round(this.lastPtsVideo * 1000)) | 0));
            }
            writer.addPacket(tag);
        };
        prototype.audioFrameDuration = function(audioTagHeader) {
            switch (audioTagHeader.getCodec()) {
                case Codec.AAC:
                    return (1024) / audioTagHeader.getAudioFormat().getSampleRate();
                case Codec.MP3:
                    return (1152) / audioTagHeader.getAudioFormat().getSampleRate();
                default:
                     throw new RuntimeException("Audio codec:" + audioTagHeader.getCodec() + " is not supported.");
            }
        };
        prototype.finish = function(muxer) {
             while (this.tags.size() > 0){
                this.processOneTag(muxer);
            }
        };
        prototype.hasOutput = function() {
            return true;
        };
    }, {tags: {name: "List", arguments: ["FLVTag"]}}, {});
    /**
     *  A packet processor that just dumps info
     *  
     */
    constructor.InfoPacketProcessor = function(checkOnly, streamType) {
        this.checkOnly = checkOnly;
        this.streamType = streamType;
    };
    constructor.InfoPacketProcessor = stjs.extend(constructor.InfoPacketProcessor, null, [FLVTool.PacketProcessor], function(constructor, prototype) {
        prototype.prevVideoTag = null;
        prototype.prevAudioTag = null;
        constructor.Factory = function() {};
        constructor.Factory = stjs.extend(constructor.Factory, null, [FLVTool.PacketProcessorFactory], function(constructor, prototype) {
            constructor.FLAG_CHECK = "check";
            constructor.FLAG_STREAM = "stream";
            prototype.newPacketProcessor = function(flags) {
                return new FLVTool.InfoPacketProcessor(flags.getBooleanFlagD(FLVTool.InfoPacketProcessor.Factory.FLAG_CHECK, false), flags.getEnumFlagD(FLVTool.InfoPacketProcessor.Factory.FLAG_STREAM, null, FLVTag.Type));
            };
            prototype.getFlags = function() {
                var map = new HashMap();
                map.put(FLVTool.InfoPacketProcessor.Factory.FLAG_CHECK, "Check sanity and report errors only, no packet dump will be generated.");
                map.put(FLVTool.InfoPacketProcessor.Factory.FLAG_STREAM, "Stream selector, can be one of: ['video', 'audio', 'script'].");
                return map;
            };
        }, {}, {});
        prototype.checkOnly = false;
        prototype.streamType = null;
        prototype.processPacket = function(pkt, writer) {
            if (this.checkOnly) 
                return true;
            if (pkt.getType() == FLVTag.Type.VIDEO) {
                if (this.streamType == FLVTag.Type.VIDEO || this.streamType == null) {
                    if (this.prevVideoTag != null) 
                        this.dumpOnePacket(this.prevVideoTag, pkt.getPts() - this.prevVideoTag.getPts());
                    this.prevVideoTag = pkt;
                }
            } else if (pkt.getType() == FLVTag.Type.AUDIO) {
                if (this.streamType == FLVTag.Type.AUDIO || this.streamType == null) {
                    if (this.prevAudioTag != null) 
                        this.dumpOnePacket(this.prevAudioTag, pkt.getPts() - this.prevAudioTag.getPts());
                    this.prevAudioTag = pkt;
                }
            } else {
                this.dumpOnePacket(pkt, 0);
            }
            return true;
        };
        prototype.dumpOnePacket = function(pkt, duration) {
            System.out.print("T=" + this.typeString(pkt.getType()) + "|PTS=" + pkt.getPts() + "|DUR=" + duration + "|" + (pkt.isKeyFrame() ? "K" : " ") + "|POS=" + pkt.getPosition());
            if (stjs.isInstanceOf(pkt.getTagHeader().constructor, FLVTag.VideoTagHeader)) {
                var vt = pkt.getTagHeader();
                System.out.print("|C=" + vt.getCodec() + "|FT=" + vt.getFrameType());
                if (stjs.isInstanceOf(vt.constructor, FLVTag.AvcVideoTagHeader)) {
                    var avct = vt;
                    System.out.print("|PKT_TYPE=" + avct.getAvcPacketType() + "|COMP_OFF=" + avct.getCompOffset());
                    if (avct.getAvcPacketType() == 0) {
                        var frameData = pkt.getData().duplicate();
                        FLVReader.parseVideoTagHeader(frameData);
                        var avcc = H264Utils.parseAVCCFromBuffer(frameData);
                        for (var iterator$sps = H264Utils.readSPSFromBufferList(avcc.getSpsList()).iterator(); iterator$sps.hasNext(); ) {
                            var sps = iterator$sps.next();
                            System.out.println();
                            System.out.print("  SPS[" + sps.getSeq_parameter_set_id() + "]:" + ToJSON.toJSON(sps));
                        }
                        for (var iterator$pps = H264Utils.readPPSFromBufferList(avcc.getPpsList()).iterator(); iterator$pps.hasNext(); ) {
                            var pps = iterator$pps.next();
                            System.out.println();
                            System.out.print("  PPS[" + pps.getPic_parameter_set_id() + "]:" + ToJSON.toJSON(pps));
                        }
                    }
                }
            } else if (stjs.isInstanceOf(pkt.getTagHeader().constructor, FLVTag.AudioTagHeader)) {
                var at = pkt.getTagHeader();
                var format = at.getAudioFormat();
                System.out.print("|C=" + at.getCodec() + "|SR=" + format.getSampleRate() + "|SS=" + (format.getSampleSizeInBits() >> 3) + "|CH=" + format.getChannels());
            } else if (pkt.getType() == FLVTag.Type.SCRIPT) {
                var metadata = FLVReader.parseMetadata(pkt.getData().duplicate());
                if (metadata != null) {
                    System.out.println();
                    System.out.print("  Metadata:" + ToJSON.toJSON(metadata));
                }
            }
            System.out.println();
        };
        prototype.typeString = function(type) {
            return type.toString().substring(0, 1);
        };
        prototype.finish = function(muxer) {
            if (this.prevVideoTag != null) 
                this.dumpOnePacket(this.prevVideoTag, 0);
            if (this.prevAudioTag != null) 
                this.dumpOnePacket(this.prevAudioTag, 0);
        };
        prototype.hasOutput = function() {
            return false;
        };
    }, {prevVideoTag: "FLVTag", prevAudioTag: "FLVTag", streamType: {name: "Enum", arguments: ["FLVTag.Type"]}}, {});
    /**
     *  A packet processor shifts pts
     *  
     */
    constructor.ShiftPtsProcessor = function(shiftTo, shiftBy, expectWrapAround) {
        this.savedTags = new LinkedList();
        this.shiftTo = shiftTo;
        this.shiftBy = shiftBy;
        this.expectWrapAround = true;
    };
    constructor.ShiftPtsProcessor = stjs.extend(constructor.ShiftPtsProcessor, null, [FLVTool.PacketProcessor], function(constructor, prototype) {
        constructor.WRAP_AROUND_VALUE = 2147483648;
        constructor.HALF_WRAP_AROUND_VALUE = 1073741824;
        constructor.Factory = function() {};
        constructor.Factory = stjs.extend(constructor.Factory, null, [FLVTool.PacketProcessorFactory], function(constructor, prototype) {
            prototype.newPacketProcessor = function(flags) {
                return new FLVTool.ShiftPtsProcessor(flags.getIntegerFlagD("to", 0), flags.getIntegerFlag("by"), flags.getBooleanFlagD("wrap-around", false));
            };
            prototype.getFlags = function() {
                var map = new HashMap();
                map.put("to", "Shift first pts to this value, and all subsequent pts accordingly.");
                map.put("by", "Shift all pts by this value.");
                map.put("wrap-around", "Expect wrap around of timestamps.");
                return map;
            };
        }, {}, {});
        prototype.shiftTo = 0;
        prototype.shiftBy = null;
        prototype.ptsDelta = 0;
        prototype.firstPtsSeen = false;
        prototype.savedTags = null;
        prototype.expectWrapAround = false;
        prototype.prevPts = 0;
        prototype.processPacket = function(pkt, writer) {
            var avcPrivatePacket = pkt.getType() == FLVTag.Type.VIDEO && (pkt.getTagHeader()).getCodec() == Codec.H264 && (pkt.getTagHeader()).getAvcPacketType() == 0;
            var aacPrivatePacket = pkt.getType() == FLVTag.Type.AUDIO && (pkt.getTagHeader()).getCodec() == Codec.AAC && (pkt.getTagHeader()).getPacketType() == 0;
            var validPkt = pkt.getType() != FLVTag.Type.SCRIPT && !avcPrivatePacket && !aacPrivatePacket;
            if (this.expectWrapAround && validPkt && pkt.getPts() < this.prevPts && (stjs.trunc(this.prevPts) - pkt.getPts() > FLVTool.ShiftPtsProcessor.HALF_WRAP_AROUND_VALUE)) {
                jcodec.Logger.warn("Wrap around detected: " + this.prevPts + " -> " + pkt.getPts());
                if (pkt.getPts() < -FLVTool.ShiftPtsProcessor.HALF_WRAP_AROUND_VALUE) {
                    this.ptsDelta += (FLVTool.ShiftPtsProcessor.WRAP_AROUND_VALUE << 1);
                } else if (pkt.getPts() >= 0) {
                    this.ptsDelta += FLVTool.ShiftPtsProcessor.WRAP_AROUND_VALUE;
                }
            }
            if (validPkt) 
                this.prevPts = pkt.getPts();
            if (this.firstPtsSeen) {
                this.writePacket(pkt, writer);
            } else {
                if (!validPkt) {
                    this.savedTags.add(pkt);
                } else {
                    if (this.shiftBy != null) {
                        this.ptsDelta = this.shiftBy;
                        if (this.ptsDelta + pkt.getPts() < 0) 
                            this.ptsDelta = -pkt.getPts();
                    } else {
                        this.ptsDelta = this.shiftTo - pkt.getPts();
                    }
                    this.firstPtsSeen = true;
                    this.emptySavedTags(writer);
                    this.writePacket(pkt, writer);
                }
            }
            return true;
        };
        prototype.writePacket = function(pkt, writer) {
            var newPts = pkt.getPts() + this.ptsDelta;
            if (newPts < 0) {
                jcodec.Logger.warn("Preventing negative pts for tag @" + pkt.getPosition());
                if (this.shiftBy != null) 
                    newPts = 0;
                 else 
                    newPts = this.shiftTo;
            } else if (newPts >= FLVTool.ShiftPtsProcessor.WRAP_AROUND_VALUE) {
                jcodec.Logger.warn("PTS wrap around @" + pkt.getPosition());
                newPts -= FLVTool.ShiftPtsProcessor.WRAP_AROUND_VALUE;
                this.ptsDelta = newPts - pkt.getPts();
            }
            pkt.setPts(((newPts) | 0));
            writer.addPacket(pkt);
        };
        prototype.emptySavedTags = function(muxer) {
             while (this.savedTags.size() > 0){
                this.writePacket(this.savedTags.remove(0), muxer);
            }
        };
        prototype.finish = function(muxer) {
            this.emptySavedTags(muxer);
        };
        prototype.hasOutput = function() {
            return true;
        };
    }, {savedTags: {name: "List", arguments: ["FLVTag"]}}, {});
}, {processors: {name: "Map", arguments: [null, "FLVTool.PacketProcessorFactory"]}}, {});
(function() {
    FLVTool.processors.put("clip", new FLVTool.ClipPacketProcessor.Factory());
    FLVTool.processors.put("fix_pts", new FLVTool.FixPtsProcessor.Factory());
    FLVTool.processors.put("info", new FLVTool.InfoPacketProcessor.Factory());
    FLVTool.processors.put("shift_pts", new FLVTool.ShiftPtsProcessor.Factory());
})();
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var QTEdit = function(_arguments) {
    this.listeners = new ArrayList();
    this.factories = arguments;
};
QTEdit = stjs.extend(QTEdit, null, [], function(constructor, prototype) {
    prototype.factories = null;
    prototype.listeners = null;
    constructor.EditFactory = function() {};
    constructor.EditFactory = stjs.extend(constructor.EditFactory, null, [], function(constructor, prototype) {
        prototype.getName = function() {};
        prototype.parseArgs = function(args) {};
        prototype.getHelp = function() {};
    }, {}, {});
    constructor.BaseCommand = function() {};
    constructor.BaseCommand = stjs.extend(constructor.BaseCommand, null, [MP4Edit], function(constructor, prototype) {
        prototype.applyRefs = function(movie, refs) {
            this.apply(movie);
        };
        prototype.apply = function(movie) {};
    }, {}, {});
    prototype.addProgressListener = function(listener) {
        this.listeners.add(listener);
    };
    prototype.execute = function(args) {
        var aa = new LinkedList(Arrays.asList(args));
        var commands = new LinkedList();
         while (aa.size() > 0){
            var i;
            for (i = 0; i < this.factories.length; i++) {
                if (aa.get(0).equals(this.factories[i].getName())) {
                    aa.remove(0);
                    try {
                        commands.add(this.factories[i].parseArgs(aa));
                    }catch (e) {
                        System.err.println("ERROR: " + e.getMessage());
                        return;
                    }
                    break;
                }
            }
            if (i == this.factories.length) 
                break;
        }
        if (aa.size() == 0) {
            System.err.println("ERROR: A movie file should be specified");
            this.help();
        }
        if (commands.size() == 0) {
            System.err.println("ERROR: At least one command should be specified");
            this.help();
        }
        var input = new File(aa.remove(0));
        if (!input.exists()) {
            System.err.println("ERROR: Input file '" + input.getAbsolutePath() + "' doesn't exist");
            this.help();
        }
        new ReplaceMP4Editor().replace(input, new CompoundMP4Edit(commands));
    };
    prototype.help = function() {
        System.out.println("Quicktime movie editor");
        System.out.println("Syntax: qtedit <command1> <options> ... <commandN> <options> <movie>");
        System.out.println("Where options:");
        for (var commandFactory in this.factories) {
            System.out.println("\t" + commandFactory.getHelp());
        }
        System.exit(-1);
    };
}, {factories: "Array", listeners: {name: "List", arguments: ["Flattern.ProgressListener"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  MPEG 4 AVC ( H.264 ) Decoder
 *  
 *  Conforms to H.264 ( ISO/IEC 14496-10 ) specifications
 *  
 *  @author The JCodec project
 *  
 */
var H264Decoder = function() {
    VideoDecoder.call(this);
    this.pictureBuffer = new ArrayList();
    this.poc = new POCManager();
    this.threaded = Runtime.getRuntime().availableProcessors() > 1;
    if (this.threaded) {
        this.tp = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors(), new (stjs.extend(function H264Decoder$1() {}, null, [ThreadFactory], function(constructor, prototype) {
            prototype.newThread = function(r) {
                var t = Executors.defaultThreadFactory().newThread(r);
                t.setDaemon(true);
                return t;
            };
        }, {}, {}))());
    }
    this.reader = new FrameReader();
};
H264Decoder = stjs.extend(H264Decoder, VideoDecoder, [], function(constructor, prototype) {
    prototype.sRefs = null;
    prototype.lRefs = null;
    prototype.pictureBuffer = null;
    prototype.poc = null;
    prototype.reader = null;
    prototype.tp = null;
    prototype.threaded = false;
    /**
     *  Constructs this decoder from a portion of a stream that contains AnnexB
     *  delimited (00 00 00 01) SPS/PPS NAL units. SPS/PPS NAL units are 0x67 and
     *  0x68 respectfully.
     *  
     *  @param codecPrivate
     */
    constructor.createH264DecoderFromCodecPrivate = function(codecPrivate) {
        var d = new H264Decoder();
        for (var iterator$bb = H264Utils.splitFrame(ByteBuffer.wrap(codecPrivate)).iterator(); iterator$bb.hasNext(); ) {
            var bb = iterator$bb.next();
            var nu = NALUnit.read(bb);
            if (nu.type == NALUnitType.SPS) {
                d.reader.addSps(bb);
            } else if (nu.type == NALUnitType.PPS) {
                d.reader.addPps(bb);
            }
        }
        return d;
    };
    prototype.decodeFrame8Bit = function(data, buffer) {
        return this.decodeFrame8BitFromNals(H264Utils.splitFrame(data), buffer);
    };
    prototype.decodeFrame8BitFromNals = function(nalUnits, buffer) {
        return new H264Decoder.FrameDecoder(this).decodeFrame(nalUnits, buffer);
    };
    prototype.decodeFrameFromNals = function(nalUnits, buffer) {
        var frame = new H264Decoder.FrameDecoder(this).decodeFrame(nalUnits, this.getSameSizeBuffer(buffer));
        return frame == null ? null : frame.toPictureWithBuffer(8, buffer);
    };
    constructor.SliceDecoderRunnable = function(fdec, sliceReader, result) {
        this.fdec = fdec;
        this.sliceReader = sliceReader;
        this.result = result;
    };
    constructor.SliceDecoderRunnable = stjs.extend(constructor.SliceDecoderRunnable, null, [Runnable], function(constructor, prototype) {
        prototype.sliceReader = null;
        prototype.result = null;
        prototype.fdec = null;
        prototype.run = function() {
            new SliceDecoder(this.fdec.activeSps, this.fdec.dec.sRefs, this.fdec.dec.lRefs, this.fdec.di, this.result).decodeFromReader(this.sliceReader);
        };
    }, {sliceReader: "SliceReader", result: "Frame", fdec: "H264Decoder.FrameDecoder"}, {});
    constructor.FrameDecoder = function(decoder) {
        this.dec = decoder;
    };
    constructor.FrameDecoder = stjs.extend(constructor.FrameDecoder, null, [], function(constructor, prototype) {
        prototype.activeSps = null;
        prototype.filter = null;
        prototype.firstSliceHeader = null;
        prototype.firstNu = null;
        prototype.dec = null;
        prototype.di = null;
        prototype.decodeFrame = function(nalUnits, buffer) {
            var sliceReaders = this.dec.reader.readFrame(nalUnits);
            if (sliceReaders == null || sliceReaders.size() == 0) 
                return null;
            var result = this.init(sliceReaders.get(0), buffer);
            if (this.dec.threaded && sliceReaders.size() > 1) {
                var futures = new ArrayList();
                for (var iterator$sliceReader = sliceReaders.iterator(); iterator$sliceReader.hasNext(); ) {
                    var sliceReader = iterator$sliceReader.next();
                    futures.add(this.dec.tp.submit(new H264Decoder.SliceDecoderRunnable(this, sliceReader, result)));
                }
                for (var iterator$future = futures.iterator(); iterator$future.hasNext(); ) {
                    var future = iterator$future.next();
                    this.waitForSure(future);
                }
            } else {
                for (var iterator$sliceReader = sliceReaders.iterator(); iterator$sliceReader.hasNext(); ) {
                    var sliceReader = iterator$sliceReader.next();
                    new SliceDecoder(this.activeSps, this.dec.sRefs, this.dec.lRefs, this.di, result).decodeFromReader(sliceReader);
                }
            }
            this.filter.deblockFrame(result);
            this.updateReferences(result);
            return result;
        };
        prototype.waitForSure = function(future) {
             while (true){
                try {
                    future.get();
                    break;
                }catch (e) {
                     throw new RuntimeException(e);
                }
            }
        };
        prototype.updateReferences = function(picture) {
            if (this.firstNu.nal_ref_idc != 0) {
                if (this.firstNu.type == NALUnitType.IDR_SLICE) {
                    this.performIDRMarking(this.firstSliceHeader.refPicMarkingIDR, picture);
                } else {
                    this.performMarking(this.firstSliceHeader.refPicMarkingNonIDR, picture);
                }
            }
        };
        prototype.init = function(sliceReader, buffer) {
            this.firstNu = sliceReader.getNALUnit();
            this.firstSliceHeader = sliceReader.getSliceHeader();
            this.activeSps = this.firstSliceHeader.sps;
            var picWidthInMbs = this.activeSps.pic_width_in_mbs_minus1 + 1;
            var picHeightInMbs = SeqParameterSet.getPicHeightInMbs(this.activeSps);
            if (this.dec.sRefs == null) {
                this.dec.sRefs = Array(1 << (this.firstSliceHeader.sps.log2_max_frame_num_minus4 + 4));
                this.dec.lRefs = new IntObjectMap();
            }
            this.di = new DeblockerInput(this.activeSps);
            var result = H264Decoder.createFrame(this.activeSps, buffer, this.firstSliceHeader.frame_num, this.firstSliceHeader.slice_type, this.di.mvs, this.di.refsUsed, this.dec.poc.calcPOC(this.firstSliceHeader, this.firstNu));
            this.filter = new DeblockingFilter(picWidthInMbs, this.activeSps.bit_depth_chroma_minus8 + 8, this.di);
            return result;
        };
        prototype.performIDRMarking = function(refPicMarkingIDR, picture) {
            this.clearAll();
            this.dec.pictureBuffer.clear();
            var saved = this.saveRef(picture);
            if (refPicMarkingIDR.isUseForlongTerm()) {
                this.dec.lRefs.put(0, saved);
                saved.setShortTerm(false);
            } else 
                this.dec.sRefs[this.firstSliceHeader.frame_num] = saved;
        };
        prototype.saveRef = function(decoded) {
            var frame = this.dec.pictureBuffer.size() > 0 ? this.dec.pictureBuffer.remove(0) : Frame.createFrame(decoded);
            frame.copyFromFrame(decoded);
            return frame;
        };
        prototype.releaseRef = function(picture) {
            if (picture != null) {
                this.dec.pictureBuffer.add(picture);
            }
        };
        prototype.clearAll = function() {
            for (var i = 0; i < this.dec.sRefs.length; i++) {
                this.releaseRef(this.dec.sRefs[i]);
                this.dec.sRefs[i] = null;
            }
            var keys = this.dec.lRefs.keys();
            for (var i = 0; i < keys.length; i++) {
                this.releaseRef(this.dec.lRefs.get(keys[i]));
            }
            this.dec.lRefs.clear();
        };
        prototype.performMarking = function(refPicMarking, picture) {
            var saved = this.saveRef(picture);
            if (refPicMarking != null) {
                var instructions = refPicMarking.getInstructions();
                for (var i = 0; i < instructions.length; i++) {
                    var instr = instructions[i];
                    switch (instr.getType()) {
                        case RefPicMarking.InstrType.REMOVE_SHORT:
                            this.unrefShortTerm(instr.getArg1());
                            break;
                        case RefPicMarking.InstrType.REMOVE_LONG:
                            this.unrefLongTerm(instr.getArg1());
                            break;
                        case RefPicMarking.InstrType.CONVERT_INTO_LONG:
                            this.convert(instr.getArg1(), instr.getArg2());
                            break;
                        case RefPicMarking.InstrType.TRUNK_LONG:
                            this.truncateLongTerm(instr.getArg1() - 1);
                            break;
                        case RefPicMarking.InstrType.CLEAR:
                            this.clearAll();
                            break;
                        case RefPicMarking.InstrType.MARK_LONG:
                            this.saveLong(saved, instr.getArg1());
                            saved = null;
                    }
                }
            }
            if (saved != null) 
                this.saveShort(saved);
            var maxFrames = 1 << (this.activeSps.log2_max_frame_num_minus4 + 4);
            if (refPicMarking == null) {
                var maxShort = Math.max(1, this.activeSps.num_ref_frames - this.dec.lRefs.size());
                var min = Integer.MAX_VALUE, num = 0, minFn = 0;
                for (var i = 0; i < this.dec.sRefs.length; i++) {
                    if (this.dec.sRefs[i] != null) {
                        var fnWrap = this.unwrap(this.firstSliceHeader.frame_num, this.dec.sRefs[i].getFrameNo(), maxFrames);
                        if (fnWrap < min) {
                            min = fnWrap;
                            minFn = this.dec.sRefs[i].getFrameNo();
                        }
                        num++;
                    }
                }
                if (num > maxShort) {
                    this.releaseRef(this.dec.sRefs[minFn]);
                    this.dec.sRefs[minFn] = null;
                }
            }
        };
        prototype.unwrap = function(thisFrameNo, refFrameNo, maxFrames) {
            return refFrameNo > thisFrameNo ? refFrameNo - maxFrames : refFrameNo;
        };
        prototype.saveShort = function(saved) {
            this.dec.sRefs[this.firstSliceHeader.frame_num] = saved;
        };
        prototype.saveLong = function(saved, longNo) {
            var prev = this.dec.lRefs.get(longNo);
            if (prev != null) 
                this.releaseRef(prev);
            saved.setShortTerm(false);
            this.dec.lRefs.put(longNo, saved);
        };
        prototype.truncateLongTerm = function(maxLongNo) {
            var keys = this.dec.lRefs.keys();
            for (var i = 0; i < keys.length; i++) {
                if (keys[i] > maxLongNo) {
                    this.releaseRef(this.dec.lRefs.get(keys[i]));
                    this.dec.lRefs.remove(keys[i]);
                }
            }
        };
        prototype.convert = function(shortNo, longNo) {
            var ind = MathUtil.wrap(this.firstSliceHeader.frame_num - shortNo, 1 << (this.firstSliceHeader.sps.log2_max_frame_num_minus4 + 4));
            this.releaseRef(this.dec.lRefs.get(longNo));
            this.dec.lRefs.put(longNo, this.dec.sRefs[ind]);
            this.dec.sRefs[ind] = null;
            this.dec.lRefs.get(longNo).setShortTerm(false);
        };
        prototype.unrefLongTerm = function(longNo) {
            this.releaseRef(this.dec.lRefs.get(longNo));
            this.dec.lRefs.remove(longNo);
        };
        prototype.unrefShortTerm = function(shortNo) {
            var ind = MathUtil.wrap(this.firstSliceHeader.frame_num - shortNo, 1 << (this.firstSliceHeader.sps.log2_max_frame_num_minus4 + 4));
            this.releaseRef(this.dec.sRefs[ind]);
            this.dec.sRefs[ind] = null;
        };
    }, {activeSps: "SeqParameterSet", filter: "DeblockingFilter", firstSliceHeader: "SliceHeader", firstNu: "NALUnit", dec: "H264Decoder", di: "DeblockerInput"}, {});
    constructor.createFrame = function(sps, buffer, frameNum, frameType, mvs, refsUsed, POC) {
        var width = sps.pic_width_in_mbs_minus1 + 1 << 4;
        var height = SeqParameterSet.getPicHeightInMbs(sps) << 4;
        var crop = null;
        if (sps.frame_cropping_flag) {
            var sX = sps.frame_crop_left_offset << 1;
            var sY = sps.frame_crop_top_offset << 1;
            var w = width - (sps.frame_crop_right_offset << 1) - sX;
            var h = height - (sps.frame_crop_bottom_offset << 1) - sY;
            crop = new Rect(sX, sY, w, h);
        }
        return new Frame(width, height, buffer, ColorSpace.YUV420J, crop, frameNum, frameType, mvs, refsUsed, POC);
    };
    prototype.addSps = function(spsList) {
        this.reader.addSpsList(spsList);
    };
    prototype.addPps = function(ppsList) {
        this.reader.addPpsList(ppsList);
    };
    prototype.probe = function(data) {
        var validSps = false, validPps = false, validSh = false;
        for (var iterator$nalUnit = H264Utils.splitFrame(data.duplicate()).iterator(); iterator$nalUnit.hasNext(); ) {
            var nalUnit = iterator$nalUnit.next();
            var marker = NALUnit.read(nalUnit);
            if (marker.type == NALUnitType.IDR_SLICE || marker.type == NALUnitType.NON_IDR_SLICE) {
                var reader = BitReader.createBitReader(nalUnit);
                validSh = this.validSh(new SliceHeaderReader().readPart1(reader));
                break;
            } else if (marker.type == NALUnitType.SPS) {
                validSps = this.validSps(SeqParameterSet.read(nalUnit));
            } else if (marker.type == NALUnitType.PPS) {
                validPps = this.validPps(PictureParameterSet.read(nalUnit));
            }
        }
        return (validSh ? 60 : 0) + (validSps ? 20 : 0) + (validPps ? 20 : 0);
    };
    prototype.validSh = function(sh) {
        return sh.first_mb_in_slice == 0 && sh.slice_type != null && sh.pic_parameter_set_id < 2;
    };
    prototype.validSps = function(sps) {
        return sps.bit_depth_chroma_minus8 < 4 && sps.bit_depth_luma_minus8 < 4 && sps.chroma_format_idc != null && sps.seq_parameter_set_id < 2 && sps.pic_order_cnt_type <= 2;
    };
    prototype.validPps = function(pps) {
        return pps.pic_init_qp_minus26 <= 26 && pps.seq_parameter_set_id <= 2 && pps.pic_parameter_set_id <= 2;
    };
}, {sRefs: "Array", lRefs: {name: "IntObjectMap", arguments: ["Frame"]}, pictureBuffer: {name: "List", arguments: ["Frame"]}, poc: "POCManager", reader: "FrameReader", tp: "ExecutorService", byteBuffer: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  ISO BMF ( MP4 ) specific muxing
 *  
 *  @author The JCodec project
 *  
 */
var VirtualMP4Movie = function(_arguments) {
    VirtualMovie.call(this, arguments);
    this.brand = Brand.MP4;
    this.muxTracks();
};
VirtualMP4Movie = stjs.extend(VirtualMP4Movie, VirtualMovie, [], function(constructor, prototype) {
    prototype.brand = null;
    prototype.headerChunk = function(ch, tracks, dataSize) {
        var chunks = ch.toArray(Array(0));
        var headerSize = MovieHelper.produceHeader(chunks, tracks, dataSize, this.brand).remaining();
        for (var chunk in chunks) {
            chunk.offset(headerSize);
        }
        var header = MovieHelper.produceHeader(chunks, tracks, dataSize, this.brand);
        return new (stjs.extend(function VirtualMP4Movie$1() {}, null, [MovieSegment], function(constructor, prototype) {
            prototype.getData = function() {
                return header.duplicate();
            };
            prototype.getNo = function() {
                return 0;
            };
            prototype.getPos = function() {
                return 0;
            };
            prototype.getDataLen = function() {
                return header.remaining();
            };
        }, {}, {}))();
    };
    prototype.packetChunk = function(track, pkt, chunkNo, trackNo, pos) {
        return new VirtualMP4Movie.PacketChunk(pkt, trackNo, chunkNo, pos, track.getCodecMeta().getFourcc());
    };
    constructor.PacketChunk = function(packet, track, no, pos, fourcc) {
        this.packet = packet;
        this.track = track;
        this.no = no;
        this.pos = pos;
        this.fourcc = fourcc;
    };
    constructor.PacketChunk = stjs.extend(constructor.PacketChunk, null, [MovieSegment], function(constructor, prototype) {
        prototype.packet = null;
        prototype.track = 0;
        prototype.no = 0;
        prototype.pos = 0;
        prototype.fourcc = null;
        prototype.getData = function() {
            var buf = this.packet.getData().duplicate();
            H264Utils.encodeMOVPacket(buf);
            return buf;
        };
        prototype.getNo = function() {
            return this.no;
        };
        prototype.getPos = function() {
            return this.pos;
        };
        prototype.offset = function(off) {
            this.pos += off;
        };
        prototype.getDataLen = function() {
            return this.packet.getDataLen();
        };
        prototype.getPacket = function() {
            return this.packet;
        };
        prototype.getTrackNo = function() {
            return this.track;
        };
    }, {packet: "VirtualPacket"}, {});
}, {brand: "Brand", chunks: "Array", _headerChunk: "MovieSegment", tracks: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Virtual movie track that transcodes the source video format to AVC on the
 *  fly.
 *  
 *  @author The JCodec project
 *  
 */
var Transcode2AVCTrack = function(src, frameDim) {
    this.transcoders = new ThreadLocal();
    this.checkFourCC(src);
    this.src = src;
    var rc = new H264FixedRateControl(Transcode2AVCTrack.TARGET_RATE);
    var encoder = new H264Encoder(rc);
    this.scaleFactor = this.selectScaleFactor(frameDim);
    this.thumbWidth = frameDim.getWidth() >> this.scaleFactor;
    this.thumbHeight = (frameDim.getHeight() >> this.scaleFactor) & ~1;
    this.mbW = (this.thumbWidth + 15) >> 4;
    this.mbH = (this.thumbHeight + 15) >> 4;
    this.se = Transcode2AVCTrack.createCodecMeta(src, encoder, this.thumbWidth, this.thumbHeight);
    this.frameSize = rc.calcFrameSize(this.mbW * this.mbH);
    this.frameSize += this.frameSize >> 4;
};
Transcode2AVCTrack = stjs.extend(Transcode2AVCTrack, null, [VirtualTrack], function(constructor, prototype) {
    constructor.TARGET_RATE = 1024;
    prototype.frameSize = 0;
    prototype.src = null;
    prototype.se = null;
    prototype.transcoders = null;
    prototype.mbW = 0;
    prototype.mbH = 0;
    prototype.scaleFactor = 0;
    prototype.thumbWidth = 0;
    prototype.thumbHeight = 0;
    prototype.selectScaleFactor = function(frameDim) {};
    prototype.getDecoder = function(scaleFactor) {};
    prototype.checkFourCC = function(proresTrack) {};
    constructor.createCodecMeta = function(src, encoder, thumbWidth, thumbHeight) {
        var codecMeta = src.getCodecMeta();
        var createAvcC = H264Utils.createAvcC(encoder.initSPS(new Size(thumbWidth, thumbHeight)), encoder.initPPS(), 4);
        return VideoCodecMeta.createVideoCodecMeta("avc1", H264Utils.getAvcCData(createAvcC), new Size(thumbWidth, thumbHeight), codecMeta.getPasp());
    };
    prototype.getCodecMeta = function() {
        return this.se;
    };
    prototype.nextPacket = function() {
        var nextPacket = this.src.nextPacket();
        if (nextPacket == null) 
            return null;
        return new Transcode2AVCTrack.TranscodePacket(this, nextPacket);
    };
    constructor.TranscodePacket = function(track, nextPacket) {
        VirtualPacketWrapper.call(this, nextPacket);
        this.track = track;
    };
    constructor.TranscodePacket = stjs.extend(constructor.TranscodePacket, VirtualPacketWrapper, [], function(constructor, prototype) {
        prototype.track = null;
        prototype.getDataLen = function() {
            return this.track.frameSize;
        };
        prototype.getData = function() {
            var t = this.track.transcoders.get();
            if (t == null) {
                t = new Transcode2AVCTrack.Transcoder(this.track);
                this.track.transcoders.set(t);
            }
            var buf = ByteBuffer.allocate(this.track.frameSize);
            var data = this.src.getData();
            return t.transcodeFrame(data, buf);
        };
    }, {track: "Transcode2AVCTrack", src: "VirtualPacket", byPts: {name: "Comparator", arguments: ["Object"]}}, {});
    constructor.Transcoder = function(track) {
        this.track = track;
        this.rc = new H264FixedRateControl(Transcode2AVCTrack.TARGET_RATE);
        this.decoder = track.getDecoder(track.scaleFactor);
        this.encoder = new H264Encoder(this.rc);
        this.pic0 = Picture8Bit.create(track.mbW << 4, (track.mbH + 1) << 4, ColorSpace.YUV444);
    };
    constructor.Transcoder = stjs.extend(constructor.Transcoder, null, [], function(constructor, prototype) {
        prototype.decoder = null;
        prototype.encoder = null;
        prototype.pic0 = null;
        prototype.pic1 = null;
        prototype.transform = null;
        prototype.rc = null;
        prototype.track = null;
        prototype.transcodeFrame = function(src, dst) {
            if (src == null) 
                return null;
            var decoded = this.decoder.decodeFrame8Bit(src, this.pic0.getData());
            if (this.pic1 == null) {
                this.pic1 = Picture8Bit.create(decoded.getWidth(), decoded.getHeight(), this.encoder.getSupportedColorSpaces()[0]);
                this.transform = ColorUtil.getTransform8Bit(decoded.getColor(), this.encoder.getSupportedColorSpaces()[0]);
            }
            this.transform.transform(decoded, this.pic1);
            this.pic1.setCrop(new Rect(0, 0, this.track.thumbWidth, this.track.thumbHeight));
            var rate = Transcode2AVCTrack.TARGET_RATE;
            do {
                try {
                    this.encoder.encodeFrame8Bit(this.pic1, dst);
                    break;
                }catch (ex) {
                    jcodec.Logger.warn("Abandon frame, buffer too small: " + dst.capacity());
                    rate -= 10;
                    this.rc.setRate(rate);
                }
            } while (rate > 10);
            this.rc.setRate(Transcode2AVCTrack.TARGET_RATE);
            H264Utils.encodeMOVPacket(dst);
            return dst;
        };
    }, {decoder: "VideoDecoder", encoder: "H264Encoder", pic0: "Picture8Bit", pic1: "Picture8Bit", transform: "Transform8Bit", rc: "H264FixedRateControl", track: "Transcode2AVCTrack"}, {});
    prototype.close = function() {
        this.src.close();
    };
    prototype.getEdits = function() {
        return this.src.getEdits();
    };
    prototype.getPreferredTimescale = function() {
        return this.src.getPreferredTimescale();
    };
}, {src: "VirtualTrack", se: "CodecMeta", transcoders: {name: "ThreadLocal", arguments: ["Transcode2AVCTrack.Transcoder"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var SequenceEncoder8Bit = function(ch) {
    this.ch = ch;
    this.muxer = MP4Muxer.createMP4Muxer(ch, Brand.MP4);
    this.outTrack = this.muxer.addTrack(TrackType.VIDEO, 25);
    this._out = ByteBuffer.allocate(1920 * 1080 * 6);
    this.encoder = H264Encoder.createH264Encoder();
    this.transform = ColorUtil.getTransform8Bit(ColorSpace.RGB, this.encoder.getSupportedColorSpaces()[0]);
    this.spsList = new ArrayList();
    this.ppsList = new ArrayList();
};
SequenceEncoder8Bit = stjs.extend(SequenceEncoder8Bit, null, [], function(constructor, prototype) {
    prototype.ch = null;
    prototype.toEncode = null;
    prototype.transform = null;
    prototype.encoder = null;
    prototype.spsList = null;
    prototype.ppsList = null;
    prototype.outTrack = null;
    prototype._out = null;
    prototype.frameNo = 0;
    prototype.muxer = null;
    prototype.sps = null;
    prototype.pps = null;
    constructor.createSequenceEncoder8Bit = function(out) {
        return new SequenceEncoder8Bit(NIOUtils.writableChannel(out));
    };
    prototype.encodeNativeFrame = function(pic) {
        if (this.toEncode == null) {
            this.toEncode = Picture8Bit.create(pic.getWidth(), pic.getHeight(), this.encoder.getSupportedColorSpaces()[0]);
        }
        this.transform.transform(pic, this.toEncode);
        this._out.clear();
        var result = this.encoder.encodeFrame8Bit(this.toEncode, this._out);
        this.spsList.clear();
        this.ppsList.clear();
        H264Utils.wipePSinplace(result, this.spsList, this.ppsList);
        var nu = NALUnit.read(NIOUtils.from(result.duplicate(), 4));
        H264Utils.encodeMOVPacket(result);
        if (this.sps == null && this.spsList.size() != 0) 
            this.sps = this.spsList.get(0);
        if (this.pps == null && this.ppsList.size() != 0) 
            this.pps = this.ppsList.get(0);
        this.outTrack.addFrame(MP4Packet.createMP4Packet(result, this.frameNo, 25, 1, this.frameNo, nu.type == NALUnitType.IDR_SLICE, null, 0, this.frameNo, 0));
        this.frameNo++;
    };
    prototype.getEncoder = function() {
        return this.encoder;
    };
    prototype.finish = function() {
        if (this.sps == null || this.pps == null) 
             throw new RuntimeException("Somehow the encoder didn't generate SPS/PPS pair, did you encode at least one frame?");
        this.outTrack.addSampleEntry(H264Utils.createMOVSampleEntryFromBuffer(this.sps, this.pps, 4));
        this.muxer.writeHeader();
        NIOUtils.closeQuietly(this.ch);
    };
}, {ch: "SeekableByteChannel", toEncode: "Picture8Bit", transform: "Transform8Bit", encoder: "H264Encoder", spsList: {name: "ArrayList", arguments: ["ByteBuffer"]}, ppsList: {name: "ArrayList", arguments: ["ByteBuffer"]}, outTrack: "FramesMP4MuxerTrack", _out: "ByteBuffer", muxer: "MP4Muxer", sps: "ByteBuffer", pps: "ByteBuffer"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  An MPEG thumbnail to AVC transcoder implemented fully in java ( using jcodec
 *  codecs ).
 *  
 *  @author The JCodec project
 *  
 */
var MPEGToAVCTranscoder = function(scaleFactor) {
    this.scaleFactor = scaleFactor;
    this.rc = new H264FixedRateControl(MPEGToAVCTranscoder.TARGET_RATE);
    this.decoder = this.getDecoder(scaleFactor);
    this.encoder = new H264Encoder(this.rc);
};
MPEGToAVCTranscoder = stjs.extend(MPEGToAVCTranscoder, null, [], function(constructor, prototype) {
    constructor.TARGET_RATE = 1024;
    prototype.decoder = null;
    prototype.encoder = null;
    prototype.pic0 = null;
    prototype.pic1 = null;
    prototype.transform = null;
    prototype.rc = null;
    prototype.scaleFactor = 0;
    prototype.thumbWidth = 0;
    prototype.thumbHeight = 0;
    prototype.getDecoder = function(scaleFactor) {
        switch (scaleFactor) {
            case 2:
                return new Mpeg2Thumb2x2();
            case 1:
                return new Mpeg2Thumb4x4();
            case 0:
                return new MPEGDecoder();
            default:
                 throw new IllegalArgumentException("Unsupported scale factor: " + scaleFactor);
        }
    };
    prototype.transcodeFrame = function(src, dst, iframe, poc) {
        if (src == null) 
            return null;
        if (this.pic0 == null) {
            var size = MPEGDecoder.getSize(src.duplicate());
            this.thumbWidth = size.getWidth() >> this.scaleFactor;
            this.thumbHeight = size.getHeight() >> this.scaleFactor;
            var mbW = (this.thumbWidth + 8) >> 4;
            var mbH = (this.thumbHeight + 8) >> 4;
            this.pic0 = Picture8Bit.create(mbW << 4, (mbH + 1) << 4, ColorSpace.YUV444);
        }
        var decoded = this.decoder.decodeFrame8Bit(src, this.pic0.getData());
        if (this.pic1 == null) {
            this.pic1 = Picture8Bit.create(decoded.getWidth(), decoded.getHeight(), this.encoder.getSupportedColorSpaces()[0]);
            this.transform = ColorUtil.getTransform8Bit(decoded.getColor(), this.encoder.getSupportedColorSpaces()[0]);
        }
        var toEnc;
        if (this.transform != null) {
            this.transform.transform(decoded, this.pic1);
            toEnc = this.pic1;
        } else {
            toEnc = decoded;
        }
        this.pic1.setCrop(new Rect(0, 0, this.thumbWidth, this.thumbHeight));
        var rate = MPEGToAVCTranscoder.TARGET_RATE;
        do {
            try {
                this.encoder.doEncodeFrame8Bit(toEnc, dst, iframe, poc, SliceType.I);
                break;
            }catch (ex) {
                jcodec.Logger.warn("Abandon frame, buffer too small: " + dst.capacity());
                rate -= 10;
                this.rc.setRate(rate);
            }
        } while (rate > 10);
        this.rc.setRate(MPEGToAVCTranscoder.TARGET_RATE);
        H264Utils.encodeMOVPacket(dst);
        return dst;
    };
    constructor.createTranscoder = function(scaleFactor) {
        return new MPEGToAVCTranscoder(scaleFactor);
    };
}, {decoder: "VideoDecoder", encoder: "H264Encoder", pic0: "Picture8Bit", pic1: "Picture8Bit", transform: "Transform8Bit", rc: "H264FixedRateControl"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var SequenceEncoder = function(ch) {
    this.ch = ch;
    this.muxer = MP4Muxer.createMP4Muxer(ch, Brand.MP4);
    this.outTrack = this.muxer.addTrack(TrackType.VIDEO, 25);
    this._out = ByteBuffer.allocate(1920 * 1080 * 6);
    this.encoder = H264Encoder.createH264Encoder();
    this.transform = ColorUtil.getTransform(ColorSpace.RGB, this.encoder.getSupportedColorSpaces()[0]);
    this.spsList = new ArrayList();
    this.ppsList = new ArrayList();
};
SequenceEncoder = stjs.extend(SequenceEncoder, null, [], function(constructor, prototype) {
    prototype.ch = null;
    prototype.toEncode = null;
    prototype.transform = null;
    prototype.encoder = null;
    prototype.spsList = null;
    prototype.ppsList = null;
    prototype.outTrack = null;
    prototype._out = null;
    prototype.frameNo = 0;
    prototype.muxer = null;
    prototype.sps = null;
    prototype.pps = null;
    constructor.createSequenceEncoder = function(out) {
        return new SequenceEncoder(NIOUtils.writableChannel(out));
    };
    prototype.encodeNativeFrame = function(pic) {
        if (this.toEncode == null) {
            this.toEncode = Picture.create(pic.getWidth(), pic.getHeight(), this.encoder.getSupportedColorSpaces()[0]);
        }
        this.transform.transform(pic, this.toEncode);
        this._out.clear();
        var result = this.encoder.encodeFrame(this.toEncode, this._out);
        this.spsList.clear();
        this.ppsList.clear();
        H264Utils.wipePSinplace(result, this.spsList, this.ppsList);
        var nu = NALUnit.read(NIOUtils.from(result.duplicate(), 4));
        H264Utils.encodeMOVPacket(result);
        if (this.sps == null && this.spsList.size() != 0) 
            this.sps = this.spsList.get(0);
        if (this.pps == null && this.ppsList.size() != 0) 
            this.pps = this.ppsList.get(0);
        this.outTrack.addFrame(MP4Packet.createMP4Packet(result, this.frameNo, 25, 1, this.frameNo, nu.type == NALUnitType.IDR_SLICE, null, 0, this.frameNo, 0));
        this.frameNo++;
    };
    prototype.getEncoder = function() {
        return this.encoder;
    };
    prototype.finish = function() {
        if (this.sps == null || this.pps == null) 
             throw new RuntimeException("Somehow the encoder didn't generate SPS/PPS pair, did you encode at least one frame?");
        this.outTrack.addSampleEntry(H264Utils.createMOVSampleEntryFromBuffer(this.sps, this.pps, 4));
        this.muxer.writeHeader();
        NIOUtils.closeQuietly(this.ch);
    };
}, {ch: "SeekableByteChannel", toEncode: "Picture", transform: "Transform", encoder: "H264Encoder", spsList: {name: "ArrayList", arguments: ["ByteBuffer"]}, ppsList: {name: "ArrayList", arguments: ["ByteBuffer"]}, outTrack: "FramesMP4MuxerTrack", _out: "ByteBuffer", muxer: "MP4Muxer", sps: "ByteBuffer", pps: "ByteBuffer"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Specialized demuxer track for PCM audio samples
 *  
 *  Always reads one chunk of frames at a time, except for after seek. After seek
 *  the beginning of chunk before the seek point is not read effectivaly reading
 *  PCM frame from exactly the frame seek was performed to.
 *  
 *  Packet size depends on underlying container PCM chunk sizes.
 *  
 *  @author The JCodec project
 *  
 */
var PCMMP4DemuxerTrack = function(movie, trak, input) {
    AbstractMP4DemuxerTrack.call(this, trak);
    this.movie = movie;
    this.input = input;
    var stsz = NodeBox.findFirstPath(trak, SampleSizesBox, Box.path("mdia.minf.stbl.stsz"));
    this.defaultSampleSize = stsz.getDefaultSize();
    var chunks = 0;
    for (var i = 1; i < this.sampleToChunks.length; i++) {
        var ch = (((this.sampleToChunks[i].getFirst() - this.sampleToChunks[i - 1].getFirst())) | 0);
        this.totalFrames += ch * this.sampleToChunks[i - 1].getCount();
        chunks += ch;
    }
    this.totalFrames += this.sampleToChunks[this.sampleToChunks.length - 1].getCount() * (this.chunkOffsets.length - chunks);
};
PCMMP4DemuxerTrack = stjs.extend(PCMMP4DemuxerTrack, AbstractMP4DemuxerTrack, [], function(constructor, prototype) {
    prototype.defaultSampleSize = 0;
    prototype.posShift = 0;
    prototype.totalFrames = 0;
    prototype.input = null;
    prototype.movie = null;
    prototype.nextFrame = function() {
        var frameSize = this.getFrameSize();
        var chSize = this.sampleToChunks[this.stscInd].getCount() * frameSize - this.posShift;
        return this.getNextFrame(ByteBuffer.allocate(chSize));
    };
    prototype.getNextFrame = function(buffer) {
        if (this.stcoInd >= this.chunkOffsets.length) 
            return null;
        var frameSize = this.getFrameSize();
        var se = this.sampleToChunks[this.stscInd].getEntry();
        var chSize = this.sampleToChunks[this.stscInd].getCount() * frameSize;
        var pktOff = this.chunkOffsets[this.stcoInd] + this.posShift;
        var pktSize = chSize - this.posShift;
        var result = this.readPacketData(this.input, buffer, pktOff, pktSize);
        var ptsRem = this.pts;
        var doneFrames = stjs.trunc(pktSize / frameSize);
        this.shiftPts(doneFrames);
        var pkt = new MP4Packet(result, QTTimeUtil.mediaToEdited(this.box, ptsRem, this.movie.getTimescale()), this.timescale, (((this.pts - ptsRem)) | 0), this.curFrame, true, null, 0, ptsRem, se - 1, pktOff, pktSize, true);
        this.curFrame += doneFrames;
        this.posShift = 0;
        ++this.stcoInd;
        if (this.stscInd < this.sampleToChunks.length - 1 && (this.stcoInd + 1) == this.sampleToChunks[this.stscInd + 1].getFirst()) 
            this.stscInd++;
        return pkt;
    };
    prototype.gotoSyncFrame = function(frameNo) {
        return this.gotoFrame(frameNo);
    };
    prototype.getFrameSize = function() {
        var entry = this.sampleEntries[this.sampleToChunks[this.stscInd].getEntry() - 1];
        if (stjs.isInstanceOf(entry.constructor, AudioSampleEntry)) {
            return (entry).calcFrameSize();
        } else {
            return this.defaultSampleSize;
        }
    };
    prototype.seekPointer = function(frameNo) {
        for (this.stcoInd = 0 , this.stscInd = 0 , this.curFrame = 0; ; ) {
            var nextFrame = this.curFrame + this.sampleToChunks[this.stscInd].getCount();
            if (nextFrame > frameNo) 
                break;
            this.curFrame = nextFrame;
            this.nextChunk();
        }
        this.posShift = ((((frameNo - this.curFrame) * this.getFrameSize())) | 0);
        this.curFrame = frameNo;
    };
    prototype.getFrameCount = function() {
        return this.totalFrames;
    };
    prototype.getMeta = function() {
        return new DemuxerTrackMeta(DemuxerTrackMeta.Type.AUDIO, this.getCodec(), null, this.totalFrames, this.duration / this.timescale, null, this.getCodecPrivate());
    };
}, {input: "SeekableByteChannel", movie: "MovieBox", box: "TrakBox", type: "TrackType", sampleEntries: "Array", timeToSamples: "Array", sampleToChunks: "Array", chunkOffsets: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Regular MP4 track containing frames
 *  
 *  @author The JCodec project
 *  
 */
var FramesMP4DemuxerTrack = function(mov, trak, input) {
    AbstractMP4DemuxerTrack.call(this, trak);
    this.input = input;
    this.movie = mov;
    var stsz = NodeBox.findFirstPath(trak, SampleSizesBox, Box.path("mdia.minf.stbl.stsz"));
    var stss = NodeBox.findFirstPath(trak, SyncSamplesBox, Box.path("mdia.minf.stbl.stss"));
    var stps = NodeBox.findFirstPath(trak, SyncSamplesBox, Box.path("mdia.minf.stbl.stps"));
    var ctts = NodeBox.findFirstPath(trak, CompositionOffsetsBox, Box.path("mdia.minf.stbl.ctts"));
    this.compOffsets = ctts == null ? null : ctts.getEntries();
    if (stss != null) {
        this.syncSamples = stss.getSyncSamples();
    }
    if (stps != null) {
        this.partialSync = stps.getSyncSamples();
    }
    this.sizes = stsz.getSizes();
    if (this.getCodec() == Codec.H264) {
        this.avcC = H264Utils.parseAVCC(this.getSampleEntries()[0]);
    }
};
FramesMP4DemuxerTrack = stjs.extend(FramesMP4DemuxerTrack, AbstractMP4DemuxerTrack, [], function(constructor, prototype) {
    prototype.sizes = null;
    prototype.offInChunk = 0;
    prototype.noInChunk = 0;
    prototype.syncSamples = null;
    prototype.partialSync = null;
    prototype.ssOff = 0;
    prototype.psOff = 0;
    prototype.compOffsets = null;
    prototype.cttsInd = 0;
    prototype.cttsSubInd = 0;
    prototype.input = null;
    prototype.movie = null;
    prototype.avcC = null;
    prototype.nextFrame = function() {
        if (this.curFrame >= this.sizes.length) 
            return null;
        var size = this.sizes[((this.curFrame) | 0)];
        return this.getNextFrame(ByteBuffer.allocate(size));
    };
    prototype.getNextFrame = function(storage) {
        if (this.curFrame >= this.sizes.length) 
            return null;
        var size = this.sizes[((this.curFrame) | 0)];
        if (storage != null && storage.remaining() < size) {
             throw new IllegalArgumentException("Buffer size is not enough to fit a packet");
        }
        var pktPos = this.chunkOffsets[Math.min(this.chunkOffsets.length - 1, this.stcoInd)] + this.offInChunk;
        var result = this.readPacketData(this.input, storage, pktPos, size);
        if (result != null && result.remaining() < size) 
            return null;
        var duration = this.timeToSamples[this.sttsInd].getSampleDuration();
        var sync = this.syncSamples == null;
        if (this.syncSamples != null && this.ssOff < this.syncSamples.length && (this.curFrame + 1) == this.syncSamples[this.ssOff]) {
            sync = true;
            this.ssOff++;
        }
        var psync = false;
        if (this.partialSync != null && this.psOff < this.partialSync.length && (this.curFrame + 1) == this.partialSync[this.psOff]) {
            psync = true;
            this.psOff++;
        }
        var realPts = this.pts;
        if (this.compOffsets != null) {
            realPts = this.pts + this.compOffsets[this.cttsInd].getOffset();
            this.cttsSubInd++;
            if (this.cttsInd < this.compOffsets.length - 1 && this.cttsSubInd == this.compOffsets[this.cttsInd].getCount()) {
                this.cttsInd++;
                this.cttsSubInd = 0;
            }
        }
        var pkt = new MP4Packet(result == null ? null : this.convertPacket(result), QTTimeUtil.mediaToEdited(this.box, realPts, this.movie.getTimescale()), this.timescale, duration, this.curFrame, sync, null, 0, realPts, this.sampleToChunks[this.stscInd].getEntry() - 1, pktPos, size, psync);
        this.offInChunk += size;
        this.curFrame++;
        this.noInChunk++;
        if (this.noInChunk >= this.sampleToChunks[this.stscInd].getCount()) {
            this.noInChunk = 0;
            this.offInChunk = 0;
            this.nextChunk();
        }
        this.shiftPts(1);
        return pkt;
    };
    prototype.convertPacket = function(result) {
        if (this.avcC != null) 
            return H264Utils.decodeMOVPacket(result, this.avcC);
        return result;
    };
    prototype.gotoSyncFrame = function(frameNo) {
        if (this.syncSamples == null) 
            return this.gotoFrame(frameNo);
         else {
            if (frameNo < 0) 
                 throw new IllegalArgumentException("negative frame number");
            if (frameNo >= this.getFrameCount()) 
                return false;
            if (frameNo == this.curFrame) 
                return true;
            for (var i = 0; i < this.syncSamples.length; i++) {
                if (this.syncSamples[i] - 1 > frameNo) 
                    return this.gotoFrame(this.syncSamples[i - 1] - 1);
            }
            return this.gotoFrame(this.syncSamples[this.syncSamples.length - 1] - 1);
        }
    };
    prototype.seekPointer = function(frameNo) {
        if (this.compOffsets != null) {
            this.cttsSubInd = ((frameNo) | 0);
            this.cttsInd = 0;
             while (this.cttsSubInd >= this.compOffsets[this.cttsInd].getCount()){
                this.cttsSubInd -= this.compOffsets[this.cttsInd].getCount();
                this.cttsInd++;
            }
        }
        this.curFrame = ((frameNo) | 0);
        this.stcoInd = 0;
        this.stscInd = 0;
        this.noInChunk = ((frameNo) | 0);
        this.offInChunk = 0;
         while (this.noInChunk >= this.sampleToChunks[this.stscInd].getCount()){
            this.noInChunk -= this.sampleToChunks[this.stscInd].getCount();
            this.nextChunk();
        }
        for (var i = 0; i < this.noInChunk; i++) {
            this.offInChunk += this.sizes[((frameNo) | 0) - this.noInChunk + i];
        }
        if (this.syncSamples != null) 
            for (this.ssOff = 0; this.ssOff < this.syncSamples.length && this.syncSamples[this.ssOff] < this.curFrame + 1; this.ssOff++) 
                ;
        if (this.partialSync != null) 
            for (this.psOff = 0; this.psOff < this.partialSync.length && this.partialSync[this.psOff] < this.curFrame + 1; this.psOff++) 
                ;
    };
    prototype.getFrameCount = function() {
        return this.sizes.length;
    };
    prototype.getMeta = function() {
        var seekFrames;
        if (this.syncSamples == null) {
            seekFrames = new Int32Array(((this.getFrameCount()) | 0));
            for (var i = 0; i < seekFrames.length; i++) {
                seekFrames[i] = i;
            }
        } else {
            seekFrames = Platform.copyOfInt(this.syncSamples, this.syncSamples.length);
            for (var i = 0; i < seekFrames.length; i++) 
                seekFrames[i]--;
        }
        var type = this.getType();
        var t = type == TrackType.VIDEO ? DemuxerTrackMeta.Type.VIDEO : (type == TrackType.SOUND ? DemuxerTrackMeta.Type.AUDIO : DemuxerTrackMeta.Type.OTHER);
        var meta = new DemuxerTrackMeta(t, this.getCodec(), seekFrames, this.sizes.length, this.duration / this.timescale, this.box.getCodedSize(), this.getCodecPrivate());
        if (type == TrackType.VIDEO) {
            var pasp = NodeBox.findFirst(this.getSampleEntries()[0], PixelAspectExt, "pasp");
            if (pasp != null) 
                meta.setPixelAspectRatio(pasp.getRational());
        }
        return meta;
    };
}, {sizes: "Int32Array", syncSamples: "Int32Array", partialSync: "Int32Array", compOffsets: "Array", input: "SeekableByteChannel", movie: "MovieBox", avcC: "AvcCBox", box: "TrakBox", type: "TrackType", sampleEntries: "Array", timeToSamples: "Array", sampleToChunks: "Array", chunkOffsets: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  High level frame grabber helper.
 *  
 *  @author The JCodec project
 *  
 */
var AVCMP4Adaptor = function(meta) {
    this.meta = meta;
    this.curENo = -1;
    this.calcBufferSize();
};
AVCMP4Adaptor = stjs.extend(AVCMP4Adaptor, null, [ContainerAdaptor], function(constructor, prototype) {
    prototype.decoder = null;
    prototype.curENo = 0;
    prototype.size = null;
    prototype.meta = null;
    prototype.calcBufferSize = function() {
        var w = Integer.MIN_VALUE, h = Integer.MIN_VALUE;
        var bb = ByteBuffer.wrap(this.meta.getCodecPrivate());
        var b;
         while ((b = H264Utils.nextNALUnit(bb)) != null){
            var nu = NALUnit.read(b);
            if (nu.type != NALUnitType.SPS) 
                continue;
            var sps = H264Utils.readSPS(b);
            var ww = sps.pic_width_in_mbs_minus1 + 1;
            if (ww > w) 
                w = ww;
            var hh = SeqParameterSet.getPicHeightInMbs(sps);
            if (hh > h) 
                h = hh;
        }
        this.size = new Size(w << 4, h << 4);
    };
    prototype.decodeFrame = function(packet, data) {
        this.updateState(packet);
        var pic = this.decoder.decodeFrameFromNals(H264Utils.splitFrame(packet.getData()), data);
        var pasp = this.meta.getPixelAspectRatio();
        if (pasp != null) {}
        return pic;
    };
    prototype.decodeFrame8Bit = function(packet, data) {
        this.updateState(packet);
        var pic = this.decoder.decodeFrame8Bit(packet.getData(), data);
        var pasp = this.meta.getPixelAspectRatio();
        if (pasp != null) {}
        return pic;
    };
    prototype.updateState = function(packet) {
        var eNo = (packet).getEntryNo();
        if (eNo != this.curENo) {
            this.curENo = eNo;
        }
        if (this.decoder == null) {
            this.decoder = H264Decoder.createH264DecoderFromCodecPrivate(this.meta.getCodecPrivate());
        }
    };
    prototype.canSeek = function(pkt) {
        this.updateState(pkt);
        return H264Utils.idrSlice(H264Utils.splitFrame(pkt.getData()));
    };
    prototype.allocatePicture = function() {
        return Picture.create(this.size.getWidth(), this.size.getHeight(), ColorSpace.YUV444).getData();
    };
    prototype.allocatePicture8Bit = function() {
        return Picture8Bit.create(this.size.getWidth(), this.size.getHeight(), ColorSpace.YUV444).getData();
    };
    prototype.getMediaInfo = function() {
        return new MediaInfo(this.size);
    };
}, {decoder: "H264Decoder", size: "Size", meta: "DemuxerTrackMeta"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Clips AVC track replacing the remainder of a GOP at cut point with I-frames
 *  
 *  @author The JCodec project
 *  
 */
var AVCClipTrack = function(src, frameFrom, frameTo) {
    ClipTrack.call(this, src, frameFrom, frameTo);
    var codecMeta = src.getCodecMeta();
    if (!"avc1".equals(codecMeta.getFourcc())) 
         throw new RuntimeException("Not an AVC source track");
    this.rc = new H264FixedRateControl(1024);
    var encoder = this.getEncoder();
    var codecPrivate = codecMeta.getCodecPrivate();
    this.codecPrivate = NIOUtils.toArray(codecPrivate);
    var rawSPS = H264Utils.getRawSPS(codecPrivate);
    var rawPPS = H264Utils.getRawPPS(codecPrivate);
    var sps = H264Utils.readSPS(rawSPS.get(0));
    this.mbW = sps.pic_width_in_mbs_minus1 + 1;
    this.mbH = SeqParameterSet.getPicHeightInMbs(sps);
    this.encSPS = encoder.initSPS(H264Utils.getPicSize(sps));
    this.encSPS.seq_parameter_set_id = 1;
    this.encPPS = encoder.initPPS();
    this.encPPS.seq_parameter_set_id = 1;
    this.encPPS.pic_parameter_set_id = 1;
    this.encSPS.profile_idc = sps.profile_idc;
    this.encSPS.level_idc = sps.level_idc;
    this.encSPS.frame_mbs_only_flag = sps.frame_mbs_only_flag;
    this.encSPS.frame_crop_bottom_offset = sps.frame_crop_bottom_offset;
    this.encSPS.frame_crop_left_offset = sps.frame_crop_left_offset;
    this.encSPS.frame_crop_right_offset = sps.frame_crop_right_offset;
    this.encSPS.frame_crop_top_offset = sps.frame_crop_top_offset;
    this.encSPS.vuiParams = sps.vuiParams;
    rawSPS.add(H264Utils.writeSPS(this.encSPS, 128));
    rawPPS.add(H264Utils.writePPS(this.encPPS, 20));
    this.se = VideoCodecMeta.createVideoCodecMeta("avc1", ByteBuffer.wrap(H264Utils.saveCodecPrivate(rawSPS, rawPPS)), codecMeta.getSize(), codecMeta.getPasp());
    var _frameSize = this.rc.calcFrameSize(this.mbW * this.mbH);
    _frameSize += _frameSize >> 4;
    this.frameSize = _frameSize;
};
AVCClipTrack = stjs.extend(AVCClipTrack, ClipTrack, [], function(constructor, prototype) {
    prototype.rc = null;
    prototype.mbW = 0;
    prototype.mbH = 0;
    prototype.se = null;
    prototype.frameSize = 0;
    prototype.encSPS = null;
    prototype.encPPS = null;
    prototype.codecPrivate = null;
    prototype.getEncoder = function() {
        var encoder = new H264Encoder(this.rc);
        encoder.setKeyInterval(1);
        return encoder;
    };
    prototype.getGop = function(src, from) {
        var packet = src.nextPacket();
        var head = new ArrayList();
         while (packet != null && packet.getFrameNo() < from){
            if (packet.isKeyframe()) 
                head.clear();
            head.add(packet);
            packet = src.nextPacket();
        }
        var tail = new ArrayList();
         while (packet != null && !packet.isKeyframe()){
            tail.add(packet);
            packet = src.nextPacket();
        }
        var gop = new ArrayList();
        var tr = new AVCClipTrack.GopTranscoder(this, head, tail, this.getEncoder());
        for (var i = 0; i < tail.size(); i++) 
            gop.add(new AVCClipTrack.TranscodePacket(tail.get(i), tr, i, this.frameSize));
        gop.add(packet);
        return gop;
    };
    constructor.GopTranscoder = function(track, head, tail, encoder) {
        this.track = track;
        this.head = head;
        this.tail = tail;
        this.encoder = encoder;
    };
    constructor.GopTranscoder = stjs.extend(constructor.GopTranscoder, null, [], function(constructor, prototype) {
        prototype.tail = null;
        prototype.head = null;
        prototype.result = null;
        prototype.track = null;
        prototype.encoder = null;
        prototype.transcode = function() {
            var decoder = H264Decoder.createH264DecoderFromCodecPrivate(this.track.codecPrivate);
            var buf = Picture8Bit.create(this.track.mbW << 4, this.track.mbH << 4, ColorSpace.YUV420J);
            var dec = null;
            for (var iterator$virtualPacket = this.head.iterator(); iterator$virtualPacket.hasNext(); ) {
                var virtualPacket = iterator$virtualPacket.next();
                dec = decoder.decodeFrame8Bit(virtualPacket.getData(), buf.getData());
            }
            var tmp = ByteBuffer.allocate(this.track.frameSize);
            var result = new ArrayList();
            for (var iterator$pkt = this.tail.iterator(); iterator$pkt.hasNext(); ) {
                var pkt = iterator$pkt.next();
                dec = decoder.decodeFrame8Bit(pkt.getData(), buf.getData());
                tmp.clear();
                var res = this.encoder.encodeFrame8Bit(dec, tmp);
                var out = ByteBuffer.allocate(this.track.frameSize);
                this.processFrame(res, out);
                result.add(out);
            }
            return result;
        };
        prototype.processFrame = function(_in, out) {
            var st = new (stjs.extend(function AVCClipTrack$GopTranscoder$1() {
                H264Utils.SliceHeaderTweaker.call(this);
            }, H264Utils.SliceHeaderTweaker, [], function(constructor, prototype) {
                prototype.tweak = function(sh) {
                    sh.pic_parameter_set_id = 1;
                };
            }, {sps: {name: "List", arguments: ["SeqParameterSet"]}, pps: {name: "List", arguments: ["PictureParameterSet"]}}, {}))();
            var dup = _in.duplicate();
             while (dup.hasRemaining()){
                var buf = H264Utils.nextNALUnit(dup);
                if (buf == null) 
                    break;
                var nu = NALUnit.read(buf);
                if (nu.type == NALUnitType.IDR_SLICE || nu.type == NALUnitType.NON_IDR_SLICE) {
                    out.putInt(1);
                    nu.write(out);
                    st.runSpsPps(buf, out, nu, this.track.encSPS, this.track.encPPS);
                }
            }
            if (out.remaining() >= 5) {
                out.putInt(1);
                new NALUnit(NALUnitType.FILLER_DATA, 0).write(out);
            }
            out.clear();
        };
        prototype.getResult = function() {
            if (this.result == null) 
                this.result = this.transcode();
            return this.result;
        };
    }, {tail: {name: "List", arguments: ["VirtualPacket"]}, head: {name: "List", arguments: ["VirtualPacket"]}, result: {name: "List", arguments: ["ByteBuffer"]}, track: "AVCClipTrack", encoder: "H264Encoder"}, {});
    prototype.getCodecMeta = function() {
        return this.se;
    };
    constructor.TranscodePacket = function(src, tr, off, frameSize) {
        VirtualPacketWrapper.call(this, src);
        this.tr = tr;
        this.off = off;
        this.frameSize = frameSize;
    };
    constructor.TranscodePacket = stjs.extend(constructor.TranscodePacket, VirtualPacketWrapper, [], function(constructor, prototype) {
        prototype.tr = null;
        prototype.off = 0;
        prototype.frameSize = 0;
        prototype.getData = function() {
            return NIOUtils.duplicate(this.tr.getResult().get(this.off));
        };
        prototype.getDataLen = function() {
            return this.frameSize;
        };
        prototype.isKeyframe = function() {
            return true;
        };
    }, {tr: "AVCClipTrack.GopTranscoder", src: "VirtualPacket", byPts: {name: "Comparator", arguments: ["Object"]}}, {});
}, {rc: "H264FixedRateControl", se: "VideoCodecMeta", encSPS: "SeqParameterSet", encPPS: "PictureParameterSet", codecPrivate: "Int8Array", src: "VirtualTrack", gop: {name: "List", arguments: ["VirtualPacket"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var VerifyTool = function() {};
VerifyTool = stjs.extend(VerifyTool, null, [], function(constructor, prototype) {
    constructor.main1 = function(args) {
        if (args.length != 1) {
            System.out.println("Syntax: <error folder location>");
            return;
        }
        new VerifyTool().doIt(args[0]);
    };
    prototype.doIt = function(location) {
        var h264 = new File(location).listFiles(new (stjs.extend(function VerifyTool$1() {}, null, [FilenameFilter], function(constructor, prototype) {
            prototype.accept = function(dir, name) {
                return name.endsWith(".264");
            };
        }, {}, {}))());
        for (var coded in h264) {
            var ref = new File(coded.getParentFile(), coded.getName().replaceAll(".264$", "_dec.yuv"));
            if (coded.exists() && ref.exists()) {
                try {
                    if (this.test(coded, ref)) {
                        System.out.println(coded.getAbsolutePath() + " -- FIXED");
                        Platform.deleteFile(coded);
                        Platform.deleteFile(ref);
                    } else {
                        System.out.println(coded.getAbsolutePath() + " -- NOT FIXED!!!!");
                    }
                }catch (t) {
                    System.out.println(coded.getAbsolutePath() + " -- ERROR: " + t.getMessage());
                }
            }
        }
    };
    prototype.test = function(coded, ref) {
        var es = new MappedH264ES(NIOUtils.fetchFromFile(coded));
        var buf = Picture8Bit.create(1920, 1088, ColorSpace.YUV420);
        var dec = new H264Decoder();
        var nextFrame;
        var _yuv = NIOUtils.fetchFromFile(ref);
         while ((nextFrame = es.nextFrame()) != null){
            var out = dec.decodeFrame8Bit(nextFrame.getData(), buf.getData()).cropped();
            var pic = out.createCompatible();
            pic.copyFrom(out);
            var lumaSize = pic.getWidth() * pic.getHeight();
            var crSize = lumaSize >> 2;
            var cbSize = lumaSize >> 2;
            var yuv = NIOUtils.read(_yuv, lumaSize + crSize + cbSize);
            if (!Platform.arrayEqualsByte(ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, lumaSize)), pic.getPlaneData(0))) 
                return false;
            if (!Platform.arrayEqualsByte(ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, crSize)), pic.getPlaneData(1))) 
                return false;
            if (!Platform.arrayEqualsByte(ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, cbSize)), pic.getPlaneData(2))) 
                return false;
        }
        return true;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Virtual movie track that transcodes Jpeg to AVC on the fly.
 *  
 *  @author The JCodec project
 *  
 */
var Jpeg2AVCTrack = function(proresTrack, frameDim) {
    Transcode2AVCTrack.call(this, proresTrack, frameDim);
};
Jpeg2AVCTrack = stjs.extend(Jpeg2AVCTrack, Transcode2AVCTrack, [], function(constructor, prototype) {
    prototype.checkFourCC = function(jpegTrack) {
        var fourcc = jpegTrack.getCodecMeta().getFourcc();
        if ("jpeg".equals(fourcc) || "mjpa".equals(fourcc)) 
            return;
         throw new IllegalArgumentException("Input track is not Jpeg");
    };
    prototype.selectScaleFactor = function(frameDim) {
        return frameDim.getWidth() >= 960 ? 2 : (frameDim.getWidth() > 480 ? 1 : 0);
    };
    prototype.getDecoder = function(scaleFactor) {
        var meta = this.src.getCodecMeta();
        switch (scaleFactor) {
            case 2:
                return new JpegToThumb2x2(meta.isInterlaced(), meta.isTopFieldFirst());
            case 1:
                return new JpegToThumb4x4(meta.isInterlaced(), meta.isTopFieldFirst());
            case 0:
                return new JpegDecoder(meta.isInterlaced(), meta.isTopFieldFirst());
            default:
                 throw new IllegalArgumentException("Unsupported scale factor: " + scaleFactor);
        }
    };
}, {src: "VirtualTrack", se: "CodecMeta", transcoders: {name: "ThreadLocal", arguments: ["Transcode2AVCTrack.Transcoder"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Prores2AVCTrack = function(proresTrack, frameDim) {
    Transcode2AVCTrack.call(this, proresTrack, frameDim);
};
Prores2AVCTrack = stjs.extend(Prores2AVCTrack, Transcode2AVCTrack, [], function(constructor, prototype) {
    prototype.checkFourCC = function(proresTrack) {
        var fourcc = proresTrack.getCodecMeta().getFourcc();
        if ("ap4h".equals(fourcc)) 
            return;
        var values = ProresEncoder.Profile.values();
        for (var i = 0; i < values.length; i++) {
            var profile = values[i];
            if (profile.fourcc.equals(fourcc)) 
                return;
        }
         throw new IllegalArgumentException("Input track is not ProRes");
    };
    prototype.selectScaleFactor = function(frameDim) {
        return frameDim.getWidth() >= 960 ? 2 : (frameDim.getWidth() > 480 ? 1 : 0);
    };
    prototype.getDecoder = function(scaleFactor) {
        switch (scaleFactor) {
            case 2:
                return new ProresToThumb2x2();
            case 1:
                return new ProresToThumb4x4();
            case 0:
                return new ProresDecoder();
            default:
                 throw new IllegalArgumentException("Unsupported scale factor: " + scaleFactor);
        }
    };
}, {src: "VirtualTrack", se: "CodecMeta", transcoders: {name: "ThreadLocal", arguments: ["Transcode2AVCTrack.Transcoder"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Virtual movie track that transcodes ProRes to AVC on the fly.
 *  
 *  @author The JCodec project
 *  
 */
var Mpeg2AVCTrack = function(src) {
    this.transcoders = new ThreadLocal();
    this.checkFourCC(src);
    this.src = src;
    var rc = new H264FixedRateControl(MPEGToAVCTranscoder.TARGET_RATE);
    var encoder = new H264Encoder(rc);
    this._nextPacket = src.nextPacket();
    var frameDim = MPEGDecoder.getSize(this._nextPacket.getData());
    this.scaleFactor = this.selectScaleFactor(frameDim);
    this.thumbWidth = frameDim.getWidth() >> this.scaleFactor;
    this.thumbHeight = (frameDim.getHeight() >> this.scaleFactor) & ~1;
    this.mbW = (this.thumbWidth + 15) >> 4;
    this.mbH = (this.thumbHeight + 15) >> 4;
    this.se = Transcode2AVCTrack.createCodecMeta(src, encoder, this.thumbWidth, this.thumbHeight);
    var _frameSize = rc.calcFrameSize(this.mbW * this.mbH);
    _frameSize += _frameSize >> 4;
    this.frameSize = _frameSize;
};
Mpeg2AVCTrack = stjs.extend(Mpeg2AVCTrack, null, [VirtualTrack], function(constructor, prototype) {
    prototype.frameSize = 0;
    prototype.src = null;
    prototype.se = null;
    prototype.transcoders = null;
    prototype.mbW = 0;
    prototype.mbH = 0;
    prototype.scaleFactor = 0;
    prototype.thumbWidth = 0;
    prototype.thumbHeight = 0;
    prototype.gop = null;
    prototype.prevGop = null;
    prototype._nextPacket = null;
    prototype.checkFourCC = function(srcTrack) {
        var fourcc = srcTrack.getCodecMeta().getFourcc();
        if (!"m2v1".equals(fourcc)) 
             throw new IllegalArgumentException("Input track is not ProRes");
    };
    prototype.selectScaleFactor = function(frameDim) {
        return frameDim.getWidth() >= 960 ? 2 : (frameDim.getWidth() > 480 ? 1 : 0);
    };
    prototype.getCodecMeta = function() {
        return this.se;
    };
    prototype.nextPacket = function() {
        if (this._nextPacket == null) 
            return null;
        if (this._nextPacket.isKeyframe()) {
            this.prevGop = this.gop;
            this.gop = new Mpeg2AVCTrack.GOP(this, this._nextPacket.getFrameNo(), this.prevGop);
            if (this.prevGop != null) 
                this.prevGop.setNextGop(this.gop);
        }
        var ret = this.gop.addPacket(this._nextPacket);
        this._nextPacket = this.src.nextPacket();
        return ret;
    };
    constructor.GOP = function(track, frameNo, prevGop) {
        this.packets = new ArrayList();
        this.track = track;
        this.frameNo = frameNo;
        this.prevGop = prevGop;
    };
    constructor.GOP = stjs.extend(constructor.GOP, null, [], function(constructor, prototype) {
        prototype.packets = null;
        prototype.data = null;
        prototype.frameNo = 0;
        prototype.nextGop = null;
        prototype.prevGop = null;
        prototype.leadingB = null;
        prototype.track = null;
        prototype.setNextGop = function(gop) {
            this.nextGop = gop;
        };
        prototype.addPacket = function(pkt) {
            this.packets.add(pkt);
            return new Mpeg2AVCTrack.TranscodePacket(pkt, this, this.packets.size() - 1, this.track.frameSize);
        };
        prototype.transcode = function() {
            if (this.data != null) 
                return;
            this.data = Array(this.packets.size());
            for (var tr = 0; tr < 2; tr++) {
                try {
                    var t = this.track.transcoders.get();
                    if (t == null) {
                        t = MPEGToAVCTranscoder.createTranscoder(this.track.scaleFactor);
                        this.track.transcoders.set(t);
                    }
                    this.carryLeadingBOver();
                    var pts = this.collectPts(this.packets);
                    for (var numRefs = 0, i = 0; i < this.packets.size(); i++) {
                        var pkt = this.packets.get(i);
                        var pktData = pkt.getData();
                        var picType = Mpeg2AVCTrack.getPicType(pktData.duplicate());
                        if (picType != MPEGConst.BiPredictiveCoded) {
                            ++numRefs;
                        } else if (numRefs < 2) {
                            continue;
                        }
                        var buf = ByteBuffer.allocate(this.track.frameSize);
                        this.data[i] = t.transcodeFrame(pktData, buf, i == 0, Arrays.binarySearch(pts, pkt.getPts()));
                    }
                    if (this.nextGop != null) {
                        this.nextGop.leadingB = new ArrayList();
                        pts = this.collectPts(this.nextGop.packets);
                        for (var numRefs = 0, i = 0; i < this.nextGop.packets.size(); i++) {
                            var pkt = this.nextGop.packets.get(i);
                            var pktData = pkt.getData();
                            var picType = Mpeg2AVCTrack.getPicType(pktData.duplicate());
                            if (picType != MPEGConst.BiPredictiveCoded) 
                                ++numRefs;
                            if (numRefs >= 2) 
                                break;
                            var buf = ByteBuffer.allocate(this.track.frameSize);
                            this.nextGop.leadingB.add(t.transcodeFrame(pktData, buf, i == 0, Arrays.binarySearch(pts, pkt.getPts())));
                        }
                    }
                    break;
                }catch (t) {
                    jcodec.Logger.error("Error transcoding gop: " + t.getMessage() + ", retrying.");
                }
            }
        };
        prototype.collectPts = function(packets2) {
            var pts = new Float64Array(packets2.size());
            for (var i = 0; i < pts.length; i++) 
                pts[i] = packets2.get(i).getPts();
            Arrays.sort(pts);
            return pts;
        };
        prototype.carryLeadingBOver = function() {
            if (this.leadingB != null) {
                for (var i = 0; i < this.leadingB.size(); i++) {
                    this.data[i] = this.leadingB.get(i);
                }
            }
        };
        prototype.getData = function(i) {
            this.transcode();
            if (this.data[i] == null && this.prevGop != null) {
                this.prevGop.transcode();
                this.carryLeadingBOver();
            }
            return this.data[i];
        };
    }, {packets: {name: "List", arguments: ["VirtualPacket"]}, data: "Array", nextGop: "Mpeg2AVCTrack.GOP", prevGop: "Mpeg2AVCTrack.GOP", leadingB: {name: "List", arguments: ["ByteBuffer"]}, track: "Mpeg2AVCTrack"}, {});
    constructor.getPicType = function(buf) {
        var segment;
         while ((segment = MPEGUtil.nextSegment(buf)) != null){
            var code = segment.getInt() & 255;
            if (code == MPEGConst.PICTURE_START_CODE) {
                var ph = PictureHeader.read(segment);
                return ph.picture_coding_type;
            }
        }
        return -1;
    };
    constructor.TranscodePacket = function(nextPacket, gop, index, frameSize) {
        VirtualPacketWrapper.call(this, nextPacket);
        this.gop = gop;
        this.index = index;
        this.frameSize = frameSize;
    };
    constructor.TranscodePacket = stjs.extend(constructor.TranscodePacket, VirtualPacketWrapper, [], function(constructor, prototype) {
        prototype.gop = null;
        prototype.index = 0;
        prototype.frameSize = 0;
        prototype.getDataLen = function() {
            return this.frameSize;
        };
        prototype.getData = function() {
            return this.gop.getData(this.index);
        };
    }, {gop: "Mpeg2AVCTrack.GOP", src: "VirtualPacket", byPts: {name: "Comparator", arguments: ["Object"]}}, {});
    prototype.close = function() {
        this.src.close();
    };
    prototype.getEdits = function() {
        return this.src.getEdits();
    };
    prototype.getPreferredTimescale = function() {
        return this.src.getPreferredTimescale();
    };
}, {src: "VirtualTrack", se: "CodecMeta", transcoders: {name: "ThreadLocal", arguments: ["MPEGToAVCTranscoder"]}, gop: "Mpeg2AVCTrack.GOP", prevGop: "Mpeg2AVCTrack.GOP", _nextPacket: "VirtualPacket"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Track taken from a real movie
 *  
 *  @author The JCodec project
 *  
 */
var RealTrack = function(movie, trak, pool) {
    this.movie = movie;
    var stsz = NodeBox.findFirstPath(trak, SampleSizesBox, Box.path("mdia.minf.stbl.stsz"));
    if (stsz.getDefaultSize() == 0) {
        this.demuxer = new (stjs.extend(function RealTrack$1(x0, x1, x2) {
            FramesMP4DemuxerTrack.call(this, x0, x1, x2);
        }, FramesMP4DemuxerTrack, [], function(constructor, prototype) {
            prototype.readPacketData = function(ch, buffer, position, size) {
                return buffer;
            };
        }, {sizes: "Int32Array", syncSamples: "Int32Array", partialSync: "Int32Array", compOffsets: "Array", input: "SeekableByteChannel", movie: "MovieBox", avcC: "AvcCBox", box: "TrakBox", type: "TrackType", sampleEntries: "Array", timeToSamples: "Array", sampleToChunks: "Array", chunkOffsets: "Array"}, {}))(movie, trak, null);
    } else {
        this.demuxer = new (stjs.extend(function RealTrack$2(x0, x1, x2) {
            PCMMP4DemuxerTrack.call(this, x0, x1, x2);
        }, PCMMP4DemuxerTrack, [], function(constructor, prototype) {
            prototype.readPacketData = function(ch, buffer, position, size) {
                return buffer;
            };
        }, {input: "SeekableByteChannel", movie: "MovieBox", box: "TrakBox", type: "TrackType", sampleEntries: "Array", timeToSamples: "Array", sampleToChunks: "Array", chunkOffsets: "Array"}, {}))(movie, trak, null);
    }
    this.trak = trak;
    this.pool = pool;
};
RealTrack = stjs.extend(RealTrack, null, [VirtualTrack], function(constructor, prototype) {
    prototype.trak = null;
    prototype.pool = null;
    prototype.demuxer = null;
    prototype.movie = null;
    prototype.nextPacket = function() {
        var pkt = this.demuxer.getNextFrame(null);
        if (pkt == null) 
            return null;
        return new RealTrack.RealPacket(this, pkt);
    };
    prototype.getCodecMeta = function() {
        var se = this.trak.getSampleEntries()[0];
        if (stjs.isInstanceOf(se.constructor, VideoSampleEntry)) {
            var vse = se;
            var pasp = NodeBox.findFirst(se, PixelAspectExt, "pasp");
            var fiel = NodeBox.findFirst(se, FielExtension, "fiel");
            var interlace = false, topField = false;
            if (fiel != null) {
                interlace = fiel.isInterlaced();
                topField = fiel.topFieldFirst();
            }
            var codecPrivate = this.demuxer.getMeta().getCodecPrivate();
            return VideoCodecMeta.createVideoCodecMeta2(se.getFourcc(), ByteBuffer.wrap(codecPrivate), new Size(vse.getWidth(), vse.getHeight()), pasp != null ? pasp.getRational() : null, interlace, topField);
        } else if (stjs.isInstanceOf(se.constructor, AudioSampleEntry)) {
            var ase = se;
            var codecPrivate = null;
            if ("mp4a".equals(ase.getFourcc())) {
                var lb = NodeBox.findFirst(se, Box.LeafBox, "esds");
                if (lb == null) {
                    lb = NodeBox.findFirstPath(se, Box.LeafBox, [null, "esds"]);
                }
                codecPrivate = lb.getData();
            }
            return AudioCodecMeta.createAudioCodecMeta(se.getFourcc(), ase.calcSampleSize(), ase.getChannelCount(), stjs.trunc(ase.getSampleRate()), ase.getEndian(), ase.isPCM(), AudioSampleEntry.getLabelsFromSampleEntry(ase), codecPrivate);
        } else 
             throw new RuntimeException("Sample entry '" + se.getFourcc() + "' is not supported.");
    };
    prototype.close = function() {
        this.pool.close();
    };
    constructor.RealPacket = function(track, nextFrame) {
        this.track = track;
        this.packet = nextFrame;
    };
    constructor.RealPacket = stjs.extend(constructor.RealPacket, null, [VirtualPacket], function(constructor, prototype) {
        prototype.packet = null;
        prototype.track = null;
        prototype.getData = function() {
            var bb = ByteBuffer.allocate(this.packet.getSize());
            var ch = null;
            try {
                ch = this.track.pool.getChannel();
                if (this.packet.getFileOff() >= ch.size()) 
                    return null;
                ch.setPosition(this.packet.getFileOff());
                ch.read(bb);
                bb.flip();
                return this.track.demuxer.convertPacket(bb);
            } finally {
                if (ch != null) 
                    ch.close();
            }
        };
        prototype.getDataLen = function() {
            return this.packet.getSize();
        };
        prototype.getPts = function() {
            return this.packet.getMediaPts() / this.packet.getTimescale();
        };
        prototype.getDuration = function() {
            return this.packet.getDuration() / this.packet.getTimescale();
        };
        prototype.isKeyframe = function() {
            return this.packet.isKeyFrame() || this.packet.isPsync();
        };
        prototype.getFrameNo = function() {
            return ((this.packet.getFrameNo()) | 0);
        };
    }, {packet: "MP4Packet", track: "RealTrack", byPts: {name: "Comparator", arguments: ["Object"]}}, {});
    prototype.getEdits = function() {
        var edits = this.demuxer.getEdits();
        if (edits == null) 
            return null;
        var result = Array(edits.size());
        for (var i = 0; i < edits.size(); i++) {
            var ee = edits.get(i);
            result[i] = new VirtualTrack.VirtualEdit(ee.getMediaTime() / this.trak.getTimescale(), ee.getDuration() / this.movie.getTimescale());
        }
        return result;
    };
    prototype.getPreferredTimescale = function() {
        return ((this.demuxer.getTimescale()) | 0);
    };
}, {trak: "TrakBox", pool: "ByteChannelPool", demuxer: "AbstractMP4DemuxerTrack", movie: "MovieBox"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Demuxer frontend for MP4
 *  
 *  @author The JCodec project
 *  
 */
var MP4Demuxer = function(input) {
    this.input = input;
    this.tracks = new LinkedList();
    this.findMovieBox(input);
};
MP4Demuxer = stjs.extend(MP4Demuxer, null, [], function(constructor, prototype) {
    prototype.tracks = null;
    prototype.timecodeTrack = null;
    prototype.movie = null;
    prototype.input = null;
    prototype.create = function(trak) {
        var stsz = NodeBox.findFirstPath(trak, SampleSizesBox, Box.path("mdia.minf.stbl.stsz"));
        if (stsz.getDefaultSize() == 0) 
            return new FramesMP4DemuxerTrack(this.movie, trak, this.input);
         else 
            return new PCMMP4DemuxerTrack(this.movie, trak, this.input);
    };
    prototype.getTracks = function() {
        return this.tracks.toArray([]);
    };
    prototype.findMovieBox = function(input) {
        this.movie = MP4Util.parseMovieChannel(input);
        if (this.movie == null) 
             throw new IOException("Could not find movie meta information box");
        this.processHeader(this.movie);
    };
    prototype.processHeader = function(moov) {
        var tt = null;
        var trakBoxs = NodeBox.findAll(moov, TrakBox, "trak");
        for (var i = 0; i < trakBoxs.length; i++) {
            var trak = trakBoxs[i];
            var se = NodeBox.findFirstPath(trak, SampleEntry, ["mdia", "minf", "stbl", "stsd", null]);
            if ("tmcd".equals(se.getFourcc())) {
                tt = trak;
            } else {
                this.tracks.add(this.create(trak));
            }
        }
        if (tt != null) {
            var video = this.getVideoTrack();
            if (video != null) 
                this.timecodeTrack = new TimecodeMP4DemuxerTrack(this.movie, tt, this.input);
        }
    };
    prototype.getVideoTrack = function() {
        for (var iterator$demuxerTrack = this.tracks.iterator(); iterator$demuxerTrack.hasNext(); ) {
            var demuxerTrack = iterator$demuxerTrack.next();
            if (demuxerTrack.box.isVideo()) 
                return demuxerTrack;
        }
        return null;
    };
    prototype.getMovie = function() {
        return this.movie;
    };
    prototype.getTrack = function(no) {
        for (var iterator$track = this.tracks.iterator(); iterator$track.hasNext(); ) {
            var track = iterator$track.next();
            if (track.getNo() == no) 
                return track;
        }
        return null;
    };
    prototype.getAudioTracks = function() {
        var result = new ArrayList();
        for (var iterator$demuxerTrack = this.tracks.iterator(); iterator$demuxerTrack.hasNext(); ) {
            var demuxerTrack = iterator$demuxerTrack.next();
            if (demuxerTrack.box.isAudio()) 
                result.add(demuxerTrack);
        }
        return result;
    };
    prototype.getTimecodeTrack = function() {
        return this.timecodeTrack;
    };
    constructor.makeInt = function(b3, b2, b1, b0) {
        return (((b3) << 24) | ((b2 & 255) << 16) | ((b1 & 255) << 8) | ((b0 & 255)));
    };
    constructor.intFourcc = function(string) {
        var b = Platform.getBytes(string);
        return MP4Demuxer.makeInt(b[0], b[1], b[2], b[3]);
    };
    constructor.ftyp = MP4Demuxer.intFourcc("ftyp");
    constructor.free = MP4Demuxer.intFourcc("free");
    constructor.moov = MP4Demuxer.intFourcc("moov");
    constructor.mdat = MP4Demuxer.intFourcc("mdat");
    constructor.wide = MP4Demuxer.intFourcc("wide");
    constructor.probe = function(b) {
        var fork = b.duplicate();
        var success = 0;
        var total = 0;
         while (fork.remaining() >= 8){
            var len = fork.getInt() & 4294967295;
            var fcc = fork.getInt();
            var hdrLen = 8;
            if (len == 1) {
                len = fork.getLong();
                hdrLen = 16;
            } else if (len < 8) 
                break;
            if (fcc == MP4Demuxer.ftyp && len < 64 || fcc == MP4Demuxer.moov && len < 100 * 1024 * 1024 || fcc == MP4Demuxer.free || fcc == MP4Demuxer.mdat || fcc == MP4Demuxer.wide) 
                success++;
            total++;
            if (len >= Integer.MAX_VALUE) 
                break;
            NIOUtils.skip(fork, (((len - hdrLen)) | 0));
        }
        return total == 0 ? 0 : stjs.trunc(success * 100 / total);
    };
}, {tracks: {name: "List", arguments: ["AbstractMP4DemuxerTrack"]}, timecodeTrack: "TimecodeMP4DemuxerTrack", movie: "MovieBox", input: "SeekableByteChannel"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var StreamingMain = function() {};
StreamingMain = stjs.extend(StreamingMain, null, [], function(constructor, prototype) {
    constructor.main1 = function(args) {
        var m1 = new File(System.getProperty("user.home") + "/Desktop/supercool.mov");
        var ch1 = new FilePool(m1, 10);
        var mov1 = MP4Util.parseMovie(m1);
        var v1 = mov1.getVideoTrack();
        var rt = new RealTrack(mov1, v1, ch1);
        var rt1 = new StereoDownmixTrack(new RealTrack(mov1, mov1.getAudioTracks().get(0), ch1), new RealTrack(mov1, mov1.getAudioTracks().get(1), ch1), new RealTrack(mov1, mov1.getAudioTracks().get(2), ch1), new RealTrack(mov1, mov1.getAudioTracks().get(3), ch1));
        var start = System.currentTimeMillis();
        var cachePolicyExec = Executors.newSingleThreadScheduledExecutor();
        var vm = new VirtualMP4Movie(new CachingTrack(new Prores2AVCTrack(rt, v1.getCodedSize()), 10, cachePolicyExec), new CachingTrack(rt1, 10, cachePolicyExec));
        System.out.println(System.currentTimeMillis() - start);
        var os = new BufferedOutputStream(new FileOutputStream(System.getProperty("user.home") + "/Desktop/megashit.mov"));
        for (var off = 0; off < vm.size(); ) {
            var to = stjs.trunc((10000 * Math.random())) + off;
            var mr;
            if (off > 20) {
                mr = new MovieRange(vm, off - 20, to);
                for (var i = 0; i < 20; i++) 
                    mr.read();
            } else {
                mr = new MovieRange(vm, off, to);
            }
            IOUtils.copy(mr, os);
            mr.close();
            off = to;
        }
        vm.close();
        os.close();
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var ConcurrentMovieRangeServiceMain = function() {};
ConcurrentMovieRangeServiceMain = stjs.extend(ConcurrentMovieRangeServiceMain, null, [], function(constructor, prototype) {
    constructor.main1 = function(args) {
        if (args.length < 1) {
            System.out.println("Syntax: <movie.mov>");
            return;
        }
        var file = new File(args[0]);
        var fp = new FilePool(file, 10);
        var movie = MP4Util.parseMovie(file);
        var vt = new RealTrack(movie, movie.getVideoTrack(), fp);
        var vm = new VirtualMP4Movie(vt);
        var is = new MovieRange(vm, 0, vm.size());
        var ref = File.createTempFile("cool", "super");
        ref.deleteOnExit();
        var tmpOs = new FileOutputStream(ref);
        IOUtils.copy(is, tmpOs);
        is.close();
        tmpOs.close();
        var cmrs = new ConcurrentMovieRangeService(vm, 2);
        var tp = Executors.newFixedThreadPool(20, new (stjs.extend(function ConcurrentMovieRangeServiceMain$1() {}, null, [ThreadFactory], function(constructor, prototype) {
            prototype.newThread = function(runnable) {
                var thread = Executors.defaultThreadFactory().newThread(runnable);
                thread.setDaemon(true);
                return thread;
            };
        }, {}, {}))());
        var ff = Array(1000);
        for (var i = 0; i < 1000; i++) {
            ff[i] = tp.submit(new ConcurrentMovieRangeServiceMain.OneTest(vm, ref, cmrs));
        }
        for (var i = 0; i < 1000; i++) {
            try {
                ff[i].get();
            }catch (e) {
                e.printStackTrace();
            }
        }
    };
    constructor.OneTest = function(vm, ref, cmrs) {
        this.vm = vm;
        this.ref = ref;
        this.cmrs = cmrs;
    };
    constructor.OneTest = stjs.extend(constructor.OneTest, null, [Runnable], function(constructor, prototype) {
        prototype.vm = null;
        prototype.ref = null;
        prototype.cmrs = null;
        prototype.run = function() {
            try {
                var size = this.vm.size();
                var from = stjs.trunc((Math.random() * size));
                var to = from + stjs.trunc((Math.random() * (size - from)));
                System.out.println("RANGE: " + from + " - " + to);
                var is1 = this.cmrs.getRange(from, to);
                var _in = new FileInputStream(this.ref).getChannel();
                _in.position(from);
                var is2 = Channels.newInputStream(_in);
                var buf1 = new Int8Array(4096), buf2 = new Int8Array(4096);
                var b, ii = 0;
                do {
                    b = is1.read(buf1);
                    var b2 = is2.read(buf2);
                    if (b != -1) {
                        for (var k = 0; k < b; k++) {
                            if (buf1[k] != buf2[k]) 
                                 throw new RuntimeException("[" + (ii + k) + "]" + buf1[k] + ":" + buf2[k]);
                        }
                        ii += b;
                    }
                } while (b != -1);
                if (ii != to - from + 1) 
                     throw new RuntimeException("Read less [" + ii + " < " + (to - from + 1));
                is1.close();
                is2.close();
            }catch (e) {
                e.printStackTrace();
            }
        };
    }, {vm: "VirtualMovie", ref: "File", cmrs: "ConcurrentMovieRangeService"}, {});
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var ConcatMain = function() {};
ConcatMain = stjs.extend(ConcatMain, null, [], function(constructor, prototype) {
    constructor.main1 = function(args) {
        var folder = new File(System.getProperty("user.home"), "upload");
        var listFiles = folder.listFiles(new (stjs.extend(function ConcatMain$1() {}, null, [FilenameFilter], function(constructor, prototype) {
            prototype.accept = function(dir, name) {
                return name.startsWith("chunk") && name.endsWith(".mov");
            };
        }, {}, {}))());
        Arrays.sort(listFiles, new (stjs.extend(function ConcatMain$2() {}, null, [Comparator], function(constructor, prototype) {
            prototype.compare = function(o1, o2) {
                return Integer.parseInt(o1.getName().replaceAll("[^0-9]", "")) - Integer.parseInt(o2.getName().replaceAll("[^0-9]", ""));
            };
        }, {}, {}))());
        var tracks = Array(listFiles.length);
        for (var i = 0; i < tracks.length; i++) {
            var m1 = listFiles[i];
            var ch1 = new FilePool(m1, 1);
            var mov1 = MP4Util.parseMovie(m1);
            var v1 = mov1.getVideoTrack();
            var rt = new RealTrack(mov1, v1, ch1);
            tracks[i] = rt;
        }
        var concat = new ConcatTrack(tracks);
        var vm = new VirtualMP4Movie(concat);
        var os = new BufferedOutputStream(new FileOutputStream(new File(System.getProperty("user.home"), "concat.mov")));
        var movieRange = new MovieRange(vm, 0, vm.size() - 1);
        IOUtils.copy(movieRange, os);
        movieRange.close();
        os.close();
        vm.close();
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var DemuxerMain = function() {};
DemuxerMain = stjs.extend(DemuxerMain, null, [], function(constructor, prototype) {
    constructor.main1 = function(args) {
        var demuxer = new MP4Demuxer(NIOUtils.readableFileChannel(args[0]));
        var vt = demuxer.getVideoTrack();
        var decoder = new ProresDecoder();
        var duration = vt.getDuration().getNum();
        var frameCount = vt.getFrameCount();
        for (var t = 0; ; t++) {
            DemuxerMain.randomPts(vt, decoder, duration, new Yuv422pToRgb(2, 0), new File(args[1]));
        }
    };
    constructor.randomPts = function(vt, decoder, duration, transform, base) {
        var pts = stjs.trunc((Math.random() * duration));
        vt.seekPts(pts);
        for (var i = 0; i < 10; i++) {
            var frames = vt.nextFrame();
            var pic = decoder.decodeFrame(frames.getData(), DemuxerMain.allocBuffer(vt));
            var dest = Picture.create(pic.getWidth(), pic.getHeight(), ColorSpace.RGB);
            transform.transform(pic, dest);
        }
    };
    constructor.allocBuffer = function(vt) {
        var vse = vt.getSampleEntries()[0];
        var size = stjs.trunc((stjs.trunc((11 * vse.getWidth() * vse.getHeight()) / 10)));
        return [new Int32Array(size), new Int32Array(size), new Int32Array(size)];
    };
    constructor.randomFrame = function(vt, decoder, frameCount, transform, base) {
        var frame = stjs.trunc((Math.random() * frameCount));
        System.out.println(frame);
        vt.gotoFrame(((frame) | 0));
        for (var i = 0; i < 10; i++) {
            var frames = vt.nextFrame();
            var pic = decoder.decodeFrame(frames.getData(), DemuxerMain.allocBuffer(vt));
            var dest = Picture.create(pic.getWidth(), pic.getHeight(), ColorSpace.RGB);
            transform.transform(pic, dest);
        }
    };
    constructor.testAudio = function(src, wavFile) {
        var demuxer = new MP4Demuxer(NIOUtils.readableChannel(src));
        var demuxerTrack = demuxer.getAudioTracks().get(0);
        var fos = NIOUtils.writableChannel(wavFile);
        var se = demuxerTrack.getSampleEntries()[0];
        var wav = new WavHeader("RIFF", 40, "WAVE", new WavHeader.FmtChunk(((1) << 16 >> 16), stjs.trunc(se.getChannelCount()), stjs.trunc(se.getSampleRate()), stjs.trunc(se.getSampleRate()) * se.getBytesPerFrame(), ((se.getBytesPerFrame()) << 16 >> 16), ((((stjs.trunc(se.getBytesPerFrame() / se.getChannelCount())) << 3)) << 16 >> 16)), 44, se.getBytesPerFrame() * demuxerTrack.getFrameCount());
        wav.write(fos);
         while (true){
            var packet = demuxerTrack.nextFrame();
            fos.write(packet.getData());
        }
    };
    constructor.testProres = function(base) {
        var decoder = new ProresDecoder();
        for (var i = 1; ; i++) {
            System.out.println(i);
            var buffer = NIOUtils.fetchFromFile(new File(base, String.format("frame%08d.raw", i)));
            var sz = 1920 * 1080 * 2;
            decoder.decodeFrame(buffer, [new Int32Array(sz), new Int32Array(sz), new Int32Array(sz)]);
        }
    };
    constructor.testVideo = function(src, base) {
        var startFn = 7572;
        var demuxer = new MP4Demuxer(NIOUtils.readableChannel(src));
        var vt = demuxer.getVideoTrack();
        vt.gotoFrame(startFn);
        for (var i = 0; ; i++) {
            var expected = IOUtils.readFileToByteArray(new File(base, String.format("frame%08d.raw", i + startFn + 1)));
            var pkt = vt.nextFrame();
            if (!Platform.arrayEqualsByte(expected, NIOUtils.toArray(pkt.getData()))) 
                 throw new RuntimeException("not equal");
            System.out.print(".");
            if ((i % 100) == 0) 
                System.out.println();
        }
    };
    constructor.testAudioMuxer = function(wav, out) {
        var header = WavHeader.read(wav);
        var _in = new RandomAccessFile(wav, "r");
        _in.seek(header.dataOffset);
        var ch = _in.getChannel();
        var muxer = MP4Muxer.createMP4MuxerToChannel(NIOUtils.writableChannel(out));
        var track = muxer.addPCMTrack(48000, 1, 3, MP4Muxer.audioSampleEntry("in24", 1, 3, 1, 48000, ByteOrder.LITTLE_ENDIAN));
        var buffer = ByteBuffer.allocate(3 * 24000);
         while (ch.read(buffer) != -1){
            track.addSamples(buffer);
        }
        muxer.writeHeader();
    };
    constructor.testRemux = function(src, dst) {
        var muxer = MP4Muxer.createMP4MuxerToChannel(NIOUtils.writableChannel(dst));
        var demuxer1 = new MP4Demuxer(NIOUtils.readableChannel(src));
        var vt1 = demuxer1.getVideoTrack();
        var outTrack = muxer.addTrack(TrackType.VIDEO, ((vt1.getTimescale()) | 0));
        outTrack.addSampleEntry(vt1.getSampleEntries()[0]);
        for (var i = 0; i < vt1.getFrameCount(); i++) {
            outTrack.addFrame(vt1.nextFrame());
        }
        muxer.writeHeader();
    };
    constructor.storeMdat = function(src, dst) {
        var rootAtoms = MP4Util.getRootAtoms(NIOUtils.readableChannel(src));
        var mdatOff = -1, mdatSize = 0;
        for (var iterator$atom = rootAtoms.iterator(); iterator$atom.hasNext(); ) {
            var atom = iterator$atom.next();
            if ("mdat".equals(atom.getHeader().getFourcc())) {
                mdatOff = atom.getOffset();
                mdatOff += atom.getHeader().headerSize();
                mdatSize = atom.getHeader().getBodySize();
            }
        }
        if (mdatOff == -1) {
            System.out.println("no mdat");
            return;
        }
        var _in = new BufferedInputStream(new FileInputStream(src));
        _in.skip(mdatOff);
        var out = new BufferedOutputStream(new FileOutputStream(dst));
        for (var i = 0; i < mdatSize; i++) {
            out.write(_in.read());
        }
    };
    constructor.narrowDown = function(src, dst) {
        var rw = NIOUtils.rwChannel(dst);
        var inp = NIOUtils.readableChannel(src);
        var rootAtoms = MP4Util.getRootAtoms(inp);
        for (var iterator$atom = rootAtoms.iterator(); iterator$atom.hasNext(); ) {
            var atom = iterator$atom.next();
            if ("moov".equals(atom.getHeader().getFourcc())) {
                var box = atom.parseBox(inp);
                MP4Util.writeMovie(rw, box);
            } else {
                atom.copy(inp, rw);
            }
        }
        inp.close();
        rw.close();
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var JCodecUtil = function() {};
JCodecUtil = stjs.extend(JCodecUtil, null, [], function(constructor, prototype) {
    constructor.knownDecoders = [new ProresDecoder(), new MPEGDecoder(), new H264Decoder()];
    constructor.Format = stjs.enumeration("MOV", "MPEG_PS", "MPEG_TS");
    constructor.detectFormat = function(f) {
        return JCodecUtil.detectFormatBuffer(NIOUtils.fetchFromFileL(f, 200 * 1024));
    };
    constructor.detectFormatChannel = function(f) {
        return JCodecUtil.detectFormatBuffer(NIOUtils.fetchFromChannel(f, 200 * 1024));
    };
    constructor.detectFormatBuffer = function(b) {
        var movScore = MP4Demuxer.probe(b.duplicate());
        var psScore = MPSDemuxer.probe(b.duplicate());
        var tsScore = MTSDemuxer.probe(b.duplicate());
        if (movScore == 0 && psScore == 0 && tsScore == 0) 
            return null;
        return movScore > psScore ? (movScore > tsScore ? JCodecUtil.Format.MOV : JCodecUtil.Format.MPEG_TS) : (psScore > tsScore ? JCodecUtil.Format.MPEG_PS : JCodecUtil.Format.MPEG_TS);
    };
    constructor.detectDecoder = function(b) {
        var maxProbe = 0;
        var selected = null;
        for (var i = 0; i < JCodecUtil.knownDecoders.length; i++) {
            var vd = JCodecUtil.knownDecoders[i];
            var probe = vd.probe(b);
            if (probe > maxProbe) {
                selected = vd;
                maxProbe = probe;
            }
        }
        return selected;
    };
    constructor.getVideoDecoder = function(fourcc) {
        if ("apch".equals(fourcc) || "apcs".equals(fourcc) || "apco".equals(fourcc) || "apcn".equals(fourcc) || "ap4h".equals(fourcc)) 
            return new ProresDecoder();
         else if ("m2v1".equals(fourcc)) 
            return new MPEGDecoder();
         else 
            return null;
    };
    constructor.savePictureAsPPM = function(pic, file) {
        var transform = ColorUtil.getTransform8Bit(pic.getColor(), ColorSpace.RGB);
        var rgb = Picture8Bit.create(pic.getWidth(), pic.getHeight(), ColorSpace.RGB);
        transform.transform(pic, rgb);
        NIOUtils.writeTo(new PPMEncoder().encodeFrame8Bit(rgb), file);
    };
    constructor.getPriorityExecutor = function(nThreads) {
        return new (stjs.extend(function JCodecUtil$1(x0, x1, x2, x3, x4) {
            ThreadPoolExecutor.call(this, x0, x1, x2, x3, x4);
        }, ThreadPoolExecutor, [], function(constructor, prototype) {
            prototype.newTaskFor = function(callable) {
                var newTaskFor = ThreadPoolExecutor.prototype.newTaskFor.call(this, callable);
                return new PriorityFuture(newTaskFor, (callable).getPriority());
            };
        }, {}, {}))(nThreads, nThreads, 0, TimeUnit.MILLISECONDS, new PriorityBlockingQueue(10, PriorityFuture.COMP));
    };
}, {knownDecoders: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Remux = function() {};
Remux = stjs.extend(Remux, null, [], function(constructor, prototype) {
    constructor.main1 = function(args) {
        if (args.length < 1) {
            System.out.println("remux <movie>");
            return;
        }
        var tgt = new File(args[0]);
        var src = Remux.hidFile(tgt);
        tgt.renameTo(src);
        try {
            new Remux().remux(tgt, src, null, null);
        }catch (t) {
            tgt.renameTo(new File(tgt.getParentFile(), tgt.getName() + ".error"));
            src.renameTo(tgt);
        }
    };
    constructor.Handler = function() {};
    constructor.Handler = stjs.extend(constructor.Handler, null, [], function(constructor, prototype) {
        prototype.handle = function(mov) {};
    }, {}, {});
    prototype.remux = function(tgt, src, timecode, handler) {
        var input = null;
        var output = null;
        var tci = null;
        try {
            input = NIOUtils.readableChannel(src);
            output = NIOUtils.writableChannel(tgt);
            var demuxer = new MP4Demuxer(input);
            var tt = null;
            if (timecode != null) {
                tci = NIOUtils.readableChannel(src);
                var tcd = new MP4Demuxer(tci);
                tt = tcd.getTimecodeTrack();
            }
            var muxer = WebOptimizedMP4Muxer.withOldHeader(output, Brand.MOV, demuxer.getMovie());
            var at = demuxer.getAudioTracks();
            var audioTracks = new ArrayList();
            for (var iterator$demuxerTrack = at.iterator(); iterator$demuxerTrack.hasNext(); ) {
                var demuxerTrack = iterator$demuxerTrack.next();
                var att = muxer.addPCMAudioTrack((demuxerTrack.getSampleEntries()[0]).getFormat());
                audioTracks.add(att);
                att.setEdits(demuxerTrack.getEdits());
                att.setName(demuxerTrack.getName());
            }
            var vt = demuxer.getVideoTrack();
            var video = muxer.addTrack(TrackType.VIDEO, ((vt.getTimescale()) | 0));
            video.setTimecode(muxer.addTimecodeTrack(((vt.getTimescale()) | 0)));
            this.copyEdits(vt, video, new Rational(((vt.getTimescale()) | 0), demuxer.getMovie().getTimescale()));
            video.addSampleEntries(vt.getSampleEntries());
            var pkt = null;
             while ((pkt = vt.nextFrame()) != null){
                if (tt != null) 
                    pkt = tt.getTimecode(pkt);
                pkt = this.processFrame(pkt);
                video.addFrame(pkt);
                for (var i = 0; i < at.size(); i++) {
                    var ase = at.get(i).getSampleEntries()[0];
                    var frames = stjs.trunc((ase.getSampleRate() * pkt.getDuration() / vt.getTimescale()));
                    var apkt = at.get(i).nextFrame();
                    audioTracks.get(i).addSamples(apkt.getData());
                }
            }
            var movie = muxer.finalizeHeader();
            if (handler != null) 
                handler.handle(movie);
            muxer.storeHeader(movie);
        } finally {
            NIOUtils.closeQuietly(input);
            NIOUtils.closeQuietly(output);
            NIOUtils.closeQuietly(tci);
        }
    };
    prototype.copyEdits = function(from, two, tsRatio) {
        var edits = from.getEdits(), result = new ArrayList();
        if (edits == null) 
            return;
        for (var iterator$edit = edits.iterator(); iterator$edit.hasNext(); ) {
            var edit = iterator$edit.next();
            result.add(new Edit(tsRatio.multiplyLong(edit.getDuration()), edit.getMediaTime(), edit.getRate()));
        }
        two.setEdits(result);
    };
    prototype.processFrame = function(pkt) {
        return pkt;
    };
    constructor.hidFile = function(tgt) {
        var src = new File(tgt.getParentFile(), "." + tgt.getName());
        if (src.exists()) {
            var i = 1;
            do {
                src = new File(tgt.getParentFile(), "." + tgt.getName() + "." + (i++));
            } while (src.exists());
        }
        return src;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var TestTool = function(jm, errs) {
    this.jm = jm;
    this.errs = new File(errs);
    this.coded = File.createTempFile("seq", ".264");
    this.decoded = File.createTempFile("seq_dec", ".yuv");
    this.jmconf = File.createTempFile("ldecod", ".conf");
    this.prepareJMConf();
};
TestTool = stjs.extend(TestTool, null, [], function(constructor, prototype) {
    prototype.jm = null;
    prototype.coded = null;
    prototype.decoded = null;
    prototype.jmconf = null;
    prototype.errs = null;
    constructor.main1 = function(args) {
        if (args.length != 3) {
            System.out.println("JCodec h.264 test tool");
            System.out.println("Syntax: <path to ldecod> <movie file> <foder for errors>");
            return;
        }
        new TestTool(args[0], args[2]).doIt(args[1]);
    };
    prototype.doIt = function(_in) {
        var raw = null;
        var source = null;
        try {
            source = new FileChannelWrapper(new FileInputStream(_in).getChannel());
            var demux = new MP4Demuxer(source);
            var inTrack = demux.getVideoTrack();
            var ine = inTrack.getSampleEntries()[0];
            var _rawData = ByteBuffer.allocate(1920 * 1088 * 6);
            var codecPrivate = inTrack.getMeta().getCodecPrivate();
            var decoder = H264Decoder.createH264DecoderFromCodecPrivate(codecPrivate);
            var inFrame;
            var sf = 2600;
            inTrack.gotoFrame(sf);
             while ((inFrame = inTrack.nextFrame()) != null && !inFrame.isKeyFrame())
                ;
            inTrack.gotoFrame(inFrame.getFrameNo());
            var decodedPics = new ArrayList();
            var totalFrames = ((inTrack.getFrameCount()) | 0), seqNo = 0;
            for (var i = sf; (inFrame = inTrack.nextFrame()) != null; i++) {
                var data = inFrame.getData();
                var nalUnits = H264Utils.splitFrame(data);
                _rawData.clear();
                H264Utils.joinNALUnitsToBuffer(nalUnits, _rawData);
                _rawData.flip();
                if (H264Utils.idrSliceFromBuffer(_rawData)) {
                    if (raw != null) {
                        raw.close();
                        this.runJMCompareResults(decodedPics, seqNo);
                        decodedPics = new ArrayList();
                        seqNo = i;
                    }
                    raw = new FileChannelWrapper(new FileOutputStream(this.coded).getChannel());
                    raw.write(ByteBuffer.wrap(codecPrivate));
                }
                raw.write(_rawData);
                decodedPics.add(decoder.decodeFrame8BitFromNals(nalUnits, Picture8Bit.create((ine.getWidth() + 15) & ~15, (ine.getHeight() + 15) & ~15, ColorSpace.YUV420).getData()));
                if (i % 500 == 0) 
                    System.out.println((stjs.trunc(i * 100 / totalFrames)) + "%");
            }
            if (decodedPics.size() > 0) 
                this.runJMCompareResults(decodedPics, seqNo);
        } finally {
            if (source != null) 
                source.close();
            if (raw != null) 
                raw.close();
        }
    };
    prototype.runJMCompareResults = function(decodedPics, seqNo) {
        try {
            var process = Runtime.getRuntime().exec(this.jm + " -d " + this.jmconf.getAbsolutePath());
            process.waitFor();
            var yuv = NIOUtils.fetchFromFile(this.decoded);
            for (var iterator$pic = decodedPics.iterator(); iterator$pic.hasNext(); ) {
                var pic = iterator$pic.next();
                pic = pic.cropped();
                var equals = Platform.arrayEqualsByte(ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, pic.getPlaneWidth(0) * pic.getPlaneHeight(0))), pic.getPlaneData(0));
                equals &= Platform.arrayEqualsByte(ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, pic.getPlaneWidth(1) * pic.getPlaneHeight(1))), pic.getPlaneData(1));
                equals &= Platform.arrayEqualsByte(ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, pic.getPlaneWidth(2) * pic.getPlaneHeight(2))), pic.getPlaneData(2));
                if (!equals) 
                    this.diff(seqNo);
            }
        }catch (e) {
            this.diff(seqNo);
        }
    };
    prototype.diff = function(seqNo) {
        System.out.println(seqNo + ": DIFF!!!");
        this.coded.renameTo(new File(this.errs, String.format("seq%08d.264", seqNo)));
        this.decoded.renameTo(new File(this.errs, String.format("seq%08d_dec.yuv", seqNo)));
    };
    prototype.prepareJMConf = function() {
        var cool = null;
        try {
            cool = Platform.getResourceAsStream(this.getClass(), "org/jcodec/testing/jm.conf");
            var str = IOUtils.readToString(cool);
            str = str.replace("%input_file%", this.coded.getAbsolutePath());
            str = str.replace("%output_file%", this.decoded.getAbsolutePath());
            IOUtils.writeStringToFile(this.jmconf, str);
        } finally {
            IOUtils.closeQuietly(cool);
        }
    };
}, {coded: "File", decoded: "File", jmconf: "File", errs: "File"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Extracts frames from a movie into uncompressed images suitable for
 *  processing.
 *  
 *  Supports going to random points inside of a movie ( seeking ) by frame number
 *  of by second.
 *  
 *  NOTE: Supports only AVC ( H.264 ) in MP4 ( ISO BMF, QuickTime ) at this
 *  point.
 *  
 *  @author The JCodec project
 *  
 */
var FrameGrab = function(videoTrack, decoder) {
    if (decoder == null || videoTrack == null) {
         throw new NullPointerException();
    }
    this.buffers = new ThreadLocal();
    this.videoTrack = videoTrack;
    this.decoder = decoder;
};
FrameGrab = stjs.extend(FrameGrab, null, [], function(constructor, prototype) {
    prototype.videoTrack = null;
    prototype.decoder = null;
    prototype.buffers = null;
    constructor._detectKeyFrame = function(videoTrack, start) {
        var seekFrames = videoTrack.getMeta().getSeekFrames();
        if (seekFrames == null) 
            return start;
        var prev = seekFrames[0];
        for (var i = 1; i < seekFrames.length; i++) {
            if (seekFrames[i] > start) 
                break;
            prev = seekFrames[i];
        }
        return prev;
    };
    constructor._detectDecoder = function(sdt, frame) {
        var meta = sdt.getMeta();
        switch (meta.getCodec()) {
            case Codec.H264:
                return new AVCMP4Adaptor(meta);
            default:
                 throw new UnsupportedFormatException("Codec is not supported");
        }
    };
    constructor.detectDecoder = function(sdt) {
        var curFrame = ((sdt.getCurFrame()) | 0);
        var keyFrame = FrameGrab._detectKeyFrame(sdt, curFrame);
        sdt.gotoFrame(keyFrame);
        var frame = sdt.nextFrame();
        var decoder = FrameGrab._detectDecoder(sdt, frame);
        return decoder;
    };
    constructor.createFrameGrab = function(_in) {
        var header = ByteBuffer.allocate(65536);
        _in.read(header);
        header.flip();
        var detectFormat = JCodecUtil.detectFormatBuffer(header);
        var videoTrack = null;
        switch (detectFormat) {
            case JCodecUtil.Format.MOV:
                var d1 = new MP4Demuxer(_in);
                videoTrack = d1.getVideoTrack();
                break;
            case JCodecUtil.Format.MPEG_PS:
                 throw new UnsupportedFormatException("MPEG PS is temporarily unsupported.");
            case JCodecUtil.Format.MPEG_TS:
                 throw new UnsupportedFormatException("MPEG TS is temporarily unsupported.");
            default:
                 throw new UnsupportedFormatException("Container format is not supported by JCodec");
        }
        return new FrameGrab(videoTrack, FrameGrab.detectDecoder(videoTrack));
    };
    prototype.sdt = function() {
        if (!(stjs.isInstanceOf(this.videoTrack.constructor, SeekableDemuxerTrack))) 
             throw new JCodecException("Not a seekable track");
        return this.videoTrack;
    };
    /**
     *  Position frame grabber to a specific second in a movie. As a result the
     *  next decoded frame will be precisely at the requested second.
     *  
     *  WARNING: potentially very slow. Use only when you absolutely need precise
     *  seek. Tries to seek to exactly the requested second and for this it might
     *  have to decode a sequence of frames from the closes key frame. Depending
     *  on GOP structure this may be as many as 500 frames.
     *  
     *  @param second
     *  @return
     *  @throws IOException
     *  @throws JCodecException
     */
    prototype.seekToSecondPrecise = function(second) {
        this.sdt().seek(second);
        this.decodeLeadingFrames();
        return this;
    };
    /**
     *  Position frame grabber to a specific frame in a movie. As a result the
     *  next decoded frame will be precisely the requested frame number.
     *  
     *  WARNING: potentially very slow. Use only when you absolutely need precise
     *  seek. Tries to seek to exactly the requested frame and for this it might
     *  have to decode a sequence of frames from the closes key frame. Depending
     *  on GOP structure this may be as many as 500 frames.
     *  
     *  @param frameNumber
     *  @return
     *  @throws IOException
     *  @throws JCodecException
     */
    prototype.seekToFramePrecise = function(frameNumber) {
        this.sdt().gotoFrame(frameNumber);
        this.decodeLeadingFrames();
        return this;
    };
    /**
     *  Position frame grabber to a specific second in a movie.
     *  
     *  Performs a sloppy seek, meaning that it may actually not seek to exact
     *  second requested, instead it will seek to the closest key frame
     *  
     *  NOTE: fast, as it just seeks to the closest previous key frame and
     *  doesn't try to decode frames in the middle
     *  
     *  @param second
     *  @return
     *  @throws IOException
     *  @throws JCodecException
     */
    prototype.seekToSecondSloppy = function(second) {
        this.sdt().seek(second);
        this.goToPrevKeyframe();
        return this;
    };
    /**
     *  Position frame grabber to a specific frame in a movie
     *  
     *  Performs a sloppy seek, meaning that it may actually not seek to exact
     *  frame requested, instead it will seek to the closest key frame
     *  
     *  NOTE: fast, as it just seeks to the closest previous key frame and
     *  doesn't try to decode frames in the middle
     *  
     *  @param frameNumber
     *  @return
     *  @throws IOException
     *  @throws JCodecException
     */
    prototype.seekToFrameSloppy = function(frameNumber) {
        this.sdt().gotoFrame(frameNumber);
        this.goToPrevKeyframe();
        return this;
    };
    prototype.goToPrevKeyframe = function() {
        this.sdt().gotoFrame(this.detectKeyFrame(((this.sdt().getCurFrame()) | 0)));
    };
    prototype.decodeLeadingFrames = function() {
        var sdt = this.sdt();
        var curFrame = ((sdt.getCurFrame()) | 0);
        var keyFrame = this.detectKeyFrame(curFrame);
        sdt.gotoFrame(keyFrame);
        var frame = sdt.nextFrame();
         while (frame.getFrameNo() < curFrame){
            this.decoder.decodeFrame(frame, this.getBuffer());
            frame = sdt.nextFrame();
        }
        sdt.gotoFrame(curFrame);
    };
    prototype.getBuffer = function() {
        var buf = this.buffers.get();
        if (buf == null) {
            buf = this.decoder.allocatePicture();
            this.buffers.set(buf);
        }
        return buf;
    };
    prototype.detectKeyFrame = function(start) {
        var seekFrames = this.videoTrack.getMeta().getSeekFrames();
        if (seekFrames == null) 
            return start;
        var prev = seekFrames[0];
        for (var i = 1; i < seekFrames.length; i++) {
            if (seekFrames[i] > start) 
                break;
            prev = seekFrames[i];
        }
        return prev;
    };
    /**
     *  Get frame at current position in JCodec native image
     *  
     *  @return
     *  @throws IOException
     */
    prototype.getNativeFrame = function() {
        var frame = this.videoTrack.nextFrame();
        if (frame == null) 
            return null;
        return this.decoder.decodeFrame(frame, this.getBuffer());
    };
    /**
     *  Gets info about the media
     *  
     *  @return
     */
    prototype.getMediaInfo = function() {
        return this.decoder.getMediaInfo();
    };
    /**
     *  Get frame at a specified frame number as JCodec image
     *  
     *  @param file
     *  @param second
     *  @return
     *  @throws IOException
     *  @throws JCodecException
     */
    constructor.getFrameFromChannel = function(file, frameNumber) {
        return FrameGrab.createFrameGrab(file).seekToFramePrecise(frameNumber).getNativeFrame();
    };
    /**
     *  Get frame at a specified frame number as JCodec image
     *  
     *  @param file
     *  @param second
     *  @return
     *  @throws IOException
     *  @throws JCodecException
     */
    constructor.getFrameFromFile = function(file, frameNumber) {
        var ch = null;
        try {
            ch = NIOUtils.readableChannel(file);
            return FrameGrab.createFrameGrab(ch).seekToFramePrecise(frameNumber).getNativeFrame();
        } finally {
            NIOUtils.closeQuietly(ch);
        }
    };
    /**
     *  Get frame at a specified second as JCodec image
     *  
     *  @param file
     *  @param second
     *  @return
     *  @throws IOException
     *  @throws JCodecException
     */
    constructor.getFrameAtSecFromChannel = function(file, second) {
        return FrameGrab.createFrameGrab(file).seekToSecondPrecise(second).getNativeFrame();
    };
    /**
     *  Get frame at a specified second as JCodec image
     *  
     *  @param file
     *  @param second
     *  @return
     *  @throws IOException
     *  @throws JCodecException
     */
    constructor.getFrameAtSec = function(file, second) {
        var ch = null;
        try {
            ch = NIOUtils.readableChannel(file);
            return FrameGrab.createFrameGrab(ch).seekToSecondPrecise(second).getNativeFrame();
        } finally {
            NIOUtils.closeQuietly(ch);
        }
    };
    prototype.getVideoTrack = function() {
        return this.videoTrack;
    };
    prototype.getDecoder = function() {
        return this.decoder;
    };
}, {videoTrack: "SeekableDemuxerTrack", decoder: "ContainerAdaptor", buffers: {name: "ThreadLocal", arguments: ["Array"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Extracts frames from a movie into uncompressed images suitable for
 *  processing.
 *  
 *  Supports going to random points inside of a movie ( seeking ) by frame number
 *  of by second.
 *  
 *  NOTE: Supports only AVC ( H.264 ) in MP4 ( ISO BMF, QuickTime ) at this
 *  point.
 *  
 *  @author The JCodec project
 *  
 */
var FrameGrab8Bit = function(videoTrack, decoder) {
    this.videoTrack = videoTrack;
    this.decoder = decoder;
    this.buffers = new ThreadLocal();
};
FrameGrab8Bit = stjs.extend(FrameGrab8Bit, null, [], function(constructor, prototype) {
    prototype.videoTrack = null;
    prototype.decoder = null;
    prototype.buffers = null;
    constructor.createFrameGrab8Bit = function(_in) {
        var header = ByteBuffer.allocate(65536);
        _in.read(header);
        header.flip();
        var detectFormat = JCodecUtil.detectFormatBuffer(header);
        var videoTrack_;
        switch (detectFormat) {
            case JCodecUtil.Format.MOV:
                var d1 = new MP4Demuxer(_in);
                videoTrack_ = d1.getVideoTrack();
                break;
            case JCodecUtil.Format.MPEG_PS:
                 throw new UnsupportedFormatException("MPEG PS is temporarily unsupported.");
            case JCodecUtil.Format.MPEG_TS:
                 throw new UnsupportedFormatException("MPEG TS is temporarily unsupported.");
            default:
                 throw new UnsupportedFormatException("Container format is not supported by JCodec");
        }
        var fg = new FrameGrab8Bit(videoTrack_, FrameGrab8Bit.detectDecoder(videoTrack_));
        fg.decodeLeadingFrames();
        return fg;
    };
    prototype.sdt = function() {
        if (!(stjs.isInstanceOf(this.videoTrack.constructor, SeekableDemuxerTrack))) 
             throw new JCodecException("Not a seekable track");
        return this.videoTrack;
    };
    /**
     *  Position frame grabber to a specific second in a movie. As a result the
     *  next decoded frame will be precisely at the requested second.
     *  
     *  WARNING: potentially very slow. Use only when you absolutely need precise
     *  seek. Tries to seek to exactly the requested second and for this it might
     *  have to decode a sequence of frames from the closes key frame. Depending
     *  on GOP structure this may be as many as 500 frames.
     *  
     *  @param second
     *  @return
     *  @throws IOException
     *  @throws JCodecException
     */
    prototype.seekToSecondPrecise = function(second) {
        this.sdt().seek(second);
        this.decodeLeadingFrames();
        return this;
    };
    /**
     *  Position frame grabber to a specific frame in a movie. As a result the
     *  next decoded frame will be precisely the requested frame number.
     *  
     *  WARNING: potentially very slow. Use only when you absolutely need precise
     *  seek. Tries to seek to exactly the requested frame and for this it might
     *  have to decode a sequence of frames from the closes key frame. Depending
     *  on GOP structure this may be as many as 500 frames.
     *  
     *  @param frameNumber
     *  @return
     *  @throws IOException
     *  @throws JCodecException
     */
    prototype.seekToFramePrecise = function(frameNumber) {
        this.sdt().gotoFrame(frameNumber);
        this.decodeLeadingFrames();
        return this;
    };
    /**
     *  Position frame grabber to a specific second in a movie.
     *  
     *  Performs a sloppy seek, meaning that it may actually not seek to exact
     *  second requested, instead it will seek to the closest key frame
     *  
     *  NOTE: fast, as it just seeks to the closest previous key frame and
     *  doesn't try to decode frames in the middle
     *  
     *  @param second
     *  @return
     *  @throws IOException
     *  @throws JCodecException
     */
    prototype.seekToSecondSloppy = function(second) {
        this.sdt().seek(second);
        this.goToPrevKeyframe();
        return this;
    };
    /**
     *  Position frame grabber to a specific frame in a movie
     *  
     *  Performs a sloppy seek, meaning that it may actually not seek to exact
     *  frame requested, instead it will seek to the closest key frame
     *  
     *  NOTE: fast, as it just seeks to the closest previous key frame and
     *  doesn't try to decode frames in the middle
     *  
     *  @param frameNumber
     *  @return
     *  @throws IOException
     *  @throws JCodecException
     */
    prototype.seekToFrameSloppy = function(frameNumber) {
        this.sdt().gotoFrame(frameNumber);
        this.goToPrevKeyframe();
        return this;
    };
    prototype.goToPrevKeyframe = function() {
        this.sdt().gotoFrame(this.detectKeyFrame(((this.sdt().getCurFrame()) | 0)));
    };
    prototype.decodeLeadingFrames = function() {
        var sdt = this.sdt();
        var curFrame = ((sdt.getCurFrame()) | 0);
        var keyFrame = this.detectKeyFrame(curFrame);
        sdt.gotoFrame(keyFrame);
        var frame = sdt.nextFrame();
        if (this.decoder == null) 
            this.decoder = FrameGrab8Bit.detectDecoder(sdt);
         while (frame.getFrameNo() < curFrame){
            this.decoder.decodeFrame8Bit(frame, this.getBuffer());
            frame = sdt.nextFrame();
        }
        sdt.gotoFrame(curFrame);
    };
    prototype.getBuffer = function() {
        var buf = this.buffers.get();
        if (buf == null) {
            buf = this.decoder.allocatePicture8Bit();
            this.buffers.set(buf);
        }
        return buf;
    };
    prototype.detectKeyFrame = function(start) {
        var seekFrames = this.videoTrack.getMeta().getSeekFrames();
        if (seekFrames == null) 
            return start;
        var prev = seekFrames[0];
        for (var i = 1; i < seekFrames.length; i++) {
            if (seekFrames[i] > start) 
                break;
            prev = seekFrames[i];
        }
        return prev;
    };
    constructor.detectDecoder = function(videoTrack) {
        var meta = videoTrack.getMeta();
        switch (meta.getCodec()) {
            case Codec.H264:
                return new AVCMP4Adaptor(meta);
            default:
                 throw new UnsupportedFormatException("Codec is not supported");
        }
    };
    /**
     *  Get frame at current position in JCodec native image
     *  
     *  @return A decoded picture with metadata.
     *  @throws IOException
     */
    prototype.getNativeFrameWithMetadata = function() {
        var frame = this.videoTrack.nextFrame();
        if (frame == null) 
            return null;
        var picture = this.decoder.decodeFrame8Bit(frame, this.getBuffer());
        return new PictureWithMetadata8Bit(picture, frame.getPtsD(), frame.getDurationD());
    };
    /**
     *  Get frame at current position in JCodec native image
     *  
     *  @return
     *  @throws IOException
     */
    prototype.getNativeFrame = function() {
        var frame = this.videoTrack.nextFrame();
        if (frame == null) 
            return null;
        return this.decoder.decodeFrame8Bit(frame, this.getBuffer());
    };
    /**
     *  Get frame at a specified second as JCodec image
     *  
     *  @param file
     *  @param second
     *  @return
     *  @throws IOException
     *  @throws JCodecException
     */
    constructor.getFrameAtSec = function(file, second) {
        var ch = null;
        try {
            ch = NIOUtils.readableChannel(file);
            return FrameGrab8Bit.createFrameGrab8Bit(ch).seekToSecondPrecise(second).getNativeFrame();
        } finally {
            NIOUtils.closeQuietly(ch);
        }
    };
    /**
     *  Get frame at a specified second as JCodec image
     *  
     *  @param file
     *  @param second
     *  @return
     *  @throws IOException
     *  @throws JCodecException
     */
    constructor.getFrameFromChannelAtSec = function(file, second) {
        return FrameGrab8Bit.createFrameGrab8Bit(file).seekToSecondPrecise(second).getNativeFrame();
    };
    /**
     *  Get frame at a specified frame number as JCodec image
     *  
     *  @param file
     *  @param second
     *  @return
     *  @throws IOException
     *  @throws JCodecException
     */
    constructor.getFrameFromFile = function(file, frameNumber) {
        var ch = null;
        try {
            ch = NIOUtils.readableChannel(file);
            return FrameGrab8Bit.createFrameGrab8Bit(ch).seekToFramePrecise(frameNumber).getNativeFrame();
        } finally {
            NIOUtils.closeQuietly(ch);
        }
    };
    /**
     *  Get frame at a specified frame number as JCodec image
     *  
     *  @param file
     *  @param second
     *  @return
     *  @throws IOException
     *  @throws JCodecException
     */
    constructor.getFrameFromChannel = function(file, frameNumber) {
        return FrameGrab8Bit.createFrameGrab8Bit(file).seekToFramePrecise(frameNumber).getNativeFrame();
    };
    /**
     *  Get a specified frame by number from an already open demuxer track
     *  
     *  @param vt
     *  @param decoder
     *  @param frameNumber
     *  @return
     *  @throws IOException
     *  @throws JCodecException
     */
    constructor.getNativeFrameAtFrame = function(vt, decoder, frameNumber) {
        return new FrameGrab8Bit(vt, decoder).seekToFramePrecise(frameNumber).getNativeFrame();
    };
    /**
     *  Get a specified frame by second from an already open demuxer track
     *  
     *  @param vt
     *  @param decoder
     *  @param frameNumber
     *  @return
     *  @throws IOException
     *  @throws JCodecException
     */
    constructor.getNativeFrameAtSec = function(vt, decoder, second) {
        return new FrameGrab8Bit(vt, decoder).seekToSecondPrecise(second).getNativeFrame();
    };
    /**
     *  Get a specified frame by number from an already open demuxer track (
     *  sloppy mode, i.e. nearest keyframe )
     *  
     *  @param vt
     *  @param decoder
     *  @param frameNumber
     *  @return
     *  @throws IOException
     *  @throws JCodecException
     */
    constructor.getNativeFrameSloppy = function(vt, decoder, frameNumber) {
        return new FrameGrab8Bit(vt, decoder).seekToFrameSloppy(frameNumber).getNativeFrame();
    };
    /**
     *  Get a specified frame by second from an already open demuxer track (
     *  sloppy mode, i.e. nearest keyframe )
     *  
     *  @param vt
     *  @param decoder
     *  @param frameNumber
     *  @return
     *  @throws IOException
     *  @throws JCodecException
     */
    constructor.getNativeFrameAtSecSloppy = function(vt, decoder, second) {
        return new FrameGrab8Bit(vt, decoder).seekToSecondSloppy(second).getNativeFrame();
    };
    /**
     *  Gets info about the media
     *  
     *  @return
     */
    prototype.getMediaInfo = function() {
        return this.decoder.getMediaInfo();
    };
    /**
     *  @return the videoTrack
     */
    prototype.getVideoTrack = function() {
        return this.videoTrack;
    };
    /**
     *  @return the decoder
     */
    prototype.getDecoder = function() {
        return this.decoder;
    };
}, {videoTrack: "SeekableDemuxerTrack", decoder: "ContainerAdaptor", buffers: {name: "ThreadLocal", arguments: ["Array"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var WebOptimize = function() {};
WebOptimize = stjs.extend(WebOptimize, null, [], function(constructor, prototype) {
    constructor.main1 = function(args) {
        if (args.length < 1) {
            System.out.println("Syntax: optimize <movie>");
            System.exit(-1);
        }
        var tgt = new File(args[0]);
        var src = Remux.hidFile(tgt);
        tgt.renameTo(src);
        try {
            var movie = MP4Util.createRefMovieFromFile(src);
            new Flattern().flattern(movie, tgt);
        }catch (t) {
            t.printStackTrace();
            tgt.renameTo(new File(tgt.getParentFile(), tgt.getName() + ".error"));
            src.renameTo(tgt);
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Re-exports a prores movie
 *  
 *  @author The JCodec project
 *  
 */
var ReExport = function() {
    Remux.call(this);
};
ReExport = stjs.extend(ReExport, Remux, [], function(constructor, prototype) {
    prototype.outBuf = null;
    prototype.processFrame = function(pkt) {
        if (this.outBuf == null) {
            this.outBuf = ByteBuffer.allocate(pkt.getData().remaining() * 2);
        }
        var out = ProresFix.transcode(pkt.getData(), this.outBuf);
        return MP4Packet.createMP4PacketWithData(pkt, out);
    };
    constructor.main2 = function(args) {
        if (args.length < 1) {
            System.out.println("reexport <movie> <out>");
            return;
        }
        var tgt = new File(args[0]);
        var src = Remux.hidFile(tgt);
        tgt.renameTo(src);
        try {
            new ReExport().remux(tgt, src, null, null);
        }catch (t) {
            t.printStackTrace();
            tgt.renameTo(new File(tgt.getParentFile(), tgt.getName() + ".error"));
            src.renameTo(tgt);
        }
    };
}, {outBuf: "ByteBuffer"}, {});
//# sourceMappingURL=jcodec.map
var MPEGTestConst = function() {};
MPEGTestConst = stjs.extend(MPEGTestConst, null, [], function(constructor, prototype) {
    constructor._mpegHeader = new Int32Array([0, 0, 1, 179, 53, 81, 224, 19, 255, 255, 225, 64, 0, 0, 1, 181, 20, 106, 0, 1, 0, 128, 0, 0, 1, 184, 0, 8, 0, 0]);
    constructor._mpegFrame = new Int32Array([0, 0, 1, 0, 0, 15, 255, 248, 0, 0, 1, 181, 143, 255, 243, 65, 128, 0, 0, 1, 1, 27, 248, 125, 41, 73, 74, 229, 41, 72, 139, 148, 165, 34, 46, 82, 148, 136, 185, 74, 82, 34, 229, 41, 72, 139, 148, 165, 34, 46, 82, 148, 136, 185, 74, 82, 34, 229, 41, 72, 139, 148, 165, 34, 46, 82, 148, 136, 185, 74, 82, 34, 229, 41, 72, 139, 148, 165, 34, 46, 82, 148, 136, 185, 74, 82, 34, 229, 41, 72, 139, 148, 165, 34, 46, 82, 148, 136, 185, 74, 82, 34, 229, 41, 72, 139, 148, 165, 34, 46, 82, 148, 136, 185, 74, 82, 34, 229, 41, 72, 139, 148, 165, 34, 46, 82, 148, 136, 185, 74, 82, 34, 229, 41, 72, 139, 148, 165, 34, 46, 82, 148, 136, 185, 74, 82, 34, 229, 41, 72, 139, 148, 165, 34, 46, 82, 148, 136, 185, 74, 82, 34, 229, 41, 72, 139, 148, 165, 34, 46, 82, 148, 136, 185, 74, 82, 34, 229, 41, 72, 139, 148, 165, 34, 46, 82, 148, 136, 185, 74, 82, 34, 229, 41, 72, 139, 148, 165, 34, 46, 82, 148, 136, 185, 74, 82, 34, 229, 41, 72, 139, 148, 165, 34, 46, 82, 148, 136, 185, 74, 82, 34, 229, 41, 73, 206]);
    constructor._prores = new Int32Array([0, 0, 167, 178, 105, 99, 112, 102, 0, 148, 0, 0, 116, 101, 108, 48, 2, 208, 2, 64, 132, 3, 0, 0, 0, 0, 0, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 4, 4, 4, 4, 4, 4, 5, 5, 4, 4, 4, 4, 4, 5, 5, 6, 4, 4, 4, 4, 5, 5, 6, 7, 4, 4, 4, 4, 5, 6, 7, 7, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 4, 4, 4, 4, 4, 4, 5, 5, 4, 4, 4, 4, 4, 5, 5, 6, 4, 4, 4, 4]);
    constructor.toBB = function(_arguments) {
        var len = 0;
        for (var i = 0; i < arguments.length; i++) 
            len += arguments[i].length;
        var off = 0;
        var bytes = new Int8Array(len);
        for (var i = 0; i < arguments.length; i++) {
            for (var j = 0; j < arguments[i].length; j++) 
                bytes[off++] = (arguments[i][j] << 24 >> 24);
        }
        return bytes;
    };
    constructor.mpeg = function() {
        return MPEGTestConst.toBB(MPEGTestConst._mpegHeader, MPEGTestConst._mpegFrame, MPEGTestConst._mpegHeader, MPEGTestConst._mpegFrame, MPEGTestConst._mpegFrame);
    };
    constructor.prores = function() {
        return MPEGTestConst.toBB(MPEGTestConst._prores);
    };
}, {_mpegHeader: "Int32Array", _mpegFrame: "Int32Array", _prores: "Int32Array"}, {});
var ByteBufferManipulationTest = function() {};
ByteBufferManipulationTest = stjs.extend(ByteBufferManipulationTest, null, [], function(constructor, prototype) {
    prototype.test = function() {
        var size = 64;
        var b1 = ByteBuffer.allocate(128);
        b1.setPosition(2);
        ByteBufferManipulationTest.printBuffer(b1, "ori");
        var b2 = b1.duplicate();
        b2.setLimit(64);
        ByteBufferManipulationTest.printBuffer(b2, "dup");
        ByteBufferManipulationTest.printBuffer(b1, "ori");
        var b3 = b1.slice();
        b3.setLimit(64);
        ByteBufferManipulationTest.printBuffer(b3, "sli");
        ByteBufferManipulationTest.printBuffer(b1, "ori");
    };
    constructor.printBuffer = function(bb, name) {
        System.out.println(name + "  pos: " + bb.position() + " lim: " + bb.limit() + " rem: " + bb.remaining() + " cap: " + bb.capacity());
    };
}, {}, {});
var ByteBufferManipulationTest = function() {};
ByteBufferManipulationTest = stjs.extend(ByteBufferManipulationTest, null, [], function(constructor, prototype) {
    prototype.test = function() {
        var bb = ByteBuffer.wrap(new Int8Array([0, 1, 2, 3, 4, 5]));
        bb.setLimit(3);
        var a = bb.array();
        Assert.assertEquals(6, a.length);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var TestByteBufferUtil = function() {};
TestByteBufferUtil = stjs.extend(TestByteBufferUtil, null, [], function(constructor, prototype) {
    prototype.testSearch = function() {
        var marker = new Int8Array([0, 0, 1]);
        var buf = ByteBuffer.wrap(new Int8Array([10, 11, 12, 0, 0, 0, 0, 0, 1, 53, 23, 13, 0, 0, 12, 0, 0, 1, 13, 0, 23, 0, 0, 23, 0, 0, 1, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 4]));
        Assert.assertArrayEquals(new Int8Array([10, 11, 12, 0, 0, 0]), NIOUtils.toArray(NIOUtils.search(buf, 0, marker)));
        Assert.assertArrayEquals(new Int8Array([0, 0, 1, 53, 23, 13, 0, 0, 12]), NIOUtils.toArray(NIOUtils.search(buf, 1, marker)));
        Assert.assertArrayEquals(new Int8Array([0, 0, 1, 13, 0, 23, 0, 0, 23]), NIOUtils.toArray(NIOUtils.search(buf, 1, marker)));
        Assert.assertArrayEquals(new Int8Array([0, 0, 1, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 4]), NIOUtils.toArray(NIOUtils.search(buf, 1, marker)));
    };
    prototype.testSliceVsPut = function() {
        var rawFrame = NIOUtils.fetchFromFile(new File("src/test/resources/mkv/single-frame01.vp8"));
        var newFrame = ByteBuffer.allocate(rawFrame.limit());
        var start = System.currentTimeMillis();
        for (var i = 0; i < 1.0E8; i++) {
            newFrame.putBuf(rawFrame);
            newFrame.flip();
        }
        System.out.println((System.currentTimeMillis() - start) + "ms for put");
        start = System.currentTimeMillis();
        for (var i = 0; i < 1.0E8; i++) {
            newFrame = rawFrame.slice();
        }
        System.out.println((System.currentTimeMillis() - start) + "ms for slice");
    };
}, {}, {});
var MacroblockI16x16DecodingTest = function() {};
MacroblockI16x16DecodingTest = stjs.extend(MacroblockI16x16DecodingTest, null, [], function(constructor, prototype) {
    prototype.testMBlockCABAC1 = function() {
        var es = new MappedH264ES(NIOUtils.fetchFromFile(new File("src/test/resources/h264/cabac/i16x16_1/16x16.264")));
        var data = es.nextFrame().getData();
        var buf = Picture8Bit.create(16, 16, ColorSpace.YUV420);
        var out = new H264Decoder().decodeFrame8Bit(data, buf.getData());
        var yuv = NIOUtils.fetchFromFile(new File("src/test/resources/h264/cabac/i16x16_1/16x16.yuv"));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 256)), out.getPlaneData(0));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 64)), out.getPlaneData(1));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 64)), out.getPlaneData(2));
    };
    prototype.testMBlockCABAC2 = function() {
        var es = new MappedH264ES(NIOUtils.fetchFromFile(new File("src/test/resources/h264/cabac/i16x16_2/32x32.264")));
        var data = es.nextFrame().getData();
        var buf = Picture8Bit.create(32, 32, ColorSpace.YUV420);
        var out = new H264Decoder().decodeFrame8Bit(data, buf.getData());
        var yuv = NIOUtils.fetchFromFile(new File("src/test/resources/h264/cabac/i16x16_2/32x32.yuv"));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 1024)), out.getPlaneData(0));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 256)), out.getPlaneData(1));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 256)), out.getPlaneData(2));
    };
    prototype.testMBlockCABAC3 = function() {
        var es = new MappedH264ES(NIOUtils.fetchFromFile(new File("src/test/resources/h264/cabac/i16x16_3/32x32.264")));
        var data = es.nextFrame().getData();
        var buf = Picture8Bit.create(32, 32, ColorSpace.YUV420);
        var out = new H264Decoder().decodeFrame8Bit(data, buf.getData());
        var yuv = NIOUtils.fetchFromFile(new File("src/test/resources/h264/cabac/i16x16_3/32x32.yuv"));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 1024)), out.getPlaneData(0));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 256)), out.getPlaneData(1));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 256)), out.getPlaneData(2));
    };
    prototype.testMBlockCABAC4 = function() {
        var es = new MappedH264ES(NIOUtils.fetchFromFile(new File("src/test/resources/h264/cabac/i16x16_4/32x32.264")));
        var data = es.nextFrame().getData();
        var buf = Picture8Bit.create(32, 32, ColorSpace.YUV420);
        var out = new H264Decoder().decodeFrame8Bit(data, buf.getData());
        var yuv = NIOUtils.fetchFromFile(new File("src/test/resources/h264/cabac/i16x16_4/32x32.yuv"));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 1024)), out.getPlaneData(0));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 256)), out.getPlaneData(1));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 256)), out.getPlaneData(2));
    };
    prototype.testMBlockCABAC5 = function() {
        var es = new MappedH264ES(NIOUtils.fetchFromFile(new File("src/test/resources/h264/cabac/i16x16_5/32x32.264")));
        var data = es.nextFrame().getData();
        var buf = Picture8Bit.create(32, 32, ColorSpace.YUV420);
        var out = new H264Decoder().decodeFrame8Bit(data, buf.getData());
        var yuv = NIOUtils.fetchFromFile(new File("src/test/resources/h264/cabac/i16x16_5/32x32.yuv"));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 1024)), out.getPlaneData(0));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 256)), out.getPlaneData(1));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 256)), out.getPlaneData(2));
    };
    prototype.testMBlockCAVLC = function() {
        var es = new MappedH264ES(NIOUtils.fetchFromFile(new File("src/test/resources/h264/cavlc/i16x16_420/16x16.264")));
        var data = es.nextFrame().getData();
        var buf = Picture8Bit.create(16, 16, ColorSpace.YUV420);
        var out = new H264Decoder().decodeFrame8Bit(data, buf.getData());
        var yuv = NIOUtils.fetchFromFile(new File("src/test/resources/h264/cavlc/i16x16_420/16x16.yuv"));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 256)), out.getPlaneData(0));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 64)), out.getPlaneData(1));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 64)), out.getPlaneData(2));
    };
    prototype.testMBlockCAVLC1 = function() {
        var es = new MappedH264ES(NIOUtils.fetchFromFile(new File("src/test/resources/h264/cavlc/i16x16_420_1/32x32_1.264")));
        var data = es.nextFrame().getData();
        var buf = Picture8Bit.create(32, 32, ColorSpace.YUV420);
        var out = new H264Decoder().decodeFrame8Bit(data, buf.getData());
        var yuv = NIOUtils.fetchFromFile(new File("src/test/resources/h264/cavlc/i16x16_420_1/32x32_1.yuv"));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 1024)), out.getPlaneData(0));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 256)), out.getPlaneData(1));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 256)), out.getPlaneData(2));
    };
    prototype.testMBlockCAVLC2 = function() {
        var es = new MappedH264ES(NIOUtils.fetchFromFile(new File("src/test/resources/h264/cavlc/i16x16_420_2/32x32_2.264")));
        var data = es.nextFrame().getData();
        var buf = Picture8Bit.create(32, 32, ColorSpace.YUV420);
        var out = new H264Decoder().decodeFrame8Bit(data, buf.getData());
        var yuv = NIOUtils.fetchFromFile(new File("src/test/resources/h264/cavlc/i16x16_420_2/32x32_2.yuv"));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 1024)), out.getPlaneData(0));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 256)), out.getPlaneData(1));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 256)), out.getPlaneData(2));
    };
    prototype.testMBlockCAVLC3 = function() {
        var es = new MappedH264ES(NIOUtils.fetchFromFile(new File("src/test/resources/h264/cavlc/i16x16_420_3/32x32_3.264")));
        var data = es.nextFrame().getData();
        var buf = Picture8Bit.create(32, 32, ColorSpace.YUV420);
        var out = new H264Decoder().decodeFrame8Bit(data, buf.getData());
        var yuv = NIOUtils.fetchFromFile(new File("src/test/resources/h264/cavlc/i16x16_420_3/32x32_3.yuv"));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 1024)), out.getPlaneData(0));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 256)), out.getPlaneData(1));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 256)), out.getPlaneData(2));
    };
    prototype.testMBlockCAVLC4 = function() {
        var es = new MappedH264ES(NIOUtils.fetchFromFile(new File("src/test/resources/h264/cavlc/i16x16_420_4/32x32_4.264")));
        var data = es.nextFrame().getData();
        var buf = Picture8Bit.create(32, 32, ColorSpace.YUV420);
        var out = new H264Decoder().decodeFrame8Bit(data, buf.getData());
        var yuv = NIOUtils.fetchFromFile(new File("src/test/resources/h264/cavlc/i16x16_420_4/32x32_4.yuv"));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 1024)), out.getPlaneData(0));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 256)), out.getPlaneData(1));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 256)), out.getPlaneData(2));
    };
    prototype.getAsIntArray = function(yuv, size) {
        var b = new Int8Array(size);
        var result = new Int32Array(size);
        yuv.getBuf(b);
        for (var i = 0; i < b.length; i++) {
            result[i] = b[i] & 255;
        }
        return result;
    };
}, {}, {});
var MBlock8x8Test = function() {};
MBlock8x8Test = stjs.extend(MBlock8x8Test, null, [], function(constructor, prototype) {
    prototype.testMBlockCABACStrict1 = function() {
        var es = new MappedH264ES(NIOUtils.fetchFromFile(new File("src/test/resources/h264/cabac/i8x8/64x64_1.264")));
        var data = es.nextFrame().getData();
        var buf = Picture8Bit.create(64, 64, ColorSpace.YUV420);
        var out = new H264Decoder().decodeFrame8Bit(data, buf.getData());
        var yuv = NIOUtils.fetchFromFile(new File("src/test/resources/h264/cabac/i8x8/64x64_1_dec.yuv"));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 4096)), out.getPlaneData(0));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 1024)), out.getPlaneData(1));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 1024)), out.getPlaneData(2));
    };
    prototype.testMBlockCABACStrict2 = function() {
        var es = new MappedH264ES(NIOUtils.fetchFromFile(new File("src/test/resources/h264/cabac/i8x8/64x64_2.264")));
        var data = es.nextFrame().getData();
        var buf = Picture8Bit.create(64, 64, ColorSpace.YUV420);
        var out = new H264Decoder().decodeFrame8Bit(data, buf.getData());
        var yuv = NIOUtils.fetchFromFile(new File("src/test/resources/h264/cabac/i8x8/64x64_2_dec.yuv"));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 4096)), out.getPlaneData(0));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 1024)), out.getPlaneData(1));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 1024)), out.getPlaneData(2));
    };
    prototype.testMBlockCABACStrict3 = function() {
        var es = new MappedH264ES(NIOUtils.fetchFromFile(new File("src/test/resources/h264/cabac/i8x8/64x64_3.264")));
        var data = es.nextFrame().getData();
        var buf = Picture8Bit.create(64, 64, ColorSpace.YUV420);
        var out = new H264Decoder().decodeFrame8Bit(data, buf.getData());
        var yuv = NIOUtils.fetchFromFile(new File("src/test/resources/h264/cabac/i8x8/64x64_3_dec.yuv"));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 4096)), out.getPlaneData(0));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 1024)), out.getPlaneData(1));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 1024)), out.getPlaneData(2));
    };
    prototype.testMBlockCABACStrict4 = function() {
        var es = new MappedH264ES(NIOUtils.fetchFromFile(new File("src/test/resources/h264/cabac/i8x8/64x64_4.264")));
        var data = es.nextFrame().getData();
        var buf = Picture8Bit.create(64, 64, ColorSpace.YUV420);
        var out = new H264Decoder().decodeFrame8Bit(data, buf.getData());
        var yuv = NIOUtils.fetchFromFile(new File("src/test/resources/h264/cabac/i8x8/64x64_4_dec.yuv"));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 4096)), out.getPlaneData(0));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 1024)), out.getPlaneData(1));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 1024)), out.getPlaneData(2));
    };
    prototype.testMBlockCAVLCStrict1 = function() {
        var es = new MappedH264ES(NIOUtils.fetchFromFile(new File("src/test/resources/h264/cavlc/i8x8/64x64_1.264")));
        var data = es.nextFrame().getData();
        var buf = Picture8Bit.create(64, 64, ColorSpace.YUV420);
        var out = new H264Decoder().decodeFrame8Bit(data, buf.getData());
        var yuv = NIOUtils.fetchFromFile(new File("src/test/resources/h264/cavlc/i8x8/64x64_1_dec.yuv"));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 4096)), out.getPlaneData(0));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 1024)), out.getPlaneData(1));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 1024)), out.getPlaneData(2));
    };
    prototype.testMBlockCAVLCStrict2 = function() {
        var es = new MappedH264ES(NIOUtils.fetchFromFile(new File("src/test/resources/h264/cavlc/i8x8/64x64_2.264")));
        var data = es.nextFrame().getData();
        var buf = Picture8Bit.create(64, 64, ColorSpace.YUV420);
        var out = new H264Decoder().decodeFrame8Bit(data, buf.getData());
        var yuv = NIOUtils.fetchFromFile(new File("src/test/resources/h264/cavlc/i8x8/64x64_2_dec.yuv"));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 4096)), out.getPlaneData(0));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 1024)), out.getPlaneData(1));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 1024)), out.getPlaneData(2));
    };
    prototype.testMBlockCAVLCStrict3 = function() {
        var es = new MappedH264ES(NIOUtils.fetchFromFile(new File("src/test/resources/h264/cavlc/i8x8/64x64_3.264")));
        var data = es.nextFrame().getData();
        var buf = Picture8Bit.create(64, 64, ColorSpace.YUV420);
        var out = new H264Decoder().decodeFrame8Bit(data, buf.getData());
        var yuv = NIOUtils.fetchFromFile(new File("src/test/resources/h264/cavlc/i8x8/64x64_3_dec.yuv"));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 4096)), out.getPlaneData(0));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 1024)), out.getPlaneData(1));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 1024)), out.getPlaneData(2));
    };
    prototype.testMBlockCAVLCStrict4 = function() {
        var es = new MappedH264ES(NIOUtils.fetchFromFile(new File("src/test/resources/h264/cavlc/i8x8/64x64_4.264")));
        var data = es.nextFrame().getData();
        var buf = Picture8Bit.create(64, 64, ColorSpace.YUV420);
        var out = new H264Decoder().decodeFrame8Bit(data, buf.getData());
        var yuv = NIOUtils.fetchFromFile(new File("src/test/resources/h264/cavlc/i8x8/64x64_4_dec.yuv"));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 4096)), out.getPlaneData(0));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 1024)), out.getPlaneData(1));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 1024)), out.getPlaneData(2));
    };
    prototype.getAsIntArray = function(yuv, size) {
        var b = new Int8Array(size);
        var result = new Int32Array(size);
        yuv.getBuf(b);
        for (var i = 0; i < b.length; i++) {
            result[i] = b[i] & 255;
        }
        return result;
    };
}, {}, {});
var MacroblockINxNDecodingTest = function() {};
MacroblockINxNDecodingTest = stjs.extend(MacroblockINxNDecodingTest, null, [], function(constructor, prototype) {
    prototype.testMBlockCABAC1 = function() {
        var es = new MappedH264ES(NIOUtils.fetchFromFile(new File("src/test/resources/h264/cabac/iNxN_1/16x16.264")));
        var data = es.nextFrame().getData();
        var buf = Picture8Bit.create(16, 16, ColorSpace.YUV420);
        var out = new H264Decoder().decodeFrame8Bit(data, buf.getData());
        var yuv = NIOUtils.fetchFromFile(new File("src/test/resources/h264/cabac/iNxN_1/16x16.yuv"));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 256)), out.getPlaneData(0));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 64)), out.getPlaneData(1));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 64)), out.getPlaneData(2));
    };
    prototype.testMBlockCABAC2 = function() {
        var es = new MappedH264ES(NIOUtils.fetchFromFile(new File("src/test/resources/h264/cabac/iNxN_2/32x32_1.264")));
        var data = es.nextFrame().getData();
        var buf = Picture8Bit.create(32, 32, ColorSpace.YUV420);
        var out = new H264Decoder().decodeFrame8Bit(data, buf.getData());
        var yuv = NIOUtils.fetchFromFile(new File("src/test/resources/h264/cabac/iNxN_2/32x32_1.yuv"));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 1024)), out.getPlaneData(0));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 256)), out.getPlaneData(1));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 256)), out.getPlaneData(2));
    };
    prototype.testMBlockCABAC3 = function() {
        var es = new MappedH264ES(NIOUtils.fetchFromFile(new File("src/test/resources/h264/cabac/iNxN_3/32x32_2.264")));
        var data = es.nextFrame().getData();
        var buf = Picture8Bit.create(32, 32, ColorSpace.YUV420);
        var out = new H264Decoder().decodeFrame8Bit(data, buf.getData());
        var yuv = NIOUtils.fetchFromFile(new File("src/test/resources/h264/cabac/iNxN_3/32x32_2.yuv"));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 1024)), out.getPlaneData(0));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 256)), out.getPlaneData(1));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 256)), out.getPlaneData(2));
    };
    prototype.testMBlockCABAC4 = function() {
        var es = new MappedH264ES(NIOUtils.fetchFromFile(new File("src/test/resources/h264/cabac/iNxN_4/32x32_3.264")));
        var data = es.nextFrame().getData();
        var buf = Picture8Bit.create(32, 32, ColorSpace.YUV420);
        var out = new H264Decoder().decodeFrame8Bit(data, buf.getData());
        var yuv = NIOUtils.fetchFromFile(new File("src/test/resources/h264/cabac/iNxN_4/32x32_3.yuv"));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 1024)), out.getPlaneData(0));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 256)), out.getPlaneData(1));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 256)), out.getPlaneData(2));
    };
    prototype.testMBlockCABAC5 = function() {
        var es = new MappedH264ES(NIOUtils.fetchFromFile(new File("src/test/resources/h264/cabac/iNxN_5/32x32_4.264")));
        var data = es.nextFrame().getData();
        var buf = Picture8Bit.create(32, 32, ColorSpace.YUV420);
        var out = new H264Decoder().decodeFrame8Bit(data, buf.getData());
        var yuv = NIOUtils.fetchFromFile(new File("src/test/resources/h264/cabac/iNxN_5/32x32_4.yuv"));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 1024)), out.getPlaneData(0));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 256)), out.getPlaneData(1));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 256)), out.getPlaneData(2));
    };
    prototype.testMBlockCAVLC = function() {
        var es = new MappedH264ES(NIOUtils.fetchFromFile(new File("src/test/resources/h264/cavlc/iNxN_1/16x16.264")));
        var data = es.nextFrame().getData();
        var buf = Picture8Bit.create(16, 16, ColorSpace.YUV420);
        var out = new H264Decoder().decodeFrame8Bit(data, buf.getData());
        var yuv = NIOUtils.fetchFromFile(new File("src/test/resources/h264/cavlc/iNxN_1/16x16.yuv"));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 256)), out.getPlaneData(0));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 64)), out.getPlaneData(1));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 64)), out.getPlaneData(2));
    };
    prototype.testMBlockCAVLC1 = function() {
        var es = new MappedH264ES(NIOUtils.fetchFromFile(new File("src/test/resources/h264/cavlc/iNxN_2/32x32_1.264")));
        var data = es.nextFrame().getData();
        var buf = Picture8Bit.create(32, 32, ColorSpace.YUV420);
        var out = new H264Decoder().decodeFrame8Bit(data, buf.getData());
        var yuv = NIOUtils.fetchFromFile(new File("src/test/resources/h264/cavlc/iNxN_2/32x32_1.yuv"));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 1024)), out.getPlaneData(0));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 256)), out.getPlaneData(1));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 256)), out.getPlaneData(2));
    };
    prototype.testMBlockCAVLC2 = function() {
        var es = new MappedH264ES(NIOUtils.fetchFromFile(new File("src/test/resources/h264/cavlc/iNxN_3/32x32_2.264")));
        var data = es.nextFrame().getData();
        var buf = Picture8Bit.create(32, 32, ColorSpace.YUV420);
        var out = new H264Decoder().decodeFrame8Bit(data, buf.getData());
        var yuv = NIOUtils.fetchFromFile(new File("src/test/resources/h264/cavlc/iNxN_3/32x32_2.yuv"));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 1024)), out.getPlaneData(0));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 256)), out.getPlaneData(1));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 256)), out.getPlaneData(2));
    };
    prototype.testMBlockCAVLC3 = function() {
        var es = new MappedH264ES(NIOUtils.fetchFromFile(new File("src/test/resources/h264/cavlc/iNxN_4/32x32_3.264")));
        var data = es.nextFrame().getData();
        var buf = Picture8Bit.create(32, 32, ColorSpace.YUV420);
        var out = new H264Decoder().decodeFrame8Bit(data, buf.getData());
        var yuv = NIOUtils.fetchFromFile(new File("src/test/resources/h264/cavlc/iNxN_4/32x32_3.yuv"));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 1024)), out.getPlaneData(0));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 256)), out.getPlaneData(1));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 256)), out.getPlaneData(2));
    };
    prototype.testMBlockCAVLC4 = function() {
        var es = new MappedH264ES(NIOUtils.fetchFromFile(new File("src/test/resources/h264/cavlc/iNxN_5/32x32_4.264")));
        var data = es.nextFrame().getData();
        var buf = Picture8Bit.create(32, 32, ColorSpace.YUV420);
        var out = new H264Decoder().decodeFrame8Bit(data, buf.getData());
        var yuv = NIOUtils.fetchFromFile(new File("src/test/resources/h264/cavlc/iNxN_5/32x32_4.yuv"));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 1024)), out.getPlaneData(0));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 256)), out.getPlaneData(1));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 256)), out.getPlaneData(2));
    };
    prototype.getAsIntArray = function(yuv, size) {
        var b = new Int8Array(size);
        var result = new Int32Array(size);
        yuv.getBuf(b);
        for (var i = 0; i < b.length; i++) {
            result[i] = b[i] & 255;
        }
        return result;
    };
}, {}, {});
var IntDCTTest = function() {};
IntDCTTest = stjs.extend(IntDCTTest, null, [], function(constructor, prototype) {
    prototype.testPerformance = function() {
        var input = new Int32Array([-416, -33, -60, 32, 48, -40, 0, 0, 0, -24, -56, 19, 26, 0, 0, 0, -42, 13, 80, -24, -40, 0, 0, 0, -56, 17, 44, -29, 0, 0, 0, 0, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
        var dct = new IntDCT();
        var count = 40000000;
        var ws = IntBuffer.allocate(64);
        var out = IntBuffer.allocate(64);
        var inptr = IntBuffer.wrap(input);
        var start = System.currentTimeMillis();
        for (var i = 0; i < count; i++) {
            ws.clear();
            out.clear();
            inptr.clear();
            dct.doDecode(inptr, ws, out);
        }
        var time = System.currentTimeMillis() - start;
        var kdctPerSec = stjs.trunc(count / time);
        System.out.println(kdctPerSec + "kdct/sec");
    };
    prototype.testRangeLimit = function() {
        Assert.assertEquals(-128 & 255, IntDCT.range_limit(0));
        Assert.assertEquals(-127 & 255, IntDCT.range_limit(1));
        Assert.assertEquals(-1 & 255, IntDCT.range_limit(133));
        Assert.assertEquals(126, IntDCT.range_limit(1022));
        for (var i = -256; i < 1024; i++) {
            System.out.printf("range_limit(%4d) == %4d\n", i, IntDCT.range_limit(i));
        }
    };
    prototype.testDescale = function() {
        Assert.assertEquals(-4063, IntDCT.DESCALE(-8321313, 11));
        Assert.assertEquals(18, IntDCT.DESCALE(36362, 11));
    };
}, {}, {});
var MacroblockIntraMixedDecodingTest = function() {};
MacroblockIntraMixedDecodingTest = stjs.extend(MacroblockIntraMixedDecodingTest, null, [], function(constructor, prototype) {
    prototype.testMBlockCABAC1 = function() {
        var es = new MappedH264ES(NIOUtils.fetchFromFile(new File("src/test/resources/h264/cabac/mixed_1/64x64_1.264")));
        var data = es.nextFrame().getData();
        var buf = Picture8Bit.create(64, 64, ColorSpace.YUV420);
        var out = new H264Decoder().decodeFrame8Bit(data, buf.getData());
        var yuv = NIOUtils.fetchFromFile(new File("src/test/resources/h264/cabac/mixed_1/64x64_1.yuv"));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 4096)), out.getPlaneData(0));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 1024)), out.getPlaneData(1));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 1024)), out.getPlaneData(2));
    };
    prototype.testMBlockCABAC2 = function() {
        var es = new MappedH264ES(NIOUtils.fetchFromFile(new File("src/test/resources/h264/cabac/mixed_2/64x64_2.264")));
        var data = es.nextFrame().getData();
        var buf = Picture8Bit.create(64, 64, ColorSpace.YUV420);
        var out = new H264Decoder().decodeFrame8Bit(data, buf.getData());
        var yuv = NIOUtils.fetchFromFile(new File("src/test/resources/h264/cabac/mixed_2/64x64_2.yuv"));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 4096)), out.getPlaneData(0));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 1024)), out.getPlaneData(1));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 1024)), out.getPlaneData(2));
    };
    prototype.testMBlockCABAC3 = function() {
        var es = new MappedH264ES(NIOUtils.fetchFromFile(new File("src/test/resources/h264/cabac/mixed_3/64x64_3.264")));
        var data = es.nextFrame().getData();
        var buf = Picture8Bit.create(64, 64, ColorSpace.YUV420);
        var out = new H264Decoder().decodeFrame8Bit(data, buf.getData());
        var yuv = NIOUtils.fetchFromFile(new File("src/test/resources/h264/cabac/mixed_3/64x64_3.yuv"));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 4096)), out.getPlaneData(0));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 1024)), out.getPlaneData(1));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 1024)), out.getPlaneData(2));
    };
    prototype.testMBlockCABAC4 = function() {
        var es = new MappedH264ES(NIOUtils.fetchFromFile(new File("src/test/resources/h264/cabac/mixed_4/64x64_4.264")));
        var data = es.nextFrame().getData();
        var buf = Picture8Bit.create(64, 64, ColorSpace.YUV420);
        var out = new H264Decoder().decodeFrame8Bit(data, buf.getData());
        var yuv = NIOUtils.fetchFromFile(new File("src/test/resources/h264/cabac/mixed_4/64x64_4.yuv"));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 4096)), out.getPlaneData(0));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 1024)), out.getPlaneData(1));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 1024)), out.getPlaneData(2));
    };
    prototype.testMBlockCAVLC1 = function() {
        var es = new MappedH264ES(NIOUtils.fetchFromFile(new File("src/test/resources/h264/cavlc/mixed_1/64x64_1.264")));
        var data = es.nextFrame().getData();
        var buf = Picture8Bit.create(64, 64, ColorSpace.YUV420);
        var out = new H264Decoder().decodeFrame8Bit(data, buf.getData());
        var yuv = NIOUtils.fetchFromFile(new File("src/test/resources/h264/cavlc/mixed_1/64x64_1.yuv"));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 4096)), out.getPlaneData(0));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 1024)), out.getPlaneData(1));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 1024)), out.getPlaneData(2));
    };
    prototype.testMBlockCAVLC2 = function() {
        var es = new MappedH264ES(NIOUtils.fetchFromFile(new File("src/test/resources/h264/cavlc/mixed_2/64x64_2.264")));
        var data = es.nextFrame().getData();
        var buf = Picture8Bit.create(64, 64, ColorSpace.YUV420);
        var out = new H264Decoder().decodeFrame8Bit(data, buf.getData());
        var yuv = NIOUtils.fetchFromFile(new File("src/test/resources/h264/cavlc/mixed_2/64x64_2.yuv"));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 4096)), out.getPlaneData(0));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 1024)), out.getPlaneData(1));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 1024)), out.getPlaneData(2));
    };
    prototype.testMBlockCAVLC3 = function() {
        var es = new MappedH264ES(NIOUtils.fetchFromFile(new File("src/test/resources/h264/cavlc/mixed_3/64x64_3.264")));
        var data = es.nextFrame().getData();
        var buf = Picture8Bit.create(64, 64, ColorSpace.YUV420);
        var out = new H264Decoder().decodeFrame8Bit(data, buf.getData());
        var yuv = NIOUtils.fetchFromFile(new File("src/test/resources/h264/cavlc/mixed_3/64x64_3.yuv"));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 4096)), out.getPlaneData(0));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 1024)), out.getPlaneData(1));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 1024)), out.getPlaneData(2));
    };
    prototype.testMBlockCAVLC4 = function() {
        var es = new MappedH264ES(NIOUtils.fetchFromFile(new File("src/test/resources/h264/cavlc/mixed_4/64x64_4.264")));
        var data = es.nextFrame().getData();
        var buf = Picture8Bit.create(64, 64, ColorSpace.YUV420);
        var out = new H264Decoder().decodeFrame8Bit(data, buf.getData());
        var yuv = NIOUtils.fetchFromFile(new File("src/test/resources/h264/cavlc/mixed_4/64x64_4.yuv"));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 4096)), out.getPlaneData(0));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 1024)), out.getPlaneData(1));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 1024)), out.getPlaneData(2));
    };
    prototype.testMBlockShit = function() {
        var es = new MappedH264ES(NIOUtils.fetchFromFile(new File("src/test/resources/h264/cabac/random_1/random_1.264")));
        var data = es.nextFrame().getData();
        var buf = Picture8Bit.create(480, 272, ColorSpace.YUV420);
        var out = new H264Decoder().decodeFrame8Bit(data, buf.getData());
        var yuv = NIOUtils.fetchFromFile(new File("src/test/resources/h264/cabac/random_1/random_1.yuv"));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 129600)), Platform.copyOfRangeB(out.getPlaneData(0), 0, 129600));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 32400)), Platform.copyOfRangeB(out.getPlaneData(1), 0, 32400));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(this.getAsIntArray(yuv, 32400)), Platform.copyOfRangeB(out.getPlaneData(2), 0, 32400));
    };
    prototype.getAsIntArray = function(yuv, size) {
        var b = new Int8Array(size);
        var result = new Int32Array(size);
        yuv.getBuf(b);
        for (var i = 0; i < b.length; i++) {
            result[i] = b[i] & 255;
        }
        return result;
    };
}, {}, {});
var MP4DemuxerTest = function() {};
MP4DemuxerTest = stjs.extend(MP4DemuxerTest, null, [], function(constructor, prototype) {
    prototype.testAudioTrack = function() {
        var resource = Platform.getResource(this.getClass(), "37.mp4");
        System.out.println(resource);
        var source = new File(resource.getFile());
        var input = new AutoFileChannelWrapper(source);
        var demuxer = new MP4Demuxer(input);
        var track = demuxer.getAudioTracks().get(0);
        var packet;
         while (null != (packet = track.nextFrame())){
            var data = packet.getData();
        }
    };
}, {}, {});
var MPEGESTest = function() {};
MPEGESTest = stjs.extend(MPEGESTest, null, [], function(constructor, prototype) {
    prototype.testES = function() {
        var mpeg = MPEGTestConst.mpeg();
        var frame1 = MPEGTestConst.toBB(MPEGTestConst._mpegHeader, MPEGTestConst._mpegFrame);
        var frame2 = MPEGTestConst.toBB(MPEGTestConst._mpegFrame);
        var mpeges = new MPEGES(Channels.newChannel(new ByteArrayInputStream(mpeg)), 32);
        var buf = ByteBuffer.allocate(1024);
        var f1 = mpeges.getFrame(buf);
        Assert.assertArrayEquals(frame1, NIOUtils.toArray(f1.getData()));
        var f2 = mpeges.getFrame(buf);
        Assert.assertArrayEquals(frame1, NIOUtils.toArray(f2.getData()));
        var f3 = mpeges.getFrame(buf);
        Assert.assertArrayEquals(frame2, NIOUtils.toArray(f3.getData()));
    };
}, {}, {});
var EbmlFloatTest = function() {};
EbmlFloatTest = stjs.extend(EbmlFloatTest, null, [], function(constructor, prototype) {
    prototype.test = function() {
        var durationElem = MKVType.createByType(MKVType.Duration);
        durationElem.setDouble(5 * 1000.0);
        Assert.assertEquals(5000.0, durationElem.getDouble(), 1.0E-4);
    };
}, {}, {});
var CoeffTransformerTest = function() {};
CoeffTransformerTest = stjs.extend(CoeffTransformerTest, null, [], function(constructor, prototype) {
    prototype.testDCT = function() {
        var coeffs = new Int32Array([2560, -4160, -2816, -1920, 960, -1200, 320, 0, 768, -640, -512, 320, 0, 0, 0, 0]);
        var expected = new Int32Array([-86, 92, 136, 126, -80, 72, 66, 84, -81, 71, 47, 45, -89, 91, 97, 49]);
        CoeffTransformer.idct4x4(coeffs);
        Assert.assertArrayEquals(expected, coeffs);
    };
    prototype.testHadamard = function() {
        var coeffs = new Int32Array([61, -11, -13, -14, 9, -4, -2, 2, -12, 6, 6, 4, 8, 1, -2, 2]);
        var expected = new Int32Array([41, 75, 79, 69, 15, 89, 97, 95, 23, 97, 85, 83, 13, 47, 23, 45]);
        CoeffTransformer.invDC4x4(coeffs);
        Assert.assertArrayEquals(expected, coeffs);
    };
    prototype.testRescaleAfterIHadamard4x4 = function() {
        var coeffs = new Int32Array([41, 75, 79, 69, 15, 89, 97, 95, 23, 97, 85, 83, 13, 47, 23, 45]);
        var expected = new Int32Array([2624, 4800, 5056, 4416, 960, 5696, 6208, 6080, 1472, 6208, 5440, 5312, 832, 3008, 1472, 2880]);
        CoeffTransformer.dequantizeDC4x4(coeffs, 28);
        Assert.assertArrayEquals(expected, coeffs);
    };
    prototype.testRescaleBeforeIDCT4x4 = function() {
        var coeffs = new Int32Array([10, -13, -11, -6, 3, -3, 1, 0, 3, -2, -2, 1, 0, 0, 0, 0]);
        var expected = new Int32Array([2560, -4160, -2816, -1920, 960, -1200, 320, 0, 768, -640, -512, 320, 0, 0, 0, 0]);
        CoeffTransformer.dequantizeAC(coeffs, 28);
        Assert.assertArrayEquals(expected, coeffs);
    };
    prototype.testReorder = function() {
        var coeffs = new Int32Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);
        var expected = new Int32Array([0, 1, 5, 6, 2, 4, 7, 12, 3, 8, 11, 13, 9, 10, 14, 15]);
        var reordered = CoeffTransformer.unzigzagAC(coeffs);
        Assert.assertArrayEquals(expected, reordered);
    };
    prototype.testQuantizeDC4x4 = function() {
        var dc = new Int32Array([1765, -3340, 1340, -3432, 1435, -4056, 6743, -2454, 3432, -1234, 7643, -1432, 1654, -5643, 2345, -1786]);
        var expected = new Int32Array([11, -21, 8, -21, 9, -25, 42, -15, 21, -8, 48, -9, 10, -35, 14, -11]);
        CoeffTransformer.quantizeDC4x4(dc, 30);
        Assert.assertArrayEquals(expected, dc);
    };
    prototype.testQuantizeAC = function() {
        var dc = new Int32Array([0, 573, 232, 123, 402, 123, 754, 74, 12, 15, 13, 12, 14, 15, 43, 57]);
        var expected = new Int32Array([0, 4, 3, 1, 3, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
        CoeffTransformer.quantizeAC(dc, 30);
        Assert.assertArrayEquals(expected, dc);
    };
    prototype.testQuantizeDC2x2 = function() {
        var dc = new Int32Array([1765, -3340, 1435, -4056]);
        var expected = new Int32Array([11, -21, 9, -25]);
        CoeffTransformer.quantizeDC2x2(dc, 30);
        Assert.assertArrayEquals(expected, dc);
    };
}, {}, {});
/**
 *  
 *  Reads raw yuv file
 *  
 *  @author Jay Codec
 *  
 */
var RawReader8Bit = function(rawFile, width, height) {
    this.rawFileName = rawFile;
    this.width = width;
    this.height = height;
};
RawReader8Bit = stjs.extend(RawReader8Bit, null, [], function(constructor, prototype) {
    prototype.rawFileName = null;
    prototype.width = 0;
    prototype.height = 0;
    prototype.is = null;
    prototype.readNextFrame = function() {
        if (this.is == null) {
            this.is = new BufferedInputStream(new FileInputStream(this.rawFileName));
            if (this.is == null) 
                return null;
        }
        return this.readFrame();
    };
    prototype.readFrame = function() {
        var size = this.width * this.height;
        var luma = new Int8Array(size);
        var cb = new Int8Array(size >> 2);
        var cr = new Int8Array(size >> 2);
        var first = this.is.read();
        if (first == -1) 
            return null;
        luma[0] = (first << 24 >> 24);
        for (var i = 1; i < size; i++) {
            luma[i] = (this.is.read() << 24 >> 24);
        }
        for (var i = 0; i < (size >> 2); i++) {
            cb[i] = (this.is.read() << 24 >> 24);
        }
        for (var i = 0; i < (size >> 2); i++) {
            cr[i] = (this.is.read() << 24 >> 24);
        }
        return Picture8Bit.createPicture8Bit(this.width, this.height, [luma, cb, cr], ColorSpace.YUV420);
    };
}, {rawFileName: "File", is: "InputStream"}, {});
/**
 *  
 *  Reads raw yuv file
 *  
 *  @author Jay Codec
 *  
 */
var RawReader = function(rawFile, width, height) {
    this.rawFileName = rawFile;
    this.width = width;
    this.height = height;
};
RawReader = stjs.extend(RawReader, null, [], function(constructor, prototype) {
    prototype.rawFileName = null;
    prototype.width = 0;
    prototype.height = 0;
    prototype.is = null;
    prototype.readNextFrame8Bit = function() {
        if (this.is == null) {
            this.is = new BufferedInputStream(new FileInputStream(this.rawFileName));
            if (this.is == null) 
                return null;
        }
        return this.readFrame();
    };
    prototype.readFrame = function() {
        var size = this.width * this.height;
        var luma = new Int8Array(size);
        var cb = new Int8Array(size >> 2);
        var cr = new Int8Array(size >> 2);
        var first = ((this.is.read() - 128) << 24 >> 24);
        if (first == -1) 
            return null;
        luma[0] = first;
        for (var i = 1; i < size; i++) {
            luma[i] = ((this.is.read() - 128) << 24 >> 24);
        }
        for (var i = 0; i < (size >> 2); i++) {
            cb[i] = ((this.is.read() - 128) << 24 >> 24);
        }
        for (var i = 0; i < (size >> 2); i++) {
            cr[i] = ((this.is.read() - 128) << 24 >> 24);
        }
        return Picture8Bit.createPicture8Bit(this.width, this.height, [luma, cb, cr], ColorSpace.YUV420);
    };
}, {rawFileName: "File", is: "InputStream"}, {});
var PerformanceTest = function() {};
PerformanceTest = stjs.extend(PerformanceTest, null, [], function(constructor, prototype) {
    prototype.testNoContainer = function() {
        var dir = "src/test/resources/video/seq_h264_4";
        var info = Platform.stringFromBytes(this.readFile(dir + "/info.txt").array());
        var width = Integer.parseInt(info.split(" ")[0]);
        var height = Integer.parseInt(info.split(" ")[1]);
        var frameCount = Integer.parseInt(info.split(" ")[2]);
        var picData = Picture8Bit.create(width, height, ColorSpace.YUV420J).getData();
        var decoder = new H264Decoder();
        decoder.addSps(Collections.singletonList(this.readFile(dir + "/sps")));
        decoder.addPps(Collections.singletonList(this.readFile(dir + "/pps")));
        var frames = new ArrayList();
        for (var fn = 0; fn < frameCount; fn++) {
            var buf = this.readFile(dir + "/" + this.zeroPad3(fn));
            frames.add(this.extractNALUnits(buf));
        }
        for (var i = 1, warmUpIterations = 5; i <= warmUpIterations; i++) {
            System.out.println("warming up " + i + "/" + warmUpIterations);
            for (var fn = 0; fn < frameCount; fn++) 
                decoder.decodeFrame8BitFromNals(this.duplicateBuffers(frames.get(fn)), picData);
        }
        var fpss = 0;
        var iterations = 5;
        for (var i = 1; i <= iterations; i++) {
            System.out.println("benchmarking " + i + "/" + iterations);
            var t = System.currentTimeMillis();
            for (var fn = 0; fn < frameCount; fn++) 
                decoder.decodeFrame8BitFromNals(this.duplicateBuffers(frames.get(fn)), picData);
            t = System.currentTimeMillis() - t;
            var fps = stjs.trunc(frames.size() * 1000 / t);
            System.out.println(fps + " fps");
            fpss += fps;
        }
        System.out.println("\naverage: " + (stjs.trunc(fpss / iterations)) + " fps");
    };
    prototype.readFile = function(path) {
        var file = new File(path);
        var _in = new BufferedInputStream(new FileInputStream(file));
        var buf = new Int8Array(((file.length()) | 0));
        _in.read(buf);
        _in.close();
        return ByteBuffer.wrap(buf);
    };
    prototype.zeroPad3 = function(n) {
        var s = n + "";
         while (s.length < 3)
            s = "0" + s;
        return s;
    };
    prototype.extractNALUnits = function(buf) {
        buf = buf.duplicate();
        var nalUnits = new ArrayList();
         while (buf.remaining() > 4){
            var length = buf.getInt();
            var nalUnit = ByteBuffer.allocate(length);
            for (var i = 0; i < length; i++) {
                nalUnit.put(buf.get());
            }
            nalUnit.flip();
            nalUnits.add(nalUnit);
        }
        return nalUnits;
    };
    prototype.duplicateBuffers = function(bufs) {
        var result = new ArrayList();
        for (var iterator$buf = bufs.iterator(); iterator$buf.hasNext(); ) {
            var buf = iterator$buf.next();
            result.add(buf.duplicate());
        }
        return result;
    };
}, {}, {});
var TestBitstreamWriter = function() {};
TestBitstreamWriter = stjs.extend(TestBitstreamWriter, null, [], function(constructor, prototype) {
    prototype.testWrite = function() {
        var buf = ByteBuffer.allocate(1024);
        var bw = new BitWriter(buf);
        bw.writeNBit(1, 1);
        bw.writeNBit(12345, 16);
        bw.writeNBit(85412, 15);
        bw.writeNBit(452688, 20);
        bw.writeNBit(25274, 15);
        bw.flush();
        buf.flip();
        Assert.assertArrayEquals(new Int8Array([(Short.parseShort("10011000", 2) << 24 >> 24), (Short.parseShort("00011100", 2) << 24 >> 24), (Short.parseShort("11001101", 2) << 24 >> 24), (Short.parseShort("10100100", 2) << 24 >> 24), (Short.parseShort("01101110", 2) << 24 >> 24), (Short.parseShort("10000101", 2) << 24 >> 24), (Short.parseShort("00001100", 2) << 24 >> 24), (Short.parseShort("01010111", 2) << 24 >> 24), (Short.parseShort("01000000", 2) << 24 >> 24)]), NIOUtils.toArray(buf));
    };
    prototype.testWrite1Bit = function() {
        var buf = ByteBuffer.allocate(1024);
        var bw = new BitWriter(buf.duplicate());
        bw.write1Bit(1);
        bw.flush();
        var dst = new Int8Array(4);
        buf.getBuf(dst);
        for (var i = 0; i < dst.length; i++) {
            System.out.println(String.format("%02x", dst[i] & 255));
        }
    };
}, {}, {});
var TestVLC = function() {};
TestVLC = stjs.extend(TestVLC, null, [], function(constructor, prototype) {
    constructor.codes = ["101111110001", "1000000", "101111100101", "1000001", "101111110100", "1000010", "101111101011", "1000101", "1001000", "1001001", "101111101010", "1011000", "1001100", "1001101", "101111100100", "1001110", "101111110101", "1001111", "11", "1010001", "101111100110", "1010010", "1010011", "1011111111101", "1010101", "0", "101111111010", "1010110", "1010111", "101111111000", "101111100111", "1000011", "1011001", "101111100010", "1011111111111", "101111111101", "1011101", "101111100000", "1011111111110", "101111100001", "1000100", "101111100011", "1000111", "101111101100", "1011011", "101111101000", "1010000", "101111101001", "101111101101", "1000110", "101111101110", "101111101111", "1001011", "101111110000", "101111110011", "1001010", "1011010", "101111110110", "101111110111", "1010100", "101111111001", "101111111011", "1011100", "101111111100", "1011111111100", "1011110", "101111110010"];
    prototype.testVLC1 = function() {
        var vlc = VLC.createVLC(TestVLC.codes);
        for (var i = 0; i < TestVLC.codes.length; i++) {
            var buf = ByteBuffer.allocate(1024);
            var out = new BitWriter(buf);
            vlc.writeVLC(out, i);
            out.flush();
            buf.flip();
            var _in = BitReader.createBitReader(buf);
            var readVLC = vlc.readVLC(_in);
            Assert.assertEquals(readVLC, i);
        }
    };
    prototype.testVLC2 = function() {
        var vlc = VLC.createVLC(TestVLC.codes);
        var buf = ByteBuffer.allocate(1024);
        var out = new BitWriter(buf);
        for (var i = 0; i < TestVLC.codes.length; i++) {
            vlc.writeVLC(out, i);
        }
        out.flush();
        buf.flip();
        var _in = BitReader.createBitReader(buf);
        for (var i = 0; i < TestVLC.codes.length; i++) {
            Assert.assertEquals(i, vlc.readVLC(_in));
        }
    };
    prototype.testVLC3 = function() {
        var decoded = new Int32Array([51, 58, 24, 48, 45, 1, 34, 33, 63, 15, 16, 24, 28, 31, 33, 7, 54, 28, 2, 30, 1, 42, 11, 7, 64, 39, 41, 50, 65, 10, 34, 36, 23, 40, 17, 28, 38, 57, 59, 25, 60, 8, 32, 20, 19, 53, 23, 26, 37, 14, 9, 56, 60, 57, 36, 29, 62, 63, 35, 24, 44, 3, 23, 62, 38, 49, 15, 56, 24, 48, 50, 45, 65, 1, 12, 1, 10, 6, 51, 10, 21, 41, 57, 34, 27, 65, 31, 64, 17, 64, 45, 46, 66, 31, 16, 18, 28, 66, 21, 51]);
        var vlc = VLC.createVLC(TestVLC.codes);
        var buf = ByteBuffer.allocate(1024);
        var bout = new BitWriter(buf);
        for (var i in decoded) {
            vlc.writeVLC(bout, i);
        }
        buf.flip();
        var bis = BitReader.createBitReader(buf);
        var actual = new Int32Array(decoded.length);
        for (var i = 0; i < decoded.length; i++) {
            actual[i] = vlc.readVLC(bis);
        }
        Assert.assertArrayEquals(decoded, actual);
    };
}, {codes: "Array"}, {});
var MockMDecoder = function(out, m) {
    MDecoder.call(this, null, null);
    this.out = out;
    this.m = m;
};
MockMDecoder = stjs.extend(MockMDecoder, MDecoder, [], function(constructor, prototype) {
    prototype.out = null;
    prototype.m = null;
    prototype.pos = 0;
    prototype.readOneByte = function() {};
    prototype.initCodeRegister = function() {};
    prototype.decodeBin = function(_m) {
        Assert.assertEquals(this.m[this.pos], _m);
        return this.out[this.pos++];
    };
    prototype.decodeFinalBin = function() {
        Assert.assertEquals(this.m[this.pos], -2);
        return this.out[this.pos++];
    };
    prototype.decodeBinBypass = function() {
        Assert.assertEquals(this.m[this.pos], -1);
        return this.out[this.pos++];
    };
}, {out: "Int32Array", m: "Int32Array", _in: "ByteBuffer", cm: "Array"}, {});
var ToJSONTest = function() {};
ToJSONTest = stjs.extend(ToJSONTest, null, [], function(constructor, prototype) {
    constructor.Cl1 = function() {
        this.arr = new ArrayList();
    };
    constructor.Cl1 = stjs.extend(constructor.Cl1, null, [], function(constructor, prototype) {
        prototype.arr = null;
        prototype.addCl2 = function(inst) {
            this.arr.add(inst);
        };
        prototype.getArr = function() {
            return this.arr;
        };
    }, {arr: {name: "List", arguments: ["ToJSONTest.Cl2"]}}, {});
    constructor.Cl2 = function(owner) {
        this.owner = owner;
    };
    constructor.Cl2 = stjs.extend(constructor.Cl2, null, [], function(constructor, prototype) {
        prototype.owner = null;
        prototype.getOwner = function() {
            return this.owner;
        };
    }, {owner: "ToJSONTest.Cl1"}, {});
    prototype.testCycle = function() {
        var cl1 = new ToJSONTest.Cl1();
        cl1.addCl2(new ToJSONTest.Cl2(cl1));
        cl1.addCl2(new ToJSONTest.Cl2(cl1));
        cl1.addCl2(new ToJSONTest.Cl2(cl1));
        cl1.addCl2(new ToJSONTest.Cl2(cl1));
        cl1.addCl2(new ToJSONTest.Cl2(cl1));
        Assert.assertEquals("{\"arr\":[{\"owner\":null,},{\"owner\":null,},{\"owner\":null,},{\"owner\":null,},{\"owner\":null,}],}", ToJSON.toJSON(cl1));
    };
    prototype.testMap = function() {
        var europe = new LinkedHashMap();
        europe.put("ukraine", ["Kyiv", "Lviv", "Odessa", "Kharkiv"]);
        europe.put("russia", ["Moscow", "St. Petersburg", "Tver", "Novosibirsk"]);
        var asia = new LinkedHashMap();
        asia.put("china", ["Beijing", "Shanghai", "Chongqing", "Tianjin"]);
        asia.put("japan", ["Tokyo", "Kyoto", "Osaka", "Hakone"]);
        asia.put("korea", ["Seoul", "Busan", "Daegu", "Daejon"]);
        var map = new LinkedHashMap();
        map.put("europe", europe);
        map.put("asia", asia);
        Assert.assertEquals("{\"europe\":{\"ukraine\":[\"Kyiv\",\"Lviv\",\"Odessa\",\"Kharkiv\"],\"russia\":[\"Moscow\",\"St. Petersburg\",\"Tver\",\"Novosibirsk\"]},\"asia\":{\"china\":[\"Beijing\",\"Shanghai\",\"Chongqing\",\"Tianjin\"],\"japan\":[\"Tokyo\",\"Kyoto\",\"Osaka\",\"Hakone\"],\"korea\":[\"Seoul\",\"Busan\",\"Daegu\",\"Daejon\"]}}", ToJSON.toJSON(map));
    };
}, {}, {});
var H264UtilsTest = function() {};
H264UtilsTest = stjs.extend(H264UtilsTest, null, [], function(constructor, prototype) {
    prototype.testEscapeNAL = function() {
        var src = new Int16Array([100, 0, 21, 172, 178, 1, 0, 75, 127, 224, 0, 96, 0, 130, 0, 0, 0, 2, 0, 0, 0, 100, 30, 44, 92, 144]);
        var tgt = new Int16Array([100, 0, 21, 172, 178, 1, 0, 75, 127, 224, 0, 96, 0, 130, 0, 0, 3, 0, 2, 0, 0, 3, 0, 100, 30, 44, 92, 144]);
        var b = Platform.copyOfByte(this.asByteArray(src), src.length + 2);
        var bb = ByteBuffer.wrap(b);
        bb.setLimit(bb.limit() - 2);
        H264Utils.escapeNALinplace(bb);
        for (var c in b) {
            System.out.println(String.format("%02x", c & 255));
        }
        Assert.assertArrayEquals(this.asByteArray(tgt), b);
    };
    prototype.asByteArray = function(src) {
        var result = new Int8Array(src.length);
        for (var i = 0; i < src.length; i++) {
            result[i] = (src[i] << 24 >> 24);
        }
        return result;
    };
    prototype.testAvcCToAnnexB = function() {
        var spsList = new ArrayList();
        spsList.add(ByteBuffer.wrap(new Int8Array(['s', 't', 'a', 'n'])));
        spsList.add(ByteBuffer.wrap(new Int8Array(['t', 'h', 'e'])));
        var ppsList = new ArrayList();
        ppsList.add(ByteBuffer.wrap(new Int8Array(['m', 'a', 'n'])));
        ppsList.add(ByteBuffer.wrap(new Int8Array(['c', 'o', 'o', 'l'])));
        var avcCBox = AvcCBox.createAvcCBox(66, 0, 42, 0, spsList, ppsList);
        var res = H264Utils.avcCToAnnexB(avcCBox);
        Assert.assertArrayEquals(new Int8Array([0, 0, 0, 1, 103, 's', 't', 'a', 'n', 0, 0, 0, 1, 103, 't', 'h', 'e', 0, 0, 0, 1, 104, 'm', 'a', 'n', 0, 0, 0, 1, 104, 'c', 'o', 'o', 'l']), res);
    };
}, {}, {});
var VerifyDCT = function() {
    DCT.call(this);
};
VerifyDCT = stjs.extend(VerifyDCT, DCT, [], function(constructor, prototype) {
    constructor.slow = SlowDCT.INSTANCE;
    constructor.fast = IntDCT.INSTANCE;
    constructor.diffcnt = 0;
    prototype.decode = function(orig) {
        var expected = VerifyDCT.slow.decode(orig);
        var actual = VerifyDCT.fast.decode(orig);
        if (!Platform.arrayEqualsInt(expected, actual)) {
            System.out.println("\nwhile decoding: ");
            Debug.print8x8i(orig);
            System.out.println("expected: ");
            Debug.print8x8i(expected);
            System.out.println("actual: ");
            Debug.print8x8i(actual);
            System.out.println("diff: ");
            for (var i = 0; i < expected.length; i++) {
                if (i % 8 == 0) {
                    System.out.println();
                }
                System.out.printf("%3d, ", (expected[i] - actual[i]));
            }
            VerifyDCT.diffcnt++;
            if (VerifyDCT.diffcnt == 10) {
                 throw new UnhandledStateException("diffcnt == 10");
            }
        }
        return expected;
    };
}, {slow: "SlowDCT", fast: "IntDCT"}, {});
var MathUtilTest = function() {};
MathUtilTest = stjs.extend(MathUtilTest, null, [], function(constructor, prototype) {
    prototype.test = function() {
        System.out.println(MathUtil.nextPowerOfTwo(1024));
    };
}, {}, {});
var Intra16x16PredictionBuilderTest = function() {};
Intra16x16PredictionBuilderTest = stjs.extend(Intra16x16PredictionBuilderTest, null, [], function(constructor, prototype) {
    constructor.emptyResidual = Array.apply(null, Array(16)).map(function() {
        return new Int32Array(16);
    });
    constructor.testResidual = Array.apply(null, Array(16)).map(function() {
        return new Int32Array(16);
    });
    prototype.offset = function(actual) {
        var result = new Int8Array(actual.length);
        for (var i = 0; i < actual.length; i++) {
            result[i] = (MathUtil.clip(actual[i] + i - 128, -128, 127) << 24 >> 24);
        }
        return result;
    };
    prototype.testVertical = function() {
        var expected = ArrayUtil.toByteArrayShifted(28, 132, 205, 207, 207, 207, 207, 207, 207, 207, 207, 206, 206, 206, 206, 206, 28, 132, 205, 207, 207, 207, 207, 207, 207, 207, 207, 206, 206, 206, 206, 206, 28, 132, 205, 207, 207, 207, 207, 207, 207, 207, 207, 206, 206, 206, 206, 206, 28, 132, 205, 207, 207, 207, 207, 207, 207, 207, 207, 206, 206, 206, 206, 206, 28, 132, 205, 207, 207, 207, 207, 207, 207, 207, 207, 206, 206, 206, 206, 206, 28, 132, 205, 207, 207, 207, 207, 207, 207, 207, 207, 206, 206, 206, 206, 206, 28, 132, 205, 207, 207, 207, 207, 207, 207, 207, 207, 206, 206, 206, 206, 206, 28, 132, 205, 207, 207, 207, 207, 207, 207, 207, 207, 206, 206, 206, 206, 206, 28, 132, 205, 207, 207, 207, 207, 207, 207, 207, 207, 206, 206, 206, 206, 206, 28, 132, 205, 207, 207, 207, 207, 207, 207, 207, 207, 206, 206, 206, 206, 206, 28, 132, 205, 207, 207, 207, 207, 207, 207, 207, 207, 206, 206, 206, 206, 206, 28, 132, 205, 207, 207, 207, 207, 207, 207, 207, 207, 206, 206, 206, 206, 206, 28, 132, 205, 207, 207, 207, 207, 207, 207, 207, 207, 206, 206, 206, 206, 206, 28, 132, 205, 207, 207, 207, 207, 207, 207, 207, 207, 206, 206, 206, 206, 206, 28, 132, 205, 207, 207, 207, 207, 207, 207, 207, 207, 206, 206, 206, 206, 206, 28, 132, 205, 207, 207, 207, 207, 207, 207, 207, 207, 206, 206, 206, 206, 206);
        var top = ArrayUtil.toByteArrayShifted(28, 132, 205, 207, 207, 207, 207, 207, 207, 207, 207, 206, 206, 206, 206, 206);
        var actual = new Int8Array(256);
        Intra16x16PredictionBuilder.predictVertical(Intra16x16PredictionBuilderTest.emptyResidual, true, top, 0, actual);
        Assert.assertArrayEquals(expected, actual);
        Intra16x16PredictionBuilder.predictVertical(Intra16x16PredictionBuilderTest.testResidual, true, top, 0, actual);
        Assert.assertArrayEquals(this.offset(expected), actual);
    };
    prototype.testHorizontal = function() {
        var expected = ArrayUtil.toByteArrayShifted(234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 237, 237, 237, 237, 237, 237, 237, 237, 237, 237, 237, 237, 237, 237, 237, 237, 237, 237, 237, 237, 237, 237, 237, 237, 237, 237, 237, 237, 237, 237, 237, 237, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114);
        var left = ArrayUtil.toByteArrayShifted(234, 233, 232, 232, 234, 234, 233, 233, 235, 237, 237, 204, 165, 135, 125, 114);
        var actual = new Int8Array(256);
        Intra16x16PredictionBuilder.predictHorizontal(Intra16x16PredictionBuilderTest.emptyResidual, true, left, 0, actual);
        Assert.assertArrayEquals(expected, actual);
        Intra16x16PredictionBuilder.predictHorizontal(Intra16x16PredictionBuilderTest.testResidual, true, left, 0, actual);
        Assert.assertArrayEquals(this.offset(expected), actual);
    };
    prototype.testDC = function() {
        var expected = ArrayUtil.toByteArrayShifted(194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194, 194);
        var left = ArrayUtil.toByteArrayShifted(147, 196, 206, 213, 206, 208, 212, 214, 214, 214, 214, 214, 208, 209, 192, 154);
        var top = ArrayUtil.toByteArrayShifted(132, 182, 204, 202, 210, 210, 210, 210, 210, 210, 183, 130, 136, 189, 194, 178);
        var actual = new Int8Array(256);
        Intra16x16PredictionBuilder.predictDC(Intra16x16PredictionBuilderTest.emptyResidual, true, true, left, top, 0, actual);
        Assert.assertArrayEquals(expected, actual);
        Intra16x16PredictionBuilder.predictDC(Intra16x16PredictionBuilderTest.testResidual, true, true, left, top, 0, actual);
        Assert.assertArrayEquals(this.offset(expected), actual);
    };
    prototype.testPlane = function() {
        var expected = ArrayUtil.toByteArrayShifted(105, 111, 117, 124, 130, 136, 143, 149, 155, 162, 168, 174, 181, 187, 193, 200, 104, 110, 116, 123, 129, 135, 142, 148, 154, 161, 167, 173, 180, 186, 192, 199, 103, 109, 115, 122, 128, 134, 141, 147, 153, 160, 166, 172, 179, 185, 191, 198, 102, 108, 114, 121, 127, 133, 140, 146, 152, 159, 165, 171, 178, 184, 190, 197, 101, 107, 113, 120, 126, 132, 139, 145, 151, 158, 164, 170, 177, 183, 189, 196, 100, 106, 112, 119, 125, 131, 138, 144, 150, 157, 163, 169, 176, 182, 188, 195, 99, 105, 111, 118, 124, 130, 137, 143, 149, 156, 162, 168, 175, 181, 187, 194, 98, 104, 110, 117, 123, 129, 136, 142, 148, 155, 161, 167, 174, 180, 186, 193, 97, 103, 109, 116, 122, 128, 135, 141, 147, 154, 160, 166, 173, 179, 185, 192, 96, 102, 108, 115, 121, 127, 134, 140, 146, 153, 159, 165, 172, 178, 184, 191, 95, 101, 107, 114, 120, 126, 133, 139, 145, 152, 158, 164, 171, 177, 183, 190, 94, 100, 106, 113, 119, 125, 132, 138, 144, 151, 157, 163, 170, 176, 182, 189, 93, 99, 105, 112, 118, 124, 131, 137, 143, 150, 156, 162, 169, 175, 181, 188, 92, 98, 104, 111, 117, 123, 130, 136, 142, 149, 155, 161, 168, 174, 180, 187, 91, 97, 103, 110, 116, 122, 129, 135, 141, 148, 154, 160, 167, 173, 179, 186, 90, 96, 102, 109, 115, 121, 128, 134, 140, 147, 153, 159, 166, 172, 178, 185);
        var left = ArrayUtil.toByteArrayShifted(97, 94, 88, 86, 92, 92, 92, 92, 91, 99, 100, 94, 96, 89, 79, 76);
        var tl = ArrayUtil.toByteArrayShifted(122);
        var top = ArrayUtil.toByteArrayShifted(110, 95, 108, 158, 199, 199, 199, 199, 204, 202, 196, 193, 199, 202, 206, 208);
        var actual = new Int8Array(256);
        Intra16x16PredictionBuilder.predictPlane(Intra16x16PredictionBuilderTest.emptyResidual, true, true, left, top, tl, 0, actual);
        Assert.assertArrayEquals(expected, actual);
        Intra16x16PredictionBuilder.predictPlane(Intra16x16PredictionBuilderTest.testResidual, true, true, left, top, tl, 0, actual);
        Assert.assertArrayEquals(this.offset(expected), actual);
    };
    prototype.testPlane2 = function() {
        var expected = ArrayUtil.toByteArrayShifted(125, 134, 143, 152, 161, 170, 179, 188, 197, 206, 215, 225, 234, 243, 252, 255, 119, 128, 137, 146, 155, 164, 173, 183, 192, 201, 210, 219, 228, 237, 246, 255, 113, 122, 131, 141, 150, 159, 168, 177, 186, 195, 204, 213, 222, 231, 240, 249, 108, 117, 126, 135, 144, 153, 162, 171, 180, 189, 198, 207, 216, 225, 234, 244, 102, 111, 120, 129, 138, 147, 156, 165, 174, 183, 192, 202, 211, 220, 229, 238, 96, 105, 114, 123, 132, 141, 150, 160, 169, 178, 187, 196, 205, 214, 223, 232, 90, 99, 108, 118, 127, 136, 145, 154, 163, 172, 181, 190, 199, 208, 217, 226, 85, 94, 103, 112, 121, 130, 139, 148, 157, 166, 175, 184, 193, 202, 211, 221, 79, 88, 97, 106, 115, 124, 133, 142, 151, 160, 169, 179, 188, 197, 206, 215, 73, 82, 91, 100, 109, 118, 127, 137, 146, 155, 164, 173, 182, 191, 200, 209, 67, 76, 85, 95, 104, 113, 122, 131, 140, 149, 158, 167, 176, 185, 194, 203, 62, 71, 80, 89, 98, 107, 116, 125, 134, 143, 152, 161, 170, 179, 188, 198, 56, 65, 74, 83, 92, 101, 110, 119, 128, 137, 146, 156, 165, 174, 183, 192, 50, 59, 68, 77, 86, 95, 104, 114, 123, 132, 141, 150, 159, 168, 177, 186, 44, 53, 62, 72, 81, 90, 99, 108, 117, 126, 135, 144, 153, 162, 171, 180, 39, 48, 57, 66, 75, 84, 93, 102, 111, 120, 129, 138, 147, 156, 165, 175);
        var left = ArrayUtil.toByteArrayShifted(140, 138, 133, 130, 128, 123, 113, 108, 101, 96, 86, 81, 74, 72, 67, 64);
        var tl = ArrayUtil.toByteArrayShifted(160);
        var top = ArrayUtil.toByteArrayShifted(68, 76, 91, 98, 112, 120, 135, 142, 158, 166, 181, 188, 202, 210, 225, 232);
        var actual = new Int8Array(256);
        Intra16x16PredictionBuilder.predictPlane(Intra16x16PredictionBuilderTest.emptyResidual, true, true, left, top, tl, 0, actual);
        Assert.assertArrayEquals(expected, actual);
        Intra16x16PredictionBuilder.predictPlane(Intra16x16PredictionBuilderTest.testResidual, true, true, left, top, tl, 0, actual);
        Assert.assertArrayEquals(this.offset(expected), actual);
    };
}, {emptyResidual: "Array", testResidual: "Array"}, {});
(function() {
    for (var i = 0; i < 256; i++) {
        Intra16x16PredictionBuilderTest.testResidual[H264Const.LUMA_4x4_BLOCK_LUT[i]][H264Const.LUMA_4x4_POS_LUT[i]] = i - 128;
    }
})();
var DisplayTimecodesTest = function() {};
DisplayTimecodesTest = stjs.extend(DisplayTimecodesTest, null, [], function(constructor, prototype) {
    prototype.test = function() {
        var filename = "./src/test/resources/mkv/";
        filename += "10frames.webm";
        System.out.println("Scanning file: " + filename);
        var iFS = new FileInputStream(new File(filename));
        var reader = new MKVParser(new FileChannelWrapper(iFS.getChannel()));
        var path = [MKVType.Segment];
        var s = MKVType.findFirstTree(reader.parse(), path);
        this.printCues(s);
        this.printBlocks(s);
        this.printTracks(s);
        this.printInfo(s);
    };
    prototype.printInfo = function(s) {
        var sb = new StringBuilder("info ");
        var path = [MKVType.Segment, MKVType.Info, MKVType.TimecodeScale];
        var scale = MKVType.findFirst(s, path);
        var path1 = [MKVType.Segment, MKVType.Info, MKVType.Duration];
        var duration = MKVType.findFirst(s, path1);
        DisplayTimecodesTest.appendUint(sb, "scale", scale);
        DisplayTimecodesTest.appendFloat(sb, "duration", duration);
        sb.append("\n");
        System.out.println(sb.toString());
    };
    prototype.printCues = function(s) {
        var sb = new StringBuilder();
        var path4 = [MKVType.Segment, MKVType.Cues, MKVType.CuePoint];
        for (var aCuePoint in MKVType.findAll(s, EbmlMaster, false, path4)) {
            var path = [MKVType.CuePoint, MKVType.CueTime];
            var time = MKVType.findFirst(aCuePoint, path);
            sb.append("cue time: ").append(time.getUint());
            var path5 = [MKVType.CuePoint, MKVType.CueTrackPositions];
            for (var aCueTrackPosition in MKVType.findAll(aCuePoint, EbmlMaster, false, path5)) {
                var path1 = [MKVType.CueTrackPositions, MKVType.CueTrack];
                DisplayTimecodesTest.appendUint(sb, "track", MKVType.findFirst(aCueTrackPosition, path1));
                var path2 = [MKVType.CueTrackPositions, MKVType.CueClusterPosition];
                var EbmlMaster = MKVType.findFirst(aCueTrackPosition, path2);
                if (EbmlMaster != null) 
                    sb.append(" EbmlMaster offset ").append(EbmlMaster.getUint() + s.dataOffset);
                var path3 = [MKVType.CueTrackPositions, MKVType.CueBlockNumber];
                DisplayTimecodesTest.appendUint(sb, "block", MKVType.findFirst(aCueTrackPosition, path3));
            }
            sb.append("\n");
        }
        System.out.println(sb.toString());
    };
    constructor.appendUint = function(b, caption, e) {
        if (e != null) 
            b.append(" ").append(caption).append(": ").append(e.getUint());
    };
    constructor.appendUlong = function(b, caption, e) {
        if (e != null) 
            b.append(" ").append(caption).append(": ").append(e.getUlong());
    };
    constructor.appendString = function(b, caption, e) {
        if (e != null) 
            b.append(" ").append(caption).append(": ").append(e.getString());
    };
    constructor.appendFloat = function(b, caption, e) {
        if (e != null) 
            b.append(" ").append(caption).append(": ").append(e.getDouble());
    };
    prototype.printBlocks = function(s) {
        var sb = new StringBuilder();
        var path5 = [MKVType.Segment, MKVType.Cluster];
        for (var aEbmlMaster in MKVType.findAll(s, EbmlMaster, false, path5)) {
            var path = [MKVType.Cluster, MKVType.Timecode];
            var time = MKVType.findFirst(aEbmlMaster, path);
            var path1 = [MKVType.Cluster, MKVType.Position];
            var position = MKVType.findFirst(aEbmlMaster, path1);
            sb.append("EbmlMaster time: ").append(time.getUint());
            DisplayTimecodesTest.appendUint(sb, "position", position);
            sb.append(" offset: ").append(aEbmlMaster.offset).append("\n");
            for (var iterator$aChild = aEbmlMaster.children.iterator(); iterator$aChild.hasNext(); ) {
                var aChild = iterator$aChild.next();
                if (stjs.isInstanceOf(aChild.constructor, MkvBlock)) {
                    var block = aChild;
                    sb.append("    block tarck: ").append(block.trackNumber).append(" timecode: ").append(block.timecode).append(" offset: ").append(block.offset).append("\n");
                    sb.append("    block real timecode: " + (time.getUint() + block.timecode));
                    sb.append("\n");
                } else if (stjs.isInstanceOf(aChild.constructor, EbmlMaster)) {
                    var path2 = [MKVType.BlockGroup, MKVType.Block];
                    var block = MKVType.findFirst(aChild, path2);
                    sb.append("    block tarck: ").append(block.trackNumber).append(" timecode: ").append(block.timecode).append(" offset: ").append(block.offset).append("\n");
                    sb.append("    block real timecode: " + (time.getUint() + block.timecode));
                    var path3 = [MKVType.BlockGroup, MKVType.ReferenceBlock];
                    DisplayTimecodesTest.appendUint(sb, "reference", MKVType.findFirst(aEbmlMaster, path3));
                    var path4 = [MKVType.Cluster, MKVType.BlockDuration];
                    DisplayTimecodesTest.appendUint(sb, "duration", MKVType.findFirst(aEbmlMaster, path4));
                    sb.append("\n");
                }
            }
            sb.append("\n");
        }
        System.out.println(sb.toString());
    };
    prototype.printTracks = function(s) {
        var sb = new StringBuilder();
        var path31 = [MKVType.Segment, MKVType.Tracks, MKVType.TrackEntry];
        for (var anEntry in MKVType.findAll(s, EbmlMaster, false, path31)) {
            sb.append("track ");
            var path = [MKVType.TrackEntry, MKVType.Name];
            DisplayTimecodesTest.appendString(sb, "name", MKVType.findFirst(anEntry, path));
            var path1 = [MKVType.TrackEntry, MKVType.Language];
            DisplayTimecodesTest.appendString(sb, "language", MKVType.findFirst(anEntry, path1));
            var path2 = [MKVType.TrackEntry, MKVType.TrackNumber];
            DisplayTimecodesTest.appendUint(sb, "number", MKVType.findFirst(anEntry, path2));
            var path3 = [MKVType.TrackEntry, MKVType.TrackType];
            DisplayTimecodesTest.appendUint(sb, "type", MKVType.findFirst(anEntry, path3));
            var path4 = [MKVType.TrackEntry, MKVType.FlagEnabled];
            DisplayTimecodesTest.appendUint(sb, "enabled", MKVType.findFirst(anEntry, path4));
            var path5 = [MKVType.TrackEntry, MKVType.FlagDefault];
            DisplayTimecodesTest.appendUint(sb, "default", MKVType.findFirst(anEntry, path5));
            var path6 = [MKVType.TrackEntry, MKVType.FlagForced];
            DisplayTimecodesTest.appendUint(sb, "forced", MKVType.findFirst(anEntry, path6));
            var path7 = [MKVType.TrackEntry, MKVType.FlagLacing];
            DisplayTimecodesTest.appendUint(sb, "lacing", MKVType.findFirst(anEntry, path7));
            var path8 = [MKVType.TrackEntry, MKVType.MinCache];
            DisplayTimecodesTest.appendUint(sb, "mincache", MKVType.findFirst(anEntry, path8));
            var path9 = [MKVType.TrackEntry, MKVType.MaxCache];
            DisplayTimecodesTest.appendUint(sb, "maccache", MKVType.findFirst(anEntry, path9));
            var path10 = [MKVType.TrackEntry, MKVType.DefaultDuration];
            DisplayTimecodesTest.appendUint(sb, "defaultduration", MKVType.findFirst(anEntry, path10));
            var path11 = [MKVType.TrackEntry, MKVType.CodecID];
            DisplayTimecodesTest.appendString(sb, "codecid", MKVType.findFirst(anEntry, path11));
            var path12 = [MKVType.TrackEntry, MKVType.CodecName];
            DisplayTimecodesTest.appendString(sb, "codecname", MKVType.findFirst(anEntry, path12));
            var path13 = [MKVType.TrackEntry, MKVType.AttachmentLink];
            DisplayTimecodesTest.appendString(sb, "attachmentlink", MKVType.findFirst(anEntry, path13));
            var path14 = [MKVType.TrackEntry, MKVType.CodecDecodeAll];
            DisplayTimecodesTest.appendUint(sb, "codecdecodeall", MKVType.findFirst(anEntry, path14));
            var path15 = [MKVType.TrackEntry, MKVType.TrackOverlay];
            DisplayTimecodesTest.appendUint(sb, "overlay", MKVType.findFirst(anEntry, path15));
            var path16 = [MKVType.TrackEntry, MKVType.Video];
            var video = MKVType.findFirst(anEntry, path16);
            var path17 = [MKVType.TrackEntry, MKVType.Audio];
            var audio = MKVType.findFirst(anEntry, path17);
            if (video != null) {
                sb.append("\n    video ");
                var path18 = [MKVType.Video, MKVType.FlagInterlaced];
                DisplayTimecodesTest.appendUint(sb, "interlaced", MKVType.findFirst(video, path18));
                var path19 = [MKVType.Video, MKVType.StereoMode];
                DisplayTimecodesTest.appendUint(sb, "stereo", MKVType.findFirst(video, path19));
                var path20 = [MKVType.Video, MKVType.AlphaMode];
                DisplayTimecodesTest.appendUint(sb, "alpha", MKVType.findFirst(video, path20));
                var path21 = [MKVType.Video, MKVType.PixelWidth];
                DisplayTimecodesTest.appendUint(sb, "pixelwidth", MKVType.findFirst(video, path21));
                var path22 = [MKVType.Video, MKVType.PixelHeight];
                DisplayTimecodesTest.appendUint(sb, "pixelheight", MKVType.findFirst(video, path22));
                var path23 = [MKVType.Video, MKVType.PixelCropBottom];
                DisplayTimecodesTest.appendUint(sb, "cropbottom", MKVType.findFirst(video, path23));
                var path24 = [MKVType.Video, MKVType.PixelCropTop];
                DisplayTimecodesTest.appendUint(sb, "croptop", MKVType.findFirst(video, path24));
                var path25 = [MKVType.Video, MKVType.PixelCropLeft];
                DisplayTimecodesTest.appendUint(sb, "cropleft", MKVType.findFirst(video, path25));
                var path26 = [MKVType.Video, MKVType.PixelCropRight];
                DisplayTimecodesTest.appendUint(sb, "cropright", MKVType.findFirst(video, path26));
                var path27 = [MKVType.Video, MKVType.DisplayWidth];
                DisplayTimecodesTest.appendUint(sb, "displaywidth", MKVType.findFirst(video, path27));
                var path28 = [MKVType.Video, MKVType.DisplayHeight];
                DisplayTimecodesTest.appendUint(sb, "displayheight", MKVType.findFirst(video, path28));
                var path29 = [MKVType.Video, MKVType.DisplayUnit];
                DisplayTimecodesTest.appendUint(sb, "displayunit", MKVType.findFirst(video, path29));
                var path30 = [MKVType.Video, MKVType.AspectRatioType];
                DisplayTimecodesTest.appendUint(sb, "aspectratiotype", MKVType.findFirst(video, path30));
            } else if (audio != null) {
                sb.append("\n    audio ");
                var path18 = [MKVType.Audio, MKVType.SamplingFrequency];
                DisplayTimecodesTest.appendFloat(sb, "sampling", MKVType.findFirst(audio, path18));
                var path19 = [MKVType.Audio, MKVType.OutputSamplingFrequency];
                DisplayTimecodesTest.appendFloat(sb, "outputsampling", MKVType.findFirst(audio, path19));
                var path20 = [MKVType.Audio, MKVType.Channels];
                DisplayTimecodesTest.appendUint(sb, "channels", MKVType.findFirst(audio, path20));
                var path21 = [MKVType.Audio, MKVType.BitDepth];
                DisplayTimecodesTest.appendUint(sb, "bitdepth", MKVType.findFirst(audio, path21));
            }
            sb.append("\n");
        }
        System.out.println(sb.toString());
    };
}, {}, {});
var EbmlUintTest = function() {};
EbmlUintTest = stjs.extend(EbmlUintTest, null, [], function(constructor, prototype) {
    prototype.testAbs = function() {
        Assert.assertEquals(4, EbmlUintTest.abs(-4));
        Assert.assertEquals(1, EbmlUintTest.abs(-1));
        Assert.assertEquals(-9223372036854775807, EbmlUintTest.abs(9223372036854775807));
    };
    prototype.testUnsignedIntegerData = function() {
        var uie1 = new EbmlUint(MKVType.BlockDuration.id);
        uie1.setUint(128);
        var bb = uie1.getData();
        Assert.assertArrayEquals(new Int8Array([(155 << 24 >> 24), (129 << 24 >> 24), (128 << 24 >> 24)]), bb.array());
        var uie2 = EbmlUint.createEbmlUint(MKVType.TrackNumber.id, 1);
        bb = uie2.getData();
        Assert.assertArrayEquals(new Int8Array([(215 << 24 >> 24), (129 << 24 >> 24), 1]), bb.array());
    };
    prototype.testElementMuxing2 = function() {
        var uie = EbmlUint.createEbmlUint(MKVType.CueClusterPosition.id, 145582);
        var bb = uie.getData();
        Assert.assertArrayEquals(new Int8Array([(241 << 24 >> 24), (131 << 24 >> 24), 2, 56, (174 << 24 >> 24)]), bb.array());
    };
    prototype.testMax = function() {
        Assert.assertEquals(-4, EbmlUintTest.max(-4, -5));
        Assert.assertEquals(Long.MIN_VALUE, EbmlUintTest.max(Long.MIN_VALUE, Long.MAX_VALUE));
    };
    constructor.abs = function(v) {
        var mask = v >>> 56;
        return (v + mask) ^ mask;
    };
    constructor.max = function(x, y) {
        var c = (x - y) >>> 63;
        return x ^ ((x ^ y) & -c);
    };
    prototype.testPayloadSize = function() {
        Assert.assertEquals(1, EbmlUint.calculatePayloadSize(33));
        Assert.assertEquals(1, EbmlUint.calculatePayloadSize(0));
        Assert.assertEquals(3, EbmlUint.calculatePayloadSize(2162688));
        Assert.assertEquals(2, EbmlUint.calculatePayloadSize(256));
    };
}, {}, {});
var TestBooleanEncoder = function() {};
TestBooleanEncoder = stjs.extend(TestBooleanEncoder, null, [], function(constructor, prototype) {
    prototype.testOne = function() {
        var expected = new Int16Array([10, 143, 239, 0, 20, 177, 176, 34, 250, 0, 1, 134, 149, 219, 71, 187, 122, 222, 205, 1, 14, 1, 168, 218, 20, 168, 201, 1, 114, 0, 72, 0, 192, 0, 198, 255, 168, 141, 19, 155, 140, 228, 195, 184, 26, 0]);
        var probs = new Int32Array([107, 50, 100, 102, 116, 25, 42, 98, 35, 70, 61, 80, 46, 65, 121, 117, 81, 91, 18, 77, 2, 31, 17, 102, 20, 51, 16, 13, 127, 27, 65, 107, 78, 37, 81, 67, 63, 124, 37, 98, 67, 98, 51, 114, 36, 45, 103, 117, 8, 121, 67, 11, 24, 84, 113, 44, 8, 2, 58, 8, 30, 124, 115, 108, 34, 69, 48, 97, 65, 85, 68, 5, 56, 119, 119, 92, 36, 94, 81, 45, 88, 21, 56, 112, 106, 42, 29, 114, 44, 87, 122, 75, 84, 109, 56, 118, 50, 104, 87, 116, 61, 27, 121, 117, 18, 112, 82, 55, 79, 35, 100, 39, 57, 28, 24, 35, 71, 53, 21, 116, 13, 16, 63, 97, 126, 119, 87, 49, 95, 47, 37, 29, 74, 31, 19, 93, 16, 101, 21, 95, 9, 121, 6, 66, 22, 30, 102, 93, 84, 123, 81, 97, 11, 17, 66, 10, 8, 26, 59, 104, 73, 96, 6, 20, 127, 26, 113, 16, 127, 6, 111, 9, 0, 118, 76, 23, 20, 50, 116, 104, 45, 70, 74, 57, 87, 12, 67, 96, 38, 127, 73, 112, 95, 80, 4, 95, 106, 118, 111, 106, 125, 95, 115, 125, 85, 63, 20, 106, 113, 9, 83, 31, 80, 29, 89, 40, 42, 29, 9, 81, 28, 83, 65, 124, 35, 69, 92, 14, 60, 75, 120, 57, 43, 108, 55, 0, 44, 76, 106, 29, 86, 61, 61, 39, 91, 23, 79, 5, 52, 89]);
        var bits = new Int32Array([0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1]);
        var out = ByteBuffer.allocate(512);
        var encoder = new VPxBooleanEncoder(out);
        for (var i = 0; i < probs.length; i++) 
            encoder.writeBit(probs[i], bits[i]);
        encoder.stop();
        out.flip();
        Assert.assertArrayEquals(this.asByteArray(expected), NIOUtils.toArray(out));
    };
    prototype.asByteArray = function(src) {
        var result = new Int8Array(src.length);
        for (var i = 0; i < src.length; i++) {
            result[i] = (src[i] << 24 >> 24);
        }
        return result;
    };
}, {}, {});
var TestCoeffEncoder = function() {};
TestCoeffEncoder = stjs.extend(TestCoeffEncoder, null, [], function(constructor, prototype) {
    constructor.cloneProb = function() {
        var ref = VPXConst.tokenDefaultBinProbs;
        var result = Array.apply(null, Array(4)).map(function() {
            return Array.apply(null, Array(8)).map(function() {
                return Array.apply(null, Array(3)).map(function() {
                    return new Int32Array(11);
                });
            });
        });
        for (var i = 0; i < ref.length; i++) 
            for (var j = 0; j < ref[i].length; j++) 
                for (var k = 0; k < ref[i][j].length; k++) 
                    for (var l = 0; l < ref[i][j][k].length; l++) 
                        result[i][j][k][l] = ref[i][j][k][l];
        return result;
    };
    constructor.binProbs1 = TestCoeffEncoder.cloneProb();
    constructor.binProbs2 = TestCoeffEncoder.cloneProb();
    constructor.binProbs3 = TestCoeffEncoder.cloneProb();
    prototype.testCoeffWHT = function() {
        var bs = new VPXBitstream(TestCoeffEncoder.binProbs1, 1);
        bs.encodeCoeffsWHT(new TestCoeffEncoder.MockVpxBooleanEncoder(new Int32Array([198, 35, 237, 223, 162, 145, 62, 254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 128, 81, 99, 181, 242, 249, 255, 128, 180, 157, 141, 134, 130, 128, 23, 91, 163, 242, 247, 255, 128, 180, 157, 141, 134, 130, 128, 44, 130, 201, 253, 255, 128, 128, 173, 148, 140, 128, 45, 99, 1, 1, 1, 128, 128, 254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 128, 22, 100, 174, 245, 255, 128, 128, 254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 128, 35, 77, 181, 251, 255, 128, 128, 180, 157, 141, 134, 130, 128, 45, 99, 1, 1, 1, 128, 128, 254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 128, 45, 99, 1, 1, 1, 128, 128, 254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 128, 45, 99, 1, 1, 1, 128, 128, 180, 157, 141, 134, 130, 128, 45, 99, 1, 1, 1, 128, 128, 254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 128, 45, 99, 1, 1, 1, 128, 128, 254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 128, 45, 99, 1, 1, 1, 128, 128, 173, 148, 140, 128, 45, 99, 1, 1, 1, 128, 128, 180, 157, 141, 134, 130, 128, 45, 99, 1, 1, 1, 128, 128, 180, 157, 141, 134, 130, 128, 137, 1, 177, 255, 128, 128, 128, 254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 128]), new Int32Array([1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1])), new Int32Array([156, -58, 54, -15, -97, -75, -54, 91, 91, -54, -75, -97, -15, 54, -58, -363]), 0);
    };
    prototype.testCoeffDCTY15 = function() {
        var bs = new VPXBitstream(TestCoeffEncoder.binProbs3, 1);
        bs.encodeCoeffsDCT15(new TestCoeffEncoder.MockVpxBooleanEncoder(new Int32Array([253, 136, 254, 255, 128, 128, 128, 173, 148, 140, 128, 78, 134, 202, 1, 64, 128, 128, 180, 157, 141, 134, 130, 128, 77, 110, 216, 64, 128, 128, 128, 176, 155, 140, 135, 128, 1, 1, 1, 43, 128, 128, 128, 173, 148, 140, 128, 37, 116, 196, 243, 255, 255, 165, 145, 128, 102, 103, 231, 64, 128, 128, 159, 128, 1, 1, 1, 43, 128, 128, 128, 173, 148, 140, 128, 1, 1, 1, 43, 128, 128, 128, 173, 148, 140, 128, 1, 1, 1, 43, 128, 128, 128, 173, 148, 140, 128, 1, 1, 1, 43, 128, 128, 165, 145, 128, 1, 1, 1, 43, 128, 128, 165, 145, 128, 1, 1, 1, 43, 128, 128, 165, 145, 128, 1, 1, 1, 43, 128, 128, 159, 128, 1, 1, 1, 43, 128, 128, 159, 128, 1, 128, 128, 128, 128, 128, 128]), new Int32Array([1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1])), new Int32Array([0, 13, 38, -29, -16, 10, 5, -12, 13, 16, -7, 10, -7, 5, -5, -3]), 0, 0, 0);
    };
    prototype.testCoeffDCTY16 = function() {
        var bs = new VPXBitstream(TestCoeffEncoder.binProbs2, 1);
        bs.encodeCoeffsDCT16(new TestCoeffEncoder.MockVpxBooleanEncoder(new Int32Array([202, 24, 213, 235, 220, 240, 255, 254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 128, 39, 77, 1, 51, 43, 255, 85, 176, 155, 140, 135, 128, 24, 71, 130, 39, 1, 163, 110, 176, 155, 140, 135, 128, 28, 108, 121, 7, 38, 132, 128, 128, 176, 155, 140, 135, 128, 20, 95, 222, 1, 255, 128, 128, 165, 145, 128, 42, 80, 121, 121, 7, 38, 132, 51, 165, 145, 128, 42, 80, 21, 68, 132, 15, 165, 145, 128, 42, 80, 121, 7, 38, 132, 51, 165, 145, 128, 42, 80, 121, 1, 102, 128, 128, 128, 128]), new Int32Array([1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1])), new Int32Array([83, 21, 21, 0, -19, 0, -9, 0, 0, -9, 8, 0, 8, 0, 0, -3]), 0, 0, 0);
    };
    prototype.testCoeffDCTU = function() {
        var bs = new VPXBitstream(TestCoeffEncoder.binProbs1, 1);
        bs.encodeCoeffsDCTUV(new TestCoeffEncoder.MockVpxBooleanEncoder(new Int32Array([1, 9, 248, 251, 255, 128, 128, 176, 155, 140, 135, 128, 155, 77, 1, 1, 128, 128, 128, 176, 155, 140, 135, 128, 69, 46, 190, 1, 128, 128, 128, 176, 155, 140, 135, 128, 141, 124, 134, 51, 80, 128, 128, 128, 173, 148, 140, 128, 149, 255, 1, 1, 128, 128, 128, 128, 173, 148, 140, 128, 55, 93, 134, 134, 51, 80, 128, 128, 128, 173, 148, 140, 128, 55, 93, 1, 128, 128, 128, 159, 128, 55, 93, 134, 51, 80, 128, 128, 159, 128, 55, 93, 134, 128, 128, 128, 128, 128]), new Int32Array([1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0])), new Int32Array([19, 34, 34, 0, 16, 0, -14, 0, 0, -11, -5, 0, -6, 0, 0, 2]), 1, 0, 0, 0);
    };
    constructor.MockVpxBooleanEncoder = function(probs, bits) {
        VPxBooleanEncoder.call(this, null);
        this.probs = probs;
        this.bits = bits;
    };
    constructor.MockVpxBooleanEncoder = stjs.extend(constructor.MockVpxBooleanEncoder, VPxBooleanEncoder, [], function(constructor, prototype) {
        prototype.probs = null;
        prototype.bits = null;
        prototype.cur = 0;
        prototype.writeBit = function(prob, bit) {
            Assert.assertEquals(this.probs[this.cur], prob);
            Assert.assertEquals(this.bits[this.cur], bit);
            this.cur++;
        };
    }, {probs: "Int32Array", bits: "Int32Array", out: "ByteBuffer"}, {});
}, {binProbs1: "Array", binProbs2: "Array", binProbs3: "Array"}, {});
(function() {
    TestCoeffEncoder.binProbs1[1][6][2][2] = 1;
    TestCoeffEncoder.binProbs1[1][6][2][3] = 1;
    TestCoeffEncoder.binProbs1[1][6][2][6] = 1;
    TestCoeffEncoder.binProbs1[2][0][0][0] = 1;
    TestCoeffEncoder.binProbs1[2][0][1][3] = 1;
    TestCoeffEncoder.binProbs1[2][1][2][2] = 1;
    TestCoeffEncoder.binProbs1[2][1][2][3] = 1;
    TestCoeffEncoder.binProbs1[2][1][2][6] = 128;
    TestCoeffEncoder.binProbs1[2][2][2][3] = 1;
    TestCoeffEncoder.binProbs1[2][2][2][6] = 128;
    TestCoeffEncoder.binProbs1[2][4][2][1] = 255;
    TestCoeffEncoder.binProbs1[2][5][0][1] = 1;
    TestCoeffEncoder.binProbs1[2][5][0][2] = 1;
    TestCoeffEncoder.binProbs1[2][6][0][2] = 51;
    TestCoeffEncoder.binProbs1[2][6][0][3] = 80;
    TestCoeffEncoder.binProbs1[2][6][1][0] = 1;
    TestCoeffEncoder.binProbs1[2][6][1][2] = 1;
    TestCoeffEncoder.binProbs1[2][6][1][3] = 64;
    TestCoeffEncoder.binProbs1[2][6][2][2] = 1;
    TestCoeffEncoder.binProbs2[2][0][0][0] = 1;
    TestCoeffEncoder.binProbs2[2][1][2][2] = 1;
    TestCoeffEncoder.binProbs2[2][1][2][3] = 32;
    TestCoeffEncoder.binProbs2[2][1][2][6] = 146;
    TestCoeffEncoder.binProbs2[2][2][2][3] = 32;
    TestCoeffEncoder.binProbs2[2][2][2][6] = 110;
    TestCoeffEncoder.binProbs2[2][3][2][2] = 1;
    TestCoeffEncoder.binProbs2[2][3][2][3] = 1;
    TestCoeffEncoder.binProbs2[2][4][2][2] = 1;
    TestCoeffEncoder.binProbs2[2][5][2][0] = 1;
    TestCoeffEncoder.binProbs2[2][5][2][2] = 85;
    TestCoeffEncoder.binProbs2[2][6][0][2] = 96;
    TestCoeffEncoder.binProbs2[2][6][1][0] = 1;
    TestCoeffEncoder.binProbs2[2][6][1][2] = 70;
    TestCoeffEncoder.binProbs2[2][6][1][3] = 160;
    TestCoeffEncoder.binProbs2[2][6][2][0] = 1;
    TestCoeffEncoder.binProbs2[2][6][2][2] = 54;
    TestCoeffEncoder.binProbs2[3][0][2][3] = 1;
    TestCoeffEncoder.binProbs2[3][0][2][6] = 57;
    TestCoeffEncoder.binProbs2[3][1][2][2] = 1;
    TestCoeffEncoder.binProbs2[3][1][2][3] = 51;
    TestCoeffEncoder.binProbs2[3][1][2][6] = 43;
    TestCoeffEncoder.binProbs2[3][1][2][9] = 85;
    TestCoeffEncoder.binProbs2[3][2][2][3] = 39;
    TestCoeffEncoder.binProbs2[3][2][2][6] = 1;
    TestCoeffEncoder.binProbs2[3][2][2][8] = 163;
    TestCoeffEncoder.binProbs2[3][2][2][9] = 110;
    TestCoeffEncoder.binProbs2[3][4][2][3] = 26;
    TestCoeffEncoder.binProbs2[3][4][2][6] = 114;
    TestCoeffEncoder.binProbs2[3][5][0][2] = 1;
    TestCoeffEncoder.binProbs2[3][5][2][2] = 23;
    TestCoeffEncoder.binProbs2[3][5][2][3] = 77;
    TestCoeffEncoder.binProbs2[3][5][2][6] = 146;
    TestCoeffEncoder.binProbs2[3][6][0][2] = 7;
    TestCoeffEncoder.binProbs2[3][6][0][3] = 38;
    TestCoeffEncoder.binProbs2[3][6][0][6] = 132;
    TestCoeffEncoder.binProbs2[3][6][0][7] = 51;
    TestCoeffEncoder.binProbs2[3][6][2][2] = 21;
    TestCoeffEncoder.binProbs2[3][6][2][3] = 68;
    TestCoeffEncoder.binProbs2[3][6][2][6] = 132;
    TestCoeffEncoder.binProbs2[3][6][2][7] = 15;
    TestCoeffEncoder.binProbs2[3][7][0][2] = 102;
    TestCoeffEncoder.binProbs2[3][7][2][0] = 28;
    TestCoeffEncoder.binProbs2[3][7][2][2] = 32;
    TestCoeffEncoder.binProbs3[0][2][2][3] = 1;
    TestCoeffEncoder.binProbs3[0][2][2][6] = 64;
    TestCoeffEncoder.binProbs3[0][3][2][3] = 64;
    TestCoeffEncoder.binProbs3[0][5][2][3] = 64;
    TestCoeffEncoder.binProbs3[0][6][2][0] = 1;
    TestCoeffEncoder.binProbs3[0][6][2][1] = 1;
    TestCoeffEncoder.binProbs3[0][6][2][2] = 1;
    TestCoeffEncoder.binProbs3[0][6][2][3] = 43;
    TestCoeffEncoder.binProbs3[0][7][2][0] = 1;
    TestCoeffEncoder.binProbs3[1][6][2][2] = 1;
    TestCoeffEncoder.binProbs3[1][6][2][3] = 1;
    TestCoeffEncoder.binProbs3[1][6][2][6] = 1;
    TestCoeffEncoder.binProbs3[2][0][0][0] = 1;
    TestCoeffEncoder.binProbs3[2][0][1][3] = 1;
    TestCoeffEncoder.binProbs3[2][1][2][2] = 1;
    TestCoeffEncoder.binProbs3[2][1][2][3] = 1;
    TestCoeffEncoder.binProbs3[2][1][2][6] = 128;
    TestCoeffEncoder.binProbs3[2][2][2][3] = 1;
    TestCoeffEncoder.binProbs3[2][2][2][6] = 128;
    TestCoeffEncoder.binProbs3[2][4][2][1] = 128;
    TestCoeffEncoder.binProbs3[2][4][2][2] = 64;
    TestCoeffEncoder.binProbs3[2][5][0][2] = 1;
    TestCoeffEncoder.binProbs3[2][5][2][2] = 1;
    TestCoeffEncoder.binProbs3[2][6][0][2] = 98;
    TestCoeffEncoder.binProbs3[2][6][0][3] = 128;
    TestCoeffEncoder.binProbs3[2][6][1][0] = 1;
    TestCoeffEncoder.binProbs3[2][6][1][2] = 23;
    TestCoeffEncoder.binProbs3[2][6][1][3] = 102;
    TestCoeffEncoder.binProbs3[2][6][2][2] = 38;
})();
var Intra4x4PredictionBuilderTest = function() {};
Intra4x4PredictionBuilderTest = stjs.extend(Intra4x4PredictionBuilderTest, null, [], function(constructor, prototype) {
    constructor.emptyResidual = new Int32Array(16);
    constructor.testResidual = new Int32Array(16);
    prototype.addResidual = function(pred, residual) {
        var result = new Int8Array(pred.length);
        for (var i = 0; i < pred.length; i++) 
            result[i] = (MathUtil.clip(pred[i] + residual[i], -128, 127) << 24 >> 24);
        return result;
    };
    prototype.inMB = function(is, blkX, blkY) {
        var result = new Int8Array(256);
        var idxMap = new Int32Array([0, 1, 2, 3, 16, 17, 18, 19, 32, 33, 34, 35, 48, 49, 50, 51]);
        var off = (blkY << 4) + blkX;
        for (var i = 0; i < 16; i++) {
            result[idxMap[i] + off] = is[i];
        }
        return result;
    };
    prototype.testDC = function() {
        var pred = new Int8Array(256);
        var top = ArrayUtil.toByteArrayShifted(1, 2, 3, 4, 5, 6, 7, 8);
        var left = ArrayUtil.toByteArrayShifted(9, 10, 11, 12);
        Intra4x4PredictionBuilder.predictDC(Intra4x4PredictionBuilderTest.emptyResidual, true, true, left, top, 0, 0, 0, pred);
        Assert.assertArrayEquals(this.inMB(ArrayUtil.toByteArrayShifted(7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7), 0, 0), pred);
        for (var blkY = 0; blkY < 16; blkY += 4) {
            for (var blkX = 0; blkX < 16; blkX += 4) {
                Arrays.fill(pred, (0 << 24 >> 24));
                Intra4x4PredictionBuilder.predictDC(Intra4x4PredictionBuilderTest.testResidual, true, true, ArrayUtil.padLeft(left, blkY), ArrayUtil.padLeft(top, blkX), 0, blkX, blkY, pred);
                Assert.assertArrayEquals("@[" + blkX + ", " + blkY + "]", this.inMB(this.addResidual(ArrayUtil.toByteArrayShifted(7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7), Intra4x4PredictionBuilderTest.testResidual), blkX, blkY), pred);
            }
        }
    };
    prototype.testVertical = function() {
        var pred = new Int8Array(256);
        var top = ArrayUtil.toByteArrayShifted(1, 2, 3, 4, 5, 6, 7, 8);
        Intra4x4PredictionBuilder.predictVertical(Intra4x4PredictionBuilderTest.emptyResidual, true, top, 0, 0, 0, pred);
        Assert.assertArrayEquals(this.inMB(ArrayUtil.toByteArrayShifted(1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4), 0, 0), pred);
        for (var blkY = 0; blkY < 16; blkY += 4) {
            for (var blkX = 0; blkX < 16; blkX += 4) {
                Arrays.fill(pred, (0 << 24 >> 24));
                Intra4x4PredictionBuilder.predictVertical(Intra4x4PredictionBuilderTest.testResidual, true, ArrayUtil.padLeft(top, blkX), 0, blkX, blkY, pred);
                Assert.assertArrayEquals("@[" + blkX + ", " + blkY + "]", this.inMB(this.addResidual(ArrayUtil.toByteArrayShifted(1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4), Intra4x4PredictionBuilderTest.testResidual), blkX, blkY), pred);
            }
        }
    };
    prototype.testHorizontal = function() {
        var pred = new Int8Array(256);
        var left = ArrayUtil.toByteArrayShifted(9, 10, 11, 12);
        Intra4x4PredictionBuilder.predictHorizontal(Intra4x4PredictionBuilderTest.emptyResidual, true, left, 0, 0, 0, pred);
        Assert.assertArrayEquals(this.inMB(ArrayUtil.toByteArrayShifted(9, 9, 9, 9, 10, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 12), 0, 0), pred);
        for (var blkY = 0; blkY < 16; blkY += 4) {
            for (var blkX = 0; blkX < 16; blkX += 4) {
                Arrays.fill(pred, (0 << 24 >> 24));
                Intra4x4PredictionBuilder.predictHorizontal(Intra4x4PredictionBuilderTest.testResidual, true, ArrayUtil.padLeft(left, blkY), 0, blkX, blkY, pred);
                Assert.assertArrayEquals("@[" + blkX + ", " + blkY + "]", this.inMB(this.addResidual(ArrayUtil.toByteArrayShifted(9, 9, 9, 9, 10, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 12), Intra4x4PredictionBuilderTest.testResidual), blkX, blkY), pred);
            }
        }
    };
    prototype.testDiagonalDownLeft = function() {
        var pred = new Int8Array(256);
        var top = ArrayUtil.toByteArrayShifted(209, 212, 218, 222, 216, 219, 225, 229);
        Intra4x4PredictionBuilder.predictDiagonalDownLeft(Intra4x4PredictionBuilderTest.emptyResidual, true, true, top, 0, 0, 0, pred);
        Assert.assertArrayEquals(this.inMB(ArrayUtil.toByteArrayShifted(213, 218, 220, 218, 218, 220, 218, 220, 220, 218, 220, 225, 218, 220, 225, 228), 0, 0), pred);
        for (var blkY = 0; blkY < 16; blkY += 4) {
            for (var blkX = 0; blkX < 16; blkX += 4) {
                Arrays.fill(pred, (0 << 24 >> 24));
                Intra4x4PredictionBuilder.predictDiagonalDownLeft(Intra4x4PredictionBuilderTest.testResidual, true, true, ArrayUtil.padLeft(top, blkX), 0, blkX, blkY, pred);
                Assert.assertArrayEquals("@[" + blkX + ", " + blkY + "]", this.inMB(this.addResidual(ArrayUtil.toByteArrayShifted(213, 218, 220, 218, 218, 220, 218, 220, 220, 218, 220, 225, 218, 220, 225, 228), Intra4x4PredictionBuilderTest.testResidual), blkX, blkY), pred);
            }
        }
    };
    prototype.testDiagonalDownRight = function() {
        var pred = new Int8Array(256);
        var top = ArrayUtil.toByteArrayShifted(183, 196, 170, 131, 0, 0, 0, 0);
        var left = ArrayUtil.toByteArrayShifted(207, 207, 207, 207);
        var tl = ArrayUtil.toByteArrayShifted(196, 0, 0, 0);
        Intra4x4PredictionBuilder.predictDiagonalDownRight(Intra4x4PredictionBuilderTest.emptyResidual, true, true, left, top, tl, 0, 0, 0, pred);
        Assert.assertArrayEquals(this.inMB(ArrayUtil.toByteArrayShifted(196, 190, 186, 167, 204, 196, 190, 186, 207, 204, 196, 190, 207, 207, 204, 196), 0, 0), pred);
        for (var blkY = 0; blkY < 16; blkY += 4) {
            for (var blkX = 0; blkX < 16; blkX += 4) {
                Arrays.fill(pred, (0 << 24 >> 24));
                Intra4x4PredictionBuilder.predictDiagonalDownRight(Intra4x4PredictionBuilderTest.testResidual, true, true, ArrayUtil.padLeft(left, blkY), ArrayUtil.padLeft(top, blkX), ArrayUtil.padLeft(tl, blkY >> 2), 0, blkX, blkY, pred);
                Assert.assertArrayEquals("@[" + blkX + ", " + blkY + "]", this.inMB(this.addResidual(ArrayUtil.toByteArrayShifted(196, 190, 186, 167, 204, 196, 190, 186, 207, 204, 196, 190, 207, 207, 204, 196), Intra4x4PredictionBuilderTest.testResidual), blkX, blkY), pred);
            }
        }
    };
    prototype.testDiagonalDownRight1 = function() {
        var pred = new Int8Array(256);
        var top = ArrayUtil.toByteArrayShifted(236, 236, 236, 236, 0, 0, 0, 0);
        var left = ArrayUtil.toByteArrayShifted(233, 233, 233, 233);
        var tl = ArrayUtil.toByteArrayShifted(226, 0, 0, 0);
        Intra4x4PredictionBuilder.predictDiagonalDownRight(Intra4x4PredictionBuilderTest.emptyResidual, true, true, left, top, tl, 0, 0, 0, pred);
        Assert.assertArrayEquals(this.inMB(ArrayUtil.toByteArrayShifted(230, 234, 236, 236, 231, 230, 234, 236, 233, 231, 230, 234, 233, 233, 231, 230), 0, 0), pred);
        for (var blkY = 0; blkY < 16; blkY += 4) {
            for (var blkX = 0; blkX < 16; blkX += 4) {
                Arrays.fill(pred, (0 << 24 >> 24));
                Intra4x4PredictionBuilder.predictDiagonalDownRight(Intra4x4PredictionBuilderTest.testResidual, true, true, ArrayUtil.padLeft(left, blkY), ArrayUtil.padLeft(top, blkX), ArrayUtil.padLeft(tl, blkY >> 2), 0, blkX, blkY, pred);
                Assert.assertArrayEquals("@[" + blkX + ", " + blkY + "]", this.inMB(this.addResidual(ArrayUtil.toByteArrayShifted(230, 234, 236, 236, 231, 230, 234, 236, 233, 231, 230, 234, 233, 233, 231, 230), Intra4x4PredictionBuilderTest.testResidual), blkX, blkY), pred);
            }
        }
    };
    prototype.testVerticalRight = function() {
        var pred = new Int8Array(256);
        var top = ArrayUtil.toByteArrayShifted(207, 201, 197, 175, 0, 0, 0, 0);
        var left = ArrayUtil.toByteArrayShifted(208, 176, 129, 122);
        var tl = ArrayUtil.toByteArrayShifted(206, 0, 0, 0);
        Intra4x4PredictionBuilder.predictVerticalRight(Intra4x4PredictionBuilderTest.emptyResidual, true, true, left, top, tl, 0, 0, 0, pred);
        Assert.assertArrayEquals(this.inMB(ArrayUtil.toByteArrayShifted(207, 204, 199, 186, 207, 205, 202, 193, 200, 207, 204, 199, 172, 207, 205, 202), 0, 0), pred);
        for (var blkY = 0; blkY < 16; blkY += 4) {
            for (var blkX = 0; blkX < 16; blkX += 4) {
                Arrays.fill(pred, (0 << 24 >> 24));
                Intra4x4PredictionBuilder.predictVerticalRight(Intra4x4PredictionBuilderTest.testResidual, true, true, ArrayUtil.padLeft(left, blkY), ArrayUtil.padLeft(top, blkX), ArrayUtil.padLeft(tl, blkY >> 2), 0, blkX, blkY, pred);
                Assert.assertArrayEquals("@[" + blkX + ", " + blkY + "]", this.inMB(this.addResidual(ArrayUtil.toByteArrayShifted(207, 204, 199, 186, 207, 205, 202, 193, 200, 207, 204, 199, 172, 207, 205, 202), Intra4x4PredictionBuilderTest.testResidual), blkX, blkY), pred);
            }
        }
    };
    prototype.testHorizontalDown = function() {
        var pred = new Int8Array(256);
        var top = ArrayUtil.toByteArrayShifted(209, 157, 114, 118);
        var left = ArrayUtil.toByteArrayShifted(197, 198, 202, 205);
        var tl = ArrayUtil.toByteArrayShifted(204, 0, 0, 0);
        Intra4x4PredictionBuilder.predictHorizontalDown(Intra4x4PredictionBuilderTest.emptyResidual, true, true, left, top, tl, 0, 0, 0, pred);
        Assert.assertArrayEquals(this.inMB(ArrayUtil.toByteArrayShifted(201, 204, 195, 159, 198, 199, 201, 204, 200, 199, 198, 199, 204, 202, 200, 199), 0, 0), pred);
        for (var blkY = 0; blkY < 16; blkY += 4) {
            for (var blkX = 0; blkX < 16; blkX += 4) {
                Arrays.fill(pred, (0 << 24 >> 24));
                Intra4x4PredictionBuilder.predictHorizontalDown(Intra4x4PredictionBuilderTest.testResidual, true, true, ArrayUtil.padLeft(left, blkY), ArrayUtil.padLeft(top, blkX), ArrayUtil.padLeft(tl, blkY >> 2), 0, blkX, blkY, pred);
                Assert.assertArrayEquals("@[" + blkX + ", " + blkY + "]", this.inMB(this.addResidual(ArrayUtil.toByteArrayShifted(201, 204, 195, 159, 198, 199, 201, 204, 200, 199, 198, 199, 204, 202, 200, 199), Intra4x4PredictionBuilderTest.testResidual), blkX, blkY), pred);
            }
        }
    };
    prototype.testVerticalLeft = function() {
        var pred = new Int8Array(256);
        var top = ArrayUtil.toByteArrayShifted(215, 201, 173, 159, 137, 141, 150, 155);
        Intra4x4PredictionBuilder.predictVerticalLeft(Intra4x4PredictionBuilderTest.emptyResidual, true, true, top, 0, 0, 0, pred);
        Assert.assertArrayEquals(this.inMB(ArrayUtil.toByteArrayShifted(208, 187, 166, 148, 198, 177, 157, 144, 187, 166, 148, 139, 177, 157, 144, 142), 0, 0), pred);
        for (var blkY = 0; blkY < 16; blkY += 4) {
            for (var blkX = 0; blkX < 16; blkX += 4) {
                Arrays.fill(pred, (0 << 24 >> 24));
                Intra4x4PredictionBuilder.predictVerticalLeft(Intra4x4PredictionBuilderTest.testResidual, true, true, ArrayUtil.padLeft(top, blkX), 0, blkX, blkY, pred);
                Assert.assertArrayEquals("@[" + blkX + ", " + blkY + "]", this.inMB(this.addResidual(ArrayUtil.toByteArrayShifted(208, 187, 166, 148, 198, 177, 157, 144, 187, 166, 148, 139, 177, 157, 144, 142), Intra4x4PredictionBuilderTest.testResidual), blkX, blkY), pred);
            }
        }
    };
    prototype.testHorizontalUp = function() {
        var pred = new Int8Array(256);
        var left = ArrayUtil.toByteArrayShifted(175, 180, 216, 221);
        Intra4x4PredictionBuilder.predictHorizontalUp(Intra4x4PredictionBuilderTest.emptyResidual, true, left, 0, 0, 0, pred);
        Assert.assertArrayEquals(this.inMB(ArrayUtil.toByteArrayShifted(178, 188, 198, 208, 198, 208, 219, 220, 219, 220, 221, 221, 221, 221, 221, 221), 0, 0), pred);
        for (var blkY = 0; blkY < 16; blkY += 4) {
            for (var blkX = 0; blkX < 16; blkX += 4) {
                Arrays.fill(pred, (0 << 24 >> 24));
                Intra4x4PredictionBuilder.predictHorizontalUp(Intra4x4PredictionBuilderTest.testResidual, true, ArrayUtil.padLeft(left, blkY), 0, blkX, blkY, pred);
                Assert.assertArrayEquals("@[" + blkX + ", " + blkY + "]", this.inMB(this.addResidual(ArrayUtil.toByteArrayShifted(178, 188, 198, 208, 198, 208, 219, 220, 219, 220, 221, 221, 221, 221, 221, 221), Intra4x4PredictionBuilderTest.testResidual), blkX, blkY), pred);
            }
        }
    };
}, {emptyResidual: "Int32Array", testResidual: "Int32Array"}, {});
(function() {
    for (var i = 0; i < 16; i++) {
        Intra4x4PredictionBuilderTest.testResidual[i] = 16 * i - 128;
    }
})();
var EbmlUtilTest = function() {};
EbmlUtilTest = stjs.extend(EbmlUtilTest, null, [], function(constructor, prototype) {
    prototype.testReadingOverLimit = function() {
        var fis = new FileInputStream("./src/test/resources/mkv/10frames.webm");
        try {
            var source = new FileChannelWrapper(fis.getChannel());
            var buffer = ByteBuffer.allocate(8);
            buffer.setLimit(1);
            source.read(buffer);
            System.out.println(EbmlUtil.toHexString(buffer.array()));
            buffer.setLimit(2);
            source.read(buffer);
            System.out.println(EbmlUtil.toHexString(buffer.array()));
        } finally {
            fis.close();
        }
    };
    prototype.testComputeLength = function() {
        Assert.assertEquals(1, EbmlUtil.computeLength((128 << 24 >> 24)));
        Assert.assertEquals(2, EbmlUtil.computeLength((64 << 24 >> 24)));
        Assert.assertEquals(3, EbmlUtil.computeLength((32 << 24 >> 24)));
        Assert.assertEquals(4, EbmlUtil.computeLength((16 << 24 >> 24)));
        Assert.assertEquals(5, EbmlUtil.computeLength((8 << 24 >> 24)));
        Assert.assertEquals(6, EbmlUtil.computeLength((4 << 24 >> 24)));
        Assert.assertEquals(7, EbmlUtil.computeLength((2 << 24 >> 24)));
        Assert.assertEquals(8, EbmlUtil.computeLength((1 << 24 >> 24)));
        try {
            EbmlUtil.computeLength((0 << 24 >> 24));
            Assert.fail("Max length is 8");
        }catch (re) {
            System.out.println(re.getMessage());
        }
    };
    prototype.testEbmlBytes = function() {
        Assert.assertArrayEquals(new Int8Array([(129 << 24 >> 24)]), EbmlUtil.ebmlEncode(1));
        Assert.assertArrayEquals(new Int8Array([64, (128 << 24 >> 24)]), EbmlUtil.ebmlEncode(128));
        Assert.assertArrayEquals(new Int8Array([32, 64, 0]), EbmlUtil.ebmlEncode(16384));
    };
    prototype.testEbmlLength = function() {
        Assert.assertEquals(1, EbmlUtil.ebmlLength(0));
        Assert.assertEquals(1, EbmlUtil.ebmlLength(127));
        Assert.assertEquals(2, EbmlUtil.ebmlLength(128));
        Assert.assertEquals(2, EbmlUtil.ebmlLength(128));
    };
}, {}, {});
var AWTUtil = function() {};
AWTUtil = stjs.extend(AWTUtil, null, [], function(constructor, prototype) {
    constructor.toBufferedImage = function(src) {
        if (src.getColor() != ColorSpace.RGB) {
            var transform = ColorUtil.getTransform(src.getColor(), ColorSpace.RGB);
            if (transform == null) {
                 throw new IllegalArgumentException("Unsupported input colorspace: " + src.getColor());
            }
            var out = Picture.create(src.getWidth(), src.getHeight(), ColorSpace.RGB);
            transform.transform(src, out);
            new RgbToBgr().transform(out, out);
            src = out;
        }
        var dst = new BufferedImage(src.getCroppedWidth(), src.getCroppedHeight(), BufferedImage.TYPE_3BYTE_BGR);
        if (src.getCrop() == null) 
            AWTUtil.toBufferedImage2(src, dst);
         else 
            AWTUtil.toBufferedImageCropped(src, dst);
        return dst;
    };
    constructor.toBufferedImageCropped = function(src, dst) {
        var data = (dst.getRaster().getDataBuffer()).getData();
        var srcData = src.getPlaneData(0);
        var dstStride = dst.getWidth() * 3;
        var srcStride = src.getWidth() * 3;
        for (var line = 0, srcOff = 0, dstOff = 0; line < dst.getHeight(); line++) {
            for (var id = dstOff, is = srcOff; id < dstOff + dstStride; id += 3 , is += 3) {
                data[id] = (srcData[is] << 24 >> 24);
                data[id + 1] = (srcData[is + 1] << 24 >> 24);
                data[id + 2] = (srcData[is + 2] << 24 >> 24);
            }
            srcOff += srcStride;
            dstOff += dstStride;
        }
    };
    constructor.toBufferedImage8Bit2 = function(src, dst) {
        var data = (dst.getRaster().getDataBuffer()).getData();
        var srcData = src.getPlaneData(0);
        for (var i = 0; i < data.length; i++) {
            data[i] = ((srcData[i] + 128) << 24 >> 24);
        }
    };
    constructor.toBufferedImage8Bit = function(src) {
        if (src.getColor() != ColorSpace.RGB) {
            var transform = ColorUtil.getTransform8Bit(src.getColor(), ColorSpace.RGB);
            if (transform == null) {
                 throw new IllegalArgumentException("Unsupported input colorspace: " + src.getColor());
            }
            var out = Picture8Bit.create(src.getWidth(), src.getHeight(), ColorSpace.RGB);
            transform.transform(src, out);
            new RgbToBgr8Bit().transform(out, out);
            src = out;
        }
        var dst = new BufferedImage(src.getCroppedWidth(), src.getCroppedHeight(), BufferedImage.TYPE_3BYTE_BGR);
        if (src.getCrop() == null) 
            AWTUtil.toBufferedImage8Bit2(src, dst);
         else 
            AWTUtil.toBufferedImageCropped8Bit(src, dst);
        return dst;
    };
    constructor.toBufferedImageCropped8Bit = function(src, dst) {
        var data = (dst.getRaster().getDataBuffer()).getData();
        var srcData = src.getPlaneData(0);
        var dstStride = dst.getWidth() * 3;
        var srcStride = src.getWidth() * 3;
        for (var line = 0, srcOff = 0, dstOff = 0; line < dst.getHeight(); line++) {
            for (var id = dstOff, is = srcOff; id < dstOff + dstStride; id += 3 , is += 3) {
                data[id] = ((srcData[is] + 128) << 24 >> 24);
                data[id + 1] = ((srcData[is + 1] + 128) << 24 >> 24);
                data[id + 2] = ((srcData[is + 2] + 128) << 24 >> 24);
            }
            srcOff += srcStride;
            dstOff += dstStride;
        }
    };
    constructor.toBufferedImage2 = function(src, dst) {
        var data = (dst.getRaster().getDataBuffer()).getData();
        var srcData = src.getPlaneData(0);
        for (var i = 0; i < data.length; i++) {
            data[i] = (srcData[i] << 24 >> 24);
        }
    };
    constructor.fromBufferedImage = function(src) {
        var dst = Picture.create(src.getWidth(), src.getHeight(), ColorSpace.RGB);
        AWTUtil.fromBufferedImage2(src, dst);
        return dst;
    };
    constructor.fromBufferedImage2 = function(src, dst) {
        var dstData = dst.getPlaneData(0);
        var off = 0;
        for (var i = 0; i < src.getHeight(); i++) {
            for (var j = 0; j < src.getWidth(); j++) {
                var rgb1 = src.getRGB(j, i);
                dstData[off++] = (rgb1 >> 16) & 255;
                dstData[off++] = (rgb1 >> 8) & 255;
                dstData[off++] = rgb1 & 255;
            }
        }
    };
}, {}, {});
/**
 *  @see http://multimedia.cx/eggs/category/vp8/
 *  @see https://ritdml.rit.edu/bitstream/handle/1850/14525/SCassidyThesis11-2011.pdf?sequence=1
 *  @see http://www-ee.uta.edu/Dip/Courses/EE5359/2011SpringFinalReportPPT/Shah_EE5359Spring2011FinalPPT.pdf
 *  
 */
var VP8EncoderTest = function() {};
VP8EncoderTest = stjs.extend(VP8EncoderTest, null, [], function(constructor, prototype) {
    constructor.naturalToZigzag4x4Index = new Int32Array([0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15]);
    constructor.zigzagToNatural4x4Index = new Int32Array([0, 1, 5, 6, 2, 4, 7, 12, 3, 8, 11, 13, 9, 10, 14, 15]);
    constructor.MBSIZE = 16;
    prototype.testBOr = function() {
        var skipInnerLoopFilter = false;
        skipInnerLoopFilter = skipInnerLoopFilter | VP8EncoderTest.d(false);
        System.out.println(skipInnerLoopFilter);
        skipInnerLoopFilter = skipInnerLoopFilter | VP8EncoderTest.d(true);
        skipInnerLoopFilter = skipInnerLoopFilter | VP8EncoderTest.d(false);
        System.out.println(skipInnerLoopFilter);
    };
    constructor.d = function(b) {
        System.out.println("executed d");
        return b;
    };
    constructor.yPlane = new Int32Array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]);
    prototype.testMacroblocking = function() {
        Assert.assertEquals(256, VP8EncoderTest.countNonZero(VP8EncoderTest.getMacroblock(0, 0, VP8EncoderTest.yPlane, 24, 23)));
        Assert.assertEquals(128, VP8EncoderTest.countNonZero(VP8EncoderTest.getMacroblock(1, 0, VP8EncoderTest.yPlane, 24, 23)));
        Assert.assertEquals(112, VP8EncoderTest.countNonZero(VP8EncoderTest.getMacroblock(0, 1, VP8EncoderTest.yPlane, 24, 23)));
        var mb11 = VP8EncoderTest.getMacroblock(1, 1, VP8EncoderTest.yPlane, 24, 23);
        Assert.assertEquals(56, VP8EncoderTest.countNonZero(mb11));
        Assert.assertArrayEquals(new Int32Array([17, 18, 19, 20, 21, 22, 23, 24, 0, 0, 0, 0, 0, 0, 0, 0, 17, 18, 19, 20, 21, 22, 23, 24, 0, 0, 0, 0, 0, 0, 0, 0, 17, 18, 19, 20, 21, 22, 23, 24, 0, 0, 0, 0, 0, 0, 0, 0, 17, 18, 19, 20, 21, 22, 23, 24, 0, 0, 0, 0, 0, 0, 0, 0, 17, 18, 19, 20, 21, 22, 23, 24, 0, 0, 0, 0, 0, 0, 0, 0, 17, 18, 19, 20, 21, 22, 23, 24, 0, 0, 0, 0, 0, 0, 0, 0, 17, 18, 19, 20, 21, 22, 23, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), mb11);
    };
    prototype.testSubblocking = function() {
        var mb11 = VP8EncoderTest.getMacroblock(1, 1, VP8EncoderTest.yPlane, 24, 23);
        Assert.assertArrayEquals(new Int32Array([17, 18, 19, 20, 17, 18, 19, 20, 17, 18, 19, 20, 0, 0, 0, 0]), this.getSubblock(0, 1, mb11));
        Assert.assertArrayEquals(new Int32Array([21, 22, 23, 24, 21, 22, 23, 24, 21, 22, 23, 24, 21, 22, 23, 24]), this.getSubblock(1, 0, mb11));
        Assert.assertArrayEquals(new Int32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), this.getSubblock(2, 3, mb11));
        Assert.assertArrayEquals(new Int32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), this.getSubblock(3, 3, mb11));
    };
    prototype.getSubblock = function(i, j, mb) {
        var X = i * 4;
        var Y = j * 64;
        var firstRow = 0 * 16 + Y, secondRow = 1 * 16 + Y, thirdRow = 2 * 16 + Y, fourthRow = 3 * 16 + Y;
        var firstColumn = 0 + X;
        var secondColumn = 1 + X;
        var thridColumn = 2 + X;
        var fourthColumn = 3 + X;
        return new Int32Array([mb[firstColumn + firstRow], mb[secondColumn + firstRow], mb[thridColumn + firstRow], mb[fourthColumn + firstRow], mb[firstColumn + secondRow], mb[secondColumn + secondRow], mb[thridColumn + secondRow], mb[fourthColumn + secondRow], mb[firstColumn + thirdRow], mb[secondColumn + thirdRow], mb[thridColumn + thirdRow], mb[fourthColumn + thirdRow], mb[firstColumn + fourthRow], mb[secondColumn + fourthRow], mb[thridColumn + fourthRow], mb[fourthColumn + fourthRow]]);
    };
    constructor.getMacroblock = function(x, y, p, width, height) {
        var result = new Int32Array(256);
        for (var j = 0; j < VP8EncoderTest.MBSIZE; j++) 
            for (var i = 0; i < VP8EncoderTest.MBSIZE; i++) {
                var k = j + y * VP8EncoderTest.MBSIZE;
                var l = i + x * VP8EncoderTest.MBSIZE;
                if (l < width && k < height) 
                    result[j * VP8EncoderTest.MBSIZE + i] = p[k * width + l];
            }
        return result;
    };
    constructor.countNonZero = function(a) {
        var result = 0;
        for (var el in a) 
            if (el != 0) 
                result++;
        return result;
    };
    prototype.getMbData = function(is, height, width, mbRows, mbCols) {};
    prototype.test = function() {
        var input = new Int32Array([92, 91, 89, 86, 91, 90, 88, 86, 89, 89, 89, 88, 89, 87, 88, 93]);
        var predictorRemoved = VP8EncoderTest.LinearAlgebraUtil.substractScalar(input, 128);
        Assert.assertArrayEquals(new Int32Array([-36, -37, -39, -42, -37, -38, -40, -42, -39, -39, -39, -40, -39, -41, -40, -35]), predictorRemoved);
        var transformed = VP8DCT.encodeDCT(predictorRemoved);
        Assert.assertArrayEquals(new Int32Array([-312, 7, 1, 0, 1, 12, -5, 2, 2, -3, 3, -1, 1, 0, -2, 1]), transformed);
    };
    constructor.LinearAlgebraUtil = function() {};
    constructor.LinearAlgebraUtil = stjs.extend(constructor.LinearAlgebraUtil, null, [], function(constructor, prototype) {
        constructor.multiplyByScalar = function(vector, scalar) {
            var result = new Int32Array(vector.length);
            for (var i = 0; i < vector.length; i++) 
                result[i] = vector[i] * scalar;
            return result;
        };
        constructor.divideByScalar = function(vector, scalar) {
            var result = new Int32Array(vector.length);
            for (var i = 0; i < vector.length; i++) 
                result[i] = stjs.trunc(vector[i] / scalar);
            return result;
        };
        constructor.substractScalar = function(vector, scalar) {
            var result = new Int32Array(vector.length);
            for (var i = 0; i < vector.length; i++) 
                result[i] = vector[i] - scalar;
            return result;
        };
        constructor.substractVector = function(vector1, vector2) {
            if (vector1.length != vector2.length) 
                 throw new RuntimeException("vector1.length (" + vector1.length + ") != vector2.length (" + vector2.length + ")");
            var result = new Int32Array(vector1.length);
            for (var i = 0; i < vector1.length; i++) 
                result[i] = vector1[i] - vector2[i];
            return result;
        };
        constructor.serialize2DTo1DArray = function(_in) {
            if (_in.length == 0) 
                 throw new RuntimeException("_in.length == 0. Two-dimentional array required.");
            var width = _in[0].length;
            var result = new Int32Array(_in.length * width);
            for (var i = 0; i < _in.length; i++) {
                if (width != _in[i].length) 
                     throw new RuntimeException("_in[" + i + "].length != _in[0].length. A rectangular two-dimentional array required.");
                for (var j = 0; j < _in[i].length; j++) {
                    result[i * width + j] = _in[i][j];
                }
            }
            return result;
        };
        constructor.intArrayToShortArray = function(array) {
            var result = new Int16Array(array.length);
            for (var i = 0; i < array.length; i++) 
                result[i] = ((array[i]) << 16 >> 16);
            return result;
        };
    }, {}, {});
}, {naturalToZigzag4x4Index: "Int32Array", zigzagToNatural4x4Index: "Int32Array", yPlane: "Int32Array"}, {});
var TrunBoxTest = function() {};
TrunBoxTest = stjs.extend(TrunBoxTest, null, [], function(constructor, prototype) {
    prototype.testReadWriteCreate = function() {
        var box = TrunBox.create(2).dataOffset(20).sampleCompositionOffset(new Int32Array([11, 12])).sampleDuration(new Int32Array([15, 16])).sampleFlags(new Int32Array([100, 200])).sampleSize(new Int32Array([30, 40])).create();
        System.out.println(box.toString());
        var bb = ByteBuffer.allocate(1024);
        box.write(bb);
        bb.flip();
        var parsed = TrunBox.createTrunBox();
        bb.getLong();
        parsed.parse(bb);
        Assert.assertEquals(box.toString(), parsed.toString());
    };
}, {}, {});
var PPSReadTest = function() {};
PPSReadTest = stjs.extend(PPSReadTest, null, [], function(constructor, prototype) {
    prototype.expected = null;
    prototype.setUp = function() {
        this.expected = new PictureParameterSet();
        this.expected.pic_parameter_set_id = 0;
        this.expected.seq_parameter_set_id = 0;
        this.expected.entropy_coding_mode_flag = true;
        this.expected.pic_order_present_flag = false;
        this.expected.num_slice_groups_minus1 = 0;
        this.expected.num_ref_idx_active_minus1 = new Int32Array([0, 0]);
        this.expected.weighted_pred_flag = false;
        this.expected.weighted_bipred_idc = 0;
        this.expected.pic_init_qp_minus26 = 0;
        this.expected.pic_init_qs_minus26 = 0;
        this.expected.chroma_qp_index_offset = -2;
        this.expected.deblocking_filter_control_present_flag = true;
        this.expected.constrained_intra_pred_flag = false;
        this.expected.redundant_pic_cnt_present_flag = false;
    };
    prototype.testRead = function() {
        var bb = NIOUtils.fetchFromFile(new File("src/test/resources/h264/pps/pps.dat"));
        var pps = PictureParameterSet.read(bb);
        Assert.assertEquals(this.expected, pps);
    };
}, {expected: "PictureParameterSet"}, {});
var SliceHeaderTest = function() {};
SliceHeaderTest = stjs.extend(SliceHeaderTest, null, [], function(constructor, prototype) {
    prototype.test1 = function() {
        var data = new Int8Array([-102, 79, 8, 100, -54, 97, 55]);
        var sps = new Int16Array([100, 0, 21, 172, 178, 1, 0, 75, 127, 224, 0, 96, 0, 130, 0, 0, 0, 2, 0, 0, 0, 100, 30, 44, 92, 144]);
        var pps = new Int16Array([235, 194, 203, 34, 192]);
        var shr = new SliceHeaderReader();
        var shw = new SliceHeaderWriter();
        var reader = BitReader.createBitReader(ByteBuffer.wrap(data));
        var out = ByteBuffer.allocate(data.length);
        var writer = new BitWriter(out);
        var sps1 = SeqParameterSet.read(ByteBuffer.wrap(this.asByteArray(sps)));
        var pps1 = PictureParameterSet.read(ByteBuffer.wrap(this.asByteArray(pps)));
        var sh = shr.readPart1(reader);
        shr.readPart2(sh, new NALUnit(NALUnitType.NON_IDR_SLICE, 1), sps1, pps1, reader);
        shw.write(sh, false, 1, writer);
        writer.flush();
        out.flip();
        var array = NIOUtils.toArray(out);
        for (var b in array) {
            System.out.println(b);
        }
        Assert.assertArrayEquals(data, NIOUtils.toArray(out));
    };
    prototype.asByteArray = function(src) {
        var result = new Int8Array(src.length);
        for (var i = 0; i < src.length; i++) {
            result[i] = (src[i] << 24 >> 24);
        }
        return result;
    };
}, {}, {});
var MacroblockBiDecodingTest = function() {};
MacroblockBiDecodingTest = stjs.extend(MacroblockBiDecodingTest, null, [], function(constructor, prototype) {
    prototype.testB16x16CABAC = function() {
        var encoded = "src/test/resources/h264/cabac/test_b_16x16.264";
        var decoded = "src/test/resources/h264/cabac/test_b_16x16.yuv";
        var nFrames = 3;
        this.testOneFile(encoded, decoded, nFrames, new Int32Array([0, 2, 1]));
    };
    prototype.testB16x8CABAC = function() {
        var encoded = "src/test/resources/h264/cabac/test_b_16x8.264";
        var decoded = "src/test/resources/h264/cabac/test_b_16x8.yuv";
        var nFrames = 3;
        this.testOneFile(encoded, decoded, nFrames, new Int32Array([0, 2, 1]));
    };
    prototype.testB4x4CABAC = function() {
        var encoded = "src/test/resources/h264/cabac/test_b_4x4.264";
        var decoded = "src/test/resources/h264/cabac/test_b_4x4.yuv";
        var nFrames = 3;
        this.testOneFile(encoded, decoded, nFrames, new Int32Array([0, 2, 1]));
    };
    prototype.testB4x8CABAC = function() {
        var encoded = "src/test/resources/h264/cabac/test_b_4x8.264";
        var decoded = "src/test/resources/h264/cabac/test_b_4x8.yuv";
        var nFrames = 3;
        this.testOneFile(encoded, decoded, nFrames, new Int32Array([0, 2, 1]));
    };
    prototype.testB8x16CABAC = function() {
        var encoded = "src/test/resources/h264/cabac/test_b_8x16.264";
        var decoded = "src/test/resources/h264/cabac/test_b_8x16.yuv";
        var nFrames = 3;
        this.testOneFile(encoded, decoded, nFrames, new Int32Array([0, 2, 1]));
    };
    prototype.testB8x4CABAC = function() {
        var encoded = "src/test/resources/h264/cabac/test_b_8x4.264";
        var decoded = "src/test/resources/h264/cabac/test_b_8x4.yuv";
        var nFrames = 3;
        this.testOneFile(encoded, decoded, nFrames, new Int32Array([0, 2, 1]));
    };
    prototype.testB8x8CABAC = function() {
        var encoded = "src/test/resources/h264/cabac/test_b_8x8.264";
        var decoded = "src/test/resources/h264/cabac/test_b_8x8.yuv";
        var nFrames = 3;
        this.testOneFile(encoded, decoded, nFrames, new Int32Array([0, 2, 1]));
    };
    prototype.testBSkipABAC = function() {
        var encoded = "src/test/resources/h264/cabac/test_b_skip.264";
        var decoded = "src/test/resources/h264/cabac/test_b_skip.yuv";
        var nFrames = 3;
        this.testOneFile(encoded, decoded, nFrames, new Int32Array([0, 2, 1]));
    };
    prototype.testBi16x16CABAC = function() {
        var encoded = "src/test/resources/h264/cabac/test_bi_16x16.264";
        var decoded = "src/test/resources/h264/cabac/test_bi_16x16.yuv";
        var nFrames = 3;
        this.testOneFile(encoded, decoded, nFrames, new Int32Array([0, 2, 1]));
    };
    prototype.testBi16x8CABAC = function() {
        var encoded = "src/test/resources/h264/cabac/test_bi_16x8.264";
        var decoded = "src/test/resources/h264/cabac/test_bi_16x8.yuv";
        var nFrames = 3;
        this.testOneFile(encoded, decoded, nFrames, new Int32Array([0, 2, 1]));
    };
    prototype.testBi8x16CABAC = function() {
        var encoded = "src/test/resources/h264/cabac/test_bi_8x16.264";
        var decoded = "src/test/resources/h264/cabac/test_bi_8x16.yuv";
        var nFrames = 3;
        this.testOneFile(encoded, decoded, nFrames, new Int32Array([0, 2, 1]));
    };
    prototype.testBi8x8CABAC = function() {
        var encoded = "src/test/resources/h264/cabac/test_bi_8x8.264";
        var decoded = "src/test/resources/h264/cabac/test_bi_8x8.yuv";
        var nFrames = 3;
        this.testOneFile(encoded, decoded, nFrames, new Int32Array([0, 2, 1]));
    };
    prototype.testMixedBiRef = function() {
        var encoded = "src/test/resources/h264/cabac/test_bi_mix_ref.264";
        var decoded = "src/test/resources/h264/cabac/test_bi_mix_ref.yuv";
        var nFrames = 5;
        this.testOneFile(encoded, decoded, nFrames, new Int32Array([0, 2, 3, 4, 1]));
    };
    prototype.testLongTermCABAC = function() {
        var encoded = "src/test/resources/h264/cabac/test_long_term_cabac.264";
        var decoded = "src/test/resources/h264/cabac/test_long_term_cabac.yuv";
        var nFrames = 3;
        this.testOneFile(encoded, decoded, nFrames, new Int32Array([0, 1, 2]));
    };
    prototype.testBiDirectSpatialNoInference = function() {
        var encoded = "src/test/resources/h264/cabac/test_spat_direct_noinf.264";
        var decoded = "src/test/resources/h264/cabac/test_spat_direct_noinf.yuv";
        var nFrames = 3;
        this.testOneFile(encoded, decoded, nFrames, new Int32Array([0, 2, 1]));
    };
    prototype.testSpatialDirect = function() {
        var encoded = "src/test/resources/h264/cabac/test_spat_direct.264";
        var decoded = "src/test/resources/h264/cabac/test_spat_direct.yuv";
        var nFrames = 3;
        this.testOneFile(encoded, decoded, nFrames, new Int32Array([0, 2, 1]));
    };
    prototype.testBiDirectTemporalNoInference = function() {
        var encoded = "src/test/resources/h264/cabac/test_temp_direct_noinf.264";
        var decoded = "src/test/resources/h264/cabac/test_temp_direct_noinf.yuv";
        var nFrames = 3;
        this.testOneFile(encoded, decoded, nFrames, new Int32Array([0, 2, 1]));
    };
    prototype.testBiDirectTemporal = function() {
        var encoded = "src/test/resources/h264/cabac/test_temp_direct.264";
        var decoded = "src/test/resources/h264/cabac/test_temp_direct.yuv";
        var nFrames = 3;
        this.testOneFile(encoded, decoded, nFrames, new Int32Array([0, 2, 1]));
    };
    prototype.testB16x16CAVLC = function() {
        var encoded = "src/test/resources/h264/cavlc/test_b_16x16_cavlc.264";
        var decoded = "src/test/resources/h264/cavlc/test_b_16x16_cavlc.yuv";
        var nFrames = 3;
        this.testOneFile(encoded, decoded, nFrames, new Int32Array([0, 2, 1]));
    };
    prototype.testB16x8CAVLC = function() {
        var encoded = "src/test/resources/h264/cavlc/test_b_16x8_cavlc.264";
        var decoded = "src/test/resources/h264/cavlc/test_b_16x8_cavlc.yuv";
        var nFrames = 3;
        this.testOneFile(encoded, decoded, nFrames, new Int32Array([0, 2, 1]));
    };
    prototype.testB4x4CAVLC = function() {
        var encoded = "src/test/resources/h264/cavlc/test_b_4x4_cavlc.264";
        var decoded = "src/test/resources/h264/cavlc/test_b_4x4_cavlc.yuv";
        var nFrames = 3;
        this.testOneFile(encoded, decoded, nFrames, new Int32Array([0, 2, 1]));
    };
    prototype.testB4x8CAVLC = function() {
        var encoded = "src/test/resources/h264/cavlc/test_b_4x8_cavlc.264";
        var decoded = "src/test/resources/h264/cavlc/test_b_4x8_cavlc.yuv";
        var nFrames = 3;
        this.testOneFile(encoded, decoded, nFrames, new Int32Array([0, 2, 1]));
    };
    prototype.testB8x16CAVLC = function() {
        var encoded = "src/test/resources/h264/cavlc/test_b_8x16_cavlc.264";
        var decoded = "src/test/resources/h264/cavlc/test_b_8x16_cavlc.yuv";
        var nFrames = 3;
        this.testOneFile(encoded, decoded, nFrames, new Int32Array([0, 2, 1]));
    };
    prototype.testB8x4CAVLC = function() {
        var encoded = "src/test/resources/h264/cavlc/test_b_8x4_cavlc.264";
        var decoded = "src/test/resources/h264/cavlc/test_b_8x4_cavlc.yuv";
        var nFrames = 3;
        this.testOneFile(encoded, decoded, nFrames, new Int32Array([0, 2, 1]));
    };
    prototype.testB8x8CAVLC = function() {
        var encoded = "src/test/resources/h264/cavlc/test_b_8x8_cavlc.264";
        var decoded = "src/test/resources/h264/cavlc/test_b_8x8_cavlc.yuv";
        var nFrames = 3;
        this.testOneFile(encoded, decoded, nFrames, new Int32Array([0, 2, 1]));
    };
    prototype.testBi16x16CAVLC = function() {
        var encoded = "src/test/resources/h264/cavlc/test_bi_16x16_cavlc.264";
        var decoded = "src/test/resources/h264/cavlc/test_bi_16x16_cavlc.yuv";
        var nFrames = 3;
        this.testOneFile(encoded, decoded, nFrames, new Int32Array([0, 2, 1]));
    };
    prototype.testBi16x8CAVLC = function() {
        var encoded = "src/test/resources/h264/cavlc/test_bi_16x8_cavlc.264";
        var decoded = "src/test/resources/h264/cavlc/test_bi_16x8_cavlc.yuv";
        var nFrames = 3;
        this.testOneFile(encoded, decoded, nFrames, new Int32Array([0, 2, 1]));
    };
    prototype.testBi8x16CAVLC = function() {
        var encoded = "src/test/resources/h264/cavlc/test_bi_8x16_cavlc.264";
        var decoded = "src/test/resources/h264/cavlc/test_bi_8x16_cavlc.yuv";
        var nFrames = 3;
        this.testOneFile(encoded, decoded, nFrames, new Int32Array([0, 2, 1]));
    };
    prototype.testBi8x8CAVLC = function() {
        var encoded = "src/test/resources/h264/cavlc/test_bi_8x8_cavlc.264";
        var decoded = "src/test/resources/h264/cavlc/test_bi_8x8_cavlc.yuv";
        var nFrames = 3;
        this.testOneFile(encoded, decoded, nFrames, new Int32Array([0, 2, 1]));
    };
    prototype.testMixedBiRefCAVLC = function() {
        var encoded = "src/test/resources/h264/cavlc/test_bi_mix_ref_cavlc.264";
        var decoded = "src/test/resources/h264/cavlc/test_bi_mix_ref_cavlc.yuv";
        var nFrames = 5;
        this.testOneFile(encoded, decoded, nFrames, new Int32Array([0, 2, 3, 4, 1]));
    };
    prototype.testBiDirectSpatialCAVLC = function() {
        var encoded = "src/test/resources/h264/cavlc/test_bi_spat_direct_cavlc.264";
        var decoded = "src/test/resources/h264/cavlc/test_bi_spat_direct_cavlc.yuv";
        var nFrames = 3;
        this.testOneFile(encoded, decoded, nFrames, new Int32Array([0, 2, 1]));
    };
    prototype.testBiDirectSpatialNoInferenceCAVLC = function() {
        var encoded = "src/test/resources/h264/cavlc/test_bi_spat_direct_noinf_cavlc.264";
        var decoded = "src/test/resources/h264/cavlc/test_bi_spat_direct_noinf_cavlc.yuv";
        var nFrames = 3;
        this.testOneFile(encoded, decoded, nFrames, new Int32Array([0, 2, 1]));
    };
    prototype.testBiDirectTemporalCAVLC = function() {
        var encoded = "src/test/resources/h264/cavlc/test_bi_temp_direct_cavlc.264";
        var decoded = "src/test/resources/h264/cavlc/test_bi_temp_direct_cavlc.yuv";
        var nFrames = 3;
        this.testOneFile(encoded, decoded, nFrames, new Int32Array([0, 2, 1]));
    };
    prototype.testBiDirectTemporalNoInferenceCAVLC = function() {
        var encoded = "src/test/resources/h264/cavlc/test_bi_temp_direct_noinf_cavlc.264";
        var decoded = "src/test/resources/h264/cavlc/test_bi_temp_direct_noinf_cavlc.yuv";
        var nFrames = 3;
        this.testOneFile(encoded, decoded, nFrames, new Int32Array([0, 2, 1]));
    };
    prototype.testLongTermCAVLC = function() {
        var encoded = "src/test/resources/h264/cavlc/test_long_term_cavlc.264";
        var decoded = "src/test/resources/h264/cavlc/test_long_term_cavlc.yuv";
        var nFrames = 3;
        this.testOneFile(encoded, decoded, nFrames, new Int32Array([0, 1, 2]));
    };
    prototype.testOneFile = function(encoded, decoded, nFrames, reorderMap) {
        var es = new MappedH264ES(NIOUtils.fetchFromFile(new File(encoded)));
        var dec = new H264Decoder();
        var out = Array(nFrames);
        for (var i = 0; i < nFrames; i++) {
            out[i] = dec.decodeFrame8Bit(es.nextFrame().getData(), Picture8Bit.create(32, 32, ColorSpace.YUV420).getData());
        }
        var yuv = NIOUtils.fetchFromFile(new File(decoded));
        for (var i = 0; i < nFrames; i++) {
            Assert.assertArrayEquals(String.format("Frame %d luma", i), ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, 1024)), out[reorderMap[i]].getPlaneData(0));
            Assert.assertArrayEquals(String.format("Frame %d cb", i), ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, 256)), out[reorderMap[i]].getPlaneData(1));
            Assert.assertArrayEquals(String.format("Frame %d cr", i), ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, 256)), out[reorderMap[i]].getPlaneData(2));
        }
    };
}, {}, {});
var MacroblockInterDecodingTest = function() {};
MacroblockInterDecodingTest = stjs.extend(MacroblockInterDecodingTest, null, [], function(constructor, prototype) {
    prototype.testMBlockCABAC1 = function() {
        var es = new MappedH264ES(NIOUtils.fetchFromFile(new File("src/test/resources/h264/cabac/p_1/seq.264")));
        var dec = new H264Decoder();
        var out = [dec.decodeFrame8Bit(es.nextFrame().getData(), Picture8Bit.create(32, 32, ColorSpace.YUV420).getData()), dec.decodeFrame8Bit(es.nextFrame().getData(), Picture8Bit.create(32, 32, ColorSpace.YUV420).getData()), dec.decodeFrame8Bit(es.nextFrame().getData(), Picture8Bit.create(32, 32, ColorSpace.YUV420).getData())];
        var yuv = NIOUtils.fetchFromFile(new File("src/test/resources/h264/cabac/p_1/seq_dec.yuv"));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, 1024)), out[0].getPlaneData(0));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, 256)), out[0].getPlaneData(1));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, 256)), out[0].getPlaneData(2));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, 1024)), out[1].getPlaneData(0));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, 256)), out[1].getPlaneData(1));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, 256)), out[1].getPlaneData(2));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, 1024)), out[2].getPlaneData(0));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, 256)), out[2].getPlaneData(1));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, 256)), out[2].getPlaneData(2));
    };
    prototype.testMBlockCABAC2 = function() {
        var es = new MappedH264ES(NIOUtils.fetchFromFile(new File("src/test/resources/h264/cabac/p_2/seq.264")));
        var dec = new H264Decoder();
        var out = [dec.decodeFrame8Bit(es.nextFrame().getData(), Picture8Bit.create(32, 32, ColorSpace.YUV420).getData()), dec.decodeFrame8Bit(es.nextFrame().getData(), Picture8Bit.create(32, 32, ColorSpace.YUV420).getData()), dec.decodeFrame8Bit(es.nextFrame().getData(), Picture8Bit.create(32, 32, ColorSpace.YUV420).getData())];
        var yuv = NIOUtils.fetchFromFile(new File("src/test/resources/h264/cabac/p_2/seq_dec.yuv"));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, 1024)), out[0].getPlaneData(0));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, 256)), out[0].getPlaneData(1));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, 256)), out[0].getPlaneData(2));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, 1024)), out[1].getPlaneData(0));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, 256)), out[1].getPlaneData(1));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, 256)), out[1].getPlaneData(2));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, 1024)), out[2].getPlaneData(0));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, 256)), out[2].getPlaneData(1));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, 256)), out[2].getPlaneData(2));
    };
    prototype.testMBlockCAVLC1 = function() {
        var es = new MappedH264ES(NIOUtils.fetchFromFile(new File("src/test/resources/h264/cavlc/p_1/seq.264")));
        var dec = new H264Decoder();
        var out = [dec.decodeFrame8Bit(es.nextFrame().getData(), Picture8Bit.create(32, 32, ColorSpace.YUV420).getData()), dec.decodeFrame8Bit(es.nextFrame().getData(), Picture8Bit.create(32, 32, ColorSpace.YUV420).getData()), dec.decodeFrame8Bit(es.nextFrame().getData(), Picture8Bit.create(32, 32, ColorSpace.YUV420).getData())];
        var yuv = NIOUtils.fetchFromFile(new File("src/test/resources/h264/cavlc/p_1/seq_dec.yuv"));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, 1024)), out[0].getPlaneData(0));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, 256)), out[0].getPlaneData(1));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, 256)), out[0].getPlaneData(2));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, 1024)), out[1].getPlaneData(0));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, 256)), out[1].getPlaneData(1));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, 256)), out[1].getPlaneData(2));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, 1024)), out[2].getPlaneData(0));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, 256)), out[2].getPlaneData(1));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, 256)), out[2].getPlaneData(2));
    };
    prototype.testMBlockCAVLC2 = function() {
        var es = new MappedH264ES(NIOUtils.fetchFromFile(new File("src/test/resources/h264/cavlc/p_2/seq.264")));
        var dec = new H264Decoder();
        var out = [dec.decodeFrame8Bit(es.nextFrame().getData(), Picture8Bit.create(32, 32, ColorSpace.YUV420).getData()), dec.decodeFrame8Bit(es.nextFrame().getData(), Picture8Bit.create(32, 32, ColorSpace.YUV420).getData()), dec.decodeFrame8Bit(es.nextFrame().getData(), Picture8Bit.create(32, 32, ColorSpace.YUV420).getData())];
        var yuv = NIOUtils.fetchFromFile(new File("src/test/resources/h264/cavlc/p_2/seq_dec.yuv"));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, 1024)), out[0].getPlaneData(0));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, 256)), out[0].getPlaneData(1));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, 256)), out[0].getPlaneData(2));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, 1024)), out[1].getPlaneData(0));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, 256)), out[1].getPlaneData(1));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, 256)), out[1].getPlaneData(2));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, 1024)), out[2].getPlaneData(0));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, 256)), out[2].getPlaneData(1));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, 256)), out[2].getPlaneData(2));
    };
}, {}, {});
var MPEGUtilTest = function() {};
MPEGUtilTest = stjs.extend(MPEGUtilTest, null, [], function(constructor, prototype) {
    prototype.testGotoNextMarker = function() {
        var input = ByteBuffer.wrap(new Int8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 120, 1, 2, 3, 4, 5, 0, 0, 0, 0, 0, 0, 0, 1, 117, 6, 7, 8, 9, 10, 0, 0, 1, 114, 11, 12, 13]));
        var before1 = MPEGUtil.gotoNextMarker(input);
        Assert.assertArrayEquals(new Int8Array([0, 0, 0, 0, 0, 0, 0]), NIOUtils.toArray(before1));
        Assert.assertEquals(input.position(), 7);
        input.setPosition(input.position() + 4);
        var before2 = MPEGUtil.gotoNextMarker(input);
        Assert.assertArrayEquals(new Int8Array([1, 2, 3, 4, 5, 0, 0, 0, 0, 0]), NIOUtils.toArray(before2));
        Assert.assertEquals(input.position(), 21);
        Assert.assertEquals(1, before2.getAt(0));
        input.setPosition(input.position() + 4);
        var before3 = MPEGUtil.gotoNextMarker(input);
        Assert.assertArrayEquals(new Int8Array([6, 7, 8, 9, 10]), NIOUtils.toArray(before3));
        Assert.assertEquals(input.position(), 30);
        Assert.assertEquals(6, before3.getAt(0));
        input.setPosition(input.position() + 4);
        var before4 = MPEGUtil.gotoNextMarker(input);
        Assert.assertArrayEquals(new Int8Array([11, 12, 13]), NIOUtils.toArray(before4));
        Assert.assertFalse(input.hasRemaining());
        Assert.assertEquals(11, before4.getAt(0));
    };
    prototype.testNextSegment = function() {
        var input = ByteBuffer.wrap(new Int8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 120, 1, 2, 3, 4, 5, 0, 0, 0, 0, 0, 0, 0, 1, 117, 6, 7, 8, 9, 10, 0, 0, 1, 114, 11, 12, 13]));
        input.get();
        var segment1 = MPEGUtil.nextSegment(input);
        Assert.assertArrayEquals(new Int8Array([0, 0, 1, 120, 1, 2, 3, 4, 5, 0, 0, 0, 0, 0]), NIOUtils.toArray(segment1));
        var segment2 = MPEGUtil.nextSegment(input);
        Assert.assertArrayEquals(new Int8Array([0, 0, 1, 117, 6, 7, 8, 9, 10]), NIOUtils.toArray(segment2));
        var segment3 = MPEGUtil.nextSegment(input);
        Assert.assertArrayEquals(new Int8Array([0, 0, 1, 114, 11, 12, 13]), NIOUtils.toArray(segment3));
    };
}, {}, {});
var MPEGPredOctTest = function() {};
MPEGPredOctTest = stjs.extend(MPEGPredOctTest, null, [], function(constructor, prototype) {
    constructor.padded = ArrayUtil.toByteArrayShifted(new Int32Array([10, 10, 10, 20, 30, 40, 40, 40, 40, 10, 10, 10, 20, 30, 40, 40, 40, 40, 10, 10, 10, 20, 30, 40, 40, 40, 40, 50, 50, 50, 60, 70, 80, 80, 80, 80, 90, 90, 90, 100, 110, 120, 120, 120, 120, 130, 130, 130, 140, 150, 160, 160, 160, 160, 130, 130, 130, 140, 150, 160, 160, 160, 160, 130, 130, 130, 140, 150, 160, 160, 160, 160, 130, 130, 130, 140, 150, 160, 160, 160, 160]));
    constructor.unpadded = ArrayUtil.toByteArrayShifted(new Int32Array([10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160]));
    constructor.interp = [new Int32Array([10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160]), new Int32Array([11, 21, 31, 40, 51, 61, 71, 80, 91, 101, 111, 120, 131, 141, 151, 160]), new Int32Array([12, 22, 33, 41, 52, 62, 73, 81, 92, 102, 113, 121, 132, 142, 153, 161]), new Int32Array([13, 24, 34, 41, 53, 64, 74, 81, 93, 104, 114, 121, 133, 144, 154, 161]), new Int32Array([14, 25, 36, 41, 54, 65, 76, 81, 94, 105, 116, 121, 134, 145, 156, 161]), new Int32Array([16, 26, 37, 40, 56, 66, 77, 80, 96, 106, 117, 120, 136, 146, 157, 160]), new Int32Array([17, 28, 38, 40, 57, 68, 78, 80, 97, 108, 118, 120, 137, 148, 158, 160]), new Int32Array([19, 29, 39, 40, 59, 69, 79, 80, 99, 109, 119, 120, 139, 149, 159, 160]), new Int32Array([13, 23, 33, 43, 55, 65, 75, 85, 95, 105, 115, 125, 132, 142, 152, 162]), new Int32Array([14, 24, 34, 44, 56, 66, 76, 85, 96, 107, 117, 126, 133, 143, 153, 162]), new Int32Array([15, 26, 36, 44, 57, 67, 78, 86, 97, 108, 118, 126, 134, 144, 155, 162]), new Int32Array([16, 27, 37, 44, 58, 69, 79, 86, 98, 109, 119, 126, 135, 146, 156, 163]), new Int32Array([17, 28, 39, 44, 59, 70, 81, 86, 100, 110, 121, 126, 136, 147, 158, 163]), new Int32Array([19, 29, 40, 44, 61, 71, 82, 85, 101, 112, 122, 126, 138, 148, 159, 162]), new Int32Array([20, 31, 41, 44, 62, 73, 83, 85, 103, 113, 124, 126, 139, 149, 160, 162]), new Int32Array([22, 32, 42, 43, 64, 74, 84, 85, 104, 114, 125, 125, 141, 151, 161, 162]), new Int32Array([17, 27, 37, 47, 60, 70, 80, 90, 101, 111, 121, 131, 132, 142, 152, 162]), new Int32Array([18, 28, 39, 48, 60, 71, 81, 90, 102, 113, 123, 132, 133, 143, 154, 163]), new Int32Array([19, 30, 40, 48, 61, 72, 83, 90, 103, 114, 124, 132, 134, 145, 155, 163]), new Int32Array([20, 31, 41, 48, 63, 73, 84, 90, 104, 115, 125, 132, 135, 146, 156, 163]), new Int32Array([21, 32, 43, 48, 64, 75, 85, 90, 105, 116, 127, 132, 136, 147, 158, 163]), new Int32Array([23, 34, 44, 48, 66, 76, 87, 90, 107, 118, 128, 132, 138, 149, 159, 163]), new Int32Array([24, 35, 45, 48, 67, 77, 88, 90, 108, 119, 129, 132, 139, 150, 160, 163]), new Int32Array([26, 36, 46, 47, 68, 78, 89, 90, 110, 120, 130, 131, 141, 151, 161, 162]), new Int32Array([22, 32, 42, 52, 65, 75, 85, 95, 107, 117, 127, 137, 133, 143, 153, 163]), new Int32Array([23, 33, 43, 52, 65, 76, 86, 95, 107, 118, 128, 137, 134, 144, 154, 163]), new Int32Array([24, 34, 45, 52, 66, 77, 88, 95, 108, 119, 129, 137, 135, 145, 156, 163]), new Int32Array([25, 36, 46, 53, 68, 78, 89, 95, 110, 120, 131, 137, 136, 146, 157, 164]), new Int32Array([26, 37, 48, 53, 69, 80, 90, 95, 111, 122, 132, 137, 137, 148, 159, 164]), new Int32Array([28, 38, 49, 52, 71, 81, 92, 95, 112, 123, 134, 137, 139, 149, 160, 163]), new Int32Array([29, 39, 50, 52, 72, 82, 93, 95, 114, 124, 135, 137, 140, 150, 161, 163]), new Int32Array([31, 41, 51, 52, 73, 83, 94, 95, 115, 125, 136, 137, 141, 152, 162, 163]), new Int32Array([27, 37, 47, 57, 70, 80, 90, 100, 113, 123, 133, 143, 133, 143, 153, 163]), new Int32Array([28, 38, 48, 57, 71, 81, 91, 100, 114, 124, 134, 144, 134, 144, 154, 164]), new Int32Array([29, 39, 50, 57, 72, 82, 93, 101, 115, 126, 136, 144, 135, 146, 156, 164]), new Int32Array([30, 41, 51, 58, 73, 84, 94, 101, 116, 127, 137, 144, 136, 147, 157, 164]), new Int32Array([31, 42, 53, 58, 74, 85, 96, 101, 117, 128, 139, 144, 137, 148, 159, 164]), new Int32Array([33, 43, 54, 57, 76, 86, 97, 100, 119, 129, 140, 144, 139, 149, 160, 164]), new Int32Array([34, 44, 55, 57, 77, 88, 98, 100, 120, 131, 141, 144, 140, 151, 161, 164]), new Int32Array([36, 46, 56, 57, 79, 89, 99, 100, 122, 132, 142, 143, 142, 152, 162, 163]), new Int32Array([33, 43, 53, 63, 75, 85, 95, 105, 118, 128, 138, 148, 132, 142, 152, 162]), new Int32Array([34, 45, 55, 64, 76, 87, 97, 106, 119, 129, 139, 149, 133, 143, 153, 162]), new Int32Array([35, 46, 56, 64, 77, 88, 98, 106, 120, 131, 141, 149, 134, 144, 155, 162]), new Int32Array([36, 47, 58, 64, 78, 89, 99, 106, 121, 132, 142, 149, 135, 146, 156, 163]), new Int32Array([38, 48, 59, 64, 80, 90, 101, 106, 122, 133, 144, 149, 136, 147, 158, 163]), new Int32Array([39, 50, 60, 64, 81, 92, 102, 106, 124, 134, 145, 149, 138, 148, 159, 162]), new Int32Array([41, 51, 62, 64, 83, 93, 104, 106, 125, 136, 146, 149, 139, 149, 160, 162]), new Int32Array([42, 52, 63, 64, 84, 94, 105, 105, 127, 137, 147, 148, 141, 151, 161, 162]), new Int32Array([39, 49, 59, 69, 80, 90, 100, 110, 123, 133, 143, 153, 132, 142, 152, 162]), new Int32Array([40, 50, 60, 69, 81, 92, 102, 111, 124, 134, 144, 153, 133, 143, 153, 162]), new Int32Array([41, 51, 62, 69, 82, 93, 103, 111, 125, 135, 146, 153, 134, 144, 155, 162]), new Int32Array([42, 52, 63, 69, 83, 94, 104, 111, 126, 136, 147, 154, 135, 146, 156, 163]), new Int32Array([43, 54, 65, 70, 85, 95, 106, 111, 127, 138, 149, 154, 136, 147, 158, 163]), new Int32Array([45, 55, 66, 69, 86, 97, 107, 111, 129, 139, 150, 153, 138, 148, 159, 162]), new Int32Array([46, 56, 67, 69, 88, 98, 109, 111, 130, 140, 151, 153, 139, 149, 160, 162]), new Int32Array([47, 58, 68, 69, 89, 99, 110, 110, 131, 142, 152, 153, 141, 151, 161, 162]), new Int32Array([45, 55, 65, 75, 85, 95, 105, 115, 127, 137, 147, 157, 130, 140, 150, 160]), new Int32Array([45, 56, 66, 75, 86, 96, 106, 115, 128, 138, 148, 157, 131, 142, 152, 161]), new Int32Array([46, 57, 68, 75, 87, 97, 108, 116, 129, 139, 150, 157, 132, 143, 153, 161]), new Int32Array([48, 58, 69, 75, 88, 99, 109, 116, 130, 141, 151, 158, 133, 144, 154, 161]), new Int32Array([49, 60, 70, 75, 89, 100, 111, 116, 131, 142, 153, 158, 135, 145, 156, 161]), new Int32Array([51, 61, 72, 75, 91, 101, 112, 115, 133, 143, 154, 157, 136, 147, 157, 161]), new Int32Array([52, 62, 73, 75, 92, 103, 113, 115, 134, 144, 155, 157, 138, 148, 159, 161]), new Int32Array([53, 63, 74, 75, 94, 104, 114, 115, 136, 146, 156, 157, 139, 149, 160, 160])];
    constructor.topFieldInt = function(pix, w, h) {
        var result = new Int32Array(pix.length * 2);
        for (var i = 0, soff = 0, roff = 0; i < h; i++) {
            for (var j = 0; j < w; j++ , soff++ , roff++) {
                result[roff] = pix[soff];
            }
            for (var j = 0; j < w; j++ , roff++) {
                result[roff] = 0;
            }
        }
        return result;
    };
    constructor.bottomFieldInt = function(pix, w, h) {
        var result = new Int32Array(pix.length * 2);
        for (var i = 0, soff = 0, roff = 0; i < h; i++) {
            for (var j = 0; j < w; j++ , roff++) {
                result[roff] = 0;
            }
            for (var j = 0; j < w; j++ , soff++ , roff++) {
                result[roff] = pix[soff];
            }
        }
        return result;
    };
    constructor.topField = function(pix, w, h) {
        var result = new Int8Array(pix.length * 2);
        for (var i = 0, soff = 0, roff = 0; i < h; i++) {
            for (var j = 0; j < w; j++ , soff++ , roff++) {
                result[roff] = pix[soff];
            }
            for (var j = 0; j < w; j++ , roff++) {
                result[roff] = 0;
            }
        }
        return result;
    };
    constructor.bottomField = function(pix, w, h) {
        var result = new Int8Array(pix.length * 2);
        for (var i = 0, soff = 0, roff = 0; i < h; i++) {
            for (var j = 0; j < w; j++ , roff++) {
                result[roff] = 0;
            }
            for (var j = 0; j < w; j++ , soff++ , roff++) {
                result[roff] = pix[soff];
            }
        }
        return result;
    };
    prototype.testSafe = function() {
        var pred = new MPEGPredOct(new MPEGPred([], 0, true));
        for (var y = 0; y < 8; y++) {
            for (var x = 0; x < 8; x++) {
                var result = new Int32Array(16);
                pred.predictPlane(MPEGPredOctTest.padded, (2 << 3) + x, (2 << 3) + y, 9, 9, 0, 0, result, 0, 32, 32, 0);
                Assert.assertArrayEquals("@ " + x + "," + y, MPEGPredOctTest.interp[(y << 3) + x], result);
                var result32 = new Int32Array(32);
                pred.predictPlane(MPEGPredOctTest.topField(MPEGPredOctTest.padded, 9, 9), (2 << 3) + x, (2 << 3) + y, 9, 18, 1, 0, result32, 0, 32, 32, 1);
                Assert.assertArrayEquals("@ " + x + "," + y + ":tff", MPEGPredOctTest.topFieldInt(MPEGPredOctTest.interp[(y << 3) + x], 4, 4), result32);
                Arrays.fill(result32, 0);
                pred.predictPlane(MPEGPredOctTest.bottomField(MPEGPredOctTest.padded, 9, 9), (2 << 3) + x, (2 << 3) + y, 9, 18, 1, 1, result32, 1, 32, 32, 1);
                Assert.assertArrayEquals("@ " + x + "," + y + ":bff", MPEGPredOctTest.bottomFieldInt(MPEGPredOctTest.interp[(y << 3) + x], 4, 4), result32);
            }
        }
    };
    prototype.testUnsafe = function() {
        var pred = new MPEGPredOct(new MPEGPred([], 0, true));
        for (var y = 0; y < 8; y++) {
            for (var x = 0; x < 8; x++) {
                var result = new Int32Array(16);
                pred.predictPlane(MPEGPredOctTest.unpadded, x, y, 4, 4, 0, 0, result, 0, 32, 32, 0);
                Assert.assertArrayEquals("@ " + x + "," + y, MPEGPredOctTest.interp[(y << 3) + x], result);
                var result32 = new Int32Array(32);
                pred.predictPlane(MPEGPredOctTest.topField(MPEGPredOctTest.unpadded, 4, 4), x, y, 4, 8, 1, 0, result32, 0, 32, 32, 1);
                Assert.assertArrayEquals("@ " + x + "," + y + ":tff", MPEGPredOctTest.topFieldInt(MPEGPredOctTest.interp[(y << 3) + x], 4, 4), result32);
                Arrays.fill(result32, 0);
                pred.predictPlane(MPEGPredOctTest.bottomField(MPEGPredOctTest.unpadded, 4, 4), x, y, 4, 8, 1, 1, result32, 1, 32, 32, 1);
                Assert.assertArrayEquals("@ " + x + "," + y + ":bff", MPEGPredOctTest.bottomFieldInt(MPEGPredOctTest.interp[(y << 3) + x], 4, 4), result32);
            }
        }
    };
}, {padded: "Int8Array", unpadded: "Int8Array", interp: "Array"}, {});
var Intra8x8PredictionBuilderTest = function() {};
Intra8x8PredictionBuilderTest = stjs.extend(Intra8x8PredictionBuilderTest, null, [], function(constructor, prototype) {
    constructor.testResidual = new Int32Array(64);
    constructor.emptyResidual = new Int32Array(64);
    prototype.addResidual = function(pred, residual) {
        var result = new Int8Array(pred.length);
        for (var i = 0; i < pred.length; i++) 
            result[i] = (MathUtil.clip(pred[i] + residual[i], -128, 127) << 24 >> 24);
        return result;
    };
    prototype.inMB = function(is, blkX, blkY) {
        var result = new Int8Array(256);
        var off = (blkY << 4) + blkX;
        for (var i = 0; i < 8; i++) {
            for (var j = 0; j < 8; j++) 
                result[off + (i << 4) + j] = is[(i << 3) + j];
        }
        return result;
    };
    prototype.testDC = function() {
        var pred = new Int8Array(256);
        var top = ArrayUtil.toByteArrayShifted(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 64, 65, 66, 67, 68, 69, 70, 71);
        var left = ArrayUtil.toByteArrayShifted(16, 17, 18, 19, 20, 21, 22, 23);
        var topLeft = ArrayUtil.toByteArrayShifted(24);
        var expected = new Int8Array(64);
        Arrays.fill(expected, ((13 - 128) << 24 >> 24));
        new Intra8x8PredictionBuilder().predictDC(Intra8x8PredictionBuilderTest.emptyResidual, true, true, true, true, topLeft, left, top, 0, 0, 0, pred);
        Assert.assertArrayEquals(this.inMB(expected, 0, 0), pred);
        for (var blkY = 0; blkY < 16; blkY += 8) {
            for (var blkX = 0; blkX < 16; blkX += 8) {
                Arrays.fill(pred, (0 << 24 >> 24));
                new Intra8x8PredictionBuilder().predictDC(Intra8x8PredictionBuilderTest.testResidual, true, true, true, true, ArrayUtil.padLeft(topLeft, blkY >> 2), ArrayUtil.padLeft(left, blkY), ArrayUtil.padLeft(top, blkX), 0, blkX, blkY, pred);
                Assert.assertArrayEquals(this.inMB(this.addResidual(expected, Intra8x8PredictionBuilderTest.testResidual), blkX, blkY), pred);
            }
        }
    };
    prototype.testVertical = function() {
        var pred = new Int8Array(256);
        var top = ArrayUtil.toByteArrayShifted(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 64, 65, 66, 67, 68, 69, 70, 71);
        var topLeft = ArrayUtil.toByteArrayShifted(24, 0, 0, 0);
        var expected = ArrayUtil.toByteArrayShifted(7, 2, 3, 4, 5, 6, 7, 8, 7, 2, 3, 4, 5, 6, 7, 8, 7, 2, 3, 4, 5, 6, 7, 8, 7, 2, 3, 4, 5, 6, 7, 8, 7, 2, 3, 4, 5, 6, 7, 8, 7, 2, 3, 4, 5, 6, 7, 8, 7, 2, 3, 4, 5, 6, 7, 8, 7, 2, 3, 4, 5, 6, 7, 8);
        new Intra8x8PredictionBuilder().predictVertical(Intra8x8PredictionBuilderTest.emptyResidual, true, true, topLeft, top, 0, 0, 0, pred);
        Assert.assertArrayEquals(this.inMB(expected, 0, 0), pred);
        for (var blkY = 0; blkY < 16; blkY += 8) {
            for (var blkX = 0; blkX < 16; blkX += 8) {
                Arrays.fill(pred, (0 << 24 >> 24));
                new Intra8x8PredictionBuilder().predictVertical(Intra8x8PredictionBuilderTest.testResidual, true, true, ArrayUtil.padLeft(topLeft, blkY >> 2), ArrayUtil.padLeft(top, blkX), 0, blkX, blkY, pred);
                Assert.assertArrayEquals(this.inMB(this.addResidual(expected, Intra8x8PredictionBuilderTest.testResidual), blkX, blkY), pred);
            }
        }
    };
    prototype.testHorizontal = function() {
        var pred = new Int8Array(256);
        var left = ArrayUtil.toByteArrayShifted(16, 17, 18, 19, 20, 21, 22, 23);
        var topLeft = ArrayUtil.toByteArrayShifted(24, 0, 0, 0);
        var expected = ArrayUtil.toByteArrayShifted(18, 18, 18, 18, 18, 18, 18, 18, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23);
        new Intra8x8PredictionBuilder().predictHorizontal(Intra8x8PredictionBuilderTest.emptyResidual, true, topLeft, left, 0, 0, 0, pred);
        Assert.assertArrayEquals(this.inMB(expected, 0, 0), pred);
        for (var blkY = 0; blkY < 16; blkY += 8) {
            for (var blkX = 0; blkX < 16; blkX += 8) {
                Arrays.fill(pred, (0 << 24 >> 24));
                new Intra8x8PredictionBuilder().predictHorizontal(Intra8x8PredictionBuilderTest.testResidual, true, ArrayUtil.padLeft(topLeft, blkY >> 2), ArrayUtil.padLeft(left, blkY), 0, blkX, blkY, pred);
                Assert.assertArrayEquals(this.inMB(this.addResidual(expected, Intra8x8PredictionBuilderTest.testResidual), blkX, blkY), pred);
            }
        }
    };
    prototype.testDiagonalDownLeft = function() {
        var pred = new Int8Array(256);
        var top = ArrayUtil.toByteArrayShifted(10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160);
        var topLeft = ArrayUtil.toByteArrayShifted(170, 180, 190, 200);
        var expected = ArrayUtil.toByteArrayShifted(31, 30, 40, 50, 60, 70, 80, 90, 30, 40, 50, 60, 70, 80, 90, 100, 40, 50, 60, 70, 80, 90, 100, 110, 50, 60, 70, 80, 90, 100, 110, 120, 60, 70, 80, 90, 100, 110, 120, 130, 70, 80, 90, 100, 110, 120, 130, 140, 80, 90, 100, 110, 120, 130, 140, 150, 90, 100, 110, 120, 130, 140, 150, 156);
        new Intra8x8PredictionBuilder().predictDiagonalDownLeft(Intra8x8PredictionBuilderTest.emptyResidual, true, true, true, topLeft, top, 0, 0, 0, pred);
        Assert.assertArrayEquals(this.inMB(expected, 0, 0), pred);
        for (var blkY = 0; blkY < 16; blkY += 8) {
            for (var blkX = 0; blkX < 16; blkX += 8) {
                Arrays.fill(pred, (0 << 24 >> 24));
                new Intra8x8PredictionBuilder().predictDiagonalDownLeft(Intra8x8PredictionBuilderTest.testResidual, true, true, true, ArrayUtil.padLeft(topLeft, blkY >> 2), ArrayUtil.padLeft(top, blkX), 0, blkX, blkY, pred);
                Assert.assertArrayEquals(this.inMB(this.addResidual(expected, Intra8x8PredictionBuilderTest.testResidual), blkX, blkY), pred);
            }
        }
    };
    prototype.testDiagonalDownRight = function() {
        var pred = new Int8Array(256);
        var top = ArrayUtil.toByteArrayShifted(10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160);
        var left = ArrayUtil.toByteArrayShifted(210, 215, 220, 225, 230, 235, 240, 245);
        var tl = ArrayUtil.toByteArrayShifted(170, 180, 190, 200);
        var expected = ArrayUtil.toByteArrayShifted(134, 67, 31, 30, 40, 50, 60, 70, 189, 134, 67, 31, 30, 40, 50, 60, 213, 189, 134, 67, 31, 30, 40, 50, 220, 213, 189, 134, 67, 31, 30, 40, 225, 220, 213, 189, 134, 67, 31, 30, 230, 225, 220, 213, 189, 134, 67, 31, 235, 230, 225, 220, 213, 189, 134, 67, 240, 235, 230, 225, 220, 213, 189, 134);
        new Intra8x8PredictionBuilder().predictDiagonalDownRight(Intra8x8PredictionBuilderTest.emptyResidual, true, tl, left, top, 0, 0, 0, pred);
        Assert.assertArrayEquals(this.inMB(expected, 0, 0), pred);
        for (var blkY = 0; blkY < 16; blkY += 8) {
            for (var blkX = 0; blkX < 16; blkX += 8) {
                Arrays.fill(pred, (0 << 24 >> 24));
                new Intra8x8PredictionBuilder().predictDiagonalDownRight(Intra8x8PredictionBuilderTest.testResidual, true, ArrayUtil.padLeft(tl, blkY >> 2), ArrayUtil.padLeft(left, blkY), ArrayUtil.padLeft(top, blkX), 0, blkX, blkY, pred);
                Assert.assertArrayEquals(this.inMB(this.addResidual(expected, Intra8x8PredictionBuilderTest.testResidual), blkX, blkY), pred);
            }
        }
    };
    prototype.testVerticalRight = function() {
        var pred = new Int8Array(256);
        var top = ArrayUtil.toByteArrayShifted(10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160);
        var left = ArrayUtil.toByteArrayShifted(210, 215, 220, 225, 230, 235, 240, 245);
        var tl = ArrayUtil.toByteArrayShifted(170, 180, 190, 200);
        var expected = ArrayUtil.toByteArrayShifted(97, 37, 25, 35, 45, 55, 65, 75, 134, 67, 31, 30, 40, 50, 60, 70, 189, 97, 37, 25, 35, 45, 55, 65, 213, 134, 67, 31, 30, 40, 50, 60, 220, 189, 97, 37, 25, 35, 45, 55, 225, 213, 134, 67, 31, 30, 40, 50, 230, 220, 189, 97, 37, 25, 35, 45, 235, 225, 213, 134, 67, 31, 30, 40);
        new Intra8x8PredictionBuilder().predictVerticalRight(Intra8x8PredictionBuilderTest.emptyResidual, true, tl, left, top, 0, 0, 0, pred);
        Assert.assertArrayEquals(this.inMB(expected, 0, 0), pred);
        for (var blkY = 0; blkY < 16; blkY += 8) {
            for (var blkX = 0; blkX < 16; blkX += 8) {
                Arrays.fill(pred, (0 << 24 >> 24));
                new Intra8x8PredictionBuilder().predictVerticalRight(Intra8x8PredictionBuilderTest.testResidual, true, ArrayUtil.padLeft(tl, blkY >> 2), ArrayUtil.padLeft(left, blkY), ArrayUtil.padLeft(top, blkX), 0, blkX, blkY, pred);
                Assert.assertArrayEquals(this.inMB(this.addResidual(expected, Intra8x8PredictionBuilderTest.testResidual), blkX, blkY), pred);
            }
        }
    };
    prototype.testHorizontalDown = function() {
        var pred = new Int8Array(256);
        var top = ArrayUtil.toByteArrayShifted(10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160);
        var left = ArrayUtil.toByteArrayShifted(210, 215, 220, 225, 230, 235, 240, 245);
        var tl = ArrayUtil.toByteArrayShifted(170, 180, 190, 200);
        var expected = ArrayUtil.toByteArrayShifted(171, 134, 67, 31, 30, 40, 50, 60, 208, 189, 171, 134, 67, 31, 30, 40, 218, 213, 208, 189, 171, 134, 67, 31, 223, 220, 218, 213, 208, 189, 171, 134, 228, 225, 223, 220, 218, 213, 208, 189, 233, 230, 228, 225, 223, 220, 218, 213, 238, 235, 233, 230, 228, 225, 223, 220, 242, 240, 238, 235, 233, 230, 228, 225);
        new Intra8x8PredictionBuilder().predictHorizontalDown(Intra8x8PredictionBuilderTest.emptyResidual, true, tl, left, top, 0, 0, 0, pred);
        Assert.assertArrayEquals(this.inMB(expected, 0, 0), pred);
        for (var blkY = 0; blkY < 16; blkY += 8) {
            for (var blkX = 0; blkX < 16; blkX += 8) {
                Arrays.fill(pred, (0 << 24 >> 24));
                new Intra8x8PredictionBuilder().predictHorizontalDown(Intra8x8PredictionBuilderTest.testResidual, true, ArrayUtil.padLeft(tl, blkY >> 2), ArrayUtil.padLeft(left, blkY), ArrayUtil.padLeft(top, blkX), 0, blkX, blkY, pred);
                Assert.assertArrayEquals(this.inMB(this.addResidual(expected, Intra8x8PredictionBuilderTest.testResidual), blkX, blkY), pred);
            }
        }
    };
    prototype.testVerticalLeft = function() {
        var pred = new Int8Array(256);
        var top = ArrayUtil.toByteArrayShifted(10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160);
        var tl = ArrayUtil.toByteArrayShifted(170, 180, 190, 200);
        var expected = ArrayUtil.toByteArrayShifted(37, 25, 35, 45, 55, 65, 75, 85, 31, 30, 40, 50, 60, 70, 80, 90, 25, 35, 45, 55, 65, 75, 85, 95, 30, 40, 50, 60, 70, 80, 90, 100, 35, 45, 55, 65, 75, 85, 95, 105, 40, 50, 60, 70, 80, 90, 100, 110, 45, 55, 65, 75, 85, 95, 105, 115, 50, 60, 70, 80, 90, 100, 110, 120);
        new Intra8x8PredictionBuilder().predictVerticalLeft(Intra8x8PredictionBuilderTest.emptyResidual, true, true, tl, top, 0, 0, 0, pred);
        Assert.assertArrayEquals(this.inMB(expected, 0, 0), pred);
        for (var blkY = 0; blkY < 16; blkY += 8) {
            for (var blkX = 0; blkX < 16; blkX += 8) {
                Arrays.fill(pred, (0 << 24 >> 24));
                new Intra8x8PredictionBuilder().predictVerticalLeft(Intra8x8PredictionBuilderTest.testResidual, true, true, ArrayUtil.padLeft(tl, blkY >> 2), ArrayUtil.padLeft(top, blkX), 0, blkX, blkY, pred);
                Assert.assertArrayEquals(this.inMB(this.addResidual(expected, Intra8x8PredictionBuilderTest.testResidual), blkX, blkY), pred);
            }
        }
    };
    prototype.testHorizontalUp = function() {
        var pred = new Int8Array(256);
        var left = ArrayUtil.toByteArrayShifted(210, 215, 220, 225, 230, 235, 240, 245);
        var tl = ArrayUtil.toByteArrayShifted(170, 180, 190, 200);
        var expected = ArrayUtil.toByteArrayShifted(208, 213, 218, 220, 223, 225, 228, 230, 218, 220, 223, 225, 228, 230, 233, 235, 223, 225, 228, 230, 233, 235, 238, 240, 228, 230, 233, 235, 238, 240, 242, 243, 233, 235, 238, 240, 242, 243, 244, 244, 238, 240, 242, 243, 244, 244, 244, 244, 242, 243, 244, 244, 244, 244, 244, 244, 244, 244, 244, 244, 244, 244, 244, 244);
        new Intra8x8PredictionBuilder().predictHorizontalUp(Intra8x8PredictionBuilderTest.emptyResidual, true, tl, left, 0, 0, 0, pred);
        Assert.assertArrayEquals(this.inMB(expected, 0, 0), pred);
        for (var blkY = 0; blkY < 16; blkY += 8) {
            for (var blkX = 0; blkX < 16; blkX += 8) {
                Arrays.fill(pred, (0 << 24 >> 24));
                new Intra8x8PredictionBuilder().predictHorizontalUp(Intra8x8PredictionBuilderTest.testResidual, true, ArrayUtil.padLeft(tl, blkY >> 2), ArrayUtil.padLeft(left, blkY), 0, blkX, blkY, pred);
                Assert.assertArrayEquals(this.inMB(this.addResidual(expected, Intra8x8PredictionBuilderTest.testResidual), blkX, blkY), pred);
            }
        }
    };
}, {testResidual: "Int32Array", emptyResidual: "Int32Array"}, {});
(function() {
    for (var i = 0; i < 64; i++) {
        Intra8x8PredictionBuilderTest.testResidual[i] = (i << 2) - 128;
    }
})();
var FfmpegIntDctTest = function() {};
FfmpegIntDctTest = stjs.extend(FfmpegIntDctTest, null, [], function(constructor, prototype) {
    prototype.testPerformance = function() {
        var input = new Int16Array([-416, -33, -60, 32, 48, -40, 0, 0, 0, -24, -56, 19, 26, 0, 0, 0, -42, 13, 80, -24, -40, 0, 0, 0, -56, 17, 44, -29, 0, 0, 0, 0, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
        var dct = new FfmpegIntDct();
        var count = 40000000;
        var start = System.currentTimeMillis();
        var copy = new Int16Array(64);
        for (var i = 0; i < count; i++) {
            System.arraycopy(input, 0, copy, 0, 64);
            dct.decode(copy);
        }
        var time = System.currentTimeMillis() - start;
        var kdctPerSec = stjs.trunc(count / time);
        System.out.println(kdctPerSec + "kdct/sec");
    };
    prototype.testIdct = function() {
        var input = new Int16Array([-416, -33, -60, 32, 48, -40, 0, 0, 0, -24, -56, 19, 26, 0, 0, 0, -42, 13, 80, -24, -40, 0, 0, 0, -56, 17, 44, -29, 0, 0, 0, 0, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
        var expectedOutput = new Int32Array([60, 63, 55, 58, 70, 61, 58, 80, 58, 56, 56, 83, 108, 88, 63, 71, 60, 52, 62, 113, 150, 116, 70, 67, 66, 56, 68, 122, 156, 116, 69, 72, 69, 62, 65, 100, 120, 86, 59, 76, 68, 68, 61, 68, 78, 60, 53, 78, 74, 82, 67, 54, 63, 64, 65, 83, 83, 96, 77, 56, 70, 83, 83, 89]);
        var output = new FfmpegIntDct().decode(input);
        Debug.print8x8i(expectedOutput);
        Debug.print8x8s(output);
    };
}, {}, {});
var SampleOffsetUtilsTest = function() {};
SampleOffsetUtilsTest = stjs.extend(SampleOffsetUtilsTest, null, [], function(constructor, prototype) {
    constructor.f = new File("src/test/resources/petro_dae/95BCC757-7E23-445B-B7AB-6737208069FA/example1.mp4");
    prototype.testGetFirstSampleAtChunk = function() {
        var moov = MP4Util.parseMovie(SampleOffsetUtilsTest.f);
        var minf = moov.getAudioTracks().get(0).getMdia().getMinf();
        var stco = NodeBox.findFirstPath(minf, ChunkOffsetsBox, Box.path("stbl.stco"));
        var stsc = NodeBox.findFirstPath(minf, SampleToChunkBox, Box.path("stbl.stsc"));
        Assert.assertEquals(0, SampleOffsetUtils.getFirstSampleAtChunk(1, stsc, stco));
        Assert.assertEquals(2, SampleOffsetUtils.getFirstSampleAtChunk(2, stsc, stco));
        Assert.assertEquals(4, SampleOffsetUtils.getFirstSampleAtChunk(3, stsc, stco));
    };
    prototype.testGetChunkBySample = function() {
        var moov = MP4Util.parseMovie(SampleOffsetUtilsTest.f);
        var minf = moov.getAudioTracks().get(0).getMdia().getMinf();
        var stco = NodeBox.findFirstPath(minf, ChunkOffsetsBox, Box.path("stbl.stco"));
        var stsc = NodeBox.findFirstPath(minf, SampleToChunkBox, Box.path("stbl.stsc"));
        Assert.assertEquals(1, SampleOffsetUtils.getChunkBySample(0, stco, stsc));
        Assert.assertEquals(1, SampleOffsetUtils.getChunkBySample(1, stco, stsc));
        Assert.assertEquals(2, SampleOffsetUtils.getChunkBySample(2, stco, stsc));
        Assert.assertEquals(2, SampleOffsetUtils.getChunkBySample(3, stco, stsc));
    };
    prototype.testGetSamplesInChunk = function() {
        var moov = MP4Util.parseMovie(SampleOffsetUtilsTest.f);
        var minf = moov.getAudioTracks().get(0).getMdia().getMinf();
        var stsc = NodeBox.findFirstPath(minf, SampleToChunkBox, Box.path("stbl.stsc"));
        Assert.assertEquals(2, SampleOffsetUtils.getSamplesInChunk(1, stsc));
        Assert.assertEquals(2, SampleOffsetUtils.getSamplesInChunk(2, stsc));
        Assert.assertEquals(1, SampleOffsetUtils.getSamplesInChunk(4, stsc));
        Assert.assertEquals(4, SampleOffsetUtils.getSamplesInChunk(12, stsc));
    };
}, {f: "File"}, {});
var EbmlDateTest = function() {};
EbmlDateTest = stjs.extend(EbmlDateTest, null, [], function(constructor, prototype) {
    prototype.testFewBytesToLong = function() {
        var bb = ByteBuffer.wrap(new Int8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0]));
        var l = bb.getLong();
        Assert.assertEquals(1, l);
    };
    prototype.testSet = function() {
        var d = MKVType.createByType(MKVType.DateUTC);
        d.setLong(0);
        Assert.assertEquals(EbmlDateTest.getDate(1970, 1, 1), d.getDate());
        System.out.println(EbmlUtil.toHexString(d.data.array()));
        System.out.println(EbmlDateTest.getDate(2001, 1, 1));
    };
    constructor.getDate = function(year, month, day) {
        var c = Calendar.getInstance();
        c.set(year, month - 1, day);
        c.set(Calendar.HOUR, 0);
        c.set(Calendar.MINUTE, 0);
        c.set(Calendar.MILLISECOND, 0);
        return c.getTime();
    };
}, {}, {});
/**
 *  See for theoretical details: http://www.youtube.com/playlist?list=PLE125425EC837021F
 */
var ArithmeticCoderTest = function() {};
ArithmeticCoderTest = stjs.extend(ArithmeticCoderTest, null, [], function(constructor, prototype) {
    constructor.PRECISSION = 8;
    constructor.rs = new Int32Array([10, 25, 11, 15, 10]);
    constructor.printArrayAsHex = function(b) {
        var sb = new StringBuilder("{");
        if (b.length > 0) {
            sb.append("0x").append(Integer.toHexString(b[0] & 255).toUpperCase());
            for (var i = 1; i < b.length; i++) 
                sb.append(", 0x").append(Integer.toHexString(b[i] & 255).toUpperCase());
        }
        sb.append("}");
        return sb.toString();
    };
    prototype.testPrinting = function() {
        Assert.assertEquals("{0xD8}", ArithmeticCoderTest.printArrayAsHex(new Int8Array([(216 << 24 >> 24)])));
        Assert.assertEquals("{0xD8, 0x44}", ArithmeticCoderTest.printArrayAsHex(new Int8Array([(216 << 24 >> 24), 68])));
    };
    prototype.testEncoder = function() {
        var ac = new ArithmeticCoderTest.ArithmeticCoder(ArithmeticCoderTest.PRECISSION, ArithmeticCoderTest.rs);
        ac.encode(Arrays.asList([1, 2, 3, 4, 0]));
        Assert.assertArrayEquals(new Int8Array([92, 24]), ac.e.getArray());
        ac.encode(Arrays.asList([4, 0]));
        Assert.assertArrayEquals(new Int8Array([(220 << 24 >> 24)]), ac.e.getArray());
        ac.encode(Arrays.asList([1, 1, 1, 2, 0]));
        Assert.assertArrayEquals(new Int8Array([58, (128 << 24 >> 24)]), ac.e.getArray());
    };
    prototype.testDecoder = function() {
        var ad = new ArithmeticCoderTest.ArithmeticDecoder(ArithmeticCoderTest.PRECISSION, ArithmeticCoderTest.rs);
        ad.decode(new Int8Array([92, 24]));
        System.out.println(ad.data);
        ad.decode(new Int8Array([(220 << 24 >> 24)]));
        System.out.println(ad.data);
        ad.decode(new Int8Array([58, (128 << 24 >> 24)]));
        System.out.println(ad.data);
    };
    prototype.testCodingAndDecoding = function() {
        var smallRs = new Int32Array([2, 5, 1, 3, 2]);
        var ac = new ArithmeticCoderTest.ArithmeticCoder(ArithmeticCoderTest.PRECISSION, smallRs);
        var ad = new ArithmeticCoderTest.ArithmeticDecoder(ArithmeticCoderTest.PRECISSION, smallRs);
        var asList = Arrays.asList([1, 2, 3, 0]);
        ac.encode(asList);
        ad.decode(ac.e.getArray());
        Assert.assertEquals(asList, ad.data);
        asList = Arrays.asList([2, 3, 4, 0]);
        ac.encode(asList);
        ad.decode(ac.e.getArray());
        Assert.assertEquals(asList, ad.data);
        asList = Arrays.asList([1, 2, 4, 0]);
        ac.encode(asList);
        ad.decode(ac.e.getArray());
        Assert.assertEquals(asList, ad.data);
        asList = Arrays.asList([1, 3, 4, 0]);
        ac.encode(asList);
        ad.decode(ac.e.getArray());
        Assert.assertEquals(asList, ad.data);
        asList = Arrays.asList([4, 3, 4, 0]);
        ac.encode(asList);
        ad.decode(ac.e.getArray());
        Assert.assertEquals(asList, ad.data);
        asList = Arrays.asList([1, 2, 3, 4, 0]);
        ac.encode(asList);
        ad.decode(ac.e.getArray());
        Assert.assertEquals(asList, ad.data);
    };
    constructor.ArithmeticCoder = function(precission, r) {
        this.precission = precission;
        this.whole = (1 << precission);
        this.half = this.whole >> 1;
        this.quater = this.whole >> 2;
        this.r = r;
        this.c = new Int32Array(r.length);
        this.d = new Int32Array(r.length);
        this.d[0] = this.r[0];
        this.c[0] = 0;
        var bigR = r[0];
        for (var i = 1; i < r.length; i++) {
            for (var k = 0; k < i; k++) {
                this.c[i] += r[k];
            }
            this.d[i] = this.c[i] + r[i];
            bigR += r[i];
        }
        this.R = bigR;
    };
    constructor.ArithmeticCoder = stjs.extend(constructor.ArithmeticCoder, null, [], function(constructor, prototype) {
        prototype.precission = 0;
        prototype.whole = 0;
        prototype.half = 0;
        prototype.quater = 0;
        prototype.r = null;
        prototype.c = null;
        prototype.d = null;
        prototype.R = 0;
        prototype.e = null;
        constructor.sOnes = function(s) {
            return (1 << s) - 1;
        };
        prototype.emitZeroAndSOnes = function(s) {
            this.e.emit(0);
             while (s > 0){
                this.e.emit(1);
                s--;
            }
        };
        prototype.emitOneAndSZeros = function(s) {
            this.e.emit(1);
             while (s > 0){
                this.e.emit(0);
                s--;
            }
        };
        prototype.encode = function(input) {
            this.e = new ArithmeticCoderTest.Emitter();
            var a = 0;
            var b = this.whole;
            var s = 0;
            for (var index = 0; index < input.size(); index++) {
                var omega = b - a;
                b = a + Math.round((omega * this.d[input.get(index)]) / (this.R * 1.0));
                a = a + Math.round((omega * this.c[input.get(index)]) / (this.R * 1.0));
                 while (b < this.half || a > this.half){
                    if (b < this.half) {
                        this.emitZeroAndSOnes(s);
                        s = 0;
                        a = 2 * a;
                        b = 2 * b;
                    } else if (a > this.half) {
                        this.emitOneAndSZeros(s);
                        s = 0;
                        a = 2 * (a - this.half);
                        b = 2 * (b - this.half);
                    }
                }
                 while (a > this.quater && b < 3 * this.quater){
                    s++;
                    a = 2 * (a - this.quater);
                    b = 2 * (b - this.quater);
                }
            }
            s++;
            if (a <= this.quater) {
                this.emitZeroAndSOnes(s);
            } else {
                this.emitOneAndSZeros(s);
            }
        };
    }, {r: "Int32Array", c: "Int32Array", d: "Int32Array", e: "ArithmeticCoderTest.Emitter"}, {});
    constructor.ArithmeticDecoder = function(precission, r) {
        this.precission = precission;
        this.whole = (1 << precission);
        this.half = this.whole >> 1;
        this.quater = this.whole >> 2;
        this.r = r;
        this.c = new Int32Array(r.length);
        this.d = new Int32Array(r.length);
        this.d[0] = this.r[0];
        this.c[0] = 0;
        var bigR = r[0];
        for (var i = 1; i < r.length; i++) {
            for (var k = 0; k < i; k++) {
                this.c[i] += r[k];
            }
            this.d[i] = this.c[i] + r[i];
            bigR += r[i];
        }
        this.R = bigR;
    };
    constructor.ArithmeticDecoder = stjs.extend(constructor.ArithmeticDecoder, null, [], function(constructor, prototype) {
        prototype.precission = 0;
        prototype.whole = 0;
        prototype.half = 0;
        prototype.quater = 0;
        prototype.r = null;
        prototype.c = null;
        prototype.d = null;
        prototype.R = 0;
        prototype.data = null;
        prototype.decode = function(bs) {
            this.data = new ArrayList();
            var a = 0;
            var b = this.whole;
            var z = 0;
            var i = 0;
             while (i < this.precission && i < bs.length * 8){
                if (BooleanArithmeticDecoder.getBitInBytes(bs, ((i) | 0)) != 0) {
                    z += (1 << (this.precission - i - 1));
                }
                i++;
            }
             while (true){
                for (var j = 0; j < 5; j++) {
                    var omega = b - a;
                    var bzero = a + Math.round((omega * this.d[j]) / (this.R * 1.0));
                    var azero = a + Math.round((omega * this.c[j]) / (this.R * 1.0));
                    if (azero <= z && z < bzero) {
                        this.data.add(j);
                        a = azero;
                        b = bzero;
                        if (j == 0) {
                            return;
                        }
                        break;
                    }
                }
                 while (b < this.half || a > this.half){
                    if (b < this.half) {
                        a = 2 * a;
                        b = 2 * b;
                        z = 2 * z;
                    } else if (a > this.half) {
                        a = 2 * (a - this.half);
                        b = 2 * (b - this.half);
                        z = 2 * (z - this.half);
                    }
                    if (i < (bs.length * 8)) {
                        if (BooleanArithmeticDecoder.getBitInBytes(bs, ((i) | 0)) == 1) 
                            z++;
                        i++;
                    }
                }
                 while (a > this.quater && b < 3 * this.quater){
                    a = (a - this.quater) << 1;
                    b = (b - this.quater) << 1;
                    z = (z - this.quater) << 1;
                    if (i < (bs.length * 8)) {
                        if (BooleanArithmeticDecoder.getBitInBytes(bs, ((i) | 0)) == 1) 
                            z++;
                        i++;
                    }
                }
            }
        };
    }, {r: "Int32Array", c: "Int32Array", d: "Int32Array", data: {name: "List", arguments: [null]}}, {});
    prototype.testEmiter = function() {
        var p = new ArithmeticCoderTest.Emitter();
        Assert.assertArrayEquals(new Int8Array(), p.getArray());
        p.emit(1);
        p.emit(1);
        p.emit(0);
        p.emit(1);
        p.emit(1);
        p.emit(0);
        Assert.assertArrayEquals(new Int8Array([(216 << 24 >> 24)]), p.getArray());
        p = new ArithmeticCoderTest.Emitter();
        p.emit(0);
        p.emit(1);
        p.emit(0);
        p.emit(0);
        p.emit(0);
        p.emit(0);
        p.emit(1);
        p.emit(1);
        p.emit(0);
        p.emit(0);
        p.emit(1);
        Assert.assertArrayEquals(new Int8Array([67, 32]), p.getArray());
    };
    constructor.Emitter = function() {
        this.baos = new ByteArrayOutputStream();
    };
    constructor.Emitter = stjs.extend(constructor.Emitter, null, [], function(constructor, prototype) {
        prototype.i = 0;
        prototype.buffer = 0;
        prototype.baos = null;
        prototype.emit = function(b) {
            if (b != 1 && b != 0) 
                 throw new IllegalArgumentException("Only 0's and 1's are accepted");
            this.buffer |= b << (7 - this.i);
            this.i++;
            if (this.i > 7) {
                this.i = 0;
                this.baos.write(new Int8Array([this.buffer]));
                this.buffer = 0;
            }
        };
        prototype.getArray = function() {
            if (this.i != 0) {
                this.i = 0;
                this.baos.write(new Int8Array([this.buffer]));
                this.buffer = 0;
            }
            return this.baos.toByteArray();
        };
    }, {baos: "ByteArrayOutputStream"}, {});
}, {rs: "Int32Array"}, {});
var BinUtil = function() {};
BinUtil = stjs.extend(BinUtil, null, [], function(constructor, prototype) {
    /**
     *  Converts a string in the form "[01]*" into bits and packs them into byte
     *  array
     *  
     *  @param str
     *  @return
     */
    constructor.binaryStringToBytes = function(str) {
        var baos = new ByteArrayOutputStream();
        var curByte = 0;
        var i, bc = 0;
        for (i = 0; i < str.length; i++) {
            var bit;
            var charAt = str.charAt(i);
            if (charAt == '1') 
                bit = 1;
             else if (charAt == '0') 
                bit = 0;
             else 
                continue;
            curByte |= bit << (7 - bc % 8);
            if (bc % 8 == 7) {
                baos.write(curByte);
                curByte = 0;
            }
            bc++;
        }
        if (bc % 8 != 0) 
            baos.write(curByte);
        return baos.toByteArray();
    };
}, {}, {});
var TestWebmStreaming = function() {};
TestWebmStreaming = stjs.extend(TestWebmStreaming, null, [], function(constructor, prototype) {
    constructor.CUES_START = 1241;
    constructor.TWO_CUES_END = 1275;
    constructor.main1 = function(args) {
        var m1 = new File("src/test/resources/test.prores.mov");
        var ch1 = new FilePool(m1, 10);
        var mov1 = MP4Util.parseMovie(m1);
        var v1 = mov1.getVideoTrack();
        var rt = new RealTrack(mov1, v1, ch1);
        var start = System.currentTimeMillis();
        var cachePolicyExec = Executors.newSingleThreadScheduledExecutor();
        var vm = new VirtualWebmMovie(new CachingTrack(new Prores2VP8Track(rt, v1.getCodedSize()), 10, cachePolicyExec));
        System.out.println(System.currentTimeMillis() - start);
        var f = File.createTempFile("test", ".webm");
        System.out.println("Saving output to " + f.getAbsolutePath());
        var os = new BufferedOutputStream(new FileOutputStream(f));
        for (var off = 0; off < vm.size(); ) {
            var to = stjs.trunc((10000 * Math.random())) + off;
            var mr = new MovieRange(vm, off, to);
            IOUtils.copy(mr, os);
            mr.close();
            off = to + 1;
        }
        vm.close();
        os.close();
    };
    constructor.b = new Int8Array([(28 << 24 >> 24), (83 << 24 >> 24), (187 << 24 >> 24), (107 << 24 >> 24), (66 << 24 >> 24), (114 << 24 >> 24), (187 << 24 >> 24), (140 << 24 >> 24), (179 << 24 >> 24), (129 << 24 >> 24), (0 << 24 >> 24), (183 << 24 >> 24), (135 << 24 >> 24), (247 << 24 >> 24), (129 << 24 >> 24), (1 << 24 >> 24), (241 << 24 >> 24), (130 << 24 >> 24), (7 << 24 >> 24), (37 << 24 >> 24), (187 << 24 >> 24), (141 << 24 >> 24), (179 << 24 >> 24), (129 << 24 >> 24), (20 << 24 >> 24), (183 << 24 >> 24), (136 << 24 >> 24), (247 << 24 >> 24), (129 << 24 >> 24), (1 << 24 >> 24), (241 << 24 >> 24), (131 << 24 >> 24), (4 << 24 >> 24), (139 << 24 >> 24), (55 << 24 >> 24)]);
    prototype.testMovieRange = function() {
        var m1 = new File("src/test/resources/test.prores.mov");
        var ch1 = new FilePool(m1, 10);
        var mov1 = MP4Util.parseMovie(m1);
        var v1 = mov1.getVideoTrack();
        var rt = new RealTrack(mov1, v1, ch1);
        var start = System.currentTimeMillis();
        var cachePolicyExec = Executors.newSingleThreadScheduledExecutor();
        var vm = new VirtualWebmMovie(new CachingTrack(new Prores2VP8Track(rt, v1.getCodedSize()), 10, cachePolicyExec));
        System.out.println(System.currentTimeMillis() - start);
        var mr = null;
        try {
            var off = 24, to = 27;
            try {
                mr = new MovieRange(vm, off, to);
                Assert.assertArrayEquals("webm".getBytes(), IOUtils.toByteArray(mr));
            } finally {
                mr.close();
            }
            off = 36;
            to = 39;
            try {
                mr = new MovieRange(vm, off, to);
                Assert.assertArrayEquals(MKVType.Segment.id, IOUtils.toByteArray(mr));
            } finally {
                mr.close();
            }
            off = 297827;
            to = 297830;
            try {
                mr = new MovieRange(vm, off, to);
                Assert.assertArrayEquals(MKVType.Cluster.id, IOUtils.toByteArray(mr));
            } finally {
                mr.close();
            }
            off = TestWebmStreaming.CUES_START;
            to = TestWebmStreaming.TWO_CUES_END;
            try {
                mr = new MovieRange(vm, off, to);
                Assert.assertArrayEquals(TestWebmStreaming.b, IOUtils.toByteArray(mr));
            } finally {
                mr.close();
            }
        } finally {
            vm.close();
        }
    };
    prototype.testMultiRangeCopying = function() {
        var m1 = new File("src/test/resources/test.prores.mov");
        var ch1 = new FilePool(m1, 10);
        var mov1 = MP4Util.parseMovie(m1);
        var v1 = mov1.getVideoTrack();
        var rt = new RealTrack(mov1, v1, ch1);
        var cachePolicyExec = Executors.newSingleThreadScheduledExecutor();
        var vm = new VirtualWebmMovie(new CachingTrack(new Prores2VP8Track(rt, v1.getCodedSize()), 10, cachePolicyExec));
        var baos = new ByteArrayOutputStream(TestWebmStreaming.b.length);
        for (var off = TestWebmStreaming.CUES_START; off < TestWebmStreaming.TWO_CUES_END; ) {
            var remaining = TestWebmStreaming.TWO_CUES_END - off;
            var to = Math.min(stjs.trunc((remaining * Math.random())) + off + 1, TestWebmStreaming.TWO_CUES_END);
            var mr = new MovieRange(vm, off, to);
            var copied = IOUtils.copy(mr, baos);
            var len = to - off + 1;
            System.out.println("off: " + off + " to: " + to + " len: " + len + " copied: " + copied);
            Assert.assertTrue("copied " + copied + " bytes, which is more then required " + len, len >= copied);
            mr.close();
            off = to + 1;
        }
        vm.close();
        Assert.assertArrayEquals(TestWebmStreaming.b, baos.toByteArray());
        baos.close();
    };
}, {b: "Int8Array"}, {});
var ChromaPredictionBuilderTest = function() {};
ChromaPredictionBuilderTest = stjs.extend(ChromaPredictionBuilderTest, null, [], function(constructor, prototype) {
    constructor.emptyResidual = Array.apply(null, Array(4)).map(function() {
        return new Int32Array(16);
    });
    prototype.testVertical = function() {
        var expectedCb = ArrayUtil.toByteArrayShifted(129, 127, 122, 119, 116, 116, 116, 116, 129, 127, 122, 119, 116, 116, 116, 116, 129, 127, 122, 119, 116, 116, 116, 116, 129, 127, 122, 119, 116, 116, 116, 116, 129, 127, 122, 119, 116, 116, 116, 116, 129, 127, 122, 119, 116, 116, 116, 116, 129, 127, 122, 119, 116, 116, 116, 116, 129, 127, 122, 119, 116, 116, 116, 116);
        var expectedCr = ArrayUtil.toByteArrayShifted(128, 128, 128, 128, 132, 132, 132, 132, 128, 128, 128, 128, 132, 132, 132, 132, 128, 128, 128, 128, 132, 132, 132, 132, 128, 128, 128, 128, 132, 132, 132, 132, 128, 128, 128, 128, 132, 132, 132, 132, 128, 128, 128, 128, 132, 132, 132, 132, 128, 128, 128, 128, 132, 132, 132, 132, 128, 128, 128, 128, 132, 132, 132, 132);
        var topCb = ArrayUtil.toByteArrayShifted(129, 127, 122, 119, 116, 116, 116, 116);
        var topCr = ArrayUtil.toByteArrayShifted(128, 128, 128, 128, 132, 132, 132, 132);
        var actualCb = new Int8Array(64);
        var actualCr = new Int8Array(64);
        ChromaPredictionBuilder.predictVertical(ChromaPredictionBuilderTest.emptyResidual, 0, true, topCb, actualCb);
        ChromaPredictionBuilder.predictVertical(ChromaPredictionBuilderTest.emptyResidual, 0, true, topCr, actualCr);
        Assert.assertArrayEquals(expectedCb, actualCb);
        Assert.assertArrayEquals(expectedCr, actualCr);
    };
    prototype.testHorizontal = function() {
        var expectedCb = ArrayUtil.toByteArrayShifted(115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 118, 118, 118, 118, 118, 118, 118, 118, 116, 116, 116, 116, 116, 116, 116, 116, 111, 111, 111, 111, 111, 111, 111, 111, 108, 108, 108, 108, 108, 108, 108, 108);
        var expectedCr = ArrayUtil.toByteArrayShifted(137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 131, 131, 131, 131, 131, 131, 131, 131, 134, 134, 134, 134, 134, 134, 134, 134, 139, 139, 139, 139, 139, 139, 139, 139, 141, 141, 141, 141, 141, 141, 141, 141);
        var leftCb = ArrayUtil.toByteArrayShifted(115, 115, 115, 115, 118, 116, 111, 108);
        var leftCr = ArrayUtil.toByteArrayShifted(137, 137, 137, 137, 131, 134, 139, 141);
        var actualCb = new Int8Array(64);
        var actualCr = new Int8Array(64);
        ChromaPredictionBuilder.predictHorizontal(ChromaPredictionBuilderTest.emptyResidual, 0, true, leftCb, actualCb);
        ChromaPredictionBuilder.predictHorizontal(ChromaPredictionBuilderTest.emptyResidual, 0, true, leftCr, actualCr);
        Assert.assertArrayEquals(expectedCb, actualCb);
        Assert.assertArrayEquals(expectedCr, actualCr);
    };
    prototype.testDC = function() {
        var expectedCb = ArrayUtil.toByteArrayShifted(119, 119, 119, 119, 120, 120, 120, 120, 119, 119, 119, 119, 120, 120, 120, 120, 119, 119, 119, 119, 120, 120, 120, 120, 119, 119, 119, 119, 120, 120, 120, 120, 118, 118, 118, 118, 119, 119, 119, 119, 118, 118, 118, 118, 119, 119, 119, 119, 118, 118, 118, 118, 119, 119, 119, 119, 118, 118, 118, 118, 119, 119, 119, 119);
        var expectedCr = ArrayUtil.toByteArrayShifted(131, 131, 131, 131, 132, 132, 132, 132, 131, 131, 131, 131, 132, 132, 132, 132, 131, 131, 131, 131, 132, 132, 132, 132, 131, 131, 131, 131, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132);
        var leftCb = ArrayUtil.toByteArrayShifted(118, 118, 118, 118, 118, 118, 118, 118);
        var topCb = ArrayUtil.toByteArrayShifted(120, 120, 120, 120, 120, 120, 120, 120);
        var leftCr = ArrayUtil.toByteArrayShifted(131, 131, 131, 131, 132, 132, 132, 132);
        var topCr = ArrayUtil.toByteArrayShifted(131, 131, 131, 131, 132, 132, 132, 132);
        var actualCb = new Int8Array(64);
        var actualCr = new Int8Array(64);
        ChromaPredictionBuilder.predictDC(ChromaPredictionBuilderTest.emptyResidual, 0, true, true, leftCb, topCb, actualCb);
        ChromaPredictionBuilder.predictDC(ChromaPredictionBuilderTest.emptyResidual, 0, true, true, leftCr, topCr, actualCr);
        Assert.assertArrayEquals(expectedCb, actualCb);
        Assert.assertArrayEquals(expectedCr, actualCr);
    };
    prototype.testPlane = function() {
        var expectedCb = ArrayUtil.toByteArrayShifted(115, 116, 116, 117, 117, 118, 118, 119, 116, 117, 117, 118, 118, 119, 119, 120, 117, 117, 118, 118, 119, 119, 120, 120, 118, 118, 119, 119, 120, 120, 121, 121, 118, 119, 119, 120, 120, 121, 121, 122, 119, 119, 120, 120, 121, 121, 122, 122, 120, 120, 121, 121, 122, 122, 123, 123, 120, 121, 121, 122, 122, 123, 123, 124);
        var expectedCr = ArrayUtil.toByteArrayShifted(137, 136, 136, 135, 135, 134, 134, 133, 137, 136, 136, 135, 135, 134, 133, 133, 137, 136, 136, 135, 135, 134, 133, 133, 137, 136, 136, 135, 134, 134, 133, 133, 137, 136, 136, 135, 134, 134, 133, 133, 137, 136, 135, 135, 134, 134, 133, 132, 137, 136, 135, 135, 134, 134, 133, 132, 136, 136, 135, 135, 134, 133, 133, 132);
        var leftCb = ArrayUtil.toByteArrayShifted(116, 116, 116, 116, 119, 119, 119, 119);
        var tlCb = ArrayUtil.toByteArrayShifted(113);
        var topCb = ArrayUtil.toByteArrayShifted(118, 118, 118, 118, 119, 119, 119, 119);
        var leftCr = ArrayUtil.toByteArrayShifted(137, 137, 137, 137, 138, 138, 138, 138);
        var tlCr = ArrayUtil.toByteArrayShifted(141);
        var topCr = ArrayUtil.toByteArrayShifted(132, 132, 132, 132, 132, 132, 132, 132);
        var actualCb = new Int8Array(64);
        var actualCr = new Int8Array(64);
        ChromaPredictionBuilder.predictPlane(ChromaPredictionBuilderTest.emptyResidual, 0, true, true, leftCb, topCb, tlCb, actualCb);
        ChromaPredictionBuilder.predictPlane(ChromaPredictionBuilderTest.emptyResidual, 0, true, true, leftCr, topCr, tlCr, actualCr);
        Assert.assertArrayEquals(expectedCb, actualCb);
        Assert.assertArrayEquals(expectedCr, actualCr);
    };
}, {emptyResidual: "Array"}, {});
var MD5Test = function() {};
MD5Test = stjs.extend(MD5Test, null, [], function(constructor, prototype) {
    prototype.testmd5sum = function() {
        var b1 = new Int8Array([0, 0, 0, 85, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
        var b2 = new Int8Array([0, 0, 0, 42, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -1, -1, -1, 0, 0, 0, 0, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
        System.out.println(MD5.md5sum(ByteBuffer.wrap(b1)));
        System.out.println(MD5.md5sum(ByteBuffer.wrap(b2)));
    };
}, {}, {});
var EbmlSintTest = function() {};
EbmlSintTest = stjs.extend(EbmlSintTest, null, [], function(constructor, prototype) {
    prototype.testPacking = function() {
        Assert.assertEquals(1, EbmlSint.ebmlSignedLength(1));
        Assert.assertEquals(1, EbmlSint.ebmlSignedLength(2));
        Assert.assertEquals(2, EbmlSint.ebmlSignedLength(128));
        Assert.assertEquals(3, EbmlSint.ebmlSignedLength(32768));
        var size = EbmlSint.ebmlSignedLength(100500);
        Assert.assertEquals(3, size);
        System.out.println(EbmlUtil.toHexString(EbmlUtil.ebmlEncodeLen(100500, size)));
    };
    prototype.testNegativeVals = function() {
        Assert.assertEquals(1, EbmlSint.ebmlSignedLength(-3));
        Assert.assertEquals(1, EbmlSint.ebmlSignedLength(0));
        Assert.assertEquals(1, EbmlSint.ebmlSignedLength(10));
        Assert.assertEquals(1, EbmlSint.ebmlSignedLength(6));
        Assert.assertEquals(1, EbmlSint.ebmlSignedLength(27));
        Assert.assertEquals(1, EbmlSint.ebmlSignedLength(5));
    };
    prototype.testBytePacking = function() {
        Assert.assertArrayEquals(new Int8Array([95, 63]), EbmlSint.convertToBytes(-192));
        Assert.assertArrayEquals(new Int8Array([95, (159 << 24 >> 24)]), EbmlSint.convertToBytes(-96));
        Assert.assertArrayEquals(new Int8Array([96, 95]), EbmlSint.convertToBytes(96));
        Assert.assertArrayEquals(new Int8Array([(191 << 24 >> 24)]), EbmlSint.convertToBytes(0));
        var value = -192;
        var size = EbmlSint.ebmlSignedLength(value);
        value += EbmlSint.signedComplement[size];
        Assert.assertEquals(2, size);
        Assert.assertArrayEquals(new Int8Array([95, 63]), EbmlUtil.ebmlEncodeLen(value, size));
    };
    prototype.test = function() {
        var sie = new EbmlSint(MKVType.BlockDuration.id);
        sie.setLong(100500);
        var bb = sie.getData();
        Assert.assertArrayEquals(new Int8Array([(155 << 24 >> 24), (131 << 24 >> 24), 49, (136 << 24 >> 24), (147 << 24 >> 24)]), bb.array());
    };
    prototype.testEdgeCase = function() {
        var sie = new EbmlSint(MKVType.BlockDuration.id);
        sie.setLong(-1048575);
        var bb = sie.getData();
        Assert.assertArrayEquals(new Int8Array([(155 << 24 >> 24), (131 << 24 >> 24), 32, 0, 0]), bb.array());
    };
}, {}, {});
var FileTypeBoxTest = function() {};
FileTypeBoxTest = stjs.extend(FileTypeBoxTest, null, [], function(constructor, prototype) {
    prototype.testParse = function() {
        var buf = ByteBuffer.allocate(28 + 8);
        buf.putInt(28);
        buf.putArr("ftyp".getBytes());
        buf.putArr("mp42".getBytes());
        buf.putInt(1);
        buf.putArr("mp41".getBytes());
        buf.putArr("mp42".getBytes());
        buf.putArr("isom".getBytes());
        buf.putInt(8);
        buf.putArr("free".getBytes());
        buf.clear();
        var input = new ByteBufferSeekableByteChannel(buf);
        var rootAtoms = MP4Util.getRootAtoms(input);
        Assert.assertEquals(2, rootAtoms.size());
        var atom = rootAtoms.get(0);
        Assert.assertEquals("ftyp", atom.getHeader().getFourcc());
        var box = atom.parseBox(input);
        Assert.assertTrue(FileTypeBox.isInstance(box));
        var ftyp = box;
        Assert.assertEquals("mp42", ftyp.getMajorBrand());
        Assert.assertArrayEquals(["mp41", "mp42", "isom"], ftyp.getCompBrands().toArray(Array(0)));
    };
}, {}, {});
var MPEGDecoderTest = function() {};
MPEGDecoderTest = stjs.extend(MPEGDecoderTest, null, [], function(constructor, prototype) {
    prototype.testProbe = function() {
        var decoder = new MPEGDecoder();
        Assert.assertEquals(50, decoder.probe(ByteBuffer.wrap(MPEGTestConst.mpeg())));
        Assert.assertEquals(0, decoder.probe(ByteBuffer.wrap(MPEGTestConst.prores())));
    };
}, {}, {});
/**
 *  Dumps data in hexadecimal format.
 *  <p>
 *  Provides a single function to take an array of bytes and display it in
 *  hexadecimal form.
 *  <p>
 *  Origin of code: POI.
 * 
 *  @version $Id: HexDump.java 1302748 2012-03-20 01:35:32Z ggregory $
 */
var HexDump = /**
 *  Instances should NOT be constructed in standard programming.
 */
function() {};
HexDump = stjs.extend(HexDump, null, [], function(constructor, prototype) {
    /**
     *  Dump an array of bytes to an OutputStream. The output is formatted for
     *  human inspection, with a hexadecimal offset followed by the hexadecimal
     *  values of the next 16 bytes of data and the printable ASCII characters
     *  (if any) that those bytes represent printed per each line of output.
     *  <p>
     *  The offset argument specifies the start offset of the data array within a
     *  larger entity like a file or an incoming stream. For example, if the data
     *  array contains the third kibibyte of a file, then the offset argument
     *  should be set to 2048. The offset value printed at the beginning of each
     *  line indicates where in that larger entity the first byte on that line is
     *  located.
     *  <p>
     *  All bytes between the given index (inclusive) and the end of the data
     *  array are dumped.
     * 
     *  @param data
     *             the byte array to be dumped
     *  @param offset
     *             offset of the byte array within a larger entity
     *  @param stream
     *             the OutputStream to which the data is to be written
     *  @param index
     *             initial index into the byte array
     * 
     *  @throws IOException
     *              is thrown if anything goes wrong writing the data to stream
     *  @throws ArrayIndexOutOfBoundsException
     *              if the index is outside the data array's bounds
     *  @throws IllegalArgumentException
     *              if the output stream is null
     */
    constructor.dumpOut = function(data, offset, stream, index, len) {
        if (index < 0 || index >= data.length) {
             throw new ArrayIndexOutOfBoundsException("illegal index: " + index + " into array of length " + data.length);
        }
        if (stream == null) {
             throw new IllegalArgumentException("cannot write to nullstream");
        }
        var display_offset = offset + index;
        var buffer = new StringBuilder(74);
        for (var j = index; j < len; j += 16) {
            var chars_read = len - j;
            if (chars_read > 16) {
                chars_read = 16;
            }
            HexDump.dumpLong(buffer, display_offset).append(' ');
            for (var k = 0; k < 16; k++) {
                if (k < chars_read) {
                    HexDump.dumpByte(buffer, data[k + j]);
                } else {
                    buffer.append("  ");
                }
                buffer.append(' ');
            }
            for (var k = 0; k < chars_read; k++) {
                if (data[k + j] >= ' ' && data[k + j] < 127) {
                    buffer.append(((data[k + j]) & 65535));
                } else {
                    buffer.append('.');
                }
            }
            buffer.append(HexDump.EOL);
            stream.write(buffer.toString().getBytes());
            stream.flush();
            buffer.setLength(0);
            display_offset += chars_read;
        }
    };
    constructor.hexdump = function(data) {
        var sb = new StringBuilder();
        HexDump.dump(data, 0, sb);
        return sb.toString();
    };
    constructor.hexdump0 = function(data) {
        var sb = new StringBuilder();
        HexDump.dump(data, -data.position(), sb);
        return sb.toString();
    };
    constructor.dump = function(data, offset, buffer) {
        var index = data.position();
        var len = data.limit();
        var display_offset = offset + index;
        for (var j = index; j < len; j += 16) {
            var chars_read = len - j;
            if (chars_read > 16) {
                chars_read = 16;
            }
            HexDump.dumpLong(buffer, display_offset).append(' ');
            for (var k = 0; k < 16; k++) {
                if (k < chars_read) {
                    HexDump.dumpByte(buffer, data.getAt(k + j));
                } else {
                    buffer.append("  ");
                }
                buffer.append(' ');
            }
            for (var k = 0; k < chars_read; k++) {
                var b = data.getAt(k + j);
                if (b >= ' ' && b < 127) {
                    buffer.append(((b) & 65535));
                } else {
                    buffer.append('.');
                }
            }
            buffer.append(HexDump.EOL);
            display_offset += chars_read;
        }
        return buffer;
    };
    /**
     *  The line-separator (initializes to "line.separator" system property.
     */
    constructor.EOL = System.getProperty("line.separator");
    constructor._hexcodes = new Uint16Array(['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F']);
    constructor._shifts = new Int32Array([28, 24, 20, 16, 12, 8, 4, 0]);
    /**
     *  Dump a long value into a StringBuilder.
     * 
     *  @param _lbuffer
     *             the StringBuilder to dump the value in
     *  @param value
     *             the long value to be dumped
     *  @return StringBuilder containing the dumped value.
     */
    constructor.dumpLong = function(_lbuffer, value) {
        for (var j = 0; j < 8; j++) {
            _lbuffer.append(HexDump._hexcodes[(((value >> HexDump._shifts[j])) | 0) & 15]);
        }
        return _lbuffer;
    };
    /**
     *  Dump a byte value into a StringBuilder.
     * 
     *  @param _cbuffer
     *             the StringBuilder to dump the value in
     *  @param value
     *             the byte value to be dumped
     *  @return StringBuilder containing the dumped value.
     */
    constructor.dumpByte = function(_cbuffer, value) {
        for (var j = 0; j < 2; j++) {
            _cbuffer.append(HexDump._hexcodes[value >> HexDump._shifts[j + 6] & 15]);
        }
        return _cbuffer;
    };
}, {_hexcodes: "Uint16Array", _shifts: "Int32Array"}, {});
var MDecoderTest = function() {};
MDecoderTest = stjs.extend(MDecoderTest, null, [], function(constructor, prototype) {
    prototype.testMDecoder = function() {
        var data = new Int16Array([202, 63, 211, 139, 113, 90, 143, 127, 255, 234, 141, 57, 125, 96, 6, 69, 16, 151, 63, 131, 76, 182, 166, 94, 195, 197, 80, 204, 221, 26, 242, 115, 30, 98, 231, 60, 140, 1, 170, 206, 248, 242, 174, 43, 242, 221, 120, 56, 247, 160, 215, 11, 139, 239, 188, 212, 139, 188, 230, 122, 9, 59, 160, 10, 56, 78, 53, 178, 95, 122, 48, 50, 25, 43, 51, 54, 12, 133, 82, 78, 253, 131, 24, 150, 216, 83, 109, 220, 255, 212, 237, 182, 191, 83, 178, 233, 84]);
        var m = new Int32Array([3, 399, 68, 68, 68, 68, 68, 68, 69, 69, 69, 68, 69, 69, 69, 68, 69, 69, 69, 68, 68, 69, 69, 69, 68, 68, 69, 69, 69, 68, 69, 69, 69, 68, 69, 69, 69, 68, 69, 69, 69, 68, 69, 69, 69, 64, 73, 73, 73, 73, 77, 81, 60, 96, 134, 195, 248, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, -1, 96, 96, 93, 134, 195, 135, 196, 136, 197, 137, 198, 138, 199, 139, 200, 140, 201, 141, 202, 142, 203, 143, 144, 145, 206, 146, 207, 248, -1, 249, -1, 250, -1, 251, -1, 251, 252, -1, 247, 253, 253, -1, 247, 254, -1, 247, -1, 247, -1, 247, 255, 255, 255, -1, 247, 256, -1, 95, 134, 195, 135, 196, 136, 197, 137, 198, 138, 199, 139, 140, 141, 142, 203, 143, 144, 145, 206, 146, 147, 148, 209, 248, -1, 249, -1, 250, -1, 251, 252, -1, 247, -1, 247, 253, -1, 247, 254, -1, 247, 255, -1, 96, 134, 195, 135, 136, 197, 137, 198, 138, 139, 140, 141, 142, 143, 204, 248, -1, 249, -1, 250, -1, 251, -1, 96, 134, 195, 135, 196, 136, 197, 137, 198, 138, 199, 139, 200, 140, 141, 202, 142, 203, 143, 204, 144, 145, 206, 248, -1, 249, -1, 250, -1, 251, -1, 251, -1, 251, -1, 251, -1, 251, 252, 252, -1, 247, -1, 247, 253, -1, 96, 134, 195, 135, 136, 197, 137, 198, 138, 199, 139, 200, 140, 141, 142, 203, 143, 204, 144, 205, 145, 146, 207, 248, -1, 249, -1, 250, -1, 251, -1, 251, -1, 251, -1, 251, 252, -1, 247, 253, 253, -1, 247, 254, -1, 94, 134, 195, 135, 196, 136, 197, 137, 198, 138, 199, 139, 200, 140, 201, 141, 202, 142, 203, 143, 204, 248, -1, 249, -1, 250, -1, 251, -1, 251, -1, 251, 252, 252, 252, 252, -1, 247, -1, 247, 253, 253, 253, 253, 253, 253, -1, 247, 254, 254, 254, 254, 254, 254, -1, 247, 255, 255, 255, 255, 255, 255, 255, 255, -1, 96, 134, 195, 135, 196, 136, 197, 137, 198, 138, 139, 200, 140, 201, 141, 202, 142, 203, 143, 144, 145, 206, 146, 207, 248, -1, 249, -1, 250, -1, 251, 252, -1, 247, -1, 247, 253, -1, 247, 254, 254, 254, 254, -1, 247, 255, -1, 247, -1, 247, 256, 256, -1, 96, 134, 195, 135, 196, 136, 137, 138, 139, 140, 201, 248, 252, -1, 247, 253, 253, 253, 253, 253, 253, 253, -1, 247, 254, 254, -1, 96, 134, 195, 135, 196, 136, 137, 138, 139, 200, 140, 201, 248, -1, 249, 252, -1, 247, 253, 253, -1, 247, 254, 254, 254, 254, 254, 254, 254, 254, -1, 96, 134, 195, 135, 136, 197, 137, 198, 138, 199, 139, 200, 140, 201, 141, 202, 142, 203, 143, 144, 145, 206, 248, -1, 249, -1, 250, -1, 251, -1, 251, -1, 251, -1, 251, -1, 251, -1, 251, -1, 96, 134, 195, 135, 196, 136, 137, 138, 139, 140, 141, 202, 248, -1, 249, -1, 250, 252, -1, 96, 134, 195, 135, 136, 197, 137, 138, 199, 139, 200, 140, 141, 202, 142, 143, 144, 145, 146, 207, 147, 208, 248, -1, 249, -1, 250, -1, 251, -1, 251, -1, 251, -1, 251, -1, 96, 134, 135, 136, 197, 137, 138, 139, 200, 140, 201, 141, 202, 142, 143, 144, 145, 146, 207, 248, -1, 249, -1, 250, 252, -1, 247, 253, -1, 247, -1, 100, 149, 210, 150, 211, 151, 212, 258, 262, 262, -1, 257, 263, 263, 263, 263, 263, 263, -1, 257, 264, -1, 257, 265, 265, 265, 265, -1, 100, 149, 210, 150, 211, 151, 212, 258, 262, 262, 262, -1, 257, 263, 263, 263, -1, 257, 264, 264, 264, 264, 264, 264, 264, -1, 104, 152, 213, 267, -1, 104, 152, 213, 153, 214, 154, 215, 155, 216, 156, 157, 158, 159, 220, 160, 221, 161, 222, 267, -1, 268, 271, 271, 271, -1, 266, -1, 266, -1, 266, -1, 266, 272, 272, -1, 266, -1, 104, 152, 153, 154, 155, 216, 156, 217, 157, 218, 158, 219, 267, -1, 268, -1, 269, -1, 270, 271, -1, 104, 152, 213, 153, 154, 155, 216, 156, 157, 158, 219, 159, 220, 160, 161, 162, 223, 163, 224, 164, 225, 267, -1, 268, -1, 269, -1, 270, -1, 270, -1, 270, -1, 270, -1, 104, 103, 152, 213, 153, 214, 154, 215, 155, 216, 156, 157, 158, 159, 220, 160, 221, 161, 222, 267, -1, 268, -1, 269, -1, 270, -1, 270, -1, 270, -1, 270, -1, 102, 152, 153, 154, 155, 216, 156, 217, 157, 218, 158, 219, 159, 160, 161, 222, 267, -1, 268, -1, 269, -1, 270, -1, 270, 271, -1, 104, 152, 213, 153, 154, 155, 216, 156, 157, 158, 219, 159, 220, 160, 161, 162, 223, 163, 224, 164, 225, 267, -1, 268, -1, 269, -1, 270, -1, 270, -1, 270, -1, 270, -1]);
        var out = new Int32Array([0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0]);
        var cm = Array.apply(null, Array(2)).map(function() {
            return new Int32Array(1024);
        });
        new CABAC(1).initModels(cm, SliceType.I, 0, 34);
        var decoder = new MDecoder(ByteBuffer.wrap(this.shortArray2ByteArray(data)), cm);
        for (var i = 0; i < m.length; i++) {
            Assert.assertEquals("Bin " + i, out[i], m[i] == -1 ? decoder.decodeBinBypass() : decoder.decodeBin(m[i]));
        }
    };
    prototype.shortArray2ByteArray = function(src) {
        var result = new Int8Array(src.length);
        for (var i = 0; i < src.length; i++) {
            result[i] = (src[i] << 24 >> 24);
        }
        return result;
    };
}, {}, {});
var SegmentTypeBoxTest = function() {};
SegmentTypeBoxTest = stjs.extend(SegmentTypeBoxTest, null, [], function(constructor, prototype) {
    prototype.testParse = function() {
        var buf = ByteBuffer.allocate(24 + 8);
        buf.putInt(24);
        buf.putArr("stypmsdh".getBytes());
        buf.putInt(0);
        buf.putArr("msdhmsix".getBytes());
        buf.putInt(8);
        buf.putArr("free".getBytes());
        buf.clear();
        var input = new ByteBufferSeekableByteChannel(buf);
        var rootAtoms = MP4Util.getRootAtoms(input);
        Assert.assertEquals(2, rootAtoms.size());
        var atom = rootAtoms.get(0);
        Assert.assertEquals("styp", atom.getHeader().getFourcc());
        var box = atom.parseBox(input);
        Assert.assertTrue(SegmentTypeBox.isInstance(box));
        var ftyp = box;
        Assert.assertEquals("msdh", ftyp.getMajorBrand());
        Assert.assertArrayEquals(["msdh", "msix"], ftyp.getCompBrands().toArray(Array(0)));
    };
}, {}, {});
var SimpleIDCT10BitTest = function() {};
SimpleIDCT10BitTest = stjs.extend(SimpleIDCT10BitTest, null, [], function(constructor, prototype) {
    prototype.testOne = function() {
        var input = new Int32Array([1832, -256, -226, -164, -96, -52, -24, -2, -266, 50, 44, 34, 18, 10, 6, 2, -240, 52, 46, 26, 22, 12, 2, -6, -228, 38, 38, 32, 18, 8, -2, 5, -192, 38, 28, 32, 10, 2, 7, 5, -144, 28, 22, 16, 10, 7, 5, 0, -100, 20, 24, 6, 2, 5, 6, -4, -44, 2, 16, -2, 7, 6, -4, 0]);
        var output = new Int32Array([64, 64, 63, 63, 64, 64, 65, 64, 112, 227, 276, 284, 284, 275, 276, 275, 111, 230, 287, 288, 275, 278, 283, 289, 108, 224, 283, 277, 288, 285, 272, 268, 108, 224, 276, 276, 288, 276, 284, 279, 109, 227, 279, 280, 280, 277, 279, 277, 112, 228, 280, 292, 285, 275, 284, 285, 115, 233, 284, 286, 280, 280, 276, 280]);
        SimpleIDCT10Bit.idct10(input, 0);
        Assert.assertArrayEquals(output, input);
    };
    prototype.testTwo = function() {
        var input = new Int32Array([1196, -75, 10, 0, -5, -10, -10, 0, -140, -65, -10, -5, 5, 5, 0, 5, -105, -75, 20, -10, 20, -10, 10, 5, -50, 20, 35, 15, 5, -5, -5, 0, -10, 20, 35, -15, 0, 5, 6, 0, -15, 15, -15, 5, 0, 6, -13, 0, 15, 20, 10, -5, 0, -13, 0, -9, -15, 0, -15, -10, 6, 0, 0, -9]);
        var output = new Int32Array([78, 76, 71, 80, 98, 103, 127, 155, 81, 82, 105, 114, 144, 152, 164, 169, 110, 140, 148, 169, 169, 168, 160, 156, 163, 170, 169, 165, 162, 163, 178, 148, 175, 178, 166, 160, 150, 159, 162, 160, 184, 191, 156, 151, 166, 169, 166, 162, 142, 148, 143, 160, 170, 163, 167, 155, 154, 159, 162, 151, 157, 167, 171, 204]);
        SimpleIDCT10Bit.idct10(input, 0);
        Assert.assertArrayEquals(output, input);
    };
    prototype.testThree = function() {
        var input = new Int32Array([2180, 8, 8, -4, 4, 4, -4, 4, 0, 4, -4, 8, 4, 0, 16, 4, 0, 0, -4, 4, 20, 4, -12, 4, 4, 8, -8, -12, -4, -4, 0, 0, 0, 0, 4, 8, 0, 0, 0, 0, 24, 4, -8, 24, -4, -5, -15, -6, 4, 8, -8, -16, 15, 10, 0, 0, -8, -16, -8, 12, 5, -6, 0, 7]);
        var output = new Int32Array([284, 272, 272, 282, 287, 270, 270, 268, 275, 264, 277, 263, 262, 265, 266, 276, 276, 262, 271, 275, 277, 271, 271, 273, 285, 288, 274, 268, 267, 285, 279, 268, 263, 266, 276, 257, 264, 271, 269, 275, 271, 282, 291, 288, 261, 256, 268, 276, 272, 285, 260, 271, 285, 278, 285, 268, 277, 267, 263, 277, 268, 254, 276, 278]);
        SimpleIDCT10Bit.idct10(input, 0);
        Assert.assertArrayEquals(output, input);
    };
}, {}, {});
var TestProresEncoder = function() {};
TestProresEncoder = stjs.extend(TestProresEncoder, null, [], function(constructor, prototype) {
    prototype.testSlice1 = function() {
        var slice = new Int32Array([4096, 0, 0, 0, 8, 0, 0, 0, 16, 16, 8, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 8, 16, 8, 8, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 4048, -48, -24, -8, 0, 8, 0, -8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -10, 0, 8, 0, 0, -8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
        var qMat = new Int32Array(64);
        Arrays.fill(qMat, 4);
        this.onePlaneTest(ByteBuffer.allocate(1024), slice, 2, qMat);
    };
    prototype.testSlice2 = function() {
        var slice = new Int32Array([2088, 1248, -208, -328, 144, 80, -88, 16, 232, 184, -48, -56, 48, 48, -8, -8, -64, -48, 16, 32, 16, -8, -16, -16, 16, 32, 16, 8, 0, -8, -8, 0, 56, 56, 0, -16, -24, -16, -10, 0, -8, -8, -24, -32, -16, 0, 10, 12, 0, -8, -8, 8, 20, 10, 0, 0, 24, 16, 8, 24, 30, 12, -14, -28, 512, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1640, 904, -152, -224, 136, 72, -72, 0, 96, 80, -8, -16, 8, 8, 0, 0, -56, -48, 8, 24, 0, -8, 0, 0, 24, 16, 8, 0, 0, -16, -16, 0, 0, 8, 0, 0, 0, 0, -10, -10, -8, -16, -8, -16, -16, -10, -20, 0, 0, 0, 0, 8, 0, -10, -12, -14, 0, 0, -8, 0, -10, -12, -14, -14, 504, -8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
        var qMat = new Int32Array(64);
        Arrays.fill(qMat, 4);
        this.onePlaneTest(ByteBuffer.allocate(1024), slice, 4, qMat);
    };
    prototype.onePlaneTest = function(out, slice, blocksPerSlice, qMat) {
        var writer = new BitWriter(out);
        var encoder = new ProresEncoder(ProresEncoder.Profile.HQ, false);
        encoder.constructor.writeDCCoeffs(writer, qMat, slice, blocksPerSlice);
        encoder.constructor.writeACCoeffs(writer, qMat, slice, blocksPerSlice, ProresConsts.progressive_scan, 64);
        writer.flush();
        System.out.println("result");
        out.flip();
        var decoder = new ProresDecoder();
        var bits = BitReader.createBitReader(out);
        var result = new Int32Array(blocksPerSlice << 6);
        decoder.constructor.readDCCoeffs(bits, qMat, result, blocksPerSlice, 64);
        decoder.constructor.readACCoeffs(bits, qMat, result, blocksPerSlice, ProresConsts.progressive_scan, 64, 6);
        Assert.assertArrayEquals(slice, result);
    };
    prototype.testWholeThing = function() {
        var Y = ArrayUtil.randomByteArray(4096, (1 << 24 >> 24), (254 << 24 >> 24));
        var U = ArrayUtil.randomByteArray(2048, (1 << 24 >> 24), (254 << 24 >> 24));
        var V = ArrayUtil.randomByteArray(2048, (1 << 24 >> 24), (254 << 24 >> 24));
        var picture = Picture8Bit.createPicture8Bit(64, 64, [Y, U, V], ColorSpace.YUV422);
        var buf = ByteBuffer.allocate(64 * 64 * 6);
        new ProresEncoder(ProresEncoder.Profile.HQ, false).encodeFrame8Bit(picture, buf);
        var decoder = new ProresDecoder();
        var result = decoder.decodeFrame8Bit(buf, [new Int8Array(4096), new Int8Array(2048), new Int8Array(2048)]);
        System.out.println("Y");
        this.assertByteArrayApproximatelyEquals(Y, result.getPlaneData(0), 20);
        System.out.println("U");
        this.assertByteArrayApproximatelyEquals(U, result.getPlaneData(1), 20);
        System.out.println("V");
        this.assertByteArrayApproximatelyEquals(V, result.getPlaneData(2), 20);
    };
    prototype.testIdct = function() {
        var rand = ArrayUtil.randomIntArray(64, 4, 255);
        var rand8Bit = ArrayUtil.toByteArrayShifted(rand);
        var out = new Int32Array(64);
        SimpleIDCT10Bit.fdct10(rand8Bit, 0, out);
        for (var i = 0; i < 64; i++) {
            out[i] >>= 2;
            rand[i] <<= 2;
        }
        SimpleIDCT10Bit.idct10(out, 0);
        this.assertIntArrayApproximatelyEquals(rand, out, 50);
    };
    prototype.assertByteArrayApproximatelyEquals = function(rand, newRand, threash) {
        var maxDiff = 0;
        for (var i = 0; i < rand.length; i++) {
            var diff = Math.abs(rand[i] - newRand[i]);
            if (diff > maxDiff) 
                maxDiff = diff;
        }
        Assert.assertTrue("Maxdiff: " + maxDiff, maxDiff < threash);
    };
    prototype.assertIntArrayApproximatelyEquals = function(rand, newRand, threash) {
        var maxDiff = 0;
        for (var i = 0; i < rand.length; i++) {
            var diff = Math.abs(rand[i] - newRand[i]);
            if (diff > maxDiff) 
                maxDiff = diff;
        }
        Assert.assertTrue("Maxdiff: " + maxDiff, maxDiff < threash);
    };
}, {}, {});
var TestBitReader = function() {};
TestBitReader = stjs.extend(TestBitReader, null, [], function(constructor, prototype) {
    prototype.testEOF = function() {
        var src = new Int8Array([this.b("10011000")]);
        var eof = false;
        try {
            var bs = BitStream.createBitStream(src);
            for (var i = 0; i < 10; i++) {
                System.out.println(Integer.toBinaryString(bs.readBits(4)) + " " + bs.getBitsLeft());
            }
        }catch (e) {
            eof = true;
        }
        Assert.assertTrue(eof);
    };
    prototype.testEOF2 = function() {
        var src = new Int8Array([this.b("10011000")]);
        var eof = false;
        try {
            var bs = new NIOBitStream(BitReader.createBitReader(ByteBuffer.wrap(src)));
            for (var i = 0; i < 10; i++) {
                System.out.println(Integer.toBinaryString(bs.readBits(4)) + " " + bs.getBitsLeft());
            }
        }catch (e) {
            eof = true;
        }
        Assert.assertTrue(eof);
    };
    prototype.testReader1 = function() {
        var _in = this.reader(new Int8Array([this.b("10011000"), this.b("00011100"), this.b("11001101"), this.b("01010101"), this.b("11101001"), this.b("00101110"), this.b("00000111"), this.b("00011101"), this.b("10100100"), this.b("01101110"), this.b("10000101"), this.b("00001100"), this.b("01010111"), this.b("01000000")]));
        Assert.assertFalse(_in.lastByte());
        Assert.assertEquals(this.i("1"), _in.read1Bit());
        Assert.assertFalse(_in.lastByte());
        Assert.assertEquals(this.i("00110000001110011001101"), _in.checkNBit(23));
        Assert.assertEquals(this.i("001"), _in.readNBit(3));
        Assert.assertTrue(_in.moreData());
        Assert.assertFalse(_in.lastByte());
        Assert.assertEquals(this.i("1000"), _in.readNBit(4));
        Assert.assertTrue(_in.isByteAligned());
        Assert.assertEquals(0, _in.curBit());
        Assert.assertEquals(7, _in.skip(7));
        Assert.assertEquals(7, _in.curBit());
        Assert.assertFalse(_in.lastByte());
        Assert.assertEquals(this.i("011"), _in.readNBit(3));
        Assert.assertEquals(this.i("0011010101010"), _in.checkNBit(13));
        Assert.assertEquals(this.i("0011"), _in.readNBit(4));
        Assert.assertEquals(35, _in.skip(35));
        Assert.assertTrue(_in.moreData());
        Assert.assertFalse(_in.lastByte());
        Assert.assertEquals(this.i("0011"), _in.checkNBit(4));
        Assert.assertEquals(this.i("001110110"), _in.readNBit(9));
        Assert.assertFalse(_in.lastByte());
        Assert.assertEquals(this.i("1"), _in.readNBit(1));
        Assert.assertFalse(_in.lastByte());
        Assert.assertEquals(this.i("00100"), _in.readNBit(5));
        Assert.assertTrue(_in.moreData());
        Assert.assertFalse(_in.lastByte());
        Assert.assertEquals(this.i("011"), _in.readNBit(3));
        Assert.assertFalse(_in.lastByte());
        Assert.assertEquals(this.i("01110"), _in.checkNBit(5));
        Assert.assertEquals(this.i("01110100"), _in.readNBit(8));
        Assert.assertFalse(_in.lastByte());
        Assert.assertEquals(this.i("001010000110001"), _in.readNBit(15));
        Assert.assertTrue(_in.moreData());
        Assert.assertFalse(_in.lastByte());
        Assert.assertEquals(this.i("010111010"), _in.readNBit(9));
        Assert.assertTrue(_in.lastByte());
        Assert.assertFalse(_in.moreData());
        Assert.assertEquals(this.i("0"), _in.read1Bit());
        Assert.assertEquals(this.i("0"), _in.read1Bit());
        Assert.assertEquals(this.i("0"), _in.readNBit(1));
        Assert.assertEquals(this.i("00"), _in.readNBit(2));
    };
    prototype.reader = function(src) {
        return BitReader.createBitReader(ByteBuffer.wrap(src));
    };
    prototype.testReader2 = function() {
        var _in = this.reader(new Int8Array([this.b("10100111"), this.b("10101110"), this.b("10010111"), this.b("01000010"), this.b("10100101"), this.b("11000001"), this.b("11100001"), this.b("01010101"), this.b("00111100"), this.b("10100011"), this.b("01010000"), this.b("01010100"), this.b("00101010"), this.b("01010100"), this.b("10101001"), this.b("00001010"), this.b("10000011"), this.b("11000000"), this.b("00010101"), this.b("11010100"), this.b("10111110"), this.b("10100100"), this.b("10001010"), this.b("01010001"), this.b("00100000"), this.b("00111110"), this.b("00000101"), this.b("00100100")]));
        Assert.assertTrue(_in.moreData());
        Assert.assertFalse(_in.lastByte());
        Assert.assertEquals(this.i("101001111010"), _in.readNBit(12));
        Assert.assertTrue(_in.moreData());
        Assert.assertEquals(this.i("1"), _in.read1Bit());
        Assert.assertEquals(this.i("110100101110100001"), _in.readNBit(18));
        Assert.assertEquals(this.i("0"), _in.read1Bit());
        Assert.assertEquals(this.i("1"), _in.read1Bit());
        Assert.assertEquals(this.i("0"), _in.read1Bit());
        Assert.assertEquals(6, _in.skip(6));
        Assert.assertEquals(this.i("110"), _in.readNBit(3));
        Assert.assertEquals(this.i("0000111"), _in.readNBit(7));
        Assert.assertTrue(_in.moreData());
        Assert.assertEquals(this.i("10000"), _in.checkNBit(5));
        Assert.assertEquals(this.i("10000101010"), _in.readNBit(11));
        Assert.assertEquals(this.i("10100"), _in.readNBit(5));
        Assert.assertEquals(15, _in.skip(15));
        Assert.assertEquals(this.i("1"), _in.read1Bit());
        Assert.assertEquals(this.i("0"), _in.read1Bit());
        Assert.assertEquals(this.i("1000001010"), _in.readNBit(10));
        Assert.assertEquals(47, _in.skip(47));
        Assert.assertEquals(this.i("00000001010111010100101111101010"), _in.readNBit(32));
        Assert.assertTrue(_in.moreData());
        Assert.assertEquals(this.i("01001000101"), _in.readNBit(11));
        Assert.assertTrue(_in.moreData());
        Assert.assertEquals(20, _in.skip(20));
        Assert.assertTrue(_in.moreData());
        Assert.assertEquals(this.i("11110000001010010010"), _in.readNBit(20));
        Assert.assertFalse(_in.moreData());
        Assert.assertTrue(_in.lastByte());
    };
    prototype.testReader3 = function() {
        var _in = this.reader(new Int8Array([this.b("10100111"), this.b("10101110"), this.b("10010111"), this.b("01000010"), this.b("10100101"), this.b("11000001"), this.b("11100001"), this.b("01010101"), this.b("00111100"), this.b("10100011"), this.b("01010000")]));
        Assert.assertEquals(this.i("1"), _in.read1Bit());
        Assert.assertEquals(this.i("0"), _in.read1Bit());
        Assert.assertEquals(this.i("1"), _in.read1Bit());
        Assert.assertEquals(this.i("0"), _in.read1Bit());
        Assert.assertEquals(this.i("0"), _in.read1Bit());
        Assert.assertEquals(this.i("1"), _in.read1Bit());
        Assert.assertEquals(this.i("1"), _in.read1Bit());
        Assert.assertEquals(this.i("1"), _in.read1Bit());
        Assert.assertEquals(this.i("1"), _in.read1Bit());
        Assert.assertEquals(this.i("0"), _in.read1Bit());
        Assert.assertEquals(this.i("1"), _in.read1Bit());
        Assert.assertEquals(this.i("0"), _in.read1Bit());
        Assert.assertEquals(this.i("1"), _in.read1Bit());
        Assert.assertEquals(this.i("1"), _in.read1Bit());
        Assert.assertEquals(this.i("1"), _in.read1Bit());
        Assert.assertEquals(this.i("0"), _in.read1Bit());
        Assert.assertEquals(this.i("1"), _in.read1Bit());
        Assert.assertEquals(this.i("0"), _in.read1Bit());
        Assert.assertEquals(this.i("0"), _in.read1Bit());
        Assert.assertEquals(this.i("1"), _in.read1Bit());
        Assert.assertEquals(this.i("0"), _in.read1Bit());
        Assert.assertEquals(this.i("1"), _in.read1Bit());
        Assert.assertEquals(this.i("1"), _in.read1Bit());
        Assert.assertEquals(this.i("1"), _in.read1Bit());
        Assert.assertEquals(this.i("0"), _in.read1Bit());
        Assert.assertEquals(this.i("1"), _in.read1Bit());
        Assert.assertEquals(this.i("0"), _in.read1Bit());
        Assert.assertEquals(this.i("0"), _in.read1Bit());
        Assert.assertEquals(this.i("0"), _in.read1Bit());
        Assert.assertEquals(this.i("0"), _in.read1Bit());
        Assert.assertEquals(this.i("1"), _in.read1Bit());
        Assert.assertEquals(this.i("0"), _in.read1Bit());
        Assert.assertEquals(this.i("1"), _in.read1Bit());
        Assert.assertEquals(this.i("0"), _in.read1Bit());
        Assert.assertEquals(this.i("1"), _in.read1Bit());
        Assert.assertEquals(this.i("0"), _in.read1Bit());
        Assert.assertEquals(this.i("0"), _in.read1Bit());
        Assert.assertEquals(this.i("1"), _in.read1Bit());
        Assert.assertEquals(this.i("0"), _in.read1Bit());
        Assert.assertEquals(this.i("1"), _in.read1Bit());
        Assert.assertEquals(this.i("1"), _in.read1Bit());
        Assert.assertEquals(this.i("1"), _in.read1Bit());
        Assert.assertEquals(this.i("0"), _in.read1Bit());
        Assert.assertEquals(this.i("0"), _in.read1Bit());
        Assert.assertEquals(this.i("0"), _in.read1Bit());
        Assert.assertEquals(this.i("0"), _in.read1Bit());
        Assert.assertEquals(this.i("0"), _in.read1Bit());
        Assert.assertEquals(this.i("1"), _in.read1Bit());
        Assert.assertEquals(this.i("1"), _in.read1Bit());
        Assert.assertEquals(this.i("1"), _in.read1Bit());
        Assert.assertEquals(this.i("1"), _in.read1Bit());
        Assert.assertEquals(this.i("0"), _in.read1Bit());
        Assert.assertEquals(this.i("0"), _in.read1Bit());
        Assert.assertEquals(this.i("0"), _in.read1Bit());
        Assert.assertEquals(this.i("0"), _in.read1Bit());
        Assert.assertEquals(this.i("1"), _in.read1Bit());
        Assert.assertEquals(this.i("0"), _in.read1Bit());
        Assert.assertEquals(this.i("1"), _in.read1Bit());
        Assert.assertEquals(this.i("0"), _in.read1Bit());
        Assert.assertEquals(this.i("1"), _in.read1Bit());
        Assert.assertEquals(this.i("0"), _in.read1Bit());
        Assert.assertEquals(this.i("1"), _in.read1Bit());
        Assert.assertEquals(this.i("0"), _in.read1Bit());
        Assert.assertEquals(this.i("1"), _in.read1Bit());
    };
    prototype.testReader4 = function() {
        var _in = this.reader(new Int8Array([this.b("00000000"), this.b("00000000"), this.b("00000000"), this.b("00000000"), this.b("00000000"), this.b("00000000"), this.b("00000000"), this.b("00000000"), this.b("10001100"), this.b("00011100"), this.b("00110100"), this.b("00010000"), this.b("11111111")]));
        _in.skip(63);
        Assert.assertEquals(this.i("010"), _in.readNBit(3));
        Assert.assertEquals(this.i("001"), _in.readNBit(3));
        Assert.assertEquals(this.i("100"), _in.readNBit(3));
        Assert.assertEquals(this.i("000"), _in.readNBit(3));
        Assert.assertEquals(this.i("111"), _in.readNBit(3));
        Assert.assertEquals(this.i("000"), _in.readNBit(3));
        Assert.assertEquals(this.i("011"), _in.readNBit(3));
        Assert.assertEquals(this.i("010"), _in.readNBit(3));
        Assert.assertEquals(this.i("000"), _in.readNBit(3));
        Assert.assertEquals(this.i("010"), _in.readNBit(3));
        Assert.assertEquals(this.i("000"), _in.readNBit(3));
    };
    prototype.testReader5 = function() {
        var _in = BitReader.createBitReader(NIOUtils.fetchFromFile(new File("src/test/resources/h264/bitstream/data.dat")));
        var in1 = new DummyBitstreamReader(new BufferedInputStream(new FileInputStream("src/test/resources/h264/bitstream/data.dat")));
        var readFileToString = Platform.stringFromBytes(NIOUtils.toArray(NIOUtils.fetchFromFile(new File("src/test/resources/h264/bitstream/reads.csv"))));
        var split = StringUtils.splitS(readFileToString, ",");
        for (var string in split) {
            var trim = string.trim();
            if (StringUtils.isEmpty(trim)) 
                continue;
            if ("r1".equals(trim)) 
                Assert.assertEquals(in1.read1Bit(), _in.read1Bit());
             else if ("a".equals(trim)) 
                Assert.assertEquals(in1.align(), _in.align());
             else if ("md".equals(trim)) 
                Assert.assertEquals(in1.moreData(), _in.moreData());
             else if ("lb".equals(trim)) 
                Assert.assertEquals(in1.lastByte(), _in.lastByte());
             else if ("cub".equals(trim)) 
                Assert.assertEquals(in1.curBit(), _in.curBit());
             else if (trim.startsWith("s")) {
                var i = Integer.parseInt(trim.substring(1));
                in1.skip(i);
                _in.skip(i);
            } else if (trim.startsWith("c")) {
                var i = Integer.parseInt(trim.substring(1));
                Assert.assertEquals(in1.checkNBit(i), _in.checkNBit(i));
            } else {
                var i = Integer.parseInt(trim);
                Assert.assertEquals(in1.readNBit(i), _in.readNBit(i));
            }
        }
    };
    prototype.testReader6 = function() {
        var _in = this.reader(new Int8Array([this.b("01010100"), this.b("00011001"), this.b("10000100"), this.b("10001111"), this.b("11101011"), this.b("10010100"), this.b("01101010"), this.b("01011111"), this.b("01110101")]));
        Assert.assertEquals(0, _in.read1Bit());
        Assert.assertEquals(1, _in.read1Bit());
        Assert.assertEquals(20, _in.readNBit(6));
        Assert.assertEquals(0, _in.read1Bit());
        Assert.assertEquals(0, _in.read1Bit());
        Assert.assertEquals(0, _in.read1Bit());
        Assert.assertEquals(1, _in.read1Bit());
        Assert.assertEquals(4, _in.readNBit(3));
        Assert.assertEquals(1, _in.read1Bit());
        Assert.assertEquals(1, _in.read1Bit());
        Assert.assertEquals(0, _in.read1Bit());
        Assert.assertEquals(0, _in.read1Bit());
        Assert.assertEquals(0, _in.read1Bit());
        Assert.assertEquals(0, _in.read1Bit());
        Assert.assertEquals(1, _in.read1Bit());
        Assert.assertEquals(0, _in.read1Bit());
        Assert.assertEquals(0, _in.read1Bit());
        Assert.assertEquals(1, _in.read1Bit());
        Assert.assertEquals(0, _in.read1Bit());
        Assert.assertEquals(0, _in.read1Bit());
        Assert.assertEquals(0, _in.read1Bit());
        Assert.assertEquals(1, _in.read1Bit());
        Assert.assertEquals(1, _in.read1Bit());
        Assert.assertEquals(1, _in.read1Bit());
        Assert.assertEquals(1, _in.read1Bit());
        Assert.assertEquals(1, _in.read1Bit());
        Assert.assertEquals(1, _in.read1Bit());
        Assert.assertEquals(1, _in.read1Bit());
        Assert.assertEquals(0, _in.read1Bit());
        Assert.assertEquals(1, _in.read1Bit());
        Assert.assertEquals(0, _in.read1Bit());
        Assert.assertEquals(1, _in.read1Bit());
        Assert.assertEquals(1, _in.read1Bit());
        Assert.assertEquals(1, _in.read1Bit());
        Assert.assertEquals(0, _in.read1Bit());
        Assert.assertEquals(0, _in.read1Bit());
        Assert.assertEquals(1, _in.read1Bit());
        Assert.assertEquals(0, _in.read1Bit());
        Assert.assertEquals(1, _in.read1Bit());
        Assert.assertEquals(0, _in.read1Bit());
        Assert.assertEquals(0, _in.read1Bit());
        Assert.assertEquals(0, _in.read1Bit());
        Assert.assertEquals(1, _in.read1Bit());
        Assert.assertEquals(1, _in.read1Bit());
        Assert.assertEquals(0, _in.read1Bit());
        Assert.assertEquals(1, _in.read1Bit());
        Assert.assertEquals(0, _in.read1Bit());
        Assert.assertEquals(1, _in.read1Bit());
        Assert.assertEquals(0, _in.read1Bit());
        Assert.assertEquals(0, _in.read1Bit());
        Assert.assertEquals(1, _in.read1Bit());
        Assert.assertEquals(0, _in.read1Bit());
        Assert.assertEquals(1, _in.read1Bit());
        Assert.assertEquals(1, _in.read1Bit());
        Assert.assertEquals(1, _in.read1Bit());
        Assert.assertEquals(1, _in.read1Bit());
        Assert.assertEquals(1, _in.read1Bit());
        Assert.assertEquals(0, _in.read1Bit());
        Assert.assertEquals(1, _in.read1Bit());
        Assert.assertEquals(1, _in.read1Bit());
        Assert.assertEquals(1, _in.read1Bit());
        Assert.assertEquals(0, _in.read1Bit());
        Assert.assertEquals(1, _in.read1Bit());
        Assert.assertEquals(0, _in.read1Bit());
        Assert.assertEquals(1, _in.read1Bit());
    };
    prototype.testRandom1Bit = function() {
        var data = this.randomData(10000);
        var in1 = this.reader(data);
        var in2 = new DummyBitstreamReader(new ByteArrayInputStream(data));
        for (var i = 0; i < 80000; i++) {
            var exp = in2.read1Bit();
            Assert.assertEquals(exp, in1.read1Bit());
        }
    };
    prototype.testRandomNBit = function() {
        for (var bits = 1; bits <= 32; bits++) {
            var data = this.randomData(bits * 10000);
            var in1 = this.reader(data);
            var in2 = new DummyBitstreamReader(new ByteArrayInputStream(data));
            for (var i = 0; i < 80000; i++) {
                var exp = in2.readNBit(bits);
                var exp1 = in1.readNBit(bits);
                Assert.assertEquals(exp, exp1);
            }
        }
    };
    prototype.testCheckSkip = function() {
        var data = this.randomData(2048);
        var reader = this.reader(data);
        reader.skip(1000 << 3);
        reader.skip(31);
        for (var i = 0; i < 40; i++) {
            reader.checkNBit(5);
            reader.skip(8);
        }
    };
    prototype.randomData = function(n) {
        var data = new Int8Array(n);
        for (var i = 0; i < n; i++) {
            var ni = 0;
            ni |= (Math.random() < 0.5 ? 0 : 1);
            for (var j = 0; j < 7; j++) {
                ni <<= 1;
                ni |= (Math.random() < 0.5 ? 0 : 1);
            }
            data[i] = (ni << 24 >> 24);
        }
        return data;
    };
    prototype.b = function(str) {
        return (Short.parseShort(str, 2) << 24 >> 24);
    };
    prototype.i = function(str) {
        return ((Long.parseLong(str, 2)) | 0);
    };
}, {}, {});
var ColorExtensionTest = function() {};
ColorExtensionTest = stjs.extend(ColorExtensionTest, null, [], function(constructor, prototype) {
    prototype.testColorIsom = function() {
        var color = ColorExtension.createColr();
        color.setColorRange((2 << 24 >> 24));
        var buf = ByteBuffer.allocate(64);
        color.write(buf);
        buf.flip();
        Assert.assertEquals(19, buf.remaining());
    };
    prototype.testColorMov = function() {
        var color = ColorExtension.createColr();
        var buf = ByteBuffer.allocate(64);
        color.write(buf);
        buf.flip();
        Assert.assertEquals(18, buf.remaining());
    };
}, {}, {});
var VP8DCTTest = function() {};
VP8DCTTest = stjs.extend(VP8DCTTest, null, [], function(constructor, prototype) {
    prototype.testDCT = function() {
        var input = new Int32Array([87, -38, 1, 0, 87, -38, 1, 0, 87, -38, 1, 0, 87, 116, 155, 154]);
        var output = new Int32Array([331, 85, 171, 155, -301, 132, 101, 55, 231, -101, -77, -42, -125, 55, 42, 23]);
        VPXDCT.fdct4x4(input);
        Assert.assertArrayEquals(output, input);
    };
    prototype.testWalsh = function() {
        var input = new Int32Array([-696, 625, 104, 856, 856, 163, 625, 656, -896, 856, -128, 856, 856, 336, 856, -896]);
        var output = new Int32Array([2515, -414, -922, -937, 674, -878, 1077, -473, -473, 615, -878, 1136, -937, -1384, -414, -3871]);
        VPXDCT.walsh4x4(input);
        Assert.assertArrayEquals(output, input);
    };
    prototype.testIDCT = function() {
        var input = new Int32Array([331, 85, 171, 155, -301, 132, 101, 55, 231, -101, -77, -42, -125, 55, 42, 23]);
        var output = new Int32Array([87, -38, 1, 0, 87, -38, 1, 0, 87, -38, 1, 0, 87, 116, 155, 154]);
        VPXDCT.idct4x4(input);
        Assert.assertArrayEquals(output, input);
    };
    prototype.testIWalsh = function() {
        var input = new Int32Array([2515, -414, -922, -937, 674, -878, 1077, -473, -473, 615, -878, 1136, -937, -1384, -414, -3871]);
        var output = new Int32Array([-696, 625, 104, 856, 856, 163, 625, 655, -896, 856, -128, 856, 856, 336, 856, -896]);
        VPXDCT.iwalsh4x4(input);
        Assert.assertArrayEquals(output, input);
    };
}, {}, {});
var DctTest = function() {};
DctTest = stjs.extend(DctTest, null, [], function(constructor, prototype) {
    constructor.input = new Int32Array([-416, -33, -60, 32, 48, -40, 0, 0, 0, -24, -56, 19, 26, 0, 0, 0, -42, 13, 80, -24, -40, 0, 0, 0, -56, 17, 44, -29, 0, 0, 0, 0, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    constructor.expectedOutput = new Int32Array([60, 63, 55, 58, 70, 61, 58, 80, 58, 56, 56, 83, 108, 88, 63, 71, 60, 52, 62, 113, 150, 116, 70, 67, 66, 56, 68, 122, 156, 116, 69, 72, 69, 62, 65, 100, 120, 86, 59, 76, 68, 68, 61, 68, 78, 60, 53, 78, 74, 82, 67, 54, 63, 64, 65, 83, 83, 96, 77, 56, 70, 83, 83, 89]);
    constructor.input2 = new Int32Array([-964, -18, 3, 0, 0, 0, 0, 0, -36, -9, 6, -4, 0, 0, 0, 0, 6, 21, 6, 0, 0, 0, 0, 0, -20, 8, -16, 0, 0, 0, 0, 0, 15, 5, -12, 16, 0, 0, 0, 0, -7, -6, 16, -10, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, -8, 0, 0, 0, 0, 0, 0]);
    constructor.expectedOutput2 = new Int32Array([2, 2, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 3, 5, 0, 1, 1, 0, 0, 6, 18, 27, 3, 2, 1, 3, 7, 11, 15, 18, 0, 0, 3, 12, 20, 20, 11, 2, 1, 5, 9, 11, 9, 7, 6, 6, 7, 9, 9, 5, 1, 3, 11, 19, 29, 23, 18, 19, 23, 24, 18, 12]);
    constructor.input3 = new Int32Array([-556, -51, 6, -8, 5, 0, 0, 0, -6, 3, 3, -8, -5, 0, 0, 0, -33, 3, 36, -8, 0, 16, -10, 0, -8, -24, 4, 0, 8, 0, 0, 0, 0, 0, -12, 8, 0, -14, 0, 0, 0, -6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    constructor.expectedOutput3 = new Int32Array([43, 44, 41, 45, 44, 48, 67, 75, 54, 52, 55, 54, 44, 50, 67, 69, 55, 59, 65, 63, 59, 63, 65, 65, 46, 58, 64, 65, 80, 77, 59, 66, 44, 52, 57, 64, 81, 77, 60, 71, 48, 43, 51, 60, 63, 66, 70, 78, 53, 45, 48, 55, 51, 56, 72, 75, 58, 55, 49, 52, 51, 52, 63, 62]);
    prototype.testIntDct = function() {
        var dct = IntDCT.INSTANCE;
        this.doTestRelaxed(dct, DctTest.input, DctTest.expectedOutput);
        this.doTestRelaxed(dct, DctTest.input2, DctTest.expectedOutput2);
        this.doTestRelaxed(dct, DctTest.input3, DctTest.expectedOutput3);
    };
    prototype.testSlowDct = function() {
        var dct = SlowDCT.INSTANCE;
        this.doTestStrict(dct, DctTest.input, DctTest.expectedOutput);
        this.doTestStrict(dct, DctTest.input2, DctTest.expectedOutput2);
        this.doTestStrict(dct, DctTest.input3, DctTest.expectedOutput3);
    };
    prototype.doTestRelaxed = function(dct, input, expected) {
        var output = dct.decode(input);
        Asserts.assertEpsilonEqualsInt(expected, output, 1);
    };
    prototype.doTestStrict = function(dct, input, expected) {
        var output = dct.decode(input);
        var equals = Platform.arrayEqualsInt(expected, output);
        if (!equals) {
            Debug.print8x8i(expected);
            System.out.println();
            Debug.print8x8i(output);
        }
        Assert.assertTrue(equals);
    };
}, {input: "Int32Array", expectedOutput: "Int32Array", input2: "Int32Array", expectedOutput2: "Int32Array", input3: "Int32Array", expectedOutput3: "Int32Array"}, {});
var MockMEncoder = function(bits, m) {
    MEncoder.call(this, null, null);
    this.bits = bits;
    this.m = m;
};
MockMEncoder = stjs.extend(MockMEncoder, MEncoder, [], function(constructor, prototype) {
    prototype.bits = null;
    prototype.m = null;
    prototype.pos = 0;
    prototype.encodeBin = function(model, bin) {
        Assert.assertEquals(this.m[this.pos], model);
        Assert.assertEquals(this.bits[this.pos++], bin);
    };
    prototype.encodeBinBypass = function(bin) {
        Assert.assertEquals(this.bits[this.pos++], bin);
    };
    prototype.encodeBinFinal = function(bin) {
        Assert.assertEquals(this.m[this.pos], -2);
        Assert.assertEquals(this.bits[this.pos++], bin);
    };
    prototype.finishEncoding = function() {};
}, {bits: "Int32Array", m: "Int32Array", out: "ByteBuffer", models: "Array"}, {});
var PGMIO = function() {};
PGMIO = stjs.extend(PGMIO, null, [], function(constructor, prototype) {
    constructor.readPGM = function(is) {
        var dis = new DataInputStream(is);
        var p5 = dis.readLine();
        if (!p5.equals("P5")) {
             throw new IOException("Only P5 is supported");
        }
        var dim = dis.readLine();
        var depth = dis.readLine();
        var tmp = dim.split(" ");
        var width = Integer.parseInt(tmp[0]);
        var height = Integer.parseInt(tmp[1]);
        var buf = new Int8Array(width * height);
        var y = new Int8Array(width * height);
        var read = dis.read(buf, 0, width * height);
        if (read != width * height) {
             throw new IOException("Could not read data fully");
        }
        for (var i = 0; i < width * height; i++) {
            y[i] = (((buf[i] & 255) - 128) << 24 >> 24);
        }
        return Picture8Bit.createPicture8Bit(width, height, [y], ColorSpace.GREY);
    };
    constructor.readPGMFile = function(name) {
        var is = null;
        try {
            is = new BufferedInputStream(new FileInputStream(name));
            return PGMIO.readPGM(is);
        } finally {
            IOUtils.closeQuietly(is);
        }
    };
    constructor.savePGM = function(ref, string) {
        var out = null;
        try {
            out = new FileOutputStream(string);
            var ps = new PrintStream(new BufferedOutputStream(out));
            ps.println("P5");
            ps.println(ref.getWidth() + " " + ref.getHeight());
            ps.println("255");
            ps.flush();
            var data = ref.getPlaneData(0);
            for (var i = 0; i < data.length; i++) 
                ps.write(data[i]);
            ps.flush();
        } finally {
            IOUtils.closeQuietly(out);
        }
    };
}, {}, {});
var TestRgbToYuv420 = function() {};
TestRgbToYuv420 = stjs.extend(TestRgbToYuv420, null, [], function(constructor, prototype) {
    prototype.testRGBToYuv420 = function() {
        var rgb = new Int32Array([3, 192, 105, 19, 153, 61, 125, 114, 16, 175, 213, 20, 186, 252, 183, 122, 99, 236, 255, 50, 72, 45, 127, 129, 54, 114, 84, 96, 52, 65, 73, 226, 196, 131, 90, 195, 85, 197, 130, 190, 147, 86, 104, 177, 233, 72, 205, 82, 18, 41, 88, 123, 140, 54, 5, 132, 129, 47, 137, 69, 34, 208, 223, 167, 89, 36, 176, 124, 153, 144, 91, 153, 170, 114, 63, 185, 145, 167, 92, 179, 36, 52, 95, 30, 68, 97, 33, 29, 189, 136, 211, 118, 55, 149, 102, 161, 47, 249, 48, 167, 157, 131, 117, 244, 186, 241, 80, 72, 109, 178, 104, 20, 233, 121, 224, 93, 142, 171, 99, 61, 72, 192, 108, 149, 165, 193, 146, 138, 63, 43, 97, 133, 97, 35, 25, 73, 149, 229, 198, 190, 84, 245, 92, 142, 52, 42, 189, 191, 178, 58, 73, 156, 71, 214, 6, 28, 136, 172, 120, 34, 199, 234, 15, 82, 71, 240, 89, 107, 251, 4, 86, 49, 170, 165, 204, 248, 166, 17, 29, 210, 95, 80, 196, 42, 201, 170, 188, 111, 243, 33, 231, 237, 50, 223, 16, 176, 233, 2, 61, 147, 94, 111, 207, 43, 5, 133, 109, 70, 70, 167, 199, 50, 37, 145, 14, 190, 34, 94, 74, 54, 58, 231, 10, 54, 83, 227, 74, 74, 56, 228, 48, 179, 226, 179, 247, 152, 23, 20, 86, 39, 75, 94, 210, 212, 43, 117, 174, 7, 147, 250, 130, 243, 119, 142, 66, 74, 207, 237, 249, 190, 209, 174, 173, 0, 155, 11, 156, 7, 216, 247, 122, 232, 52, 65, 129, 139, 40, 10, 205, 184, 40, 79, 4, 220, 90, 123, 69, 252, 209, 75, 52, 198, 151, 96, 45, 199, 20, 230, 232, 24]);
        var y = new Int32Array([124, 104, 107, 170, 209, 120, 114, 104, 96, 73, 168, 114, 150, 147, 155, 146, 50, 124, 96, 104, 151, 107, 139, 114, 123, 153, 133, 80, 86, 132, 135, 122, 158, 151, 187, 125, 144, 150, 134, 116, 142, 156, 129, 89, 61, 132, 171, 139, 69, 161, 120, 77, 149, 148, 68, 133, 91, 130, 210, 56, 100, 145, 144, 164, 143, 179, 115, 153, 95, 86, 96, 79, 79, 82, 54, 119, 150, 194, 159, 68, 103, 104, 79, 170, 125, 163, 196, 148, 77, 151, 169, 111, 51, 91, 137, 107, 113, 153, 130, 195]);
        var u = new Int32Array([118, 108, 83, 49, 108, 185, 107, 141, 124, 127, 138, 168, 115, 95, 163, 94, 152, 93, 146, 112, 160, 93, 133, 147, 97, 132, 78, 106, 104, 129, 87, 147, 70, 115, 121, 101, 106, 111, 130, 101, 109, 143, 94, 152, 114, 174, 80, 127, 191, 74, 103, 107, 111, 168, 133, 113, 127, 144, 99, 209, 177, 138, 174, 160, 63, 35, 118, 71, 137, 170, 100, 186, 128, 204, 147, 105, 75, 114, 57, 117, 182, 135, 164, 160, 98, 161, 128, 52, 170, 173, 66, 142, 209, 124, 103, 200, 98, 97, 73, 37]);
        var v = new Int32Array([51, 76, 140, 125, 104, 128, 216, 92, 104, 146, 63, 139, 84, 151, 92, 78, 115, 127, 73, 93, 51, 166, 149, 147, 156, 144, 100, 114, 120, 62, 173, 144, 54, 134, 77, 199, 103, 43, 182, 162, 81, 119, 137, 102, 156, 89, 139, 191, 122, 142, 98, 217, 116, 53, 99, 193, 230, 75, 115, 110, 126, 61, 152, 41, 67, 119, 94, 98, 74, 121, 194, 173, 103, 114, 107, 195, 65, 111, 179, 102, 112, 197, 191, 173, 123, 68, 152, 141, 181, 34, 93, 99, 127, 188, 43, 139, 188, 152, 73, 142]);
        var uu = this.downscale(u, 10, 10);
        var vv = this.downscale(v, 10, 10);
        var transform = new RgbToYuv420p8Bit();
        var _in = Picture8Bit.createPicture8Bit(10, 10, [ArrayUtil.toByteArrayShifted(rgb), null, null, null], ColorSpace.RGB);
        var out = Picture8Bit.create(10, 10, ColorSpace.YUV420);
        transform.transform(_in, out);
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(y), out.getPlaneData(0));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(uu), out.getPlaneData(1));
        Assert.assertArrayEquals(ArrayUtil.toByteArrayShifted(vv), out.getPlaneData(2));
    };
    prototype.downscale = function(plane, w, h) {
        var result = new Int32Array(w * h >> 2);
        for (var i = 0, k = 0; i < h; i += 2 , k += w * 2) {
            for (var j = 0; j < w; j += 2) {
                var off1 = k + j;
                var off2 = (k >> 2) + (j >> 1);
                result[off2] = (plane[off1] + plane[off1 + 1] + plane[off1 + w] + plane[off1 + 1 + w] + 2) >> 2;
            }
        }
        return result;
    };
}, {}, {});
var SeekHeadFactoryTest = function() {};
SeekHeadFactoryTest = stjs.extend(SeekHeadFactoryTest, null, [], function(constructor, prototype) {
    prototype.testJCodecConvention = function() {
        var tree = this.fakeMkvTree();
        var fos = new FileOutputStream("src/test/resources/mkv/seek_head.ebml");
        try {
            var fc = new FileChannelWrapper(fos.getChannel());
            for (var iterator$me = tree.iterator(); iterator$me.hasNext(); ) {
                var me = iterator$me.next();
                me.mux(fc);
            }
        } finally {
            IOUtils.closeQuietly(fos);
        }
    };
    prototype.fakeMkvTree = function() {
        var tree = new ArrayList();
        var ebmlHeaderElem = MKVType.createByType(MKVType.EBML);
        this.addFakeEbmlHeader(ebmlHeaderElem);
        tree.add(ebmlHeaderElem);
        var segmentElem = MKVType.createByType(MKVType.Segment);
        this.addFakeInfo(segmentElem);
        this.addFakeTracks(segmentElem);
        this.addFakeCues(segmentElem);
        this.muxSeeks(segmentElem);
        tree.add(segmentElem);
        return tree;
    };
    prototype.muxSeeks = function(segmentElem) {
        var shi = new SeekHeadFactory();
        for (var i = 0; i < segmentElem.children.size() && i < 4; i++) {
            var e = segmentElem.children.get(i);
            if (!e.type.equals(MKVType.Tracks) && !e.type.equals(MKVType.Info) && !e.type.equals(MKVType.Tags) && !e.type.equals(MKVType.Cues)) {
                 throw new UnhandledStateException("Unknown entry found among segment children, index " + i);
            }
            shi.add(e);
        }
        segmentElem.children.add(0, shi.indexSeekHead());
    };
    prototype.testMuxingFromTestFileSeek = function() {
        var file = new File("src/test/resources/mkv/seek_head.ebml");
        var rawFrame = IOUtils.readFileToByteArray(file);
        var seekHead = MKVType.createByType(MKVType.SeekHead);
        var seek = MKVType.createByType(MKVType.Seek);
        MKVMuxer.createBuffer(seek, MKVType.SeekID, ByteBuffer.wrap(MKVType.Info.id));
        var se = MKVType.createByType(MKVType.SeekPosition);
        se.setUint(64);
        seek.add(se);
        seekHead.add(seek);
        seek = MKVType.createByType(MKVType.Seek);
        MKVMuxer.createBuffer(seek, MKVType.SeekID, ByteBuffer.wrap(MKVType.Tracks.id));
        se = MKVType.createByType(MKVType.SeekPosition);
        se.setUint(275);
        seek.add(se);
        seekHead.add(seek);
        seek = MKVType.createByType(MKVType.Seek);
        MKVMuxer.createBuffer(seek, MKVType.SeekID, ByteBuffer.wrap(MKVType.Tags.id));
        se = MKVType.createByType(MKVType.SeekPosition);
        se.setUint(440);
        seek.add(se);
        seekHead.add(seek);
        seek = MKVType.createByType(MKVType.Seek);
        MKVMuxer.createBuffer(seek, MKVType.SeekID, ByteBuffer.wrap(MKVType.Cues.id));
        se = MKVType.createByType(MKVType.SeekPosition);
        se.setUint(602);
        seek.add(se);
        seekHead.add(seek);
        var bb = seekHead.getData();
        Assert.assertArrayEquals(rawFrame, bb.array());
        Assert.assertArrayEquals(rawFrame, NIOUtils.toArray(bb));
    };
    prototype.printSizeOptions = function() {
        var s = SeekHeadFactory.estimeteSeekSize(4, 1);
        s += SeekHeadFactory.estimeteSeekSize(4, 1);
        s += SeekHeadFactory.estimeteSeekSize(4, 2);
        s += SeekHeadFactory.estimeteSeekSize(4, 3);
        var z = EbmlUtil.ebmlLength(s);
        s += 4 + z;
        System.out.println("size:" + s + " can be encoded in " + z + " byte(s) using ebml, with seekhead size eq to:" + z);
    };
    prototype.printVariousSeekSizes = function() {
        System.out.println("seekSize(1): " + SeekHeadFactory.estimeteSeekSize(4, 1));
        System.out.println("seekSize(2): " + SeekHeadFactory.estimeteSeekSize(4, 2));
        System.out.println("seekSize(3): " + SeekHeadFactory.estimeteSeekSize(4, 3));
    };
    constructor.fakeZOffset = 0;
    constructor.createFakeZ = function(id, size) {
        var z = new SeekHeadFactory.SeekMock();
        z.id = id;
        z.size = size;
        z.dataOffset = SeekHeadFactoryTest.fakeZOffset;
        z.seekPointerSize = EbmlUint.longToBytes(z.dataOffset).length;
        SeekHeadFactoryTest.fakeZOffset += z.size;
        System.out.println("Added id:" + EbmlUtil.toHexString(z.id) + " offset:" + z.dataOffset + " seekpointer size:" + z.seekPointerSize);
        return z;
    };
    prototype.testEdgeCasesWithFakeZ = function() {
        var a = new SeekHeadFactory();
        a.a.add(SeekHeadFactoryTest.createFakeZ(MKVType.Info.id, 255));
        a.a.add(SeekHeadFactoryTest.createFakeZ(MKVType.Tracks.id, 65285));
        a.a.add(SeekHeadFactoryTest.createFakeZ(MKVType.Tags.id, 16711616));
        a.a.add(SeekHeadFactoryTest.createFakeZ(MKVType.Cues.id, 255));
        var computeSize = a.computeSeekHeadSize();
        System.out.println("SeekHeadSize: " + computeSize);
        Assert.assertEquals(a.estimateSize(), computeSize);
    };
    constructor.createFakeElement = function(id, size) {
        var e = new EbmlBin(id);
        e.dataLen = size;
        return e;
    };
    prototype.testSeekHeadSize = function() {
        var a = new SeekHeadFactory();
        a.add(SeekHeadFactoryTest.createFakeElement(MKVType.Info.id, 255 - 4 - 2));
        a.add(SeekHeadFactoryTest.createFakeElement(MKVType.Tracks.id, 65285 - 4 - 2));
        a.add(SeekHeadFactoryTest.createFakeElement(MKVType.Cues.id, 16711679 - 4 - 3));
        var computeSize = a.computeSeekHeadSize();
        System.out.println("SeekHeadSize: " + computeSize);
        Assert.assertEquals(a.estimateSize(), computeSize);
    };
    prototype.testSeekHeadMuxing = function() {
        var a = new SeekHeadFactory();
        a.add(SeekHeadFactoryTest.createFakeElement(MKVType.Info.id, 255 - 4 - 2));
        a.add(SeekHeadFactoryTest.createFakeElement(MKVType.Tracks.id, 65280 - 4 - 3));
        a.add(SeekHeadFactoryTest.createFakeElement(MKVType.Cues.id, 16711680 - 4 - 4));
        a.add(SeekHeadFactoryTest.createFakeElement(MKVType.Tags.id, 255 - 4 - 4));
        var computeSize = a.computeSeekHeadSize();
        System.out.println("SeekHeadSize: " + computeSize);
        Assert.assertEquals(a.estimateSize(), computeSize);
        var mux = a.indexSeekHead().getData();
        Assert.assertEquals(a.estimateSize(), mux.limit());
        var fos = new FileOutputStream("src/test/resources/mkv/seek_head.ebml");
        try {
            fos.getChannel().write(mux);
        } finally {
            IOUtils.closeQuietly(fos);
        }
    };
    prototype.addFakeEbmlHeader = function(ebmlHeaderElem) {
        var docTypeElem = MKVType.createByType(MKVType.DocType);
        docTypeElem.setString("matroska");
        var docTypeVersionElem = MKVType.createByType(MKVType.DocTypeVersion);
        docTypeVersionElem.setUint(2);
        var docTypeReadVersionElem = MKVType.createByType(MKVType.DocTypeReadVersion);
        docTypeReadVersionElem.setUint(2);
        ebmlHeaderElem.add(docTypeElem);
        ebmlHeaderElem.add(docTypeVersionElem);
        ebmlHeaderElem.add(docTypeReadVersionElem);
    };
    prototype.addFakeInfo = function(segmentElem) {
        var segmentInfoElem = MKVType.createByType(MKVType.Info);
        var dateElem = MKVType.createByType(MKVType.DateUTC);
        dateElem.setDate(new jsutil.Date());
        segmentInfoElem.add(dateElem);
        MKVMuxer.createLong(segmentInfoElem, MKVType.TimecodeScale, 100000);
        MKVMuxer.createDouble(segmentInfoElem, MKVType.Duration, 87336.0 * 1000.0);
        MKVMuxer.createString(segmentInfoElem, MKVType.WritingApp, "JCodec v0.1.0");
        MKVMuxer.createString(segmentInfoElem, MKVType.MuxingApp, "Matroska Muxer v0.1a");
        segmentElem.add(segmentInfoElem);
    };
    prototype.addFakeTracks = function(segmentElem) {
        var r = new Random();
        var tracksElem = MKVType.createByType(MKVType.Tracks);
        var trackEntryElem = MKVType.createByType(MKVType.TrackEntry);
        MKVMuxer.createLong(trackEntryElem, MKVType.TrackNumber, 1);
        MKVMuxer.createLong(trackEntryElem, MKVType.TrackUID, r.nextLong());
        MKVMuxer.createLong(trackEntryElem, MKVType.TrackType, 1);
        MKVMuxer.createString(trackEntryElem, MKVType.Name, "Video");
        MKVMuxer.createString(trackEntryElem, MKVType.Language, "en");
        MKVMuxer.createString(trackEntryElem, MKVType.CodecID, "V_UNCOMPRESSED");
        var trackVideoElem = MKVType.createByType(MKVType.Video);
        MKVMuxer.createLong(trackVideoElem, MKVType.PixelWidth, 1024);
        MKVMuxer.createLong(trackVideoElem, MKVType.PixelHeight, 768);
        MKVMuxer.createLong(trackVideoElem, MKVType.DisplayWidth, 1024);
        MKVMuxer.createLong(trackVideoElem, MKVType.DisplayHeight, 768);
        trackEntryElem.add(trackVideoElem);
        tracksElem.add(trackEntryElem);
        trackEntryElem = MKVType.createByType(MKVType.TrackEntry);
        MKVMuxer.createLong(trackEntryElem, MKVType.TrackNumber, 2);
        MKVMuxer.createLong(trackEntryElem, MKVType.TrackUID, r.nextLong());
        MKVMuxer.createLong(trackEntryElem, MKVType.TrackType, 2);
        MKVMuxer.createString(trackEntryElem, MKVType.Name, "Audio");
        MKVMuxer.createString(trackEntryElem, MKVType.Language, "en");
        MKVMuxer.createString(trackEntryElem, MKVType.CodecID, "A_MPEG/L3");
        var trackAudioElem = MKVType.createByType(MKVType.Audio);
        MKVMuxer.createLong(trackAudioElem, MKVType.Channels, 2);
        MKVMuxer.createDouble(trackAudioElem, MKVType.SamplingFrequency, 48000.0);
        trackEntryElem.add(trackAudioElem);
        tracksElem.add(trackEntryElem);
        segmentElem.add(tracksElem);
    };
    prototype.addFakeCues = function(segmentElem) {
        var cuesElem = MKVType.createByType(MKVType.Cues);
        segmentElem.add(cuesElem);
    };
}, {}, {});
var MPSIndexerTest = function() {};
MPSIndexerTest = stjs.extend(MPSIndexerTest, null, [], function(constructor, prototype) {
    constructor.toHex = function(struct) {
        var bb = ByteBuffer.allocate(1024);
        struct.write(bb);
        bb.flip();
        return NIOUtils.toArray(bb);
    };
    constructor.flatten = function(data) {
        var total = 0;
        for (var i = 0; i < data.length; i++) {
            total += data[i].length;
        }
        var result = new Int8Array(total);
        for (var i = 0, off = 0; i < data.length; i++) {
            for (var j = 0; j < data[i].length; j++ , off++) {
                result[off] = data[i][j];
            }
        }
        return result;
    };
    constructor.syncMarker = new Int8Array([0, 0, 1]);
    constructor.mpegStreamParams = MPSIndexerTest.flatten([MPSIndexerTest.syncMarker, new Int8Array([(179 << 24 >> 24)]), MPSIndexerTest.toHex(SequenceHeader.createSequenceHeader(1920, 1080, 1, 1, 512 * 1024, 0, 0, null, null)), MPSIndexerTest.syncMarker, new Int8Array([(181 << 24 >> 24)]), MPSIndexerTest.toHex(SequenceExtension.createSequenceExtension(100, 1, 1, 0, 0, 0, 0, 0, 0, 0)), MPSIndexerTest.syncMarker, new Int8Array([(184 << 24 >> 24)]), MPSIndexerTest.toHex(new GOPHeader(new TapeTimecode(((1) << 16 >> 16), (0 << 24 >> 24), (0 << 24 >> 24), (10 << 24 >> 24), false), false, false))]);
    constructor.mpegSlices = MPSIndexerTest.flatten([MPSIndexerTest.syncMarker, new Int8Array([1, 0, 0, 0]), MPSIndexerTest.syncMarker, new Int8Array([2, 0, 0, 0]), MPSIndexerTest.syncMarker, new Int8Array([3, 0, 0, 0])]);
    constructor.mpegFrame = function(tempRef, frameType) {
        return MPSIndexerTest.flatten([MPSIndexerTest.syncMarker, new Int8Array([0]), MPSIndexerTest.toHex(PictureHeader.createPictureHeader(tempRef, frameType, 0, 0, 0, 0, 0)), MPSIndexerTest.syncMarker, new Int8Array([(181 << 24 >> 24)]), MPSIndexerTest.toHex(new PictureCodingExtension()), MPSIndexerTest.mpegSlices]);
    };
    constructor.iFrame = MPSIndexerTest.flatten([MPSIndexerTest.mpegStreamParams, MPSIndexerTest.mpegFrame(0, 1)]);
    prototype.ts = function(ts) {
        return new Int8Array([(((ts >> 29) << 1) << 24 >> 24), ((ts >> 22) << 24 >> 24), (((ts >> 15) << 1) << 24 >> 24), ((ts >> 7) << 24 >> 24), (((ts & 127) << 1) << 24 >> 24)]);
    };
    prototype.sub = function(arr, off, length) {
        return Platform.copyOfRangeB(arr, off, Math.min(arr.length, off + length));
    };
    prototype._pes = function(streamId, pts, dts, payloadLen, off, es, zeroLen) {
        var sub = this.sub(es, off, payloadLen);
        var pesLen = zeroLen ? 0 : sub.length + 13;
        return MPSIndexerTest.flatten([new Int8Array([0, 0, 1, (streamId << 24 >> 24), ((pesLen >> 8) << 24 >> 24), ((pesLen & 255) << 24 >> 24), (128 << 24 >> 24), (192 << 24 >> 24), 10]), this.ts(pts), this.ts(dts), sub]);
    };
    prototype.pes = function(streamId, payloadLen, off, es, zeroLen) {
        var sub = this.sub(es, off, payloadLen);
        var pesLen = zeroLen ? 0 : sub.length + 3;
        return MPSIndexerTest.flatten([new Int8Array([0, 0, 1, (streamId << 24 >> 24), ((pesLen >> 8) << 24 >> 24), ((pesLen & 255) << 24 >> 24), (128 << 24 >> 24), (0 << 24 >> 24), 0]), sub]);
    };
    prototype.printHex = function(mpegPS) {
        for (var i = 0; i < mpegPS.length; i += 32) {
            for (var j = i; j < Math.min(mpegPS.length, i + 32); j++) {
                System.out.print(String.format("%02x", mpegPS[j]) + " ");
            }
            System.out.println();
        }
    };
    prototype.testSingleVideoLengthPresentPtsPresent = function() {
        var mpegFrames = [MPSIndexerTest.iFrame, MPSIndexerTest.mpegFrame(5, 2), MPSIndexerTest.mpegFrame(2, 3), MPSIndexerTest.mpegFrame(3, 3), MPSIndexerTest.mpegFrame(4, 3)];
        var mpegES = MPSIndexerTest.flatten(mpegFrames);
        var pesLen = stjs.trunc(mpegFrames[1].length / 3);
        var peses = [this.pes(224, pesLen, 0, mpegES, false), this.pes(224, pesLen, pesLen, mpegES, false), this._pes(224, 10000, 9995, pesLen, pesLen * 2, mpegES, false), this.pes(224, pesLen, pesLen * 3, mpegES, false), this.pes(224, pesLen, pesLen * 4, mpegES, false), this._pes(224, 13003, 12998, pesLen, pesLen * 5, mpegES, false), this.pes(224, pesLen, pesLen * 6, mpegES, false), this.pes(224, pesLen, pesLen * 7, mpegES, false), this.pes(224, pesLen, pesLen * 8, mpegES, false), this._pes(224, 16006, 16001, pesLen, pesLen * 9, mpegES, false), this.pes(224, pesLen, pesLen * 10, mpegES, false), this.pes(224, pesLen, pesLen * 11, mpegES, false), this._pes(224, 19009, 19004, pesLen, pesLen * 12, mpegES, false), this.pes(224, pesLen, pesLen * 13, mpegES, false), this.pes(224, pesLen, pesLen * 14, mpegES, false), this._pes(224, 21012, 21007, pesLen, pesLen * 15, mpegES, false), this.pes(224, pesLen, pesLen * 16, mpegES, false), this.pes(224, pesLen, pesLen * 17, mpegES, false), this.pes(224, pesLen, pesLen * 18, mpegES, false)];
        var mpegPS = MPSIndexerTest.flatten(peses);
        this.printHex(mpegPS);
        var mpsIndexer = new MPSIndexer();
        mpsIndexer.indexChannel(new ByteBufferSeekableByteChannel(ByteBuffer.wrap(mpegPS)), null);
        var index = mpsIndexer.serialize();
        var pesTokens = index.getPesTokens();
        Assert.assertEquals(peses.length, pesTokens.length);
        for (var i = 0; i < pesTokens.length; i++) {
            Assert.assertEquals(i == pesTokens.length - 1 ? (mpegES.length % pesLen) : pesLen, MPSIndex.payLoadSize(pesTokens[i]));
            Assert.assertEquals(peses[i].length, MPSIndex.pesLen(pesTokens[i]));
        }
        var streams = index.getStreams();
        Assert.assertEquals(1, streams.length);
        var stream = streams[0];
        Assert.assertArrayEquals(new Int32Array([10000, 13003, 16006, 19009, 21012]), stream.getFpts());
        Assert.assertArrayEquals(new Int32Array([mpegFrames[0].length, mpegFrames[1].length, mpegFrames[2].length, mpegFrames[3].length, mpegFrames[4].length]), stream.fsizes);
        Assert.assertArrayEquals(new Int32Array([0]), stream.sync);
    };
    prototype.testInterleavedLengthPresentPtsPresent = function() {
        var EMPTY = new Int8Array([0, 0]);
        var mpegFrames = [MPSIndexerTest.iFrame, MPSIndexerTest.mpegFrame(5, 2), MPSIndexerTest.mpegFrame(2, 3), MPSIndexerTest.mpegFrame(3, 3), MPSIndexerTest.mpegFrame(4, 3)];
        var mpegES = MPSIndexerTest.flatten(mpegFrames);
        var pesLen = stjs.trunc(mpegFrames[1].length / 3);
        var peses = [this.pes(224, pesLen, 0, mpegES, false), this.pes(224, pesLen, pesLen, mpegES, false), this._pes(189, 10100, 10095, 2, 0, EMPTY, false), this._pes(224, 10000, 9995, pesLen, pesLen * 2, mpegES, false), this.pes(224, pesLen, pesLen * 3, mpegES, false), this._pes(189, 16100, 16095, 2, 0, EMPTY, false), this.pes(224, pesLen, pesLen * 4, mpegES, false), this._pes(224, 13003, 12998, pesLen, pesLen * 5, mpegES, false), this._pes(189, 22100, 22095, 2, 0, EMPTY, false), this.pes(224, pesLen, pesLen * 6, mpegES, false), this.pes(224, pesLen, pesLen * 7, mpegES, false), this._pes(189, 28100, 28095, 2, 0, EMPTY, false), this.pes(224, pesLen, pesLen * 8, mpegES, false), this._pes(224, 16006, 16001, pesLen, pesLen * 9, mpegES, false), this._pes(189, 34100, 34095, 2, 0, EMPTY, false), this.pes(224, pesLen, pesLen * 10, mpegES, false), this.pes(224, pesLen, pesLen * 11, mpegES, false), this._pes(189, 40100, 40095, 2, 0, EMPTY, false), this._pes(224, 19009, 19004, pesLen, pesLen * 12, mpegES, false), this.pes(224, pesLen, pesLen * 13, mpegES, false), this._pes(189, 46100, 46095, 2, 0, EMPTY, false), this.pes(224, pesLen, pesLen * 14, mpegES, false), this._pes(224, 21012, 21007, pesLen, pesLen * 15, mpegES, false), this._pes(189, 52100, 52095, 2, 0, EMPTY, false), this.pes(224, pesLen, pesLen * 16, mpegES, false), this.pes(224, pesLen, pesLen * 17, mpegES, false), this._pes(189, 58100, 58095, 2, 0, EMPTY, false), this.pes(224, pesLen, pesLen * 18, mpegES, false)];
        var mpegPS = MPSIndexerTest.flatten(peses);
        this.printHex(mpegPS);
        var mpsIndexer = new MPSIndexer();
        mpsIndexer.indexChannel(new ByteBufferSeekableByteChannel(ByteBuffer.wrap(mpegPS)), null);
        var index = mpsIndexer.serialize();
        var pesTokens = index.getPesTokens();
        Assert.assertEquals(peses.length, pesTokens.length);
        for (var i = 0; i < pesTokens.length; i++) {
            Assert.assertEquals((i % 3) == 2 ? 2 : i == pesTokens.length - 1 ? (mpegES.length % pesLen) : pesLen, MPSIndex.payLoadSize(pesTokens[i]));
            Assert.assertEquals(peses[i].length, MPSIndex.pesLen(pesTokens[i]));
        }
        var streams = index.getStreams();
        Assert.assertEquals(2, streams.length);
        var stream = this.getVideoStream(streams);
        Assert.assertArrayEquals(new Int32Array([10000, 13003, 16006, 19009, 21012]), stream.getFpts());
        Assert.assertArrayEquals(new Int32Array([mpegFrames[0].length, mpegFrames[1].length, mpegFrames[2].length, mpegFrames[3].length, mpegFrames[4].length]), stream.fsizes);
        Assert.assertArrayEquals(new Int32Array([0]), stream.sync);
    };
    prototype.testInterleavedNoLengthPtsPresent = function() {
        var EMPTY = new Int8Array([0, 0]);
        var mpegFrames = [MPSIndexerTest.iFrame, MPSIndexerTest.mpegFrame(5, 2), MPSIndexerTest.mpegFrame(2, 3), MPSIndexerTest.mpegFrame(3, 3), MPSIndexerTest.mpegFrame(4, 3)];
        var mpegES = MPSIndexerTest.flatten(mpegFrames);
        var pesLen = stjs.trunc(mpegFrames[1].length / 3);
        var peses = [this.pes(224, pesLen, 0, mpegES, true), this.pes(224, pesLen, pesLen, mpegES, true), this._pes(189, 10100, 10095, 2, 0, EMPTY, false), this._pes(224, 10000, 9995, pesLen, pesLen * 2, mpegES, true), this.pes(224, pesLen, pesLen * 3, mpegES, true), this._pes(189, 16100, 16095, 2, 0, EMPTY, false), this.pes(224, pesLen, pesLen * 4, mpegES, true), this._pes(224, 13003, 12998, pesLen, pesLen * 5, mpegES, true), this._pes(189, 22100, 22095, 2, 0, EMPTY, false), this.pes(224, pesLen, pesLen * 6, mpegES, true), this.pes(224, pesLen, pesLen * 7, mpegES, true), this._pes(189, 28100, 28095, 2, 0, EMPTY, false), this.pes(224, pesLen, pesLen * 8, mpegES, true), this._pes(224, 16006, 16001, pesLen, pesLen * 9, mpegES, true), this._pes(189, 34100, 34095, 2, 0, EMPTY, false), this.pes(224, pesLen, pesLen * 10, mpegES, true), this.pes(224, pesLen, pesLen * 11, mpegES, true), this._pes(189, 40100, 40095, 2, 0, EMPTY, false), this._pes(224, 19009, 19004, pesLen, pesLen * 12, mpegES, true), this.pes(224, pesLen, pesLen * 13, mpegES, true), this._pes(189, 46100, 46095, 2, 0, EMPTY, false), this.pes(224, pesLen, pesLen * 14, mpegES, true), this._pes(224, 21012, 21007, pesLen, pesLen * 15, mpegES, true), this._pes(189, 52100, 52095, 2, 0, EMPTY, false), this.pes(224, pesLen, pesLen * 16, mpegES, true), this.pes(224, pesLen, pesLen * 17, mpegES, true), this._pes(189, 58100, 58095, 2, 0, EMPTY, false), this.pes(224, pesLen, pesLen * 18, mpegES, true)];
        var mpegPS = MPSIndexerTest.flatten(peses);
        this.printHex(mpegPS);
        var mpsIndexer = new MPSIndexer();
        mpsIndexer.indexChannel(new ByteBufferSeekableByteChannel(ByteBuffer.wrap(mpegPS)), null);
        var index = mpsIndexer.serialize();
        var pesTokens = index.getPesTokens();
        Assert.assertEquals(peses.length, pesTokens.length);
        for (var i = 0; i < pesTokens.length; i++) {
            Assert.assertEquals((i % 3) == 2 ? 2 : i == pesTokens.length - 1 ? (mpegES.length % pesLen) : pesLen, MPSIndex.payLoadSize(pesTokens[i]));
            Assert.assertEquals(peses[i].length, MPSIndex.pesLen(pesTokens[i]));
        }
        var streams = index.getStreams();
        Assert.assertEquals(2, streams.length);
        var stream = this.getVideoStream(streams);
        Assert.assertArrayEquals(new Int32Array([10000, 13003, 16006, 19009, 21012]), stream.getFpts());
        Assert.assertArrayEquals(new Int32Array([mpegFrames[0].length, mpegFrames[1].length, mpegFrames[2].length, mpegFrames[3].length, mpegFrames[4].length]), stream.fsizes);
        Assert.assertArrayEquals(new Int32Array([0]), stream.sync);
    };
    prototype.testInterleavedNoLengthPtsInterpolation = function() {
        var EMPTY = new Int8Array([0, 0]);
        var mpegFrames = [MPSIndexerTest.iFrame, MPSIndexerTest.mpegFrame(4, 2), MPSIndexerTest.mpegFrame(1, 3), MPSIndexerTest.mpegFrame(2, 3), MPSIndexerTest.mpegFrame(3, 3)];
        var mpegES = MPSIndexerTest.flatten(mpegFrames);
        var pesLen = stjs.trunc(mpegFrames[1].length / 3);
        var peses = [this.pes(224, pesLen, 0, mpegES, true), this.pes(224, pesLen, pesLen, mpegES, true), this._pes(189, 10100, 10095, 2, 0, EMPTY, false), this.pes(224, pesLen, pesLen * 2, mpegES, true), this.pes(224, pesLen, pesLen * 3, mpegES, true), this._pes(189, 16100, 16095, 2, 0, EMPTY, false), this.pes(224, pesLen, pesLen * 4, mpegES, true), this._pes(224, 22012, 22007, pesLen, pesLen * 5, mpegES, true), this._pes(189, 22100, 22095, 2, 0, EMPTY, false), this.pes(224, pesLen, pesLen * 6, mpegES, true), this.pes(224, pesLen, pesLen * 7, mpegES, true), this._pes(189, 28100, 28095, 2, 0, EMPTY, false), this.pes(224, pesLen, pesLen * 8, mpegES, true), this.pes(224, pesLen, pesLen * 9, mpegES, true), this._pes(189, 34100, 34095, 2, 0, EMPTY, false), this.pes(224, pesLen, pesLen * 10, mpegES, true), this.pes(224, pesLen, pesLen * 11, mpegES, true), this._pes(189, 40100, 40095, 2, 0, EMPTY, false), this._pes(224, 16006, 16001, pesLen, pesLen * 12, mpegES, true), this.pes(224, pesLen, pesLen * 13, mpegES, true), this._pes(189, 46100, 46095, 2, 0, EMPTY, false), this.pes(224, pesLen, pesLen * 14, mpegES, true), this.pes(224, pesLen, pesLen * 15, mpegES, true), this._pes(189, 52100, 52095, 2, 0, EMPTY, false), this.pes(224, pesLen, pesLen * 16, mpegES, true), this.pes(224, pesLen, pesLen * 17, mpegES, true), this._pes(189, 58100, 58095, 2, 0, EMPTY, false), this.pes(224, pesLen, pesLen * 18, mpegES, true)];
        var mpegPS = MPSIndexerTest.flatten(peses);
        this.printHex(mpegPS);
        var mpsIndexer = new MPSIndexer();
        mpsIndexer.indexChannel(new ByteBufferSeekableByteChannel(ByteBuffer.wrap(mpegPS)), null);
        var index = mpsIndexer.serialize();
        var pesTokens = index.getPesTokens();
        Assert.assertEquals(peses.length, pesTokens.length);
        for (var i = 0; i < pesTokens.length; i++) {
            Assert.assertEquals((i % 3) == 2 ? 2 : i == pesTokens.length - 1 ? (mpegES.length % pesLen) : pesLen, MPSIndex.payLoadSize(pesTokens[i]));
            Assert.assertEquals(peses[i].length, MPSIndex.pesLen(pesTokens[i]));
        }
        var streams = index.getStreams();
        Assert.assertEquals(2, streams.length);
        var stream = this.getVideoStream(streams);
        Assert.assertArrayEquals(new Int32Array([10000, 22012, 13003, 16006, 19009]), stream.getFpts());
        Assert.assertArrayEquals(new Int32Array([mpegFrames[0].length, mpegFrames[1].length, mpegFrames[2].length, mpegFrames[3].length, mpegFrames[4].length]), stream.fsizes);
        Assert.assertArrayEquals(new Int32Array([0]), stream.sync);
    };
    prototype.getVideoStream = function(streams) {
        for (var stream in streams) {
            if (MPSUtils.videoStream(stream.streamId)) 
                return stream;
        }
        return null;
    };
}, {syncMarker: "Int8Array", mpegStreamParams: "Int8Array", mpegSlices: "Int8Array", iFrame: "Int8Array"}, {});
var EbmlUlongTest = function() {};
EbmlUlongTest = stjs.extend(EbmlUlongTest, null, [], function(constructor, prototype) {
    prototype.test = function() {
        var z = new EbmlUlong(MKVType.CueClusterPosition.id);
        z.setUlong(2);
        Assert.assertArrayEquals("THIS IS PARTA!!!", new Int8Array([0, 0, 0, 0, 0, 0, 0, 2]), z.data.array());
    };
    prototype.test1 = function() {
        var z = new EbmlUlong(MKVType.CueClusterPosition.id);
        z.setBuf(ByteBuffer.wrap(new Int8Array([0, 0, 0, 0, 0, 0, 0, 2])));
        Assert.assertEquals("THIS IS PARTA!!!", 2, z.getUlong());
    };
}, {}, {});
var CollectionsTest = function() {};
CollectionsTest = stjs.extend(CollectionsTest, null, [], function(constructor, prototype) {
    prototype.testIntObjectMap = function() {
        var test = new IntObjectMap();
        test.put(24, 11);
        Assert.assertEquals(Integer.valueOf(11), test.get(24));
        test.put(248, 21);
        Assert.assertEquals(Integer.valueOf(11), test.get(24));
        Assert.assertEquals(Integer.valueOf(21), test.get(248));
        Assert.assertEquals(test.size(), 2);
        Assert.assertArrayEquals(test.keys(), new Int32Array([24, 248]));
        Assert.assertArrayEquals(test.values(Array(0)), [11, 21]);
    };
    prototype.testIntIntMap = function() {
        var test = new IntIntMap();
        test.put(24, 11);
        Assert.assertEquals(11, test.get(24));
        test.put(248, 21);
        Assert.assertEquals(11, test.get(24));
        Assert.assertEquals(21, test.get(248));
        Assert.assertEquals(test.size(), 2);
        Assert.assertArrayEquals(test.keys(), new Int32Array([24, 248]));
        Assert.assertArrayEquals(test.values(), new Int32Array([11, 21]));
    };
    prototype.testByteArrayList = function() {
        var intal = ByteArrayList.createByteArrayList();
        var arr = new Int8Array(200);
        for (var i = 0; i < 200; i++) {
            intal.add((i << 24 >> 24));
            arr[i] = (i << 24 >> 24);
        }
        Assert.assertEquals(20, intal.get(20));
        Assert.assertEquals(40, intal.get(40));
        Assert.assertEquals(151, intal.get(151) & 255);
        Assert.assertEquals(200, intal.size());
        Assert.assertArrayEquals(arr, intal.toArray());
        var other = new Int8Array([1, 2, 3, 4, 5]);
        intal.addAll(other);
        Assert.assertEquals(205, intal.size());
        Assert.assertEquals(5, intal.get(204));
        intal.fill(10, 100, (99 << 24 >> 24));
        Assert.assertEquals(99, intal.get(50));
    };
    prototype.testIntArrayList = function() {
        var intal = IntArrayList.createIntArrayList();
        var arr = new Int32Array(200);
        for (var i = 0; i < 200; i++) {
            intal.add(i * 10);
            arr[i] = i * 10;
        }
        Assert.assertEquals(200, intal.get(20));
        Assert.assertEquals(400, intal.get(40));
        Assert.assertEquals(1510, intal.get(151));
        Assert.assertEquals(200, intal.size());
        Assert.assertArrayEquals(arr, intal.toArray());
        var other = new Int32Array([1, 2, 3, 4, 5]);
        intal.addAll(other);
        Assert.assertEquals(205, intal.size());
        Assert.assertEquals(5, intal.get(204));
        intal.fill(10, 100, 99);
        Assert.assertEquals(99, intal.get(50));
    };
    prototype.testLongArrayList = function() {
        var intal = LongArrayList.createLongArrayList();
        var arr = Array(200);
        for (var i = 0; i < 200; i++) {
            intal.add(i * 10);
            arr[i] = i * 10;
        }
        Assert.assertEquals(200, intal.get(20));
        Assert.assertEquals(400, intal.get(40));
        Assert.assertEquals(1510, intal.get(151));
        Assert.assertEquals(200, intal.size());
        Assert.assertArrayEquals(arr, intal.toArray());
        var other = [1, 2, 3, 4, 5];
        intal.addAll(other);
        Assert.assertEquals(205, intal.size());
        Assert.assertEquals(5, intal.get(204));
        intal.fill(10, 100, 99);
        Assert.assertEquals(99, intal.get(50));
    };
}, {}, {});
var TestSubblockPrediction = function() {};
TestSubblockPrediction = stjs.extend(TestSubblockPrediction, null, [], function(constructor, prototype) {
    prototype.testVR = function() {
        var above = new Int32Array([46, 50, 55, 60]);
        var left = new Int32Array([40, 37, 35, 35]);
        var aboveLeft = 42;
        var aboveRight = new Int32Array([68, 68, 68, 68]);
        var p = new Int32Array([44, 48, 53, 58, 43, 46, 50, 55, 40, 44, 48, 53, 37, 43, 46, 50]);
        Assert.assertArrayEquals(p, VP8Util.predictVR(above, left, aboveLeft));
    };
    prototype.testHD = function() {
        var above = new Int32Array([40, 40, 41, 42]);
        var left = new Int32Array([35, 35, 35, 35]);
        var aboveLeft = 36;
        var aboveRight = new Int32Array([46, 50, 55, 60]);
        var p = new Int32Array([36, 37, 39, 40, 35, 35, 36, 37, 35, 35, 35, 35, 35, 35, 35, 35]);
        Assert.assertArrayEquals(p, VP8Util.predictHD(above, left, aboveLeft));
    };
    prototype.testHU = function() {
        var above = new Int32Array([48, 48, 47, 43]);
        var left = new Int32Array([17, 17, 17, 17]);
        var aboveLeft = 48;
        var aboveRight = new Int32Array([38, 38, 38, 38]);
        var p = new Int32Array([17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17]);
        Assert.assertArrayEquals(p, VP8Util.predictHU(left));
    };
    prototype.testRD = function() {
        var above = new Int32Array([39, 37, 37, 37]);
        var left = new Int32Array([48, 48, 48, 48]);
        var aboveLeft = 43;
        var aboveRight = new Int32Array([37, 37, 37, 37]);
        var p = new Int32Array([43, 40, 38, 37, 47, 43, 40, 38, 48, 47, 43, 40, 48, 48, 47, 43]);
        Assert.assertArrayEquals(p, VP8Util.predictRD(above, left, aboveLeft));
    };
    prototype.testVE = function() {
        var above = new Int32Array([38, 37, 37, 37]);
        var aboveLeft = 41;
        var aboveRight = new Int32Array([37, 37, 37, 37]);
        var p = new Int32Array([39, 37, 37, 37, 39, 37, 37, 37, 39, 37, 37, 37, 39, 37, 37, 37]);
        Assert.assertArrayEquals(p, VP8Util.predictVE(above, aboveLeft, aboveRight));
    };
    prototype.testHE = function() {
        var above = new Int32Array([48, 48, 48, 48]);
        var left = new Int32Array([40, 40, 40, 39]);
        var aboveLeft = 44;
        var aboveRight = new Int32Array([45, 45, 45, 45]);
        var p = new Int32Array([41, 41, 41, 41, 40, 40, 40, 40, 40, 40, 40, 40, 39, 39, 39, 39]);
        Assert.assertArrayEquals(p, VP8Util.predictHE(left, aboveLeft));
    };
    prototype.testDC = function() {
        var above = new Int32Array([39, 39, 39, 39]);
        var left = new Int32Array([38, 40, 59, 126]);
        var p = new Int32Array([52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52]);
        Assert.assertArrayEquals(p, VP8Util.predictDC(above, left));
    };
    prototype.testTM = function() {
        var above = new Int32Array([41, 41, 41, 41]);
        var left = new Int32Array([37, 48, 104, 180]);
        var aboveLeft = 41;
        var p = new Int32Array([37, 37, 37, 37, 48, 48, 48, 48, 104, 104, 104, 104, 180, 180, 180, 180]);
        Assert.assertArrayEquals(p, VP8Util.predictTM(above, left, aboveLeft));
    };
    prototype.testLD = function() {
        var above = new Int32Array([92, 92, 92, 92]);
        var left = new Int32Array([88, 87, 83, 79]);
        var aboveLeft = 81;
        var aboveRight = new Int32Array([85, 85, 85, 85]);
        var p = new Int32Array([92, 92, 90, 87, 92, 90, 87, 85, 90, 87, 85, 85, 87, 85, 85, 85]);
        Assert.assertArrayEquals(p, VP8Util.predictLD(above, aboveRight));
    };
    prototype.testVL = function() {
        var above = new Int32Array([87, 85, 83, 73]);
        var left = new Int32Array([94, 83, 81, 87]);
        var aboveLeft = 104;
        var aboveRight = new Int32Array([61, 61, 61, 61]);
        var p = new Int32Array([86, 84, 78, 67, 85, 81, 73, 64, 84, 78, 67, 61, 81, 73, 64, 61]);
        Assert.assertArrayEquals(p, VP8Util.predictVL(above, aboveRight));
    };
}, {}, {});
var FixTimestampTest = function() {};
FixTimestampTest = stjs.extend(FixTimestampTest, null, [], function(constructor, prototype) {
    constructor.SetPTS = function(setpts) {
        FixTimestamp.call(this);
        this.delta = Long.MIN_VALUE;
        this.setpts = setpts;
    };
    constructor.SetPTS = stjs.extend(constructor.SetPTS, FixTimestamp, [], function(constructor, prototype) {
        prototype.delta = 0;
        prototype.setpts = 0;
        prototype.doWithTimestamp = function(streamId, pts, isPts) {
            if (!isPts) 
                return pts;
            if (this.delta == Long.MIN_VALUE) {
                this.delta = this.setpts - pts;
            }
            return pts + this.delta;
        };
    }, {}, {});
    constructor.setFirstPts = function(tsfile, firstPts) {
        var set = new FixTimestampTest.SetPTS(firstPts);
        set.fix(tsfile);
    };
    prototype.testSetPts = function() {
        var largeTs = new File("02.ts");
        var noSoundTs = new File("02nosound.ts");
        FixTimestampTest.doCopyFile(largeTs, noSoundTs, true);
        FixTimestampTest.setFirstPts(noSoundTs, 609483);
    };
    constructor.doCopyFile = function(srcFile, destFile, preserveFileDate) {
        if (destFile.exists() && destFile.isDirectory()) {
             throw new IOException("Destination '" + destFile + "' exists but is a directory");
        }
        var fis = null;
        var fos = null;
        var input = null;
        var output = null;
        try {
            fis = new FileInputStream(srcFile);
            fos = new FileOutputStream(destFile);
            input = fis.getChannel();
            output = fos.getChannel();
            var size = input.size();
            var pos = 0;
            var count = 0;
             while (pos < size){
                count = size - pos;
                pos += output.transferFrom(input, pos, count);
            }
        } finally {
            output.close();
            fos.close();
            input.close();
            fis.close();
        }
        if (srcFile.length() != destFile.length()) {
             throw new IOException("Failed to copy full contents from '" + srcFile + "' to '" + destFile + "'");
        }
        if (preserveFileDate) {
            destFile.setLastModified(srcFile.lastModified());
        }
    };
}, {}, {});
var SegmentIndexBoxTest = function() {};
SegmentIndexBoxTest = stjs.extend(SegmentIndexBoxTest, null, [], function(constructor, prototype) {
    /**
     * Example sidx box
     *  <pre>
     *  00000000  00 00 00 2c 73 69 64 78  00 00 00 00 00 00 00 01  |...,sidx........|
     *  00000010  00 01 5f 90 00 00 00 00  00 00 00 00 00 00 00 01  |.._.............|
     *  00000020  00 06 dc 00 00 06 99 30  90 00 00 00              |.......0....|
     *  </pre>
     */
    constructor.expected = new Int8Array([0, 0, 0, 44, 115, 105, 100, 120, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 95, (144 << 24 >> 24), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 6, (220 << 24 >> 24), 0, 0, 6, (153 << 24 >> 24), 48, (144 << 24 >> 24), 0, 0, 0]);
    prototype.testParse = function() {
        var sidx = SegmentIndexBox.createSegmentIndexBox();
        var input = ByteBuffer.wrap(SegmentIndexBoxTest.expected);
        input.setPosition(8);
        sidx.parse(input);
        Assert.assertEquals(90000, sidx.timescale);
        Assert.assertEquals(1, sidx.reference_count);
        var actual = ByteBuffer.allocate(SegmentIndexBoxTest.expected.length);
        sidx.write(actual);
        Assert.assertArrayEquals(SegmentIndexBoxTest.expected, actual.array());
    };
}, {expected: "Int8Array"}, {});
var SparseIDCTTest = function() {};
SparseIDCTTest = stjs.extend(SparseIDCTTest, null, [], function(constructor, prototype) {
    prototype.testSparseIDCT = function() {
        var count = 0, n = 1000000;
        for (var i = 0; i < 10000; i++) 
            count += this.oneTest();
        System.out.println(stjs.trunc((100 * count) / (64 * n)));
    };
    prototype.oneTest = function() {
        var pixels = new Int32Array(64);
        for (var i = 0; i < 64; i++) {
            pixels[i] = stjs.trunc((Math.random() * 256));
        }
        var dct = Platform.copyOfInt(pixels, 64);
        DCTRef.fdct(dct, 0);
        var refidct = Platform.copyOfInt(dct, 64);
        SimpleIDCT10Bit.idct10(refidct, 0);
        var sparse = new Int32Array(64);
        SparseIDCT.start(sparse, dct[0]);
        for (var i = 1; i < 64; i++) 
            SparseIDCT.coeff(sparse, i, dct[i]);
        SparseIDCT.finish(sparse);
        var max = 0, count = 0;
        for (var i = 0; i < 64; i++) {
            var diff = Math.abs(sparse[i] - refidct[i]);
            if (diff > max) 
                max = diff;
            if (diff != 0) 
                count++;
        }
        Assert.assertTrue(max < 2);
        return count;
    };
}, {}, {});
var SPSReadTest = function() {};
SPSReadTest = stjs.extend(SPSReadTest, null, [], function(constructor, prototype) {
    prototype.sps1 = null;
    prototype.setUp = function() {
        this.sps1 = new SeqParameterSet();
        this.sps1.profile_idc = 66;
        this.sps1.constraint_set_0_flag = false;
        this.sps1.constraint_set_1_flag = false;
        this.sps1.constraint_set_2_flag = false;
        this.sps1.constraint_set_3_flag = false;
        this.sps1.constraint_set_4_flag = false;
        this.sps1.constraint_set_5_flag = false;
        this.sps1.level_idc = 30;
        this.sps1.seq_parameter_set_id = 0;
        this.sps1.log2_max_frame_num_minus4 = 5;
        this.sps1.pic_order_cnt_type = 0;
        this.sps1.log2_max_pic_order_cnt_lsb_minus4 = 6;
        this.sps1.num_ref_frames = 1;
        this.sps1.gaps_in_frame_num_value_allowed_flag = false;
        this.sps1.pic_width_in_mbs_minus1 = 31;
        this.sps1.pic_height_in_map_units_minus1 = 23;
        this.sps1.frame_mbs_only_flag = true;
        this.sps1.direct_8x8_inference_flag = true;
        this.sps1.frame_cropping_flag = false;
        this.sps1.vuiParams = new VUIParameters();
        this.sps1.vuiParams.aspect_ratio_info_present_flag = false;
        this.sps1.vuiParams.overscan_info_present_flag = false;
        this.sps1.vuiParams.video_signal_type_present_flag = false;
        this.sps1.vuiParams.chroma_loc_info_present_flag = false;
        this.sps1.vuiParams.timing_info_present_flag = true;
        this.sps1.vuiParams.num_units_in_tick = 1000;
        this.sps1.vuiParams.time_scale = 50000;
        this.sps1.vuiParams.fixed_frame_rate_flag = true;
        this.sps1.vuiParams.pic_struct_present_flag = false;
        this.sps1.vuiParams.bitstreamRestriction = new VUIParameters.BitstreamRestriction();
        this.sps1.vuiParams.bitstreamRestriction.motion_vectors_over_pic_boundaries_flag = true;
        this.sps1.vuiParams.bitstreamRestriction.max_bytes_per_pic_denom = 0;
        this.sps1.vuiParams.bitstreamRestriction.max_bits_per_mb_denom = 0;
        this.sps1.vuiParams.bitstreamRestriction.log2_max_mv_length_horizontal = 10;
        this.sps1.vuiParams.bitstreamRestriction.log2_max_mv_length_vertical = 10;
        this.sps1.vuiParams.bitstreamRestriction.num_reorder_frames = 0;
        this.sps1.vuiParams.bitstreamRestriction.max_dec_frame_buffering = 1;
    };
    prototype.testRead = function() {
        var path = "src/test/resources/h264/sps/sps1.dat";
        var is = null;
        try {
            var sps = SeqParameterSet.read(NIOUtils.fetchFromFile(new File(path)));
            Assert.assertEquals(sps.profile_idc, 66);
            Assert.assertEquals(sps.constraint_set_0_flag, false);
            Assert.assertEquals(sps.constraint_set_1_flag, false);
            Assert.assertEquals(sps.constraint_set_2_flag, false);
            Assert.assertEquals(sps.constraint_set_3_flag, false);
            Assert.assertEquals(sps.constraint_set_4_flag, false);
            Assert.assertEquals(sps.constraint_set_5_flag, false);
            Assert.assertEquals(sps.level_idc, 30);
            Assert.assertEquals(sps.seq_parameter_set_id, 0);
            Assert.assertEquals(sps.log2_max_frame_num_minus4, 5);
            Assert.assertEquals(sps.pic_order_cnt_type, 0);
            Assert.assertEquals(sps.log2_max_pic_order_cnt_lsb_minus4, 6);
            Assert.assertEquals(sps.num_ref_frames, 1);
            Assert.assertEquals(sps.gaps_in_frame_num_value_allowed_flag, false);
            Assert.assertEquals(sps.pic_width_in_mbs_minus1, 31);
            Assert.assertEquals(sps.pic_height_in_map_units_minus1, 23);
            Assert.assertEquals(sps.frame_mbs_only_flag, true);
            Assert.assertEquals(sps.direct_8x8_inference_flag, true);
            Assert.assertEquals(sps.frame_cropping_flag, false);
            Assert.assertNotNull(sps.vuiParams);
            Assert.assertEquals(sps.vuiParams.aspect_ratio_info_present_flag, false);
            Assert.assertEquals(sps.vuiParams.overscan_info_present_flag, false);
            Assert.assertEquals(sps.vuiParams.video_signal_type_present_flag, false);
            Assert.assertEquals(sps.vuiParams.chroma_loc_info_present_flag, false);
            Assert.assertEquals(sps.vuiParams.timing_info_present_flag, true);
            Assert.assertEquals(sps.vuiParams.num_units_in_tick, 1000);
            Assert.assertEquals(sps.vuiParams.time_scale, 50000);
            Assert.assertEquals(sps.vuiParams.fixed_frame_rate_flag, true);
            Assert.assertNull(sps.vuiParams.nalHRDParams);
            Assert.assertNull(sps.vuiParams.vclHRDParams);
            Assert.assertEquals(sps.vuiParams.pic_struct_present_flag, false);
            Assert.assertNotNull(sps.vuiParams.bitstreamRestriction);
            Assert.assertEquals(sps.vuiParams.bitstreamRestriction.motion_vectors_over_pic_boundaries_flag, true);
            Assert.assertEquals(sps.vuiParams.bitstreamRestriction.max_bytes_per_pic_denom, 0);
            Assert.assertEquals(sps.vuiParams.bitstreamRestriction.max_bits_per_mb_denom, 0);
            Assert.assertEquals(sps.vuiParams.bitstreamRestriction.log2_max_mv_length_horizontal, 10);
            Assert.assertEquals(sps.vuiParams.bitstreamRestriction.log2_max_mv_length_vertical, 10);
            Assert.assertEquals(sps.vuiParams.bitstreamRestriction.num_reorder_frames, 0);
            Assert.assertEquals(sps.vuiParams.bitstreamRestriction.max_dec_frame_buffering, 1);
        } finally {
            IOUtils.closeQuietly(is);
        }
    };
    prototype.testWrite = function() {
        var path = "src/test/resources/h264/sps/sps1.dat";
        var bb = ByteBuffer.allocate(1024);
        this.sps1.write(bb);
        bb.flip();
        var expect = NIOUtils.fetchFromFile(new File(path));
        Assert.assertArrayEquals(NIOUtils.toArray(bb), NIOUtils.toArray(expect));
    };
}, {sps1: "SeqParameterSet"}, {});
var ConformanceTest = function() {};
ConformanceTest = stjs.extend(ConformanceTest, null, [], function(constructor, prototype) {
    prototype.testNoContainer = function() {
        var dir = "src/test/resources/video/seq_h264_4";
        var yuv = "src/test/resources/video/seq_h264_4.yuv";
        var info = Platform.stringFromBytes(this.readFile(dir + "/info.txt").array());
        System.out.println("info " + info);
        var width = Integer.parseInt(info.split(" ")[0]);
        var height = Integer.parseInt(info.split(" ")[1]);
        var frameCount = Integer.parseInt(info.split(" ")[2]);
        var picData = Picture8Bit.create(width, height, ColorSpace.YUV420J).getData();
        var decoder = new H264Decoder();
        decoder.addSps(Collections.singletonList(this.readFile(dir + "/sps")));
        decoder.addPps(Collections.singletonList(this.readFile(dir + "/pps")));
        var rawReader = new RawReader8Bit(new File(yuv), width, height);
        for (var fn = 0; fn < frameCount; fn++) {
            System.out.println("fn " + fn);
            var buf = this.readFile(dir + "/" + this.zeroPad3(fn));
            var pic = decoder.decodeFrame8BitFromNals(this.extractNALUnits(buf), picData);
            var ref = rawReader.readNextFrame();
            Assert.assertTrue("frame=" + fn + " FAILED", ConformanceTest.compare(ref, pic));
        }
    };
    prototype.readFile = function(path) {
        var file = new File(path);
        var _in = new BufferedInputStream(new FileInputStream(file));
        var buf = new Int8Array(((file.length()) | 0));
        _in.read(buf);
        _in.close();
        return ByteBuffer.wrap(buf);
    };
    prototype.zeroPad3 = function(n) {
        var s = n + "";
         while (s.length < 3)
            s = "0" + s;
        return s;
    };
    prototype.extractNALUnits = function(buf) {
        buf = buf.duplicate();
        var nalUnits = new ArrayList();
         while (buf.remaining() > 4){
            var length = buf.getInt();
            var nalUnit = ByteBuffer.allocate(length);
            for (var i = 0; i < length; i++) {
                nalUnit.put(buf.get());
            }
            nalUnit.flip();
            nalUnits.add(nalUnit);
        }
        return nalUnits;
    };
    constructor.compare = function(expected, actual) {
        var size = expected.getWidth() * expected.getHeight();
        var expY = expected.getPlaneData(0);
        var actY = actual.getPlaneData(0);
        for (var i = 0; i < size; i++) {
            if (expY[i] != actY[i]) 
                return false;
        }
        var expCb = expected.getPlaneData(1);
        var actCb = actual.getPlaneData(1);
        for (var i = 0; i < (size >> 2); i++) {
            if (expCb[i] != actCb[i]) 
                return false;
        }
        var expCr = expected.getPlaneData(2);
        var actCr = actual.getPlaneData(2);
        for (var i = 0; i < (size >> 2); i++) {
            if (expCr[i] != actCr[i]) 
                return false;
        }
        return true;
    };
}, {}, {});
/**
 *  A tool to test jcodec for conformance
 *  
 *  @author The JCodec project
 *  
 */
var ConformanceTestTool = function() {};
ConformanceTestTool = stjs.extend(ConformanceTestTool, null, [], function(constructor, prototype) {
    constructor.main1 = function(args) {
        (new ConformanceTestTool()).doIt(args);
    };
    prototype.doIt = function(args) {
        if (args.length < 2) {
            System.out.println("Syntax: conformace <directory> <report.html>");
            return;
        }
        var dir = new File(args[0]);
        var sb = new StringBuilder();
        sb.append("<table>");
        var i = 0;
        var files = dir.listFiles();
        for (var file in files) {
            if (file.isDirectory()) {
                this.processOneDir(file, sb, i);
                i++;
            }
        }
        sb.append("</table>");
        System.out.println("TESTING DONE");
        NIOUtils.writeTo(ByteBuffer.wrap(sb.toString().getBytes()), new File(args[1]));
    };
    prototype.processOneDir = function(file, sb, i) {
        var listFiles = file.listFiles();
        var coded = null, decoded = null;
        for (var file2 in listFiles) {
            if (file2.isDirectory()) 
                return;
            var name = file2.getName();
            if (name.endsWith(".264") || name.endsWith(".h264")) {
                coded = file2;
            } else if (name.endsWith(".yuv") || name.endsWith(".raw")) {
                decoded = file2;
            }
        }
        if (coded == null || decoded == null) {
            System.out.println("No suitable files found for directory: " + file.getName());
            return;
        }
        sb.append("<tr><td>" + (i + 1) + "</td><td><a href=\"http://storage.jcodec.org/h264/baseline/" + file.getName() + ".zip\">" + file.getName() + ".zip</a></td><td>");
        System.out.print("-- " + file.getName());
        this.doOneTest(coded, decoded, sb);
        sb.append("</td><td>&nbsp;</td></tr>");
    };
    prototype.doOneTest = function(coded, decoded, sb) {
        try {
            var rawReader = null;
            var oldWidth = 0, oldHeight = 0;
            var is = null;
            try {
                is = new BufferedInputStream(new FileInputStream(coded));
                var demuxer = new MappedH264ES(NIOUtils.mapFile(coded));
                var decoder = new H264Decoder();
                var buf = Picture8Bit.create(1920, 1088, ColorSpace.YUV420);
                var pic;
                var i = 0;
                 while ((pic = decoder.decodeFrame8Bit(this.reorder(demuxer.nextFrame()), buf.getData())) != null){
                    if (rawReader == null || oldWidth != pic.getWidth() || oldHeight != pic.getHeight()) {
                        rawReader = new RawReader(decoded, pic.getWidth(), pic.getHeight());
                        oldWidth = pic.getWidth();
                        oldHeight = pic.getHeight();
                    }
                    var ref = rawReader.readNextFrame8Bit();
                    if (!ConformanceTestTool.compare(ref, pic)) {
                        System.err.println(" - FAILED (" + i + ")");
                        sb.append("FAILED");
                        return;
                    }
                    i++;
                }
                var ref = rawReader.readNextFrame8Bit();
                if (ref != null) {
                    System.err.println(" - FAILED");
                    sb.append("FAILED");
                } else {
                    System.out.println(" - PASSED");
                    sb.append("<span class=\"passed\">PASSED</span>");
                }
            } finally {
                IOUtils.closeQuietly(is);
            }
        }catch (t) {
            System.err.println(" - FAILED");
            sb.append("FAILED");
            t.printStackTrace();
        }
    };
    prototype.reorder = function(nextFrame) {
         throw new RuntimeException("Display order reordering!!!");
    };
    constructor.compare = function(expected, actual) {
        var size = expected.getWidth() * expected.getHeight();
        var expY = expected.getPlaneData(0);
        var actY = actual.getPlaneData(0);
        for (var i = 0; i < size; i++) {
            if (expY[i] != actY[i]) 
                return false;
        }
        var expCb = expected.getPlaneData(1);
        var actCb = actual.getPlaneData(1);
        for (var i = 0; i < (size >> 2); i++) {
            if (expCb[i] != actCb[i]) 
                return false;
        }
        var expCr = expected.getPlaneData(2);
        var actCr = actual.getPlaneData(2);
        for (var i = 0; i < (size >> 2); i++) {
            if (expCr[i] != actCr[i]) 
                return false;
        }
        return true;
    };
}, {}, {});
var Utils = function() {};
Utils = stjs.extend(Utils, null, [], function(constructor, prototype) {
    constructor.tildeExpand = function(path) {
        if (path.startsWith("~")) {
            path = path.replaceFirst("~", System.getProperty("user.home"));
        }
        return new File(path);
    };
    constructor.printArray = function(array, title) {
        if (title.length > 0) 
            System.out.println(title[0]);
        var max = ArrayUtil.max(array);
        var digits = Math.max(1, stjs.trunc((3 * MathUtil.log2(max)) / 10));
        for (var i = 0; i < array.length; i++) {
            System.out.print(String.format("%0" + digits + "d", array[i]));
            if (i < array.length - 1) 
                System.out.print(",");
        }
        System.out.println();
    };
    constructor.printArrayHex = function(array, title) {
        if (title.length > 0) 
            System.out.println(title[0]);
        var max = ArrayUtil.max(array);
        var digits = Math.max(2, MathUtil.log2(max) >> 2);
        for (var i = 0; i < array.length; i++) {
            System.out.print(String.format("%0" + digits + "x", array[i]));
            if (i < array.length - 1) 
                System.out.print(",");
        }
        System.out.println();
    };
    constructor.printArray2d = function(array, title) {
        if (title.length > 0) 
            System.out.println(title[0]);
        for (var i = 0; i < array.length; i++) {
            Utils.printArray(array[i], Array(0));
        }
        System.out.println();
    };
    constructor.assertArrayEquals = function(is, v) {
        Assert.assertEquals(is.length, v.length);
        for (var i = 0; i < is.length; i++) {
            Assert.assertArrayEquals(is[i], v[i]);
        }
    };
    constructor.compareMP4H264Files = function(file, refFile) {
        var ch1 = null, ch2 = null;
        try {
            ch1 = NIOUtils.readableChannel(file);
            ch2 = NIOUtils.readableChannel(refFile);
            var frameGrab1 = FrameGrab8Bit.createFrameGrab8Bit(ch1);
            var frameGrab2 = FrameGrab8Bit.createFrameGrab8Bit(ch2);
            var fr1, fr2;
            do {
                fr1 = frameGrab1.getNativeFrame();
                fr2 = frameGrab2.getNativeFrame();
                if (fr1 == null || fr2 == null) 
                    break;
                fr1 = fr1.cropped();
                fr2 = fr2.cropped();
                Assert.assertTrue(Utils.picturesRoughlyEqual(fr1, fr2, 20));
            } while (fr1 != null && fr2 != null);
            Assert.assertNull(fr1);
            Assert.assertNull(fr2);
        } finally {
            IOUtils.closeQuietly(ch1);
            IOUtils.closeQuietly(ch2);
        }
    };
    constructor.maxDiff = function(fr1, fr2) {
        if (fr2.getWidth() != fr1.getWidth() || fr2.getHeight() != fr1.getHeight()) 
             throw new IllegalArgumentException("Diffing pictures of different sizes.");
        var maxDiff = 0;
        for (var i = 0; i < fr2.getData().length; i++) {
            var diff = Utils.findMaxDiff(fr2.getPlaneData(i), fr1.getPlaneData(i));
            if (diff > maxDiff) {
                maxDiff = diff;
            }
        }
        return maxDiff;
    };
    constructor.picturesRoughlyEqual = function(fr1, fr2, threshold) {
        if (fr2.getWidth() != fr1.getWidth() || fr2.getHeight() != fr1.getHeight()) 
            return false;
        for (var i = 0; i < fr2.getData().length; i++) {
            var maxDiff = Utils.findMaxDiff(fr2.getPlaneData(i), fr1.getPlaneData(i));
            if (maxDiff > 0) {
                jcodec.Logger.warn("Max diff: " + maxDiff);
            }
            if (maxDiff > threshold) {
                return false;
            }
        }
        return true;
    };
    constructor.findMaxDiff = function(rand, newRand) {
        var maxDiff = 0;
        for (var i = 0; i < rand.length; i++) {
            var diff = Math.abs(rand[i] - newRand[i]);
            if (diff > maxDiff) 
                maxDiff = diff;
        }
        return maxDiff;
    };
    constructor.readYuvFrame = function(ch, width, height) {
        var result = Picture8Bit.create(width, height, ColorSpace.YUV420J);
        for (var i = 0; i < result.getData().length; i++) {
            var planeData = result.getPlaneData(i);
            if (ch.read(ByteBuffer.wrap(planeData)) != result.getPlaneData(i).length) {
                 throw new EOFException();
            }
            for (var j = 0; j < planeData.length; j++) {
                planeData[j] = (((planeData[j] & 255) - 128) << 24 >> 24);
            }
        }
        return result;
    };
    constructor.saveImage = function(fr2, formatName, name) {
        ImageIO.write(AWTUtil.toBufferedImage8Bit(fr2), formatName, new File(name));
    };
    constructor.diff = function(one, two, mul) {
        var result = Picture8Bit.create(one.getWidth(), one.getHeight(), one.getColor());
        var dataO = one.getData();
        var dataT = two.getData();
        var dataR = result.getData();
        Arrays.fill(dataR[1], (64 << 24 >> 24));
        for (var i = 0; i < dataO[0].length; i++) {
            dataR[0][i] = ((MathUtil.clipMax(MathUtil.abs(dataO[0][i] - dataT[0][i]) * mul, 255) - 128) << 24 >> 24);
        }
        return result;
    };
}, {}, {});
var DCTTest = function() {};
DCTTest = stjs.extend(DCTTest, null, [], function(constructor, prototype) {
    prototype.testDCT = function() {
        var input = new Int32Array([-36, -37, -39, -42, -37, -38, -40, -42, -39, -39, -39, -40, -39, -41, -40, -35]);
        var out = VP8DCT.encodeDCT(input);
        System.out.println("dct encoded: ");
        System.out.println(DCTTest.formatAsSquare(out));
        out = VP8EncoderTest.LinearAlgebraUtil.divideByScalar(out, 4);
        System.out.println("quantized: ");
        System.out.println(DCTTest.formatAsSquare(out));
        out = VP8EncoderTest.LinearAlgebraUtil.multiplyByScalar(out, 4);
        System.out.println("dequantized: ");
        System.out.println(DCTTest.formatAsSquare(out));
        var restored = VP8DCT.decodeDCT(out);
        System.out.println("restored: ");
        System.out.println(DCTTest.formatAsSquare(restored));
        System.out.println("error: ");
        System.out.println(DCTTest.formatAsSquare(VP8EncoderTest.LinearAlgebraUtil.substractVector(input, restored)));
    };
    prototype.testWHT = function() {
        var input = new Int32Array([-312, -333, -269, -242, -289, -287, -322, -239, -330, -334, -332, -329, -347, -339, -273, -312]);
        var out = VP8DCT.encodeWHT(input);
        System.out.println("wht encoded: ");
        System.out.println(DCTTest.formatAsSquare(out));
        out = VP8EncoderTest.LinearAlgebraUtil.divideByScalar(out, 4);
        System.out.println("quantized: ");
        System.out.println(DCTTest.formatAsSquare(out));
        out = VP8EncoderTest.LinearAlgebraUtil.multiplyByScalar(out, 4);
        System.out.println("dequantized: ");
        System.out.println(DCTTest.formatAsSquare(out));
        var restored = VP8DCT.decodeWHT(out);
        System.out.println("restored: ");
        System.out.println(DCTTest.formatAsSquare(restored));
        System.out.println("error: ");
        System.out.println(DCTTest.formatAsSquare(VP8EncoderTest.LinearAlgebraUtil.substractVector(input, restored)));
    };
    constructor.formatAsSquare = function(a) {
        var size = (a.length == 4) ? 2 : (a.length == 16) ? 4 : (a.length == 64) ? 8 : 0;
        var str = "";
        for (var i = 0; i < a.length; i++) {
            str += String.valueOf(a[i]);
            str += (((i + 1) % size) == 0) ? "\n" : "\t";
        }
        return str;
    };
}, {}, {});
var BooleanCodingTest = function() {};
BooleanCodingTest = stjs.extend(BooleanCodingTest, null, [], function(constructor, prototype) {
    prototype.testLeadingZero = function() {
        Assert.assertEquals(7, BooleanArithmeticDecoder.leadingZeroCountInByte((1 << 24 >> 24)));
        Assert.assertEquals(0, BooleanArithmeticDecoder.leadingZeroCountInByte((129 << 24 >> 24)));
        Assert.assertEquals(0, BooleanArithmeticDecoder.leadingZeroCountInByte((256 << 24 >> 24)));
        Assert.assertEquals(7, BooleanArithmeticDecoder.leadingZeroCountInByte((257 << 24 >> 24)));
        Assert.assertEquals(1, BooleanArithmeticDecoder.leadingZeroCountInByte((383 << 24 >> 24)));
    };
    prototype.testBitInByte = function() {
        Assert.assertEquals(1, BooleanArithmeticDecoder.getBitInBytes(new Int8Array([(128 << 24 >> 24)]), 0));
        Assert.assertEquals(0, BooleanArithmeticDecoder.getBitInBytes(new Int8Array([(128 << 24 >> 24)]), 1));
        Assert.assertEquals(1, BooleanArithmeticDecoder.getBitInBytes(new Int8Array([(144 << 24 >> 24)]), 3));
        Assert.assertEquals(1, BooleanArithmeticDecoder.getBitInBytes(new Int8Array([(145 << 24 >> 24)]), 7));
        Assert.assertEquals(1, BooleanArithmeticDecoder.getBitInBytes(new Int8Array([0, (145 << 24 >> 24)]), 15));
    };
    prototype.test = function() {
        var b = IOUtils.toByteArray(new FileInputStream(new File("src/test/resources/part1.vp8.mb")));
        var bac = new BooleanArithmeticDecoder(ByteBuffer.wrap(b), 0);
        Assert.assertEquals("clear type is expected to be 0", 0, bac.decodeBit());
        Assert.assertEquals("clamp type is expected to be 0", 0, bac.decodeBit());
        Assert.assertEquals("segmentation is expected to be disabled", 0, bac.decodeBit());
        Assert.assertEquals("simple filter disabled", 0, bac.decodeBit());
        Assert.assertEquals("filter level is 8", 8, bac.decodeInt(6));
        Assert.assertEquals("sharpness level is 0", 0, bac.decodeInt(3));
        Assert.assertEquals(1, bac.decodeBit());
    };
    constructor.BooleanArithmeticEncoder = function(output) {
        this.output = output;
        this.range = 255;
        this.bottom = 0;
        this.bitCount = 24;
    };
    constructor.BooleanArithmeticEncoder = stjs.extend(constructor.BooleanArithmeticEncoder, null, [], function(constructor, prototype) {
        prototype.output = null;
        prototype.range = 0;
        prototype.bottom = 0;
        prototype.bitCount = 0;
        /**
         *  copy-paste from http://tools.ietf.org/html/rfc6386
         *  @param probability
         *  @param value
         */
        prototype.encode = function(probability, value) {
            var split = 1 + (((this.range - 1) * probability) >> 8);
            if (value != 0) {
                this.bottom += split;
                this.range -= split;
            } else 
                this.range = split;
             while (this.range < 128){
                this.range <<= 1;
                if ((this.bottom & (1 << 31)) != 0) 
                    BooleanCodingTest.BooleanArithmeticEncoder.add_one_to_output(this.output);
                this.bottom <<= 1;
                --this.bitCount;
                if (this.bitCount == 0) {
                    this.output.put(((this.bottom >> 24) << 24 >> 24));
                    this.bottom &= (1 << 24) - 1;
                    this.bitCount = 8;
                }
            }
        };
        prototype.flushRemaining = function() {
            var c = this.bitCount;
            var v = this.bottom;
            if ((v & (1 << (32 - c))) != 0) 
                BooleanCodingTest.BooleanArithmeticEncoder.add_one_to_output(this.output);
            v <<= c & 7;
            c >>= 3;
             while (--c >= 0)
                v <<= 8;
            c = 4;
             while (--c >= 0){
                this.output.put(((v >>> 24) << 24 >> 24));
                v <<= 8;
            }
        };
        constructor.add_one_to_output = function(buffer) {
            var ar = buffer.array();
            var idx = buffer.position();
             while (idx > 0 && (ar[--idx] == (255 << 24 >> 24))){
                ar[idx] = 0;
            }
            ar[idx]++;
        };
    }, {output: "ByteBuffer"}, {});
    prototype.testAdd = function() {
        var bb = ByteBuffer.allocate(128);
        bb.put((24 << 24 >> 24));
        bb.put((255 << 24 >> 24));
        BooleanCodingTest.BooleanArithmeticEncoder.add_one_to_output(bb);
        Assert.assertEquals(2, bb.position());
        Assert.assertEquals((0 << 24 >> 24), bb.getAt(bb.position() - 1));
        Assert.assertEquals((25 << 24 >> 24), bb.getAt(bb.position() - 2));
    };
    prototype.testOut = function() {
        var bb = ByteBuffer.allocate(128);
        bb.put((24 << 24 >> 24));
        bb.put((255 << 24 >> 24));
        Assert.assertEquals(2, bb.position());
        Assert.assertEquals((255 << 24 >> 24), bb.getAt(bb.position() - 1));
        Assert.assertEquals((24 << 24 >> 24), bb.getAt(bb.position() - 2));
    };
    prototype.testDecodeEncodedSequence = function() {
        var bae = new BooleanCodingTest.BooleanArithmeticEncoder(ByteBuffer.allocate(16));
        var probability = 155;
        var data = new Int32Array([1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1]);
        for (var d in data) 
            bae.encode(probability, d);
        bae.flushRemaining();
        var array = bae.output.array();
        System.out.println(ArithmeticCoderTest.printArrayAsHex(array));
        var bac = new BooleanArithmeticDecoder(ByteBuffer.wrap(array), 0);
        for (var d in data) 
            Assert.assertTrue(d == bac.decodeBool(probability));
    };
}, {}, {});
var MP4UtilTest = function() {};
MP4UtilTest = stjs.extend(MP4UtilTest, null, [], function(constructor, prototype) {
    prototype.testSimple = function() {
        var f = new File("./src/test/resources/video/seq_h264_1.mp4");
        var moov = MP4Util.parseMovie(f);
        Assert.assertNotNull(moov);
        Assert.assertNotNull(moov.getVideoTrack());
        Assert.assertNotNull(moov.getAudioTracks().get(0));
        var sampleEntries = moov.getVideoTrack().getSampleEntries();
        var vse = sampleEntries[0];
        Assert.assertNotNull(vse);
        var avcc = vse.getBoxes().get(0);
        Assert.assertNotNull(avcc);
        System.out.println(sampleEntries);
        var box = moov.getAudioTracks().get(0).getSampleEntries()[0].getBoxes().get(0);
        Assert.assertEquals("esds", box.getFourcc());
        System.out.println(box);
    };
    prototype.testName = function() {
        var f = new File("src/test/resources/zhuker/1D158634-69DF-4C7F-AB6F-CCC83F04FEDB/1.mp4");
        var moov = MP4Util.parseMovie(f);
        var minf = moov.getVideoTrack().getMdia().getMinf();
        var avcCBox = NodeBox.findFirstPath(minf, AvcCBox, Box.path("stbl.stsd.avc1.avcC"));
        var size = avcCBox.getHeader().getSize();
        var buf = ByteBuffer.allocate(128);
        avcCBox.write(buf);
        buf.flip();
        System.out.println(HexDump.hexdump0(buf));
        Assert.assertEquals(size, buf.remaining());
    };
    prototype.testReadWriteIphoneMp4 = function() {
        var f = new File("src/test/resources/zhuker/1D158634-69DF-4C7F-AB6F-CCC83F04FEDB/1.mp4");
        var read = ByteBuffer.allocate(64 * 1024);
        MP4Util.parseMovie(f).write(read);
        read.flip();
        var atom = MP4Util.findFirstAtom("moov", new AutoFileChannelWrapper(f));
        var written = NIOUtils.mapFile(f);
        written.setPosition(((atom.getOffset()) | 0));
        written.setLimit((((written.position() + atom.getHeader().getSize())) | 0));
        var equals = read.equals(written);
        if (!equals) {}
        Assert.assertTrue(equals);
    };
}, {}, {});
var CABACTest = function() {};
CABACTest = stjs.extend(CABACTest, null, [], function(constructor, prototype) {
    prototype.testMBTypeI = function() {
        var m = new MockMDecoder(new Int32Array([0]), new Int32Array([3]));
        Assert.assertEquals(0, new CABAC(1).readMBTypeI(m, null, null, false, false));
        var e = new MockMEncoder(new Int32Array([0]), new Int32Array([3]));
        new CABAC(1).writeMBTypeI(e, null, null, false, false, 0);
        m = new MockMDecoder(new Int32Array([1, 1]), new Int32Array([3, -2]));
        Assert.assertEquals(25, new CABAC(1).readMBTypeI(m, null, null, false, false));
        e = new MockMEncoder(new Int32Array([1, 1]), new Int32Array([3, -2]));
        new CABAC(1).writeMBTypeI(e, null, null, false, false, 25);
        m = new MockMDecoder(new Int32Array([0]), new Int32Array([4]));
        Assert.assertEquals(0, new CABAC(1).readMBTypeI(m, MBType.I_16x16, null, true, false));
        m = new MockMDecoder(new Int32Array([0]), new Int32Array([4]));
        Assert.assertEquals(0, new CABAC(1).readMBTypeI(m, null, MBType.I_16x16, false, true));
        m = new MockMDecoder(new Int32Array([0]), new Int32Array([5]));
        Assert.assertEquals(0, new CABAC(1).readMBTypeI(m, MBType.I_16x16, MBType.I_16x16, true, true));
        m = new MockMDecoder(new Int32Array([1, 0, 0, 1, 1, 1, 0]), new Int32Array([3, -2, 6, 7, 8, 9, 10]));
        Assert.assertEquals(11, new CABAC(1).readMBTypeI(m, null, null, false, false));
        e = new MockMEncoder(new Int32Array([1, 0, 0, 1, 1, 1, 0]), new Int32Array([3, -2, 6, 7, 8, 9, 10]));
        new CABAC(1).writeMBTypeI(e, null, null, false, false, 11);
    };
    prototype.testMBTypeP = function() {
        var cabac = new CABAC(2);
        var m = new MockMDecoder(new Int32Array([0, 0, 1]), new Int32Array([14, 15, 16]));
        Assert.assertEquals(3, cabac.readMBTypeP(m));
    };
    prototype.testReadIntraChromaPredMode = function() {
        var m = new MockMDecoder(new Int32Array([0]), new Int32Array([64]));
        Assert.assertEquals(0, new CABAC(1).readIntraChromaPredMode(m, 0, null, null, false, false));
        var e = new MockMEncoder(new Int32Array([0]), new Int32Array([64]));
        new CABAC(1).writeIntraChromaPredMode(e, 0, null, null, false, false, 0);
        m = new MockMDecoder(new Int32Array([1, 1, 1]), new Int32Array([64, 67, 67]));
        Assert.assertEquals(3, new CABAC(1).readIntraChromaPredMode(m, 0, null, null, false, false));
        e = new MockMEncoder(new Int32Array([1, 1, 1]), new Int32Array([64, 67, 67]));
        new CABAC(1).writeIntraChromaPredMode(e, 0, null, null, false, false, 3);
    };
    prototype.testMBQpDelta = function() {
        var m = new MockMDecoder(new Int32Array([0]), new Int32Array([60]));
        Assert.assertEquals(0, new CABAC(1).readMBQpDelta(m, null));
        m = new MockMDecoder(new Int32Array([1, 1, 1, 1, 1, 1, 0]), new Int32Array([60, 62, 63, 63, 63, 63, 63]));
        Assert.assertEquals(6, new CABAC(1).readMBQpDelta(m, null));
        var e = new MockMEncoder(new Int32Array([0]), new Int32Array([60]));
        new CABAC(1).writeMBQpDelta(e, null, 0);
        e = new MockMEncoder(new Int32Array([1, 1, 1, 1, 1, 1, 0]), new Int32Array([60, 62, 63, 63, 63, 63, 63]));
        new CABAC(1).writeMBQpDelta(e, null, 6);
    };
    prototype.testRefIdx = function() {
        var m = new MockMDecoder(new Int32Array([0]), new Int32Array([54]));
        Assert.assertEquals(0, new CABAC(40).readRefIdx(m, true, false, null, null, H264Const.PartPred.L0, H264Const.PartPred.L0, H264Const.PartPred.L0, 17, 0, 0, 4, 4, 0));
        m = new MockMDecoder(new Int32Array([1, 0]), new Int32Array([54, 58]));
        Assert.assertEquals(1, new CABAC(40).readRefIdx(m, true, true, MBType.P_16x16, MBType.P_16x16, H264Const.PartPred.L0, H264Const.PartPred.L0, H264Const.PartPred.L0, 23, 0, 0, 4, 2, 0));
        m = new MockMDecoder(new Int32Array([1, 0, 1, 0]), new Int32Array([54, 58, 55, 58]));
        var cabac = new CABAC(40);
        Assert.assertEquals(1, cabac.readRefIdx(m, true, false, MBType.P_16x16, null, H264Const.PartPred.L0, H264Const.PartPred.L0, H264Const.PartPred.L0, 21, 0, 0, 2, 4, 0));
        Assert.assertEquals(1, cabac.readRefIdx(m, true, false, MBType.P_8x16, null, H264Const.PartPred.L0, H264Const.PartPred.L0, H264Const.PartPred.L0, 21, 2, 0, 2, 4, 0));
    };
    prototype.testMVD = function() {
        var m = new MockMDecoder(new Int32Array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0]), new Int32Array([40, 43, 44, 45, 46, 46, 46, 46, 46, -1, -1, -1, -1, -1, -1, -1]));
        var cabac = new CABAC(2);
        Assert.assertEquals(28, cabac.readMVD(m, 0, false, false, null, null, H264Const.PartPred.L0, H264Const.PartPred.L0, H264Const.PartPred.L0, 0, 0, 0, 2, 1, 0));
        m = new MockMDecoder(new Int32Array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0]), new Int32Array([47, 50, 51, 52, 53, 53, 53, 53, 53, -1, -1, -1, -1, -1, -1, -1, -1, -1]));
        Assert.assertEquals(64, cabac.readMVD(m, 1, false, false, null, null, H264Const.PartPred.L0, H264Const.PartPred.L0, H264Const.PartPred.L0, 0, 0, 0, 2, 1, 0));
        m = new MockMDecoder(new Int32Array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0]), new Int32Array([41, 43, 44, 45, 46, 46, 46, 46, 46, -1, -1, -1, -1, -1, -1, -1, -1, -1]));
        Assert.assertEquals(40, cabac.readMVD(m, 0, false, true, null, MBType.P_8x8, H264Const.PartPred.L0, H264Const.PartPred.L0, H264Const.PartPred.L0, 0, 0, 1, 2, 1, 0));
        m = new MockMDecoder(new Int32Array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1]), new Int32Array([49, 50, 51, 52, 53, 53, 53, 53, 53, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]));
        Assert.assertEquals(-89, cabac.readMVD(m, 1, false, true, null, MBType.P_8x8, H264Const.PartPred.L0, H264Const.PartPred.L0, H264Const.PartPred.L0, 0, 0, 1, 2, 1, 0));
        m = new MockMDecoder(new Int32Array([1, 1, 1, 1, 0, 0]), new Int32Array([41, 43, 44, 45, 46, -1]));
        Assert.assertEquals(4, cabac.readMVD(m, 0, true, false, MBType.P_8x8, null, H264Const.PartPred.L0, H264Const.PartPred.L0, H264Const.PartPred.L0, 0, 2, 0, 1, 2, 0));
        m = new MockMDecoder(new Int32Array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1]), new Int32Array([49, 50, 51, 52, 53, 53, 53, 53, 53, -1, -1, -1, -1, -1, -1, -1, -1, -1]));
        Assert.assertEquals(-40, cabac.readMVD(m, 1, true, false, MBType.P_8x8, null, H264Const.PartPred.L0, H264Const.PartPred.L0, H264Const.PartPred.L0, 0, 2, 0, 1, 2, 0));
        m = new MockMDecoder(new Int32Array([1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0]), new Int32Array([41, 43, 44, 45, 46, 46, 46, 46, 46, -1, -1, -1, -1, -1]));
        Assert.assertEquals(16, cabac.readMVD(m, 0, true, false, MBType.P_8x8, null, H264Const.PartPred.L0, H264Const.PartPred.L0, H264Const.PartPred.L0, 0, 3, 0, 1, 2, 0));
        m = new MockMDecoder(new Int32Array([0]), new Int32Array([49]));
        Assert.assertEquals(0, cabac.readMVD(m, 1, true, false, MBType.P_8x8, null, H264Const.PartPred.L0, H264Const.PartPred.L0, H264Const.PartPred.L0, 0, 3, 0, 1, 2, 0));
        m = new MockMDecoder(new Int32Array([0]), new Int32Array([42]));
        Assert.assertEquals(0, cabac.readMVD(m, 0, false, true, null, MBType.P_8x8, H264Const.PartPred.L0, H264Const.PartPred.L0, H264Const.PartPred.L0, 0, 0, 2, 2, 2, 0));
        m = new MockMDecoder(new Int32Array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0]), new Int32Array([49, 50, 51, 52, 53, 53, 53, 53, 53, -1, -1, -1, -1, -1, -1, -1, -1, -1]));
        Assert.assertEquals(64, cabac.readMVD(m, 1, false, true, null, MBType.P_8x8, H264Const.PartPred.L0, H264Const.PartPred.L0, H264Const.PartPred.L0, 0, 0, 2, 2, 2, 0));
        m = new MockMDecoder(new Int32Array([0]), new Int32Array([41]));
        Assert.assertEquals(0, cabac.readMVD(m, 0, true, true, MBType.P_8x8, MBType.P_8x8, H264Const.PartPred.L0, H264Const.PartPred.L0, H264Const.PartPred.L0, 0, 2, 2, 2, 2, 0));
        m = new MockMDecoder(new Int32Array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0]), new Int32Array([49, 50, 51, 52, 53, 53, 53, 53, 53, -1, -1, -1, -1, -1, -1, -1, -1, -1]));
        Assert.assertEquals(40, cabac.readMVD(m, 1, true, true, MBType.P_8x8, MBType.P_8x8, H264Const.PartPred.L0, H264Const.PartPred.L0, H264Const.PartPred.L0, 0, 2, 2, 2, 2, 0));
    };
    prototype.testMBSkipFlag = function() {
        var cabac = new CABAC(2);
        var m = new MockMDecoder(new Int32Array([0]), new Int32Array([11]));
        Assert.assertEquals(false, cabac.readMBSkipFlag(m, SliceType.P, false, false, 0));
        m = new MockMDecoder(new Int32Array([0]), new Int32Array([12]));
        Assert.assertEquals(false, cabac.readMBSkipFlag(m, SliceType.P, true, false, 1));
        m = new MockMDecoder(new Int32Array([0]), new Int32Array([12]));
        Assert.assertEquals(false, cabac.readMBSkipFlag(m, SliceType.P, false, true, 0));
        m = new MockMDecoder(new Int32Array([0]), new Int32Array([13]));
        Assert.assertEquals(false, cabac.readMBSkipFlag(m, SliceType.P, true, true, 1));
    };
    prototype.testSubMbType = function() {
        var m = new MockMDecoder(new Int32Array([0, 0]), new Int32Array([21, 22]));
        Assert.assertEquals(1, new CABAC(1).readSubMbTypeP(m));
        m = new MockMDecoder(new Int32Array([0, 1, 1]), new Int32Array([21, 22, 23]));
        Assert.assertEquals(2, new CABAC(1).readSubMbTypeP(m));
        m = new MockMDecoder(new Int32Array([1]), new Int32Array([21]));
        Assert.assertEquals(0, new CABAC(1).readSubMbTypeP(m));
    };
}, {}, {});
var ResidualBlockTest = function() {};
ResidualBlockTest = stjs.extend(ResidualBlockTest, null, [], function(constructor, prototype) {
    prototype.testLuma1CAVLC = function() {
        var code = "0000100 01110010111101101";
        var coeffs = new Int32Array([0, 3, 0, 1, -1, -1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]);
        this.testResidualCAVLC(code, H264Const.CoeffToken[0], coeffs);
    };
    prototype.testLuma2CAVLC = function() {
        var code = "0000000110 10001001000010111001100";
        var coeffs = new Int32Array([-2, 4, 3, -3, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
        this.testResidualCAVLC(code, H264Const.CoeffToken[0], coeffs);
    };
    prototype.testLuma3CAVLC = function() {
        var code = "00011 10001110010";
        var coeffs = new Int32Array([0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0]);
        this.testResidualCAVLC(code, H264Const.CoeffToken[0], coeffs);
    };
    prototype.testChromaAC3CAVLC = function() {
        var code = "000000100 000 1 010 0011 10 101 00";
        var coeffs = new Int32Array([1, -3, 2, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0]);
        this.testResidualCAVLC(code, H264Const.CoeffToken[0], coeffs);
    };
    prototype.zigzag = function(src, tab) {
        var result = new Int32Array(src.length);
        for (var i = 0; i < src.length; i++) 
            result[tab[i]] = src[i];
        return result;
    };
    prototype.testResidualCAVLC = function(code, coeffTokenTab, expected) {
        var reader = BitReader.createBitReader(ByteBuffer.wrap(BinUtil.binaryStringToBytes(code)));
        var cavlc = new CAVLC(new SeqParameterSet(), new PictureParameterSet(), 4, 4);
        var actual = new Int32Array(expected.length);
        cavlc.readCoeffs(reader, coeffTokenTab, H264Const.totalZeros16, actual, 0, 16, CoeffTransformer.zigzag4x4);
        Assert.assertArrayEquals(this.zigzag(expected, CoeffTransformer.zigzag4x4), actual);
    };
    prototype.testLumaCABAC = function() {
        var bits = new Int32Array([1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1]);
        var m = new Int32Array([134, 195, 135, 196, 136, 197, 137, 198, 138, 199, 139, 200, 140, 201, 141, 202, 142, 203, 143, 144, 145, 206, 146, 207, 248, -1, 249, -1, 250, -1, 251, -1, 251, 252, -1, 247, 253, 253, -1, 247, 254, -1, 247, -1, 247, -1, 247, 255, 255, 255, -1, 247, 256, -1]);
        var coeffs = new Int32Array([-2, -1, 1, 0, 4, 2, -1, 0, -3, -1, 1, 0, 2, 1, 0, 0]);
        var actual = new Int32Array(16);
        var decoder = new MockMDecoder(bits, m);
        new CABAC(1).readCoeffs(decoder, CABAC.BlockType.LUMA_16, actual, 0, 16, new Int32Array([0, 4, 1, 2, 5, 8, 12, 9, 6, 3, 7, 10, 13, 14, 11, 15]), H264Const.identityMapping16, H264Const.identityMapping16);
        Assert.assertArrayEquals(coeffs, actual);
        var encoder = new MockMEncoder(bits, m);
        new CABAC(1).writeCoeffs(encoder, CABAC.BlockType.LUMA_16, actual, 0, 16, new Int32Array([0, 4, 1, 2, 5, 8, 12, 9, 6, 3, 7, 10, 13, 14, 11, 15]));
    };
    prototype.testChromaDCCABAC = function() {
        var bits = new Int32Array([1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1]);
        var m = new Int32Array([149, 210, 150, 211, 151, 212, 258, 262, 262, -1, 257, 263, 263, 263, 263, 263, 263, -1, 257, 264, -1, 257, 265, 265, 265, 265, -1]);
        var coeffs = new Int32Array([-5, 2, 7, -3]);
        var actual = new Int32Array(4);
        var decoder = new MockMDecoder(bits, m);
        new CABAC(1).readCoeffs(decoder, CABAC.BlockType.CHROMA_DC, actual, 0, 4, new Int32Array([0, 1, 2, 3]), H264Const.identityMapping16, H264Const.identityMapping16);
        Assert.assertArrayEquals(coeffs, actual);
        var encoder = new MockMEncoder(bits, m);
        new CABAC(1).writeCoeffs(encoder, CABAC.BlockType.CHROMA_DC, actual, 0, 4, new Int32Array([0, 1, 2, 3]));
    };
    prototype.testAC15CABAC = function() {
        var bits = new Int32Array([1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0]);
        var m = new Int32Array([152, 213, 153, 154, 155, 216, 156, 157, 158, 219, 159, 220, 160, 161, 162, 223, 163, 224, 164, 225, 267, -1, 268, -1, 269, -1, 270, -1, 270, -1, 270, -1, 270, -1]);
        var coeffs = new Int32Array([0, 0, 0, 0, 1, -1, 1, 0, 0, -1, 1, 0, 0, -1, -1, 0]);
        var actual = new Int32Array(16);
        var decoder = new MockMDecoder(bits, m);
        new CABAC(1).readCoeffs(decoder, CABAC.BlockType.CHROMA_AC, actual, 1, 15, new Int32Array([0, 4, 1, 2, 5, 8, 12, 9, 6, 3, 7, 10, 13, 14, 11, 15]), H264Const.identityMapping16, H264Const.identityMapping16);
        Assert.assertArrayEquals(coeffs, actual);
        var encoder = new MockMEncoder(bits, m);
        new CABAC(1).writeCoeffs(encoder, CABAC.BlockType.CHROMA_AC, actual, 1, 15, new Int32Array([0, 4, 1, 2, 5, 8, 12, 9, 6, 3, 7, 10, 13, 14, 11, 15]));
    };
    prototype.testLumaDCCabac = function() {
        var coeffs = new Int32Array([46, -10, -5, -27, -18, -4, 7, 9, 19, -3, -37, 14, -17, -15, -43, -28]);
        var bits = new Int32Array([1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]);
        var m = new Int32Array([105, 166, 106, 167, 107, 168, 108, 169, 109, 170, 110, 171, 111, 172, 112, 173, 113, 174, 114, 175, 115, 176, 116, 177, 117, 178, 118, 179, 119, 180, 228, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, -1, -1, -1, -1, -1, -1, -1, -1, 227, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, -1, 227, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 227, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, -1, -1, 227, 236, 236, 236, 236, 236, 236, 236, 236, 236, 236, 236, 236, 236, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 227, 236, 236, 236, 236, 236, 236, 236, 236, -1, 227, 236, 236, 236, 236, 236, 236, 236, 236, 236, 236, 236, 236, 236, -1, -1, -1, -1, -1, -1, -1, -1, 227, 236, 236, 236, 236, 236, 236, -1, 227, 236, 236, -1, 227, 236, 236, 236, 236, 236, 236, 236, 236, 236, 236, 236, 236, 236, -1, -1, -1, -1, 227, 236, 236, 236, 236, 236, 236, 236, 236, 236, 236, 236, 236, 236, -1, -1, -1, -1, -1, -1, 227, 236, 236, 236, -1, 227, 236, 236, 236, 236, -1, 227, 236, 236, 236, 236, 236, 236, 236, 236, 236, -1, 227, 236, 236, 236, 236, 236, 236, 236, 236, 236, 236, 236, 236, 236, -1, -1, -1, -1, -1, -1, 227, 236, 236, 236, 236, 236, 236, 236, 236, 236, 236, 236, 236, 236, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]);
        var actual = new Int32Array(16);
        var decoder = new MockMDecoder(bits, m);
        new CABAC(1).readCoeffs(decoder, CABAC.BlockType.LUMA_16_DC, actual, 0, 16, new Int32Array([0, 4, 1, 2, 5, 8, 12, 9, 6, 3, 7, 10, 13, 14, 11, 15]), H264Const.identityMapping16, H264Const.identityMapping16);
        Assert.assertArrayEquals(coeffs, actual);
        var encoder = new MockMEncoder(bits, m);
        new CABAC(1).writeCoeffs(encoder, CABAC.BlockType.LUMA_16_DC, actual, 0, 16, new Int32Array([0, 4, 1, 2, 5, 8, 12, 9, 6, 3, 7, 10, 13, 14, 11, 15]));
    };
}, {}, {});
var FrameUtil = function() {};
FrameUtil = stjs.extend(FrameUtil, null, [], function(constructor, prototype) {
    constructor.displayComponent = function(component, width, height, decorate) {
        var widthInBlks = width >> 2;
        var heightInBlks = height >> 2;
        var stride = width;
        for (var blkY = 0; blkY < heightInBlks; blkY++) {
            if (decorate) {
                if (blkY % 4 == 0) {
                    for (var i = 0; i < stride; i++) {
                        System.out.print("====");
                    }
                    System.out.print("=========================");
                } else {
                    for (var i = 0; i < stride; i++) {
                        System.out.print("----");
                    }
                    System.out.print("-------------------------");
                }
            }
            System.out.println();
            for (var j = 0; j < 4; j++) {
                for (var blkX = 0; blkX < widthInBlks; blkX++) {
                    for (var i = 0; i < 4; i++) {
                        var offset = ((blkY << 2) + j) * stride + ((blkX << 2) + i);
                        if (decorate) 
                            System.out.printf("%3d ", component[offset] + 128);
                         else 
                            System.out.printf("%3d, ", component[offset] + 128);
                    }
                    if (decorate) {
                        if (blkX % 4 == 0) 
                            System.out.print(" || ");
                         else 
                            System.out.print(" | ");
                    }
                }
                System.out.println();
            }
        }
    };
    constructor.main1 = function(args) {
        var is = null;
        try {
            is = new FileInputStream(args[0]);
            var pgm = PGMIO.readPGM(is);
            FrameUtil.displayComponent(pgm.getPlaneData(0), pgm.getWidth(), pgm.getHeight(), false);
        }catch (e) {
            e.printStackTrace();
        } finally {
            IOUtils.closeQuietly(is);
        }
    };
}, {}, {});
var MBDeblockerTest = function() {};
MBDeblockerTest = stjs.extend(MBDeblockerTest, null, [], function(constructor, prototype) {
    prototype.testCalcStrength = function() {
        var left = new EncodedMB();
        var top = new EncodedMB();
        var cur = new EncodedMB();
        var v = Array.apply(null, Array(4)).map(function() {
            return new Int32Array(4);
        });
        var h = Array.apply(null, Array(4)).map(function() {
            return new Int32Array(4);
        });
        top.getMx()[12] = 4;
        cur.getMx()[2] = -2;
        top.getMx()[14] = 2;
        cur.getMy()[1] = -1;
        top.getMy()[13] = 2;
        top.getNc()[15] = 1;
        cur.getNc()[4] = 1;
        cur.getMx()[6] = 2;
        cur.getMx()[10] = -2;
        cur.getMx()[11] = 2;
        cur.getMx()[14] = 2;
        left.setType(MBType.I_16x16);
        MBDeblocker.calcStrengthForBlocks(cur, left, v, MBDeblocker.LOOKUP_IDX_P_V, MBDeblocker.LOOKUP_IDX_Q_V);
        top.setType(MBType.P_16x16);
        MBDeblocker.calcStrengthForBlocks(cur, top, h, MBDeblocker.LOOKUP_IDX_P_H, MBDeblocker.LOOKUP_IDX_Q_H);
        Utils.assertArrayEquals([new Int32Array([4, 0, 0, 0]), new Int32Array([4, 2, 0, 0]), new Int32Array([4, 0, 0, 1]), new Int32Array([4, 0, 0, 0])], ArrayUtil.rotate(v));
        Utils.assertArrayEquals([new Int32Array([1, 0, 1, 2]), new Int32Array([2, 0, 1, 0]), new Int32Array([2, 0, 1, 0]), new Int32Array([0, 0, 1, 0])], h);
    };
    prototype.testMBlockGeneric = function() {
        var cur = new EncodedMB(), left = new EncodedMB(), top = new EncodedMB();
        var actions = new ArrayList();
        var deblocker = new (stjs.extend(function MBDeblockerTest$1() {
            MBDeblocker.call(this);
        }, MBDeblocker, [], function(constructor, prototype) {
            prototype.filterBs4 = function(indexAlpha, indexBeta, pelsP, pelsQ, p3Idx, p2Idx, p1Idx, p0Idx, q0Idx, q1Idx, q2Idx, q3Idx) {
                actions.add("{bs:" + 4 + ",indexAlpha:" + indexAlpha + ",indexBeta:" + indexBeta + ",pelsP:" + this.label(pelsP, cur, left, top) + ",pelsQ:" + this.label(pelsQ, cur, left, top) + ",p3Idx:" + p3Idx + ",p2Idx:" + p2Idx + ",p1Idx:" + p1Idx + ",p0Idx:" + p0Idx + ",q0Idx:" + q0Idx + ",q1Idx:" + q1Idx + ",q2Idx:" + q2Idx + ",q3Idx:" + q3Idx + ",isChroma:false}");
            };
            prototype.filterBs = function(bs, indexAlpha, indexBeta, pelsP, pelsQ, p2Idx, p1Idx, p0Idx, q0Idx, q1Idx, q2Idx) {
                actions.add("{bs:" + bs + ",indexAlpha:" + indexAlpha + ",indexBeta:" + indexBeta + ",pelsP:" + this.label(pelsP, cur, left, top) + ",pelsQ:" + this.label(pelsQ, cur, left, top) + ",p2Idx:" + p2Idx + ",p1Idx:" + p1Idx + ",p0Idx:" + p0Idx + ",q0Idx:" + q0Idx + ",q1Idx:" + q1Idx + ",q2Idx:" + q2Idx + ",isChroma:false}");
            };
            prototype.filterBs4Chr = function(indexAlpha, indexBeta, pelsP, pelsQ, p1Idx, p0Idx, q0Idx, q1Idx) {
                actions.add("{bs:" + 4 + ",indexAlpha:" + indexAlpha + ",indexBeta:" + indexBeta + ",pelsP:" + this.label(pelsP, cur, left, top) + ",pelsQ:" + this.label(pelsQ, cur, left, top) + ",p1Idx:" + p1Idx + ",p0Idx:" + p0Idx + ",q0Idx:" + q0Idx + ",q1Idx:" + q1Idx + ",isChroma:true}");
            };
            prototype.filterBsChr = function(bs, indexAlpha, indexBeta, pelsP, pelsQ, p1Idx, p0Idx, q0Idx, q1Idx) {
                actions.add("{bs:" + bs + ",indexAlpha:" + indexAlpha + ",indexBeta:" + indexBeta + ",pelsP:" + this.label(pelsP, cur, left, top) + ",pelsQ:" + this.label(pelsQ, cur, left, top) + ",p1Idx:" + p1Idx + ",p0Idx:" + p0Idx + ",q0Idx:" + q0Idx + ",q1Idx:" + q1Idx + ",isChroma:true}");
            };
            prototype.label = function(pels, curMB, leftMB, topMB) {
                var cur = curMB.getPixels(), top = topMB.getPixels(), left = leftMB.getPixels();
                if (cur.getPlaneData(0) == pels || cur.getPlaneData(1) == pels || cur.getPlaneData(2) == pels) 
                    return "cur";
                 else if (left.getPlaneData(0) == pels || left.getPlaneData(1) == pels || left.getPlaneData(2) == pels) 
                    return "left";
                 else if (top.getPlaneData(0) == pels || top.getPlaneData(1) == pels || top.getPlaneData(2) == pels) 
                    return "top";
                 else 
                    return "N/A";
            };
        }, {LOOKUP_IDX_P_V: "Array", LOOKUP_IDX_Q_V: "Array", LOOKUP_IDX_P_H: "Array", LOOKUP_IDX_Q_H: "Array", BS_I: "Array", P_POS_V: "Array", Q_POS_V: "Array", P_POS_H: "Array", Q_POS_H: "Array", P_POS_V_CHR: "Array", Q_POS_V_CHR: "Array", P_POS_H_CHR: "Array", Q_POS_H_CHR: "Array"}, {}))();
        var vertStrength = [new Int32Array([4, 4, 4, 4]), new Int32Array([1, 1, 1, 1]), new Int32Array([1, 1, 1, 1]), new Int32Array([1, 1, 1, 1])];
        var horizStrength = [new Int32Array([4, 4, 4, 4]), new Int32Array([1, 1, 1, 1]), new Int32Array([1, 1, 1, 1]), new Int32Array([1, 1, 1, 1])];
        deblocker.deblockMBGeneric(cur, left, top, vertStrength, horizStrength);
        var expected = ["{bs:4,indexAlpha:0,indexBeta:0,pelsP:left,pelsQ:cur,p3Idx:12,p2Idx:13,p1Idx:14,p0Idx:15,q0Idx:0,q1Idx:1,q2Idx:2,q3Idx:3,isChroma:false}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:left,pelsQ:cur,p3Idx:28,p2Idx:29,p1Idx:30,p0Idx:31,q0Idx:16,q1Idx:17,q2Idx:18,q3Idx:19,isChroma:false}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:left,pelsQ:cur,p3Idx:44,p2Idx:45,p1Idx:46,p0Idx:47,q0Idx:32,q1Idx:33,q2Idx:34,q3Idx:35,isChroma:false}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:left,pelsQ:cur,p3Idx:60,p2Idx:61,p1Idx:62,p0Idx:63,q0Idx:48,q1Idx:49,q2Idx:50,q3Idx:51,isChroma:false}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:left,pelsQ:cur,p3Idx:76,p2Idx:77,p1Idx:78,p0Idx:79,q0Idx:64,q1Idx:65,q2Idx:66,q3Idx:67,isChroma:false}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:left,pelsQ:cur,p3Idx:92,p2Idx:93,p1Idx:94,p0Idx:95,q0Idx:80,q1Idx:81,q2Idx:82,q3Idx:83,isChroma:false}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:left,pelsQ:cur,p3Idx:108,p2Idx:109,p1Idx:110,p0Idx:111,q0Idx:96,q1Idx:97,q2Idx:98,q3Idx:99,isChroma:false}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:left,pelsQ:cur,p3Idx:124,p2Idx:125,p1Idx:126,p0Idx:127,q0Idx:112,q1Idx:113,q2Idx:114,q3Idx:115,isChroma:false}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:left,pelsQ:cur,p3Idx:140,p2Idx:141,p1Idx:142,p0Idx:143,q0Idx:128,q1Idx:129,q2Idx:130,q3Idx:131,isChroma:false}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:left,pelsQ:cur,p3Idx:156,p2Idx:157,p1Idx:158,p0Idx:159,q0Idx:144,q1Idx:145,q2Idx:146,q3Idx:147,isChroma:false}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:left,pelsQ:cur,p3Idx:172,p2Idx:173,p1Idx:174,p0Idx:175,q0Idx:160,q1Idx:161,q2Idx:162,q3Idx:163,isChroma:false}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:left,pelsQ:cur,p3Idx:188,p2Idx:189,p1Idx:190,p0Idx:191,q0Idx:176,q1Idx:177,q2Idx:178,q3Idx:179,isChroma:false}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:left,pelsQ:cur,p3Idx:204,p2Idx:205,p1Idx:206,p0Idx:207,q0Idx:192,q1Idx:193,q2Idx:194,q3Idx:195,isChroma:false}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:left,pelsQ:cur,p3Idx:220,p2Idx:221,p1Idx:222,p0Idx:223,q0Idx:208,q1Idx:209,q2Idx:210,q3Idx:211,isChroma:false}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:left,pelsQ:cur,p3Idx:236,p2Idx:237,p1Idx:238,p0Idx:239,q0Idx:224,q1Idx:225,q2Idx:226,q3Idx:227,isChroma:false}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:left,pelsQ:cur,p3Idx:252,p2Idx:253,p1Idx:254,p0Idx:255,q0Idx:240,q1Idx:241,q2Idx:242,q3Idx:243,isChroma:false}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:left,pelsQ:cur,p1Idx:6,p0Idx:7,q0Idx:0,q1Idx:1,isChroma:true}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:left,pelsQ:cur,p1Idx:14,p0Idx:15,q0Idx:8,q1Idx:9,isChroma:true}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:left,pelsQ:cur,p1Idx:22,p0Idx:23,q0Idx:16,q1Idx:17,isChroma:true}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:left,pelsQ:cur,p1Idx:30,p0Idx:31,q0Idx:24,q1Idx:25,isChroma:true}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:left,pelsQ:cur,p1Idx:38,p0Idx:39,q0Idx:32,q1Idx:33,isChroma:true}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:left,pelsQ:cur,p1Idx:46,p0Idx:47,q0Idx:40,q1Idx:41,isChroma:true}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:left,pelsQ:cur,p1Idx:54,p0Idx:55,q0Idx:48,q1Idx:49,isChroma:true}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:left,pelsQ:cur,p1Idx:62,p0Idx:63,q0Idx:56,q1Idx:57,isChroma:true}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:left,pelsQ:cur,p1Idx:6,p0Idx:7,q0Idx:0,q1Idx:1,isChroma:true}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:left,pelsQ:cur,p1Idx:14,p0Idx:15,q0Idx:8,q1Idx:9,isChroma:true}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:left,pelsQ:cur,p1Idx:22,p0Idx:23,q0Idx:16,q1Idx:17,isChroma:true}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:left,pelsQ:cur,p1Idx:30,p0Idx:31,q0Idx:24,q1Idx:25,isChroma:true}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:left,pelsQ:cur,p1Idx:38,p0Idx:39,q0Idx:32,q1Idx:33,isChroma:true}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:left,pelsQ:cur,p1Idx:46,p0Idx:47,q0Idx:40,q1Idx:41,isChroma:true}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:left,pelsQ:cur,p1Idx:54,p0Idx:55,q0Idx:48,q1Idx:49,isChroma:true}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:left,pelsQ:cur,p1Idx:62,p0Idx:63,q0Idx:56,q1Idx:57,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:1,p1Idx:2,p0Idx:3,q0Idx:4,q1Idx:5,q2Idx:6,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:17,p1Idx:18,p0Idx:19,q0Idx:20,q1Idx:21,q2Idx:22,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:33,p1Idx:34,p0Idx:35,q0Idx:36,q1Idx:37,q2Idx:38,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:49,p1Idx:50,p0Idx:51,q0Idx:52,q1Idx:53,q2Idx:54,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:65,p1Idx:66,p0Idx:67,q0Idx:68,q1Idx:69,q2Idx:70,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:81,p1Idx:82,p0Idx:83,q0Idx:84,q1Idx:85,q2Idx:86,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:97,p1Idx:98,p0Idx:99,q0Idx:100,q1Idx:101,q2Idx:102,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:113,p1Idx:114,p0Idx:115,q0Idx:116,q1Idx:117,q2Idx:118,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:129,p1Idx:130,p0Idx:131,q0Idx:132,q1Idx:133,q2Idx:134,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:145,p1Idx:146,p0Idx:147,q0Idx:148,q1Idx:149,q2Idx:150,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:161,p1Idx:162,p0Idx:163,q0Idx:164,q1Idx:165,q2Idx:166,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:177,p1Idx:178,p0Idx:179,q0Idx:180,q1Idx:181,q2Idx:182,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:193,p1Idx:194,p0Idx:195,q0Idx:196,q1Idx:197,q2Idx:198,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:209,p1Idx:210,p0Idx:211,q0Idx:212,q1Idx:213,q2Idx:214,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:225,p1Idx:226,p0Idx:227,q0Idx:228,q1Idx:229,q2Idx:230,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:241,p1Idx:242,p0Idx:243,q0Idx:244,q1Idx:245,q2Idx:246,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:0,p0Idx:1,q0Idx:2,q1Idx:3,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:8,p0Idx:9,q0Idx:10,q1Idx:11,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:16,p0Idx:17,q0Idx:18,q1Idx:19,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:24,p0Idx:25,q0Idx:26,q1Idx:27,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:32,p0Idx:33,q0Idx:34,q1Idx:35,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:40,p0Idx:41,q0Idx:42,q1Idx:43,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:48,p0Idx:49,q0Idx:50,q1Idx:51,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:56,p0Idx:57,q0Idx:58,q1Idx:59,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:0,p0Idx:1,q0Idx:2,q1Idx:3,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:8,p0Idx:9,q0Idx:10,q1Idx:11,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:16,p0Idx:17,q0Idx:18,q1Idx:19,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:24,p0Idx:25,q0Idx:26,q1Idx:27,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:32,p0Idx:33,q0Idx:34,q1Idx:35,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:40,p0Idx:41,q0Idx:42,q1Idx:43,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:48,p0Idx:49,q0Idx:50,q1Idx:51,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:56,p0Idx:57,q0Idx:58,q1Idx:59,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:5,p1Idx:6,p0Idx:7,q0Idx:8,q1Idx:9,q2Idx:10,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:21,p1Idx:22,p0Idx:23,q0Idx:24,q1Idx:25,q2Idx:26,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:37,p1Idx:38,p0Idx:39,q0Idx:40,q1Idx:41,q2Idx:42,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:53,p1Idx:54,p0Idx:55,q0Idx:56,q1Idx:57,q2Idx:58,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:69,p1Idx:70,p0Idx:71,q0Idx:72,q1Idx:73,q2Idx:74,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:85,p1Idx:86,p0Idx:87,q0Idx:88,q1Idx:89,q2Idx:90,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:101,p1Idx:102,p0Idx:103,q0Idx:104,q1Idx:105,q2Idx:106,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:117,p1Idx:118,p0Idx:119,q0Idx:120,q1Idx:121,q2Idx:122,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:133,p1Idx:134,p0Idx:135,q0Idx:136,q1Idx:137,q2Idx:138,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:149,p1Idx:150,p0Idx:151,q0Idx:152,q1Idx:153,q2Idx:154,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:165,p1Idx:166,p0Idx:167,q0Idx:168,q1Idx:169,q2Idx:170,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:181,p1Idx:182,p0Idx:183,q0Idx:184,q1Idx:185,q2Idx:186,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:197,p1Idx:198,p0Idx:199,q0Idx:200,q1Idx:201,q2Idx:202,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:213,p1Idx:214,p0Idx:215,q0Idx:216,q1Idx:217,q2Idx:218,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:229,p1Idx:230,p0Idx:231,q0Idx:232,q1Idx:233,q2Idx:234,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:245,p1Idx:246,p0Idx:247,q0Idx:248,q1Idx:249,q2Idx:250,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:2,p0Idx:3,q0Idx:4,q1Idx:5,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:10,p0Idx:11,q0Idx:12,q1Idx:13,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:18,p0Idx:19,q0Idx:20,q1Idx:21,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:26,p0Idx:27,q0Idx:28,q1Idx:29,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:34,p0Idx:35,q0Idx:36,q1Idx:37,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:42,p0Idx:43,q0Idx:44,q1Idx:45,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:50,p0Idx:51,q0Idx:52,q1Idx:53,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:58,p0Idx:59,q0Idx:60,q1Idx:61,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:2,p0Idx:3,q0Idx:4,q1Idx:5,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:10,p0Idx:11,q0Idx:12,q1Idx:13,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:18,p0Idx:19,q0Idx:20,q1Idx:21,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:26,p0Idx:27,q0Idx:28,q1Idx:29,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:34,p0Idx:35,q0Idx:36,q1Idx:37,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:42,p0Idx:43,q0Idx:44,q1Idx:45,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:50,p0Idx:51,q0Idx:52,q1Idx:53,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:58,p0Idx:59,q0Idx:60,q1Idx:61,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:9,p1Idx:10,p0Idx:11,q0Idx:12,q1Idx:13,q2Idx:14,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:25,p1Idx:26,p0Idx:27,q0Idx:28,q1Idx:29,q2Idx:30,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:41,p1Idx:42,p0Idx:43,q0Idx:44,q1Idx:45,q2Idx:46,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:57,p1Idx:58,p0Idx:59,q0Idx:60,q1Idx:61,q2Idx:62,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:73,p1Idx:74,p0Idx:75,q0Idx:76,q1Idx:77,q2Idx:78,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:89,p1Idx:90,p0Idx:91,q0Idx:92,q1Idx:93,q2Idx:94,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:105,p1Idx:106,p0Idx:107,q0Idx:108,q1Idx:109,q2Idx:110,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:121,p1Idx:122,p0Idx:123,q0Idx:124,q1Idx:125,q2Idx:126,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:137,p1Idx:138,p0Idx:139,q0Idx:140,q1Idx:141,q2Idx:142,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:153,p1Idx:154,p0Idx:155,q0Idx:156,q1Idx:157,q2Idx:158,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:169,p1Idx:170,p0Idx:171,q0Idx:172,q1Idx:173,q2Idx:174,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:185,p1Idx:186,p0Idx:187,q0Idx:188,q1Idx:189,q2Idx:190,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:201,p1Idx:202,p0Idx:203,q0Idx:204,q1Idx:205,q2Idx:206,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:217,p1Idx:218,p0Idx:219,q0Idx:220,q1Idx:221,q2Idx:222,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:233,p1Idx:234,p0Idx:235,q0Idx:236,q1Idx:237,q2Idx:238,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:249,p1Idx:250,p0Idx:251,q0Idx:252,q1Idx:253,q2Idx:254,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:4,p0Idx:5,q0Idx:6,q1Idx:7,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:12,p0Idx:13,q0Idx:14,q1Idx:15,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:20,p0Idx:21,q0Idx:22,q1Idx:23,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:28,p0Idx:29,q0Idx:30,q1Idx:31,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:36,p0Idx:37,q0Idx:38,q1Idx:39,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:44,p0Idx:45,q0Idx:46,q1Idx:47,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:52,p0Idx:53,q0Idx:54,q1Idx:55,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:60,p0Idx:61,q0Idx:62,q1Idx:63,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:4,p0Idx:5,q0Idx:6,q1Idx:7,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:12,p0Idx:13,q0Idx:14,q1Idx:15,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:20,p0Idx:21,q0Idx:22,q1Idx:23,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:28,p0Idx:29,q0Idx:30,q1Idx:31,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:36,p0Idx:37,q0Idx:38,q1Idx:39,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:44,p0Idx:45,q0Idx:46,q1Idx:47,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:52,p0Idx:53,q0Idx:54,q1Idx:55,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:60,p0Idx:61,q0Idx:62,q1Idx:63,isChroma:true}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:top,pelsQ:cur,p3Idx:192,p2Idx:208,p1Idx:224,p0Idx:240,q0Idx:0,q1Idx:16,q2Idx:32,q3Idx:48,isChroma:false}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:top,pelsQ:cur,p3Idx:193,p2Idx:209,p1Idx:225,p0Idx:241,q0Idx:1,q1Idx:17,q2Idx:33,q3Idx:49,isChroma:false}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:top,pelsQ:cur,p3Idx:194,p2Idx:210,p1Idx:226,p0Idx:242,q0Idx:2,q1Idx:18,q2Idx:34,q3Idx:50,isChroma:false}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:top,pelsQ:cur,p3Idx:195,p2Idx:211,p1Idx:227,p0Idx:243,q0Idx:3,q1Idx:19,q2Idx:35,q3Idx:51,isChroma:false}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:top,pelsQ:cur,p3Idx:196,p2Idx:212,p1Idx:228,p0Idx:244,q0Idx:4,q1Idx:20,q2Idx:36,q3Idx:52,isChroma:false}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:top,pelsQ:cur,p3Idx:197,p2Idx:213,p1Idx:229,p0Idx:245,q0Idx:5,q1Idx:21,q2Idx:37,q3Idx:53,isChroma:false}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:top,pelsQ:cur,p3Idx:198,p2Idx:214,p1Idx:230,p0Idx:246,q0Idx:6,q1Idx:22,q2Idx:38,q3Idx:54,isChroma:false}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:top,pelsQ:cur,p3Idx:199,p2Idx:215,p1Idx:231,p0Idx:247,q0Idx:7,q1Idx:23,q2Idx:39,q3Idx:55,isChroma:false}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:top,pelsQ:cur,p3Idx:200,p2Idx:216,p1Idx:232,p0Idx:248,q0Idx:8,q1Idx:24,q2Idx:40,q3Idx:56,isChroma:false}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:top,pelsQ:cur,p3Idx:201,p2Idx:217,p1Idx:233,p0Idx:249,q0Idx:9,q1Idx:25,q2Idx:41,q3Idx:57,isChroma:false}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:top,pelsQ:cur,p3Idx:202,p2Idx:218,p1Idx:234,p0Idx:250,q0Idx:10,q1Idx:26,q2Idx:42,q3Idx:58,isChroma:false}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:top,pelsQ:cur,p3Idx:203,p2Idx:219,p1Idx:235,p0Idx:251,q0Idx:11,q1Idx:27,q2Idx:43,q3Idx:59,isChroma:false}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:top,pelsQ:cur,p3Idx:204,p2Idx:220,p1Idx:236,p0Idx:252,q0Idx:12,q1Idx:28,q2Idx:44,q3Idx:60,isChroma:false}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:top,pelsQ:cur,p3Idx:205,p2Idx:221,p1Idx:237,p0Idx:253,q0Idx:13,q1Idx:29,q2Idx:45,q3Idx:61,isChroma:false}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:top,pelsQ:cur,p3Idx:206,p2Idx:222,p1Idx:238,p0Idx:254,q0Idx:14,q1Idx:30,q2Idx:46,q3Idx:62,isChroma:false}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:top,pelsQ:cur,p3Idx:207,p2Idx:223,p1Idx:239,p0Idx:255,q0Idx:15,q1Idx:31,q2Idx:47,q3Idx:63,isChroma:false}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:top,pelsQ:cur,p1Idx:48,p0Idx:56,q0Idx:0,q1Idx:8,isChroma:true}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:top,pelsQ:cur,p1Idx:49,p0Idx:57,q0Idx:1,q1Idx:9,isChroma:true}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:top,pelsQ:cur,p1Idx:50,p0Idx:58,q0Idx:2,q1Idx:10,isChroma:true}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:top,pelsQ:cur,p1Idx:51,p0Idx:59,q0Idx:3,q1Idx:11,isChroma:true}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:top,pelsQ:cur,p1Idx:52,p0Idx:60,q0Idx:4,q1Idx:12,isChroma:true}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:top,pelsQ:cur,p1Idx:53,p0Idx:61,q0Idx:5,q1Idx:13,isChroma:true}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:top,pelsQ:cur,p1Idx:54,p0Idx:62,q0Idx:6,q1Idx:14,isChroma:true}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:top,pelsQ:cur,p1Idx:55,p0Idx:63,q0Idx:7,q1Idx:15,isChroma:true}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:top,pelsQ:cur,p1Idx:48,p0Idx:56,q0Idx:0,q1Idx:8,isChroma:true}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:top,pelsQ:cur,p1Idx:49,p0Idx:57,q0Idx:1,q1Idx:9,isChroma:true}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:top,pelsQ:cur,p1Idx:50,p0Idx:58,q0Idx:2,q1Idx:10,isChroma:true}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:top,pelsQ:cur,p1Idx:51,p0Idx:59,q0Idx:3,q1Idx:11,isChroma:true}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:top,pelsQ:cur,p1Idx:52,p0Idx:60,q0Idx:4,q1Idx:12,isChroma:true}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:top,pelsQ:cur,p1Idx:53,p0Idx:61,q0Idx:5,q1Idx:13,isChroma:true}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:top,pelsQ:cur,p1Idx:54,p0Idx:62,q0Idx:6,q1Idx:14,isChroma:true}", "{bs:4,indexAlpha:0,indexBeta:0,pelsP:top,pelsQ:cur,p1Idx:55,p0Idx:63,q0Idx:7,q1Idx:15,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:16,p1Idx:32,p0Idx:48,q0Idx:64,q1Idx:80,q2Idx:96,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:17,p1Idx:33,p0Idx:49,q0Idx:65,q1Idx:81,q2Idx:97,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:18,p1Idx:34,p0Idx:50,q0Idx:66,q1Idx:82,q2Idx:98,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:19,p1Idx:35,p0Idx:51,q0Idx:67,q1Idx:83,q2Idx:99,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:20,p1Idx:36,p0Idx:52,q0Idx:68,q1Idx:84,q2Idx:100,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:21,p1Idx:37,p0Idx:53,q0Idx:69,q1Idx:85,q2Idx:101,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:22,p1Idx:38,p0Idx:54,q0Idx:70,q1Idx:86,q2Idx:102,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:23,p1Idx:39,p0Idx:55,q0Idx:71,q1Idx:87,q2Idx:103,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:24,p1Idx:40,p0Idx:56,q0Idx:72,q1Idx:88,q2Idx:104,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:25,p1Idx:41,p0Idx:57,q0Idx:73,q1Idx:89,q2Idx:105,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:26,p1Idx:42,p0Idx:58,q0Idx:74,q1Idx:90,q2Idx:106,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:27,p1Idx:43,p0Idx:59,q0Idx:75,q1Idx:91,q2Idx:107,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:28,p1Idx:44,p0Idx:60,q0Idx:76,q1Idx:92,q2Idx:108,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:29,p1Idx:45,p0Idx:61,q0Idx:77,q1Idx:93,q2Idx:109,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:30,p1Idx:46,p0Idx:62,q0Idx:78,q1Idx:94,q2Idx:110,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:31,p1Idx:47,p0Idx:63,q0Idx:79,q1Idx:95,q2Idx:111,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:0,p0Idx:8,q0Idx:16,q1Idx:24,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:1,p0Idx:9,q0Idx:17,q1Idx:25,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:2,p0Idx:10,q0Idx:18,q1Idx:26,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:3,p0Idx:11,q0Idx:19,q1Idx:27,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:4,p0Idx:12,q0Idx:20,q1Idx:28,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:5,p0Idx:13,q0Idx:21,q1Idx:29,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:6,p0Idx:14,q0Idx:22,q1Idx:30,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:7,p0Idx:15,q0Idx:23,q1Idx:31,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:0,p0Idx:8,q0Idx:16,q1Idx:24,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:1,p0Idx:9,q0Idx:17,q1Idx:25,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:2,p0Idx:10,q0Idx:18,q1Idx:26,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:3,p0Idx:11,q0Idx:19,q1Idx:27,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:4,p0Idx:12,q0Idx:20,q1Idx:28,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:5,p0Idx:13,q0Idx:21,q1Idx:29,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:6,p0Idx:14,q0Idx:22,q1Idx:30,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:7,p0Idx:15,q0Idx:23,q1Idx:31,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:80,p1Idx:96,p0Idx:112,q0Idx:128,q1Idx:144,q2Idx:160,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:81,p1Idx:97,p0Idx:113,q0Idx:129,q1Idx:145,q2Idx:161,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:82,p1Idx:98,p0Idx:114,q0Idx:130,q1Idx:146,q2Idx:162,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:83,p1Idx:99,p0Idx:115,q0Idx:131,q1Idx:147,q2Idx:163,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:84,p1Idx:100,p0Idx:116,q0Idx:132,q1Idx:148,q2Idx:164,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:85,p1Idx:101,p0Idx:117,q0Idx:133,q1Idx:149,q2Idx:165,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:86,p1Idx:102,p0Idx:118,q0Idx:134,q1Idx:150,q2Idx:166,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:87,p1Idx:103,p0Idx:119,q0Idx:135,q1Idx:151,q2Idx:167,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:88,p1Idx:104,p0Idx:120,q0Idx:136,q1Idx:152,q2Idx:168,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:89,p1Idx:105,p0Idx:121,q0Idx:137,q1Idx:153,q2Idx:169,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:90,p1Idx:106,p0Idx:122,q0Idx:138,q1Idx:154,q2Idx:170,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:91,p1Idx:107,p0Idx:123,q0Idx:139,q1Idx:155,q2Idx:171,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:92,p1Idx:108,p0Idx:124,q0Idx:140,q1Idx:156,q2Idx:172,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:93,p1Idx:109,p0Idx:125,q0Idx:141,q1Idx:157,q2Idx:173,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:94,p1Idx:110,p0Idx:126,q0Idx:142,q1Idx:158,q2Idx:174,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:95,p1Idx:111,p0Idx:127,q0Idx:143,q1Idx:159,q2Idx:175,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:16,p0Idx:24,q0Idx:32,q1Idx:40,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:17,p0Idx:25,q0Idx:33,q1Idx:41,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:18,p0Idx:26,q0Idx:34,q1Idx:42,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:19,p0Idx:27,q0Idx:35,q1Idx:43,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:20,p0Idx:28,q0Idx:36,q1Idx:44,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:21,p0Idx:29,q0Idx:37,q1Idx:45,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:22,p0Idx:30,q0Idx:38,q1Idx:46,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:23,p0Idx:31,q0Idx:39,q1Idx:47,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:16,p0Idx:24,q0Idx:32,q1Idx:40,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:17,p0Idx:25,q0Idx:33,q1Idx:41,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:18,p0Idx:26,q0Idx:34,q1Idx:42,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:19,p0Idx:27,q0Idx:35,q1Idx:43,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:20,p0Idx:28,q0Idx:36,q1Idx:44,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:21,p0Idx:29,q0Idx:37,q1Idx:45,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:22,p0Idx:30,q0Idx:38,q1Idx:46,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:23,p0Idx:31,q0Idx:39,q1Idx:47,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:144,p1Idx:160,p0Idx:176,q0Idx:192,q1Idx:208,q2Idx:224,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:145,p1Idx:161,p0Idx:177,q0Idx:193,q1Idx:209,q2Idx:225,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:146,p1Idx:162,p0Idx:178,q0Idx:194,q1Idx:210,q2Idx:226,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:147,p1Idx:163,p0Idx:179,q0Idx:195,q1Idx:211,q2Idx:227,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:148,p1Idx:164,p0Idx:180,q0Idx:196,q1Idx:212,q2Idx:228,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:149,p1Idx:165,p0Idx:181,q0Idx:197,q1Idx:213,q2Idx:229,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:150,p1Idx:166,p0Idx:182,q0Idx:198,q1Idx:214,q2Idx:230,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:151,p1Idx:167,p0Idx:183,q0Idx:199,q1Idx:215,q2Idx:231,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:152,p1Idx:168,p0Idx:184,q0Idx:200,q1Idx:216,q2Idx:232,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:153,p1Idx:169,p0Idx:185,q0Idx:201,q1Idx:217,q2Idx:233,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:154,p1Idx:170,p0Idx:186,q0Idx:202,q1Idx:218,q2Idx:234,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:155,p1Idx:171,p0Idx:187,q0Idx:203,q1Idx:219,q2Idx:235,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:156,p1Idx:172,p0Idx:188,q0Idx:204,q1Idx:220,q2Idx:236,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:157,p1Idx:173,p0Idx:189,q0Idx:205,q1Idx:221,q2Idx:237,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:158,p1Idx:174,p0Idx:190,q0Idx:206,q1Idx:222,q2Idx:238,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p2Idx:159,p1Idx:175,p0Idx:191,q0Idx:207,q1Idx:223,q2Idx:239,isChroma:false}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:32,p0Idx:40,q0Idx:48,q1Idx:56,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:33,p0Idx:41,q0Idx:49,q1Idx:57,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:34,p0Idx:42,q0Idx:50,q1Idx:58,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:35,p0Idx:43,q0Idx:51,q1Idx:59,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:36,p0Idx:44,q0Idx:52,q1Idx:60,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:37,p0Idx:45,q0Idx:53,q1Idx:61,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:38,p0Idx:46,q0Idx:54,q1Idx:62,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:39,p0Idx:47,q0Idx:55,q1Idx:63,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:32,p0Idx:40,q0Idx:48,q1Idx:56,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:33,p0Idx:41,q0Idx:49,q1Idx:57,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:34,p0Idx:42,q0Idx:50,q1Idx:58,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:35,p0Idx:43,q0Idx:51,q1Idx:59,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:36,p0Idx:44,q0Idx:52,q1Idx:60,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:37,p0Idx:45,q0Idx:53,q1Idx:61,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:38,p0Idx:46,q0Idx:54,q1Idx:62,isChroma:true}", "{bs:1,indexAlpha:0,indexBeta:0,pelsP:cur,pelsQ:cur,p1Idx:39,p0Idx:47,q0Idx:55,q1Idx:63,isChroma:true}"];
        Assert.assertArrayEquals(expected, actions.toArray(Array(0)));
    };
}, {}, {});
var CuesFactoryTest = function() {};
CuesFactoryTest = stjs.extend(CuesFactoryTest, null, [], function(constructor, prototype) {
    prototype.testWithValidCues = function() {
        var inputStream = new FileInputStream(Utils.tildeExpand("~/References/mkv.test/test2.webm"));
        var iFS = inputStream.getChannel();
        var p = new MKVParser(new FileChannelWrapper(iFS));
        var t = null;
        try {
            t = p.parse();
        } finally {
            IOUtils.closeQuietly(inputStream);
        }
        var path7 = [MKVType.Segment, MKVType.Cluster];
        var ccs = MKVType.findAllTree(t, EbmlMaster, path7);
        var baseOffset = 0;
        var path = [MKVType.Segment, MKVType.SeekHead];
        baseOffset += this.getSizeIfPresent(MKVType.findFirstTree(t, path));
        var path1 = [MKVType.Segment, MKVType.Info];
        baseOffset += this.getSizeIfPresent(MKVType.findFirstTree(t, path1));
        var path2 = [MKVType.Segment, MKVType.Tracks];
        baseOffset += this.getSizeIfPresent(MKVType.findFirstTree(t, path2));
        var path3 = [MKVType.Segment, MKVType.Tags];
        baseOffset += this.getSizeIfPresent(MKVType.findFirstTree(t, path3));
        System.out.println(" baseOffset " + baseOffset);
        var indexer = new CuesFactory(baseOffset, 1);
        var path4 = [MKVType.Segment, MKVType.Cues];
        var origCues = MKVType.findFirstTree(t, path4);
        for (var c in ccs) 
            indexer.add(CuesFactory.CuePointMock.make(c));
        var cues = indexer.createCues();
        var path8 = [MKVType.Cues, MKVType.CuePoint];
        var path9 = [MKVType.Cues, MKVType.CuePoint];
        Assert.assertEquals("Number of CuePoints must match", MKVType.findAll(origCues, EbmlBase, false, path8).length, MKVType.findAll(cues, EbmlBase, false, path9).length);
        var path10 = [MKVType.Cues, MKVType.CuePoint, MKVType.CueTrackPositions, MKVType.CueClusterPosition];
        var path11 = [MKVType.Cues, MKVType.CuePoint, MKVType.CueTrackPositions, MKVType.CueClusterPosition];
        Assert.assertEquals("Number of CueClusterPositions must match", MKVType.findAll(origCues, EbmlBase, false, path10).length, MKVType.findAll(cues, EbmlBase, false, path11).length);
        Assert.assertEquals(origCues.size(), cues.size());
        var path5 = [MKVType.Cues, MKVType.CuePoint, MKVType.CueTrackPositions, MKVType.CueClusterPosition];
        var cueClusterPosition = MKVType.findFirst(cues, path5);
        var path6 = [MKVType.Cues, MKVType.CuePoint, MKVType.CueTrackPositions, MKVType.CueClusterPosition];
        var origCueClusterPosition = MKVType.findFirst(origCues, path6);
        Assert.assertEquals(cueClusterPosition.getUint(), origCueClusterPosition.getUint());
    };
    prototype.getSizeIfPresent = function(element) {
        if (element != null) {
            System.out.println("Add " + element.type + " size " + element.size());
            return element.size();
        }
        return 0;
    };
    prototype.testEntryLength = function() {
        System.out.println(CuesFactory.estimateCuePointSize(8, 8, 8));
    };
    prototype.testLengthOfIndexWithSingleEntry = function() {
        var cf = new CuesFactory(1024, 1);
        cf.add(CuesFactory.CuePointMock.doMake(MKVType.Cluster.id, 0, 278539));
        var array = cf.createCues().getData().array();
        Assert.assertEquals(19, array.length);
    };
    prototype.testLengthOfIndexWithTwoEntries = function() {
        var cf = new CuesFactory(1024, 1);
        cf.add(CuesFactory.CuePointMock.doMake(MKVType.Cluster.id, 0, 278539));
        cf.add(CuesFactory.CuePointMock.doMake(MKVType.Cluster.id, 2, 278539));
        var array = cf.createCues().getData().array();
        Assert.assertEquals(34, array.length);
    };
}, {}, {});
var VP8DecoderTest = function() {};
VP8DecoderTest = stjs.extend(VP8DecoderTest, null, [], function(constructor, prototype) {
    prototype.bb = null;
    prototype.dec = null;
    prototype.testKF = function() {
        this.dec.decode(this.bb.duplicate());
        ImageIO.write(AWTUtil.toBufferedImage8Bit(this.dec.getPicture8Bit()), "png", Utils.tildeExpand("~/decoded.png"));
    };
    prototype.testKFToPicture = function() {
        this.dec.decode(this.bb.duplicate());
        ImageIO.write(AWTUtil.toBufferedImage8Bit(this.dec.getPicture8Bit()), "png", Utils.tildeExpand("~/decoded.pic.png"));
    };
    prototype.pysch = function() {
        var mbWidth = 4;
        var mbHeight = 2;
        var stride = mbWidth * 16;
        var size = mbWidth * mbHeight * 16 * 16;
        for (var mbRow = 0; mbRow < mbWidth; mbRow++) 
            for (var mbCol = 0; mbCol < mbHeight; mbCol++) 
                for (var lumaRow = 0; lumaRow < 4; lumaRow++) 
                    for (var lumaCol = 0; lumaCol < 4; lumaCol++) 
                        for (var lumaPRow = 0; lumaPRow < 4; lumaPRow++) 
                            for (var lumaPCol = 0; lumaPCol < 4; lumaPCol++) {
                                var lIdx = 16 * stride * mbRow + 4 * stride * lumaRow + stride * lumaPRow + 16 * mbCol + 4 * lumaCol + lumaPCol;
                                System.out.println("mbRow: " + mbRow + " mbCol: " + mbCol + " lumaRow: " + lumaRow + " lumaCol: " + lumaCol + " lumaPRow: " + lumaPRow + " lumaPCol: " + lumaPCol + " = " + lIdx);
                                Assert.assertTrue("Must me smaller then " + size + " but was " + lIdx, (lIdx < size));
                            }
        System.out.println(size);
    };
    prototype.setUp = function() {
        var path = "src/test/resources/fr.vp8";
        this.bb = NIOUtils.fetchFromFile(new File(path));
        System.out.println("byte array length: " + this.bb.remaining());
        this.dec = new VP8Decoder();
    };
}, {bb: "ByteBuffer", dec: "VP8Decoder"}, {});
var MKVTestSuite = function(dir) {
    this.base = dir;
    this.test1 = new File(dir, "test1.mkv");
    this.test2 = new File(dir, "test2.mkv");
    this.test3 = new File(dir, "test3.mkv");
    this.test4 = new File(dir, "test4.mkv");
    this.test5 = new File(dir, "test5.mkv");
    this.test6 = new File(dir, "test6.mkv");
    this.test7 = new File(dir, "test7.mkv");
    this.test8 = new File(dir, "test8.mkv");
};
MKVTestSuite = stjs.extend(MKVTestSuite, null, [], function(constructor, prototype) {
    prototype.test1 = null;
    prototype.test2 = null;
    prototype.test3 = null;
    prototype.test4 = null;
    prototype.test5 = null;
    prototype.test6 = null;
    prototype.test7 = null;
    prototype.test8 = null;
    prototype.base = null;
    prototype.isSuitePresent = function() {
        return this.test1.exists() && this.test2.exists() && this.test3.exists() && this.test4.exists() && this.test5.exists() && this.test6.exists() && this.test7.exists() && this.test8.exists();
    };
    prototype.allTests = function() {
        return [this.test1, this.test2, this.test3, this.test4, this.test5, this.test6, this.test7, this.test8];
    };
    constructor.loadProperties = function(file) {
        var reader = null;
        try {
            var props = new Properties();
            if (file.exists()) {
                reader = new BufferedReader(new FileReader(file));
                props.load(reader);
            }
            return props;
        } finally {
            IOUtils.closeQuietly(reader);
        }
    };
    constructor.read = function() {
        return MKVTestSuite.readFile(new File("./src/test/resources/mkv/suite.properties"));
    };
    constructor.readFile = function(f) {
        if (!f.exists()) 
             throw new RuntimeException(f.getAbsolutePath() + " doesn't exists");
        var props = MKVTestSuite.loadProperties(f);
        var path = props.getProperty("mkv.test.suite.path");
        var dir = Utils.tildeExpand(path);
        return new MKVTestSuite(dir);
    };
}, {test1: "File", test2: "File", test3: "File", test4: "File", test5: "File", test6: "File", test7: "File", test8: "File", base: "File"}, {});
var FrameGrabTest = function() {};
FrameGrabTest = stjs.extend(FrameGrabTest, null, [], function(constructor, prototype) {
    constructor.SEQ_1_MP4 = "src/test/resources/video/seq_h264_1.mp4";
    constructor.SEQ_2_MP4 = "src/test/resources/video/seq_h264_2.mp4";
    constructor.SEQ_3_MP4 = "src/test/resources/video/seq_h264_3.mp4";
    constructor.SEQ_1_YUV = "src/test/resources/video/seq_1.yuv";
    constructor.SEQ_2_YUV = "src/test/resources/video/seq_2.yuv";
    constructor.SEQ_3_YUV = "src/test/resources/video/seq_3.yuv";
    prototype.saveImages = false;
    prototype.testFrameGrab = function() {
        this.compareOneSequence(FrameGrabTest.SEQ_1_MP4, FrameGrabTest.SEQ_1_YUV);
        this.compareOneSequence(FrameGrabTest.SEQ_2_MP4, FrameGrabTest.SEQ_2_YUV);
        this.compareOneSequence(FrameGrabTest.SEQ_3_MP4, FrameGrabTest.SEQ_3_YUV);
    };
    prototype.compareOneSequence = function(compressed, uncompressed) {
        var ch1 = null, ch2 = null;
        try {
            ch1 = NIOUtils.readableChannel(new File(compressed));
            ch2 = NIOUtils.readableChannel(new File(uncompressed));
            var frameGrab1 = FrameGrab8Bit.createFrameGrab8Bit(ch1);
            var fr1;
            var decoded = new ArrayList();
            do {
                fr1 = frameGrab1.getNativeFrameWithMetadata();
                if (fr1 == null) 
                    break;
                fr1 = new PictureWithMetadata8Bit(fr1.getPicture().cloneCropped(), fr1.getTimestamp(), fr1.getDuration());
                decoded.add(fr1);
            } while (fr1 != null);
            Collections.sort(decoded, new (stjs.extend(function FrameGrabTest$1() {}, null, [Comparator], function(constructor, prototype) {
                prototype.compare = function(o1, o2) {
                    return o1.getTimestamp() < o2.getTimestamp() ? -1 : (o1.getTimestamp() == o2.getTimestamp() ? 0 : 1);
                };
            }, {}, {}))());
            for (var iterator$pic = decoded.iterator(); iterator$pic.hasNext(); ) {
                var pic = iterator$pic.next();
                var frame = pic.getPicture();
                var fr2 = Utils.readYuvFrame(ch2, frame.getWidth(), frame.getHeight());
                if (this.saveImages && Utils.maxDiff(frame, fr2) > 0) {
                    System.out.println(String.format("POC: %d, pts: %f", frame.getPOC(), pic.getTimestamp()));
                    Utils.saveImage(fr2, "png", String.format("/tmp/orig_%s_%f.%s", new File(compressed).getName(), pic.getTimestamp(), "png"));
                    Utils.saveImage(frame, "png", String.format("/tmp/dec_%s_%f.%s", new File(compressed).getName(), pic.getTimestamp(), "png"));
                    Utils.saveImage(Utils.diff(frame, fr2, 10), "png", String.format("/tmp/diff_%s_%f.%s", new File(compressed).getName(), pic.getTimestamp(), "png"));
                }
                Assert.assertTrue(String.format("Seq %s, poc %d, pts %f", compressed, frame.getPOC(), pic.getTimestamp()), Utils.picturesRoughlyEqual(frame, fr2, 50));
            }
        } finally {
            IOUtils.closeQuietly(ch1);
            IOUtils.closeQuietly(ch2);
        }
    };
}, {}, {});
var AVCClipCatTest = function() {};
AVCClipCatTest = stjs.extend(AVCClipCatTest, null, [], function(constructor, prototype) {
    constructor.SEQ_1_MP4 = "src/test/resources/video/seq_h264_1.mp4";
    constructor.SEQ_2_MP4 = "src/test/resources/video/seq_h264_2.mp4";
    constructor.SEQ_3_MP4 = "src/test/resources/video/seq_h264_3.mp4";
    prototype.testClipCat = function() {
        var f1 = new File(AVCClipCatTest.SEQ_1_MP4);
        var f2 = new File(AVCClipCatTest.SEQ_2_MP4);
        var f3 = new File(AVCClipCatTest.SEQ_3_MP4);
        var m1 = MP4Util.parseMovie(f1);
        var m2 = MP4Util.parseMovie(f2);
        var m3 = MP4Util.parseMovie(f3);
        var t1 = new ClipTrack(new RealTrack(m1, m1.getVideoTrack(), new FilePool(f1, 10)), 60, 120);
        var t2 = new ClipTrack(new RealTrack(m2, m2.getVideoTrack(), new FilePool(f2, 10)), 60, 120);
        var t3 = new ClipTrack(new RealTrack(m3, m3.getVideoTrack(), new FilePool(f3, 10)), 60, 120);
        var ct = new AVCConcatTrack(t1, t2, t3);
        var vm = new VirtualMP4Movie(ct);
        var range = new MovieRange(vm, 0, vm.size());
        var file = File.createTempFile("cat_key_clip", ".mp4");
        jcodec.Logger.info("Transcoding to: " + file.getAbsolutePath());
        var out = new BufferedOutputStream(new FileOutputStream(file));
        IOUtils.copy(range, out);
        out.flush();
        out.close();
        Utils.compareMP4H264Files(file, new File("src/test/resources/AVCClipCatTest/cat_key_clip.mp4"));
    };
    prototype.testAVCClip = function() {
        var f1 = new File(AVCClipCatTest.SEQ_1_MP4);
        var m1 = MP4Util.parseMovie(f1);
        var t1 = new AVCClipTrack(new RealTrack(m1, m1.getVideoTrack(), new FilePool(f1, 10)), 60, 120);
        var vm = new VirtualMP4Movie(t1);
        var range = new MovieRange(vm, 0, vm.size());
        var file = File.createTempFile("precise_clip", ".mp4");
        jcodec.Logger.info("Transcoding to: " + file.getAbsolutePath());
        var out = new BufferedOutputStream(new FileOutputStream(file));
        IOUtils.copy(range, out);
        out.flush();
        out.close();
        Utils.compareMP4H264Files(file, new File("src/test/resources/AVCClipCatTest/precise_clip.mp4"));
    };
    prototype.testAVCClipCat = function() {
        var f1 = new File(AVCClipCatTest.SEQ_1_MP4);
        var f2 = new File(AVCClipCatTest.SEQ_2_MP4);
        var f3 = new File(AVCClipCatTest.SEQ_3_MP4);
        var m1 = MP4Util.parseMovie(f1);
        var m2 = MP4Util.parseMovie(f2);
        var m3 = MP4Util.parseMovie(f3);
        var t1 = new AVCClipTrack(new RealTrack(m1, m1.getVideoTrack(), new FilePool(f1, 10)), 60, 120);
        var t2 = new AVCClipTrack(new RealTrack(m2, m2.getVideoTrack(), new FilePool(f2, 10)), 60, 120);
        var t3 = new AVCClipTrack(new RealTrack(m3, m3.getVideoTrack(), new FilePool(f3, 10)), 60, 120);
        var ct = new AVCConcatTrack(t1, t2, t3);
        var vm = new VirtualMP4Movie(ct);
        var range = new MovieRange(vm, 0, vm.size());
        var file = File.createTempFile("cat_avc_clip", ".mp4");
        jcodec.Logger.info("Transcoding to: " + file.getAbsolutePath());
        var out = new BufferedOutputStream(new FileOutputStream(file));
        IOUtils.copy(range, out);
        out.flush();
        out.close();
        Utils.compareMP4H264Files(file, new File("src/test/resources/AVCClipCatTest/cat_avc_clip.mp4"));
    };
}, {}, {});
var BlockOrderingTest = function() {};
BlockOrderingTest = stjs.extend(BlockOrderingTest, null, [], function(constructor, prototype) {
    prototype.testFixedLacing = function() {
        var file = new File("src/test/resources/mkv/fixed_lacing_simple_block.ebml");
        var rawFrame = IOUtils.readFileToByteArray(file);
        var be = new MkvBlock(MKVType.SimpleBlock.id);
        be.offset = 0;
        be.dataLen = 3077;
        be.dataOffset = 3;
        var fileInputStream = new FileInputStream(file);
        var source = ByteBuffer.allocate(fileInputStream.available());
        try {
            var channel = fileInputStream.getChannel();
            channel.position(be.dataOffset);
            channel.read(source);
            source.flip();
        } finally {
            IOUtils.closeQuietly(fileInputStream);
        }
        be.read(source);
        be.readFrames(source);
        Assert.assertEquals(rawFrame.length, be.size());
        var data = be.getData().array();
        System.out.println(EbmlUtil.toHexString(data));
        Assert.assertArrayEquals(rawFrame, data);
    };
    prototype.testEbmlLacing = function() {
        var file = new File("src/test/resources/mkv/ebml_lacing_block.ebml");
        var rawFrame = NIOUtils.fetchFromFile(file);
        var be = new MkvBlock(MKVType.Block.id);
        be.offset = 0;
        be.dataLen = 3874;
        be.dataOffset = 3;
        var fileInputStream = new FileInputStream(file);
        var source = ByteBuffer.allocate(fileInputStream.available());
        try {
            var channel = fileInputStream.getChannel();
            channel.position(be.dataOffset);
            channel.read(source);
            source.flip();
        } finally {
            IOUtils.closeQuietly(fileInputStream);
        }
        be.read(source);
        be.readFrames(source);
        Assert.assertEquals(rawFrame.capacity(), be.size());
        Assert.assertArrayEquals(rawFrame.array(), be.getData().array());
    };
    prototype.testName = function() {
        System.out.println(VP8Decoder.printHexByte((-98 << 24 >> 24)));
        System.out.println(VP8Decoder.printHexByte((-95 << 24 >> 24)));
    };
    prototype.testXiphLacing = function() {
        var file = new File("src/test/resources/mkv/xiph_lacing_block.ebml");
        var rawFrame = IOUtils.readFileToByteArray(file);
        var be = new MkvBlock(MKVType.Block.id);
        be.offset = 0;
        be.dataLen = 851;
        be.dataOffset = 3;
        var fileInputStream = new FileInputStream(file);
        var source = ByteBuffer.allocate(fileInputStream.available());
        try {
            var channel = fileInputStream.getChannel();
            channel.position(be.dataOffset);
            channel.read(source);
            source.flip();
        } finally {
            IOUtils.closeQuietly(fileInputStream);
        }
        be.read(source);
        be.readFrames(source);
        Assert.assertEquals(rawFrame.length, be.size());
        Assert.assertArrayEquals(rawFrame, be.getData().array());
    };
    prototype.testNoLacing = function() {
        var file = new File("src/test/resources/mkv/no_lacing_simple_block.ebml");
        var rawFrame = IOUtils.readFileToByteArray(file);
        var be = new MkvBlock(MKVType.SimpleBlock.id);
        be.offset = 0;
        be.dataLen = 772;
        be.dataOffset = 3;
        var fileInputStream = new FileInputStream(file);
        var source = ByteBuffer.allocate(fileInputStream.available());
        try {
            var channel = fileInputStream.getChannel();
            channel.position(be.dataOffset);
            channel.read(source);
            source.flip();
        } finally {
            IOUtils.closeQuietly(fileInputStream);
        }
        be.read(source);
        be.readFrames(source);
        Assert.assertEquals(be.dataLen, be.getDataSize());
        Assert.assertEquals(rawFrame.length, be.size());
        Assert.assertArrayEquals(rawFrame, be.getData().array());
    };
    prototype.test = function() {
        var suite = MKVTestSuite.read();
        if (!suite.isSuitePresent()) 
            Assert.fail("MKV test suite is missing, please download from http://www.matroska.org/downloads/test_w1.html, and save to the path recorded in src/test/resources/mkv/suite.properties");
        System.out.println("Scanning file: " + suite.test1.getAbsolutePath());
        var inputStream = new FileInputStream(suite.test1);
        try {
            var reader = new MKVParser(new FileChannelWrapper(inputStream.getChannel()));
            var t = reader.parse();
            this.printTracks(t);
            this.printTimecodes(t);
        } finally {
            IOUtils.closeQuietly(inputStream);
        }
    };
    prototype.printTracks = function(tree) {
        var path = [MKVType.Segment, MKVType.Tracks, MKVType.TrackEntry, MKVType.TrackNumber];
        for (var nr in MKVType.findAllTree(tree, EbmlUint, path)) 
            System.out.println("Track nr:" + nr.getUint());
    };
    prototype.printTimecodes = function(tree) {
        var path2 = [MKVType.Segment, MKVType.Cluster];
        var clusters = MKVType.findAllTree(tree, EbmlMaster, path2);
        for (var c in clusters) {
            var path = [MKVType.Cluster, MKVType.Timecode];
            var ctc = (MKVType.findFirst(c, path)).getUint();
            var bks = 0;
            for (var iterator$e = c.children.iterator(); iterator$e.hasNext(); ) {
                var e = iterator$e.next();
                if (stjs.isInstanceOf(e.constructor, MkvBlock)) {
                    var block = e;
                    var btc = block.timecode;
                    block.absoluteTimecode = btc + ctc;
                    System.out.println("        Block timecode: " + btc + " absoluete timecode: " + (btc + ctc) + " track: " + block.trackNumber + " offset: " + e.offset + " lacing " + block.lacing);
                    bks++;
                } else if (MKVType.BlockGroup.equals(e.type)) {
                    var path1 = [MKVType.BlockGroup, MKVType.Block];
                    var be = MKVType.findFirst(e, path1);
                    be.absoluteTimecode = be.timecode + ctc;
                    System.out.println("        Block Group timecode: " + be.timecode + " absoluete timecode: " + (be.timecode + ctc) + " track: " + be.trackNumber + " offset: " + be.offset + " lacing " + be.lacing);
                    bks++;
                }
            }
            System.out.println("    Cluster timecode: " + ctc + " offset: " + c.offset + " bks: " + bks);
        }
    };
}, {}, {});
var MKVParserTest = function() {};
MKVParserTest = stjs.extend(MKVParserTest, null, [], function(constructor, prototype) {
    prototype.suite = null;
    prototype.setUp = function() {
        this.suite = MKVTestSuite.read();
        if (!this.suite.isSuitePresent()) 
            Assert.fail("MKV test suite is missing, please download from http://www.matroska.org/downloads/test_w1.html, and save to the path recorded in src/test/resources/mkv/suite.properties");
    };
    prototype.test = function() {
        System.out.println("Scanning file: " + this.suite.test1.getAbsolutePath());
        var fileInputStream = new FileInputStream(this.suite.test1);
        var reader = new MKVParser(new FileChannelWrapper(fileInputStream.getChannel()));
        reader.parse();
        IOUtils.closeQuietly(fileInputStream);
    };
    prototype.testFindAll = function() {
        for (var aFile in this.suite.allTests()) {
            System.out.println("Scanning file: " + aFile.getAbsolutePath());
            var stream = new FileInputStream(aFile);
            var reader = new MKVParser(new FileChannelWrapper(stream.getChannel()));
            var tree;
            try {
                tree = reader.parse();
            } finally {
                IOUtils.closeQuietly(stream);
            }
            var path = [MKVType.Segment, MKVType.Cluster, MKVType.SimpleBlock];
            var simpleBlocks = MKVType.findAllTree(tree, MkvBlock, path);
            if (simpleBlocks == null || simpleBlocks.length == 0) {
                var path1 = [MKVType.Segment, MKVType.Cluster, MKVType.BlockGroup, MKVType.Block];
                simpleBlocks = MKVType.findAllTree(tree, MkvBlock, path1);
                if (simpleBlocks == null || simpleBlocks.length == 0) 
                    System.err.println("No simple blocks / block groups found. Looks suspicious");
            }
            System.out.println(" simple blocks found: " + simpleBlocks.length);
        }
    };
    prototype.testFind = function() {
        System.out.println("Scanning file: " + this.suite.test5.getAbsolutePath());
        var stream = null;
        try {
            stream = new FileInputStream(this.suite.test5);
            var iFS = stream.getChannel();
            var reader = new MKVParser(new FileChannelWrapper(iFS));
            var t = reader.parse();
            var path = [MKVType.Segment];
            var allSegments = MKVType.findAllTree(t, EbmlMaster, path);
            Assert.assertNotNull(allSegments);
            Assert.assertEquals(1, allSegments.length);
            var path1 = [MKVType.Segment, MKVType.Cluster];
            var allClusters = MKVType.findAllTree(t, EbmlMaster, path1);
            Assert.assertNotNull(allClusters);
            Assert.assertEquals(25, allClusters.length);
        } finally {
            stream.close();
        }
    };
    prototype.testFirstElementAndSizeAsBytes = function() {
        var fis = new FileInputStream("./src/test/resources/mkv/10frames.webm");
        try {
            var channel = new FileChannelWrapper(fis.getChannel());
            Assert.assertArrayEquals(MKVType.EBML.id, MKVParser.readEbmlId(channel));
            channel.setPosition(12);
            Assert.assertArrayEquals(new Int8Array([66, (134 << 24 >> 24)]), MKVParser.readEbmlId(channel));
        } finally {
            fis.close();
        }
    };
    prototype.testFirstElement = function() {
        var fis = new FileInputStream("./src/test/resources/mkv/10frames.webm");
        try {
            var source = new FileChannelWrapper(fis.getChannel());
            Assert.assertArrayEquals(MKVType.EBML.id, MKVParser.readEbmlId(source));
            Assert.assertEquals(31, MKVParser.readEbmlInt(source));
        } finally {
            fis.close();
        }
    };
    constructor.printParsedTree = function(os, tree) {
        for (var iterator$e = tree.iterator(); iterator$e.hasNext(); ) {
            var e = iterator$e.next();
            MKVParserTest.printTree(0, e, os);
        }
    };
    constructor.printTree = function(i, e, os) {
        os.write(MKVParserTest.printPaddedType(i, e).toString().getBytes());
        os.write("\n".getBytes());
        if (stjs.isInstanceOf(e.constructor, EbmlMaster)) {
            var parent = e;
            for (var iterator$child = parent.children.iterator(); iterator$child.hasNext(); ) {
                var child = iterator$child.next();
                MKVParserTest.printTree(i + 1, child, os);
            }
            os.write(MKVParserTest.printPaddedType(i, e).append(" CLOSED.").toString().getBytes());
            os.write("\n".getBytes());
        }
    };
    constructor.printPaddedType = function(size, e) {
        var sb = new StringBuilder();
        for (; size > 0; size--) {
            sb.append("    ");
        }
        sb.append(e.type);
        return sb;
    };
}, {suite: "MKVTestSuite"}, {});
var MkvBlockTest = function() {};
MkvBlockTest = stjs.extend(MkvBlockTest, null, [], function(constructor, prototype) {
    prototype.testXiph = function() {
        var _in = new Int32Array([187, 630, 255, 60, 16777215]);
        var expecteds = new Int8Array([(187 << 24 >> 24), (255 << 24 >> 24), (255 << 24 >> 24), 120, (255 << 24 >> 24), 0, 60]);
        Assert.assertArrayEquals(expecteds, MkvBlock.muxXiphLacing(_in));
    };
    prototype.testReadEbmlInt = function() {
        Assert.assertEquals(577, MkvBlock.ebmlDecode(ByteBuffer.wrap(new Int8Array([66, 65]))));
        Assert.assertEquals(33, MkvBlock.ebmlDecode(ByteBuffer.wrap(new Int8Array([(161 << 24 >> 24)]))));
        Assert.assertEquals(577, MkvBlock.ebmlDecode(ByteBuffer.wrap(new Int8Array([66, 65, 34, 34, 34]))));
    };
    prototype.testEbml = function() {
        var _in = new Int32Array([187, 630, 255, 60, 16777215]);
        var expecteds = [187, 443, -375, -195];
        Assert.assertArrayEquals(expecteds, MkvBlock.calcEbmlLacingDiffs(_in));
        _in = new Int32Array([480, 576, 672, 672, 672, 672, 576, 672]);
        expecteds = [480, 96, 96, 0, 0, 0, -96];
        Assert.assertArrayEquals(expecteds, MkvBlock.calcEbmlLacingDiffs(_in));
    };
    prototype.testMuxEbml = function() {
        var frameSizes = new Int32Array([480, 576, 672, 672, 672, 672, 576, 672]);
        var expected = new Int8Array([65, (224 << 24 >> 24), 96, 95, 96, 95, (191 << 24 >> 24), (191 << 24 >> 24), (191 << 24 >> 24), 95, (159 << 24 >> 24)]);
        Assert.assertArrayEquals(expected, MkvBlock.muxEbmlLacing(frameSizes));
        frameSizes = new Int32Array([480, 576]);
        expected = new Int8Array([65, (224 << 24 >> 24)]);
        Assert.assertArrayEquals(expected, MkvBlock.muxEbmlLacing(frameSizes));
        frameSizes = new Int32Array([480, 576, 672]);
        expected = new Int8Array([65, (224 << 24 >> 24), 96, 95]);
        Assert.assertArrayEquals(expected, MkvBlock.muxEbmlLacing(frameSizes));
    };
    prototype.testReadingEbml = function() {
        var bb = ByteBuffer.wrap(new Int8Array([(130 << 24 >> 24), 0, 0, (134 << 24 >> 24), 7, 65, (224 << 24 >> 24), 96, 95, 96, 95, (191 << 24 >> 24), (191 << 24 >> 24), (191 << 24 >> 24), 95, (159 << 24 >> 24)]));
        var startPosition = 5;
        bb.setPosition(startPosition);
        var be = new MkvBlock(MKVType.SimpleBlock.id);
        be.offset = 274;
        be.dataOffset = 277;
        be.dataLen = 5008;
        var sizes = new Int32Array(bb.getAt(4) + 1);
        be.headerSize = MkvBlock.readEBMLLaceSizes(bb, sizes, stjs.trunc(be.dataLen), startPosition);
        Assert.assertNotNull(sizes);
        Assert.assertEquals(bb.capacity(), be.headerSize);
        Assert.assertEquals(480, sizes[0]);
        Assert.assertEquals(480 + 96, sizes[1]);
        Assert.assertEquals(480 + 96 + 96, sizes[2]);
        Assert.assertEquals(480 + 96 + 96 + 0, sizes[3]);
        Assert.assertEquals(480 + 96 + 96 + 0 + 0, sizes[4]);
        Assert.assertEquals(480 + 96 + 96 + 0 + 0 + 0, sizes[5]);
        Assert.assertEquals(480 + 96 + 96 + 0 + 0 + 0 - 96, sizes[6]);
        Assert.assertEquals(be.dataLen - ((480 + 96 + 96 + 0 + 0 + 0 - 96) + (480 + 96 + 96 + 0 + 0 + 0) + (480 + 96 + 96 + 0 + 0) + (480 + 96 + 96 + 0) + (480 + 96 + 96) + (480 + 96) + 480 + be.headerSize), sizes[7]);
    };
    prototype.testReadingXiph = function() {
        var bb = ByteBuffer.wrap(new Int8Array([(130 << 24 >> 24), 0, (174 << 24 >> 24), 2, 7, 81, (146 << 24 >> 24), (146 << 24 >> 24), 80, 79, 75, 84, (212 << 24 >> 24), (253 << 24 >> 24)]));
        var startPosition = 5;
        bb.setPosition(startPosition);
        var be = new MkvBlock(MKVType.Block.id);
        be.offset = 84400;
        be.dataOffset = 84403;
        be.dataLen = 851;
        var sizes = new Int32Array(bb.getAt(4) + 1);
        be.headerSize = MkvBlock.readXiphLaceSizes(bb, sizes, stjs.trunc(be.dataLen), startPosition);
        Assert.assertEquals(12, be.headerSize);
        var third = bb.getAt(7) & 255;
        var second = bb.getAt(6) & 255;
        var eightth = stjs.trunc((be.dataLen)) - (bb.getAt(5) + second + third + bb.getAt(8) + bb.getAt(9) + bb.getAt(10) + bb.getAt(11) + be.headerSize);
        Assert.assertArrayEquals(new Int32Array([bb.getAt(5), second, third, bb.getAt(8), bb.getAt(9), bb.getAt(10), bb.getAt(11), eightth]), sizes);
    };
    prototype.testReadingXiphV2 = function() {
        var bb = ByteBuffer.wrap(new Int8Array([(130 << 24 >> 24), 0, (174 << 24 >> 24), 2, 4, (187 << 24 >> 24), (255 << 24 >> 24), (255 << 24 >> 24), 120, (255 << 24 >> 24), 0, 60]));
        var startPosition = 5;
        bb.setPosition(startPosition);
        var be = new MkvBlock(MKVType.Block.id);
        be.offset = 84400;
        be.dataOffset = 84403;
        be.dataLen = 851;
        var sizes = new Int32Array(bb.getAt(4) + 1);
        be.headerSize = MkvBlock.readXiphLaceSizes(bb, sizes, stjs.trunc(be.dataLen), startPosition);
        Assert.assertEquals(12, be.headerSize);
        Assert.assertArrayEquals(new Int32Array([187, 630, 255, 60, stjs.trunc((be.dataLen)) - (187 + 630 + 255 + 60 + be.headerSize)]), sizes);
    };
    prototype.testGetSize = function() {
        var suite = MKVTestSuite.read();
        if (!suite.isSuitePresent()) 
            Assert.fail("MKV test suite is missing, please download from http://www.matroska.org/downloads/test_w1.html, and save to the path recorded in src/test/resources/mkv/suite.properties");
        System.out.println("Scanning file: " + suite.test1.getAbsolutePath());
        var inputStream = new FileInputStream(suite.test1);
        try {
            var reader = new MKVParser(new FileChannelWrapper(inputStream.getChannel()));
            var path = [MKVType.Segment, MKVType.Cluster, MKVType.SimpleBlock];
            var blocks = MKVType.findAllTree(reader.parse(), MkvBlock, path);
            for (var be in blocks) 
                if (be.lacingPresent) {
                    Assert.assertEquals("    " + be.lacing + " Lacing block offset " + be.offset, be.dataLen + (be.dataOffset - be.offset), be.size());
                }
        } finally {
            IOUtils.closeQuietly(inputStream);
        }
    };
    prototype.testReadingSignedInt = function() {
        Assert.assertEquals(-30, MkvBlock.ebmlDecodeSigned(ByteBuffer.wrap(new Int8Array([(161 << 24 >> 24)]))));
        Assert.assertEquals(-7614, MkvBlock.ebmlDecodeSigned(ByteBuffer.wrap(new Int8Array([66, 65]))));
    };
}, {}, {});
var SimpleMappingTest = function() {};
SimpleMappingTest = stjs.extend(SimpleMappingTest, null, [], function(constructor, prototype) {
    prototype.test = function() {
        var suite = MKVTestSuite.read();
        System.out.println("Scanning file: " + suite.test2.getAbsolutePath());
        var fileInputStream = null;
        try {
            fileInputStream = new FileInputStream(suite.test2);
            this.readEBMLElements(fileInputStream.getChannel());
        } finally {
            fileInputStream.close();
        }
    };
    prototype.readEBMLElements = function(channel) {
        var offset = channel.position();
        var bb = SimpleMappingTest.fetchFrom(channel);
        System.out.println("pysch 0x" + EbmlUtil.toHexString(bb.array()).toUpperCase() + " " + MKVType.createById(bb.array(), offset));
    };
    constructor.fetchFrom = function(ch) {
        var bufferForFirstByte = ByteBuffer.allocate(1);
        bufferForFirstByte.clear();
        ch.read(bufferForFirstByte);
        bufferForFirstByte.flip();
        var first = bufferForFirstByte.get();
        var idSize = EbmlUtil.computeLength(first);
        var bufferForId = ByteBuffer.allocate(idSize);
        bufferForId.put(first);
        ch.read(bufferForId);
        bufferForId.flip();
        return bufferForId;
    };
    constructor.read = function(channel, buffer) {
        var rem = buffer.position();
         while (channel.read(buffer) != -1 && buffer.hasRemaining())
            ;
        return buffer.position() - rem;
    };
}, {}, {});
var MKVMuxerTest = function() {};
MKVMuxerTest = stjs.extend(MKVMuxerTest, null, [], function(constructor, prototype) {
    prototype.suite = null;
    prototype.testRead10Frames = function() {
        var rawFrames = Array(10);
        rawFrames[0] = IOUtils.readFileToByteArray(new File("src/test/resources/mkv/10frames01.vp8"));
        rawFrames[1] = IOUtils.readFileToByteArray(new File("src/test/resources/mkv/10frames02.vp8"));
        rawFrames[2] = IOUtils.readFileToByteArray(new File("src/test/resources/mkv/10frames03.vp8"));
        rawFrames[3] = IOUtils.readFileToByteArray(new File("src/test/resources/mkv/10frames04.vp8"));
        rawFrames[4] = IOUtils.readFileToByteArray(new File("src/test/resources/mkv/10frames05.vp8"));
        rawFrames[5] = IOUtils.readFileToByteArray(new File("src/test/resources/mkv/10frames06.vp8"));
        rawFrames[6] = IOUtils.readFileToByteArray(new File("src/test/resources/mkv/10frames07.vp8"));
        rawFrames[7] = IOUtils.readFileToByteArray(new File("src/test/resources/mkv/10frames08.vp8"));
        rawFrames[8] = IOUtils.readFileToByteArray(new File("src/test/resources/mkv/10frames09.vp8"));
        rawFrames[9] = IOUtils.readFileToByteArray(new File("src/test/resources/mkv/10frames10.vp8"));
        var file = new File("src/test/resources/mkv/10frames.webm");
        var inputStream = new FileInputStream(file);
        var parser = new MKVParser(new FileChannelWrapper(inputStream.getChannel()));
        var tree = null;
        try {
            tree = parser.parse();
        } finally {
            if (inputStream != null) 
                inputStream.close();
            inputStream = null;
        }
        var path = [MKVType.Segment, MKVType.Cluster];
        var cc = MKVType.findAllTree(tree, EbmlMaster, path);
        inputStream = new FileInputStream(file);
        Assert.assertNotNull(cc);
        Assert.assertEquals(2, cc.length);
        try {
            var frameReadingChannel = inputStream.getChannel();
            var bs = MKVMuxerTest.getBlocksByTrackNumber(cc[0], 1);
            Assert.assertNotNull(bs);
            Assert.assertEquals(5, bs.size());
            for (var i = 0; i < 5; i++) {
                var channel = frameReadingChannel;
                var bb = ByteBuffer.allocate(bs.get(i).dataLen);
                frameReadingChannel.position(bs.get(i).dataOffset);
                frameReadingChannel.read(bb);
                var frames = bs.get(i).getFrames(bb);
                Assert.assertNotNull(frames);
                Assert.assertEquals(1, frames.length);
                Assert.assertArrayEquals(rawFrames[i], MKVMuxerTest.bufferToArray(frames[0]));
            }
            bs = MKVMuxerTest.getBlocksByTrackNumber(cc[1], 1);
            Assert.assertNotNull(bs);
            Assert.assertEquals(5, bs.size());
            for (var i = 5; i < 10; i++) {
                var bb = ByteBuffer.allocate(bs.get(i - 5).dataLen);
                frameReadingChannel.position(bs.get(i - 5).dataOffset);
                frameReadingChannel.read(bb);
                var frames = bs.get(i - 5).getFrames(bb);
                Assert.assertNotNull(frames);
                Assert.assertEquals(1, frames.length);
                Assert.assertArrayEquals(rawFrames[i], MKVMuxerTest.bufferToArray(frames[0]));
            }
        } finally {
            IOUtils.closeQuietly(inputStream);
        }
    };
    prototype.showKeyFrames = function() {
        var inputStream = new FileInputStream(this.suite.test5);
        var p = new MKVParser(new FileChannelWrapper(inputStream.getChannel()));
        var t = null;
        try {
            t = p.parse();
        } finally {
            IOUtils.closeQuietly(inputStream);
        }
        var path1 = [MKVType.Segment, MKVType.Cluster];
        for (var c in MKVType.findAllTree(t, EbmlMaster, path1)) {
            for (var iterator$e = c.children.iterator(); iterator$e.hasNext(); ) {
                var e = iterator$e.next();
                if (e.type.equals(MKVType.SimpleBlock)) {
                    var be = e;
                    System.out.println("offset: " + be.size() + " timecode: " + be.timecode);
                } else if (e.type.equals(MKVType.BlockGroup)) {
                    var path = [MKVType.BlockGroup, MKVType.Block];
                    var be = MKVType.findFirst(e, path);
                    System.out.println("offset: " + be.size() + " timecode: " + be.timecode);
                }
            }
        }
    };
    prototype.printTrackInfo = function() {
        var inputStream = new FileInputStream(this.suite.test1);
        var parser = new MKVParser(new FileChannelWrapper(inputStream.getChannel()));
        var tree = null;
        try {
            tree = parser.parse();
        } finally {
            if (inputStream != null) 
                inputStream.close();
            inputStream = null;
        }
        var path = [MKVType.Segment, MKVType.Cues, MKVType.CuePoint, MKVType.CueTime];
        var tcs = MKVType.findAllTree(tree, EbmlUint, path);
        for (var tc in tcs) 
            System.out.println("CueTime " + tc.getUint() + " " + tc.offset);
    };
    prototype.testMatroskaBytes = function() {
        Assert.assertArrayEquals(new Int8Array([109, 97, 116, 114, 111, 115, 107, 97]), "matroska".getBytes());
    };
    prototype.testEBMLHeaderMuxin = function() {
        var ebmlHeaderElem = MKVType.createByType(MKVType.EBML);
        var docTypeElem = MKVType.createByType(MKVType.DocType);
        docTypeElem.setString("matroska");
        var docTypeVersionElem = MKVType.createByType(MKVType.DocTypeVersion);
        docTypeVersionElem.setUint(1);
        var docTypeReadVersionElem = MKVType.createByType(MKVType.DocTypeReadVersion);
        docTypeReadVersionElem.setUint(1);
        ebmlHeaderElem.add(docTypeElem);
        ebmlHeaderElem.add(docTypeVersionElem);
        ebmlHeaderElem.add(docTypeReadVersionElem);
        var bb = ebmlHeaderElem.getData();
        System.out.println("c: " + bb.capacity() + " p: " + bb.position() + " l: " + bb.limit());
    };
    prototype.testEbmlMasterMuxig = function() {
        var ebmlHeaderElem = MKVType.createByType(MKVType.EBML);
        var docTypeElem = MKVType.createByType(MKVType.DocType);
        docTypeElem.setString("matroska");
        ebmlHeaderElem.add(docTypeElem);
        var bb = ebmlHeaderElem.getData();
        Assert.assertArrayEquals(new Int8Array([26, 69, (223 << 24 >> 24), (163 << 24 >> 24), (139 << 24 >> 24), 66, (130 << 24 >> 24), (136 << 24 >> 24), 109, 97, 116, 114, 111, 115, 107, 97]), bb.array());
    };
    prototype.testEmptyEbmlMasterMuxig = function() {
        var ebmlHeaderElem = MKVType.createByType(MKVType.EBML);
        var bb = ebmlHeaderElem.getData();
        Assert.assertArrayEquals(new Int8Array([26, 69, (223 << 24 >> 24), (163 << 24 >> 24), (128 << 24 >> 24)]), bb.array());
    };
    prototype.setUp = function() {
        this.suite = MKVTestSuite.read();
        if (!this.suite.isSuitePresent()) 
            Assert.fail("MKV test suite is missing, please download from http://www.matroska.org/downloads/test_w1.html, and save to the path recorded in src/test/resources/mkv/suite.properties");
    };
    prototype.copyMuxing = function() {
        var inputStream = new FileInputStream(this.suite.test3);
        var parser = new MKVParser(new FileChannelWrapper(inputStream.getChannel()));
        var tree = null;
        try {
            tree = parser.parse();
        } finally {
            if (inputStream != null) 
                inputStream.close();
            inputStream = null;
        }
        var remuxerInputStream = new FileInputStream(this.suite.test3);
        var os = new FileOutputStream(new File(this.suite.test3.getParent(), "copy-" + this.suite.test3.getName()));
        try {
            var channel = remuxerInputStream.getChannel();
            var path = [MKVType.Segment, MKVType.Cluster, MKVType.SimpleBlock];
            for (var be in MKVType.findAllTree(tree, MkvBlock, path)) {
                var bb = ByteBuffer.allocate(be.dataLen);
                channel.position(be.dataOffset);
                var read = channel.read(bb);
                bb.flip();
                be.readFrames(bb);
            }
            var path1 = [MKVType.Segment, MKVType.Cluster, MKVType.BlockGroup, MKVType.Block];
            for (var be in MKVType.findAllTree(tree, MkvBlock, path1)) {
                var bb = ByteBuffer.allocate(be.dataLen);
                channel.position(be.dataOffset);
                var read = channel.read(bb);
                bb.flip();
                be.readFrames(bb);
            }
            for (var iterator$e = tree.iterator(); iterator$e.hasNext(); ) {
                var e = iterator$e.next();
                e.mux(new FileChannelWrapper(os.getChannel()));
            }
        } finally {
            if (remuxerInputStream != null) 
                remuxerInputStream.close();
            if (os != null) 
                os.close();
        }
    };
    prototype.testName = function() {
        var inputStream = new FileInputStream(this.suite.test3);
        var parser = new MKVParser(new FileChannelWrapper(inputStream.getChannel()));
        var tree = null;
        try {
            tree = parser.parse();
        } finally {
            if (inputStream != null) 
                inputStream.close();
            inputStream = null;
        }
        var path = [MKVType.Segment, MKVType.Cluster];
        var cc = MKVType.findAllTree(tree, EbmlMaster, path);
        this.printCueTable(cc);
    };
    prototype.printCueTable = function(cc) {
        var time = 0;
        var predictedOffset = 0;
        for (var c in cc) {
            var csize = c.size();
            var path = [MKVType.Cluster, MKVType.Timecode];
            System.out.println("cluster " + (MKVType.findFirst(c, path)).getUint() + " size: " + csize + " predOffset: " + predictedOffset);
            var min = MKVMuxerTest.getMinTimecode(c, 1);
            var max = MKVMuxerTest.getMaxTimecode(c, 1);
             while (min <= time && time <= max){
                System.out.println("timecode: " + time + " offset: " + c.offset);
                time += 1000;
            }
            predictedOffset += csize;
        }
    };
    constructor.getMinTimecode = function(c, trackNr) {
        var path = [MKVType.Cluster, MKVType.Timecode];
        var timecode = MKVType.findFirst(c, path);
        var clusterTimecode = timecode.getUint();
        var minTimecode = clusterTimecode;
        for (var iterator$be = MKVMuxerTest.getBlocksByTrackNumber(c, trackNr).iterator(); iterator$be.hasNext(); ) {
            var be = iterator$be.next();
            if (clusterTimecode + be.timecode < minTimecode) 
                minTimecode = clusterTimecode + be.timecode;
        }
        return minTimecode;
    };
    constructor.getMaxTimecode = function(c, trackNr) {
        var path = [MKVType.Cluster, MKVType.Timecode];
        var timecode = MKVType.findFirst(c, path);
        var clusterTimecode = timecode.getUint();
        var maxTimecode = clusterTimecode;
        for (var iterator$be = MKVMuxerTest.getBlocksByTrackNumber(c, trackNr).iterator(); iterator$be.hasNext(); ) {
            var be = iterator$be.next();
            if (clusterTimecode + be.timecode > maxTimecode) 
                maxTimecode = clusterTimecode + be.timecode;
        }
        return maxTimecode;
    };
    constructor.getBlocksByTrackNumber = function(c, nr) {
        var blocks = new ArrayList();
        for (var iterator$child = c.children.iterator(); iterator$child.hasNext(); ) {
            var child = iterator$child.next();
            var block = null;
            if (child.type.equals(MKVType.SimpleBlock)) 
                block = child;
             else if (child.type.equals(MKVType.BlockGroup)) {
                var path = [MKVType.BlockGroup, MKVType.Block];
                block = MKVType.findFirst(child, path);
            } else 
                continue;
            if (block.trackNumber == nr) 
                blocks.add(block);
        }
        return blocks;
    };
    prototype.testBasicMathDivision = function() {
        var framesPerCluster = 25;
        var i = 0;
        Assert.assertEquals(0, i % framesPerCluster);
        i = 25;
        Assert.assertEquals(0, i % framesPerCluster);
        i = 50;
        Assert.assertEquals(0, i % framesPerCluster);
    };
    prototype.testBasicLinkedList = function() {
        var ll = new LinkedList();
        ll.add(1);
        Assert.assertEquals(Integer.valueOf(1), ll.getLast());
        ll.add(2);
        Assert.assertEquals(Integer.valueOf(2), ll.getLast());
        ll.add(3);
        Assert.assertEquals(Integer.valueOf(3), ll.getLast());
    };
    constructor.bufferToArray = function(bb) {
        var ar = new Int8Array(bb.remaining());
        bb.getBuf(ar);
        return ar;
    };
}, {suite: "MKVTestSuite"}, {});
var MKVDemuxerTest = function() {};
MKVDemuxerTest = stjs.extend(MKVDemuxerTest, null, [], function(constructor, prototype) {
    prototype.dem = null;
    prototype.demInputStream = null;
    prototype.par = null;
    prototype.setUp = function() {
        var inputStream = new FileInputStream("./src/test/resources/mkv/10frames.webm");
        this.par = new MKVParser(new FileChannelWrapper(inputStream.getChannel()));
        var t = null;
        try {
            t = this.par.parse();
        } finally {
            IOUtils.closeQuietly(inputStream);
        }
        this.demInputStream = new FileInputStream("./src/test/resources/mkv/10frames.webm");
        this.dem = new MKVDemuxer(t, new FileChannelWrapper(this.demInputStream.getChannel()));
    };
    prototype.tearDown = function() {
        IOUtils.closeQuietly(this.demInputStream);
    };
    prototype.testGetFrame = function() {
        Assert.assertNotNull(this.dem);
        Assert.assertNotNull(this.dem.getVideoTrack());
        var video = this.dem.getVideoTrack();
        var frame = video.nextFrame();
        Assert.assertNotNull(video);
        var vp8Frame = IOUtils.readFileToByteArray(new File("./src/test/resources/mkv/10frames01.vp8"));
        Assert.assertArrayEquals(vp8Frame, MKVMuxerTest.bufferToArray(frame.getData()));
    };
    prototype.testPosition = function() {
        Assert.assertNotNull(this.dem);
        Assert.assertNotNull(this.dem.getVideoTrack());
        var video = this.dem.getVideoTrack();
        video.gotoFrame(1);
        var frame = video.nextFrame();
        Assert.assertNotNull(video);
        var vp8Frame = IOUtils.readFileToByteArray(new File("./src/test/resources/mkv/10frames02.vp8"));
        Assert.assertArrayEquals(vp8Frame, MKVMuxerTest.bufferToArray(frame.getData()));
    };
}, {dem: "MKVDemuxer", demInputStream: "FileInputStream", par: "MKVParser"}, {});
var AudioTrackTest = function() {};
AudioTrackTest = stjs.extend(AudioTrackTest, null, [], function(constructor, prototype) {
    prototype.par = null;
    prototype.demInputStream = null;
    prototype.dem = null;
    prototype.showInterlacedBlocks = false;
    prototype.testSoundSamples = function() {
        var audio = this.dem.getAudioTracks().get(0);
        Assert.assertNotNull(audio);
        audio.gotoFrame(9);
        var p = audio.nextFrame();
        var audioSample = NIOUtils.fetchFromFile(Utils.tildeExpand("./src/test/resources/mkv/test1.audiosample09.mp3"));
        Assert.assertArrayEquals(audioSample.array(), MKVMuxerTest.bufferToArray(p.getData()));
    };
    prototype.testTwoSoundSamples = function() {
        var audio = this.dem.getAudioTracks().get(0);
        Assert.assertNotNull(audio);
        audio.gotoFrame(8);
        var p = audio.getFrames(2);
        var sample08 = IOUtils.readFileToByteArray(Utils.tildeExpand("./src/test/resources/mkv/test1.audiosample08.mp3"));
        var sample09 = IOUtils.readFileToByteArray(Utils.tildeExpand("./src/test/resources/mkv/test1.audiosample09.mp3"));
        var twoSamples = new Int8Array(sample08.length + sample09.length);
        System.arraycopy(sample08, 0, twoSamples, 0, sample08.length);
        System.arraycopy(sample09, 0, twoSamples, sample08.length, sample09.length);
        Assert.assertArrayEquals(twoSamples, p.getData().array());
    };
    prototype.setUp = function() {
        var suite = MKVTestSuite.read();
        if (!suite.isSuitePresent()) 
            Assert.fail("MKV test suite is missing, please download from http://www.matroska.org/downloads/test_w1.html, and save to the path recorded in src/test/resources/mkv/suite.properties");
        var inputStream = new FileInputStream(suite.test1);
        this.par = new MKVParser(new FileChannelWrapper(inputStream.getChannel()));
        var mkv = null;
        try {
            mkv = this.par.parse();
        } finally {
            IOUtils.closeQuietly(inputStream);
        }
        if (this.showInterlacedBlocks) {
            var path = [MKVType.Segment, MKVType.Cluster, MKVType.SimpleBlock];
            var blocks = MKVType.findAllTree(mkv, MkvBlock, path);
            for (var be in blocks) {
                System.out.println("\nTRACK " + be.trackNumber);
                var pref = "";
                if (be.lacingPresent) {
                    pref = "lacing ";
                }
                for (var offset in be.frameOffsets) 
                    System.out.println(pref + "sample offset " + Long.toHexString(offset));
            }
        }
        this.demInputStream = new FileInputStream(suite.test1);
        this.dem = new MKVDemuxer(mkv, new FileChannelWrapper(this.demInputStream.getChannel()));
    };
    prototype.tearDown = function() {
        IOUtils.closeQuietly(this.demInputStream);
    };
}, {par: "MKVParser", demInputStream: "FileInputStream", dem: "MKVDemuxer"}, {});
var MKVFrameReadingTest = function() {};
MKVFrameReadingTest = stjs.extend(MKVFrameReadingTest, null, [], function(constructor, prototype) {
    constructor.suite = null;
    constructor.outPattern = "/tmp/frame%d.png";
    prototype.par = null;
    prototype.dem = null;
    prototype.demInputStream = null;
    prototype.test = function() {
        var decoder = new H264Decoder();
        var transform = new Yuv420pToRgb8Bit();
        var inTrack = this.dem.getVideoTrack();
        var rgb = Picture8Bit.create(this.dem.getPictureWidth(), this.dem.getPictureHeight(), ColorSpace.RGB);
        var bi = new BufferedImage(this.dem.getPictureWidth(), this.dem.getPictureHeight(), BufferedImage.TYPE_3BYTE_BGR);
        var avcC = AvcCBox.parseAvcCBox((inTrack).getCodecState());
        decoder.addSps(avcC.getSpsList());
        decoder.addPps(avcC.getPpsList());
        var inFrame;
        for (var i = 1; (inFrame = inTrack.nextFrame()) != null && i <= 200; i++) {
            var buf = Picture8Bit.create(this.dem.getPictureWidth(), this.dem.getPictureHeight(), ColorSpace.YUV422);
            var pic = decoder.decodeFrame8BitFromNals(H264Utils.splitMOVPacket(inFrame.getData(), avcC), buf.getData());
            if (bi == null) 
                bi = new BufferedImage(pic.getWidth(), pic.getHeight(), BufferedImage.TYPE_3BYTE_BGR);
            if (rgb == null) 
                rgb = Picture8Bit.create(pic.getWidth(), pic.getHeight(), ColorSpace.RGB);
            transform.transform(pic, rgb);
            AWTUtil.toBufferedImage8Bit2(rgb, bi);
            ImageIO.write(bi, "png", new File(String.format(MKVFrameReadingTest.outPattern, i++)));
        }
    };
    prototype.testFirstFrame = function() {
        var transform = new Yuv420pToRgb8Bit();
        var decoder = new H264Decoder();
        var inTrack = this.dem.getVideoTrack();
        var avcC = AvcCBox.parseAvcCBox((inTrack).getCodecState());
        Assert.assertNotNull(avcC.getSpsList());
        Assert.assertFalse(avcC.getSpsList().isEmpty());
        Assert.assertNotNull(avcC.getPpsList());
        Assert.assertFalse(avcC.getPpsList().isEmpty());
        decoder.addSps(avcC.getSpsList());
        decoder.addPps(avcC.getPpsList());
        var inFrame = inTrack.nextFrame();
        Assert.assertNotNull(inFrame);
        var bb = inFrame.getData();
        Assert.assertNotNull(bb);
        var file = new File(MKVFrameReadingTest.suite.base, "test5_frame0.h264");
        var rawFrame = IOUtils.readFileToByteArray(file);
        Assert.assertArrayEquals(rawFrame, MKVMuxerTest.bufferToArray(bb));
        var buf = Picture8Bit.create(this.dem.getPictureWidth(), this.dem.getPictureHeight(), ColorSpace.YUV422);
        var pic = decoder.decodeFrame8BitFromNals(H264Utils.splitMOVPacket(inFrame.getData(), avcC), buf.getData());
        var rgb = Picture8Bit.create(this.dem.getPictureWidth(), this.dem.getPictureHeight(), ColorSpace.RGB);
        var bi = new BufferedImage(this.dem.getPictureWidth(), this.dem.getPictureHeight(), BufferedImage.TYPE_3BYTE_BGR);
        transform.transform(pic, rgb);
        AWTUtil.toBufferedImage8Bit2(rgb, bi);
        var f = new File(String.format(MKVFrameReadingTest.outPattern, 0));
        System.out.println("Writing to file: " + f.getAbsolutePath());
        ImageIO.write(bi, "png", f);
    };
}, {suite: "MKVTestSuite", par: "MKVParser", dem: "MKVDemuxer", demInputStream: "SeekableByteChannel"}, {});
var CompareFramesTest = function() {};
CompareFramesTest = stjs.extend(CompareFramesTest, null, [], function(constructor, prototype) {
    prototype.testReadFrames = function() {
        var rawFrame = IOUtils.readFileToByteArray(new File("src/test/resources/mkv/single-frame01.vp8"));
        var channel = new FileInputStream("src/test/resources/mkv/single-frame.webm").getChannel();
        var p = new MKVParser(new FileChannelWrapper(channel));
        var tree = p.parse();
        var path = [MKVType.Segment, MKVType.Cluster];
        var me = MKVType.findAllTree(tree, EbmlMaster, path);
        Assert.assertNotNull(me);
        Assert.assertEquals(1, me.length);
        var bs = MKVMuxerTest.getBlocksByTrackNumber(me[0], 1);
        Assert.assertNotNull(bs);
        Assert.assertEquals(1, bs.size());
        var videoBlock = bs.get(0);
        var source = ByteBuffer.allocate(((videoBlock.size()) | 0));
        channel.position(videoBlock.dataOffset);
        channel.read(source);
        source.flip();
        var frames = videoBlock.getFrames(source);
        var byteBuffer = frames[0];
        var frameBytes = MKVMuxerTest.bufferToArray(byteBuffer);
        Assert.assertNotNull(frames);
        Assert.assertEquals(1, frames.length);
        Assert.assertArrayEquals(rawFrame, frameBytes);
    };
    prototype.testFramesByTrack = function() {
        var c = new FileInputStream("src/test/resources/mkv/single-frame.webm").getChannel();
        try {
            var p = new MKVParser(new FileChannelWrapper(c));
            var tree = p.parse();
            var path = [MKVType.Segment, MKVType.Cluster];
            var me = MKVType.findAllTree(tree, EbmlMaster, path);
            Assert.assertNotNull(me);
            Assert.assertEquals(1, me.length);
            var bs = MKVMuxerTest.getBlocksByTrackNumber(me[0], 1);
            Assert.assertNotNull(bs);
            Assert.assertEquals(1, bs.size());
        } finally {
            IOUtils.closeQuietly(c);
        }
    };
}, {}, {});
//# sourceMappingURL=jcodec.map
var f = new File("hello.txt")

console.log(f);
console.log(System.currentTimeMillis());

var start = System.currentTimeMillis();
var conf = new PerformanceTest();
console.log(conf);
conf.testNoContainer();
var time = System.currentTimeMillis() - start;
console.log("ConformanceTest.testNoContainer ok "+time+" msec");

process.exit(0)
